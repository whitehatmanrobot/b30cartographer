( );			//@cmember Get top AE
	virtual HRESULT Done();							//@cmember Commit AEs
	virtual void Discard();							//@cmember Discard AEs
	virtual void StartGroupTyping();				//@cmember Start GT
	virtual void StopGroupTyping();					//@cmember Stop GT

	CGenUndoBuilder(CTxtEdit *ped, DWORD flags,		//@cmember Constructor
					IUndoBuilder **ppubldr = NULL);
	~CGenUndoBuilder( );							//@cmember Destructor

	// IReEntrantComponent methods
	virtual void OnEnterContext() {;}				//@cmember Reentered notify

//@access	Private methods
private:
	IUndoBuilder *	_publdrPrev;					//@cmember Ptr to undobldr
													//		   higher in stack
	IUndoMgr *		_pundo;							//@cmember Ptr to undo mgr
	CTxtEdit *		_ped;							//@cmember Ptr to edit contxt
	UNDONAMEID		_idName;						//@cmember Current name
	IAntiEvent *	_pfirstae;						//@cmember AE list
	UINT			_fAutoCommit:1;					//@cmember AutoCommit on?
	UINT			_fStartGroupTyping:1;			//@cmember GroupTyping on?
	UINT			_fRedo:1;						//@cmember UB destination is
													//		   the redo stack
	UINT			_fDontFlushRedo:1;				//@cmember Don't flush redo
													//	stack; i.e. we are
													//	invoking a redo action
	UINT			_fInactive:1;					//@cmember TRUE if undo enabled
};

/*
 *	CUndoStackGuard
 *
 *	@class
 *		A stack based class which helps manage reentrancy for the undo stack
 */
class CUndoStackGuard : public IReEntrantComponent
{
//@access	Public Methods
public:
	virtual void OnEnterContext();					//@cmember reentered notify

	CUndoStackGuard(CTxtEdit *ped);					//@cmember Constructor
	~CUndoStackGuard();								//@cmember Destructor
													//@cmember Execute the undo
	HRESULT SafeUndo(IAntiEvent *pae, IUndoBuilder *publdr);// actions in <p pae>
	BOOL	WasReEntered()  {return _fReEntered;}	//@cmember Return reentered flag 

//@access	Private Data
private:
	CTxtEdit *				_ped;					//@cmember Edit context
	volatile IAntiEvent *	_paeNext;				//@cmember Antievent loop ptr
	volatile HRESULT		_hr;					//@cmember Cached hr
	IUndoBuilder *			_publdr;				//@cmember Undo/redo context
	BOOL					_fReEntered;			//@cmember Have we been
};													//		   been reentered?

// Helper Functions. 

// Loop through a chain of antievents and destroy them
void DestroyAEList(IAntiEvent *pae);

// Loop through a chain of antievents and call OnCommit
void CommitAEList(CTxtEdit *ped, IAntiEvent *pae);

// Handles merging and/or creation of selection antievent info
HRESULT HandleSelectionAEInfo(CTxtEdit *ped, IUndoBuilder *publdr, 
			LONG cp, LONG cch, LONG cpNext, LONG cchNext, SELAE flags);

#endif // !__M_UNDO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_rtflog.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFLOG.H -- RichEdit RTF Log Class Definition |
 *
 *		This file contains the class declarations for an RTF log class
 *		which can be used to track the hit counts of RTF tags encountered
 *		by the RTF reader
 *
 *	Authors:<nl>
 *		Created for RichEdit 2.0:	Brad Olenick 
 *
 *	Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */
#ifndef __RTFLOG_H
#define __RTFLOG_H

#include "tokens.h"	

extern INT cKeywords;

class CRTFLog
{
public:
	typedef size_t INDEX;
	typedef INDEX *PINDEX;
	typedef DWORD ELEMENT;
	typedef ELEMENT *PELEMENT;

	CRTFLog();				//@cmember CRTFLog constructor
	inline ~CRTFLog();		//@cmember CRTFLog destructor

	BOOL FInit() const 
		{ return _rgdwHits ? TRUE : FALSE; }	//@cmember Determines whether object is init'd

	INDEX ISize() const 
		{ return cKeywords; }			//@cmember Number of elements in log

	inline BOOL AddAt(INDEX i);					//@cmember Increment hit count for element at index i
	inline BOOL AddAt(LPCSTR lpcstrKeyword);	//@cmember Increment hit count for RTF keyword 	
	inline BOOL AddAt(TOKEN token);				//@cmember Increment hit count for RTF token

	inline ELEMENT GetAt(INDEX i) const
		{ return (*this)[i]; }											//@cmember Get hit count for element i
	inline BOOL GetAt(LPCSTR lpcstrKeyword, PELEMENT pelemCount) const;	//@cmember Get hit count for RTF keyword
	inline BOOL GetAt(TOKEN token, PELEMENT pelemCount) const;			//@cmember Get hit count for RTF token

	void Reset();						//@cmember Reset all hit count values to 0

	UINT UGetWindowMsg() const;			//@cmember Get window msg ID used for log change notifications

private:
	// we manage all updates through AddAt to 
	// facilitate change notifications
	ELEMENT &operator[](INDEX);				//@cmember Access element i for l-value
	const ELEMENT &operator[](INDEX) const;	//@cmember Access element i for r-value

	LPCSTR LpcstrLogFilename() const;	//@cmember Get name of log filename

	BOOL IIndexOfKeyword(LPCSTR lpcstrKeyword, PINDEX pi) const;	//@cmember Get log index for keyword
	BOOL IIndexOfToken(TOKEN token, PINDEX pi) const;				//@cmember Get log index for token

	void ChangeNotify(INDEX i) const
		{ 
			PostMessage(HWND_BROADCAST, UGetWindowMsg(), i, 0);
		}	//@cmember Notify clients of change to element i
	void ChangeNotifyAll() const 
		{ ChangeNotify(ISize() + 1); }						//@cmember Notify clients of log refresh

	HANDLE _hfm;		//@cmember Handle to file mapping
	HANDLE _hfile;		//@cmember Handle to file behind file mapping
	PELEMENT _rgdwHits;	//@cmember Handle to view of file mapping
	UINT _uMsg;			//@cmember Window msg ID for change notifications
};


/*
 *	CRTFLog::~CRTFLog
 *	
 *	@mfunc
 *		Destructor - cleans up memory-mapped file and underlying resources
 *
 */
inline CRTFLog::~CRTFLog()
{
	if(_rgdwHits)
	{
		UnmapViewOfFile(_rgdwHits);
	}

	if(_hfm)
	{
		CloseHandle(_hfm);
	}

	if(_hfile)
	{
		CloseHandle(_hfile);
	}
}


/*
 *	CRTFLog::AddAt(INDEX i)
 *	
 *	@mfunc
 *		Increments the hit count for log element, i, and
 *		notifies clients of the change
 *
 *	@rdesc
 *		BOOL			whether the increment was successful
 */
inline BOOL CRTFLog::AddAt(INDEX i)
{
	(*this)[i]++;

	// change notification
	ChangeNotify(i);

	return TRUE;
}


/*
 *	CRTFLog::AddAt(LPCSTR lpcstrKeyword)
 *	
 *	@mfunc
 *		Increments the hit count for log element corresponding
 *		to the RTF keyword, lpcstrKeyword, and 
 *		notifies clients of the change
 *
 *	@rdesc
 *		BOOL			whether the increment was successful
 */
inline BOOL CRTFLog::AddAt(LPCSTR lpcstrKeyword)
{
	INDEX i;

	if(!IIndexOfKeyword(lpcstrKeyword, &i))
	{
		return FALSE;
	}

	return AddAt(i);
}


/*
 *	CRTFLog::AddAt(TOKEN token)
 *	
 *	@mfunc
 *		Increments the hit count for log element corresponding
 *		to the RTF token, token, and 
 *		notifies clients of the change
 *
 *	@rdesc
 *		BOOL			whether the increment was successful
 */
inline BOOL CRTFLog::AddAt(TOKEN token)
{
	INDEX i;

	if(!IIndexOfToken(token, &i))
	{
		return FALSE;
	}

	return AddAt((INDEX)i);
}


/*
 *	CRTFLog::GetAt(LPCSTR lpcstKeyword, PELEMENT pelemCount)
 *	
 *	@mfunc
 *		Gets the hit count for log element corresponding to the
 *		RTF keyword, lpcstrKeywor
 *
 *	@rdesc
 *		BOOL		indicates whether a hit count was found for the element
 */
inline BOOL CRTFLog::GetAt(LPCSTR lpcstrKeyword, PELEMENT pelemCount) const
{
	INDEX i;
	
	if(!IIndexOfKeyword(lpcstrKeyword, &i))
	{
		return FALSE;
	}

	if(pelemCount)
	{
		*pelemCount = (*this)[i];
	}

	return TRUE;
}
	

/*
 *	CRTFLog::GetAt(LPCSTR lpcstKeyword, PELEMENT pelemCount)
 *	
 *	@mfunc
 *		Gets the hit count for log element corresponding to the
 *		RTF token, token
 *
 *	@rdesc
 *		BOOL		indicates whether a hit count was found for the element
 */
inline BOOL CRTFLog::GetAt(TOKEN token, PELEMENT pelemCount) const
{
	INDEX i;
	
	if(!IIndexOfToken(token, &i))
	{
		return FALSE;
	}

	if(pelemCount)
	{
		*pelemCount = (*this)[i];
	}

	return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_osdc.h ===
/*	@doc INTERNAL
 *
 *	@module _OSDC.H  Off Screen DC class |
 *	
 *	Define class for off screen DC
 *
 *	Original Author: <nl>
 *		Ricksa
 *
 *	History: <nl>
 *		1/11/96	ricksa	Created
 *
 *	Copyright (c) 1996-1998, Microsoft Corporation. All rights reserved.
 */
#ifndef __OSDC_H__
#define __OSDC_H__

/*
 *	COffscreenDC
 *	
 * 	@class	The COffscreenDC is a helper that creates, fills and destroys
 *			an off screen DC and its bitmaps.
 *
 */
class COffscreenDC
{
//@access Public Methods
public:
									//@cmember Constructor - create null object.
				COffscreenDC()		{_hdc = NULL;}

									//@cmember Destructor - clean up allocated 
									// resources if any.
				~COffscreenDC()		{FreeData();}
	
									//@cmember Initialize data based on input DC
	HDC			Init(HDC hdc, LONG xWidth, LONG yHeight, COLORREF crBackground);

									//@cmember Get DC for offscreen rendering
	HDC			GetDC()		{return _hdc;}
	void		GetDimensions(LONG *pdxp, LONG *pdyp);//@cmember the dimensions of the bitmap
									//@cmember Fill bitmap associated with off
									// screen rendering with background color.
	void		FillBitmap(LONG dxp, LONG dyp);

									//@cmember Render off screen bitmap to hdc
	void		RenderBitMap(HDC hdc, LONG xLeft, LONG yTop, LONG xWidth, LONG yHeight);

									//@cmember Get a copy of a bitmap from hdc
	BOOL		Get(HDC hdc, LONG xLeft, LONG yTop, LONG xWidth, LONG yHeight);

									//@cmember Reallocate bitmap for render
	BOOL		Realloc(LONG xWidth, LONG yHeight);

									//@cmember Select in a palette
	void		SelectPalette(HPALETTE hpa);

//@access Private Methods
private:
									//@cmember Free all data associated with object
	void		FreeData();

//@access Private Data 
private:
	HDC			_hdc;		//@cmember HDC for off screen DC
	HBITMAP		_hbmpOld;	//@cmember bitmap when DC created
	HBITMAP		_hbmp;		//@cmember compatible bitmap for render
	HPALETTE	_hpalOld;	//@cmember palette used by DC
};

/*
 *	COffscreenDC::FillBitmap (xWidth, yHeight)
 *
 *	@mfunc	
 *		Fill bitmap
 */
inline void COffscreenDC::FillBitmap(
	LONG dxp,		//@parm Width to fill with background color
	LONG dyp)		//@parm height to fill with background color
{
	// Erase background
	RECT rcClient;
	rcClient.top = rcClient.left = 0;
	rcClient.right = dxp;
	rcClient.bottom = dyp;
	ExtTextOut(_hdc, 0, 0, ETO_OPAQUE, &rcClient, NULL, 0, NULL);
}

/*
 *	COffscreenDC::RenderBitMap(hdc, xLeft, yTop, xWidth, yHeight)
 *
 *	@mfunc	
 *		Render bitmap to input DC
 */
inline void COffscreenDC::RenderBitMap(
	HDC  hdc,			//@parm HDC to render to
	LONG xLeft,			//@parm left position to start render
	LONG yTop,			//@parm top top position to start render
	LONG xWidth,		//@parm width to render
	LONG yHeight)		//@parm height to render
{
	BitBlt(hdc, xLeft, yTop, xWidth, yHeight, _hdc, 0, 0, SRCCOPY);
}
	
/*
 *	COffscreenDC::Get(hdc, xLeft, yTop, xWidth, yHeight)
 *
 *	@mfunc	
 *		Get a copy of a bitmap from another DC
 *
 *	@rdesc
 *		TRUE - succeeded
 *		FALSE - Failed
 */
inline BOOL COffscreenDC::Get(
	HDC  hdc,			//@parm HDC to copy from
	LONG xLeft,			//@parm left position of source bitmap
	LONG yTop,			//@parm top top position of source bitmap
	LONG xWidth,		//@parm width of bitmap
	LONG yHeight)		//@parm height to bitmap
{
	return BitBlt(_hdc, 0, 0, xWidth, yHeight, hdc, xLeft, yTop, SRCCOPY);
}

#endif __OSDC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_objmgr.h ===
/*
 *  @doc    INTERNAL
 *
 *  @module _objmgr.h   Class declaration for the object manager class |
 *
 *  Author: alexgo 11/4/95
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */
#ifndef __OBJMGR_H__
#define __OBJMGR_H__

#include "_coleobj.h"
#include "_array.h"
#include "_m_undo.h"

class CTxtEdit;
class CTxtRange;

/*
 *	@enum	return values for HandleClick
 */	
enum ClickStatus
{
	CLICK_IGNORED			= 0,
	CLICK_OBJDEACTIVATED	= 1,
	CLICK_SHOULDDRAG		= 2,
	CLICK_OBJSELECTED		= 3
};

typedef CArray<COleObject *> ObjectArray;

/*
 *	CObjectMgr
 *
 *	@class	keeps track of a collection of OLE embedded objects as well as
 *			various state tidbits
 */
class CObjectMgr
{
public:
	LONG			GetObjectCount(); 			//@cmember count # of objects 
	LONG			GetLinkCount();				//@cmember count # of links
	COleObject *	GetObjectFromCp(LONG cp);	//@cmember fetch object ptr
	COleObject *	GetObjectFromIndex(LONG index); //@cmember fetch obj ptr
												//@cmember insert object
	HRESULT			InsertObject(CTxtRange *prg, REOBJECT *preobj, 
						IUndoBuilder *publdr);
												//@cmember re-inserts the given
												// object
	HRESULT			RestoreObject(COleObject *pobj);

	IRichEditOleCallback *GetRECallback()		//@cmember return the callback
					{return _precall;}
												//@cmember set the OLE callback
	void			SetRECallback(IRichEditOleCallback *precall);			
												//@cmember sets a temporary flag
												// indicating whether or not
												// a UI update is pending.
	void			SetShowUIPending(BOOL fPending)
												{_fShowUIPending = fPending;}

	BOOL			GetShowUIPending()			//@cmember get _fShowUIPending
												{return _fShowUIPending;}
										   		//@cmember sets the inplace
												// active object
	void			SetInPlaceActiveObject(COleObject *pobj)
												{ _pobjactive = pobj; }
	COleObject *	GetInPlaceActiveObject()	//@cmember get the active obj
												{ return _pobjactive; }
	BOOL			GetHelpMode()				//@cmember in help mode?
												{ return _fInHelpMode; }
	void			SetHelpMode(BOOL fHelp)		//@cmember set the help mode
												{ _fInHelpMode = fHelp; }
												//@cmember Set the host names
	HRESULT			SetHostNames(LPWSTR pszApp, LPWSTR pszDoc);
	LPWSTR			GetAppName()				//@cmember get the app name
												{ return _pszApp; }
	LPWSTR			GetDocName()				//@cmember get the doc name
												{ return _pszDoc; }
												//@cmember activate an object
												//if appropriate
	BOOL			HandleDoubleClick(CTxtEdit *ped, const POINTUV &pt, DWORD flags);
												//@cmember an object may be
												// selected or de-activated.
	ClickStatus		HandleClick(CTxtEdit *ped, const POINTUV &pt);
												//@cmember an object may be
												// selected or deselected.
	void			HandleSingleSelect(CTxtEdit *ped, LONG cp, BOOL fHiLite);
												//@cmember an object is
												// being selected by itself.
	COleObject *	GetSingleSelect(void)		{return _pobjselect;}
												//@cmember Count cObject
	LONG			CountObjects(LONG& rcObject,// objects up to cchMax
						LONG cp);				// chars away

												//@cmember Handles the deletion
												// of objects.
	void			ReplaceRange(LONG cp, LONG cchDel,
						IUndoBuilder *publdr);
												//@cmember Count the number
												//of objects in a range.
	LONG			CountObjectsInRange(LONG cpMin, LONG cpMost);
												//@cmember Get the first
												//object in a range.
	COleObject *	GetFirstObjectInRange(LONG cpMin, LONG cpMost);
								//@cmember activate objects of one class as
								//as another
	HRESULT ActivateObjectsAs(REFCLSID rclsid, REFCLSID rclsidAs);

	LONG FindIndexForCp(LONG cp);	//@cmember does a binary search for cp
									//@cmember find an object near a point

#ifdef DEBUG
	void			DbgDump(void);
#endif

	CObjectMgr();								//@cmember constructor
	~CObjectMgr();								//@cmember destructor

private:
	ObjectArray		_objarray;		//@cmember	Array of embedded objects
	LONG			_lastindex;		//@cmember	Last index used 
									// (lookup optimization)
	IRichEditOleCallback *_precall;	//@cmember	Callback for various OLE 
									// operations.
	COleObject *	_pobjactive;	//@cmember	Object that is currently
									// inplace active 
	COleObject *	_pobjselect;	//@cmember	Object that is currently
									// individually selected (not active)
	LPWSTR		_pszApp;			//@cmember 	Name of app
	LPWSTR		_pszDoc;			//@cmember 	Name of "document"

	unsigned int	_fShowUIPending:1;//@cmember a UI update is pending
	unsigned int	_fInHelpMode:1;	//@cmember in context sensitive help mode?
};

#endif  //__OBJMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_rtext.h ===
/*
 *	_RTEXT.H
 *	
 *	Purpose:
 *		Base classes for rich-text manipulation
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 */

#ifndef _RTEXT_H
#define _RTEXT_H

#include "_edit.h"
#include "_array.h"
#include "_doc.h"
#include "_text.h"
#include "_runptr.h"
#include "_frunptr.h"
#include "_notmgr.h"



//#pragma warning(disable: 4250)	

#define yHeightCharMost	32760

class CTxtEdit;
class CTxtRange;
class CRchTxtPtr;

// ReplaceRange's flags
enum
{
	RR_ITMZ_NOUNICODEBIDI	= 0,
	RR_ITMZ_UNICODEBIDI		= 1,
	RR_ITMZ_NONE			= 2,

	RR_UNLINK				= 8,
	RR_UNHIDE				= 16,
	RR_NO_TRD_CHECK			= 32,
	RR_NO_LP_CHECK			= 64,
	RR_NO_CHECK_TABLE_SEL	= 128,
	RR_NEW_CHARS			= 256
};

extern BOOL IsWhiteSpace(unsigned ch);

// ==============================  CRchTxtPtr  =====================================================
// Keeps physical positions corresponding to text character position (cp)
// within current text block, formatting runs, objects, unknown RTF runs,
// and floating ranges.

class CRchTxtPtr : public ITxNotify
{
public:

#ifdef DEBUG
    BOOL Invariant( void ) const;
	int	 m_InvariantCheckInterval;
	LONG GetParaNumber() const;
#endif  // DEBUG

	CTxtPtr			_rpTX;		// rp in the plain text array
	CFormatRunPtr	_rpCF;		// rp in character format runs
	CFormatRunPtr	_rpPF;		// rp in paragraph format runs

// Useful constructors

	CRchTxtPtr(CTxtEdit *ped);
	CRchTxtPtr(CTxtEdit *ped, LONG cp);
	CRchTxtPtr(const CRchTxtPtr& rtp);
	CRchTxtPtr(const CDisplay * pdp);

	virtual CRchTxtPtr& operator =(const CRchTxtPtr& rtp)
	{
		_rpTX._ped = rtp._rpTX._ped;
		SetCp(rtp.GetCp());
		return *this;
	}

	LONG 	Move(LONG cch);
	LONG	AdvanceCRLF();
	LONG	BackupCRLF(BOOL fDiacriticCheck = TRUE);
#ifndef NOCOMPLEXSCRIPTS
	LONG	SnapToCluster(INT iDirection = 0);
#endif
	LONG	SetCp( LONG cp);
	void	BindToCp(LONG cp);
	void	CheckFormatRuns();
	LONG	GetCp() const			{ return _rpTX.GetCp(); }
	LONG	GetTextLength() const	{ return _rpTX.GetTextLength(); }
	LONG	GetObjectCount() const	{ return GetPed()->GetObjectCount(); }
	CTxtEdit *GetPed() const		{ return _rpTX._ped; }
	const WCHAR * GetPch(LONG &cchvalid) { return _rpTX.GetPch(cchvalid); }
	WCHAR 	GetChar()				{ return _rpTX.GetChar(); }
	WCHAR 	GetPrevChar()			{ return _rpTX.GetPrevChar(); }
	LONG	GetPlainText(LONG cchBuff, WCHAR *pch, LONG cpMost, BOOL fTextize, BOOL fUseCRLF);
	void	ValidateCp(LONG &cp) const;
	LONG	GetCachFromCch(LONG cch);
	LONG	GetCchFromCach(LONG cach);

	// Text manipulation methods

	// Range operations
	LONG	ReplaceRange(LONG cchOld, LONG cchNew, WCHAR const *pch,
						 IUndoBuilder *publdr, LONG iFormat,
						 LONG *pcchMove = NULL, DWORD dwFlags = 0);
	BOOL 	ItemizeReplaceRange(LONG cchUpdate, LONG cchMove,
						IUndoBuilder *publdr, BOOL fUnicodeBidi = FALSE);
	BOOL	ChangeCase(LONG cch, LONG Type, IUndoBuilder *publdr);
	LONG	UnitCounter (LONG iUnit, LONG &	cUnit, LONG cchMax, BOOL fNotAtBOL = FALSE);
	void	ExtendFormattingCRLF();
	LONG	ExpandRangeFormatting(LONG cchRange, LONG cchMove, LONG& cchAdvance);

	// Search and word-break support
	LONG	FindText(LONG cpMax, DWORD dwFlags, WCHAR const *pch,
					 LONG cchToFind);
	LONG	FindWordBreak(INT action, LONG cpMost = -1);

	// Text-run management
	LONG 	GetIchRunCF();
	LONG	GetIchRunPF();
	LONG 	GetCchRunCF();
	LONG 	GetCchLeftRunCF();
	LONG 	GetCchLeftRunPF();
	
	// Character & paragraph format retrieval
	const CCharFormat* GetCF() const;
	const CParaFormat* GetPF() const;
	LONG	Get_iCF();						//@cmember Get CF index
	LONG	Get_iPF();						//@cmember Get PF index

	BOOL	IsCollapsed() const	{return (GetPF()->_wEffects & PFE_COLLAPSED) != 0;}
	BOOL	IsHidden() const	{return (GetCF()->_dwEffects & CFE_HIDDEN)   != 0;}
	BOOL	InTable() const		{return (GetPF()->_wEffects & PFE_TABLE)     != 0;}
	BOOL	IsParaRTL() const	{return (GetPF()->_wEffects & PFE_RTLPARA)   != 0;}

    // ITxNotify methods
    virtual void    OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
    					LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData ) { ; }
	virtual void 	OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
						LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData ) { ; }
	virtual void	Zombie();

	BOOL	Check_rpCF();
	BOOL	Check_rpPF();

protected:
	void	InitRunPtrs();
	BOOL	IsRich();
	bool  	fUseUIFont() const {return GetPed()->fUseUIFont();}
	BOOL	IsInOutlineView() const {return GetPed()->IsInOutlineView();}
	void	SetRunPtrs(LONG cp, LONG cpFrom);

private:
	LONG	ReplaceRangeFormatting(LONG cchOld, LONG cchNew, LONG iFormat,
							IUndoBuilder *publdr,
							IAntiEvent **ppaeCF, IAntiEvent **ppaePF,
							LONG cchMove, LONG cchPrevEOP, LONG cchNextEOP,
							LONG cchSaveBefore = 0, LONG cchSaveAfter = 0);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_range.h ===
/*
 *	@doc
 *
 *	@module _RANGE.H -- CTxtRange Class |
 *	
 *		This class implements the internal text range and the TOM ITextRange
 *	
 *	Authors: <nl>
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *		Alex Gounares (floating ranges, etc.)
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _RANGE_H
#define _RANGE_H

#include "_text.h"
#include "_m_undo.h"
#include "_rtext.h"
#include "_edit.h"
#include "_uspi.h"

long	FPPTS_TO_TWIPS(float x);
#define TWIPS_TO_FPPTS(x) (((float)(x)) * (float)0.05)

class CTxtEdit;
class CTxtFont;

/*
 *	SELRR
 *
 *	@enum	flags used to control how ReplaceRange (RR) should generate
 *			selection anti-events
 */
enum SELRR
{
	SELRR_IGNORE		= 0,
    SELRR_REMEMBERRANGE = 1,
    SELRR_REMEMBERCPMIN = 2,
    SELRR_REMEMBERENDIP = 3
};

/*
 *	FINDWORD_TYPE
 *
 *	@enum	defines the different cases for finding a word
 */
enum FINDWORD_TYPE {
	FW_EXACT	= 1,		//@emem	Finds the word exactly (no extra chars)
	FW_INCLUDE_TRAILING_WHITESPACE = 2,	//@emem find the word plus the 
							// following whitespace (ala double-clicking)
};

enum MOVES
{
	MOVE_START = -1,
	MOVE_IP = 0,
	MOVE_END = 1,
};

enum MATCHES
{
	MATCH_UNTIL = 0,
	MATCH_WHILE = 1
};

enum EOPADJUST
{
	NONEWCHARS = 0,
	NEWCHARS = 1
};

enum PROTECT 
{
	PROTECTED_YES,
	PROTECTED_NO,
	PROTECTED_ASK 
};

enum CHECKPROTECT
{
	CHKPROT_BACKWARD = -1,
	CHKPROT_EITHER, 
	CHKPROT_FORWARD, 
	CHKPROT_TOM
};

// Substring's input flags
#define SUBSTR_INSPANCHARSET		1
#define SUBSTR_INSPANBLOCK			2

// Substring's output charflags
#define SUBSTR_OUTCCLTR				1
#define SUBSTR_OUTCCRTL				2

enum CSCONTROL
{
	CSC_NORMAL,
	CSC_SNAPTOCLUSTER,
	CSC_NOMULTICHARBACKUP
};

class CCharFlags
{
public:
	BYTE	_bFirstStrong;			// flag for first strong character
	BYTE	_bContaining;			// flags for all presented characters
};


#define	SCF_IGNORESELAE	 0x80000000
#define SCF_IGNORENOTIFY 0x40000000	// use it with real caution! Caller must do it itself.

/*
 *	CTxtRange
 *	
 * 	@class
 *		The CTxtRange class implements RichEdit's text range, which is the
 *		main conduit through which changes are made to the document.
 *		The range inherits from the rich-text ptr, adding a signed length
 *		insertion-point char-format index, and a ref count for use when
 *		instantiated as a TOM ITextRange.  The range object also contains
 *		a flag that reveals whether the range is a selection (with associated
 *		screen behavior) or just a simple range.  This distinction is used
 *		to simplify some of the code.
 *
 *		Some methods are virtual to allow CTxtSelection objects to facilitate
 *		UI features and selection updating.
 *
 *		See tom.doc for lots of discussion on range and selection objects and
 *		on all methods in ITextRange, ITextSelection, ITextFont, and ITextPara.
 */
class CTxtRange : public ITextSelection, public CRchTxtPtr
{
	friend CTxtFont;

//@access Protected Data
protected:
	LONG	_cch;			//@cmember # chars in range. _cch > 0 for active
							//			end at range end (cpMost)
	LONG	_cRefs;			//@cmember ITextRange/ITextSelection ref count

	short	_iFormat;		//@cmember Character format for degenerate range

	union
	{
	  WORD _wFlags;			// All together now
	  struct
	  {
		WORD  _nSelExpandLevel:4;//@cmember Table level to expand to
		WORD  _fSel :1;			//@cmember True iff this is a CTxtSelection
		WORD  _fDragProtection :1;	//@cmember True is this range should think
								//	it's protected.  Set by drag/drop code
		WORD  _fDontUpdateFmt:1;//@cmember Don't update _iFormat
		WORD  _fDualFontMode:1;	//@cmember Set during dual font mode
		WORD  _fUseiFormat:1;	//@cmember Use iFormat when replacing 
								// a non-degenerate range
		WORD  _fMoveBack:1;		//@cmember TRUE if last change moved backward
		WORD  _fSelHasEOP:1;	//@cmember TRUE if Sel has EOP
		WORD  _fSelExpandCell:1;//@cmember TRUE if Sel has CELL but no TRDs at level
		WORD  _fUseBackwardPFFmt:1;	//@cmember Use backward PF format
	  };
	};

//@access Public methods
public:

#ifdef DEBUG
	BOOL	Invariant( void ) const;
	BOOL	IsOneEndUnHidden() const;
#endif // DEBUG

	CTxtRange(const CTxtRange &rg);
	CTxtRange(CTxtEdit *ped, LONG cp = 0, LONG cch = 0);
	CTxtRange(CRchTxtPtr &rtp, LONG cch = 0);
	virtual	~CTxtRange();

	virtual CRchTxtPtr& 	operator =(const CRchTxtPtr &rtp);
	virtual CTxtRange&		operator =(const CTxtRange &rg);

	// ITxNotify methods
										//@cmember Handles notifications
	virtual void OnPreReplaceRange(		//  prior to ReplaceRange calls
				LONG cp, LONG cchDel, LONG cchNew,
				LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData);
										//@cmember Handles notifications for
	virtual void OnPostReplaceRange(	//  floating range and display updates
				LONG cp, LONG cchDel, LONG cchNew,
				LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData);
	virtual	void Zombie();				//@cmember Convert range into zombie

	void	SetIgnoreFormatUpdate(BOOL fUpdate) { _fDontUpdateFmt = fUpdate; }

	void	SetDualFontMode(BOOL fDualFontMode) {_fDualFontMode = fDualFontMode; }

	// Internal cp/cch methods
    LONG 	GetCch (void) const			//@cmember Get signed character count
				{return _cch;}
	BOOL	IsSel()						{return _fSel;}
	BOOL	fExpandCell() const			{return _fSelExpandCell;}
	BOOL	fHasEOP() const				{return _fSelHasEOP;}
    BOOL 	CpInRange (LONG cp) const;	//@cmember Says if cp is in this range
										//@cmember Says if cch chars can fit
	BOOL	CheckTextLength (LONG cch, LONG *pcch = NULL);
										//@cmember Used after _cp change to set
	LONG	CheckChange(LONG cpSave, BOOL fExtend);//  selection-changed flag, choose _cch
										//@cmember In outline mode, maintain _fSelHasEOP
	BOOL	CheckIfSelHasEOP(LONG cpSave, LONG cchSave, BOOL fDoRange = FALSE);
	void	CalcTableExpandParms();		//@cmember Calculate table Expand members
										//@cmember Insert table row
	LONG	InsertTableRow(const CParaFormat *pPF, IUndoBuilder *publdr); 
										//@cmember TRUE for valid sequence
	BOOL	IsInputSequenceValid(WCHAR* pwch, LONG cch, BOOL fOver, BOOL* pfBaseChar = NULL);
 
	// GetRange() is faster than calling GetCpMin() and GetCpMost();
    LONG    GetCpMin () const;			//@cmember Get cp of first char in range
    LONG    GetCpMost () const;			//@cmember Get cp just beyond last char in range
										//@cmember Get range ends and count
	LONG	GetRange (LONG& cpMin, LONG& cpMost) const;
    BOOL	Set(LONG cp, LONG cch);
	LONG	SetCp(LONG cp, BOOL fExtend);
	LONG	GetAdjustedTextLength() const
				{return GetPed()->GetAdjustedTextLength();}

	// Range specific methods
	LONG	Move(LONG cch, BOOL fExtend);	
	void 	Collapser(long fStart);
	void 	FlipRange();
	LONG 	CleanseAndReplaceRange (LONG cchS, WCHAR const *pchS, BOOL fTestLimit, 
				IUndoBuilder *publdr, WCHAR *pchD = NULL, LONG* pcchMove = NULL, DWORD dwFlags = 0);
	LONG	CheckLimitReplaceRange (LONG cch, WCHAR const *pch,
				BOOL fTestLimit, IUndoBuilder *publdr, QWORD qwCharFlags,
				LONG *pcchMove, LONG cpFirst, int iMatchCurrent, DWORD &dwFlags);
	HRESULT	HexToUnicode (IUndoBuilder *publdr);
	HRESULT	UnicodeToHex (IUndoBuilder *publdr);
	void	Delete(IUndoBuilder *publdr, SELRR selaemode);
	void	DeleteTerminatingEOP(IUndoBuilder *publdr);
	BOOL	BypassHiddenText(LONG iDir, BOOL fExtend);
	void	CheckMergedCells(IUndoBuilder *publdr);
	void	CheckTopCells(IUndoBuilder *publdr);
	static BOOL	CheckCells(CELLPARMS *prgCellParms,	const CParaFormat *	pPF1,
					   const CParaFormat *pPF0, DWORD dwMaskCell, DWORD dwMaskCellAssoc);
	BOOL	AdjustEndEOP (EOPADJUST NewChars);

	// Outline management
	void	CheckOutlineLevel(IUndoBuilder *publdr);
	HRESULT	ExpandOutline  (LONG Level, BOOL fWholeDocument);
	HRESULT	OutlineExpander(LONG Level, BOOL fWholeDocument);
	HRESULT	Promote		   (LPARAM lparam, IUndoBuilder *publdr);

	// ReplaceRange must be virtual since the callers of
	// CLightDTEngine::CutRangeToClipboard() cast CTxtSelection* to CTxtRange*
	virtual	LONG	DeleteWithTRDCheck(IUndoBuilder *publdr, SELRR selaemode,
									   LONG *pcchMove, DWORD dwFlags);
	virtual	LONG 	ReplaceRange(LONG cchNew, TCHAR const *pch, IUndoBuilder *publdr,
						SELRR selaemode, LONG *pcchMove = NULL, DWORD dwFlags = 0);
	virtual	BOOL 	Update(BOOL fScrollIntoView);

	// Rich-text methods
	// Get/Set Char/Para Format methods
	void 	Update_iFormat(LONG iFmtDefault);
	QWORD	GetCharRepMask(BOOL fUseDocFormat = FALSE);	//@cmember Get range charset mask
	LONG	Get_iCF();						//@cmember Get range CF index
	LONG	Get_iFormat() {return _iFormat;}//@cmember Get _iFormat for quick peek
	LONG	GetiFormat() const;
    BOOL	Set_iCF(LONG iFormat);			//@cmember Set range CF index
	PROTECT	IsProtected(CHECKPROTECT chkprot);	//@cmember Is range protected?
	BOOL	IsZombie() {return !GetPed();}	//@cmember Is range zombied?
	BOOL	IsHidden();
	BOOL	WriteAccessDenied ();
	DWORD	GetCharFormat(CCharFormat *pCF, DWORD flags = 0) const;
	DWORD	GetParaFormat(CParaFormat *pPF, DWORD dwMask2) const;
	void	SetDragProtection(BOOL fSet)	// Convinces range it's protected
				{_fDragProtection = fSet;}	//  w/o modifying backing store
	HRESULT	CharFormatSetter (const CCharFormat *pCF, DWORD dwMask, DWORD dwMask2 = 0);
	HRESULT	ParaFormatSetter (const CParaFormat *pPF, DWORD dwMask);

	HRESULT	SetCharFormat(const CCharFormat *pCF, DWORD flags,
						  IUndoBuilder *publdr, DWORD dwMask, DWORD dwMask2);
	HRESULT	SetParaFormat(const CParaFormat *pPF,
						  IUndoBuilder *publdr, DWORD dwMask, DWORD dwMask2);
	HRESULT	SetParaStyle (const CParaFormat *pPF,
						  IUndoBuilder *publdr, DWORD dwMask);
	void	SetCellParms(CELLPARMS *prgCellParms, LONG cCell, BOOL fConvertLowCells, IUndoBuilder *publdr);
											//@cmember Format range CharSets
	// Complex script feature :- Itemization
	BOOL	ItemizeRuns(IUndoBuilder *publdr, BOOL fUnicodeBiDi = FALSE, BOOL fUseCtxLevel = FALSE);
#ifndef NOCOMPLEXSCRIPTS
	HRESULT BiDiLevelFromFSM (const CBiDiFSM* pfsm);
#endif
	LONG	GetRunsPF (CRchTxtPtr* prtp, CFormatRunPtr* prpPF, LONG& cchLeft);
#if defined(DEBUG)  && !defined(NOFULLDEBUG)
	void	DebugFont (void);
#endif

	// Find enclosing unit methods
	HRESULT	Expander		(long Unit, BOOL fExtend, LONG *pDelta,
							 LONG *pcpMin, LONG *pcpMost);
	void	FindAttributes	(LONG *pcpMin, LONG *pcpMost, LONG Unit) const;
	void	FindCell		(LONG *pcpMin, LONG *pcpMost) const;
    BOOL    FindObject		(LONG *pcpMin, LONG *pcpMost) const;
    void    FindParagraph	(LONG *pcpMin, LONG *pcpMost) const;
	void	FindRow			(LONG *pcpMin, LONG *pcpMost, LONG Level = -1) const;
    void    FindSentence	(LONG *pcpMin, LONG *pcpMost) const;
	BOOL	FindVisibleRange(LONG *pcpMin, LONG *pcpMost) const;
    void    FindWord		(LONG *pcpMin, LONG *pcpMost, 
								FINDWORD_TYPE type)const;
	LONG	CountCells		(LONG &cCell, LONG cchMax);

	LONG	AdvanceCRLF(CSCONTROL csc, BOOL fExtend);
	LONG	BackupCRLF (CSCONTROL csc, BOOL fExtend);
	BOOL	AdjustCRLF (LONG iDir);
	LONG    FindWordBreak(INT action,  BOOL fExtend);

	BOOL	CheckTableSelection(BOOL fUpdate, BOOL fEnableExpandCell,
								BOOL *pfTRDsInvolved, DWORD dwFlags);
	BOOL	CheckLinkProtection(DWORD &dwFlags,	LONG &iFormat);

	void	SetUseiFormat(BOOL fUseiFormat) {_fUseiFormat = fUseiFormat;}

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDispatch methods
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

    // ITextRange methods
    STDMETHODIMP GetText (BSTR *pbstr);
    STDMETHODIMP SetText (BSTR bstr);
    STDMETHODIMP GetChar (long *pch);
    STDMETHODIMP SetChar (long ch);
    STDMETHODIMP GetDuplicate (ITextRange **ppRange);
    STDMETHODIMP GetFormattedText (ITextRange **ppRange);
    STDMETHODIMP SetFormattedText (ITextRange *pRange);
    STDMETHODIMP GetStart (long *pcpFirst);
    STDMETHODIMP SetStart (long cpFirst);
    STDMETHODIMP GetEnd (long *pcpLim);
    STDMETHODIMP SetEnd (long cpLim);
    STDMETHODIMP GetFont (ITextFont **pFont);
    STDMETHODIMP SetFont (ITextFont *pFont);
    STDMETHODIMP GetPara (ITextPara **pPara);
    STDMETHODIMP SetPara (ITextPara *pPara);
    STDMETHODIMP GetStoryLength (long *pcch);
    STDMETHODIMP GetStoryType (long *pValue);
    STDMETHODIMP Collapse (long bStart);
    STDMETHODIMP Expand (long Unit, long *pDelta);
    STDMETHODIMP GetIndex (long Unit, long *pIndex);
    STDMETHODIMP SetIndex (long Unit, long Index, long Extend);
    STDMETHODIMP SetRange (long cpActive, long cpOther);
    STDMETHODIMP InRange (ITextRange * pRange, long *pb);
    STDMETHODIMP InStory (ITextRange * pRange, long *pb);
    STDMETHODIMP IsEqual (ITextRange * pRange, long *pb);
    STDMETHODIMP Select ();
    STDMETHODIMP StartOf (long Unit, long Extend, long * pDelta);
    STDMETHODIMP EndOf (long Unit, long Extend, long * pDelta);
    STDMETHODIMP Move (long Unit, long Count, long * pDelta);
    STDMETHODIMP MoveStart (long Unit, long Count, long * pDelta);
    STDMETHODIMP MoveEnd (long Unit, long Count, long * pDelta);
    STDMETHODIMP MoveWhile (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveStartWhile (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveEndWhile (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveUntil (VARIANT FAR* Cset, long Count, long * pDelta);
    STDMETHODIMP MoveStartUntil (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveEndUntil (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP FindText (BSTR bstr, long cch, long Flags, long * pLength);
    STDMETHODIMP FindTextStart (BSTR bstr, long cch, long Flags, long * pLength);
    STDMETHODIMP FindTextEnd (BSTR bstr, long cch, long Flags, long * pLength);
    STDMETHODIMP Delete (long Unit, long Count, long * pDelta);
    STDMETHODIMP Cut (VARIANT * ppIDataObject);
    STDMETHODIMP Copy (VARIANT * ppIDataObject);
    STDMETHODIMP Paste (VARIANT * pIDataObject, long Format);
    STDMETHODIMP CanPaste (VARIANT * pIDataObject, long Format, long * pb);
    STDMETHODIMP CanEdit (long * pbCanEdit);
    STDMETHODIMP ChangeCase (long Type);
    STDMETHODIMP GetPoint (long Type, long * px, long * py);
    STDMETHODIMP SetPoint (long x, long y, long Type, long Extend);
    STDMETHODIMP ScrollIntoView (long Value);
    STDMETHODIMP GetEmbeddedObject (IUnknown ** ppv);


    // ITextSelection methods
    STDMETHODIMP GetFlags (long * pFlags) ;
    STDMETHODIMP SetFlags (long Flags) ;
    STDMETHODIMP GetType  (long * pType) ;
	STDMETHODIMP MoveLeft (long Unit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP MoveRight(long pUnit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP MoveUp   (long pUnit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP MoveDown (long pUnit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP HomeKey  (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP EndKey   (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP TypeText (BSTR bstr) ;


//@access Private ITextRange helper methods
private:
	void	RangeValidateCp (LONG cp, LONG cch);
	LONG	Comparer (ITextRange * pv);
	LONG	SpanSubstring (CUniscribe* pusp, CFormatRunPtr* pcrp, WCHAR* pwchString, 
						LONG cchString, WORD& uSubStrLevel, DWORD dwInFlags, CCharFlags* pCharflags,
						WORD& wBiDiLangId);
	HRESULT EndSetter(LONG cp, BOOL fOther);
	HRESULT Finder	 (BSTR bstr, long Count, long Flags, LONG *pDelta,
						MOVES Mode);
	HRESULT GetLong  (LONG lValue, long *pLong);
	HRESULT	IsTrue	 (BOOL f, long *pB);
	HRESULT Matcher	 (VARIANT *Cset, long Count, LONG *pDelta, MOVES Mode,
						MATCHES Match);
	HRESULT	Mover	 (long Unit, long Count, LONG *pDelta, MOVES Mode);
	HRESULT	Replacer (LONG cchNew, TCHAR const *pch, DWORD dwFlags = 0);

	LONG	CalcTextLenNotInRange();
};



// Useful Unicode range definitions for use with MoveWhile/Until methods

#define	CodeRange(n, m)	0x8000000 | ((m) - (n)) << 16 | n

#define	CR_ASCII		CodeRange(0x0, 0x7f)
#define	CR_ANSI			CodeRange(0x0, 0xff)
#define	CR_ASCIIPrint	CodeRange(0x20, 0x7e)
#define	CR_Latin1		CodeRange(0x20, 0xff)
#define	CR_Latin1Supp	CodeRange(0xa0, 0xff)
#define	CR_LatinXA		CodeRange(0x100, 0x17f)
#define	CR_LatinXB		CodeRange(0x180, 0x24f)
#define	CR_IPAX			CodeRange(0x250, 0x2af)
#define	CR_SpaceMod		CodeRange(0x2b0, 0x2ff)
#define	CR_Combining	CodeRange(0x300, 0x36f)
#define	CR_Greek		CodeRange(0x370, 0x3ff)
#define	CR_BasicGreek	CodeRange(0x370, 0x3cf)
#define	CR_GreekSymbols	CodeRange(0x3d0, 0x3ff)
#define	CR_Cyrillic		CodeRange(0x400, 0x4ff)
#define	CR_Armenian		CodeRange(0x530, 0x58f)
#define	CR_Hebrew		CodeRange(0x590, 0x5ff)
#define	CR_BasicHebrew	CodeRange(0x5d0, 0x5ea)
#define	CR_HebrewXA		CodeRange(0x590, 0x5cf)
#define	CR_HebrewXB		CodeRange(0x5eb, 0x5ff)
#define	CR_Arabic		CodeRange(0x600, 0x6ff)
#define	CR_BasicArabic	CodeRange(0x600, 0x652)
#define	CR_ArabicX		CodeRange(0x653, 0x6ff)
#define	CR_Devengari	CodeRange(0x900, 0x97f)
#define	CR_Bengali		CodeRange(0x980, 0x9ff)
#define	CR_Gurmukhi		CodeRange(0xa00, 0xa7f)
#define	CR_Gujarati		CodeRange(0xa80, 0xaff)
#define	CR_Oriya		CodeRange(0xb00, 0xb7f)
#define	CR_Tamil		CodeRange(0xb80, 0xbff)
#define	CR_Teluga		CodeRange(0xc00, 0xc7f)
#define	CR_Kannada		CodeRange(0xc80, 0xcff)
#define	CR_Malayalam	CodeRange(0xd00, 0xd7f)
#define	CR_Thai 		CodeRange(0xe00, 0xe7f)
#define	CR_Lao  		CodeRange(0xe80, 0xeff)
#define	CR_GeorgianX	CodeRange(0x10a0, 0xa0cf)
#define	CR_BascGeorgian	CodeRange(0x10d0, 0x10ff)
#define	CR_Hanguljamo	CodeRange(0x1100, 0x11ff)
#define	CR_LatinXAdd	CodeRange(0x1e00, 0x1eff)
#define	CR_GreekX		CodeRange(0x1f00, 0x1fff)
#define	CR_GenPunct		CodeRange(0x2000, 0x206f)
#define	CR_SuperScript	CodeRange(0x2070, 0x207f)
#define	CR_SubScript	CodeRange(0x2080, 0x208f)
#define	CR_SubSuperScrp	CodeRange(0x2070, 0x209f)
#define	CR_Currency		CodeRange(0x20a0, 0x20cf)
#define	CR_CombMarkSym	CodeRange(0x20d0, 0x20ff)
#define	CR_LetterLike	CodeRange(0x2100, 0x214f)
#define	CR_NumberForms	CodeRange(0x2150, 0x218f)
#define	CR_Arrows		CodeRange(0x2190, 0x21ff)
#define	CR_MathOps		CodeRange(0x2200, 0x22ff)
#define	CR_MiscTech		CodeRange(0x2300, 0x23ff)
#define	CR_CtrlPictures	CodeRange(0x2400, 0x243f)
#define	CR_OptCharRecog	CodeRange(0x2440, 0x245f)
#define	CR_EnclAlphaNum	CodeRange(0x2460, 0x24ff)
#define	CR_BoxDrawing	CodeRange(0x2500, 0x257f)
#define	CR_BlockElement	CodeRange(0x2580, 0x259f)
#define	CR_GeometShapes	CodeRange(0x25a0, 0x25ff)
#define	CR_MiscSymbols	CodeRange(0x2600, 0x26ff)
#define	CR_Dingbats		CodeRange(0x2700, 0x27bf)
#define	CR_CJKSymPunct	CodeRange(0x3000, 0x303f)
#define	CR_Hiragana		CodeRange(0x3040, 0x309f)
#define	CR_Katakana		CodeRange(0x30a0, 0x30ff)
#define	CR_Bopomofo		CodeRange(0x3100, 0x312f)
#define	CR_HangulJamo	CodeRange(0x3130, 0x318f)
#define	CR_CJLMisc		CodeRange(0x3190, 0x319f)
#define	CR_EnclCJK		CodeRange(0x3200, 0x32ff)
#define	CR_CJKCompatibl	CodeRange(0x3300, 0x33ff)
#define	CR_Hangul		CodeRange(0x3400, 0x3d2d)
#define	CR_HangulA		CodeRange(0x3d2e, 0x44b7)
#define	CR_HangulB		CodeRange(0x44b8, 0x4dff)
#define	CR_CJKIdeograph	CodeRange(0x4e00, 0x9fff)
#define	CR_PrivateUse	CodeRange(0xe000, 0xf800)
#define	CR_CJKCompIdeog	CodeRange(0xf900, 0xfaff)
#define	CR_AlphaPres	CodeRange(0xfb00, 0xfb4f)
#define	CR_ArabicPresA	CodeRange(0xfb50, 0xfdff)
#define	CR_CombHalfMark	CodeRange(0xfe20, 0xfe2f)
#define	CR_CJKCompForm	CodeRange(0xfe30, 0xfe4f)
#define	CR_SmallFormVar	CodeRange(0xfe50, 0xfe6f)
#define	CR_ArabicPresB	CodeRange(0xfe70, 0xfefe)
#define	CR_HalfFullForm	CodeRange(0xff00, 0xffef)
#define	CR_Specials		CodeRange(0xfff0, 0xfffd)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_rtfconv.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFCONV.H -- RichEdit RTF Converter Base Class Definition |
 *
 *	Description:
 *		This file contains the type declarations used by both the RTF reader
 *		and writer for the RICHEDIT control
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	@devnote
 *		sz's in the RTF*.? files usually refer to LPSTRs, not LPWSTRs
 *
 *	Copyright (c) 1995-2002, Microsoft Corporation. All rights reserved.
 */
#ifndef __RTFCONV_H
#define __RTFCONV_H

#include "_edit.h"
#include "_array.h"
#include "_range.h"
#include "_rtext.h"
#include "tokens.h"

extern const KEYWORD rgKeyword[];
extern const KEYWORD rgShapeKeyword[];

#define	LBRACE	TEXT('{')
#define	BSLASH	TEXT('\\')
#define	RBRACE	TEXT('}')
#define ZERO	TEXT('0')

// Character property bits like an ASCII-only ANSI C LC_CTYPE types
#define fUC			0x01		// A-Z
#define	fLC			0x02		// a-z
#define fDG			0x04		// 0-9
#define	fSP			0x08		// Space chars
#define	fPN			0x10		// Punctuation chars
#define fCT			0x20		// Control chars
#define	fBL			0x40		// Blank chars
#define fHX			0x80		// 0-9, a-f, or A-F

#define	fAlpha		(fUC + fLC)
#define	fAlphaNum	(fAlpha + fDG)

extern const BYTE rgbCharClass[256];

#define Classify(_ch)		(rgbCharClass[_ch])
#define IsLC(_ch)			((Classify(_ch) & fLC))
#define IsASCIIAlpha(_ch)	((Classify(_ch) & fAlpha))
#define IsDigit(_ch)		((Classify(_ch) & fDG))
#define IsXDigit(_ch)		((Classify(_ch) & fHX))
#define IsAlphaNum(_ch) 	((Classify(_ch) & fAlphaNum))
#define IsAlphaNumBlank(_ch) ((Classify(_ch) & (fAlphaNum + fBL)))

template <class T> unsigned int DiffPtrs(T *pA, T *pB)
{
	return pA - pB;
}

//#define DiffPtrs(_pA, _pB, _type) ((UINT) (((_type *) (_pA)) - ((_type *) (_pB))))

extern INT  cKeywords;
extern INT  cShapeKeywords;
extern const COLORREF g_Colors[];
extern const char szEndGroupCRLF[];

#define szaCRLF		(BYTE *)&szEndGroupCRLF[1]

/*
 *		Converter Error Codes
 */
enum
{
	ecNoError = 0,						// Success
	ecCantUnicode,
	ecColorTableOverflow,
	ecExpectingRtfKeyword,
	ecExpectingStartGroup,
	ecFontTableOverflow,
	ecGeneralFailure,
	ecKeywordTooLong,
	ecLexInitFailed,
	ecNoMemory,
	ecParserBusy,
	ecPutCharFailed,
	ecStackOverflow,
	ecStackUnderflow,
	ecUnexpectedChar,
	ecUnexpectedEOF,
	ecUnexpectedToken,
	ecUnGetCharFailed,
	ecTextMax,
	ecStreamOutObj,
	ecStreamInObj,
	ecTruncateAtCRLF,
	ecFormatCache,
	ecUTF8NotUsed,
	ecAbort,
	ecLastError							// Total error messages
};

typedef	INT	EC;

/*
 *	@struct RTFOBJECT |
 *		Object data transfer structure
 */
typedef struct _rtfobject
{
	SHORT	sType;				// @field object type (ROT_*)
	SHORT	sPictureType;		// @field specific type of sPicture
	SHORT	cBitsPerPixel;		// @field # bits per pixel, if bitmap
	SHORT	cColorPlanes;		// @field # color planes, if bitmap
	SHORT	cBytesPerLine;		// @field # bytes per raster line, if bitmap
	BOOL	fSetSize;			// @field Let client tell server the size
	LONG	xExt, yExt;			// @field dimensions in pixels for pictures, twips for
								//	for objects
	LONG	xScale, yScale;		// @field scaling percentage along axes
	SHORT	xExtGoal, yExtGoal;	// @field desired dimensions in twips for pictures
	RECT	rectCrop;			// @field cropping information in twips
	WCHAR *	szClass;			// @field object class
	WCHAR *	szName;				// @field object name

	// On RTF generation
	LONG	xExtPict, yExtPict;	// @field metafile dimensions
	LPBYTE	pbResult;			// metafile depiction of the object
	ULONG	cbResult;
} RTFOBJECT;

/*
 *	@enum ROTYPE | The values for OBJECT.sType
 *
 *		Keep this in sync with rgszROT in rtfwrit.cpp
 */
enum ROTYPE
{
	ROT_Bitmap,					// @emem Bitmap
	ROT_Metafile,				// @emem Metafile
	ROT_DIB,					// @emem Device-Independent Bitmap
	ROT_JPEG,					// @emem JPEG blip
	ROT_PNG,					// @emem PNG blip

	ROT_Embedded,				// @emem Embedded Object
	ROT_Link,					// @emem Linked Object
	ROT_AutoLink,				// @emem Autolink
	ROT_MacEdition,				// @emem Mac object

	ROT_EBookImage,				// @emem Ebook Image object
};

/*
 *		DEFINE's
 */
#define cachBufferMost		4096
#define	cachTextMax			( 512 + 1 )
#define	cachKeywordMax		( 32 + 1 )
#define	cachParamMax		( 11 + 1 )
#define cFooChunk			8
#define MAXTABLENEST		16

// Characters to give to RichEdit

#if	( cachTextMax - 1 ) % 2 == 1
#error "cachTextMax  - 1 MUST be even"
#endif

#if ( cachParamMax - 1 ) < 11
#error "cachParamMax MUST be >= 11"
#endif

/*
 * Some RTF defaults
 */
#ifdef NEVER
// we don't care about margins, just indents
#define dxDefaultLeftMargin		1800
#define dxDefaultRightMargin	1800

#else
#define dxDefaultLeftMargin		0
#define dxDefaultRightMargin	0
#endif

// next two in half points
#define	yDefaultFontSize		( 12 * 2 )
#define dyDefaultSuperscript	6

#define RESERVED_FONT_HANDLES	0x800

/*
 *	@struct TEXTFONT |
 *		text font structure
 */
typedef struct _textfont
{
	SHORT		sHandle;				// @field RTF input font handle
	BYTE		iCharRep;				// @field Font character repertoire
	BYTE		bPitchAndFamily;		// @field Font family
	SHORT		iFont;					// @field Font name index
	WCHAR		szName[LF_FACESIZE+1];	// @field Font name
	SHORT		sCodePage;				// @field Code page for font 
										// 			(INVALID_CODEPAGE == not set)
	BYTE		fNameIsDBCS;			// @field Indicates if szName is DBCS stuffed into Unicode buffer
	BYTE		fCpgFromSystem;			// @field Indicates is cpg was 
										// 			retrieved from system based
										//			on font name.
} TEXTFONT;

/*
 *		Global variables for the scope of the entire parser/reader
 */
#ifdef DEBUG
extern CHAR *		rgszParseError[];
extern CHAR *		szDest[];
#endif

#define cchMaxNumText 16

// tagged font info
typedef struct _tfi
{
	WCHAR *szNormalName;
	WCHAR *szTaggedName;
	BYTE iCharRep;
} TFI;

typedef CArray<TEXTFONT> TEXTFONTS;
typedef CArray<COLORREF> COLORREFS;

const short INVALID_CODEPAGE = -1;
const short INVALID_LANGUAGE = -1;

// default value for \ucN tag
const int iUnicodeCChDefault = 1;

/*
 *	CRTFConverter
 *
 *	@class	RTF converter base class used by CRTFRead and CRTFWrite
 */
class CRTFConverter
{
//@access Protected Data Members
protected:
	TEXTFONTS	_fonts;				// @cmember Font table
	COLORREFS	_colors;			// @cmember Color table
	EC			_ecParseError;		// @cmember Error code
	CTxtEdit *	_ped;				// @cmember CTxtEdit
	CTxtRange *	_prg;				// @cmember CTxtRange to replace/write from
	EDITSTREAM *_pes;				// @cmember EDITSTREAM to use
	DWORD		_dwFlags;			// @cmember See #defines below
	CCharFormat	_CF;				// @cmember Character formatting info
	BYTE		_iCharRep;			// @cmember Converter char set (ANSI, UTF7, UTF8)
	char		_bTableLevel;		// @cmember Table level (0 for no table)
	char		_bTableLevelIP;		// @cmember Table level at insertion point

	static TFI *_rgtfi;				// @cmember Pointer to the first font substitute record
	static INT _ctfi;				// @cmember Number of the font substitute records
	static WCHAR *_pchFontSubInfo;	// @cmember Font strings for substitutions

//@access Protected Functions
	void ReadFontSubInfo(void);

	enum PARSEFONTNAME { PFN_SUCCESS, PFN_FAIL, PFN_EOF };
	PARSEFONTNAME ParseFontName(WCHAR *pchBuf,
							WCHAR *pchBufMax,
							WCHAR chDelimiter,
							WCHAR **pszName,
							BYTE &iCharRep,
							BOOL &fSetCharSet,
							WCHAR **ppchBufNew) const;
	BOOL FontSubstitute(WCHAR *szTaggedName, 
						WCHAR *szNormalName, 
						BYTE *piCharRep);
	BOOL FindTaggedFont(const WCHAR *szNormalName, BYTE iCharRep, WCHAR **ppchTaggedName);	 
									// @cmember	Find font name with additional special tag 
									// corresponding to szNormalName & iCharRep
	BOOL IsTaggedFont(const WCHAR *szName, BYTE *piCharRep, WCHAR **ppchNormalName);
								   	// @cmember Figure out is szName font name with additional tag
								   	// corresponding to piCharRep

//@access Public Functions

public:
	CRTFConverter(CTxtRange *prg, EDITSTREAM *pes, DWORD dwFlags, BOOL fRead);
	inline ~CRTFConverter();
	static void FreeFontSubInfo();

protected:
#if defined(DEBUG)
	// for capturing RTF as its read from or written to a file
	HANDLE _hfileCapture;
#endif
};

#define	fRTFNoObjs	1
#define	fRTFFE	8					// Check this

#define IsUTF8	((_dwFlags & (0xFFFF0000 | SF_USECODEPAGE)) \
					 == ((CP_UTF8 << 16) | SF_USECODEPAGE))

/*
 *	CRTFConverter::~CRTFConverter()
 *
 *	@mfunc
 *		RTF Converter destructor
 */
inline CRTFConverter::~CRTFConverter()
{
#if defined(DEBUG)
	if(_hfileCapture)
	{
		CloseHandle(_hfileCapture);
		_hfileCapture = NULL;
	}
#endif
}

#endif // __RTFCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_rtfread.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFREAD.H -- RichEdit RTF Reader Class Definition |
 *
 *		This file contains the type declarations used by the RTF reader
 *		for the RICHEDIT control
 *
 *	Authors:<nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	@devnote
 *		All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *		noted as a szUnicode.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */
#ifndef __RTFREAD_H
#define __RTFREAD_H

#include "_rtfconv.h"

#if defined(DEBUG)
#include "_rtflog.h"
#endif

typedef SHORT	ALIGN;

/*
 *		Destinations of the stuff we may read in while parsing
 */
enum
{
	destRTF,
	destColorTable,
	destFontTable,
	destBinary,
	destObject,
	destObjectClass,
	destObjectName,
	destObjectData,			// Keep next 2 together
	destPicture,			// Keep next 3 together
	destField,
	destFieldResult,
	destFieldInstruction,
	destParaNumbering,
	destParaNumText,
	destRealFontName,
	destFollowingPunct,
	destLeadingPunct,
	destDocumentArea,
	destNULL,
	destStyleSheet,
	destShapeName,
	destShapeValue,
	destMAX					// This must be last entry
};


/*
 *		Super or subscripting state
 */
enum
{
	sSub = -1,
	sNoSuperSub,
	sSuper
};

enum DEFAULTFONT
{
	DEFFONT_NOCH = 0,
	DEFFONT_LTRCH,
	DEFFONT_RTLCH,
	DEFFONT_LOCH,
	DEFFONT_HICH,
	DEFFONT_DBCH
};

typedef struct tagDefFont
{
	SHORT sHandle;
	SHORT sSize;
} DEFFONT;

/*
 *	@struct STATE | 
 *		Structure to save current reader state
 */
struct STATE
{
	WORD		cbSkipForUnicodeMax;	//@field Bytes to skip after \uN is read
	SHORT		iCF;					//@field CF index at LBRACE

	// Miscellaneous flags
	unsigned	fBullet			 : 1;	//@field group is a \\pn bullet group
	unsigned	fRealFontName	 : 1;	//@field found a real font name when parsing
	unsigned	fBackground		 : 1;	//@field background being processed
	unsigned	fShape			 : 1;	//@field {\shp...} being processed

	// BiDi flags
	unsigned	fRightToLeftPara : 1;	//@field Para text going right to left ?
	unsigned	fZeroWidthJoiner : 1;	//@field Zero Width Joiner ?

	// xchg 12370: keep numbering indent separate
	SHORT		sIndentNumbering;		//@field numbering indent
	SHORT		sDest;					//@field Current destination
	int			nCodePage;				//@field Current code page


	// Scratch pad variables
	TEXTFONT *	ptf;					//@field Ptr to font table entry to fill
	BYTE		bRed;					//@field Color table red entry
	BYTE		bGreen;					//@field Color table green entry
	BYTE		bBlue;					//@field Color table blue entry
	char		iDefFont;				//@field Default font (\dbch, \rtlch, etc.)
	STATE * 	pstateNext;				//@field Next state on stack
	STATE * 	pstatePrev;				//@field Previous state on stack

	CParaFormat *pPF;					//@field PF for the state to which 
										//	delta's are applied
	DWORD		dwMaskPF;
	DWORD		dwMaskPF2;

	DEFFONT		rgDefFont[6];			//@cmember Default fonts for \dbch, etc.

	STATE() {};
										//@cmember Adds or applies PF to state's PF
	BOOL AddPF(const CParaFormat &PF,
				LONG lDocType, DWORD dwMask, DWORD dwMask2);
	void DeletePF();					//@cmember Deletes PF for state
	void SetCodePage(LONG CodePage);
};

typedef struct TableState
{
	BYTE	_cCell;
	BYTE	_iCell;
} TABLESTATE;

class CRTFRead ;
class COleObject;


class RTFREADOLESTREAM : public OLESTREAM
{
	OLESTREAMVTBL OLEStreamVtbl;	// @member - memory for  OLESTREAMVTBL
public:
	 CRTFRead *Reader;				// @cmember EDITSTREAM to use

	RTFREADOLESTREAM::RTFREADOLESTREAM ()
	{
		lpstbl = & OLEStreamVtbl ;
	}		
};

#define	NSTYLES		(NHSTYLES + 1)
#define CCELLS		((1 + CELL_EXTRA)*MAX_TABLE_CELLS)
/*
 *	CRTFRead
 *
 *	@class	RichEdit RTF reader class.
 *
 *	@base	public | CRTFConverter
 */
class CRTFRead : public CRTFConverter
{

//@access Private Methods and Data
	// Lexical analyzer outputs
	LONG		_iParam;				//@cmember Control-word parameter
	TOKEN		_token;					//@cmember Current control-word token
	TOKEN		_tokenLast;				//@cmember Previous token
	BYTE *		_szText;				//@cmember Current BYTE text string

	// Used for reading in
	BYTE		_rgStyles[NSTYLES];		//@cmember Style handle table
	SHORT		_Style;					//@cmember Current style handle
	LONG		_cbBinLeft;				//@cmember cb of bin data left to read
	BYTE *		_pchRTFBuffer;			//@cmember Buffer for GetChar()
	BYTE *		_pchRTFCurrent;			//@cmember Current position in buffer
	BYTE *		_pchRTFEnd;				//@cmember End of buffer
	BYTE *		_pchHexCurr;			//@cmember Current position within
										//  _szText when reading object data
	INT			_nStackDepth;			//@cmember Stack depth
	STATE *		_pstateStackTop;		//@cmember Stack top
	STATE *		_pstateLast;			//@cmember Last STATE allocated
	LONG		_cpThisPara;			//@cmember Start of current paragraph

	DWORD		_dwMaskCF;				//@cmember Character format mask
	DWORD		_dwMaskCF2;				//@cmember Character format mask 2
	CParaFormat	_PF;					//@cmember Paragraph format changes
	DWORD		_dwMaskPF;				//@cmember Paragraph format mask
	DWORD		_dwMaskPF2;				//@cmember Paragraph format mask

	LONG		_cTab;					//@cmember Count of defined tabs
	LONG		_dxCell;				//@cmember Half space betw table cells
	LONG		_cCell;					//@cmember Count of cells in table row
	LONG		_iCell;					//@cmember Current cell in table row
	COLORREF	_crCellCustom1;			//@cmember First custom cell color
	COLORREF	_crCellCustom2;			//@cmember Second custom cell color
	LONG		_rgxCell[CCELLS];		//@cmember Cell right boundaries
	LONG		_xCellPrev;				//@cmember Previous \cellx N
	LONG		_xRowOffset;			//@cmember Row offset to ensure rows fall along left margin
	DWORD		_dwBorderColors;		//@cmember Border colors
	DWORD		_dwCellColors;			//@cmember Cell border and back colors
	DWORD		_dwShading;				//@cmember Shading in hundredths of per cent (could be 1 byte)
	WORD		_wBorders;				//@cmember Border styles
	WORD		_wBorderSpace;			//@cmember Border/text spaces
	WORD		_wBorderWidth;			//@cmember Border widths
	SHORT		_iTabsTable;			//@cmember _iTabs used by last table
	TABLESTATE	_rgTableState[MAXTABLENEST];
	DWORD		_dwRowResolveFlags;		//@cmember Flags for row start resolution

	COleObject *_pobj;					//@cmember Pointer to our object

	union
	{
	  DWORD		_dwFlagsUnion;			// All together now
	  struct
	  {
		WORD	_fFailedPrevObj	 : 1;	//@cmember Fail to get prev object ?
		WORD	_fNeedIcon		 : 1;	//@cmember Objects needs an icon pres
		WORD	_fNeedPres		 : 1;	//@cmember Use stored presenation.
		WORD	_fGetColorYet	 : 1;	//@cmember used for AutoColor detect
		WORD	_fRightToLeftDoc : 1;	//@cmember Document is R to L ?
		WORD	_fReadDefFont	 : 1;	//@cmember True if we've read a default
										// 		   font from RTF input
		WORD	_fSymbolField	 : 1;	//@cmember TRUE if handling SYMBOL field
		WORD	_fSeenFontTable	 : 1;	//@cmember True if \fonttbl	processed 
		WORD	_fCharSet		 : 1;	//@cmember True if \fcharset processed
		WORD    _fNoRTFtoken     : 1;   //@cmember True in 1.0 mode if \rtf hasn't been seen
		WORD	_fInTable		 : 1;	//@cmember True if pasting into table
		WORD	_fStartRow		 : 1;	//@cmember True if AddText should start row
		WORD	_fNo_iTabsTable	 : 1;	//@cmember Suppress _iTabsTable changes
		WORD	_fParam			 : 1;	//@cmember TRUE if token has param
		WORD	_fNotifyLowFiRTF : 1;	//@cmember TRUE if EN_LOWFIRTF
		WORD	_fMac			 : 1;	//@cmember TRUE if \mac file
		BYTE	_bDocType;				//@cmember Document Type
		BYTE	_fRTLRow		 : 1;	//@cmember RightToLeft table row
		BYTE	_fNon0CharSet	 : 1;	//@cmember CharSet other than ANSI_CHARSET found
		BYTE	_fBody			 : 1;	//@cmember TRUE when body text has started
	  };
	};

	SHORT		_sDefaultFont;			//@cmember Default font to use
	SHORT       _sDefaultBiDiFont;      //@cmember Default Bidi font to use
	SHORT		_sDefaultLanguage;		//@cmember Default language to use
	SHORT		_sDefaultLanguageFE;	//@cmember Default FE language to use

	SHORT		_sDefaultTabWidth;		//@cmember Default tabwidth to use
	SHORT		_iKeyword;				//@cmember Keyword index of last token

	WCHAR		_szNumText[cchMaxNumText];	//@cmember Scratch pad for numbered lists

	int			_nCodePage;				//@cmember default codepage (RTF-read-level)
	int			_cchUsedNumText;		//@cmember space used in szNumText

	RTFOBJECT *	_prtfObject;			//@cmember Ptr to RTF Object
	RTFREADOLESTREAM RTFReadOLEStream;	//@cmember RTFREADOLESTREAM to use
	DWORD		_dwFlagsShape;			//@cmember Shape flags

	WCHAR *		_szUnicode;				//@cmember String to hold Unicoded chars
	LONG		_cchUnicode;			//@cmember Size of _szUnicode in WCHARs
	DWORD		_cchMax;				//@cmember Max cch that can still be inserted
	LONG		_cpFirst;				//@cmember Starting cp for insertion

	// Object attachment placeholder list
	LONG *		_pcpObPos;
	int			_cobPosFree;
	int 		_cobPos;

	DWORD		_dwCellBrdrWdths;		//@cmember Current cell border widths
	LONG		_dyRow;					//@cmember Current row height \trrh N
	WORD		_wNumberingStyle;		//@cmember Numbering style to use
	SHORT		_iTabsLevel1;			//@cmember _iTabs for table level 1
	BYTE		_bTabType;				//@cmember left/right/center/deciml/bar tab
	BYTE		_bTabLeader;			//@cmember none/dotted/dashed/underline

	BYTE		_bBorder;				//@cmember Current border segment
	BYTE		_iCharRepBiDi;			//@cmember Default system's BiDi char repertoire
	BYTE		_bCellFlags;			//@cmember Cell flags, e.g., merge flags
	BYTE		_bShapeNameIndex;		//@cmember Shape name index
	BYTE		_bAlignment;			//@cmember Alignment for tables

	// Lexical Analyzer Functions
	void	DeinitLex();				//@cmember Release lexer storage
	BOOL	InitLex();					//@cmember Alloc lexer storage
	EC		SkipToEndOfGroup();			//@cmember Skip to matching }
	TOKEN	TokenFindKeyword(			//@cmember Find _token for szKeyword
				BYTE *szKeyword, const KEYWORD *prgKeyword, LONG cKeyword);
	TOKEN	TokenGetHex();				//@cmember Get next byte from hex input
	TOKEN	TokenGetKeyword();			//@cmember Get next control word
	TOKEN	TokenGetText(BYTE ch);		//@cmember Get text in between ctrl words
	TOKEN	TokenGetToken();			//@cmember Get next {, }, \\, or text
	BOOL 	FInDocTextDest() const;		//@cmember Is reader in document text destination
										//@cmember Send LowFi notif. if enabled
	void	CheckNotifyLowFiRTF(BOOL fEnable = FALSE); 

	// Input Functions
	LONG	FillBuffer();				//@cmember Fill input buffer
	BYTE	GetChar();					//@cmember Return char from input buffer
	BYTE	GetCharEx();				//@cmember Return char from input buffer incl \'xx
	BYTE	GetHex();					//@cmember Get next hex value from input
	BYTE	GetHexSkipCRLF();			//@cmember Get next hex value from input
	void	GetParam(char ach);			//@cmember Get keyword's numeric parameter
	void	ReadFontName(STATE *pstate, int iAllASCII);//@cmember Copy font name into state
	BOOL	UngetChar();				//@cmember Decrement input buffer ptr
	BOOL	UngetChar(UINT cch);		//@cmember Decrement input buffer ptr 'cch' times

	// Reader Functions
										//@cmember Insert text into range
	EC		AddText(WCHAR *pch, LONG cch, BOOL fNumber, BOOL fUN = FALSE);
	void	Apply_CF();					//@cmember Apply _CF changes
	SHORT	Apply_PF();					//@cmember Apply _PF changes
	COLORREF GetColor(DWORD dwMask);	//@cmember Get color _iParam for mask
	LONG	GetStandardColorIndex();	//@cmember Get std index <-> _iparam
	LONG	GetCellColorIndex();		//@cmember Get cell index <-> _iparam
	EC		HandleChar(WORD ch);		//@cmember Insert single Unicode
	EC		HandleEndGroup();			//@cmember Handle }
	EC		HandleEndOfPara();			//@cmember Insert EOP into range
	void	HandleCell();				//@cmember Handle \cell
	void	HandleCellx(LONG iParam);	//@cmember Handle \cellx
										//@cmember Handle Word EQ field
	EC		HandleEq(CTxtRange &rg, CTxtPtr &tp);
	void	HandleFieldEndGroup();		//@cmember Handle Field End Group
	EC		HandleFieldInstruction();	//@cmember	Handle field instruction
	EC		HandleFieldSymbolFont(BYTE *pch); //@cmember Handle \\f "Facename" in symbol
						//@cmember	Handle specific SYMBOL field instruction
	EC		HandleFieldSymbolInstruction(BYTE *pch, BYTE *szSymbol);
	EC		HandleNumber();				//@cmember Handle _iParam as textToken
	EC		HandleStartGroup();			//@cmember Handle {
	enum { CONTAINS_NONASCII, ALL_ASCII };
										//@cmember Insert szText into range
	EC		HandleText(BYTE *szText, int iAllASCII, LONG cchText = -1);
	EC		HandleTextToken(STATE *pstate);//@cmember Handle tokenText
	EC		HandleToken();				//@cmember Grand _token switchboard
	void	HandleUN(STATE *pstate);	//@cmember Handle \uN sequence
	BOOL	IsLowMergedCell();			//@cmember TRUE iff low merged cell
	void	Pard(STATE *pstate);		//@cmember Set default para props
	void	SelectCurrentFont(INT iFont);//@cmember Select font <p iFont>
	void	SetPlain(STATE *pstate);	//@cmember Setup _CF for \plain
	void	DelimitRow(WCHAR *szRowDelimiter);	//@cmember Insert start-of-row
	void	InitializeTableRowParms();	//@cmember Restore table parms to initial state

	// Object functions
	EC		HexToByte(BYTE *rgchHex, BYTE *pb);
	void	FreeRtfObject();
	EC		StrAlloc(WCHAR ** ppsz, BYTE * sz);
	BOOL	ObjectReadFromEditStream(void);
	BOOL	ObjectReadEBookImageInfoFromEditStream(void); //@to get e-book image info
	BOOL	StaticObjectReadFromEditStream(int cb = 0);
	BOOL	ObjectReadSiteFlags( REOBJECT * preobj);
	
	void	SetBorderParm(WORD& Parm, LONG Value);
	BOOL 	CpgInfoFromFaceName(TEXTFONT *ptf);	//@cmember Determines 
										// charset/cpg based on TEXTFONT::szName
	void	HandleSTextFlow(int mode);	//@cmember Handle S Text Flow

//@access Public Methods
public:
		//@cmember RTF reader constructor
	CRTFRead(CTxtRange *prg, EDITSTREAM *pes, DWORD dwFlags);
	inline ~CRTFRead();					//@cmember CRTFRead destructor

	LONG	ReadRtf();					//@cmember Main Entry to RTF reader

	LONG	ReadData(BYTE *pbBuffer, LONG cbBuffer); // todo friend
	LONG	ReadBinaryData(BYTE *pbBuffer, LONG cbBuffer);
	LONG	SkipBinaryData(LONG cbSkip);
	LONG	ReadRawText(char	**pszRawText);				//@cmember Read in raw text

// Member functions/data to test coverage of RTF reader
#if defined(DEBUG)
public:
	void TestParserCoverage();
private:
	CHAR *PszKeywordFromToken(TOKEN token);
	BOOL FTokIsSymbol(TOKEN tok);
	BOOL FTokFailsCoverageTest(TOKEN tok);

	BOOL _fTestingParserCoverage;

private:
	// member data for RTF tag logging
	CRTFLog *_prtflg;
#endif //DEBUG
};

/*
 *	PointsToFontHeight(cHalfPoints)
 *
 *	@func
 *		Convert half points to font heights
 *
 *	@parm int |
 *		sPointSize |		Font height in half points
 *
 *	@rdesc
 *		LONG				The corresponding CCharFormat.yHeight value
 */
#define PointsToFontHeight(cHalfPoints) (((LONG) cHalfPoints) * 10)


/*
 *	CRTFRead::~CRTFRead
 *
 *	@mdesc
 *		Destructor 
 *
 */
inline CRTFRead::~CRTFRead()
{
// TODO: Implement RTF tag logging for the Mac and WinCE
#if defined(DEBUG) && !defined(NOFULLDEBUG)
	if(_prtflg)
	{
		delete _prtflg;
		_prtflg = NULL;
	}
#endif
}
#endif // __RTFREAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_render.h ===
/*
 *	_RENDER.H
 *	
 *	Purpose:
 *		CRenderer class
 *	
 *	Authors:
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _RENDER_H
#define _RENDER_H

#include "_measure.h"
#include "_rtext.h"
#include "_osdc.h"


BOOL IsTooSimilar(COLORREF cr1, COLORREF cr2);

class CDisplay;

// ==========================  CRenderer  ==================================
// CRenderer - specialized text pointer used for rendering text

class CRenderer : public CMeasurer
{
	friend struct COls;
	friend struct CLsrun;
#ifndef NOLINESERVICES
	friend LSERR OlsDrawGlyphs(POLS,PLSRUN,BOOL,BOOL,PCGINDEX,const int*,const int*,PGOFFSET,PGPROP,
		PCEXPTYPE,DWORD,LSTFLOW,UINT,const POINT*,PCHEIGHTS,long,long,const RECT*);
	friend LSERR WINAPI OlsOleDisplay(PDOBJ pdobj, PCDISPIN pcdispin);
	friend LSERR WINAPI OlsDrawTextRun(POLS, PLSRUN, BOOL, BOOL, const POINT *,LPCWSTR, const int *,DWORD,LSTFLOW,
	UINT, const POINT *, PCHEIGHTS,	long, long,	const RECT *);
#endif

private:
    RECTUV		_rcView;			// View rect (_hdc logical coords)
    RECTUV		_rcRender;			// Rendered rect (_hdc logical coords)
    RECTUV		_rc;				// Running clip/erase rect (_hdc logical coords)
	RECTUV		_rcErase;			// Rectangle to use for erasing iff _fEraseOnFirstDraw
    LONG        _dupLine;			// Total width of line REVIEW (keithcu) still needed
	LONG		_cpAccelerator;		// Accelerator cp if any (-1 if none).

	COLORREF	_crBackground;		// Default background color
	COLORREF	_crForeDisabled;	// Foreground color for disabled text
	COLORREF	_crShadowDisabled;	// Shadow color for disabled text
	COLORREF	_crTextColor;		// Default text color

	COLORREF	_crCurBackground;	// Current background color
	COLORREF	_crCurTextColor;	// Current text color

	COffscreenDC _osdc;				// Manager for offscreen DC
	HDC			_hdc;				// Current hdc
	HDC			_hdcBitmap;			// Memory hdc for background BitBlts
	HBITMAP		_hbitmapSave;		// Saved hbitmap when _hdcMem being used
	SHORT		_dxBitmap;			// Background bitmap width
	SHORT		_dyBitmap;			// Background bitmap height

	union
	{
	  DWORD		_dwFlags;			// All together now
	  struct
	  {
		DWORD	_fDisabled:1;		// Draw text with disabled effects?
		DWORD	_fErase:1;	    	// Erase background (non transparent)
    	DWORD	_fSelected:1;   	// Render run with selection colors
		DWORD	_fLastChunk:1;		// Rendering last chunk
		DWORD	_fSelectToEOL:1;	// Whether selection runs to end of line
		DWORD	_fRenderSelection:1;// Render selection?
		DWORD	_fBackgroundColor:1;// Some text in the line has non-default 
									// background color.
		DWORD	_fEnhancedMetafileDC:1;	// Use ExtTextOutA to hack around all
										// sort of Win95FE EMF or font problems
		DWORD	_fFEFontOnNonFEWin9x:1; // have to use ExtTextOutW even for EMF.
		DWORD	_fSelectedPrev:1;	// TRUE if prev run selected
		DWORD	_fStrikeOut:1;		// TRUE if current run is struckout
		DWORD	_fEraseOnFirstDraw:1;//Draw opaquely for first run?
		DWORD	_fDisplayDC:1;		// Display dc
	  };
	};

	LOGPALETTE *_plogpalette;
	POINTUV	 	_ptCur;				// Current rendering position on screen
	BYTE		_bUnderlineType;	// Underline type
	COLORREF	_crUnderlineClr;	// Underline color

			void	Init();			// Initialize most members to zero

			void	UpdatePalette(COleObject *pobj);

			void	RenderText(const WCHAR* pch, LONG cch);

			BOOL	SetNewFont();
			BOOL	FindDrawEntry(LONG cp);

	//Rotation wrappers;
			void	EraseTextOut(HDC hdc, const RECTUV *prc, BOOL fSimple = FALSE);
		
			BOOL 	RenderChunk(LONG &cchChunk, const WCHAR *pchRender, LONG cch);
			LONG	RenderTabs(LONG cchChunk);
			BOOL	RenderBullet();

public:
	CRenderer (const CDisplay * const pdp);
	CRenderer (const CDisplay * const pdp, const CRchTxtPtr &rtp);
	~CRenderer ();

	        void    operator =(const CLine& li)     {*(CLine*)this = li;}

			BOOL	IsSimpleBackground() const;
			void	RenderExtTextOut(POINTUV ptuv, UINT fuOptions, RECT *prc, PCWSTR pch, UINT cch, const INT *rgdxp);

			BOOL	EraseRect(const RECTUV *prc, COLORREF crBack);
			void	EraseLine();

			COLORREF GetDefaultBackColor() const	{return _crBackground;}
			COLORREF GetDefaultTextColor() const	{return _crTextColor;}
			COLORREF GetTextColor(const CCharFormat *pCF);
			void	SetDefaultBackColor(COLORREF cr);
			void	SetDefaultTextColor(COLORREF cr);
			void	SetTextColor(COLORREF cr);
			void	SetSelected(BOOL f)				{_fSelected = f;}
			void	SetErase(BOOL f)				{_fErase = f;}

	const	POINTUV& GetCurPoint() const			{return _ptCur;}
			void	SetCurPoint(const POINTUV &pt)	{_ptCur = pt;}
			void	SetRcView(const RECTUV *prcView){_rcView = *prcView; _rcRender = *prcView;}
			void	SetRcViewTop(LONG top)			{_rcView.top = top;}
			void	SetRcBottoms(LONG botv, LONG botr)	{_rcView.bottom = botv; _rcRender.bottom = botr;}
	const	RECTUV&	GetRcRender()					{return _rcRender;}
	const	RECTUV&	GetRcView()						{return _rcView;}

	const	RECTUV&	GetClipRect() const				{return _rc;}
			void	SetClipRect(void);
            void    SetClipLeftRight(LONG dup);
			HDC		GetDC()	const					{return _hdc;}

			BOOL	StartRender(const RECTUV &rcView, const RECTUV &rcRender);

			LONG	DrawTableBorders(const CParaFormat *pPF, LONG x, LONG yHeightRow, 
									 LONG iDrawBottomLine, LONG dulRow,
									 const CParaFormat *pPFAbove);
			COLORREF GetColorFromIndex(LONG icr, BOOL fForeColor,
									   const CParaFormat *pPF) const;
			COLORREF GetShadedColorFromIndices(LONG icrf, LONG icrb, LONG iShading,					//@parm Shading in .01 percent
									   const CParaFormat *pPF) const;
			void	DrawWrappedObjects(CLine *pliFirst, CLine *pliLast, LONG cpFirst, const POINTUV &ptFirst);
			void	EndRender(CLine *pliFirst, CLine *pliLast, LONG cpFirst, const POINTUV &ptFirst);
			void	FillRectWithColor(const RECTUV *prc, COLORREF cr);
			void 	NewLine (const CLine &li);
			BOOL	RenderLine(CLine &li, BOOL fLastLine);
			void	RenderOffscreenBitmap(HDC hdc, LONG dup, LONG dvp);
			BOOL	RenderOutlineSymbol();
			HDC		StartLine(CLine &li, BOOL fLastLine, LONG &cpSelMin, LONG &cpSelMost, LONG &dup, LONG &dvp);
			void	EraseToBottom();
			void	EndLine(HDC hdcSave, LONG dup, LONG dvp);
			void	RenderStrikeOut(LONG upStart, LONG vpStart, LONG dup, LONG dvp);
			void	RenderUnderline(LONG upStart, LONG vpStart, LONG dup, LONG dvp);
			void	DrawLine(const POINTUV &ptStart, const POINTUV &ptEnd);
			void	SetFontAndColor(const CCharFormat *pCF);
			HDC		SetupOffscreenDC(LONG& dup, LONG& dvp, BOOL fLastLine);
			void	SetupUnderline(BYTE bULType, BYTE bULColorIdx, COLORREF crULColor = tomAutoColor);
			CONVERTMODE	GetConvertMode();
			BOOL	fFEFontOnNonFEWin9x()			{return _fFEFontOnNonFEWin9x;}
			BOOL	UseXOR(COLORREF cr);
			BOOL	fDisplayDC() { return _fDisplayDC; }
};

/*
 * 	BottomOfRender (rcView, rcRender)
 *
 *	@mfunc
 *		Calculate maximum logical unit to render.
 *
 *	@rdesc
 *		Maximum pixel to render
 *
 *	@devnote
 *		This function exists to allow the renderer and dispml to be able
 *		to calculate the maximum pixel for rendering in exactly the same
 *		way.
 */
inline LONG BottomOfRender(const RECTUV& rcView, const RECTUV& rcRender)
{
	return min(rcView.bottom, rcRender.bottom);
}		

class CBrush
{
	COLORREF	_cr;		// Current color
	HBRUSH		_hbrushOld;	// HBRUSH when CBrush is created
	HBRUSH		_hbrush;	// Current HBRUSH
	CRenderer *	_pre;		// Renderer to use (for rotation)

public:
	CBrush(CRenderer *pre) {_pre = pre; _hbrush = 0;} 
	~CBrush();

	void	Draw(LONG u1, LONG v1, LONG u2, LONG v2, LONG dxpLine,
				 COLORREF cr, BOOL fHideGridlines);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_ols.h ===
/*
 *  _OLS.H
 *  
 *  Purpose:
 *		COls Line Services object class used to connect RichEdit with
 *		Line Services.
 *  
 *  Authors:
 *		Original RichEdit LineServices code: Rick Sailor
 *		Murray Sargent
 *
 *	Copyright (c) 1997-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _OLS_H
#define _OLS_H

#include "_common.h"
#include "_cfpf.h"
#ifndef NOCOMPLEXSCRIPTS
#include "usp10.h"
#endif

#define CP_BULLET			0x80000000

// ===============================  CLsrun =====================================
// CLsrun - LineServices run structure
struct CLsrun
{
	LONG				_cp;	// the starting cp of the run
	const CCharFormat*	_pCF;	// pointer to the character formatting
	struct CLsrun*		_pNext;	// next linked (shaped together) run
#ifndef NOCOMPLEXSCRIPTS
	SCRIPT_ANALYSIS		_a;		// run's analysis (will be 0 if non-complex script)
#endif
private:
	BYTE		_fSelected:1;	// Is this run selected?
	BYTE		_fFallback:1;	// Is font fallback applied?
public:
	void	SetSelected(BOOL fSelected) {_fSelected = fSelected;}
	BOOL	IsSelected();
	BOOL	IsBullet() {return _cp & CP_BULLET;}
	void	SetFallback(BOOL fFallback) {_fFallback = fFallback;}
	BOOL	IsFallback() {return _fFallback;}
};

// ===============================  CLsrunChunk =====================================
// CLsrunChunk - Manages a chunk of PLSRUNs
class CLsrunChunk
{
public:
	PLSRUN _prglsrun;
	int		_cel;
};

// ===============================  COls  =====================================
// COls - LineServices object class

class CTxtEdit;
class CMeasurer;
class CDispDim;

struct COls
{
public:
	CMeasurer *_pme;				// Active CMeasurer or CRenderer
	PLSLINE	   _plsline;			// Line cache
	LONG	   _cp;					// cpMin for _plsline
	const CDisplay *_pdp;			// Current Display object, used to determine if display
									// object changed without receiving focus messages
	CArray<long> _rgcp;				// Array for CP mapping
	CArray<CLsrunChunk> _rglsrunChunk;	// Array of ClsrunChunks


	// Note: might be better to alloc the following only if needed
	LSTBD _rgTab[MAX_TAB_STOPS];	// Buffer used by pfnFetchTabs
	WCHAR _szAnm[CCHMAXNUMTOSTR + 4];//numbering + braces + space + end character
	WCHAR _rgchTemp[64];			// Temporary buffer for passwords and allcaps, etc.
	int			_cchAnm;			// cch in use
	CCharFormat _CFBullet;			// Character formatting for anm run
	LONG		_cEmit;				// Brace emitting protection (0 - balance)

	COls() {}
	~COls();

	//CP matching, reverser brace support
	LONG GetCpLsFromCpRe(LONG cpRe);
	LONG GetCpReFromCpLs(LONG cpLs);
	LONG BracesBeforeCp(LONG cpLs);
	BOOL AddBraceCp(LONG cpLs);

	PLSRUN CreatePlsrun(void);

	void QueryLineInfo(LSLINFO &lslinfo, LONG *pupStart, LONG *pdupWidth);
	BOOL SetLsChp(DWORD dwObjId, PLSRUN plsrun, PLSCHP plschp);
	BOOL SetRun(PLSRUN plsrun);
	PLSRUN GetPlsrun(LONG cp, const CCharFormat *pCF, BOOL fAutoNumber);
	LSERR WINAPI FetchAnmRun(long cp, LPCWSTR *plpwchRun, DWORD *pcchRun,
							 BOOL *pfHidden, PLSCHP plsChp, PLSRUN *pplsrun);
	void	CchFromUp(POINTUV pt, CDispDim *pdispdim, LONG *pcpActual);
	void	CreateOrGetLine();
	void	DestroyLine(CDisplay *pdp);
	HRESULT	Init(CMeasurer *pme); 
	BOOL	MeasureLine(CLine *pliTarget);
	LONG	MeasureText(LONG cch, UINT taMode, CDispDim *pdispdim);
	BOOL	RenderLine(CLine &li, BOOL fLastLine);
	CMeasurer * GetMeasurer() {return _pme;}
	CRenderer * GetRenderer() {return (CRenderer*) _pme;}

};

extern COls* g_pols;
extern const LSIMETHODS vlsimethodsOle;
extern CLineServices *g_plsc;		// LineServices Context

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_tomdoc.h ===
/*
 *	@doc TOM
 *
 *	@module _tomdoc.H -- CTxtDoc Class |
 *	
 *		This class implements the TOM ITextDocument interface
 *	
 *	@devnote
 *		This class depends on the internal RichEdit CTxtStory class, but is
 *		separate, that is, a CTxtDoc has a ptr to the internal CTxtStory,
 *		rather than CTxtDoc deriving from ITextDocument.  This choice
 *		was made so that edit control instances that don't use the
 *		ITextDocument interface don't have to have the extra vtable ptr.
 *
 *		When this class is destroyed, it doesn't destroy the internal
 *		CTxtStory object (CTxtEdit::_pdoc).  However the TOM client's
 *		perception is that the document is no longer in memory, so the internal
 *		document should be cleared.  It's the client's responsibility to save
 *		the document, if desired, before releasing it.
 *
 *	@future
 *		Generalize so that CTxtDoc can handle multiple CTxtStory's.
 */

#ifndef _tomdoc_H
#define _tomdoc_H

#include "_range.h"

class CTxtDoc : public ITextDocument
{
//@access Public methods
public:
	CTxtDoc(CTxtEdit *ped);

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDispatch methods
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

    // ITextDocument methods
	STDMETHODIMP GetName (BSTR * pName);		//@cmember Get document filename
	STDMETHODIMP GetCount (long *pCount);		//@cmember Get count of stories in document
	STDMETHODIMP _NewEnum(IEnumRange **ppenum);	//@cmember Get stories enumerator
	STDMETHODIMP Item (long Index, ITextRange **pprange);//@cmember Get <p Index>th story
	STDMETHODIMP Save (VARIANT * pVar);			//@cmember Save this document
	STDMETHODIMP BeginEditCollection ();		//@cmember Turn on undo grouping
	STDMETHODIMP EndEditCollection ();			//@cmember Turn off undo grouping

//@access Private data
private:
	CTxtEdit *		_ped;		//@cmember CTxtEdit this belongs to
	TCHAR *			_pName;		//@cmember Filename of document
	LONG			_cRefs;		//@cmember Reference count
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_undoid.h ===
/*
 *	_undoid.h
 *
 *	Purpose:
 *		Undo ID defintions.  These ID's are used to lookup string names
 *		in our resources for the various undo operations
 *
 *	Author:
 *		AlexGo  4/13/95
 */

#ifndef __UNDOID_H__
#define __UNDOID_H__

//
//	typing operations
//

#define UID_TYPING			1
#define	UID_REPLACESEL		2
#define UID_DELETE			3

//
//	data transfer operations
//

#define	UID_DRAGDROP		4
#define UID_CUT				5
#define UID_PASTE			6
#define UID_LOAD			7

#endif // __UNDOID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_textnot.h ===
/*
 *	_TXTNOT.H
 *
 *	Purpose:
 *		Text Notification Manager declarations
 *
 *	Author:
 *		Honwch	1/12/2000
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _TXTNOT_H_
#define _TXTNOT_H_

#include "_notmgr.h"

class CTxtEdit;

/*
 *	CTextNotify
 *
 *	@class
 *		CTextNotify forwards notification to Messgae Filter
 *
 */
class CTextNotify : public ITxNotify
{
//@access Public Methods
public:
	CTextNotify(CTxtEdit * ped) { _ped = ped; }
	~CTextNotify();
	//
	// ITxNotify Interface
	//
	void 	OnPreReplaceRange( 
				LONG cp, 
				LONG cchDel, 
				LONG cchNew,
				LONG cpFormatMin, 
				LONG cpFormatMax, 
				NOTIFY_DATA *pNotifyData );

	void 	OnPostReplaceRange( 
				LONG cp, 
				LONG cchDel, 
				LONG cchNew,
				LONG cpFormatMin, 
				LONG cpFormatMax, 
				NOTIFY_DATA *pNotifyData );

	void	Zombie() {_ped = NULL;};

	BOOL	Add(ITxNotify *pMsgFilterNotify);
	BOOL	Remove(ITxNotify *pMsgFilterNotify);

//@access Protected Methods
protected:
	CTxtEdit	*_ped;
	ITxNotify	*_pMsgFilterNotify;
};

#endif _TXTNOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_text.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _TEXT.H	-- Declaration for a CTxtRun pointer |
 *	
 *	CTxtRun pointers point at the plain text runs (CTxtArray) of the
 *	backing store and derive from CRunPtrBase via the CRunPtr template.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _TEXT_H
#define _TEXT_H

#include "_runptr.h"
#include "_doc.h"
#include "textserv.h"
#include "_m_undo.h"

class CRchTxtPtr;
class CTxtEdit;
class CTxtIStream;

/*
 *	CTxtPtr
 *
 *	@class
 *		provides access to the array of characters in the backing store
 *		(i.e. <c CTxtArray>)
 *
 *	@base 	public | CRunPtr<lt>CTxtArray<gt>
 *
 *	@devnote
 *		The state transitions for this object are the same as those for
 *		<c CRunPtrBase>.  <md CTxtPtr::_cp> simply caches the current
 *		cp (even though it can be derived from _iRun and _ich).  _cp is
 *		used frequently enough (and computing may be expensive) that 
 *		caching the value is worthwhile.
 *
 *		CTxtPtr's *may* be put on the stack, but do so with extreme
 *		caution.  These objects do *not* float; if a change is made to 
 *		the backing store while a CTxtPtr is active, it will be out
 *		of sync and may lead to a crash.  If such a situation may 
 *		exist, use a <c CTxtRange> instead (as these float and keep 
 *		their internal text && format run pointers up-to-date).  
 *
 *		Otherwise, a CTxtPtr is a useful, very lightweight plain 
 *		text scanner.
 */

// FindEOP() result flags.  Low byte used for cchEOP
#define FEOP_CELL	256
#define FEOP_EOP	512

// FindWhiteSpace input flags
#define FWS_SKIP		1
#define FWS_BOUNDTOPARA	2
#define FWS_MOVE	256

class CTxtPtr : public CRunPtr<CTxtBlk>
{
	// Only CRchTxtPtr is allowed to call private methods like replace range.  
	friend class CRchTxtPtr;

//@access Public Methods
public:
#ifdef DEBUG
	BOOL Invariant( void ) const;		//@cmember	Invariant checking
	void Update_pchCp() const;
	void MoveGapToEndOfBlock () const;
#endif	// DEBUG

	CTxtPtr(CTxtEdit *ped, LONG cp);	//@cmember	Constructor
	CTxtPtr(const CTxtPtr &tp);			//@cmember	Copy Constructor

	LONG	GetText(LONG cch, TCHAR *pch);	//@cmember 	Fetch <p cch> chars
#ifndef NOCOMPLEXSCRIPTS
									//@cmember Fetch <p cch> chars with usp xlat	
	LONG	GetTextForUsp(LONG cch, TCHAR *pch, BOOL fNeutralOverride);
#endif
	LONG	GetPlainText(LONG cch, WCHAR *pchBuff,
					LONG cpMost, BOOL fTextize, BOOL fUseCRLF = TRUE);
	WCHAR	NextCharCount(LONG& cch);	//@cmember Move, GetChar, decrement
	WCHAR	NextChar();				//@cmember Advance to & return next char
	WCHAR	PrevChar();				//@cmember Backup to & return previous char
	WCHAR	GetChar();				//@cmember Fetch char at current cp
	WCHAR	GetPrevChar();			//@cmember Fetch char at previous cp
	LONG	GetTextLength() const;	//@cmember Get total cch for this document
	const WCHAR* GetPch(LONG& cchValid) const;//@cmember	Get ptr to block of chars

							//@cmember	Get ptr to a reverse block of chars
	const WCHAR* GetPchReverse(LONG& cchValidReverse, LONG* pcchValid = NULL) const;
	QWORD	GetCharFlagsInRange(LONG cch, BYTE bCharSetDefault);

	// The text array has its own versions of these methods (overuling
	// those in runptr base so that <md CTxtPtr::_cp> can be correctly
	// maintained.

	LONG	BindToCp(LONG cp);	//@cmember Rebinds text pointer to cp
	LONG 	SetCp(LONG cp);		//@cmember Sets the cp for the run ptr
	LONG	GetCp() const 		//@cmember Gets the current cp
	{ 
		// NB! Don't do invariant checking here so floating
		// range mechanism can work OK
		return _cp; 
	};
	void	Zombie();			//@cmember Turn this tp into a zombie

	LONG	Move(LONG cch);		//@cmember Move cp by cch chars
	
	// Advance/backup/adjust safe over CRLF and UTF-16 word pairs
	LONG	AdjustCRLF(LONG iDir = -1);//@cmember Backup to start of multichar
	LONG	AdvanceCRLF(BOOL fMulticharAdvance = TRUE);	//@cmember	Advance over multichar
							 	//@cmember Backup over multichar 
	LONG	BackupCRLF(BOOL fMulticharBackup = TRUE);
	BOOL	IsAtStartOfCell();	//@cmember Does GetCp() follow a CELL or SOTR?
	BOOL	IsAfterEOP();		//@cmember Does GetCp() follow an EOP?
	BOOL	IsAfterTRD(WCHAR ch);//@cmember Does _cp follow table-row delimiter?
	BOOL	IsAtBOSentence();	//@cmember At beginning of a sentence?
	BOOL	IsAtBOWord();		//@cmember At beginning of word?
	BOOL	IsAtEOP();			//@cmember Is _cp at an EOP marker?
	BOOL	IsAtTRD(WCHAR ch);	//@cmember Is _cp at table-row delimiter?
	LONG	MoveWhile(LONG cchRun, WCHAR chFirst, WCHAR chLast, BOOL fInRange);
	
	// Search
								//@cmember Find indicated text
	LONG	FindText(LONG cpMost, DWORD dwFlags, WCHAR const *pch, LONG cch);
								//@cmember Find next EOP
	LONG	FindEOP(LONG cchMax, LONG *pResults = NULL);
								//@cmember Find next exact	match to <p pch>
	LONG	FindExact(LONG cchMax, WCHAR *pch);
	LONG	FindBOSentence(LONG cch);	//@cmember	Find beginning of sentence
	LONG	FindOrSkipWhiteSpaces(LONG cchMax, DWORD dwFlags = 0, DWORD* pdwResult = NULL);
	LONG	FindWhiteSpaceBound(LONG cchMin, LONG& cpStart, LONG& cpEnd, DWORD dwFlags = 0);

	// Word break support
	LONG	FindWordBreak(INT action, LONG cpMost = -1);//@cmember	Find next word break
	LONG	TranslateRange(LONG cch, UINT CodePage,
						   BOOL fSymbolCharSet, IUndoBuilder *publdr);

//@access	Private methods and data
private:
							//@cmember	Replace <p cchOld> characters with 
							// <p cchNew> characters from <p pch>
	LONG	ReplaceRange(LONG cchOld, LONG cchNew, WCHAR const *pch,
									IUndoBuilder *publdr, IAntiEvent *paeCF,
									IAntiEvent *paePF);

							//@cmember	undo helper
	void 	HandleReplaceRangeUndo(LONG cchOld, LONG cchNew, 
						IUndoBuilder *publdr, IAntiEvent *paeCF,
						IAntiEvent *paePF); 

									//@cmember	Insert a range of text helper
									// for ReplaceRange					
	LONG 	InsertRange(LONG cch, WCHAR const *pch);
	void 	DeleteRange(LONG cch);	//@cmember  Delete range of text helper
									// for ReplaceRange
		// support class for FindText
	class CTxtFinder
	{
	public:
		BOOL FindText(const CTxtPtr &tp, LONG cpMost, DWORD dwFlags, 
					  const WCHAR *pchToFind, LONG cchToFind, 
					  LONG &cpFirst, LONG &cpLast);
		//@cmember Same functionality as CTxtPtr::FindText wrapper
		
	private:
		inline BOOL CharComp(WCHAR ch1, WCHAR ch2) const;
		inline BOOL CharCompIgnoreCase(WCHAR ch1, WCHAR ch2) const;
		LONG FindChar(WCHAR ch, CTxtIStream &tistr);	
		//@cmember Advances cp to char matching ch from CTxtIStream
		LONG MatchString(const WCHAR *pchToFind, LONG cchToFind, CTxtIStream &tistr);
		//@cmember Advances cp if chars in pchToFind match next chars from CTxtIStream
		LONG MatchStringBiDi(const WCHAR *pchToFind, LONG cchToFind, CTxtIStream &tistr);
		//@cmember Like MatchString, but with checks for special Arabic/Hebrew chars
		
		LONG _cchToSearch;		//@cmember # of chars to search for current FindText call
		BOOL _fSearchForward;
		BOOL _fIgnoreCase;
		BOOL _fMatchAlefhamza;	//@cmember Flags derived from dwFlags from FindText for
		BOOL _fMatchKashida;	//	Arabic/Hebrew searches
		BOOL _fMatchDiac;
		int _iDirection;		//@cmember +/-1 to step through pchToFind
	};

	LONG		_cp;		//@cmember	Character position in text stream
#ifdef DEBUG
	const WCHAR *_pchCp;	// Points to string at cp for ease in debugging
#endif

public:
	CTxtEdit *	_ped;		//@cmember	Ptr to text edit class needed for
							//  things like word break proc and used a lot
							//  by derived classes
};

/*
 *	CTxtIStream
 *
 *	@class
 *		Refinement of the CTxtPtr class which implements an istream-like interface.
 *		Given a CTxtPtr and a direction, a CTxtFinder object returns a char
 *		for every call to GetChar.  No putzing around with the buffer gap is 
 *		necessary, and expensive calls to Move and GetPch are kept to an
 *		absolute minimum.
 *		
 *	@base 	private | CTxtPtr
 *
 *	@devnote
 *		At present, this class is used in the implementation of the CTxtFinder
 *		class.  Finds require fast scanning of the sequence of characters leading
 *		in either direction from the cp.  Calls to Move and GetPch slow down
 *		such scanning significantly, so this class implements a unidirectional 
 *		istream-like scanner which avoids unnecessary calls to these expensive
 *		CTxtPtr methods.
 */
class CTxtIStream : private CTxtPtr
{
public:
	enum { DIR_FWD, DIR_REV };
	typedef WCHAR (CTxtIStream::*PFNGEWCHAR)();

							//@cmember Creates istr to read in iDir
	CTxtIStream(const CTxtPtr &tp, int iDir);

	inline WCHAR GetChar() 	//@cmember Returns next char in stream dir
		{ return (this->*_pfnGetChar)(); }
 
private:
	WCHAR GetNextChar();	//@cmember Returns next char in fwd dir	
	WCHAR GetPrevChar();	//@cmember Returns next char in rev dir

 	void FillPchFwd();		//@cmember Refreshes _pch and _cch with chars in fwd dir
 	void FillPchRev();		//@cmember Refreshes _pch and _cch with chars in rev dir

	PFNGEWCHAR _pfnGetChar;	//@cmember Func ptr to routine which get next char in iDir
	LONG _cch;				//@cmember Count of valid chars in _pch in iDir
	const WCHAR *_pch;		//@cmember Next _cch chars in iDir
};

// =======================   Misc. routines  ====================================================

void	TxCopyText(WCHAR const *pchSrc, WCHAR *pchDst, LONG cch);
//LONG	TxFindEOP(const WCHAR *pchBuff, LONG cch);
INT		CALLBACK TxWordBreakProc(WCHAR const *pch, INT ich, INT cb, INT action);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_runptr.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RUNPTR.H -- Text run and run pointer class defintion |
 *	
 *	Original Author:	<nl>
 *		Christian Fortini
 *
 *	History: <nl>
 *		6/25/95	alexgo	Commenting and Cleanup
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#ifndef _RUNPTR_H
#define _RUNPTR_H

#include "_array.h"
#include "_doc.h"

typedef CArray<CTxtRun> CRunArray;

/*
 *	CRunPtrBase
 *
 *	@class	Base run pointer functionality.  Keeps a position within an array
 *  	of text runs.
 *
 *	@devnote	Run pointers go through three different possible states :
 *
 *	NULL:	there is no data and no array (frequently a startup condition) <nl>
 *			<mf CRunPtrBase::SetRunArray> will transition from this state to 
 *			the Empty state.  It is typically up to the derived class to
 *			define when that method should be called. IsValid() fails. <nl>
 *
 *			<md CRunPtrBase::_pRuns> == NULL <nl>
 *			<md CRunPtrBase::_iRun> == 0 <nl>
 *			<md CRunPtrBase::_ich> == 0 <nl>
 *
 *	Empty:	an array class exists, but there is no data (can happen if all 
 *			of the elements in the array are deleted).  IsValid() fails.<nl>
 *	 		<md CRunPtrBase::_pRuns> != NULL <nl>
 *			<md CRunPtrBase::_iRun> == 0 <nl>
 *			<md CRunPtrBase::_ich> <gt>= 0 <nl>
 *			<md CRunPtrBase::_pRuns-<gt>Count()> == 0 <nl>
 *
 *	Normal:	the array class exists and has data; IsValid() succeeds and
 *			<md CRunPtrBase::_pRuns-<gt>Elem[] is defined <nl>
 *			<md CRunPtrBase::_pRuns> != NULL <nl>
 *			<md CRunPtrBase::_iRun> >= 0 <nl>
 *			<md CRunPtrBase::_ich> >= 0 <nl>
 *			<md _pRuns>-<gt>Count() > 0 <nl>		
 *	
 *	Note that in order to support the empty and normal states, the actual 
 *	array element at <md CRunPtrBase::_iRun> must be explicitly fetched in
 *	any method that may need it.
 *
 *	Currently, there is no way to transition to the NULL state from any of
 *  the other states.  If we needed to, we could support that by explicitly 
 *	fetching the array from the document on demand.
 *
 *	Note that only <md CRunPtrBase::_iRun> is kept.  We could also keep 
 * 	a pointer to the actual run (i.e. _pRun).  Earlier versions of this
 *	engine did in fact do this.  I've opted to not do this for several
 *	reasons: <nl>
 *		1. If IsValid(), _pRun is *always* available by calling Elem(_iRun).
 * 		Therefore, there is nominally no need to keep both _iRun and _pRun.<nl>
 *		2. Run pointers are typically used to either just move around
 *		and then fetch data or move and fetch data every time (like during 
 *		a measuring loop).  In the former case, there is no need to always
 *		bind _pRun; you can just do it on demand.  In the latter case, the
 *		two models are equivalent.  
 */

class CRunPtrBase
{
	friend class CDisplayML;
	friend class CDisplaySL;

//@access Public methods
public:

#ifdef DEBUG
	BOOL	Invariant() const;				//@cmember	Invariant tests
	void	ValidatePtr(void *pRun) const;	//@cmember	Validate <p pRun>
	LONG 	CalcTextLength() const;			//@cmember  Get total cch in runs
#define	VALIDATE_PTR(pRun)	ValidatePtr(pRun)

#else
#define	VALIDATE_PTR(pRun)
#endif // DEBUG

	CRunPtrBase(CRunArray *pRuns);			//@cmember	Constructor
	CRunPtrBase(CRunPtrBase& rp);			//@cmember	Constructor

	// Run Control
	void	SetRunArray(CRunArray *pRuns)	//@cmember Set run array for this
	{										// run ptr
		_pRuns = pRuns;
	}
	BOOL 	SetRun(LONG iRun, LONG ich);	//@cmember Set this runptr to run
											// <p iRun> & char offset <p ich>
	BOOL	NextRun();						//@cmember Advance to next run
	BOOL	PrevRun();						//@cmember Go back to prev run
	BOOL	ChgRun(LONG cRun)				//@cmember Move <p cRun> runs
	{										// returning TRUE if successful
		return SetRun(_iRun + cRun, 0);
	}	
											//@cmember Count <p cRun> runs 
	LONG	CountRuns(LONG &cRun,			// returning cch counted and
				LONG cchMax,				// updating <p cRun>
				LONG cp,
				LONG cchText) const;
											//@cmember Find run range limits
	void	FindRun (LONG *pcpMin,
				LONG *pcpMost, LONG cpMin, LONG cch, LONG cchText) const;

	CTxtRun * GetRun(LONG cRun) const;		//@cmember Retrieve run element at 
											// offset <p cRun> from this run
	LONG	Count() const					//@cmember	Get count of runs
	{
		return _pRuns->Count();
	}
	BOOL	SameRuns(CRunPtrBase *prp)		//@cmember Return TRUE iff same runs
	{
		return _pRuns == prp->_pRuns;
	}
	BOOL	SameRun(CRunPtrBase *prp)
	{
		return SameRuns(prp) && _iRun == prp->_iRun;
	}

	// Character position control
								//@cmember	Set cp for this run ptr = <p cp>
	LONG 	BindToCp(LONG cp, LONG cchText = tomForward);
	LONG 	CalculateCp() const;//@cmember	Add _cch's up to _iRun, _ich
	LONG	Move(LONG cch);		//@cmember	Move cp by <p cch> chars

	void 	AdjustBackward();	//@cmember	If on the edge of two runs, 
								// adjust to end of left (previous) run
	void	AdjustForward();	//@cmember	If at the edge of two runs,
								// adjust to start of right (next) run
	LONG 	GetIch() const		//@cmember	Return <md CRunPtrBase::_ich>
				{Assert(IsValid()); return _ich;}
	LONG 	GetIRun() const		//@cmember	Return <md CRunPtrBase::_iRun>
				{Assert(IsValid()); return _iRun;}
	void 	SetIch(LONG ich)	//@cmember	Set <md CRunPtrBase::_ich>
				{Assert(IsValid()); _ich = ich;}
	LONG	GetCchLeft() const;	//@cmember	Return GetRun(0)->_cch - GetIch()								
	inline BOOL	IsValid() const	//@cmember	Return FALSE if run ptr is in
	{							// empty or NULL states.  TRUE otherwise
		return _pRuns && _pRuns->Count();
	}

	void	SetToNull();		//@cmember	Clears data from run pointer

//@access Protected Data
protected:
	CRunArray *	_pRuns;	    	//@cmember	Pointer to CTxtRun array
	LONG 		_iRun;  	    //@cmember	Index of current run in array
	LONG 		_ich;		    //@cmember	Char offset inside current run
};


/*
 *	CRunPtr	(template)
 *
 *	@class	a template over CRunPtrBase allowing for type-safe versions of
 *		run pointers
 * 
 *	@tcarg	class 	| CElem | run array class to be used
 *
 *	@base	public | CRunPtrBase
 */
template <class CElem>
class CRunPtr : public CRunPtrBase
{
public:
	CRunPtr (void)								//@cmember	Constructor
		: CRunPtrBase (0) {}
	CRunPtr (CRunArray *pRuns)					//@cmember	Constructor
		: CRunPtrBase (pRuns) {}
	CRunPtr (CRunPtrBase& rp)					//@cmember	Constructor
		: CRunPtrBase (rp) {}

	// Array management 
										
	CElem *	Add (LONG cRun, LONG *pielIns)	//@cmember Add <p cRun> 	
	{											// elements at end of array
		return (CElem *)_pRuns->Add(cRun, pielIns);
	}
										
	CElem *	Insert (LONG cRun)					//@cmember Insert <p cRun>
	{											// elements at current pos
		return (CElem *)_pRuns->Insert(_iRun, cRun);
	}
										
	void 	Remove (LONG cRun)	//@cmember Remove <p cRun>
	{											// elements at current pos
		_pRuns->Remove (_iRun, cRun);
	}
										//@cmember	Replace <p cRun> elements
										// at current position with those
										// from <p parRun>
	BOOL 	Replace (LONG cRun, CArrayBase *parRun)
	{
		return _pRuns->Replace(_iRun, cRun, parRun);
	}

	CElem *	Elem(LONG iRun) const		//@cmember	Get ptr to run <p iRun>
	{
		return (CElem *)_pRuns->Elem(iRun);
	}
										
	CElem *	GetRun(LONG cRun) const		//@cmember	Get ptr <p cRun> runs
	{									//  away from current run
		return Elem(_iRun + cRun);
	}

	void	IncPtr(CElem *&pRun) const	//@cmember	Increment ptr <p pRun>
	{
		VALIDATE_PTR(pRun);				// Allow invalid ptr after ++ for
		pRun++;							//  for loops
	}
										
	CElem *	GetPtr(CElem *pRun, LONG cRun) const//@cmember Get ptr <p cRun>
	{											// runs away from ptr <p pRun>
		VALIDATE_PTR(pRun + cRun);
		return pRun + cRun;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_txtbrk.h ===
/*
 *		Text Breaker & Bit stream break array class definition
 *		
 *		File:    _txtbrk.h
 * 		Create:  Mar 29, 1998
 *		Author:  Worachai Chaoweeraprasit (wchao)
 *
 *		Copyright (c) 1998, Microsoft Corporation. All rights reserved.
 */


#ifndef _TXTBRK_H
#define _TXTBRK_H

// DEBUG definition
#ifdef BITVIEW
#define	BVDEBUG		_DEBUG
#define Assert		ASSERT
#else
#define BVDEBUG		DEBUG
#endif


// The number of buffer breaks before the sync point
#define	CWORD_TILLSYNC		3	// Thai wordbreak engine is expected to be in sync within 3 words
#define CCLUSTER_TILLSYNC	1	// Indic cluster is normally in sync in within 1

// Abstract Data type
#define ITEM				UINT

// CPU register size
//#define RSIZE				(sizeof(ITEM)*8)
#define RSIZE				32

// Mask most/least significant <n> bits
#define MASK_LOW(u, n)		( ((ITEM)(u)) & (1<<(n))-1 )
#define MASK_HIGH(u, n)		~MASK_LOW(u, RSIZE-n)

// BreakArray Exit convention
#ifdef BVDEBUG
#define PUSH_STATE(x,y,z)	PushState(x,y,z)
#define VALIDATE(x)			Validate(x)
#else
#define PUSH_STATE(x,y,z)
#define VALIDATE(x)			x
#endif

// Who put the state?
#define INSERTER			0
#define REMOVER				1
#define COLLAPSER			2
#define REPLACER			3


#ifdef BVDEBUG
typedef struct {
	LONG	who;
	LONG	ibGap;
	LONG	cbGap;
	LONG	cbBreak;
	LONG	cbSize;
	LONG	cp;
	LONG	cch;
} BVSTATE;
#endif

class CBreakArray : public CArray<ITEM>
{
public:
#ifdef BITVIEW
	friend class CBitView;
#endif

	CBreakArray();
	~CBreakArray() {}

	BOOL		IsValid() const { return Count() > 0; }
	void		CheckArray();

	LONG		InsertBreak (LONG cp, LONG cch);
	LONG		RemoveBreak (LONG cp, LONG cch);
	LONG 		ReplaceBreak (LONG cp, LONG cchOld, LONG cchNew);
	void		ClearBreak (LONG cp, LONG cch);
	void		SetBreak (LONG cp, BOOL fOn);
	BOOL		GetBreak (LONG cp);

	LONG		CollapseGap (void);
private:

	// n-Bits shifting methods
	void		ShUp (LONG iel, LONG cel, LONG n);
	void		ShDn (LONG iel, LONG cel, LONG n);

	// Size (in bits)
	LONG		_ibGap;			// offset from start of array to gap
	LONG		_cbGap;			// gap size
	LONG		_cbBreak;		// number of valid break
	LONG		_cbSize;		// bit array size (excluded the sentinel element)
#ifdef BITVIEW
	LONG		_cCollapse;		// how many time collapse?
#endif

public:
	LONG		GetCchBreak() { return _cbBreak; }
#ifdef BVDEBUG
	LONG		GetCbSize() { return _cbSize; }
	LONG		Validate(LONG cchRet);		
	void		PushState(LONG cp, LONG cch, LONG who);
#endif
#ifdef BITVIEW
	LONG		SetCollapseCount();
#endif

protected:
#ifdef BVDEBUG
	BVSTATE		_s;
#endif
	LONG		AddBreak(LONG cp, LONG cch);
};


#ifndef BITVIEW


///////	Complex script text breaker class
// 
//		The engine to handle cluster and (dictionary-based) word breaking method
//		used by most SouthEast Asian languages such as Thai, Lao, Burmese etc.
//
//		Create: Mar 12, 1998
//

enum BREAK_UNIT
{
	BRK_WORD		= 1,
	BRK_CLUSTER 	= 2,
	BRK_BOTH		= 3
};

class CTxtBreaker : public ITxNotify
{
public:
	CTxtBreaker(CTxtEdit *ped);
	~CTxtBreaker();

	// Breaker allocation
	BOOL				AddBreaker(UINT brkUnit);

	// Breaker refreshing
	void				Refresh();

	// Query methods
#ifndef NOCOMPLEXSCRIPTS
	BOOL				CanBreakCp (BREAK_UNIT brk, LONG cp);
#else
	BOOL				CanBreakCp (BREAK_UNIT brk, LONG cp) { return FALSE; }
#endif

	// ITxNotify methods

	virtual void    	OnPreReplaceRange (LONG cp, LONG cchDel, LONG cchNew,
										LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData);
	virtual void    	OnPostReplaceRange (LONG cp, LONG cchDel, LONG cchNew,
										LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData);
	virtual void		Zombie() {};

private:
	CTxtEdit*			_ped;
	CBreakArray*		_pbrkWord;		// word-break array (per codepoint property)
	CBreakArray*		_pbrkChar;		// cluster-break array (per codepoint property)
};

#endif	// !BITVIEW

#endif	// _TXTBRK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_rtfwrit.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFWRIT.H -- RichEdit RTF Writer Class Definition |
 *
 *	Description:
 *		This file contains the type declarations used by the RTF writer
 *		for the RICHEDIT control
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	@devnote
 *		All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *		noted as a szUnicode.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */
#ifndef __RTFWRIT_H
#define __RTFWRIT_H

#include "_rtfconv.h"
extern const KEYWORD rgKeyword[];

#define PUNCT_MAX	1024


class CRTFWrite ;


class RTFWRITEOLESTREAM : public OLESTREAM
{
	OLESTREAMVTBL OLEStreamVtbl;	// @member - memory for  OLESTREAMVTBL
public:
	 CRTFWrite *Writer;				// @cmember CRTFwriter to use

	RTFWRITEOLESTREAM::RTFWRITEOLESTREAM ()
	{
		lpstbl = & OLEStreamVtbl ;
	}		
};

enum									// Control-Word-Format indices
{
	CWF_STR, CWF_VAL, CWF_GRP, CWF_AST, CWF_GRV, CWF_SVAL
};

#define chEndGroup RBRACE

/*
 *	CRTFWrite
 *
 *	@class	RTF writer class.
 *
 *	@base	public | CRTFConverter
 *
 */
class CRTFWrite : public CRTFConverter
{
private:
	LONG		_cchBufferOut;			//@cmember # chars in output buffer
	LONG		_cchOut;				//@cmember Total # chars put out
	LONG		_cbCharLast;			//@cmember # bytes in char last written

	BYTE		_fBullet : 1;			//@cmember Currently in a bulleted style
	BYTE		_fBulletPending : 1;	//@cmember Set if next output should bull
	BYTE		_fNeedDelimeter : 1;	//@cmember Set if next char must be nonalphanumeric
	BYTE        _fIncludeObjects : 1;   //@cmember Set if objects should be included in stream
	BYTE		_fRangeHasEOP : 1;		//@cmember Set if _prg has EOP
	BYTE		_fNCRForNonASCII : 1;	//@cmember Put /uN for nonASCII
	BYTE		_fRowHasNesting : 1;	//@cmember Row has nested row(s)
	BYTE		_fFieldResult : 1;		//@cmember Writing out a fldrslt

	BYTE		_iCell;					//@cmember Index of current cell in current row
	BYTE		_cCell;					//@cmember Count of CELLs in current row

	char *		_pchRTFBuffer;			//@cmember Ptr to RTF write buffer
	BYTE *		_pbAnsiBuffer;			//@cmember Ptr to buffer used for conversion
	char *		_pchRTFEnd;				//@cmember Ptr to RTF-write-buffer end
	LONG		_symbolFont;			//@cmember Font number of Symbol used by Bullet style
	RTFWRITEOLESTREAM RTFWriteOLEStream;//@cmember RTFWRITEOLESTREAM to use
	LONG		_nHeadingStyle;			//@cmember Deepest heading # found
	LONG		_nNumber;				//@cmember Current number in para (1-based)
	LONG		_nFont;					//@cmember Current number font index
	LONG		_nFieldFont;			//@cmember font change during fieldResult, to make RE30 hyperlink code happy
	LONG		_cpg;					//@cmember Current number code page
	const CParaFormat *_pPF;			//@cmember Current para format

										//@cmember Build font/color tables
	EC			BuildTables		(CRchTxtPtr &rtp, LONG cch, BOOL& fNameIsDBCS);
	inline void	CheckDelimiter()		//@cmember Put ' ' if need delimiter
	{
		if(_fNeedDelimeter)
		{
			_fNeedDelimeter = FALSE;
			PutChar(' ');
		}
	};

										//@cmember Handle table delimeters
	BOOL		CheckInTable	(CRchTxtPtr *prtp, LONG *pcch);
	BOOL		FlushBuffer		();		//@cmember Stream out output buffer
										//@cmember Get index of <p colorref>
	LONG		LookupColor		(COLORREF colorref);
										//@cmember Get font index for <p pCF>
	LONG		LookupFont		(CCharFormat const *pCF);
										//@cmember Translate backing idx to RTF idx
	LONG		TranslateColorIndex(LONG  icr, const CParaFormat *pPF);
										//@cmember "printf" to output buffer
	BOOL _cdecl printF			(CONST CHAR *szFmt, ...);
										//@cmember Put char <p ch> in output buffer
	EC			PutBorders		(BOOL fInTable);
	BOOL		PutChar			(CHAR ch);
										//@cmember Put control word <p iCtrl> with value <p iValue> into output buffer
	BOOL		PutCtrlWord		(LONG iFormat, LONG iCtrl, LONG iValue = 0);
										//@cmember Put shape control word <p iCtrl> with value <p iValue>
	BOOL		PutShapeParm	(LONG iCtrl, LONG iValue);
										//@cmember Put string <p sz> in output buffer
	void		PutPar();				//@cmember Put \par with appropriate \r\n
	BOOL		Puts			(CHAR const *sz, LONG cb);
										//@cmember Write char format <p pCF>
	LONG		WriteCharFormat	(CRchTxtPtr *prtp, LONG cch, LONG nCodePage);
	EC			WriteColorTable	();		//@cmember Write color table
	EC			WriteFontTable	();		//@cmember Write font table
	EC			WriteInfo		();		//@cmember Write document info
										//@cmember Write para format <p pPF>
	EC			WriteParaFormat	(CRchTxtPtr *prtp, LONG *pcch);
										//@cmember Write PC data <p szData>
	EC			WritePcData		(const WCHAR *szData, INT nCodePage = CP_ACP, BOOL fIsDBCS = FALSE );
										//@cmember Write <p cch> chars of text <p pch>
	EC			WriteText		(LONG cwch, LPCWSTR lpcwstr, INT nCodePage, BOOL fIsDBCS,
								 BOOL fQuadBackSlash);
	EC			WriteTextChunk	(LONG cwch, LPCWSTR lpcwstr, INT nCodePage, BOOL fIsDBCS,
								 BOOL fQuadBackSlash);

// OBJECT
	EC			WriteObject		(LONG cp, COleObject *pobj);
	BOOL		GetRtfObjectMetafilePict(HGLOBAL hmfp, RTFOBJECT &rtfobject, SIZEL &sizelGoal);
	BOOL		GetRtfObject	(REOBJECT &reobject, RTFOBJECT &rtfobject);
	EC			WriteRtfObject	(RTFOBJECT & rtfOb, BOOL fPicture);
	BOOL		ObjectWriteToEditstream(REOBJECT &reObject, RTFOBJECT &rtfobject);
	EC			WritePicture	(RTFOBJECT &rtfObject);
	EC			WriteDib		(RTFOBJECT &rtfObject);
	EC			WriteBackgroundInfo(CDocInfo *pDocInfo);

	enum 		{ MAPTOKWD_ANSI, MAPTOKWD_UNICODE };
	inline BOOL	MapsToRTFKeywordW(WCHAR wch);
	inline BOOL	MapsToRTFKeywordA(char ch);
	int 		MapToRTFKeyword	(void *pv, int cch, int iCharEncoding, BOOL fQuadBackSlash);

public:
											//@cmember Constructor
	CRTFWrite(CTxtRange *prg, EDITSTREAM *pes, DWORD dwFlags);
	~CRTFWrite() {FreePv(_pbAnsiBuffer);}	//@cmember Destructor

	LONG		WriteRtf();				//@cmember Main write entry used by
										//  CLiteDTEngine
	LONG		WriteData		(BYTE * pbBuffer, LONG cbBuffer);
	LONG		WriteBinData	(BYTE * pbBuffer, LONG cbBuffer);

};										


#endif // __RTFWRIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_urlsup.h ===
/*
 *	@doc INTERNAL
 *
 *	@module	_URLSUP.H	URL detection support |
 *
 *	Author:	alexgo (4/1/96)
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _URLSUP_H_
#define _URLSUP_H_

#include "_dfreeze.h"
#include "_notmgr.h"
#include "_range.h"

class CTxtEdit;
class IUndoBuilder;

// Maximum URL length. It's a good thing to have a protection like
// this to make sure we don't select the whole document; and we really
// need this for space-containing URLs.

// Note (keithcu). I bumped these values up because of RAID 7210. I thought about
// removing this support altogether, but it's nice to have and speeds up
// performance when you are inserting angle brackets inside URLs and you
// do the left one first.
#define URL_MAX_SIZE			4096


// for MoveByDelimiter
#define	URL_EATWHITESPACE		32
#define URL_STOPATWHITESPACE	1
#define	URL_EATNONWHITESPACE	0
#define URL_STOPATNONWHITESPACE	2
#define	URL_EATPUNCT			0
#define URL_STOPATPUNCT			4
#define	URL_EATNONPUNCT			0
#define URL_STOPATNONPUNCT		8
#define URL_STOPATCHAR			16

// need this one to initialize a scan with something invalid
#define URL_INVALID_DELIMITER	TEXT(' ')

#define LEFTANGLEBRACKET	TEXT('<')
#define RIGHTANGLEBRACKET	TEXT('>')

/*
 *	CDetectURL
 *
 *	@class	This class watches edit changes and automatically
 *			changes detected URL's into links (see CFE_LINK && EN_LINK)
 */
class CDetectURL : public ITxNotify
{
//@access	Public Methods
public:
	// constructor/destructor

	CDetectURL(CTxtEdit *ped);				//@cmember constructor
	~CDetectURL();							//@cmember destructor

	// ITxNotify methods
											//@cmember Called before a change
	virtual void    OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                       LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData );
											//@cmember Called after a change
	virtual void    OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                       LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData );
	virtual void	Zombie();				//@cmember Turn into a zombie

	// useful methods

	void	ScanAndUpdate(IUndoBuilder *publdr);//@cmember Scan changed area 
											//			& update link status
											//@cmember Return TRUE if text is a URL
	BOOL IsURL(CTxtPtr &tp, LONG cch, BOOL *pfURLLeadin);

//@access	Private Methods and Data
private:

	// Worker routines for ScanAndUpdate
	BOOL GetScanRegion(LONG& cpStart, LONG& cpEnd);//@cmember Get region to
											//		check & clear accumulator

	static void ExpandToURL(CTxtRange& rg, LONG &cchAdvance);		
											//@cmember Expand range to next
											//		   URL candidate
	static void SetURLEffects(CTxtRange& rg, IUndoBuilder *publdr);	//@cmember Set
											//	 desired URL effects

											//@cmember Remove URL effects if
											// appropriate
	void CheckAndCleanBogusURL(CTxtRange& rg, BOOL &fDidClean, IUndoBuilder *publdr);

											//@cmember Scan along for white
											// space / not whitespace,
											// punctuation / non punctuation
											// and remember what stopped scan
	static LONG MoveByDelimiters(const CTxtPtr& tp, LONG iDir, DWORD grfDelimiters, 
							WCHAR *pchStopChar);

	static LONG GetAngleBracket(CTxtPtr &tp, LONG cch = 0);
	static WCHAR BraceMatch(WCHAR chEnclosing);
			
	CTxtEdit *				_ped;			//@cmember Edit context
	CAccumDisplayChanges 	_adc;			//@cmember Change accumulator

	// FUTURE (alexgo): we may want to add more options to detection,
	// such as the charformat to use on detection, etc.
};

#endif // _URLSUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_tomfmt.h ===
/*
 *	@doc
 *
 *	@module _tomfmt.h -- CTxtFont and CTxtPara Classes |
 *	
 *		This class implements the TOM ITextFont and ITextPara interfaces
 *	
 *	Author: <nl>
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _tomformat_H
#define _tomformat_H

#include "_range.h"

extern const BYTE g_rgREtoTOMAlign[];

// CTxtFormat: base class for CTxtFont and CTxtPara

class CTxtFormat
{
protected:
	CTxtFormat(CTxtRange *prg);
	~CTxtFormat();

	long		_cRefs;
	CTxtRange *	_prg;

	HRESULT	CanChange(long *pBool, BOOL fPara);
	HRESULT	GetParameter (long *pParm, DWORD dwMask, long Type, long *pValue);
	HRESULT	SetParameter (long *pParm, long Type, long Value);
	HRESULT	IsTrue		 (BOOL f, long *pB);
	BOOL	IsZombie()	 {return _prg && _prg->IsZombie();}
};


class CTxtFont : public ITextFont, CTxtFormat
{
	friend	CTxtRange;
	friend	CTxtEdit;

	CCharFormat	_CF;
	DWORD		_dwMask;			// CHARFORMAT2 mask
	TMPDISPLAYATTR	_tmpDisplayAttr;	// Temp display attribute
	union
	{
	  DWORD _dwFlags;				// All together now
	  struct
	  {
		DWORD _fApplyLater : 1;		// Delay call to _prg->CharFormatSetter()
		DWORD _fCacheParms : 1;		// Update _CF now but not on GetXs
		DWORD _fApplyToTmp : 1;		// Apply change to temp. display attributes
	  };
	};

public:
	CTxtFont(CTxtRange *prg);

	// IUnknown methods
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDispatch methods
	STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
	STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
	STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
	STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

	// ITextFont methods
	STDMETHODIMP GetDuplicate(ITextFont **ppFont);
	STDMETHODIMP SetDuplicate(ITextFont *pFont);
	STDMETHODIMP CanChange(long *pB);
	STDMETHODIMP IsEqual(ITextFont *pFont, long *pB);
	STDMETHODIMP Reset(long Value);
	STDMETHODIMP GetStyle(long *pValue);
	STDMETHODIMP SetStyle(long Value);
	STDMETHODIMP GetAllCaps(long *pValue);
	STDMETHODIMP SetAllCaps(long Value);
	STDMETHODIMP GetAnimation(long *pValue);
	STDMETHODIMP SetAnimation(long Value);
	STDMETHODIMP GetBackColor(long *pValue);
	STDMETHODIMP SetBackColor(long Value);
	STDMETHODIMP GetBold(long *pValue);
	STDMETHODIMP SetBold(long Value);
	STDMETHODIMP GetEmboss(long *pValue);
	STDMETHODIMP SetEmboss(long Value);
	STDMETHODIMP GetForeColor(long *pValue);
	STDMETHODIMP SetForeColor(long Value);
	STDMETHODIMP GetHidden(long *pValue);
	STDMETHODIMP SetHidden(long Value);
	STDMETHODIMP GetEngrave(long *pValue);
	STDMETHODIMP SetEngrave(long Value);
	STDMETHODIMP GetItalic(long *pValue);
	STDMETHODIMP SetItalic(long Value);
	STDMETHODIMP GetKerning(float *pValue);
	STDMETHODIMP SetKerning(float Value);
	STDMETHODIMP GetLanguageID(long *pValue);
	STDMETHODIMP SetLanguageID(long Value);
	STDMETHODIMP GetName(BSTR *pbstr);
	STDMETHODIMP SetName(BSTR bstr);
	STDMETHODIMP GetOutline(long *pValue);
	STDMETHODIMP SetOutline(long Value);
	STDMETHODIMP GetPosition(float *pValue);
	STDMETHODIMP SetPosition(float Value);
	STDMETHODIMP GetProtected(long *pValue);
	STDMETHODIMP SetProtected(long Value);
	STDMETHODIMP GetShadow(long *pValue);
	STDMETHODIMP SetShadow(long Value);
	STDMETHODIMP GetSize(float *pValue);
	STDMETHODIMP SetSize(float Value);
	STDMETHODIMP GetSmallCaps(long *pValue);
	STDMETHODIMP SetSmallCaps(long Value);
	STDMETHODIMP GetSpacing(float *pValue);
	STDMETHODIMP SetSpacing(float Value);
	STDMETHODIMP GetStrikeThrough(long *pValue);
	STDMETHODIMP SetStrikeThrough(long Value);
	STDMETHODIMP GetSubscript(long *pValue);
	STDMETHODIMP SetSubscript(long Value);
	STDMETHODIMP GetSuperscript(long *pValue);
	STDMETHODIMP SetSuperscript(long Value);
	STDMETHODIMP GetUnderline(long *pValue);
	STDMETHODIMP SetUnderline(long Value);
	STDMETHODIMP GetWeight(long *pValue);
	STDMETHODIMP SetWeight(long Value);

//@access Private ITextFont helper methods
private:
	HRESULT	GetParameter (long *pParm, DWORD dwMask, long Type, long *pValue);
	HRESULT	SetParameter (long *pParm, DWORD dwMask, long Type, long Value);
	HRESULT	EffectGetter (long *ptomBool, DWORD dwMask);
	HRESULT	EffectSetter (long Value, DWORD dwMask, DWORD dwEffect);
	HRESULT	FormatSetter (DWORD dwMask);
	HRESULT	UpdateFormat ();
};


class CTxtPara : public ITextPara, CTxtFormat
{
	friend	CTxtRange;
	friend	CTxtEdit;

	CParaFormat	_PF;
	DWORD		_dwMask;			// PARAFORMAT2 mask
	union
	{
	  DWORD _dwFlags;				// All together now
	  struct
	  {
		DWORD _fApplyLater : 1;		// Delay call to _prg->ParaFormatSetter()
		DWORD _fCacheParms : 1;		// Update _PF now but not on GetXs
	  };
	};
	LONG		_rgxTabs[MAX_TAB_STOPS];// Place to store tabs till committed

public:
	CTxtPara(CTxtRange *prg);
	~CTxtPara();

	// IUnknown methods
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDispatch methods
	STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
	STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
	STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
	STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

	// ITextPara methods
	STDMETHODIMP GetDuplicate(ITextPara **ppPara);
	STDMETHODIMP SetDuplicate(ITextPara *pPara);
	STDMETHODIMP CanChange(long *pB);
	STDMETHODIMP IsEqual(ITextPara *pPara, long *pB);
	STDMETHODIMP Reset(long Value);
	STDMETHODIMP GetStyle(long *pValue);
	STDMETHODIMP SetStyle(long Value);

	STDMETHODIMP GetAlignment(long *pValue);
	STDMETHODIMP SetAlignment(long Value);
	STDMETHODIMP GetHyphenation(long *pValue);
	STDMETHODIMP SetHyphenation(long Value);
	STDMETHODIMP GetFirstLineIndent(float *pValue);
	STDMETHODIMP GetKeepTogether(long *pValue);
	STDMETHODIMP SetKeepTogether(long Value);
	STDMETHODIMP GetKeepWithNext(long *pValue);
	STDMETHODIMP SetKeepWithNext(long Value);
	STDMETHODIMP GetLeftIndent(float *pValue);
	STDMETHODIMP GetLineSpacing(float *pValue);
	STDMETHODIMP GetLineSpacingRule(long *pValue);
    STDMETHODIMP GetListAlignment(long * pValue);
    STDMETHODIMP SetListAlignment(long Value);
    STDMETHODIMP GetListLevelIndex(long * pValue);
    STDMETHODIMP SetListLevelIndex(long Value);
    STDMETHODIMP GetListStart(long * pValue);
    STDMETHODIMP SetListStart(long Value);
    STDMETHODIMP GetListTab(float * pValue);
    STDMETHODIMP SetListTab(float Value);
	STDMETHODIMP GetListType(long *pValue);
	STDMETHODIMP SetListType(long Value);
	STDMETHODIMP GetNoLineNumber(long *pValue);
	STDMETHODIMP SetNoLineNumber(long Value);
	STDMETHODIMP GetPageBreakBefore(long *pValue);
	STDMETHODIMP SetPageBreakBefore(long Value);
	STDMETHODIMP GetRightIndent(float *pValue);
	STDMETHODIMP SetRightIndent(float Value);
	STDMETHODIMP SetIndents(float StartIndent, float LeftIndent, float RightIndent);
	STDMETHODIMP SetLineSpacing(long LineSpacingRule, float LineSpacing);
	STDMETHODIMP GetSpaceAfter(float *pValue);
	STDMETHODIMP SetSpaceAfter(float Value);
	STDMETHODIMP GetSpaceBefore(float *pValue);
	STDMETHODIMP SetSpaceBefore(float Value);
	STDMETHODIMP GetWidowControl(long *pValue);
	STDMETHODIMP SetWidowControl(long Value);

	STDMETHODIMP GetTabCount(long *pValue);
	STDMETHODIMP AddTab(float tpPos, long tbAlign, long tbLeader);
	STDMETHODIMP ClearAllTabs();
	STDMETHODIMP DeleteTab(float tbPos);
	STDMETHODIMP GetTab(long iTab, float *ptbPos, long *ptbAlign, long *ptbLeader);

	HRESULT	FormatSetter (DWORD dwMask);

//@access Private ITextPara helper methods
private:
	HRESULT	GetParameter (long *pParm, DWORD dwMask, long Type, long *pValue);
	HRESULT	SetParameter (long *pParm, DWORD dwMask, long Type, long Value);
	HRESULT	EffectGetter (long * ptomBool, DWORD dwMask);
	HRESULT	EffectSetter (long Value, DWORD dwMask);
	HRESULT	UpdateFormat ();
	void	CheckTabsAddRef();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_select.h ===
/*
 *	_SELECT.H
 *	
 *	Purpose:
 *		CTxtSelection class
 *	
 *	Owner:
 *		David R. Fulmer (original code)
 *		Christian Fortini
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _SELECT_H
#define _SELECT_H

#include "_range.h"
#include "_m_undo.h"

// amount of time, in milisecs, before pending characters force a display update
#define ticksPendingUpdate 100	// 100 mili secs ~ display at least 10 characters per second.

class CDisplay;
class CLinePtr;

typedef enum
{
	smNone,
	smWord,
	smLine,
	smPara
} SELMODE;

enum
{
	CARET_NONE	= 0,
	CARET_CUSTOM = 1,
	CARET_BIDI = 2,
	CARET_THAI = 4,
	CARET_INDIC = 8
};

class CTxtSelection : public CTxtRange
{
#ifdef DEBUG
public:
	BOOL Invariant( void ) const; // Invariant checking.
#endif // DEBUG

//@access Protected Data
protected:
	CDisplay	*_pdp;			// display this selection belong to

	LONG	_cpSel;				// active end of displayed selection
	LONG	_cchSel;			// length of displayed selection

	LONG 	_upCaret;			// caret x on screen
	LONG 	_vpCaret;			// caret y on screen 
	LONG 	_upCaretReally;		// real caret x (/r start of line) for vertical moves
	INT 	_dvpCaret;			// caret height

	union
	{
	  DWORD _dwFlags;			// All together now
	  struct
	  {
	   DWORD _fCaretNotAtBOL:1;	// If at BOL, show caret at prev EOL
	   DWORD _fDeferUpdate	:1;	// Defer updating selection/caret on screen
	   DWORD _fInAutoWordSel:1;	// Current selection used auto word sel
	   DWORD _fShowCaret	:1;	// Show caret on screen
	   DWORD _fShowSelection:1;	// Show selection on screen

	   DWORD _fIsChar		:1;	// Currently adding a single char
	   DWORD _fObSelected	:1;	// An embedded object is selected
	   DWORD _fAutoSelectAborted : 1; // Whether auto word selection is aborted
	   DWORD _fCaretCreated	:1;	// Caret has been created
	   DWORD _fNoKeyboardUpdate :1; // Keyboard is not updated while in UpdateCaret()
	   DWORD _fEOP			:1;	// InsertEOP() has been called
	   DWORD _fHomeOrEnd	:1;	// Home or End key is being processed
	   DWORD _fAutoVScroll	:1;	// 1.0 specific: flag indicating autoscrolling should be applied
	   DWORD _fForceScrollCaret:1; // 1.0 specific: force caret to scroll
	   DWORD _fShowCellLine	:1;	// Show line for CELL following TRED
	   DWORD _fUpdatedFromCp0:1;// Updated selection from cp = 0
	  };
	};
	
	SELMODE	_SelMode;			// 0 none, 1 Word, 2 Line, 3 Paragraph
	DWORD	_ticksPending;		// Count of chars inserted without UpdateWindow
	LONG 	_cpAnchor;			// Initial anchor for auto word select
	LONG	_cpAnchorMin;		// Initial selection cpMin/cpMost for select
	LONG	_cpAnchorMost;		//  modes
	LONG 	_cpWordMin;			// Start of anchor word in word select mode
	LONG 	_cpWordMost;		// End   of anchor word in word select mode
	LONG	_cpWordPrev;		// Previous anchor word end

	HBITMAP	_hbmpCaret;			// Used for funky carets, like BiDi/ital carets
	DWORD	_dwCaretInfo;		// Current caret info used to avoid new create

//@access Public Methods
public:
	CTxtSelection(CDisplay * const pdp);
	~CTxtSelection();

	CRchTxtPtr&	operator =(const CRchTxtPtr& rtp);
	CTxtRange&  operator =(const CTxtRange &rg);

	// Set the display
	void	SetDisplay(CDisplay *pdp) { _pdp = pdp; }

	// Information for Selection Change notification

	void 	SetSelectionInfo(SELCHANGE *pselchg);

	// Replacement
	LONG	DeleteWithTRDCheck(IUndoBuilder *publdr, SELRR selaemode,
							   LONG *pcchMove, DWORD dwflags);
	LONG	ReplaceRange(LONG cchNew, WCHAR const *pch, 
						IUndoBuilder *publdr, SELRR fCreateAE, LONG* pcchMove = NULL,
						DWORD dwFlags = 0);

	// Info for recalc line / UpdateView
	void	ClearCchPending()			{_ticksPending = 0;}
	LONG	GetScrSelMin() const		{return min(_cpSel, _cpSel - _cchSel);}
	LONG	GetScrSelMost() const		{return max(_cpSel, _cpSel - _cchSel);}
	BOOL	PuttingChar() const			{return _fIsChar;}

	// General updating
	virtual	BOOL 	Update(BOOL fScrollIntoView);

	BOOL	DeferUpdate()			
				{const BOOL fRet = _fDeferUpdate; _fDeferUpdate = TRUE; return fRet;}
	BOOL	DoDeferedUpdate(BOOL fScrollIntoView)		
				{_fDeferUpdate = FALSE; return Update(fScrollIntoView);}

	void	SetAutoVScroll(BOOL bAuto) {_fAutoVScroll = bAuto;}
	BOOL	GetAutoVScroll()	{return _fAutoVScroll;}
	BOOL	GetShowCellLine()	{return _fShowCellLine;}

	void	SetForceScrollCaret(BOOL bAuto) {_fForceScrollCaret = bAuto;}
	BOOL	GetForceScrollCaret() {return _fForceScrollCaret;}

	// method used by selection anti-event for out-of-phase updates
	void	SetDelayedSelectionRange(LONG cp, LONG cch);
	void	StopGroupTyping();

	// Caret management
	BOOL	CaretNotAtBOL() const;
	void	CheckTableIP(BOOL fOpenLine);
	void	CreateCaret();
	void	DeleteCaretBitmap(BOOL fReset);
	BOOL	IsCaretHorizontal() const;
	INT		GetCaretHt()				{return _dvpCaret;}
	LONG	GetUpCaretReally();
	LONG	GetUpCaret()	const			{return _upCaret;}
	LONG	GetVpCaret()	const			{return _vpCaret;}
	BOOL	IsCaretNotAtBOL() const		{return _fCaretNotAtBOL;}
	BOOL 	IsCaretInView() const;
	BOOL 	IsCaretShown() const		{return _fShowCaret && !_cch;}
	BOOL	IsUpdatedFromCp0() const	{return _fUpdatedFromCp0;}
	LONG	LineLength(LONG *pcp) const;
	BOOL	SetUpPosition(LONG upCaret, CLinePtr& rp, BOOL fBottomLine, BOOL fExtend);
	BOOL 	ShowCaret(BOOL fShow);
	BOOL 	UpdateCaret(BOOL fScrollIntoView, BOOL fForceCaret = FALSE);
	BOOL	GetCaretPoint(RECTUV &rcClient, POINTUV &pt, CLinePtr *prp, BOOL fBeforeCp);
	BOOL	MatchKeyboardToPara();

	// Selection management
	void	ClearPrevSel()				{ _cpSel = 0; _cchSel = 0; }
	BOOL	GetShowSelection()			{return _fShowSelection;}
	BOOL	ScrollWindowful(WPARAM wparam, BOOL fExtend);
	void 	SetSelection(LONG cpFirst, LONG cpMost);
	BOOL	ShowSelection(BOOL fShow);
	void	Beep()						{GetPed()->Beep();}

	// Selection with the mouse
	void 	CancelModes	(BOOL fAutoWordSel = FALSE);
	void 	ExtendSelection(const POINTUV pt);
	BOOL	PointInSel	(const POINTUV pt, RECTUV *prcClient = NULL, HITTEST Hit = HT_Undefined) const;
	void 	SelectAll	();
	void 	SelectUnit	(const POINTUV pt, LONG Unit);
	void 	SelectWord	(const POINTUV pt);
 	void 	SetCaret	(const POINTUV pt, BOOL fUpdate = TRUE);

	// Keyboard movements
	BOOL 	Left	(BOOL fCtrl, BOOL fExtend);
	BOOL	Right	(BOOL fCtrl, BOOL fExtend);
	BOOL	Up		(BOOL fCtrl, BOOL fExtend);
	BOOL	Down	(BOOL fCtrl, BOOL fExtend);
	BOOL	Home	(BOOL fCtrl, BOOL fExtend);
	BOOL	End		(BOOL fCtrl, BOOL fExtend);
	BOOL	PageUp	(BOOL fCtrl, BOOL fExtend);
	BOOL	PageDown(BOOL fCtrl, BOOL fExtend);

	// Editing
	BOOL	PutChar	 (DWORD ch, DWORD dwFlags, IUndoBuilder *publdr, LCID lcid = 0);
	void	SetIsChar(BOOL);
	void	CheckUpdateWindow();
	BOOL	InsertEOP(IUndoBuilder *publdr, WCHAR ch = 0);
	LONG	InsertTableRow (const CParaFormat *pPF, IUndoBuilder *publdr,
							BOOL fFixCellBorders = FALSE);
	
	// Keyboard switching support.
	void	CheckChangeKeyboardLayout();
	bool	CheckChangeFont (const HKL hkl, UINT iCharRep, LONG iSelFormat = 0, QWORD qwCharFlags = 0);
	UINT	CheckSynchCharSet(QWORD dwCharFlags = 0);

	// from CTxtRange
	BOOL	Delete  (DWORD flags, IUndoBuilder *publdr);
	BOOL	Backspace(BOOL fCtrl, IUndoBuilder *publdr);

	const CParaFormat* GetPF();

	// note that the parameters are different than CTxtRange::SetCharFormat
	// intentionally; the selection has extra options available to it.
	HRESULT	SetCharFormat(const CCharFormat *pCF, DWORD flags,  
									IUndoBuilder *publdr, DWORD dwMask, DWORD dwMask2);
	HRESULT	SetParaFormat(const CParaFormat *pPF,
									IUndoBuilder *publdr, DWORD dwMask, DWORD dwMask2);

	// Auto word selection helper
	void	InitClickForAutWordSel(const POINTUV pt);

	// dual font helper for CTxtSelection::PutChar
	void	SetupDualFont();

	// IUnknown and IDispatch methods handled by CTxtRange methods

	// ITextRange methods can use ITextRange methods directly, since
	// they either don't modify the display of the selection (get methods), or
	// they have appropriate virtual character to call on selection functions.

	// ITextSelection methods
	STDMETHODIMP GetFlags (long *pFlags) ;
	STDMETHODIMP SetFlags (long Flags) ;
	STDMETHODIMP GetType  (long *pType) ;
	STDMETHODIMP MoveLeft (long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP MoveRight(long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP MoveUp	  (long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP MoveDown (long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP HomeKey  (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP EndKey   (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP TypeText (BSTR bstr) ;
	STDMETHODIMP SetPoint (long x, long y, long Extend) ;

//@access Protected Methods
protected:

	// Protected update method
	void	UpdateSelection();

	// Protected caret management method
	INT 	GetCaretHeight(INT *pyDescent) const;

	HRESULT	GeoMover (long Unit, long Count, long Extend,
					  long *pDelta, LONG iDir);
	HRESULT Homer	 (long Unit, long Extend, long *pDelta,
					  BOOL (CTxtSelection::*pfn)(BOOL, BOOL));

	// Auto Select Word Helpers
	void	UpdateForAutoWord();
	void	AutoSelGoBackWord(
				LONG *pcpToUpdate,
				int iDirToPrevWord,
				int	iDirToNextWord);

	void	ExtendToWordBreak(BOOL fAfterEOP, INT iDir);
	BOOL	CheckPlainTextFinalEOP();
};

/*
 *	CSelPhaseAdjuster
 *
 *	@class	This class is put on the stack and used to temporarily hold
 *			selection cp values until the control is "stable" (and thus,
 *			we can safely set the selection
 */
class CSelPhaseAdjuster : public IReEntrantComponent
{
//@access	Public methods
public:

	// IReEntrantComponent methods

	virtual	void OnEnterContext()	{;}		//@cmember re-entered notify

	CSelPhaseAdjuster(CTxtEdit *ped);		//@cmember constructor
	~CSelPhaseAdjuster();					//@cmember destructor

	void CacheRange(LONG cp, LONG cch);		//@cmember stores the sel range

//@access	Private data
private:
	CTxtEdit *		_ped;					//@cmember edit context
	LONG			_cp;					//@cmember sel active end to set
	LONG			_cch;					//@cmember sel extension
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_version.h ===
#define RICHEDIT_VER "5.41.15.1503"
#define RICHEDIT_VERMAJ 41
#define RICHEDIT_VERMIN 15
#define RICHEDIT_VERBUILD 1503
#ifdef DEBUG
#define RICHEDIT_BUILD RICHEDIT_VER ## " (Debug)"
#else
#define RICHEDIT_BUILD RICHEDIT_VER
#endif
#define RICHEDIT_HEADER "Msftedit " ## RICHEDIT_BUILD
#define RTF_GENINFO "{\\*\\generator " ## RICHEDIT_HEADER ## ";}"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_util.h ===
/*
 *	_UTIL.H
 *
 *	Purpose:
 *		declarations for various useful utility functions
 *
 *	Author:
 *		alexgo (4/25/95)
 */

#ifndef __UTIL_H__
#define __UTIL_H__

HGLOBAL DuplicateHGlobal( HGLOBAL hglobal );
INT CountMatchingBits(const DWORD *a, const DWORD *b, INT total);
HRESULT ObjectReadSiteFlags(REOBJECT * preobj);


//Default values for drag scrolling
//(that aren't already defined by windows).
#define DEFSCROLLMAXVEL 100	//Cursor velocity above which we will not
							//drag scroll (units=.01 in/sec).
#define DEFSCROLLVAMOUNT 50	//Vert. scroll amount per interval (units=.01 in)
#define DEFSCROLLHAMOUNT 50 //Horz. scroll amount per interval (units=.01 in)

//Stuff from OLESTD samples

//Ole clipboard format defines.
#define CF_EMBEDSOURCE      "Embed Source"
#define CF_EMBEDDEDOBJECT   "Embedded Object"
#define CF_LINKSOURCE       "Link Source"
#define CF_OBJECTDESCRIPTOR "Object Descriptor"
#define CF_FILENAME         "FileName"
#define CF_OWNERLINK        "OwnerLink"

HRESULT OleStdSwitchDisplayAspect(
			LPOLEOBJECT			lpOleObj,
			LPDWORD				lpdwCurAspect,
			DWORD				dwNewAspect,
			HGLOBAL				hMetaPict,
			BOOL				fDeleteOldAspect,
			BOOL				fSetupViewAdvise,
			LPADVISESINK		lpAdviseSink,
			BOOL FAR *			lpfMustUpdate);
LPUNKNOWN OleStdQueryInterface(
			LPUNKNOWN			lpUnk,
			REFIID				riid);

void OleUIDrawShading(LPRECT lpRect, HDC hdc);

VOID OleSaveSiteFlags(LPSTORAGE pstg, DWORD dwFlags, DWORD dwUser, DWORD dvAspect);

INT	AppendString( BYTE **, BYTE *, int *, int * );

/****************************************************************************/
/*		     Stabilization classes				    						*/
/*        These are used to stabilize objects during re-entrant calls       */
/****************************************************************************/

//+-------------------------------------------------------------------------
//
//  Class: 	CSafeRefCount
//
//  Purpose: 	A concrete class for objects like the default handler to
//				inherit from.  CSafeRefCount will keep track of reference
//				counts, nesting counts, and zombie states, allowing objects
//				to easily manage the liveness of their memory images.
//
//  Interface:	
//
//  History:    dd-mmm-yy Author    Comment
//   			01-Aug-94 alexgo    author
//
//--------------------------------------------------------------------------

class CSafeRefCount
{
public:
	ULONG	SafeAddRef();
	ULONG	SafeRelease();
	ULONG	IncrementNestCount();
	ULONG	DecrementNestCount();
	BOOL	IsZombie();
   
			CSafeRefCount();
	virtual ~CSafeRefCount();

protected:
    VOID    Zombie();

private:

	ULONG	m_cRefs;
	ULONG	m_cNest;

	ULONG	m_fInDelete		:1;
	ULONG   m_fForceZombie	:1;
};

//+-------------------------------------------------------------------------
//
//  Class:	CStabilize
//
//  Purpose: 	An instance of this class should be allocated on the
//				stack of every object method that makes an outgoing call.
//				The contstructor takes a pointer to the object's base
//				CSafeRefCount class.
//
//  Interface:
//
//  History:    dd-mmm-yy Author    Comment
// 				01-Aug-94 alexgo    author
//
//  Notes:	The constructor will increment the nest count of the
//			object while the destructor will decrement it.
//
//--------------------------------------------------------------------------

class CStabilize
{
public:
	inline CStabilize( CSafeRefCount *pObjSafeRefCount );
	inline ~CStabilize();

private:
	CSafeRefCount *	m_pObjSafeRefCount;
};

inline CStabilize::CStabilize( CSafeRefCount *pObjSafeRefCount )
{
	pObjSafeRefCount->IncrementNestCount();
	m_pObjSafeRefCount = pObjSafeRefCount;
}

inline CStabilize::~CStabilize()
{
	m_pObjSafeRefCount->DecrementNestCount();
}

/*
 *	SafeReleaseAndNULL(IUnknown **ppUnk)
 *
 *	Purpose:
 *      Helper for getting stable pointers during destruction or other times
 *
 *	Notes: 
 *      Not thread safe, must provide higher level synchronization.
 */

inline void SafeReleaseAndNULL(IUnknown **ppUnk)
{
    if (*ppUnk != NULL)
    {
    IUnknown *pUnkSave = *ppUnk;
    *ppUnk = NULL;
    pUnkSave->Release();
    }
}

BOOL FIsIconMetafilePict(HGLOBAL hmfp);
HANDLE OleStdGetMetafilePictFromOleObject(
        LPOLEOBJECT         lpOleObj,
        DWORD               dwDrawAspect,
        LPSIZEL             lpSizelHim,
        DVTARGETDEVICE FAR* ptd);
HGLOBAL OleGetObjectDescriptorDataFromOleObject(
        LPOLEOBJECT pObj,
        DWORD       dwAspect,
        POINTL      ptl,
        LPSIZEL     pszl);

// Default size for stack buffer
#define MAX_STACK_BUF 256

/*
 *	CTempBuf
 *	
 * 	@class	A simple temporary buffer allocator class that will allocate
 *			buffers on the stack up to MAX_STACK_BUF and then use the 
 *			heap thereafter. 
 */
class CTempBuf
{
//@access Public Data
public:
							//@cmember Constructor
							CTempBuf();

							//@cmember Destructor
							~CTempBuf();

							//@cmember Get buffer of size cb
	void *					GetBuf(LONG cb);

//@access Private Data
private:

							//@cmember Sets up initial state of object
	void					Init();

							//@cmember Frees any buffers allocated from heap
	void					FreeBuf();

							//@cmember Buffer on stack to use
	char					_chBuf[MAX_STACK_BUF];

							//@cmember Pointer to buffer to use
	void *					_pv;

							//@cmember Size of currently allocated buffer
	LONG					_cb;
};

/*
 *	CTempBuf::CTempBuf
 *
 *	@mfunc	Initialize object
 *
 */
inline CTempBuf::CTempBuf()
{
	Init();
}

/*
 *	CTempBuf::~CTempBuf
 *
 *	@mfunc	Free any resources attached to this object
 *
 */
inline CTempBuf::~CTempBuf()
{
	FreeBuf();
}

/*
 *	CTempCharBuf
 *	
 * 	@class	A wrapper for the temporary buffer allocater that returns a buffer of
 *			char's.
 *
 *	@base	private | CTempBuf
 */
class CTempWcharBuf : private CTempBuf
{
//@access Public Data
public:

							//@cmember Get buffer of size cch wide characters
	WCHAR *					GetBuf(LONG cch);
};


/*
 *	CTempBuf::GetBuf
 *
 *	@mfunc	Get a buffer of the requested size
 *
 *	@rdesc	Pointer to buffer or NULL if one could not be allocated
 *
 */
inline WCHAR *CTempWcharBuf::GetBuf(
	LONG cch)				//@parm size of buffer needed in *characters*
{
	return (WCHAR *) CTempBuf::GetBuf(cch * sizeof(WCHAR));
}


/*
 *	CTempCharBuf
 *	
 * 	@class	A wrapper for the temporary buffer allocater that returns a buffer of
 *			char's.
 *
 *	@base	private | CTempBuf
 */
class CTempCharBuf : private CTempBuf
{
//@access Public Data
public:

							//@cmember Get buffer of size cch characters
	char *					GetBuf(LONG cch);
};


/*
 *	CTempBuf::GetBuf
 *
 *	@mfunc	Get a buffer of the requested size
 *
 *	@rdesc	Pointer to buffer or NULL if one could not be allocated
 *
 */
inline char *CTempCharBuf::GetBuf(LONG cch)
{
	return (char *) CTempBuf::GetBuf(cch * sizeof(TCHAR));
}


// Author revision color table
extern const COLORREF rgcrRevisions[]; 

// Only fixed number of revision color so don't let the table overflow.
#define REVMASK	7

int FindPrimeLessThan(int num);


#endif // !__UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_w32sys.h ===
/*
 *	_w32sys.h
 *	
 *	Purpose:
 *		Isolate various Win 32 system dependencies.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _W32SYS_H

#define _W32SYS_H

#ifndef NOFEPROCESSING
#define OBSOLETE	// need this to get old IMEShare defines
#include "imeshare.h"
#else
// Some class declarations to keep the compiler happy
struct IMESTYLE;
struct IMECOLORSTY;
struct CIMEShare;
#endif

#include "_array.h"

#ifndef THICKCARET
#define duCaret		1
#else
#define duCaret		2
#endif

#ifdef LIMITEDMEMORY
#define FONTCACHESIZE 8
#define CCSHASHSEARCHSIZE	15
#define DEFAULT_UNDO_SIZE 20
#else
#define FONTCACHESIZE 24
#define CCSHASHSEARCHSIZE	31
#define DEFAULT_UNDO_SIZE 100
#endif

#ifdef SLOWCPU
#define NUMPASTECHARSWAITCURSOR 1024
#else
#define NUMPASTECHARSWAITCURSOR (1024*32)
#endif

#ifndef NOMEMORYH
#include "memory.h"								// for memmove
#endif

#define	RSHIFT	1
#define	LSHIFT	2
#define	RCTRL	0x10
#define	LCTRL	0x20
#define	RALT	0x40
#define	LALT	0x80

#define SHIFT	(RSHIFT + LSHIFT)
#define ALT		(RALT + LALT)
#define CTRL	(RCTRL + LCTRL)

#define	HOTEURO			0x1000
#define ALT0			0x2000
#define ALTNUMPAD		0x4000
#define LETAFTERSHIFT	0x8000

// special virtual keys copied from Japan MSVC ime.h
#define VK_KANA         0x15
#define VK_KANJI        0x19

// Initialization flags that can be used in system.ini for testing purposes
#define SYSINI_USELS		0x1
#define SYSINI_BIDI			0x2
#define SYSINI_USEAIMM		0x4
#define SYSINI_DEBUGFONT	0x8
#define SYSINI_DEBUGGCF125X	0x10
#define SYSINI_USECTF		0x20

/*
 *	GetCaretDelta ()
 *	
 *	@func 	Get size of caret to add to current caret position to get the 
 *	maximum extent needed to display caret.
 *
 *	@rdesc	Size of caret over 1 pixel
 *
 *	@devnote	This exists solely to abstract this calculation 
 *	to handle a variable size caret.
 */
inline int GetCaretDelta()
{
	return duCaret - 1;
}


// Used in rtfread.cpp to keep track of lossy rtf.
#ifdef PWORD_CONVERTER_V2
#define REPORT_LOSSAGE
#endif 

//Windows CE defines which need to be before their function declarations
#ifdef UNDER_CE
typedef struct tagKERNINGPAIR {
   WORD wFirst;
   WORD wSecond;
   int  iKernAmount;
} KERNINGPAIR, *LPKERNINGPAIR;
#endif


// Defines for some Codepages
#define CP_JAPAN			932
#define CP_KOREAN			949
#define CP_CHINESE_TRAD		950
#define CP_CHINESE_SIM		936
#define CP_HEBREW			1255
#define CP_ARABIC			1256
#define CP_THAI				874
#define CP_VIETNAMESE		1258
#define CP_ULE				1200			// Unicode
#define CP_UBE				1201

#define IsUnicodeCP(cp)		(((cp) & ~1) == CP_ULE)

// Newly introduced Indic language ID
#if(WINVER < 0x500)
#define	LANG_HINDI			0x39
#define	LANG_KONKANI		0x57
#define	LANG_NEPALI			0x61
#define	LANG_BENGALI		0x45
#define	LANG_PUNJABI		0x46
#define	LANG_GUJARATHI		0x47
#define	LANG_ORIYA			0x48
#define	LANG_TAMIL			0x49
#define	LANG_TELUGU			0x4a
#define	LANG_KANNADA		0x4b
#define	LANG_MALAYALAM		0x4c
#define	LANG_ASSAMESE		0x4d
#define	LANG_MARATHI		0x4e
#define	LANG_SANSKRIT		0x4f
#endif

// Other possibly missing defines
#ifndef LANG_THAI
#define LANG_THAI                        0x1e
#endif

#define ANSI_INDEX			0					// Keep these indices in sync
#define	EASTEUROPE_INDEX	1					//  with rgCodePage[] and
#define RUSSIAN_INDEX		2					//  rgCharSet[] if entries
#define GREEK_INDEX			3					//  exist in these arrays.
#define TURKISH_INDEX		4
#define HEBREW_INDEX		5
#define ARABIC_INDEX		6
#define BALTIC_INDEX		7
#define VIET_INDEX			8
#define DEFAULT_INDEX		9
#define SYMBOL_INDEX		10
#define THAI_INDEX			11
#define SHIFTJIS_INDEX		12
#define GB2312_INDEX		13
#define HANGUL_INDEX		14
#define BIG5_INDEX			15
#define PC437_INDEX			16
#define OEM_INDEX			17
#define MAC_INDEX			18

#define NCHARSETS			19		// Size of charset-oriented tables

#define ARMENIAN_INDEX		19		// Start of Unicode-only repertoires
#define	SYRIAC_INDEX		20
#define THAANA_INDEX		21
#define DEVANAGARI_INDEX	22
#define BENGALI_INDEX		23
#define GURMUKHI_INDEX		24
#define GUJARATI_INDEX		25
#define ORIYA_INDEX			26
#define TAMIL_INDEX			27
#define TELUGU_INDEX		28
#define KANNADA_INDEX		29
#define MALAYALAM_INDEX		30
#define SINHALA_INDEX		31
#define	LAO_INDEX			32
#define	TIBETAN_INDEX		33
#define	MYANMAR_INDEX		34
#define GEORGIAN_INDEX		35
#define JAMO_INDEX			36
#define ETHIOPIC_INDEX		37
#define CHEROKEE_INDEX		38
#define ABORIGINAL_INDEX	39
#define OGHAM_INDEX			40
#define RUNIC_INDEX			41
#define	KHMER_INDEX			42
#define	MONGOLIAN_INDEX		43
#define	BRAILLE_INDEX		44
#define	YI_INDEX			45
									// Keep next four in same order as
#define JPN2_INDEX			46		//  SHIFTJIS_INDEX to BIG5_INDEX
#define CHS2_INDEX			47
#define KOR2_INDEX			48
#define CHT2_INDEX			49

#define NCHARREPERTOIRES	50		// Size of keyboard and font-binding tables

#define INDIC_FIRSTINDEX	DEVANAGARI_INDEX
#define INDIC_LASTINDEX		SINHALA_INDEX

#define	PC437_CHARSET		254

// Flags which can be passed down to REExtTextOut
// The low 2 bits are reserved for passing down the TFLOW of the text
const DWORD fETOFEFontOnNonFEWin9x = 0x04;
const DWORD fETOCustomTextOut	   = 0x08;

#define IsSymbolOrOEMCharRep(x)	(x == SYMBOL_INDEX || x == OEM_INDEX)

enum CC
{
	CC_ARABIC,
	CC_HEBREW,
	CC_RTL,
	CC_LTR,
	CC_EOP,
	CC_ASCIIDIGIT,
	CC_NEUTRAL
};

#define IsRTL(cc)		(cc <= CC_RTL)

const SHORT sLanguageEnglishUS = 0x0409;
const SHORT sLanguageMask	 = 	0x03ff;
const SHORT sLanguageArabic	 = 	0x0401;
const SHORT sLanguageHebrew	 = 	0x040d;
// FUTURE: currently this const == sLanguageEnglishUS
//			for no reason except that it was this way 
//			in RE1.0 BiDi. Consider changing, or sticking 
//			the real language in, and changing the logic
//			of handling wLang a bit.
const SHORT sLanguageNonBiDi =	0x0409;


// Logical unit definition
const int LX_PER_INCH = 1440;
const int LY_PER_INCH = 1440;

// HIMETRIC units per inch (used for conversion)
const int HIMETRIC_PER_INCH = 2540;

#if defined(DEBUG)

void* __cdecl operator new(size_t nSize, char *szFile, int nLine);
#define NEW_DEBUG new(__FILE__, __LINE__)
#define new NEW_DEBUG

void UpdateMst(void);

struct MST
{
	char *szFile;
	int  cbAlloc;
}; //Memory Statistics;

extern MST vrgmst[];

#endif //DEBUG

#ifdef CopyMemory
#undef CopyMemory
#endif
#ifdef MoveMemory
#undef MoveMemory
#endif
#ifdef FillMemory
#undef FillMemory
#endif
#ifdef ZeroMemory
#undef ZeroMemory
#endif
#ifdef CompareMemory
#undef CompareMemory
#endif

#ifndef	KF_ALTDOWN
#define KF_ALTDOWN    0x2000
#endif

// Use for our version of ExtTextOut 

enum CONVERTMODE
{
	CVT_NONE,			// Use Unicode (W) CharWidth/TextOut APIs
	CVT_WCTMB,			// Convert to MBCS using WCTMB and _wCodePage
	CVT_LOWBYTE			// Use low byte of 16-bit chars (for SYMBOL_CHARSET
};						//  and when code page isn't installed)

// Opaque Type
class CTxtSelection;
class CTxtEdit;
class CCharFormat;
class CCcs;

enum UN_FLAGS 
{
	UN_NOOBJECTS				= 1,
	UN_CONVERT_WCH_EMBEDDING	= 2
};

#undef GetStringTypeEx
#undef CharLower
#undef CharLowerBuff
#undef CharUpperBuff
#undef CreateIC
#undef CreateFile
#undef CreateFontIndirect
#undef CompareString
#undef DefWindowProc
#undef GetKeyboardLayout
#undef GetProfileSection
#undef GetKerningPairs
#undef GetTextMetrics
#undef GetTextFace
#undef GetWindowLong
#undef GetWindowLongPtr
#undef GetClassLong
#undef LoadBitmap
#undef LoadCursor
#undef LoadLibrary
#undef SendMessage
#undef SetWindowLong
#undef SetWindowLongPtr
#undef PostMessage
#undef lstrcmp
#undef lstrcmpi
#undef PeekMessage
#undef GetModuleFileName
#undef GlobalAlloc 
#undef GlobalFree
#undef GlobalFlags
#undef GlobalReAlloc
#undef GlobalLock
#undef GlobalHandle
#undef GlobalUnlock
#undef GlobalSize

// Bits used in _fFEFontInfo:
#define JPN_FONT_AVAILABLE		0x0001		// True if Jpn font is available
#define KOR_FONT_AVAILABLE		0x0002		// True if Kor font is available
#define BIG5_FONT_AVAILABLE		0x0004		// True if Trad. Chinese font is available
#define GB_FONT_AVAILABLE		0x0008		// True if Simplified Chinese font is available	
#define FEUSER_LCID				0x0010		// True if User LCID is FE LCID
#define FEUSER_CODEPAGE			0x0060		//  indicate which User FE codepage its
#define FEUSER_CP_JPN			0x0000		//	 =00 for JPN
#define FEUSER_CP_KOR			0x0020		//	 =20 for KOR
#define FEUSER_CP_BIG5			0x0040		//	 =40 for BIG5
#define FEUSER_CP_GB			0x0060		//	 =60 for GB
#define FEDATA_NOT_INIT			0xFFFF		// No data yet

class CConvertStrW
{
public:
    operator WCHAR *();

protected:
    CConvertStrW();
    ~CConvertStrW();
    void Free();

    LPWSTR   _pwstr;
    WCHAR    _awch[MAX_PATH * 2];
};

inline CConvertStrW::CConvertStrW()
{
    _pwstr = NULL;
}

inline CConvertStrW::~CConvertStrW()
{
    Free();
}

inline CConvertStrW::operator WCHAR *()
{
    return _pwstr;
}

class CStrInW : public CConvertStrW
{
public:
    CStrInW(LPCSTR pstr);
    CStrInW(LPCSTR pstr, UINT uiCodePage);
    CStrInW(LPCSTR pstr, int cch, UINT uiCodePage);
    int strlen();

protected:
    CStrInW();
    void Init(LPCSTR pstr, int cch, UINT uiCodePage);

    int _cwchLen;
	UINT _uiCodePage;
};

inline CStrInW::CStrInW()
{
}

inline int CStrInW::strlen()
{
    return _cwchLen;
}


// Mask bit for temp display Attributes
#define APPLY_TMP_FORECOLOR	0x0001		// Apply temp. text color
#define	APPLY_TMP_BACKCOLOR	0x0002		// Apply temp. background color

// Actions for GetTmpColor
#define GET_TEMP_TEXT_COLOR			1
#define GET_TEMP_BACK_COLOR			2
#define GET_TEMP_UL_COLOR			3

typedef struct _tmpDispAttrib
{
	WORD		wMask;				// Mask for temp display Attributes
	BYTE		bUnderlineType;		// Temp Underline type
	COLORREF	crTextColor;		// Temp Foreground color
	COLORREF	crBackColor;		// Temp Background color
	COLORREF	crUnderlineColor;	// Temp Underline color
} TMPDISPLAYATTR;

class CTmpDisplayAttrArray : public CArray<TMPDISPLAYATTR>
{
public:
	CTmpDisplayAttrArray() {};
	~CTmpDisplayAttrArray() {};
};

typedef DWORD (WINAPI* PFN_GETLAYOUT)(HDC);
typedef DWORD (WINAPI* PFN_SETLAYOUT)(HDC, DWORD);
#ifdef wcsicmp
#undef wcsicmp
#endif											

class CW32System
{
private :
	static DWORD		_dwPlatformId;				// platform GetVersionEx();
	static LCID			_syslcid;

public :
	static CIMEShare	*_pIMEShare;
	static UINT			_fRegisteredXBox;			// flag indicating if listbox and combobox were registered
	static DWORD		_dwMajorVersion;			// major version from GetVersionEx()
	static DWORD		_dwMinorVersion;			// minor version from GetVersionEx()
	static INT			_icr3DDarkShadow;			// value to use for COLOR_3DDKSHADOW
	static UINT			_MSIMEMouseMsg;				// mouse operation
	static UINT			_MSIMEReconvertMsg;			// reconversion
	static UINT			_MSIMEReconvertRequestMsg;	// reconversion request
	static UINT			_MSIMEDocFeedMsg;			// document feed
	static UINT			_MSIMEQueryPositionMsg;		// query position
	static UINT			_MSIMEServiceMsg;			// checking MSIME98 or later

	static UINT			_MSMouseRoller;				// mouse scrolling

	// Misc flags used for more precise character classification
	static WORD			_fFEFontInfo;
	static BYTE			_fLRMorRLM;

	// Misc flags used for FE
	static BYTE			_fHaveIMMProcs;
	static BYTE			_fHaveAIMM;
	static BYTE			_fHaveIMMEShare;
	static BYTE			_fLoadAIMM10;

	static	CTmpDisplayAttrArray *_arTmpDisplayAttrib;

	CW32System();

	~CW32System();

	static DWORD AddRef();
	static DWORD Release();

	// Platform testing
	static bool OnWinNTFE()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && IsFELCID(_syslcid );
	}
	static bool OnWinNTNonFE()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && !IsFELCID(_syslcid );
	}
	static bool OnWinNT5()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && 5 == _dwMajorVersion;
	}
	static bool OnWinNT4()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && 4 == _dwMajorVersion;
	}
	static bool OnWin9xFE()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && IsFELCID(_syslcid );
	}
	static bool OnWin9x()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS;
	}
	static bool OnWin95()
	{
		return OnWin9x() && (4 == _dwMajorVersion) && (0 == _dwMinorVersion);
	}
	static bool OnWin95FE()
	{
		return OnWin95() && IsFELCID(_syslcid );
	}
	static bool OnWin9xThai()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && PRIMARYLANGID(_syslcid) == LANG_THAI;
	}
	static bool OnWin9xBiDi()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && IsBiDiLcid(_syslcid);
	}
	static bool OnBiDiOS()
	{
		return IsBiDiLcid(_syslcid) != 0;
	}
	struct WM_CHAR_INFO
	{
		bool _fAccumulate;
		bool _fLeadByte;
		bool _fTrailByte;
		bool _fIMEChar;
	};

	static UINT GetACP() {return _ACP;}

	static LCID GetSysLCID() {return _syslcid;}

#ifndef NOANSIWINDOWS
	static LRESULT ANSIWndProc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, BOOL fIs10Mode );
	static void AnsiFilter( UINT &msg, WPARAM &wparam, LPARAM lparam, void *pvoid, BOOL fIs10Mode = FALSE );
#endif
	static HGLOBAL WINAPI GlobalAlloc( UINT uFlags, DWORD dwBytes );
	static HGLOBAL WINAPI GlobalFree( HGLOBAL hMem );
	static UINT WINAPI GlobalFlags( HGLOBAL hMem );
	static HGLOBAL WINAPI GlobalReAlloc( HGLOBAL hMem, DWORD dwBytes, UINT uFlags );
	static DWORD WINAPI GlobalSize( HGLOBAL hMem );
	static PVOID WINAPI GlobalLock( HGLOBAL hMem );
	static HGLOBAL WINAPI GlobalHandle( LPCVOID pMem );
	static BOOL WINAPI GlobalUnlock( HGLOBAL hMem );
	static void WINAPI REGetCharWidth(
		HDC		hdc,
		WCHAR	ch,
		INT		*pdxp,
		UINT	uiCodePage,
		BOOL	fCustomTextOut);
	static DWORD WINAPI GetKerningPairs(HDC hdc, DWORD ckp, KERNINGPAIR *pkp);

	static void EraseTextOut(HDC hdc, const RECT *prc);

	static void WINAPI REExtTextOut(
		CONVERTMODE cm,
		UINT uiCodePage,
		HDC hdc,
		int x,
		int y,
		UINT fuOptions,
		CONST RECT *lprc,
		const WCHAR *lpString,
		UINT cch,
		CONST INT *lpDx,
		DWORD dwETOFlags);

	static CONVERTMODE WINAPI DetermineConvertMode( HDC hdc, BYTE tmCharSet );
	static void WINAPI CalcUnderlineInfo(HDC hdc, CCcs *pccs, TEXTMETRIC *ptm );
	static BOOL WINAPI EnableScrollBar( HWND hWnd, UINT wSBflags, UINT wArrows );
	static BOOL WINAPI ShowScrollBar( HWND hWnd, int wBar, BOOL bShow, LONG nMax );
	static BOOL WINAPI IsEnhancedMetafileDC( HDC hdc );
	static HPALETTE WINAPI ManagePalette(
		HDC hdc,
		CONST LOGPALETTE *plogpal,
		HPALETTE &hpalOld,
		HPALETTE &hpalNew
	);
	static UINT WINAPI SetTextAlign(
		HDC hdc,
		UINT fMode
	);
	static BOOL WINAPI InvertRect(
		HDC hdc,
		CONST RECT *lprc
	);

	static BOOL PtInRect(const RECT *prc, POINT pt)
	{
		return ::PtInRect(prc, pt);
	}
	static BOOL PtInRect(const RECTUV *prc, POINTUV pt)
	{
		POINT ptxy = {pt.u, pt.v};
		return ::PtInRect((RECT*) prc, ptxy);
	}

	static void InflateRect(RECT *prc, int dxp, int dyp)
	{
		::InflateRect(prc, dxp, dyp);
	}
	static void InflateRect(RECTUV *prc, int dup, int dvp)
	{
		::InflateRect((RECT*) prc, dup, dvp);
	}

	static BOOL IntersectRect(RECT *prcDest, CONST RECT *prc1, CONST RECT *prc2)
	{
		return ::IntersectRect(prcDest, prc1, prc2);
	}

	static BOOL IntersectRect(RECTUV *prcDest, CONST RECTUV *prc1, CONST RECTUV *prc2)
	{
		return ::IntersectRect((RECT*) prcDest, (RECT*) prc1, (RECT*) prc2);
	}

	static void GetFacePriCharSet(HDC hdc, LOGFONT* plf);

	static BOOL WINAPI WinLPtoDP(HDC hdc, LPPOINT lppoints, int nCount);
    static BOOL WINAPI WinDPtoLP(HDC hdc, LPPOINT lppoints, int nCount);

	static long WINAPI WvsprintfA(LONG cb, LPSTR szBuf, LPCSTR szFmt, va_list arglist);

	static int WINAPI MulDivFunc(int nNumber, int nNumerator, int nDenominator);

	static inline LONG HimetricToDevice(LONG z, LONG dzpInch)
	{
		return MulDivFunc(z, dzpInch, HIMETRIC_PER_INCH);
	}
	static inline LONG DeviceToHimetric(LONG z, LONG dzpInch)
	{
		return MulDivFunc(z, HIMETRIC_PER_INCH, dzpInch);
	}

	//
	// Case insensitive ASCII compare
	//
	static BOOL ASCIICompareI( const BYTE *pstr1, const BYTE *pstr2, int iCount )
	{
		int i;	
		for (i = 0; i < iCount && !((pstr1[i] ^ pstr2[i]) & ~0x20); i++)
			;
		return i == iCount;
	}

	//
	// Allocate and convert a MultiByte string to a wide character string
	// Allocated strings must be freed with delete
	//
	static WCHAR *ConvertToWideChar( const char *pstr )
	{
		int istrlen = 0;
		if(pstr)
			for (istrlen; pstr[istrlen]; istrlen++);
		WCHAR *pnew = new WCHAR[istrlen + 1];
		if(pnew && (!pstr || 0 != ::MultiByteToWideChar( 
								CP_ACP, 0, pstr, -1, pnew, istrlen + 1)))
		{
			return pnew;
		}
		return NULL;
	}

	//
	// functions for memory and string management
	//
#ifdef DEBUG
	static void  PvSet(void *pv, char *szFile, int line);
	static PVOID PvAllocDebug(ULONG cbBuf, UINT uiMemFlags, char *szFile, int line);
	static PVOID PvReAllocDebug(PVOID pvBuf, DWORD cbBuf, char *szFile, int line);
	static void  FreePvDebug(PVOID pvBuf);
#endif
	static PVOID PvAlloc(ULONG cbBuf, UINT uiMemFlags);
	static PVOID PvReAlloc(PVOID pvBuf, DWORD cbBuf);
	static void	FreePv(PVOID pvBuf);

	static inline void *MoveMemory(void *dst, const void *src, size_t cb)
	{
		Assert(cb >= 0);
		return memmove(dst, src, cb);
	}

	static inline void *CopyMemory(void *dst, const void *src, size_t cb)
	{
		// Will work for overlapping regions
		Assert(cb >= 0);
		return MoveMemory(dst, src, cb);
	}

	static inline void *FillMemory(void *dst, int fill, size_t cb)
	{
		return memset(dst, fill, cb);
	}

	static inline void *ZeroMemory(void *dst, size_t cb)
	{
		Assert(cb >= 0);
		return memset(dst, 0, cb);
	}

	static inline int CompareMemory(const void *s1, const void *s2, size_t cb)
	{
		return memcmp(s1, s2, cb);
	}

	static size_t wcslen(const wchar_t *wcs);
	static wchar_t * wcscpy(wchar_t * dst, const wchar_t * src);
	static int wcscmp(const wchar_t * src, const wchar_t * dst);
	static int wcsicmp(const wchar_t * src, const wchar_t * dst);
	static wchar_t * wcsncpy (wchar_t * dest, const wchar_t * source, size_t count);
	static int wcsnicmp(const wchar_t *first, const wchar_t *last, size_t count);
	static unsigned long strtoul(const char *);

#ifndef NOFEPROCESSING
	// ----------------------------------
	// IME Support
	// ----------------------------------
	static BOOL ImmInitialize( void );
	static void ImmTerminate( void );
	static LONG ImmGetCompositionStringA ( HIMC, DWORD, PVOID, DWORD, BOOL );
	static LONG ImmGetCompositionStringW ( HIMC, DWORD, PVOID, DWORD, BOOL  );
	static HIMC ImmGetContext ( HWND, BOOL );
	static BOOL ImmSetCompositionFontA ( HIMC, LPLOGFONTA, BOOL );
	static BOOL ImmSetCompositionWindow ( HIMC, LPCOMPOSITIONFORM, BOOL );
	static BOOL ImmReleaseContext ( HWND, HIMC, BOOL );
	static DWORD ImmGetProperty ( HKL, DWORD, BOOL );
	static BOOL ImmGetCandidateWindow ( HIMC, DWORD, LPCANDIDATEFORM, BOOL );
	static BOOL ImmSetCandidateWindow ( HIMC, LPCANDIDATEFORM, BOOL );
	static BOOL ImmNotifyIME ( HIMC, DWORD, DWORD, DWORD, BOOL );
	static HIMC ImmAssociateContext ( HWND, HIMC, BOOL );
	static UINT ImmGetVirtualKey ( HWND, BOOL );
	static HIMC ImmEscape ( HKL, HIMC, UINT, PVOID, BOOL );
	static BOOL ImmGetOpenStatus ( HIMC, BOOL );
	static BOOL ImmSetOpenStatus ( HIMC, BOOL, BOOL );
	static BOOL ImmGetConversionStatus ( HIMC, LPDWORD, LPDWORD, BOOL );
	static BOOL ImmSetConversionStatus ( HIMC, DWORD, DWORD, BOOL );
	static HWND ImmGetDefaultIMEWnd ( HWND , BOOL);
	static BOOL ImmSetCompositionStringW (HIMC, DWORD, PVOID, DWORD, PVOID, DWORD, BOOL);
	static BOOL ImmIsIME ( HKL, BOOL );
	static BOOL FSupportSty ( UINT, UINT );
	static const IMESTYLE * PIMEStyleFromAttr ( const UINT );
	static const IMECOLORSTY * PColorStyleTextFromIMEStyle ( const IMESTYLE * );
	static const IMECOLORSTY * PColorStyleBackFromIMEStyle ( const IMESTYLE * );
	static BOOL FBoldIMEStyle ( const IMESTYLE * );
	static BOOL FItalicIMEStyle ( const IMESTYLE * );
	static BOOL FUlIMEStyle ( const IMESTYLE * );
	static UINT IdUlIMEStyle ( const IMESTYLE * );
	static COLORREF RGBFromIMEColorStyle ( const IMECOLORSTY * );
#endif	// NOFEPROCESSING

	// ----------------------------------
	// National Language Keyboard support
	// ----------------------------------
	static HKL	CheckChangeKeyboardLayout (BYTE iCharRep);
	static HKL	ActivateKeyboard (LONG iCharRep);
	static QWORD GetCharFlags125x(WCHAR ch);
	static BOOL GetKeyboardFlag (WORD dwKeyMask, WORD wKey);
	static WORD GetKeyboardFlags ()				{return _wKeyboardFlags;}
	static HKL  GetKeyboardLayout (DWORD dwThreadID);
	static DWORD GetKeyPadNumber ()				{return _dwNumKeyPad;}
	static WORD GetDeadKey ()					{return _wDeadKey;}
	static void InitKeyboardFlags ();
	static void RefreshKeyboardLayout ();
	static void ResetKeyboardFlag (WORD wFlag)	{_wKeyboardFlags &= ~wFlag;}
	static void SetDeadKey (WORD wDeadKey)		{_wDeadKey = wDeadKey;}
	static void SetKeyboardFlag (WORD wFlag)	{_wKeyboardFlags |= wFlag;}
	static void SetKeyPadNumber (DWORD dwNum)	{_dwNumKeyPad = dwNum;}
	static bool UsingHebrewKeyboard ()
					{return PRIMARYLANGID(_hklCurrent) == LANG_HEBREW;}
	static void InitPreferredFontInfo();
	static bool SetPreferredFontInfo(
		int iCharRep,
		bool fUIFont,
		SHORT iFont,
		BYTE yHeight,
		BYTE bPitchAndFamily
	);
	static bool GetPreferredFontInfo(
		int iCharRep,
		bool fUIFont,
		SHORT& iFont,
		BYTE& yHeight,
		BYTE& bPitchAndFamily
	);
	static bool IsExternalFontCheckActive() {return false;}
	static bool GetExternalPreferredFontInfo(
		const WCHAR *pch,
		LONG	cch,
		BYTE &	iCharRep,
		SHORT &	iFont,
		BYTE &	bPitchAndFamily,
		bool	fUIFont
	)	{ return false;}
	static int GetTextCharsetInfo(
		HDC hdc,                // handle to device context
		LPFONTSIGNATURE lpSig,  // pointer to structure to receive data
		DWORD dwFlags           // reserved; must be zero
	);
	static SHORT GetPreferredFontHeight(	
		bool	fUIFont,
		BYTE	iCharRepOrg, 
		BYTE	iCharRepNew, 
		SHORT	yOrgHeight
	);
	static void CheckInstalledFEFonts();
	static void CheckInstalledKeyboards();
	static bool IsFontAvail( HDC hDC, int iCharRep, bool fUIFont = false, short *piFontIndex = NULL,
		WCHAR *pFontName = NULL);
	static bool IsDefaultFontDefined(LONG iCharRep, bool fUIFont, SHORT &iFont);
#ifndef NOFEPROCESSING
	static bool IsFEFontInSystem( int cpg );
	static UINT GetFEFontInfo( void );
	static int IsFESystem()
	{
		return IsFELCID( _syslcid );
	}
#else
	static bool IsFEFontInSystem( int ) { return FALSE; }
	static UINT GetFEFontInfo( void ) { return 0; };
	static int IsFESystem() { return FALSE; }
#endif

	// Helper routines to get data from temp display attributes array
	static short GetTmpDisplayAttrIdx(TMPDISPLAYATTR &tmpDisplayAttr);
	static short GetTmpUnderline(SHORT idx);
	static bool  GetTmpColor(SHORT idx, COLORREF &crTmpColor, INT iAction);

#ifndef NOACCESSIBILITY 
	// ----------------------------------
	// Accessability Support
	// ----------------------------------
	static HRESULT VariantCopy(VARIANTARG FAR*  pvargDest, VARIANTARG FAR*  pvargSrc);
	static LRESULT LResultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN punk);
	static HRESULT CreateStdAccessibleProxyW(HWND hwnd, LPCWSTR pClassName, LONG idObject, REFIID riid, void** ppvObject);
	static HRESULT AccessibleObjectFromWindow(HWND hWnd, DWORD dwID, REFIID riidInterface, void ** ppvObject);
	static BOOL BlockInput(BOOL fBlock);
	static UINT	SendInput(UINT nInputs, LPINPUT pInputs, int cbSize);
	static VOID	NotifyWinEvent(DWORD dwEvent, HWND hWnd, LONG lObjectType, LONG lObjectId);
#endif
	
	// ----------------------------------
	// OLE Support
	// ----------------------------------
	static HRESULT LoadRegTypeLib ( REFGUID, WORD, WORD, LCID, ITypeLib ** );
	static HRESULT LoadTypeLib ( const OLECHAR *, ITypeLib ** );
	static HRESULT LoadTypeLibEx( LPCOLESTR szFile, REGKIND regkind, ITypeLib ** pptlib );
	static BSTR SysAllocString ( const OLECHAR * );
	static BSTR SysAllocStringLen ( const OLECHAR *, UINT );
	static void SysFreeString ( BSTR );
	static UINT SysStringLen ( BSTR );
	static void VariantInit ( VARIANTARG * );
	static void VariantClear ( VARIANTARG * );
	static HRESULT OleCreateFromData ( LPDATAOBJECT, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, void ** );
	static void CoTaskMemFree ( PVOID );
	static HRESULT CreateBindCtx ( DWORD, LPBC * );
	static HANDLE OleDuplicateData ( HANDLE, CLIPFORMAT, UINT );
	static HRESULT CoTreatAsClass ( REFCLSID, REFCLSID );
	static HRESULT ProgIDFromCLSID ( REFCLSID, LPOLESTR * );
	static HRESULT OleConvertIStorageToOLESTREAM ( LPSTORAGE, LPOLESTREAM );
	static HRESULT OleConvertIStorageToOLESTREAMEx ( LPSTORAGE, CLIPFORMAT, LONG, LONG, DWORD, LPSTGMEDIUM, LPOLESTREAM );
	static HRESULT OleSave ( LPPERSISTSTORAGE, LPSTORAGE, BOOL );
	static HRESULT StgCreateDocfileOnILockBytes ( ILockBytes *, DWORD, DWORD, IStorage ** );
	static HRESULT CreateILockBytesOnHGlobal ( HGLOBAL, BOOL, ILockBytes ** );
	static HRESULT OleCreateLinkToFile ( LPCOLESTR, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, void ** );
	static PVOID CoTaskMemAlloc ( ULONG );
	static PVOID CoTaskMemRealloc ( PVOID, ULONG );
	static HRESULT OleInitialize ( PVOID );
	static void OleUninitialize ( );
	static HRESULT OleSetClipboard ( IDataObject * );
	static HRESULT OleFlushClipboard ( );
	static HRESULT OleIsCurrentClipboard ( IDataObject * );
	static HRESULT DoDragDrop ( IDataObject *, IDropSource *, DWORD, DWORD * );
	static HRESULT OleGetClipboard ( IDataObject ** );
	static HRESULT RegisterDragDrop ( HWND, IDropTarget * );
	static HRESULT OleCreateLinkFromData ( IDataObject *, REFIID, DWORD, LPFORMATETC, IOleClientSite *, IStorage *, void ** );
	static HRESULT OleCreateStaticFromData ( IDataObject *, REFIID, DWORD, LPFORMATETC, IOleClientSite *, IStorage *, void ** );
	static HRESULT OleDraw ( IUnknown *, DWORD, HDC, LPCRECT );
	static HRESULT OleSetContainedObject ( IUnknown *, BOOL );
	static HRESULT CoDisconnectObject ( IUnknown *, DWORD );
	static HRESULT WriteFmtUserTypeStg ( IStorage *, CLIPFORMAT, LPOLESTR );
	static HRESULT WriteClassStg ( IStorage *, REFCLSID );
	static HRESULT SetConvertStg ( IStorage *, BOOL );
	static HRESULT ReadFmtUserTypeStg ( IStorage *, CLIPFORMAT *, LPOLESTR * );
	static HRESULT ReadClassStg ( IStorage *pstg, CLSID * );
	static HRESULT OleRun ( IUnknown * );
	static HRESULT RevokeDragDrop ( HWND );
	static HRESULT CreateStreamOnHGlobal ( HGLOBAL, BOOL, IStream ** );
	static HRESULT GetHGlobalFromStream ( IStream *pstm, HGLOBAL * );
	static HRESULT OleCreateDefaultHandler ( REFCLSID, IUnknown *, REFIID, void ** );
	static HRESULT CLSIDFromProgID ( LPCOLESTR, LPCLSID );
	static HRESULT OleConvertOLESTREAMToIStorage ( LPOLESTREAM, IStorage *, const DVTARGETDEVICE * );
	static HRESULT OleLoad ( IStorage *, REFIID, IOleClientSite *, void ** );
	static HRESULT ReleaseStgMedium ( LPSTGMEDIUM );
	static HRESULT CoCreateInstance (REFCLSID rclsid, LPUNKNOWN pUnknown,
					DWORD dwClsContext, REFIID riid, PVOID *ppv);
	static HRESULT OleCreateFromFile (REFCLSID, LPCOLESTR, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, LPVOID *);
	static void FreeOle();

#ifndef NOFEPROCESSING
	static void FreeIME();
	static BOOL HaveIMEShare();
	static BOOL getIMEShareObject(CIMEShare **ppIMEShare);	
	static BOOL IsAIMMLoaded() { return _fHaveAIMM; }
	static BOOL GetAimmObject(IUnknown **ppAimm);
	static BOOL LoadAIMM(BOOL fUseAimm12);
	static HRESULT AIMMDefWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam, LRESULT *plres);
	static HRESULT AIMMGetCodePage (HKL hKL, UINT *uCodePage);
	static HRESULT AIMMActivate (BOOL fRestoreLayout);
	static HRESULT AIMMDeactivate (void);
	static HRESULT AIMMFilterClientWindows(ATOM *aaClassList, UINT uSize, HWND hWnd);
	static HRESULT AIMMUnfilterClientWindows(HWND hWnd);
	static UINT GetDisplayGUID (HIMC hIMC, UINT uAttribute);
#endif	// NOFEPROCESSING
	
	int __cdecl sprintf(char * buff, char *fmt, ...);

#ifdef DEBUG
	int	__cdecl strcmp(const char *, const char *);
	char *	__cdecl strrchr(const char *, int);
	char *	__cdecl strcat(char *, const char *);
#endif

	// ----------------------------------
	// Useful ANSI<-->Unicode conversion
	//          and language id routines
	// ----------------------------------
	static int	MbcsFromUnicode(LPSTR pstr, int cch, LPCWSTR pwstr, 
					int cwch = -1, UINT codepage = CP_ACP,
					UN_FLAGS flags = UN_CONVERT_WCH_EMBEDDING);
	static int	UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch = -1,
					UINT uiCodePage = CP_ACP);
	static int	MBTWC(INT CodePage, DWORD dwFlags, LPCSTR pstrMB, int cchMB,
					LPWSTR pstrWC, int cchWC, LPBOOL pfNoCodePage);
	static int	WCTMB(INT CodePage, DWORD dwFlags, LPCWSTR pstrWC, int cchWC,
					LPSTR pstrMB, int cchMB, LPCSTR	pchDefault, LPBOOL pfUsedDef,
					LPBOOL pfNoCodePage, BOOL fTestCodePage = FALSE);
	static int	VerifyFEString(INT cpg, LPCWSTR pstrWC, int cchWC, BOOL	fTestInputCpg);
	static HGLOBAL TextHGlobalAtoW( HGLOBAL hglobal );
	static HGLOBAL TextHGlobalWtoA( HGLOBAL hglobal );
	static LONG  CharRepFontSig(QWORD qwFontSig, BOOL fFirstAvailable);
	static UINT  CharRepFromLID(WORD lid, BOOL fPlane2 = FALSE);
	static LONG	 CharRepFromCharSet(BYTE bCharSet);
	static INT	 CharRepFromCodePage(LONG CodePage);
	static LONG  CharRepFromFontSig(QWORD qwFontSig)
					{return CharRepFontSig(qwFontSig, FALSE);}
	static BYTE  CharSetFromCharRep(LONG iCharRep);
	static INT	CodePageFromCharRep(LONG iCharRep);
	static QWORD FontSigFromCharRep(LONG iCharRep);

#ifndef NOCOMPLEXSCRIPTS
	static HKL	FindDirectionalKeyboard(BOOL fRTL);
#else
	static HKL	FindDirectionalKeyboard(BOOL fRTL) {return NULL;}
#endif
	static BYTE GetCharSet(INT cpg, int *piCharRep = NULL);
	static BYTE MatchFECharRep(QWORD qwCharFlags, QWORD qwFontSig);
	static BYTE GetFirstAvailCharRep(QWORD qwFontSig)
					{return CharRepFontSig(qwFontSig, TRUE);}
	static UINT GetKeyboardCharRep(DWORD dwMakeAPICall = 0);
	static UINT GetKeyboardCodePage(DWORD dwMakeAPICall = 0)
					{return CodePageFromCharRep(GetKeyboardCharRep(dwMakeAPICall));}
	static LCID GetKeyboardLCID(DWORD dwMakeAPICall = 0);
	static UINT GetLocaleCharRep();
	static HKL	GetPreferredKbd(LONG iCharRep) {return _hkl[iCharRep];}
	static void	SetPreferredKbd(LONG iCharRep, HKL hkl) {_hkl[iCharRep] = hkl;}
	static UINT GetSystemDefaultCodePage()
					{return CodePageFromCharRep(CharRepFromLID(GetSystemDefaultLangID()));}
	static int	GetTrailBytesCount(BYTE ach, UINT cpg);

	static BOOL Is8BitCodePage(unsigned CodePage);
	static BOOL Is8BitCharRep(unsigned iCharRep)
					{return IN_RANGE(ANSI_INDEX, iCharRep, THAI_INDEX);}
	static BOOL IsAlef(WCHAR ch);
	static BOOL IsBiDiCharSet(unsigned CharSet)
					{return IN_RANGE(HEBREW_CHARSET, CharSet, ARABIC_CHARSET);}
	static BOOL IsBiDiCharRep(unsigned iCharRep)
					{return IN_RANGE(HEBREW_INDEX, iCharRep, ARABIC_INDEX) ||
							IN_RANGE(SYRIAC_INDEX, iCharRep, THAANA_INDEX);}
	static BOOL IsIndicCharRep(unsigned iCharRep)
					{return IN_RANGE(INDIC_FIRSTINDEX, iCharRep, INDIC_LASTINDEX);}
	static bool IsBiDiCodePage(int cpg)
					{return	IN_RANGE(CP_HEBREW, cpg, CP_ARABIC);}
	static bool IsBiDiKbdInstalled()
					{return	_hkl[HEBREW_INDEX] || _hkl[ARABIC_INDEX];}
	static bool IsThaiKbdInstalled()
					{return	_hkl[THAI_INDEX] != 0;}
	static bool IsIndicKbdInstalled();
	static bool IsComplexKbdInstalled()
					{return	IsBiDiKbdInstalled() || IsThaiKbdInstalled() || IsIndicKbdInstalled();}
	static bool IsVietnameseCodePage(int cpg)
					{return	cpg == CP_VIETNAMESE;}
	static BOOL IsDiacritic(WCHAR ch);
	static BOOL IsBiDiDiacritic(WCHAR ch);
	static BOOL IsBiDiKashida(WCHAR ch)
					{return ch == 0x0640;}
	static BOOL IsBiDiLcid(LCID lcid);
	static BOOL IsIndicLcid(LCID lcid);
	static BOOL IsComplexScriptLcid(LCID lcid);
#ifndef NOCOMPLEXSCRIPTS
	static BOOL IsDiacriticOrKashida(WCHAR ch, WORD wC3Type);
#else
	static BOOL IsDiacriticOrKashida(WCHAR, WORD) { return FALSE; }
#endif
	static bool IsFELCID(LCID lcid);
	static BOOL IsFECharSet (BYTE bCharSet);
	static BOOL IsFECharRep (BYTE iCharRep)
					{return IN_RANGE(SHIFTJIS_INDEX, iCharRep, BIG5_INDEX);}
	static bool IsFECodePage(int cpg)
					{return	IN_RANGE(CP_JAPAN, cpg, CP_CHINESE_TRAD);}
	static BOOL IsFECodePageFont (DWORD dwFontSig);
	static BOOL IsRTLCharRep(BYTE iCharRep)
					{return IN_RANGE(HEBREW_INDEX, iCharRep, ARABIC_INDEX);}
	static BOOL IsRTLCharSet(BYTE bCharSet);
		   BOOL IsStrongDirectional(CC cc)	{return cc <= CC_LTR;}
	static BOOL IsVietCdmSequenceValid(WCHAR ch1, WCHAR ch2);
	static BOOL IsUTF8BOM(BYTE *pstr);

	static WPARAM ValidateStreamWparam(WPARAM wparam);

	static CC	MECharClass(WCHAR ch);

	static HDC GetScreenDC();


	// ----------------------------------
	// Unicode Wrapped Functions
	// ----------------------------------

	// We could use inline and a function pointer table to improve efficiency and code size.

	static ATOM WINAPI RegisterREClass(
		const WNDCLASSW *lpWndClass
	);
	static BOOL GetVersion(
		DWORD *pdwPlatformId,
		DWORD *pdwMajorVersion,
		DWORD *pdwMinorVersion
	);
	static BOOL GetStringTypes(
		LCID	lcid,
		LPCTSTR lpSrcStr,
		int		cchSrc,
		LPWORD	lpCharType1,
		LPWORD	lpCharType3
	);
	static BOOL WINAPI GetStringTypeEx(
		LCID     Locale,
		DWORD    dwInfoType,
		LPCWSTR lpSrcStr,
		int      cchSrc,
		LPWORD   lpCharType
	);
	static LPWSTR WINAPI CharLower(LPWSTR pwstr);
	static DWORD WINAPI CharLowerBuff(LPWSTR pwstr, DWORD cchLength);
	static DWORD WINAPI CharUpperBuff(LPWSTR pwstr, DWORD cchLength);
	static HDC WINAPI CreateIC(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData
	);
	static HANDLE WINAPI CreateFile(
        LPCWSTR                 lpFileName,
        DWORD                   dwDesiredAccess,
        DWORD                   dwShareMode,
        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
        DWORD                   dwCreationDisposition,
        DWORD                   dwFlagsAndAttributes,
        HANDLE                  hTemplateFile
    );

	static HFONT WINAPI CreateFontIndirect(CONST LOGFONTW * plfw);
	static int WINAPI CompareString ( 
		LCID  Locale,			// locale identifier 
		DWORD  dwCmpFlags,		// comparison-style options 
		LPCWSTR  lpString1,		// pointer to first string 
		int  cch1,			// size, in bytes or characters, of first string 
		LPCWSTR  lpString2,		// pointer to second string 
		int  cch2 			// size, in bytes or characters, of second string  
	);
	static LRESULT WINAPI DefWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	static int WINAPI GetObject(HGDIOBJ hgdiObj, int cbBuffer, PVOID lpvObj);
	static DWORD APIENTRY GetProfileSection(
		LPCWSTR lpAppName,
		LPWSTR lpReturnedString,
		DWORD nSize
	);
	static int WINAPI GetTextFace(
        HDC    hdc,
        int    cch,
        LPWSTR lpFaceName
	);
	static BOOL WINAPI GetTextMetrics(HDC hdc, LPTEXTMETRICW lptm);
	static BOOL WINAPI GetTextMetrics(HDC hdc, LOGFONTW &lf, TEXTMETRICW &tm);
	static LONG WINAPI GetWindowLong(HWND hWnd, int nIndex);
	static LONG_PTR WINAPI GetWindowLongPtr(HWND hWnd, int nIndex);
	static DWORD WINAPI GetClassLong(HWND hWnd, int nIndex);
	static HBITMAP WINAPI LoadBitmap(HINSTANCE hInstance, LPCWSTR lpBitmapName);
	static HBITMAP WINAPI GetPictureBitmap(IStream *pstm);
	static HCURSOR WINAPI LoadCursor(HINSTANCE hInstance, LPCWSTR lpCursorName);
	static HINSTANCE WINAPI LoadLibrary(LPCWSTR lpLibFileName);
	static LRESULT WINAPI SendMessage(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam
	);
	static LONG WINAPI SetWindowLong(HWND hWnd, int nIndex, LONG dwNewLong);
	static LONG WINAPI SetWindowLongPtr(HWND hWnd, int nIndex, LONG_PTR dwNew);
	static BOOL WINAPI PostMessage(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam
	);
	static BOOL WINAPI UnregisterClass(LPCWSTR lpClassName, HINSTANCE hInstance);
	static int WINAPI lstrcmpi(LPCWSTR lpString1, LPCWSTR lpString2);
	static BOOL WINAPI PeekMessage(
        LPMSG   lpMsg,
        HWND    hWnd,
        UINT    wMsgFilterMin,
        UINT    wMsgFilterMax,
        UINT    wRemoveMsg
	);
	static DWORD WINAPI GetModuleFileName(
		HMODULE hModule,
		LPWSTR lpFilename,
		DWORD nSize
    );
	static DWORD GetCurrentThreadId(void);
	static BOOL TrackMouseLeave(HWND hWnd);
	static COLORREF GetCtlBorderColor(BOOL fMousedown, BOOL fMouseover);
	static COLORREF GetCtlBkgColor(BOOL fMousedown, BOOL fMouseover);
	static COLORREF GetCtlTxtColor(BOOL fMousedown, BOOL fMouseover, BOOL fDisabled);
	static void DrawBorderedRectangle(
		HDC hdc,
		RECT *prc,
		COLORREF crBorder,
		COLORREF crBackground
	);			
	static void DrawArrow(
		HDC hdc,
		RECT *prc,
		COLORREF crArrow
	);

private:
	// System Parameters
	static BOOL		_fSysParamsOk;			// System Parameters have been Initialized
	static INT 		_dupSystemFont;				// average char width of system font
	static INT 		_dvpSystemFont;			// height of system font
	static INT		_ySysFontLeading;		// System font internal leading
	static BOOL 	_fUsePalette;
	static LONG 	_xPerInchScreenDC;		// Pixels per inch used for conversions ...
	static LONG 	_yPerInchScreenDC;		// ... and determining whether screen or ...
	static INT		_cxBorder;				// GetSystemMetricx(SM_CXBORDER)...
	static INT		_cyBorder;				// GetSystemMetricx(SM_CYBORDER)...
	static INT		_cxVScroll;				// Width/height of scrlbar arw bitmap
	static INT		_cyHScroll;				// Width of scrlbar arw bitmap
	static LONG 	_dxSelBar;
	static INT		_sysiniflags;			// Start using line services from the start

	static UINT		_ACP;					// Current Ansi code page identifier

	static HDC		_hdcScreen;
	// Double click distances
	static INT		_cxDoubleClk;
	static INT		_cyDoubleClk;	

	// Double Click Time in milliseconds
	static INT		_DCT;

	//Width of hot zone (in pixels) for auto-scrolling
    static WORD	_nScrollInset;
    //Delay (in ms) before scrolling
    static WORD _nScrollDelay;
	//Interval (in ms) at which we scroll
    static WORD _nScrollInterval;
	//Amount of horizontal scroll at each interval (pixels)
	static WORD _nScrollHAmount;
	//Amount of vertical scroll at each interval (pixels)
	static WORD _nScrollVAmount;
	//Amount of time to wait for determining start of drag operation
	static WORD _nDragDelay;
	//Minimun distance that must be traversed within drag delay time interval
	static WORD _nDragMinDist;
	//Keyboard deadkey
	static WORD _wDeadKey;
	//Keyboard shift/ctrl/alt/lock status
	static WORD _wKeyboardFlags;
	//North/South sizing cursor (double arrow)
	static HCURSOR _hcurSizeNS;
	//West/East sizing cursor (double arrow)
	static HCURSOR _hcurSizeWE;
	//Northwest/Southeast sizing cursor (double arrow)
	static HCURSOR _hcurSizeNWSE;
	//Northeast/Southwest sizing cursor (double arrow)
	static HCURSOR _hcurSizeNESW;
	//Number of Lines to scroll with a mouse roller wheel, -1 for pages
	static LONG	_cLineScroll;
	//System Font Handle.  This one need only be done once.
	static HFONT _hSystemFont;
	//Default Font Handle.  This one need only be done once.
	static HFONT _hDefaultFont;
	//System Keyboard Layout
	static HKL _hklCurrent;
	static HKL _hkl[NCHARREPERTOIRES];

	// Ref Count
	static DWORD _cRefs;

	//AltNumericKeyboard number
	static DWORD _dwNumKeyPad;

	//Digit substitution mode (context, none, national)
	static BYTE	_bDigitSubstMode;

	//SYSTEM_FONT charset
	static BYTE _bCharSetSys;

public:
	static INT	GetDupSystemFont()	 {return _dupSystemFont; }
	static INT	GetDvpSystemFont()	 {return _dvpSystemFont; }
	static INT	GetSysFontLeading()	 {return _ySysFontLeading; }
	static LONG GetXPerInchScreenDC(){return _xPerInchScreenDC; }
	static LONG GetYPerInchScreenDC(){return _yPerInchScreenDC; }
	static INT	GetCxBorder()		 {return _cxBorder; }
	static INT	GetCyBorder()		 {return _cyBorder; }
	static INT	GetCyHScroll()		 {return _cyHScroll; }
	static INT	GetCxVScroll()		 {return _cxVScroll; }
	static LONG GetDxSelBar()		 {return _dxSelBar; }
    static WORD GetScrollInset()	 {return _nScrollInset; }
    static WORD GetScrollDelay()	 {return _nScrollDelay; }
    static WORD GetScrollInterval()	 {return _nScrollInterval; }
	static WORD GetScrollHAmount()	 {return _nScrollHAmount; }
	static WORD GetScrollVAmount()	 {return _nScrollVAmount; }
	static INT	GetCxDoubleClk()	 {return _cxDoubleClk; }
	static INT	GetCyDoubleClk()	 {return _cyDoubleClk; }
	static INT	GetDCT()			 {return _DCT; }
	static WORD GetDragDelay()		 {return _nDragDelay; }
	static WORD GetDragMinDist()	 {return _nDragMinDist; }
	static LONG GetRollerLineScrollCount();
	static HCURSOR GetSizeCursor(LPTSTR idcur);
	static HFONT GetSystemFont()	 {return _hSystemFont; }
	static BYTE ReadRegDigitSubstitutionMode();
	static BYTE GetDigitSubstitutionMode() {return _bDigitSubstMode;}
	static bool fUseAimm()			 {return (_sysiniflags & SYSINI_USEAIMM) != 0;}
	static bool fUseCTF()			 {return (_sysiniflags & SYSINI_USECTF) != 0;}
	static bool fUseBiDi()			 {return (_sysiniflags & SYSINI_BIDI) != 0;} 
	static bool fUseLs()			 {return (_sysiniflags & SYSINI_USELS) != 0;} 
	static bool fDebugFont()		 {return (_sysiniflags & SYSINI_DEBUGFONT) != 0;} 
	static int  DebugDefaultCpg()    {return HIWORD(_sysiniflags);}
	static BOOL FUsePalette()		 {return _fUsePalette; }
	static void InitSysParams(BOOL fUpdate = FALSE);
	static DWORD GetRefs()			 {return _cRefs;}
	static BYTE	GetSysCharSet()		 {return _bCharSetSys;}
	static BOOL IsForegroundFrame(HWND);

	// Should also be wrapped but aren't.  Used for debugging.
	// MessageBox
	// OutputDebugString

	// lstrcmpiA should also be wrapped for Win CE's sake but the code
	// that uses it is ifdeffed out for WINCE.

	// Mirroring API entry points
	static PFN_GETLAYOUT			_pfnGetLayout;
	static PFN_SETLAYOUT			_pfnSetLayout;

#ifndef NODRAFTMODE
public:
	static bool GetDraftModeFontInfo(
		SHORT &iFont,
		SHORT &yHeight,
		QWORD &qwFontSig,
		COLORREF &crColor
	);

private:
	struct DraftModeFontInfo {
		SHORT _iFont;
		SHORT _yHeight;
		QWORD _qwFontSig;
		COLORREF _crTextColor;
	};
	static struct DraftModeFontInfo _draftModeFontInfo;
#endif
};

extern CW32System *W32;
HKL	   g_hkl[];

// This fixes a problem with MulDiv reference in _font.h
#define W32MulDiv					W32->MulDivFunc

#if !defined(W32SYS_CPP)

#define OnWinNTFE					W32->OnWinNTFE
#define OnWin95FE					W32->OnWin95FE
#if defined(DEBUG)
#define PvAlloc(cbBuf, uiMemFlags)	W32->PvAllocDebug(cbBuf, uiMemFlags, __FILE__, __LINE__)
#define PvReAlloc(pv, cbBuf)		W32->PvReAllocDebug(pv, cbBuf, __FILE__, __LINE__)
#define PvSet(pv)					W32->PvSet(pv, __FILE__, __LINE__)
#define FreePv						W32->FreePvDebug
#else
#define PvAlloc						W32->PvAlloc
#define PvReAlloc					W32->PvReAlloc
#define FreePv						W32->FreePv
#define PvSet(pv)
#endif
#define CopyMemory					W32->CopyMemory
#define MoveMemory					W32->MoveMemory
#define FillMemory					W32->FillMemory
#define ZeroMemory					W32->ZeroMemory
#define CompareMemory				W32->CompareMemory
#define GlobalAlloc					W32->GlobalAlloc
#define GlobalFree					W32->GlobalFree
#define GlobalFlags					W32->GlobalFlags
#define	GlobalReAlloc				W32->GlobalReAlloc
#define	GlobalSize					W32->GlobalSize
#define	GlobalLock					W32->GlobalLock
#define	GlobalHandle				W32->GlobalHandle
#define	GlobalUnlock				W32->GlobalUnlock

#define ImmInitialize				W32->ImmInitialize
#define ImmTerminate				W32->ImmTerminate

#define ImmGetCompositionStringA	W32->ImmGetCompositionStringA
#define ImmGetCompositionStringW	W32->ImmGetCompositionStringW
#define ImmGetContext				W32->ImmGetContext
#define ImmSetCompositionFontA		W32->ImmSetCompositionFontA
#define ImmSetCompositionWindow		W32->ImmSetCompositionWindow
#define ImmReleaseContext			W32->ImmReleaseContext
#define ImmGetProperty				W32->ImmGetProperty
#define ImmGetCandidateWindow		W32->ImmGetCandidateWindow
#define ImmSetCandidateWindow		W32->ImmSetCandidateWindow
#define ImmNotifyIME				W32->ImmNotifyIME
#define ImmAssociateContext			W32->ImmAssociateContext
#define ImmGetVirtualKey			W32->ImmGetVirtualKey
#define ImmEscape					W32->ImmEscape
#define ImmGetOpenStatus			W32->ImmGetOpenStatus
#define ImmSetOpenStatus			W32->ImmSetOpenStatus
#define ImmGetConversionStatus		W32->ImmGetConversionStatus
#define ImmSetConversionStatus		W32->ImmSetConversionStatus
#define ImmGetDefaultIMEWnd			W32->ImmGetDefaultIMEWnd
#define ImmSetCompositionStringW	W32->ImmSetCompositionStringW
#define ImmIsIME					W32->ImmIsIME
#define LoadRegTypeLib				W32->LoadRegTypeLib
#define LoadTypeLib					W32->LoadTypeLib
#define SysAllocString				W32->SysAllocString
#define SysAllocStringLen			W32->SysAllocStringLen
#define SysFreeString				W32->SysFreeString
#define SysStringLen				W32->SysStringLen
#define VariantInit					W32->VariantInit
#define VariantClear				W32->VariantClear
#define OleCreateFromData			W32->OleCreateFromData
#define CoTaskMemFree				W32->CoTaskMemFree
#define CreateBindCtx				W32->CreateBindCtx
#define OleDuplicateData			W32->OleDuplicateData
#define CoTreatAsClass				W32->CoTreatAsClass
#define ProgIDFromCLSID				W32->ProgIDFromCLSID
#define OleConvertIStorageToOLESTREAM W32->OleConvertIStorageToOLESTREAM
#define OleConvertIStorageToOLESTREAMEx W32->OleConvertIStorageToOLESTREAMEx
#define OleSave						W32->OleSave
#define StgCreateDocfileOnILockBytes W32->StgCreateDocfileOnILockBytes
#define CreateILockBytesOnHGlobal	W32->CreateILockBytesOnHGlobal
#define OleCreateLinkToFile			W32->OleCreateLinkToFile
#define CoTaskMemAlloc				W32->CoTaskMemAlloc
#define CoTaskMemRealloc			W32->CoTaskMemRealloc
#define OleInitialize				W32->OleInitialize
#define OleUninitialize				W32->OleUninitialize
#define OleSetClipboard				W32->OleSetClipboard
#define OleFlushClipboard			W32->OleFlushClipboard
#define OleIsCurrentClipboard		W32->OleIsCurrentClipboard
#define DoDragDrop					W32->DoDragDrop
#define OleGetClipboard				W32->OleGetClipboard
#define RegisterDragDrop			W32->RegisterDragDrop
#define OleCreateLinkFromData		W32->OleCreateLinkFromData
#define OleCreateStaticFromData		W32->OleCreateStaticFromData
#define OleDraw						W32->OleDraw
#define OleSetContainedObject		W32->OleSetContainedObject
#define CoDisconnectObject			W32->CoDisconnectObject
#define WriteFmtUserTypeStg			W32->WriteFmtUserTypeStg
#define WriteClassStg				W32->WriteClassStg
#define SetConvertStg				W32->SetConvertStg
#define ReadFmtUserTypeStg			W32->ReadFmtUserTypeStg
#define ReadClassStg				W32->ReadClassStg
#define OleRun						W32->OleRun
#define RevokeDragDrop				W32->RevokeDragDrop
#define CreateStreamOnHGlobal		W32->CreateStreamOnHGlobal
#define GetHGlobalFromStream		W32->GetHGlobalFromStream
#define OleCreateDefaultHandler		W32->OleCreateDefaultHandler
#define CLSIDFromProgID				W32->CLSIDFromProgID
#define OleConvertOLESTREAMToIStorage W32->OleConvertOLESTREAMToIStorage
#define OleLoad						W32->OleLoad
#define ReleaseStgMedium			W32->ReleaseStgMedium
#define CoCreateInstance			W32->CoCreateInstance

#ifndef NOFEPROCESSING
#define FSupportSty					W32->FSupportSty
#define PIMEStyleFromAttr			W32->PIMEStyleFromAttr
#define PColorStyleTextFromIMEStyle W32->PColorStyleTextFromIMEStyle
#define PColorStyleBackFromIMEStyle W32->PColorStyleBackFromIMEStyle
#define FBoldIMEStyle				W32->FBoldIMEStyle
#define FItalicIMEStyle				W32->FItalicIMEStyle
#define FUlIMEStyle					W32->FUlIMEStyle
#define IdUlIMEStyle				W32->IdUlIMEStyle
#define RGBFromIMEColorStyle		W32->RGBFromIMEColorStyle
#endif	// NOFEPROCESSING

#define fHaveIMMProcs				W32->_fHaveIMMProcs
#define fHaveAIMM					W32->_fHaveAIMM
#define fLoadAIMM10					W32->_fLoadAIMM10
#define dwPlatformId				W32->_dwPlatformId
#define icr3DDarkShadow				W32->_icr3DDarkShadow
#define MSIMEMouseMsg				W32->_MSIMEMouseMsg				
#define MSIMEReconvertMsg			W32->_MSIMEReconvertMsg		
#define MSIMEReconvertRequestMsg	W32->_MSIMEReconvertRequestMsg
#define MSIMEDocFeedMsg				W32->_MSIMEDocFeedMsg
#define MSIMEQueryPositionMsg		W32->_MSIMEQueryPositionMsg
#define MSIMEServiceMsg				W32->_MSIMEServiceMsg

#define CharRepFromCharSet			W32->CharRepFromCharSet
#define CharRepFromCodePage			W32->CharRepFromCodePage
#define CharSetFromCharRep			W32->CharSetFromCharRep
#define CodePageFromCharRep			W32->CodePageFromCharRep
#define MECharClass					W32->MECharClass
#define MbcsFromUnicode				W32->MbcsFromUnicode	
#define UnicodeFromMbcs				W32->UnicodeFromMbcs
#define TextHGlobalAtoW				W32->TextHGlobalAtoW
#define TextHGlobalWtoA				W32->TextHGlobalWtoA
#define CharRepFromLID				W32->CharRepFromLID
#define In125x						W32->In125x	

#define Is8BitCharRep				W32->Is8BitCharRep
#define Is8BitCodePage				W32->Is8BitCodePage
#define IsAlef						W32->IsAlef
#define IsAmbiguous					W32->IsAmbiguous
#define IsBiDiCharRep				W32->IsBiDiCharRep
#define IsBiDiCharSet				W32->IsBiDiCharSet
#define IsBiDiDiacritic				W32->IsBiDiDiacritic
#define IsBiDiKashida				W32->IsBiDiKashida
#define IsBiDiKbdInstalled			W32->IsBiDiKbdInstalled
#define IsDiacritic					W32->IsDiacritic
#define IsDiacriticOrKashida		W32->IsDiacriticOrKashida
#define IsFECharRep					W32->IsFECharRep
#define IsFECharSet					W32->IsFECharSet	
#define IsFELCID					W32->IsFELCID	
#define IsRTLCharRep				W32->IsRTLCharRep
#define IsRTLCharSet				W32->IsRTLCharSet	
#define IsStrongDirectional			W32->IsStrongDirectional
#define IsThaiKbdInstalled			W32->IsThaiKbdInstalled
#define IsIndicKbdInstalled			W32->IsIndicKbdInstalled
#define IsComplexKbdInstalled		W32->IsComplexKbdInstalled
#define	IsTrailByte					W32->IsTrailByte
#define IsVietCdmSequenceValid		W32->IsVietCdmSequenceValid
	
#define	GetCharSet					W32->GetCharSet	
#define	FontSigFromCharRep			W32->FontSigFromCharRep
#define GetFirstAvailCharRep		W32->GetFirstAvailCharRep
#define MatchFECharRep				W32->MatchFECharRep
#define	GetKeyboardCharRep			W32->GetKeyboardCharRep	
#define	GetKeyboardCodePage			W32->GetKeyboardCodePage	
#define	GetKeyboardLCID				W32->GetKeyboardLCID	
#define	GetLocaleCharRep			W32->GetLocaleCharRep
#define	GetSystemDefaultCodePage	W32->GetSystemDefaultCodePage
#define GetTrailBytesCount			W32->GetTrailBytesCount	
#define	MBTWC						W32->MBTWC	
#define	WCTMB						W32->WCTMB
#define VerifyFEString				W32->VerifyFEString		
#define	GetKerningPairs				W32->GetKerningPairs

#define CharLower					W32->CharLower
#define CharLowerBuff				W32->CharLowerBuff
#define CharUpperBuff				W32->CharUpperBuff
#define CreateIC					W32->CreateIC
#define CreateFile					W32->CreateFile
#define CreateFontIndirect			W32->CreateFontIndirect
#define CompareString				W32->CompareString
#define DefWindowProc				W32->DefWindowProc
#define GetDeadKey					W32->GetDeadKey
#define GetKeyboardFlag				W32->GetKeyboardFlag
#define GetKeyboardFlags			W32->GetKeyboardFlags
#define GetKeyboardLayout			W32->GetKeyboardLayout
#define GetKeyPadNumber				W32->GetKeyPadNumber
#define GetProfileSection			W32->GetProfileSection
#define GetTextMetrics				W32->GetTextMetrics
#define GetTextFace					W32->GetTextFace
#define GetWindowLong				W32->GetWindowLong
#define GetWindowLongPtr			W32->GetWindowLongPtr
#define GetClassLong				W32->GetClassLong
#define InitKeyboardFlags			W32->InitKeyboardFlags
#define IsEnhancedMetafileDC		W32->IsEnhancedMetafileDC
#define LoadBitmap					W32->LoadBitmap
#define LoadCursor					W32->LoadCursor
#define LoadLibrary					W32->LoadLibrary
#define ResetKeyboardFlag			W32->ResetKeyboardFlag
#define SendMessage					W32->SendMessage
#define SetDeadKey					W32->SetDeadKey
#define SetKeyboardFlag				W32->SetKeyboardFlag
#define SetKeyPadNumber				W32->SetKeyPadNumber
#define SetWindowLong				W32->SetWindowLong
#define SetWindowLongPtr			W32->SetWindowLongPtr
#define PostMessage					W32->PostMessage
#define lstrcmpi					W32->lstrcmpi
#define PeekMessage					W32->PeekMessage
#define WinLPtoDP                   W32->WinLPtoDP
#define WinDPtoLP                   W32->WinDPtoLP
#define MulDiv						W32->MulDivFunc

#define InflateRect					W32->InflateRect
#define PtInRect					W32->PtInRect
#define IntersectRect				W32->IntersectRect

#define InflateRect					W32->InflateRect
#define PtInRect					W32->PtInRect
#define IntersectRect				W32->IntersectRect

// AIMM wrapper
#define IsAIMMLoaded				W32->IsAIMMLoaded
#define LoadAIMM					W32->LoadAIMM
#define CallAIMMDefaultWndProc		W32->AIMMDefWndProc
#define GetAIMMKeyboardCP			W32->AIMMGetCodePage
#define ActivateAIMM				W32->AIMMActivate
#define DeactivateAIMM				W32->AIMMDeactivate
#define FilterClientWindowsAIMM		W32->AIMMFilterClientWindows
#define UnfilterClientWindowsAIMM	W32->AIMMUnfilterClientWindows
#define sprintf						W32->sprintf

#ifdef DEBUG
#define strrchr						W32->strrchr
#define strcmp						W32->strcmp
#define strcat						W32->strcat
#endif

#define wcslen						W32->wcslen
#define wcscpy						W32->wcscpy
#define wcscmp						W32->wcscmp
#define wcsicmp						W32->wcsicmp
#define wcsncpy						W32->wcsncpy

#define W32GetLayout					(*W32->_pfnGetLayout)
#define W32SetLayout					(*W32->_pfnSetLayout)

#define GetTmpTextColor(a, b)		W32->GetTmpColor(a, b, GET_TEMP_TEXT_COLOR)
#define GetTmpBackColor(a, b)		W32->GetTmpColor(a, b, GET_TEMP_BACK_COLOR)
#define GetTmpUnderlineColor(a, b)	W32->GetTmpColor(a, b, GET_TEMP_UL_COLOR)
#define GetTmpDisplayAttrIdx		W32->GetTmpDisplayAttrIdx
#define GetTmpUnderline				W32->GetTmpUnderline

#define GetACP						W32->GetACP
#define GetSysLCID					W32->GetSysLCID

#define SetTextAlign				W32->SetTextAlign
#define	InvertRect					W32->InvertRect

#endif // !defined(W32SYS_CPP)

#ifndef offsetof
#define offsetof(s,m) ((size_t)&(((s*)0)->m))
#endif

#ifdef UNDER_CE

// The follwing definitions do not exist in the Windows CE environment but we emulate them.
// The values have been copied from the appropriate win32 header files.
// These definitions should be removed if Ce adds them

// Scroll Bars
#ifndef ESB_ENABLE_BOTH
#define ESB_ENABLE_BOTH				0x0000
#define ESB_DISABLE_BOTH			0x0003
#endif

// Text alignment values
#ifndef TA_TOP
#define TA_TOP                      0
#define TA_BOTTOM                   8
#define TA_BASELINE                 24
#define TA_CENTER                   6
#define TA_LEFT                     0
#define TA_RIGHT					2
#endif

// Device Technology.  This one is mostly used for exclusion
#ifndef DT_METAFILE
#define DT_METAFILE         5   // Metafile, VDM
#endif

// FInd/Replace options
#ifndef FR_DOWN
#define FR_DOWN                         0x00000001
#define FR_WHOLEWORD                    0x00000002
#define FR_MATCHCASE                    0x00000004
#endif

// Window messages
#ifndef WM_NCMOUSEMOVE
#define WM_NCMOUSEMOVE                  0x00A0
#endif
#ifndef WM_NCMBUTTONDBLCLK
#define WM_NCMBUTTONDBLCLK              0x00A9
#endif
#ifndef WM_DROPFILES
#define WM_DROPFILES                    0x0233
#endif

// Clipboard formats
#ifndef CF_METAFILEPICT
#define CF_METAFILEPICT     3
#endif

/* Pen Styles : Windows CE only supports PS_DASH */
#ifndef PS_DOT
#define PS_DOT PS_DASH
#endif
#ifndef PS_DASHDOT
#define PS_DASHDOT PS_DASH
#endif
#ifndef PS_DASHDOTDOT
#define PS_DASHDOTDOT PS_DASH
#endif

// Missing APIs
#define GetMessageTime()	0
#define IsIconic(hwnd)		0
#define SetWindowOrgEx(hdc, xOrg, yOrg, pt)
#define SetViewportExtEx(hdc, nX, nY, lpSize)
#define SetWindowExtEx(hdc, x, y, lpSize)

// Unsupported messages.
// FUTURE : Perhaps we should ifdef the code the messages control
#ifndef WS_EX_TRANSPARENT
#define WS_EX_TRANSPARENT       0x00000020L
#endif

#ifndef WM_MOUSEACTIVATE
#define WM_MOUSEACTIVATE			0x0021
#endif

#ifndef WM_SYSCOLORCHANGE
#define WM_SYSCOLORCHANGE               0x0015
#endif

#ifndef WM_STYLECHANGING
#define WM_STYLECHANGING                0x007C
#endif

#ifndef WM_WINDOWPOSCHANGING
#define WM_WINDOWPOSCHANGING            0x0046
#endif

#ifndef WM_SETCURSOR
#define WM_SETCURSOR                    0x0020
#endif

#ifndef WM_NCPAINT
#define WM_NCPAINT                      0x0085
#endif

#ifndef SM_SWAPBUTTON
#define SM_SWAPBUTTON           23
#endif

#ifndef TPM_RIGHTBUTTON
#define TPM_RIGHTBUTTON 0x0002L
#endif

#define RegisterClipboardFormatA(s)  RegisterClipboardFormatW(TEXT(s))

/*
 * EDITWORDBREAKPROC
 */
typedef int (CALLBACK* EDITWORDBREAKPROC)(LPWSTR lpch, int ichCurrent, int cch, int code);
#ifndef WB_LEFT
#define WB_LEFT            0
#define WB_RIGHT           1
#define WB_ISDELIMITER     2
#endif

#ifndef OUT_TT_ONLY_PRECIS
#define OUT_TT_ONLY_PRECIS         7
#endif

// Mapping Modes : Win CE only supports MM_TEXT
#ifndef MM_TEXT
#define MM_TEXT             1
#define SetMapMode(hdc, mapmode)
WINGDIAPI inline int WINAPI GetMapMode(HDC)
{
	return MM_TEXT;
}
#endif

#ifndef HANGUL_CHARSET
#define HANGUL_CHARSET HANGEUL_CHARSET
#endif

#endif	// UNDER_CE

#endif	// _W32SYS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\_uspi.h ===
/*
 *		Uniscribe interface (& related classes) class definition
 *		
 *		File:    _uspi.h
 * 		Create:  Jan 10, 1998
 *		Author:  Worachai Chaoweeraprasit (wchao)
 *
 *		Copyright (c) 1998, Microsoft Corporation. All rights reserved.
 */
 
#ifndef NOCOMPLEXSCRIPTS

#ifndef _USPI_H
#define _USPI_H

#include "_ls.h"
#include "usp10.h"		// Uniscribe SDK protocol


// classes
//
class CFormatRunPtr;
class CMeasurer;
class CTxtEdit;
class CUniscribe;
class CBiDiFSM;
class CTxtBreaker;


#define ALIGN(x)            		(int)(((x)+3) & ~3)		// dword aligning
#define GLYPH_COUNT(c)          	((((c)*3)/2)+16)
#define MAX_CLIENT_BUF				512						// size (in byte) of internal buffer

// USP client parameters block
//
#define cli_string                  0x00000001
#define cli_psi                     0x00000002
#define cli_psla                    0x00000004
#define cli_pwgi					0x00000008
#define cli_psva					0x00000010
#define cli_pcluster				0x00000020
#define cli_pidx					0x00000040
#define cli_pgoffset				0x00000080

#define cli_Itemize                 (cli_string | cli_psi)
#define cli_Break                   (cli_psla)
#define cli_Shape					(cli_pwgi | cli_psva | cli_pcluster)
#define cli_Place					(cli_pidx | cli_pgoffset)
#define cli_ShapePlace				(cli_Shape | cli_Place)



#ifndef LOCALE_SNATIVEDIGITS
#define LOCALE_SNATIVEDIGITS		0x00000013
#endif



/////   LANG
//
//      The following defines are temporary - they will be removed once they
//      have been added to the standard NLS header files.


#ifndef LANG_KHMER
#define LANG_KHMER       			0x53       // Cambodia
#endif
#ifndef LANG_LAO
#define LANG_LAO         			0x54       // Lao
#endif
#ifndef LANG_MONGOLIAN
#define LANG_MONGOLIAN   			0x50       // Mongolia
#endif
#ifndef LANG_TIBETAN
#define LANG_TIBETAN     			0x51       // Tibet
#endif
#ifndef LANG_URDU
#define LANG_URDU        			0x20       // India / Pakistan
#endif



//
// Memory block will contain USPCLIENT -the table of ptrs, as a memory block's header
// followed by subtables then requested data blocks. All things tie together as a
// contiguous data area so client can free the whole thing in one shot.
//


// SI subtable
//
typedef struct tagUSP_CLIENT_SI
{
	//
	// ScriptItemize's
	//
	WCHAR*          pwchString;
	int             cchString;
	SCRIPT_ITEM*    psi;
} USP_CLIENT_SI, *PUSP_CLIENT_SI;

// SB subtable
//
typedef struct tagUSP_CLIENT_SB
{
	//
	// ScriptBreak's
	//
	SCRIPT_LOGATTR* psla;
} USP_CLIENT_SB, *PUSP_CLIENT_SB;

// SS & SP subtable
typedef struct tagUSP_CLIENT_SSP
{
	//
	// ScriptShape's
	//
	WORD*			pwgi;
	WORD*			pcluster;
	SCRIPT_VISATTR*	psva;

	//
	// ScriptPlace's
	//
	int*			pidx;
	GOFFSET*		pgoffset;
} USP_CLIENT_SSP, *PUSP_CLIENT_SSP;


// header (root) table
//
typedef struct tagUSP_CLIENT
{
	PUSP_CLIENT_SI  si;
	PUSP_CLIENT_SB  sb;
	PUSP_CLIENT_SSP	ssp;
} USP_CLIENT, *PUSP_CLIENT;



// buffer request structure
//
typedef struct tagBUF_REQ
{
	int             size;	// size of requested element
	int             c;		// count of requested element
	PVOID*          ppv;	// ref to ptr of requested buffer
} BUF_REQ;


typedef enum
{
	DIGITS_NOTIMPL = 0,
	DIGITS_CTX,
	DIGITS_NONE,
	DIGITS_NATIONAL
} DIGITSHAPE;


#define		IsCS(x)				(BOOL)((x)==U_COMMA || (x)==U_PERIOD || (x)==U_COLON)


// CUniscribe's internal buffer request flag
//
#define 	igb_Glyph			1
#define 	igb_VisAttr			2
#define 	igb_Pidx			4



// LS Callback's static return buffer
#define 	celAdvance			32

class CBufferBase
{
public:
	CBufferBase(int cbElem) { _cbElem = cbElem; }
	void*	GetPtr(int cel);
	void	Release();
protected:
	void*	_p;
	int		_cElem;
	int		_cbElem;
};

template <class ELEM>
class CBuffer : public CBufferBase
{
public:
	CBuffer() : CBufferBase(sizeof(ELEM)) {}
	~CBuffer() { Release(); }
	ELEM*	Get(int cel) { return (ELEM*)GetPtr(cel); }
};


///////	Uniscribe interface object class
// 		
//
BOOL	IsSupportedOS();

class CUniscribe
{
public:
	CUniscribe();
	~CUniscribe();

	WORD	ApplyDigitSubstitution (BYTE bDigitSubstMode);

	// public helper functions
	//
	const   SCRIPT_PROPERTIES*  GeteProp (WORD eScript);
	const   CBiDiFSM*           GetFSM ();

	BOOL    CreateClientStruc (BYTE* pbBufIn, LONG cbBufIn, PUSP_CLIENT* ppc, LONG cchString, DWORD dwMask);
	void	SubstituteDigitShaper (PLSRUN plsrun, CMeasurer* pme);

	inline BOOL CacheAllocGlyphBuffers(int cch, int& cGlyphs, WORD*& pwgi, SCRIPT_VISATTR*& psva)
	{
		cGlyphs = GLYPH_COUNT(cch);
		return (pwgi = GetGlyphBuffer(cGlyphs)) && (psva = GetVABuffer(cGlyphs));
	}

	inline BOOL IsValid()	{return TRUE;}

	BOOL	GetComplexCharRep(const SCRIPT_PROPERTIES* psp, BYTE iCharRepDefault, BYTE& iCharRepOut);
	BYTE	GetRtlCharRep(CTxtEdit* ped, CRchTxtPtr* prtp);

	// higher level services
	//
	int     ItemizeString (USP_CLIENT* pc, WORD uInitLevel, int* pcItems, WCHAR* pwchString, int cch,
						   BOOL fUnicodeBidi, WORD wLangId = LANG_NEUTRAL);
	int     ShapeString (PLSRUN plsrun, SCRIPT_ANALYSIS* psa, CMeasurer* pme, const WCHAR* pwch, int cch,
						 WORD*& pwgi, WORD* pwlc, SCRIPT_VISATTR*& psva);
	int     PlaceString (PLSRUN plsrun, SCRIPT_ANALYSIS* psa, CMeasurer* pme, const WORD* pcwgi, int cgi,
						 const SCRIPT_VISATTR* psva, int* pgdx, GOFFSET* pgduv, ABC* pABC);
	int		PlaceMetafileString (PLSRUN plsrun, CMeasurer* pme, const WCHAR* pwch, int cch, PINT* ppiDx);

private:
	// private helper functions
	//
	HDC     PrepareShapeDC (PLSRUN plsrun, CMeasurer* pme, HRESULT hrReq, HFONT& hOrgFont);
	BYTE	GetCDMCharRep(BYTE iCharRepDefault);
	DWORD	GetNationalDigitLanguage(LCID lcid);

	// get callback static buffers
	//
	SCRIPT_VISATTR*	GetVABuffer(int cel) { return _rgva.Get(cel); }
	WORD*			GetGlyphBuffer(int cel) { return _rgglyph.Get(cel); }
	int*			GetWidthBuffer(int cel) { return _rgwidth.Get(cel); }
	GOFFSET*		GetGoffsetBuffer(int cel) { return _rgGoffset.Get(cel); }

	// LS callback (static) buffers
	//
	CBuffer<WORD>				_rgglyph;
	CBuffer<int>				_rgwidth;
	CBuffer<GOFFSET>			_rgGoffset;
	CBuffer<SCRIPT_VISATTR>		_rgva;

	// pointer to BidiLevel Finite State Machine
	CBiDiFSM*                   _pFSM;

	// pointer to script properties resource table
	const SCRIPT_PROPERTIES**   _ppProp;

	WORD						_wesNationalDigit;	// National digit script ID
	BYTE						_iCharRepRtl;		// Right to left char rep to use
	BYTE						_iCharRepCDM;		// CDM char repertoire to use
};

extern CUniscribe*      g_pusp;
extern int				g_cMaxScript;		// Maximum number of script produced by Uniscribe

// Virtual script ID
#define	SCRIPT_MAX_COUNT	((WORD)g_cMaxScript)
#define	SCRIPT_WHITE		SCRIPT_MAX_COUNT + 1



///////	Bidi Finite State Machine class
// 		
//		(detail: bidifsm2.html)
//
//		Revise: 12-28-98 (wchao)
//

// inputs class:
#define 	NUM_FSM_INPUTS		5
typedef enum
{
	chLTR = 0,
	chRTL,
	digitLTR,
	digitRTL,
	chGround					// Neutralize current level down to initial level
} INPUT_CLASS;

// states:
#define		NUM_FSM_STATES		6
typedef enum
{
	S_A = 0,
	S_B,
	S_C,
	S_X,
	S_Y,
	S_Z
} STATES;


class CBiDiFSMCell
{
public:
	CBiDiLevel	_level;			// BiDi level
	USHORT  	_uNext;			// Offset to the next state relative to FSM start
};


class CBiDiFSM
{
public:
	CBiDiFSM (CUniscribe* pusp) { _pusp = pusp; }
	~CBiDiFSM ();

	BOOL                Init (void);
	INPUT_CLASS         InputClass (const CCharFormat* pcCF, CTxtPtr* ptp, LONG cchRun) const;
	HRESULT             RunFSM (CRchTxtPtr* prtp, LONG cRuns, LONG cRunsStart, BYTE bBaseLevel) const;

	inline void			SetFSMCell (CBiDiFSMCell* pCell, CBiDiLevel* pLevel, USHORT uNext)
	{
		pCell->_level	= *pLevel;
		pCell->_uNext	= uNext;
	}


private:
	short               _nState;		// number of state
	short               _nInput;		// number of input class
	CUniscribe*         _pusp;			// Uniscribe obj associated with
	CBiDiFSMCell*       _pStart;		// start FSM
};

#endif		// _USPI_H

#endif		// NOCOMPLEXSCRIPTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\tom41\tom.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Jul 12 16:06:11 2001
 */
/* Compiler settings for tom.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tomtmp_h__
#define __tomtmp_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITextDocument_FWD_DEFINED__
#define __ITextDocument_FWD_DEFINED__
typedef interface ITextDocument ITextDocument;
#endif 	/* __ITextDocument_FWD_DEFINED__ */


#ifndef __ITextRange_FWD_DEFINED__
#define __ITextRange_FWD_DEFINED__
typedef interface ITextRange ITextRange;
#endif 	/* __ITextRange_FWD_DEFINED__ */


#ifndef __ITextSelection_FWD_DEFINED__
#define __ITextSelection_FWD_DEFINED__
typedef interface ITextSelection ITextSelection;
#endif 	/* __ITextSelection_FWD_DEFINED__ */


#ifndef __ITextFont_FWD_DEFINED__
#define __ITextFont_FWD_DEFINED__
typedef interface ITextFont ITextFont;
#endif 	/* __ITextFont_FWD_DEFINED__ */


#ifndef __ITextPara_FWD_DEFINED__
#define __ITextPara_FWD_DEFINED__
typedef interface ITextPara ITextPara;
#endif 	/* __ITextPara_FWD_DEFINED__ */


#ifndef __ITextStoryRanges_FWD_DEFINED__
#define __ITextStoryRanges_FWD_DEFINED__
typedef interface ITextStoryRanges ITextStoryRanges;
#endif 	/* __ITextStoryRanges_FWD_DEFINED__ */


#ifndef __ITextDocument2_FWD_DEFINED__
#define __ITextDocument2_FWD_DEFINED__
typedef interface ITextDocument2 ITextDocument2;
#endif 	/* __ITextDocument2_FWD_DEFINED__ */


#ifndef __ITextMsgFilter_FWD_DEFINED__
#define __ITextMsgFilter_FWD_DEFINED__
typedef interface ITextMsgFilter ITextMsgFilter;
#endif 	/* __ITextMsgFilter_FWD_DEFINED__ */


#ifndef __ITextDocument_FWD_DEFINED__
#define __ITextDocument_FWD_DEFINED__
typedef interface ITextDocument ITextDocument;
#endif 	/* __ITextDocument_FWD_DEFINED__ */


#ifndef __ITextRange_FWD_DEFINED__
#define __ITextRange_FWD_DEFINED__
typedef interface ITextRange ITextRange;
#endif 	/* __ITextRange_FWD_DEFINED__ */


#ifndef __ITextSelection_FWD_DEFINED__
#define __ITextSelection_FWD_DEFINED__
typedef interface ITextSelection ITextSelection;
#endif 	/* __ITextSelection_FWD_DEFINED__ */


#ifndef __ITextFont_FWD_DEFINED__
#define __ITextFont_FWD_DEFINED__
typedef interface ITextFont ITextFont;
#endif 	/* __ITextFont_FWD_DEFINED__ */


#ifndef __ITextPara_FWD_DEFINED__
#define __ITextPara_FWD_DEFINED__
typedef interface ITextPara ITextPara;
#endif 	/* __ITextPara_FWD_DEFINED__ */


#ifndef __ITextStoryRanges_FWD_DEFINED__
#define __ITextStoryRanges_FWD_DEFINED__
typedef interface ITextStoryRanges ITextStoryRanges;
#endif 	/* __ITextStoryRanges_FWD_DEFINED__ */


#ifndef __ITextDocument2_FWD_DEFINED__
#define __ITextDocument2_FWD_DEFINED__
typedef interface ITextDocument2 ITextDocument2;
#endif 	/* __ITextDocument2_FWD_DEFINED__ */


#ifndef __ITextMsgFilter_FWD_DEFINED__
#define __ITextMsgFilter_FWD_DEFINED__
typedef interface ITextMsgFilter ITextMsgFilter;
#endif 	/* __ITextMsgFilter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_tom_0000 */
/* [local] */ 










extern RPC_IF_HANDLE __MIDL_itf_tom_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tom_0000_v0_0_s_ifspec;


#ifndef __tom_LIBRARY_DEFINED__
#define __tom_LIBRARY_DEFINED__

/* library tom */
/* [version][uuid] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_tom_0000_0001
    {	tomFalse	= 0,
	tomTrue	= -1,
	tomUndefined	= -9999999,
	tomToggle	= -9999998,
	tomAutoColor	= -9999997,
	tomDefault	= -9999996,
	tomSuspend	= -9999995,
	tomResume	= -9999994,
	tomApplyNow	= 0,
	tomApplyLater	= 1,
	tomTrackParms	= 2,
	tomCacheParms	= 3,
	tomApplyTmp	= 4,
	tomBackward	= 0xc0000001,
	tomForward	= 0x3fffffff,
	tomMove	= 0,
	tomExtend	= 1,
	tomNoSelection	= 0,
	tomSelectionIP	= 1,
	tomSelectionNormal	= 2,
	tomSelectionFrame	= 3,
	tomSelectionColumn	= 4,
	tomSelectionRow	= 5,
	tomSelectionBlock	= 6,
	tomSelectionInlineShape	= 7,
	tomSelectionShape	= 8,
	tomSelStartActive	= 1,
	tomSelAtEOL	= 2,
	tomSelOvertype	= 4,
	tomSelActive	= 8,
	tomSelReplace	= 16,
	tomEnd	= 0,
	tomStart	= 32,
	tomCollapseEnd	= 0,
	tomCollapseStart	= 1,
	tomClientCoord	= 256,
	tomAllowOffClient	= 512,
	tomNone	= 0,
	tomSingle	= 1,
	tomWords	= 2,
	tomDouble	= 3,
	tomDotted	= 4,
	tomDash	= 5,
	tomDashDot	= 6,
	tomDashDotDot	= 7,
	tomWave	= 8,
	tomThick	= 9,
	tomHair	= 10,
	tomDoubleWave	= 11,
	tomHeavyWave	= 12,
	tomLongDash	= 13,
	tomThickDash	= 14,
	tomThickDashDot	= 15,
	tomThickDashDotDot	= 16,
	tomThickDotted	= 17,
	tomThickLongDash	= 18,
	tomLineSpaceSingle	= 0,
	tomLineSpace1pt5	= 1,
	tomLineSpaceDouble	= 2,
	tomLineSpaceAtLeast	= 3,
	tomLineSpaceExactly	= 4,
	tomLineSpaceMultiple	= 5,
	tomAlignLeft	= 0,
	tomAlignCenter	= 1,
	tomAlignRight	= 2,
	tomAlignJustify	= 3,
	tomAlignDecimal	= 3,
	tomAlignBar	= 4,
	tomAlignInterWord	= 3,
	tomAlignInterLetter	= 4,
	tomAlignScaled	= 5,
	tomAlignGlyphs	= 6,
	tomAlignSnapGrid	= 7,
	tomSpaces	= 0,
	tomDots	= 1,
	tomDashes	= 2,
	tomLines	= 3,
	tomThickLines	= 4,
	tomEquals	= 5,
	tomTabBack	= -3,
	tomTabNext	= -2,
	tomTabHere	= -1,
	tomListNone	= 0,
	tomListBullet	= 1,
	tomListNumberAsArabic	= 2,
	tomListNumberAsLCLetter	= 3,
	tomListNumberAsUCLetter	= 4,
	tomListNumberAsLCRoman	= 5,
	tomListNumberAsUCRoman	= 6,
	tomListNumberAsSequence	= 7,
	tomListParentheses	= 0x10000,
	tomListPeriod	= 0x20000,
	tomListPlain	= 0x30000,
	tomCharacter	= 1,
	tomWord	= 2,
	tomSentence	= 3,
	tomParagraph	= 4,
	tomLine	= 5,
	tomStory	= 6,
	tomScreen	= 7,
	tomSection	= 8,
	tomColumn	= 9,
	tomRow	= 10,
	tomWindow	= 11,
	tomCell	= 12,
	tomCharFormat	= 13,
	tomParaFormat	= 14,
	tomTable	= 15,
	tomObject	= 16,
	tomPage	= 17,
	tomMatchWord	= 2,
	tomMatchCase	= 4,
	tomMatchPattern	= 8,
	tomUnknownStory	= 0,
	tomMainTextStory	= 1,
	tomFootnotesStory	= 2,
	tomEndnotesStory	= 3,
	tomCommentsStory	= 4,
	tomTextFrameStory	= 5,
	tomEvenPagesHeaderStory	= 6,
	tomPrimaryHeaderStory	= 7,
	tomEvenPagesFooterStory	= 8,
	tomPrimaryFooterStory	= 9,
	tomFirstPageHeaderStory	= 10,
	tomFirstPageFooterStory	= 11,
	tomNoAnimation	= 0,
	tomLasVegasLights	= 1,
	tomBlinkingBackground	= 2,
	tomSparkleText	= 3,
	tomMarchingBlackAnts	= 4,
	tomMarchingRedAnts	= 5,
	tomShimmer	= 6,
	tomWipeDown	= 7,
	tomWipeRight	= 8,
	tomAnimationMax	= 8,
	tomLowerCase	= 0,
	tomUpperCase	= 1,
	tomTitleCase	= 2,
	tomSentenceCase	= 4,
	tomToggleCase	= 5,
	tomReadOnly	= 0x100,
	tomShareDenyRead	= 0x200,
	tomShareDenyWrite	= 0x400,
	tomPasteFile	= 0x1000,
	tomCreateNew	= 0x10,
	tomCreateAlways	= 0x20,
	tomOpenExisting	= 0x30,
	tomOpenAlways	= 0x40,
	tomTruncateExisting	= 0x50,
	tomRTF	= 0x1,
	tomText	= 0x2,
	tomHTML	= 0x3,
	tomWordDocument	= 0x4,
	tomBold	= 0x80000001,
	tomItalic	= 0x80000002,
	tomUnderline	= 0x80000004,
	tomStrikeout	= 0x80000008,
	tomProtected	= 0x80000010,
	tomLink	= 0x80000020,
	tomSmallCaps	= 0x80000040,
	tomAllCaps	= 0x80000080,
	tomHidden	= 0x80000100,
	tomOutline	= 0x80000200,
	tomShadow	= 0x80000400,
	tomEmboss	= 0x80000800,
	tomImprint	= 0x80001000,
	tomDisabled	= 0x80002000,
	tomRevised	= 0x80004000,
	tomNormalCaret	= 0,
	tomKoreanBlockCaret	= 0x1,
	tomIncludeInset	= 0x1,
	tomIgnoreCurrentFont	= 0,
	tomMatchFontCharset	= 0x1,
	tomMatchFontSignature	= 0x2,
	tomCharset	= 0x80000000,
	tomRE10Mode	= 0x1,
	tomUseAtFont	= 0x2,
	tomTextFlowMask	= 0xc,
	tomTextFlowES	= 0,
	tomTextFlowSW	= 0x4,
	tomTextFlowWN	= 0x8,
	tomTextFlowNE	= 0xc,
	tomUsePassword	= 0x10,
	tomNoIME	= 0x80000,
	tomSelfIME	= 0x40000
    }	tomConstants;










EXTERN_C const IID LIBID_tom;

#ifndef __ITextDocument_INTERFACE_DEFINED__
#define __ITextDocument_INTERFACE_DEFINED__

/* interface ITextDocument */
/* [object][nonextensible][dual][version][uuid] */ 


EXTERN_C const IID IID_ITextDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CC497C0-A1DF-11ce-8098-00AA0047BE5D")
    ITextDocument : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryCount( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryRanges( 
            /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSaved( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSaved( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDefaultTabStop( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetDefaultTabStop( 
            /* [in] */ float Value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE New( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Save( 
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Freeze( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Unfreeze( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BeginEditCollection( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndEditCollection( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Undo( 
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Redo( 
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Range( 
            /* [in] */ long cp1,
            /* [in] */ long cp2,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RangeFromPoint( 
            /* [in] */ long x,
            /* [in] */ long y,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextDocument __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSelection )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryCount )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryRanges )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaved )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSaved )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultTabStop )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultTabStop )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *New )( 
            ITextDocument __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Freeze )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unfreeze )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEditCollection )( 
            ITextDocument __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEditCollection )( 
            ITextDocument __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Undo )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redo )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Range )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ long cp1,
            /* [in] */ long cp2,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RangeFromPoint )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        END_INTERFACE
    } ITextDocumentVtbl;

    interface ITextDocument
    {
        CONST_VTBL struct ITextDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextDocument_GetName(This,pName)	\
    (This)->lpVtbl -> GetName(This,pName)

#define ITextDocument_GetSelection(This,ppSel)	\
    (This)->lpVtbl -> GetSelection(This,ppSel)

#define ITextDocument_GetStoryCount(This,pCount)	\
    (This)->lpVtbl -> GetStoryCount(This,pCount)

#define ITextDocument_GetStoryRanges(This,ppStories)	\
    (This)->lpVtbl -> GetStoryRanges(This,ppStories)

#define ITextDocument_GetSaved(This,pValue)	\
    (This)->lpVtbl -> GetSaved(This,pValue)

#define ITextDocument_SetSaved(This,Value)	\
    (This)->lpVtbl -> SetSaved(This,Value)

#define ITextDocument_GetDefaultTabStop(This,pValue)	\
    (This)->lpVtbl -> GetDefaultTabStop(This,pValue)

#define ITextDocument_SetDefaultTabStop(This,Value)	\
    (This)->lpVtbl -> SetDefaultTabStop(This,Value)

#define ITextDocument_New(This)	\
    (This)->lpVtbl -> New(This)

#define ITextDocument_Open(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Open(This,pVar,Flags,CodePage)

#define ITextDocument_Save(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Save(This,pVar,Flags,CodePage)

#define ITextDocument_Freeze(This,pCount)	\
    (This)->lpVtbl -> Freeze(This,pCount)

#define ITextDocument_Unfreeze(This,pCount)	\
    (This)->lpVtbl -> Unfreeze(This,pCount)

#define ITextDocument_BeginEditCollection(This)	\
    (This)->lpVtbl -> BeginEditCollection(This)

#define ITextDocument_EndEditCollection(This)	\
    (This)->lpVtbl -> EndEditCollection(This)

#define ITextDocument_Undo(This,Count,prop)	\
    (This)->lpVtbl -> Undo(This,Count,prop)

#define ITextDocument_Redo(This,Count,prop)	\
    (This)->lpVtbl -> Redo(This,Count,prop)

#define ITextDocument_Range(This,cp1,cp2,ppRange)	\
    (This)->lpVtbl -> Range(This,cp1,cp2,ppRange)

#define ITextDocument_RangeFromPoint(This,x,y,ppRange)	\
    (This)->lpVtbl -> RangeFromPoint(This,x,y,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetName_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB ITextDocument_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetSelection_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);


void __RPC_STUB ITextDocument_GetSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetStoryCount_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextDocument_GetStoryCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetStoryRanges_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories);


void __RPC_STUB ITextDocument_GetStoryRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetSaved_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextDocument_GetSaved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_SetSaved_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextDocument_SetSaved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetDefaultTabStop_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextDocument_GetDefaultTabStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_SetDefaultTabStop_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextDocument_SetDefaultTabStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_New_Proxy( 
    ITextDocument __RPC_FAR * This);


void __RPC_STUB ITextDocument_New_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Open_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Flags,
    /* [in] */ long CodePage);


void __RPC_STUB ITextDocument_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Save_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Flags,
    /* [in] */ long CodePage);


void __RPC_STUB ITextDocument_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Freeze_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextDocument_Freeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Unfreeze_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextDocument_Unfreeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_BeginEditCollection_Proxy( 
    ITextDocument __RPC_FAR * This);


void __RPC_STUB ITextDocument_BeginEditCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_EndEditCollection_Proxy( 
    ITextDocument __RPC_FAR * This);


void __RPC_STUB ITextDocument_EndEditCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Undo_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *prop);


void __RPC_STUB ITextDocument_Undo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Redo_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *prop);


void __RPC_STUB ITextDocument_Redo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Range_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ long cp1,
    /* [in] */ long cp2,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextDocument_Range_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_RangeFromPoint_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ long x,
    /* [in] */ long y,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextDocument_RangeFromPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextDocument_INTERFACE_DEFINED__ */


#ifndef __ITextRange_INTERFACE_DEFINED__
#define __ITextRange_INTERFACE_DEFINED__

/* interface ITextRange */
/* [object][nonextensible][dual][version][uuid] */ 


EXTERN_C const IID IID_ITextRange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CC497C2-A1DF-11ce-8098-00AA0047BE5D")
    ITextRange : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetText( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetText( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetChar( 
            /* [retval][out] */ long __RPC_FAR *pch) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetChar( 
            /* [in] */ long ch) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDuplicate( 
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFormattedText( 
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetFormattedText( 
            /* [in] */ ITextRange __RPC_FAR *pRange) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStart( 
            /* [retval][out] */ long __RPC_FAR *pcpFirst) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStart( 
            /* [in] */ long cpFirst) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetEnd( 
            /* [retval][out] */ long __RPC_FAR *pcpLim) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetEnd( 
            /* [in] */ long cpLim) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFont( 
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetFont( 
            /* [in] */ ITextFont __RPC_FAR *pFont) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetPara( 
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetPara( 
            /* [in] */ ITextPara __RPC_FAR *pPara) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryLength( 
            /* [retval][out] */ long __RPC_FAR *pcch) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryType( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Collapse( 
            /* [in] */ long bStart) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Expand( 
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetIndex( 
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pIndex) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetIndex( 
            /* [in] */ long Unit,
            /* [in] */ long Index,
            /* [in] */ long Extend) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetRange( 
            /* [in] */ long cpActive,
            /* [in] */ long cpOther) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE InRange( 
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE InStory( 
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Select( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StartOf( 
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndOf( 
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveStart( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveEnd( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveWhile( 
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveStartWhile( 
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveEndWhile( 
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveUntil( 
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveStartUntil( 
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveEndUntil( 
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindText( 
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindTextStart( 
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindTextEnd( 
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Cut( 
            /* [out] */ VARIANT __RPC_FAR *pVar) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Copy( 
            /* [out] */ VARIANT __RPC_FAR *pVar) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Paste( 
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanPaste( 
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanEdit( 
            /* [retval][out] */ long __RPC_FAR *pbCanEdit) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ChangeCase( 
            /* [in] */ long Type) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetPoint( 
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetPoint( 
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long Type,
            /* [in] */ long Extend) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ScrollIntoView( 
            /* [in] */ long Value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetEmbeddedObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextRangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextRange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextRange __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextRange __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetText )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChar )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pch);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetChar )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long ch);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormattedText )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFormattedText )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStart )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpFirst);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStart )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long cpFirst);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnd )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpLim);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnd )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long cpLim);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFont )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFont )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPara )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPara )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryLength )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcch);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryType )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Collapse )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long bStart);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expand )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndex )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pIndex);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIndex )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Index,
            /* [in] */ long Extend);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRange )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long cpActive,
            /* [in] */ long cpOther);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InRange )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InStory )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Select )( 
            ITextRange __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartOf )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndOf )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStart )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEnd )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveWhile )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartWhile )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndWhile )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveUntil )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartUntil )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndUntil )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindText )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextStart )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextEnd )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cut )( 
            ITextRange __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Copy )( 
            ITextRange __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Paste )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanPaste )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanEdit )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pbCanEdit);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangeCase )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Type);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPoint )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPoint )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long Type,
            /* [in] */ long Extend);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScrollIntoView )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEmbeddedObject )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv);
        
        END_INTERFACE
    } ITextRangeVtbl;

    interface ITextRange
    {
        CONST_VTBL struct ITextRangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextRange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextRange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextRange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextRange_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextRange_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextRange_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextRange_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextRange_GetText(This,pbstr)	\
    (This)->lpVtbl -> GetText(This,pbstr)

#define ITextRange_SetText(This,bstr)	\
    (This)->lpVtbl -> SetText(This,bstr)

#define ITextRange_GetChar(This,pch)	\
    (This)->lpVtbl -> GetChar(This,pch)

#define ITextRange_SetChar(This,ch)	\
    (This)->lpVtbl -> SetChar(This,ch)

#define ITextRange_GetDuplicate(This,ppRange)	\
    (This)->lpVtbl -> GetDuplicate(This,ppRange)

#define ITextRange_GetFormattedText(This,ppRange)	\
    (This)->lpVtbl -> GetFormattedText(This,ppRange)

#define ITextRange_SetFormattedText(This,pRange)	\
    (This)->lpVtbl -> SetFormattedText(This,pRange)

#define ITextRange_GetStart(This,pcpFirst)	\
    (This)->lpVtbl -> GetStart(This,pcpFirst)

#define ITextRange_SetStart(This,cpFirst)	\
    (This)->lpVtbl -> SetStart(This,cpFirst)

#define ITextRange_GetEnd(This,pcpLim)	\
    (This)->lpVtbl -> GetEnd(This,pcpLim)

#define ITextRange_SetEnd(This,cpLim)	\
    (This)->lpVtbl -> SetEnd(This,cpLim)

#define ITextRange_GetFont(This,pFont)	\
    (This)->lpVtbl -> GetFont(This,pFont)

#define ITextRange_SetFont(This,pFont)	\
    (This)->lpVtbl -> SetFont(This,pFont)

#define ITextRange_GetPara(This,pPara)	\
    (This)->lpVtbl -> GetPara(This,pPara)

#define ITextRange_SetPara(This,pPara)	\
    (This)->lpVtbl -> SetPara(This,pPara)

#define ITextRange_GetStoryLength(This,pcch)	\
    (This)->lpVtbl -> GetStoryLength(This,pcch)

#define ITextRange_GetStoryType(This,pValue)	\
    (This)->lpVtbl -> GetStoryType(This,pValue)

#define ITextRange_Collapse(This,bStart)	\
    (This)->lpVtbl -> Collapse(This,bStart)

#define ITextRange_Expand(This,Unit,pDelta)	\
    (This)->lpVtbl -> Expand(This,Unit,pDelta)

#define ITextRange_GetIndex(This,Unit,pIndex)	\
    (This)->lpVtbl -> GetIndex(This,Unit,pIndex)

#define ITextRange_SetIndex(This,Unit,Index,Extend)	\
    (This)->lpVtbl -> SetIndex(This,Unit,Index,Extend)

#define ITextRange_SetRange(This,cpActive,cpOther)	\
    (This)->lpVtbl -> SetRange(This,cpActive,cpOther)

#define ITextRange_InRange(This,pRange,pb)	\
    (This)->lpVtbl -> InRange(This,pRange,pb)

#define ITextRange_InStory(This,pRange,pb)	\
    (This)->lpVtbl -> InStory(This,pRange,pb)

#define ITextRange_IsEqual(This,pRange,pb)	\
    (This)->lpVtbl -> IsEqual(This,pRange,pb)

#define ITextRange_Select(This)	\
    (This)->lpVtbl -> Select(This)

#define ITextRange_StartOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> StartOf(This,Unit,Extend,pDelta)

#define ITextRange_EndOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> EndOf(This,Unit,Extend,pDelta)

#define ITextRange_Move(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Move(This,Unit,Count,pDelta)

#define ITextRange_MoveStart(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveStart(This,Unit,Count,pDelta)

#define ITextRange_MoveEnd(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveEnd(This,Unit,Count,pDelta)

#define ITextRange_MoveWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveWhile(This,Cset,Count,pDelta)

#define ITextRange_MoveStartWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartWhile(This,Cset,Count,pDelta)

#define ITextRange_MoveEndWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndWhile(This,Cset,Count,pDelta)

#define ITextRange_MoveUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveUntil(This,Cset,Count,pDelta)

#define ITextRange_MoveStartUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartUntil(This,Cset,Count,pDelta)

#define ITextRange_MoveEndUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndUntil(This,Cset,Count,pDelta)

#define ITextRange_FindText(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindText(This,bstr,cch,Flags,pLength)

#define ITextRange_FindTextStart(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextStart(This,bstr,cch,Flags,pLength)

#define ITextRange_FindTextEnd(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextEnd(This,bstr,cch,Flags,pLength)

#define ITextRange_Delete(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Delete(This,Unit,Count,pDelta)

#define ITextRange_Cut(This,pVar)	\
    (This)->lpVtbl -> Cut(This,pVar)

#define ITextRange_Copy(This,pVar)	\
    (This)->lpVtbl -> Copy(This,pVar)

#define ITextRange_Paste(This,pVar,Format)	\
    (This)->lpVtbl -> Paste(This,pVar,Format)

#define ITextRange_CanPaste(This,pVar,Format,pb)	\
    (This)->lpVtbl -> CanPaste(This,pVar,Format,pb)

#define ITextRange_CanEdit(This,pbCanEdit)	\
    (This)->lpVtbl -> CanEdit(This,pbCanEdit)

#define ITextRange_ChangeCase(This,Type)	\
    (This)->lpVtbl -> ChangeCase(This,Type)

#define ITextRange_GetPoint(This,Type,px,py)	\
    (This)->lpVtbl -> GetPoint(This,Type,px,py)

#define ITextRange_SetPoint(This,x,y,Type,Extend)	\
    (This)->lpVtbl -> SetPoint(This,x,y,Type,Extend)

#define ITextRange_ScrollIntoView(This,Value)	\
    (This)->lpVtbl -> ScrollIntoView(This,Value)

#define ITextRange_GetEmbeddedObject(This,ppv)	\
    (This)->lpVtbl -> GetEmbeddedObject(This,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetText_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB ITextRange_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetText_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ITextRange_SetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetChar_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pch);


void __RPC_STUB ITextRange_GetChar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetChar_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long ch);


void __RPC_STUB ITextRange_SetChar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetDuplicate_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextRange_GetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetFormattedText_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextRange_GetFormattedText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetFormattedText_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange);


void __RPC_STUB ITextRange_SetFormattedText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetStart_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcpFirst);


void __RPC_STUB ITextRange_GetStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetStart_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long cpFirst);


void __RPC_STUB ITextRange_SetStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetEnd_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcpLim);


void __RPC_STUB ITextRange_GetEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetEnd_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long cpLim);


void __RPC_STUB ITextRange_SetEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetFont_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont);


void __RPC_STUB ITextRange_GetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetFont_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextFont __RPC_FAR *pFont);


void __RPC_STUB ITextRange_SetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetPara_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara);


void __RPC_STUB ITextRange_GetPara_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetPara_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextPara __RPC_FAR *pPara);


void __RPC_STUB ITextRange_SetPara_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetStoryLength_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcch);


void __RPC_STUB ITextRange_GetStoryLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetStoryType_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextRange_GetStoryType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Collapse_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long bStart);


void __RPC_STUB ITextRange_Collapse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Expand_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_Expand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetIndex_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [retval][out] */ long __RPC_FAR *pIndex);


void __RPC_STUB ITextRange_GetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetIndex_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Index,
    /* [in] */ long Extend);


void __RPC_STUB ITextRange_SetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetRange_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long cpActive,
    /* [in] */ long cpOther);


void __RPC_STUB ITextRange_SetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_InRange_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_InRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_InStory_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_InStory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_IsEqual_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Select_Proxy( 
    ITextRange __RPC_FAR * This);


void __RPC_STUB ITextRange_Select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_StartOf_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_StartOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_EndOf_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_EndOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Move_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveStart_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveEnd_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveWhile_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveWhile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveStartWhile_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveStartWhile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveEndWhile_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveEndWhile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveUntil_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveUntil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveStartUntil_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveStartUntil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveEndUntil_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveEndUntil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_FindText_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr,
    /* [in] */ long cch,
    /* [in] */ long Flags,
    /* [retval][out] */ long __RPC_FAR *pLength);


void __RPC_STUB ITextRange_FindText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_FindTextStart_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr,
    /* [in] */ long cch,
    /* [in] */ long Flags,
    /* [retval][out] */ long __RPC_FAR *pLength);


void __RPC_STUB ITextRange_FindTextStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_FindTextEnd_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr,
    /* [in] */ long cch,
    /* [in] */ long Flags,
    /* [retval][out] */ long __RPC_FAR *pLength);


void __RPC_STUB ITextRange_FindTextEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Delete_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Cut_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [out] */ VARIANT __RPC_FAR *pVar);


void __RPC_STUB ITextRange_Cut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Copy_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [out] */ VARIANT __RPC_FAR *pVar);


void __RPC_STUB ITextRange_Copy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Paste_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Format);


void __RPC_STUB ITextRange_Paste_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_CanPaste_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Format,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_CanPaste_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_CanEdit_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pbCanEdit);


void __RPC_STUB ITextRange_CanEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_ChangeCase_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Type);


void __RPC_STUB ITextRange_ChangeCase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetPoint_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Type,
    /* [out] */ long __RPC_FAR *px,
    /* [out] */ long __RPC_FAR *py);


void __RPC_STUB ITextRange_GetPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetPoint_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long x,
    /* [in] */ long y,
    /* [in] */ long Type,
    /* [in] */ long Extend);


void __RPC_STUB ITextRange_SetPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_ScrollIntoView_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextRange_ScrollIntoView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetEmbeddedObject_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB ITextRange_GetEmbeddedObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextRange_INTERFACE_DEFINED__ */


#ifndef __ITextSelection_INTERFACE_DEFINED__
#define __ITextSelection_INTERFACE_DEFINED__

/* interface ITextSelection */
/* [object][nonextensible][dual][version][uuid] */ 


EXTERN_C const IID IID_ITextSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CC497C1-A1DF-11ce-8098-00AA0047BE5D")
    ITextSelection : public ITextRange
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [retval][out] */ long __RPC_FAR *pFlags) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ LONG Flags) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetType( 
            /* [retval][out] */ long __RPC_FAR *pType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveLeft( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveRight( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveUp( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveDown( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE HomeKey( 
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndKey( 
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE TypeText( 
            /* [in] */ BSTR bstr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextSelectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextSelection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextSelection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextSelection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetText )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChar )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pch);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetChar )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long ch);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormattedText )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFormattedText )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStart )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpFirst);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStart )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long cpFirst);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnd )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpLim);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnd )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long cpLim);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFont )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFont )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPara )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPara )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryLength )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcch);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryType )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Collapse )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long bStart);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expand )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndex )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pIndex);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIndex )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Index,
            /* [in] */ long Extend);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRange )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long cpActive,
            /* [in] */ long cpOther);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InRange )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InStory )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Select )( 
            ITextSelection __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartOf )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndOf )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStart )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEnd )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveWhile )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartWhile )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndWhile )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveUntil )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartUntil )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndUntil )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindText )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextStart )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextEnd )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cut )( 
            ITextSelection __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Copy )( 
            ITextSelection __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Paste )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanPaste )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanEdit )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pbCanEdit);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangeCase )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Type);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPoint )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPoint )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long Type,
            /* [in] */ long Extend);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScrollIntoView )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEmbeddedObject )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pFlags);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFlags )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ LONG Flags);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveLeft )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveRight )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveUp )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveDown )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HomeKey )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndKey )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TypeText )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        END_INTERFACE
    } ITextSelectionVtbl;

    interface ITextSelection
    {
        CONST_VTBL struct ITextSelectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextSelection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextSelection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextSelection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextSelection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextSelection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextSelection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextSelection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextSelection_GetText(This,pbstr)	\
    (This)->lpVtbl -> GetText(This,pbstr)

#define ITextSelection_SetText(This,bstr)	\
    (This)->lpVtbl -> SetText(This,bstr)

#define ITextSelection_GetChar(This,pch)	\
    (This)->lpVtbl -> GetChar(This,pch)

#define ITextSelection_SetChar(This,ch)	\
    (This)->lpVtbl -> SetChar(This,ch)

#define ITextSelection_GetDuplicate(This,ppRange)	\
    (This)->lpVtbl -> GetDuplicate(This,ppRange)

#define ITextSelection_GetFormattedText(This,ppRange)	\
    (This)->lpVtbl -> GetFormattedText(This,ppRange)

#define ITextSelection_SetFormattedText(This,pRange)	\
    (This)->lpVtbl -> SetFormattedText(This,pRange)

#define ITextSelection_GetStart(This,pcpFirst)	\
    (This)->lpVtbl -> GetStart(This,pcpFirst)

#define ITextSelection_SetStart(This,cpFirst)	\
    (This)->lpVtbl -> SetStart(This,cpFirst)

#define ITextSelection_GetEnd(This,pcpLim)	\
    (This)->lpVtbl -> GetEnd(This,pcpLim)

#define ITextSelection_SetEnd(This,cpLim)	\
    (This)->lpVtbl -> SetEnd(This,cpLim)

#define ITextSelection_GetFont(This,pFont)	\
    (This)->lpVtbl -> GetFont(This,pFont)

#define ITextSelection_SetFont(This,pFont)	\
    (This)->lpVtbl -> SetFont(This,pFont)

#define ITextSelection_GetPara(This,pPara)	\
    (This)->lpVtbl -> GetPara(This,pPara)

#define ITextSelection_SetPara(This,pPara)	\
    (This)->lpVtbl -> SetPara(This,pPara)

#define ITextSelection_GetStoryLength(This,pcch)	\
    (This)->lpVtbl -> GetStoryLength(This,pcch)

#define ITextSelection_GetStoryType(This,pValue)	\
    (This)->lpVtbl -> GetStoryType(This,pValue)

#define ITextSelection_Collapse(This,bStart)	\
    (This)->lpVtbl -> Collapse(This,bStart)

#define ITextSelection_Expand(This,Unit,pDelta)	\
    (This)->lpVtbl -> Expand(This,Unit,pDelta)

#define ITextSelection_GetIndex(This,Unit,pIndex)	\
    (This)->lpVtbl -> GetIndex(This,Unit,pIndex)

#define ITextSelection_SetIndex(This,Unit,Index,Extend)	\
    (This)->lpVtbl -> SetIndex(This,Unit,Index,Extend)

#define ITextSelection_SetRange(This,cpActive,cpOther)	\
    (This)->lpVtbl -> SetRange(This,cpActive,cpOther)

#define ITextSelection_InRange(This,pRange,pb)	\
    (This)->lpVtbl -> InRange(This,pRange,pb)

#define ITextSelection_InStory(This,pRange,pb)	\
    (This)->lpVtbl -> InStory(This,pRange,pb)

#define ITextSelection_IsEqual(This,pRange,pb)	\
    (This)->lpVtbl -> IsEqual(This,pRange,pb)

#define ITextSelection_Select(This)	\
    (This)->lpVtbl -> Select(This)

#define ITextSelection_StartOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> StartOf(This,Unit,Extend,pDelta)

#define ITextSelection_EndOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> EndOf(This,Unit,Extend,pDelta)

#define ITextSelection_Move(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Move(This,Unit,Count,pDelta)

#define ITextSelection_MoveStart(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveStart(This,Unit,Count,pDelta)

#define ITextSelection_MoveEnd(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveEnd(This,Unit,Count,pDelta)

#define ITextSelection_MoveWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveWhile(This,Cset,Count,pDelta)

#define ITextSelection_MoveStartWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartWhile(This,Cset,Count,pDelta)

#define ITextSelection_MoveEndWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndWhile(This,Cset,Count,pDelta)

#define ITextSelection_MoveUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveUntil(This,Cset,Count,pDelta)

#define ITextSelection_MoveStartUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartUntil(This,Cset,Count,pDelta)

#define ITextSelection_MoveEndUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndUntil(This,Cset,Count,pDelta)

#define ITextSelection_FindText(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindText(This,bstr,cch,Flags,pLength)

#define ITextSelection_FindTextStart(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextStart(This,bstr,cch,Flags,pLength)

#define ITextSelection_FindTextEnd(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextEnd(This,bstr,cch,Flags,pLength)

#define ITextSelection_Delete(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Delete(This,Unit,Count,pDelta)

#define ITextSelection_Cut(This,pVar)	\
    (This)->lpVtbl -> Cut(This,pVar)

#define ITextSelection_Copy(This,pVar)	\
    (This)->lpVtbl -> Copy(This,pVar)

#define ITextSelection_Paste(This,pVar,Format)	\
    (This)->lpVtbl -> Paste(This,pVar,Format)

#define ITextSelection_CanPaste(This,pVar,Format,pb)	\
    (This)->lpVtbl -> CanPaste(This,pVar,Format,pb)

#define ITextSelection_CanEdit(This,pbCanEdit)	\
    (This)->lpVtbl -> CanEdit(This,pbCanEdit)

#define ITextSelection_ChangeCase(This,Type)	\
    (This)->lpVtbl -> ChangeCase(This,Type)

#define ITextSelection_GetPoint(This,Type,px,py)	\
    (This)->lpVtbl -> GetPoint(This,Type,px,py)

#define ITextSelection_SetPoint(This,x,y,Type,Extend)	\
    (This)->lpVtbl -> SetPoint(This,x,y,Type,Extend)

#define ITextSelection_ScrollIntoView(This,Value)	\
    (This)->lpVtbl -> ScrollIntoView(This,Value)

#define ITextSelection_GetEmbeddedObject(This,ppv)	\
    (This)->lpVtbl -> GetEmbeddedObject(This,ppv)


#define ITextSelection_GetFlags(This,pFlags)	\
    (This)->lpVtbl -> GetFlags(This,pFlags)

#define ITextSelection_SetFlags(This,Flags)	\
    (This)->lpVtbl -> SetFlags(This,Flags)

#define ITextSelection_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ITextSelection_MoveLeft(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveLeft(This,Unit,Count,Extend,pDelta)

#define ITextSelection_MoveRight(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveRight(This,Unit,Count,Extend,pDelta)

#define ITextSelection_MoveUp(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveUp(This,Unit,Count,Extend,pDelta)

#define ITextSelection_MoveDown(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveDown(This,Unit,Count,Extend,pDelta)

#define ITextSelection_HomeKey(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> HomeKey(This,Unit,Extend,pDelta)

#define ITextSelection_EndKey(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> EndKey(This,Unit,Extend,pDelta)

#define ITextSelection_TypeText(This,bstr)	\
    (This)->lpVtbl -> TypeText(This,bstr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextSelection_GetFlags_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pFlags);


void __RPC_STUB ITextSelection_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextSelection_SetFlags_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ LONG Flags);


void __RPC_STUB ITextSelection_SetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextSelection_GetType_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pType);


void __RPC_STUB ITextSelection_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveLeft_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveRight_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveRight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveUp_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveDown_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_HomeKey_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_HomeKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_EndKey_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_EndKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_TypeText_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ITextSelection_TypeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextSelection_INTERFACE_DEFINED__ */


#ifndef __ITextFont_INTERFACE_DEFINED__
#define __ITextFont_INTERFACE_DEFINED__

/* interface ITextFont */
/* [object][nonextensible][dual][version][uuid] */ 


EXTERN_C const IID IID_ITextFont;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CC497C3-A1DF-11ce-8098-00AA0047BE5D")
    ITextFont : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDuplicate( 
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppFont) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetDuplicate( 
            /* [in] */ ITextFont __RPC_FAR *pFont) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanChange( 
            /* [retval][out] */ long __RPC_FAR *pB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ ITextFont __RPC_FAR *pFont,
            /* [retval][out] */ long __RPC_FAR *pB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Reset( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStyle( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStyle( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetAllCaps( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetAllCaps( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetAnimation( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetAnimation( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetBackColor( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetBackColor( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetBold( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetBold( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetEmboss( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetEmboss( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetForeColor( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetForeColor( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetHidden( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetHidden( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetEngrave( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetEngrave( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetItalic( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetItalic( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetKerning( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetKerning( 
            /* [in] */ float Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLanguageID( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetLanguageID( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetOutline( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetOutline( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetPosition( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetPosition( 
            /* [in] */ float Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetProtected( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetProtected( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetShadow( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetShadow( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSize( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSize( 
            /* [in] */ float Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSmallCaps( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSmallCaps( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSpacing( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSpacing( 
            /* [in] */ float Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStrikeThrough( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStrikeThrough( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSubscript( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSubscript( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSuperscript( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSuperscript( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetUnderline( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetUnderline( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetWeight( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetWeight( 
            /* [in] */ long Value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextFontVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextFont __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextFont __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextFont __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppFont);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDuplicate )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanChange )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont,
            /* [retval][out] */ long __RPC_FAR *pB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStyle )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStyle )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllCaps )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllCaps )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAnimation )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAnimation )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackColor )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackColor )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBold )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBold )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEmboss )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEmboss )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetForeColor )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetForeColor )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHidden )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHidden )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEngrave )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEngrave )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItalic )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItalic )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKerning )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKerning )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLanguageID )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLanguageID )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutline )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutline )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPosition )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPosition )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProtected )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProtected )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetShadow )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetShadow )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSize )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSmallCaps )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSmallCaps )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpacing )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSpacing )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStrikeThrough )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStrikeThrough )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubscript )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSubscript )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSuperscript )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSuperscript )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUnderline )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUnderline )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWeight )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWeight )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        END_INTERFACE
    } ITextFontVtbl;

    interface ITextFont
    {
        CONST_VTBL struct ITextFontVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextFont_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextFont_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextFont_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextFont_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextFont_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextFont_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextFont_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextFont_GetDuplicate(This,ppFont)	\
    (This)->lpVtbl -> GetDuplicate(This,ppFont)

#define ITextFont_SetDuplicate(This,pFont)	\
    (This)->lpVtbl -> SetDuplicate(This,pFont)

#define ITextFont_CanChange(This,pB)	\
    (This)->lpVtbl -> CanChange(This,pB)

#define ITextFont_IsEqual(This,pFont,pB)	\
    (This)->lpVtbl -> IsEqual(This,pFont,pB)

#define ITextFont_Reset(This,Value)	\
    (This)->lpVtbl -> Reset(This,Value)

#define ITextFont_GetStyle(This,pValue)	\
    (This)->lpVtbl -> GetStyle(This,pValue)

#define ITextFont_SetStyle(This,Value)	\
    (This)->lpVtbl -> SetStyle(This,Value)

#define ITextFont_GetAllCaps(This,pValue)	\
    (This)->lpVtbl -> GetAllCaps(This,pValue)

#define ITextFont_SetAllCaps(This,Value)	\
    (This)->lpVtbl -> SetAllCaps(This,Value)

#define ITextFont_GetAnimation(This,pValue)	\
    (This)->lpVtbl -> GetAnimation(This,pValue)

#define ITextFont_SetAnimation(This,Value)	\
    (This)->lpVtbl -> SetAnimation(This,Value)

#define ITextFont_GetBackColor(This,pValue)	\
    (This)->lpVtbl -> GetBackColor(This,pValue)

#define ITextFont_SetBackColor(This,Value)	\
    (This)->lpVtbl -> SetBackColor(This,Value)

#define ITextFont_GetBold(This,pValue)	\
    (This)->lpVtbl -> GetBold(This,pValue)

#define ITextFont_SetBold(This,Value)	\
    (This)->lpVtbl -> SetBold(This,Value)

#define ITextFont_GetEmboss(This,pValue)	\
    (This)->lpVtbl -> GetEmboss(This,pValue)

#define ITextFont_SetEmboss(This,Value)	\
    (This)->lpVtbl -> SetEmboss(This,Value)

#define ITextFont_GetForeColor(This,pValue)	\
    (This)->lpVtbl -> GetForeColor(This,pValue)

#define ITextFont_SetForeColor(This,Value)	\
    (This)->lpVtbl -> SetForeColor(This,Value)

#define ITextFont_GetHidden(This,pValue)	\
    (This)->lpVtbl -> GetHidden(This,pValue)

#define ITextFont_SetHidden(This,Value)	\
    (This)->lpVtbl -> SetHidden(This,Value)

#define ITextFont_GetEngrave(This,pValue)	\
    (This)->lpVtbl -> GetEngrave(This,pValue)

#define ITextFont_SetEngrave(This,Value)	\
    (This)->lpVtbl -> SetEngrave(This,Value)

#define ITextFont_GetItalic(This,pValue)	\
    (This)->lpVtbl -> GetItalic(This,pValue)

#define ITextFont_SetItalic(This,Value)	\
    (This)->lpVtbl -> SetItalic(This,Value)

#define ITextFont_GetKerning(This,pValue)	\
    (This)->lpVtbl -> GetKerning(This,pValue)

#define ITextFont_SetKerning(This,Value)	\
    (This)->lpVtbl -> SetKerning(This,Value)

#define ITextFont_GetLanguageID(This,pValue)	\
    (This)->lpVtbl -> GetLanguageID(This,pValue)

#define ITextFont_SetLanguageID(This,Value)	\
    (This)->lpVtbl -> SetLanguageID(This,Value)

#define ITextFont_GetName(This,pbstr)	\
    (This)->lpVtbl -> GetName(This,pbstr)

#define ITextFont_SetName(This,bstr)	\
    (This)->lpVtbl -> SetName(This,bstr)

#define ITextFont_GetOutline(This,pValue)	\
    (This)->lpVtbl -> GetOutline(This,pValue)

#define ITextFont_SetOutline(This,Value)	\
    (This)->lpVtbl -> SetOutline(This,Value)

#define ITextFont_GetPosition(This,pValue)	\
    (This)->lpVtbl -> GetPosition(This,pValue)

#define ITextFont_SetPosition(This,Value)	\
    (This)->lpVtbl -> SetPosition(This,Value)

#define ITextFont_GetProtected(This,pValue)	\
    (This)->lpVtbl -> GetProtected(This,pValue)

#define ITextFont_SetProtected(This,Value)	\
    (This)->lpVtbl -> SetProtected(This,Value)

#define ITextFont_GetShadow(This,pValue)	\
    (This)->lpVtbl -> GetShadow(This,pValue)

#define ITextFont_SetShadow(This,Value)	\
    (This)->lpVtbl -> SetShadow(This,Value)

#define ITextFont_GetSize(This,pValue)	\
    (This)->lpVtbl -> GetSize(This,pValue)

#define ITextFont_SetSize(This,Value)	\
    (This)->lpVtbl -> SetSize(This,Value)

#define ITextFont_GetSmallCaps(This,pValue)	\
    (This)->lpVtbl -> GetSmallCaps(This,pValue)

#define ITextFont_SetSmallCaps(This,Value)	\
    (This)->lpVtbl -> SetSmallCaps(This,Value)

#define ITextFont_GetSpacing(This,pValue)	\
    (This)->lpVtbl -> GetSpacing(This,pValue)

#define ITextFont_SetSpacing(This,Value)	\
    (This)->lpVtbl -> SetSpacing(This,Value)

#define ITextFont_GetStrikeThrough(This,pValue)	\
    (This)->lpVtbl -> GetStrikeThrough(This,pValue)

#define ITextFont_SetStrikeThrough(This,Value)	\
    (This)->lpVtbl -> SetStrikeThrough(This,Value)

#define ITextFont_GetSubscript(This,pValue)	\
    (This)->lpVtbl -> GetSubscript(This,pValue)

#define ITextFont_SetSubscript(This,Value)	\
    (This)->lpVtbl -> SetSubscript(This,Value)

#define ITextFont_GetSuperscript(This,pValue)	\
    (This)->lpVtbl -> GetSuperscript(This,pValue)

#define ITextFont_SetSuperscript(This,Value)	\
    (This)->lpVtbl -> SetSuperscript(This,Value)

#define ITextFont_GetUnderline(This,pValue)	\
    (This)->lpVtbl -> GetUnderline(This,pValue)

#define ITextFont_SetUnderline(This,Value)	\
    (This)->lpVtbl -> SetUnderline(This,Value)

#define ITextFont_GetWeight(This,pValue)	\
    (This)->lpVtbl -> GetWeight(This,pValue)

#define ITextFont_SetWeight(This,Value)	\
    (This)->lpVtbl -> SetWeight(This,Value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetDuplicate_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppFont);


void __RPC_STUB ITextFont_GetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetDuplicate_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ ITextFont __RPC_FAR *pFont);


void __RPC_STUB ITextFont_SetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextFont_CanChange_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextFont_CanChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextFont_IsEqual_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ ITextFont __RPC_FAR *pFont,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextFont_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextFont_Reset_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetStyle_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetStyle_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetAllCaps_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetAllCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetAllCaps_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetAllCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetAnimation_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetAnimation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetAnimation_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetAnimation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetBackColor_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetBackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetBackColor_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetBackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetBold_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetBold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetBold_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetBold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetEmboss_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetEmboss_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetEmboss_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetEmboss_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetForeColor_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetForeColor_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetHidden_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetHidden_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetHidden_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetHidden_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetEngrave_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetEngrave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetEngrave_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetEngrave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetItalic_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetItalic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetItalic_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetItalic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetKerning_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetKerning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetKerning_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetKerning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetLanguageID_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetLanguageID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetLanguageID_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetLanguageID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetName_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB ITextFont_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetName_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ITextFont_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetOutline_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetOutline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetOutline_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetOutline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetPosition_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetPosition_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetProtected_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetProtected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetProtected_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetProtected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetShadow_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetShadow_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSize_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSize_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSmallCaps_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSmallCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSmallCaps_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetSmallCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSpacing_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSpacing_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetStrikeThrough_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetStrikeThrough_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetStrikeThrough_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetStrikeThrough_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSubscript_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSubscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSubscript_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetSubscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSuperscript_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSuperscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSuperscript_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetSuperscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetUnderline_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetUnderline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetUnderline_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetUnderline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetWeight_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetWeight_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextFont_INTERFACE_DEFINED__ */


#ifndef __ITextPara_INTERFACE_DEFINED__
#define __ITextPara_INTERFACE_DEFINED__

/* interface ITextPara */
/* [object][nonextensible][dual][version][uuid] */ 


EXTERN_C const IID IID_ITextPara;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CC497C4-A1DF-11ce-8098-00AA0047BE5D")
    ITextPara : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDuplicate( 
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppPara) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetDuplicate( 
            /* [in] */ ITextPara __RPC_FAR *pPara) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanChange( 
            /* [retval][out] */ long __RPC_FAR *pB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ ITextPara __RPC_FAR *pPara,
            /* [retval][out] */ long __RPC_FAR *pB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Reset( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStyle( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStyle( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetAlignment( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetAlignment( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetHyphenation( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetHyphenation( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFirstLineIndent( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetKeepTogether( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetKeepTogether( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetKeepWithNext( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetKeepWithNext( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLeftIndent( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLineSpacing( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLineSpacingRule( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListAlignment( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListAlignment( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListLevelIndex( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListLevelIndex( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListStart( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListStart( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListTab( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListTab( 
            /* [in] */ float Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListType( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListType( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetNoLineNumber( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetNoLineNumber( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetPageBreakBefore( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetPageBreakBefore( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetRightIndent( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetRightIndent( 
            /* [in] */ float Value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetIndents( 
            /* [in] */ float StartIndent,
            /* [in] */ float LeftIndent,
            /* [in] */ float RightIndent) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetLineSpacing( 
            /* [in] */ long LineSpacingRule,
            /* [in] */ float LineSpacing) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSpaceAfter( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSpaceAfter( 
            /* [in] */ float Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSpaceBefore( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSpaceBefore( 
            /* [in] */ float Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetWidowControl( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetWidowControl( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetTabCount( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddTab( 
            /* [in] */ float tbPos,
            /* [in] */ long tbAlign,
            /* [in] */ long tbLeader) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ClearAllTabs( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteTab( 
            /* [in] */ float tbPos) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetTab( 
            /* [in] */ long iTab,
            /* [out] */ float __RPC_FAR *ptbPos,
            /* [out] */ long __RPC_FAR *ptbAlign,
            /* [out] */ long __RPC_FAR *ptbLeader) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextParaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextPara __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextPara __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextPara __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppPara);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDuplicate )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanChange )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara,
            /* [retval][out] */ long __RPC_FAR *pB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStyle )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStyle )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAlignment )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAlignment )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHyphenation )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHyphenation )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstLineIndent )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeepTogether )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKeepTogether )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeepWithNext )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKeepWithNext )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLeftIndent )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineSpacing )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineSpacingRule )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListAlignment )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListAlignment )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListLevelIndex )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListLevelIndex )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListStart )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListStart )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListTab )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListTab )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListType )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListType )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNoLineNumber )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNoLineNumber )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPageBreakBefore )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPageBreakBefore )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRightIndent )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRightIndent )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIndents )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ float StartIndent,
            /* [in] */ float LeftIndent,
            /* [in] */ float RightIndent);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLineSpacing )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long LineSpacingRule,
            /* [in] */ float LineSpacing);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpaceAfter )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSpaceAfter )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpaceBefore )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSpaceBefore )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWidowControl )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWidowControl )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTabCount )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddTab )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ float tbPos,
            /* [in] */ long tbAlign,
            /* [in] */ long tbLeader);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearAllTabs )( 
            ITextPara __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteTab )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ float tbPos);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTab )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long iTab,
            /* [out] */ float __RPC_FAR *ptbPos,
            /* [out] */ long __RPC_FAR *ptbAlign,
            /* [out] */ long __RPC_FAR *ptbLeader);
        
        END_INTERFACE
    } ITextParaVtbl;

    interface ITextPara
    {
        CONST_VTBL struct ITextParaVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextPara_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextPara_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextPara_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextPara_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextPara_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextPara_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextPara_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextPara_GetDuplicate(This,ppPara)	\
    (This)->lpVtbl -> GetDuplicate(This,ppPara)

#define ITextPara_SetDuplicate(This,pPara)	\
    (This)->lpVtbl -> SetDuplicate(This,pPara)

#define ITextPara_CanChange(This,pB)	\
    (This)->lpVtbl -> CanChange(This,pB)

#define ITextPara_IsEqual(This,pPara,pB)	\
    (This)->lpVtbl -> IsEqual(This,pPara,pB)

#define ITextPara_Reset(This,Value)	\
    (This)->lpVtbl -> Reset(This,Value)

#define ITextPara_GetStyle(This,pValue)	\
    (This)->lpVtbl -> GetStyle(This,pValue)

#define ITextPara_SetStyle(This,Value)	\
    (This)->lpVtbl -> SetStyle(This,Value)

#define ITextPara_GetAlignment(This,pValue)	\
    (This)->lpVtbl -> GetAlignment(This,pValue)

#define ITextPara_SetAlignment(This,Value)	\
    (This)->lpVtbl -> SetAlignment(This,Value)

#define ITextPara_GetHyphenation(This,pValue)	\
    (This)->lpVtbl -> GetHyphenation(This,pValue)

#define ITextPara_SetHyphenation(This,Value)	\
    (This)->lpVtbl -> SetHyphenation(This,Value)

#define ITextPara_GetFirstLineIndent(This,pValue)	\
    (This)->lpVtbl -> GetFirstLineIndent(This,pValue)

#define ITextPara_GetKeepTogether(This,pValue)	\
    (This)->lpVtbl -> GetKeepTogether(This,pValue)

#define ITextPara_SetKeepTogether(This,Value)	\
    (This)->lpVtbl -> SetKeepTogether(This,Value)

#define ITextPara_GetKeepWithNext(This,pValue)	\
    (This)->lpVtbl -> GetKeepWithNext(This,pValue)

#define ITextPara_SetKeepWithNext(This,Value)	\
    (This)->lpVtbl -> SetKeepWithNext(This,Value)

#define ITextPara_GetLeftIndent(This,pValue)	\
    (This)->lpVtbl -> GetLeftIndent(This,pValue)

#define ITextPara_GetLineSpacing(This,pValue)	\
    (This)->lpVtbl -> GetLineSpacing(This,pValue)

#define ITextPara_GetLineSpacingRule(This,pValue)	\
    (This)->lpVtbl -> GetLineSpacingRule(This,pValue)

#define ITextPara_GetListAlignment(This,pValue)	\
    (This)->lpVtbl -> GetListAlignment(This,pValue)

#define ITextPara_SetListAlignment(This,Value)	\
    (This)->lpVtbl -> SetListAlignment(This,Value)

#define ITextPara_GetListLevelIndex(This,pValue)	\
    (This)->lpVtbl -> GetListLevelIndex(This,pValue)

#define ITextPara_SetListLevelIndex(This,Value)	\
    (This)->lpVtbl -> SetListLevelIndex(This,Value)

#define ITextPara_GetListStart(This,pValue)	\
    (This)->lpVtbl -> GetListStart(This,pValue)

#define ITextPara_SetListStart(This,Value)	\
    (This)->lpVtbl -> SetListStart(This,Value)

#define ITextPara_GetListTab(This,pValue)	\
    (This)->lpVtbl -> GetListTab(This,pValue)

#define ITextPara_SetListTab(This,Value)	\
    (This)->lpVtbl -> SetListTab(This,Value)

#define ITextPara_GetListType(This,pValue)	\
    (This)->lpVtbl -> GetListType(This,pValue)

#define ITextPara_SetListType(This,Value)	\
    (This)->lpVtbl -> SetListType(This,Value)

#define ITextPara_GetNoLineNumber(This,pValue)	\
    (This)->lpVtbl -> GetNoLineNumber(This,pValue)

#define ITextPara_SetNoLineNumber(This,Value)	\
    (This)->lpVtbl -> SetNoLineNumber(This,Value)

#define ITextPara_GetPageBreakBefore(This,pValue)	\
    (This)->lpVtbl -> GetPageBreakBefore(This,pValue)

#define ITextPara_SetPageBreakBefore(This,Value)	\
    (This)->lpVtbl -> SetPageBreakBefore(This,Value)

#define ITextPara_GetRightIndent(This,pValue)	\
    (This)->lpVtbl -> GetRightIndent(This,pValue)

#define ITextPara_SetRightIndent(This,Value)	\
    (This)->lpVtbl -> SetRightIndent(This,Value)

#define ITextPara_SetIndents(This,StartIndent,LeftIndent,RightIndent)	\
    (This)->lpVtbl -> SetIndents(This,StartIndent,LeftIndent,RightIndent)

#define ITextPara_SetLineSpacing(This,LineSpacingRule,LineSpacing)	\
    (This)->lpVtbl -> SetLineSpacing(This,LineSpacingRule,LineSpacing)

#define ITextPara_GetSpaceAfter(This,pValue)	\
    (This)->lpVtbl -> GetSpaceAfter(This,pValue)

#define ITextPara_SetSpaceAfter(This,Value)	\
    (This)->lpVtbl -> SetSpaceAfter(This,Value)

#define ITextPara_GetSpaceBefore(This,pValue)	\
    (This)->lpVtbl -> GetSpaceBefore(This,pValue)

#define ITextPara_SetSpaceBefore(This,Value)	\
    (This)->lpVtbl -> SetSpaceBefore(This,Value)

#define ITextPara_GetWidowControl(This,pValue)	\
    (This)->lpVtbl -> GetWidowControl(This,pValue)

#define ITextPara_SetWidowControl(This,Value)	\
    (This)->lpVtbl -> SetWidowControl(This,Value)

#define ITextPara_GetTabCount(This,pCount)	\
    (This)->lpVtbl -> GetTabCount(This,pCount)

#define ITextPara_AddTab(This,tbPos,tbAlign,tbLeader)	\
    (This)->lpVtbl -> AddTab(This,tbPos,tbAlign,tbLeader)

#define ITextPara_ClearAllTabs(This)	\
    (This)->lpVtbl -> ClearAllTabs(This)

#define ITextPara_DeleteTab(This,tbPos)	\
    (This)->lpVtbl -> DeleteTab(This,tbPos)

#define ITextPara_GetTab(This,iTab,ptbPos,ptbAlign,ptbLeader)	\
    (This)->lpVtbl -> GetTab(This,iTab,ptbPos,ptbAlign,ptbLeader)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetDuplicate_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppPara);


void __RPC_STUB ITextPara_GetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetDuplicate_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ ITextPara __RPC_FAR *pPara);


void __RPC_STUB ITextPara_SetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_CanChange_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextPara_CanChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_IsEqual_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ ITextPara __RPC_FAR *pPara,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextPara_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_Reset_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetStyle_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetStyle_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetAlignment_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetAlignment_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetHyphenation_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetHyphenation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetHyphenation_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetHyphenation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetFirstLineIndent_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetFirstLineIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetKeepTogether_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetKeepTogether_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetKeepTogether_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetKeepTogether_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetKeepWithNext_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetKeepWithNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetKeepWithNext_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetKeepWithNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetLeftIndent_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetLeftIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetLineSpacing_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetLineSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetLineSpacingRule_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetLineSpacingRule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListAlignment_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListAlignment_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListLevelIndex_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListLevelIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListLevelIndex_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListLevelIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListStart_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListStart_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListTab_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListTab_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetListTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListType_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListType_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetNoLineNumber_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetNoLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetNoLineNumber_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetNoLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetPageBreakBefore_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetPageBreakBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetPageBreakBefore_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetPageBreakBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetRightIndent_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetRightIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetRightIndent_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetRightIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetIndents_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ float StartIndent,
    /* [in] */ float LeftIndent,
    /* [in] */ float RightIndent);


void __RPC_STUB ITextPara_SetIndents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetLineSpacing_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long LineSpacingRule,
    /* [in] */ float LineSpacing);


void __RPC_STUB ITextPara_SetLineSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetSpaceAfter_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetSpaceAfter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetSpaceAfter_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetSpaceAfter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetSpaceBefore_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetSpaceBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetSpaceBefore_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetSpaceBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetWidowControl_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetWidowControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetWidowControl_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetWidowControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetTabCount_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextPara_GetTabCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_AddTab_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ float tbPos,
    /* [in] */ long tbAlign,
    /* [in] */ long tbLeader);


void __RPC_STUB ITextPara_AddTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_ClearAllTabs_Proxy( 
    ITextPara __RPC_FAR * This);


void __RPC_STUB ITextPara_ClearAllTabs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_DeleteTab_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ float tbPos);


void __RPC_STUB ITextPara_DeleteTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetTab_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long iTab,
    /* [out] */ float __RPC_FAR *ptbPos,
    /* [out] */ long __RPC_FAR *ptbAlign,
    /* [out] */ long __RPC_FAR *ptbLeader);


void __RPC_STUB ITextPara_GetTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextPara_INTERFACE_DEFINED__ */


#ifndef __ITextStoryRanges_INTERFACE_DEFINED__
#define __ITextStoryRanges_INTERFACE_DEFINED__

/* interface ITextStoryRanges */
/* [object][nonextensible][dual][version][uuid] */ 


EXTERN_C const IID IID_ITextStoryRanges;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CC497C5-A1DF-11ce-8098-00AA0047BE5D")
    ITextStoryRanges : public IDispatch
    {
    public:
        virtual /* [restricted][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkEnum) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ long Index,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextStoryRangesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextStoryRanges __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextStoryRanges __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [restricted][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkEnum);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ long Index,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        END_INTERFACE
    } ITextStoryRangesVtbl;

    interface ITextStoryRanges
    {
        CONST_VTBL struct ITextStoryRangesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextStoryRanges_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoryRanges_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoryRanges_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoryRanges_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextStoryRanges_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextStoryRanges_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextStoryRanges_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextStoryRanges__NewEnum(This,ppunkEnum)	\
    (This)->lpVtbl -> _NewEnum(This,ppunkEnum)

#define ITextStoryRanges_Item(This,Index,ppRange)	\
    (This)->lpVtbl -> Item(This,Index,ppRange)

#define ITextStoryRanges_GetCount(This,pCount)	\
    (This)->lpVtbl -> GetCount(This,pCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [restricted][id] */ HRESULT STDMETHODCALLTYPE ITextStoryRanges__NewEnum_Proxy( 
    ITextStoryRanges __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkEnum);


void __RPC_STUB ITextStoryRanges__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextStoryRanges_Item_Proxy( 
    ITextStoryRanges __RPC_FAR * This,
    /* [in] */ long Index,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextStoryRanges_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextStoryRanges_GetCount_Proxy( 
    ITextStoryRanges __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextStoryRanges_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoryRanges_INTERFACE_DEFINED__ */


#ifndef __ITextDocument2_INTERFACE_DEFINED__
#define __ITextDocument2_INTERFACE_DEFINED__

/* interface ITextDocument2 */
/* [object][nonextensible][dual][version][uuid] */ 


EXTERN_C const IID IID_ITextDocument2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01c25500-4268-11d1-883a-3c8b00c10000")
    ITextDocument2 : public ITextDocument
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachMsgFilter( 
            /* [in] */ IUnknown __RPC_FAR *pFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetEffectColor( 
            /* [in] */ long Index,
            /* [in] */ COLORREF cr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEffectColor( 
            /* [in] */ long Index,
            /* [out] */ COLORREF __RPC_FAR *pcr) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE GetCaretType( 
            /* [retval][out] */ long __RPC_FAR *pCaretType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE SetCaretType( 
            /* [in] */ long CaretType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetImmContext( 
            /* [retval][out] */ long __RPC_FAR *pContext) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseImmContext( 
            /* [in] */ long Context) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPreferredFont( 
            /* [in] */ long cp,
            /* [in] */ long CodePage,
            /* [in] */ long Option,
            /* [in] */ long curCodepage,
            /* [in] */ long curFontSize,
            /* [out] */ BSTR __RPC_FAR *pbstr,
            /* [out] */ long __RPC_FAR *pPitchAndFamily,
            /* [out] */ long __RPC_FAR *pNewFontSize) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE GetNotificationMode( 
            /* [retval][out] */ long __RPC_FAR *pMode) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE SetNotificationMode( 
            /* [in] */ long Mode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetClientRect( 
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *pLeft,
            /* [out] */ long __RPC_FAR *pTop,
            /* [out] */ long __RPC_FAR *pRight,
            /* [out] */ long __RPC_FAR *pBottom) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE GetSelectionEx( 
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [out] */ long __RPC_FAR *phWnd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFEFlags( 
            /* [out] */ long __RPC_FAR *pFlags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateWindow( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckTextLimit( 
            long cch,
            long __RPC_FAR *pcch) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMEInProgress( 
            long Mode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SysBeep( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ long Mode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ long Notify) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDocumentFont( 
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppITextFont) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDocumentPara( 
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppITextPara) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCallManager( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppVoid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseCallManager( 
            IUnknown __RPC_FAR *pVoid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextDocument2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextDocument2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextDocument2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextDocument2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSelection )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryCount )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryRanges )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaved )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSaved )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultTabStop )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultTabStop )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *New )( 
            ITextDocument2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Freeze )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unfreeze )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEditCollection )( 
            ITextDocument2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEditCollection )( 
            ITextDocument2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Undo )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redo )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Range )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long cp1,
            /* [in] */ long cp2,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RangeFromPoint )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachMsgFilter )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEffectColor )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Index,
            /* [in] */ COLORREF cr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEffectColor )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Index,
            /* [out] */ COLORREF __RPC_FAR *pcr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCaretType )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCaretType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCaretType )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long CaretType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImmContext )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseImmContext )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Context);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPreferredFont )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long cp,
            /* [in] */ long CodePage,
            /* [in] */ long Option,
            /* [in] */ long curCodepage,
            /* [in] */ long curFontSize,
            /* [out] */ BSTR __RPC_FAR *pbstr,
            /* [out] */ long __RPC_FAR *pPitchAndFamily,
            /* [out] */ long __RPC_FAR *pNewFontSize);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNotificationMode )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pMode);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotificationMode )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Mode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClientRect )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *pLeft,
            /* [out] */ long __RPC_FAR *pTop,
            /* [out] */ long __RPC_FAR *pRight,
            /* [out] */ long __RPC_FAR *pBottom);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSelectionEx )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWindow )( 
            ITextDocument2 __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *phWnd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFEFlags )( 
            ITextDocument2 __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *pFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateWindow )( 
            ITextDocument2 __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckTextLimit )( 
            ITextDocument2 __RPC_FAR * This,
            long cch,
            long __RPC_FAR *pcch);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IMEInProgress )( 
            ITextDocument2 __RPC_FAR * This,
            long Mode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SysBeep )( 
            ITextDocument2 __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Mode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Notify);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentFont )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppITextFont);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentPara )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppITextPara);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCallManager )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppVoid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseCallManager )( 
            ITextDocument2 __RPC_FAR * This,
            IUnknown __RPC_FAR *pVoid);
        
        END_INTERFACE
    } ITextDocument2Vtbl;

    interface ITextDocument2
    {
        CONST_VTBL struct ITextDocument2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextDocument2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextDocument2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextDocument2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextDocument2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextDocument2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextDocument2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextDocument2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextDocument2_GetName(This,pName)	\
    (This)->lpVtbl -> GetName(This,pName)

#define ITextDocument2_GetSelection(This,ppSel)	\
    (This)->lpVtbl -> GetSelection(This,ppSel)

#define ITextDocument2_GetStoryCount(This,pCount)	\
    (This)->lpVtbl -> GetStoryCount(This,pCount)

#define ITextDocument2_GetStoryRanges(This,ppStories)	\
    (This)->lpVtbl -> GetStoryRanges(This,ppStories)

#define ITextDocument2_GetSaved(This,pValue)	\
    (This)->lpVtbl -> GetSaved(This,pValue)

#define ITextDocument2_SetSaved(This,Value)	\
    (This)->lpVtbl -> SetSaved(This,Value)

#define ITextDocument2_GetDefaultTabStop(This,pValue)	\
    (This)->lpVtbl -> GetDefaultTabStop(This,pValue)

#define ITextDocument2_SetDefaultTabStop(This,Value)	\
    (This)->lpVtbl -> SetDefaultTabStop(This,Value)

#define ITextDocument2_New(This)	\
    (This)->lpVtbl -> New(This)

#define ITextDocument2_Open(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Open(This,pVar,Flags,CodePage)

#define ITextDocument2_Save(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Save(This,pVar,Flags,CodePage)

#define ITextDocument2_Freeze(This,pCount)	\
    (This)->lpVtbl -> Freeze(This,pCount)

#define ITextDocument2_Unfreeze(This,pCount)	\
    (This)->lpVtbl -> Unfreeze(This,pCount)

#define ITextDocument2_BeginEditCollection(This)	\
    (This)->lpVtbl -> BeginEditCollection(This)

#define ITextDocument2_EndEditCollection(This)	\
    (This)->lpVtbl -> EndEditCollection(This)

#define ITextDocument2_Undo(This,Count,prop)	\
    (This)->lpVtbl -> Undo(This,Count,prop)

#define ITextDocument2_Redo(This,Count,prop)	\
    (This)->lpVtbl -> Redo(This,Count,prop)

#define ITextDocument2_Range(This,cp1,cp2,ppRange)	\
    (This)->lpVtbl -> Range(This,cp1,cp2,ppRange)

#define ITextDocument2_RangeFromPoint(This,x,y,ppRange)	\
    (This)->lpVtbl -> RangeFromPoint(This,x,y,ppRange)


#define ITextDocument2_AttachMsgFilter(This,pFilter)	\
    (This)->lpVtbl -> AttachMsgFilter(This,pFilter)

#define ITextDocument2_SetEffectColor(This,Index,cr)	\
    (This)->lpVtbl -> SetEffectColor(This,Index,cr)

#define ITextDocument2_GetEffectColor(This,Index,pcr)	\
    (This)->lpVtbl -> GetEffectColor(This,Index,pcr)

#define ITextDocument2_GetCaretType(This,pCaretType)	\
    (This)->lpVtbl -> GetCaretType(This,pCaretType)

#define ITextDocument2_SetCaretType(This,CaretType)	\
    (This)->lpVtbl -> SetCaretType(This,CaretType)

#define ITextDocument2_GetImmContext(This,pContext)	\
    (This)->lpVtbl -> GetImmContext(This,pContext)

#define ITextDocument2_ReleaseImmContext(This,Context)	\
    (This)->lpVtbl -> ReleaseImmContext(This,Context)

#define ITextDocument2_GetPreferredFont(This,cp,CodePage,Option,curCodepage,curFontSize,pbstr,pPitchAndFamily,pNewFontSize)	\
    (This)->lpVtbl -> GetPreferredFont(This,cp,CodePage,Option,curCodepage,curFontSize,pbstr,pPitchAndFamily,pNewFontSize)

#define ITextDocument2_GetNotificationMode(This,pMode)	\
    (This)->lpVtbl -> GetNotificationMode(This,pMode)

#define ITextDocument2_SetNotificationMode(This,Mode)	\
    (This)->lpVtbl -> SetNotificationMode(This,Mode)

#define ITextDocument2_GetClientRect(This,Type,pLeft,pTop,pRight,pBottom)	\
    (This)->lpVtbl -> GetClientRect(This,Type,pLeft,pTop,pRight,pBottom)

#define ITextDocument2_GetSelectionEx(This,ppSel)	\
    (This)->lpVtbl -> GetSelectionEx(This,ppSel)

#define ITextDocument2_GetWindow(This,phWnd)	\
    (This)->lpVtbl -> GetWindow(This,phWnd)

#define ITextDocument2_GetFEFlags(This,pFlags)	\
    (This)->lpVtbl -> GetFEFlags(This,pFlags)

#define ITextDocument2_UpdateWindow(This)	\
    (This)->lpVtbl -> UpdateWindow(This)

#define ITextDocument2_CheckTextLimit(This,cch,pcch)	\
    (This)->lpVtbl -> CheckTextLimit(This,cch,pcch)

#define ITextDocument2_IMEInProgress(This,Mode)	\
    (This)->lpVtbl -> IMEInProgress(This,Mode)

#define ITextDocument2_SysBeep(This)	\
    (This)->lpVtbl -> SysBeep(This)

#define ITextDocument2_Update(This,Mode)	\
    (This)->lpVtbl -> Update(This,Mode)

#define ITextDocument2_Notify(This,Notify)	\
    (This)->lpVtbl -> Notify(This,Notify)

#define ITextDocument2_GetDocumentFont(This,ppITextFont)	\
    (This)->lpVtbl -> GetDocumentFont(This,ppITextFont)

#define ITextDocument2_GetDocumentPara(This,ppITextPara)	\
    (This)->lpVtbl -> GetDocumentPara(This,ppITextPara)

#define ITextDocument2_GetCallManager(This,ppVoid)	\
    (This)->lpVtbl -> GetCallManager(This,ppVoid)

#define ITextDocument2_ReleaseCallManager(This,pVoid)	\
    (This)->lpVtbl -> ReleaseCallManager(This,pVoid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_AttachMsgFilter_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pFilter);


void __RPC_STUB ITextDocument2_AttachMsgFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_SetEffectColor_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Index,
    /* [in] */ COLORREF cr);


void __RPC_STUB ITextDocument2_SetEffectColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetEffectColor_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Index,
    /* [out] */ COLORREF __RPC_FAR *pcr);


void __RPC_STUB ITextDocument2_GetEffectColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetCaretType_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCaretType);


void __RPC_STUB ITextDocument2_GetCaretType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_SetCaretType_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long CaretType);


void __RPC_STUB ITextDocument2_SetCaretType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetImmContext_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pContext);


void __RPC_STUB ITextDocument2_GetImmContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_ReleaseImmContext_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Context);


void __RPC_STUB ITextDocument2_ReleaseImmContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetPreferredFont_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long cp,
    /* [in] */ long CodePage,
    /* [in] */ long Option,
    /* [in] */ long curCodepage,
    /* [in] */ long curFontSize,
    /* [out] */ BSTR __RPC_FAR *pbstr,
    /* [out] */ long __RPC_FAR *pPitchAndFamily,
    /* [out] */ long __RPC_FAR *pNewFontSize);


void __RPC_STUB ITextDocument2_GetPreferredFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetNotificationMode_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pMode);


void __RPC_STUB ITextDocument2_GetNotificationMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_SetNotificationMode_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Mode);


void __RPC_STUB ITextDocument2_SetNotificationMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetClientRect_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Type,
    /* [out] */ long __RPC_FAR *pLeft,
    /* [out] */ long __RPC_FAR *pTop,
    /* [out] */ long __RPC_FAR *pRight,
    /* [out] */ long __RPC_FAR *pBottom);


void __RPC_STUB ITextDocument2_GetClientRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetSelectionEx_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);


void __RPC_STUB ITextDocument2_GetSelectionEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetWindow_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *phWnd);


void __RPC_STUB ITextDocument2_GetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetFEFlags_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *pFlags);


void __RPC_STUB ITextDocument2_GetFEFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_UpdateWindow_Proxy( 
    ITextDocument2 __RPC_FAR * This);


void __RPC_STUB ITextDocument2_UpdateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_CheckTextLimit_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    long cch,
    long __RPC_FAR *pcch);


void __RPC_STUB ITextDocument2_CheckTextLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_IMEInProgress_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    long Mode);


void __RPC_STUB ITextDocument2_IMEInProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_SysBeep_Proxy( 
    ITextDocument2 __RPC_FAR * This);


void __RPC_STUB ITextDocument2_SysBeep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_Update_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Mode);


void __RPC_STUB ITextDocument2_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_Notify_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Notify);


void __RPC_STUB ITextDocument2_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetDocumentFont_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppITextFont);


void __RPC_STUB ITextDocument2_GetDocumentFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetDocumentPara_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppITextPara);


void __RPC_STUB ITextDocument2_GetDocumentPara_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetCallManager_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppVoid);


void __RPC_STUB ITextDocument2_GetCallManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_ReleaseCallManager_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    IUnknown __RPC_FAR *pVoid);


void __RPC_STUB ITextDocument2_ReleaseCallManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextDocument2_INTERFACE_DEFINED__ */


#ifndef __ITextMsgFilter_INTERFACE_DEFINED__
#define __ITextMsgFilter_INTERFACE_DEFINED__

/* interface ITextMsgFilter */
/* [object][nonextensible][version][uuid] */ 


EXTERN_C const IID IID_ITextMsgFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a3787420-4267-11d1-883a-3c8b00c10000")
    ITextMsgFilter : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachDocument( 
            /* [in] */ HWND hwnd,
            /* [in] */ ITextDocument2 __RPC_FAR *pTextDoc,
            /* [in] */ IUnknown __RPC_FAR *punk) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HandleMessage( 
            /* [out][in] */ UINT __RPC_FAR *pmsg,
            /* [out][in] */ WPARAM __RPC_FAR *pwparam,
            /* [out][in] */ LPARAM __RPC_FAR *plparam,
            /* [out] */ LRESULT __RPC_FAR *plres) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachMsgFilter( 
            /* [in] */ ITextMsgFilter __RPC_FAR *pMsgFilter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextMsgFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextMsgFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextMsgFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextMsgFilter __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachDocument )( 
            ITextMsgFilter __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ ITextDocument2 __RPC_FAR *pTextDoc,
            /* [in] */ IUnknown __RPC_FAR *punk);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandleMessage )( 
            ITextMsgFilter __RPC_FAR * This,
            /* [out][in] */ UINT __RPC_FAR *pmsg,
            /* [out][in] */ WPARAM __RPC_FAR *pwparam,
            /* [out][in] */ LPARAM __RPC_FAR *plparam,
            /* [out] */ LRESULT __RPC_FAR *plres);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachMsgFilter )( 
            ITextMsgFilter __RPC_FAR * This,
            /* [in] */ ITextMsgFilter __RPC_FAR *pMsgFilter);
        
        END_INTERFACE
    } ITextMsgFilterVtbl;

    interface ITextMsgFilter
    {
        CONST_VTBL struct ITextMsgFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextMsgFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextMsgFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextMsgFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextMsgFilter_AttachDocument(This,hwnd,pTextDoc,punk)	\
    (This)->lpVtbl -> AttachDocument(This,hwnd,pTextDoc,punk)

#define ITextMsgFilter_HandleMessage(This,pmsg,pwparam,plparam,plres)	\
    (This)->lpVtbl -> HandleMessage(This,pmsg,pwparam,plparam,plres)

#define ITextMsgFilter_AttachMsgFilter(This,pMsgFilter)	\
    (This)->lpVtbl -> AttachMsgFilter(This,pMsgFilter)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextMsgFilter_AttachDocument_Proxy( 
    ITextMsgFilter __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ ITextDocument2 __RPC_FAR *pTextDoc,
    /* [in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB ITextMsgFilter_AttachDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextMsgFilter_HandleMessage_Proxy( 
    ITextMsgFilter __RPC_FAR * This,
    /* [out][in] */ UINT __RPC_FAR *pmsg,
    /* [out][in] */ WPARAM __RPC_FAR *pwparam,
    /* [out][in] */ LPARAM __RPC_FAR *plparam,
    /* [out] */ LRESULT __RPC_FAR *plres);


void __RPC_STUB ITextMsgFilter_HandleMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextMsgFilter_AttachMsgFilter_Proxy( 
    ITextMsgFilter __RPC_FAR * This,
    /* [in] */ ITextMsgFilter __RPC_FAR *pMsgFilter);


void __RPC_STUB ITextMsgFilter_AttachMsgFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextMsgFilter_INTERFACE_DEFINED__ */

#endif /* __tom_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\common\pch.h ===
#include "baseinc.h"
#include "allutils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\common\sources.inc ===
!include ..\..\app.mk

MINORCOMP=appcommon

TARGETPATH=$(COBRA_ROOT)\lib\$(_OBJ_DIR)

SOURCES=\
    ..\common.c         \

PRECOMPILED_INCLUDE=..\pch.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\inc\common.h ===
VOID
InitAppCommon (
    VOID
    );

VOID
TerminateAppCommon (
    VOID
    );

HINF
InitRequiredInfs (
    IN      PCTSTR AppPath,
    IN      PCSTR FailMessageId
    );

VOID
PrintMsgOnConsole (
    IN      UINT MsgId
    );

VOID
UploadEnvVars (
    IN      MIG_PLATFORMTYPEID Platform
    );

VOID
SetLogVerbosity (
    IN      INT VerboseLevel
    );

BOOL
GetFilePath (
    IN      PCTSTR UserSpecifiedFile,
    OUT     PTSTR Buffer,
    IN      UINT BufferTchars
    );

VOID
WriteAppStatus (
    IN      PCTSTR AppJournal,
    IN      DWORD Status
    );

DWORD
ReadAppStatus (
    IN      PCTSTR AppJournal
    );

VOID
SelectComponentsViaInf (
    IN      HINF Inf
    );


typedef struct {
    GROWBUFFER BadInfs;
    GROWBUFFER MultiInfs;
    GROWBUFFER InputInf;
    PCTSTR LogFile;
    INT VerboseLevel;
    BOOL SystemOn;
    BOOL UserOn;
    BOOL FilesOn;
    BOOL TestMode;
    BOOL OverwriteImage;
    BOOL DelayedOpsOn;
    BOOL NoScanStateInfs;

    union {
        BOOL ContinueOnError;
        BOOL CurrentUser;
    };

    PCTSTR StoragePath;
    BOOL FullTransport;
    PCTSTR TransportName;
    BOOL TransportNameSpecified;

    DWORD Capabilities;

#ifdef PRERELEASE
    BOOL Recovery;
    TCHAR Tag[64];
#endif

} TOOLARGS, *PTOOLARGS;

typedef enum {
    PARSE_SUCCESS,
    PARSE_MULTI_LOG,
    PARSE_BAD_LOG,
    PARSE_MULTI_VERBOSE,
    PARSE_MISSING_STORAGE_PATH,
    PARSE_OTHER_ERROR
} PARSERESULT;

PARSERESULT
ParseToolCmdLine (
    IN      BOOL ScanState,
    IN OUT  PTOOLARGS Args,
    IN      INT Argc,
    IN      PCTSTR Argv[]
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loader\cab.h ===
#include "loader.h"

ERRORCODE
Unpack( VOID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\common\common.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    common.c

Abstract:

    Implements code common to two or more apps.

Author:

    Jim Schmidt (jimschm) 17-Oct-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "modules.h"
#include "trans.h"
#include "common.h"

//
// Strings
//

// none

//
// Constants
//

#define LOG_VERBOSE_BIT  0x01
#define LOG_UNUSED_BIT   0x02   // for v1 compatibility, do not use
#define LOG_STATUS_BIT   0x04
#define LOG_DEBUGGER_BIT 0x08
#define LOG_UPDATE_BIT   0x10

//
// Macros
//

// none

//
// Types
//

// none

//
// Globals
//

// none

//
// Macro expansion list
//

#define REQUIRED_INFS       \
        DEFMAC(OSFILES,     TEXT("USMTDef.inf"))  \

//
// Private function prototypes
//

// none

//
// Macro expansion definition
//

// this is the structure used for handling required infs

typedef struct {
    PCTSTR InfId;
    PCTSTR InfName;
} REQUIREDINF_STRUCT, *PREQUIREDINF_STRUCT;

// declare a global array of required infs

#define DEFMAC(infid,infname) {TEXT(#infid),infname},
static REQUIREDINF_STRUCT g_RequiredInfs[] = {
                              REQUIRED_INFS
                              {NULL, NULL}
                              };
#undef DEFMAC

//
// Code
//

VOID
InitAppCommon (
    VOID
    )
{
    InfGlobalInit (FALSE);
    RegInitialize();
}


VOID
TerminateAppCommon (
    VOID
    )
{
    RegTerminate();
    InfGlobalInit (FALSE);
}


HINF
InitRequiredInfs (
    IN      PCTSTR AppPath,
    IN      PCSTR FailMsgId
    )
{
    PCTSTR fullPath;
    HINF result = INVALID_HANDLE_VALUE;
    PREQUIREDINF_STRUCT p = g_RequiredInfs;

    while (p->InfId) {
        fullPath = JoinPaths (AppPath, p->InfName);
        if (DoesFileExist (fullPath)) {
            if (result == INVALID_HANDLE_VALUE) {
                result = SetupOpenInfFile (fullPath, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
                if (result == INVALID_HANDLE_VALUE) {
                    LOG ((LOG_ERROR, FailMsgId, p->InfId, fullPath));
                }
            } else {
                if (!SetupOpenAppendInfFile (fullPath, result, NULL)) {
                    LOG ((LOG_ERROR, FailMsgId, p->InfId, fullPath));
                }
            }
        } else {
            LOG ((LOG_ERROR, FailMsgId, p->InfId, fullPath));
        }
        FreePathString (fullPath);
        p++;
    }
    return result;
}


VOID
PrintMsgOnConsole (
    IN      UINT MsgId
    )
{
    PCTSTR msg;

    msg = GetStringResource (MsgId);

    if (msg) {
        _tprintf (TEXT("%s"), msg);

        FreeStringResource (msg);
    }
}


VOID
UploadEnvVars (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    PCTSTR envVars = NULL;
    MULTISZ_ENUM e;
    PTSTR envString;
    PTSTR p;

    //
    // we are going to write here all defined environment variables
    //

    envVars = (PCTSTR) GetEnvironmentStrings();

    if (envVars) {
        if (EnumFirstMultiSz (&e, envVars)) {
            do {
                envString = DuplicatePathString (e.CurrentString, 0);

                p = _tcschr (envString, TEXT('='));

                //
                // Get rid of empty environment strings or the dummy env string starting
                // with '='
                //
                if (!p || p == envString) {
                    FreePathString (envString);
                    continue;
                }

                *p = 0;
                p = _tcsinc (p);

                if (p) {
                    IsmSetEnvironmentString (Platform, S_SYSENVVAR_GROUP, envString, p);
                }

                FreePathString (envString);

            } while (EnumNextMultiSz (&e));
        }
    }
}

VOID
SetLogVerbosity (
    IN      INT VerboseLevel
    )
{
    LOG_LEVEL logBitmap = 0;

    if (VerboseLevel < 0) {
        VerboseLevel = 0;
    }

    // Always ON
    logBitmap = LL_FATAL_ERROR | LL_MODULE_ERROR | LL_ERROR;

    // ON for VERBOSE_BIT
    if (VerboseLevel & LOG_VERBOSE_BIT) {
        logBitmap |= LL_WARNING | LL_INFORMATION;
    }

    // ON for STATUS_BIT
    if (VerboseLevel & LOG_STATUS_BIT) {
        logBitmap |= LL_STATUS;
    }

    // ON for UPDATE_BIT
    if (VerboseLevel & LOG_UPDATE_BIT) {
        logBitmap |= LL_UPDATE;
    }

#ifdef PRERELEASE
    LogSetVerboseBitmap (
        logBitmap,
        LL_FATAL_ERROR|LL_MODULE_ERROR|LL_ERROR|LL_WARNING|LL_INFORMATION|LL_STATUS|LL_UPDATE,
        VerboseLevel & LOG_DEBUGGER_BIT
        );
#else
    LogSetVerboseBitmap (
        logBitmap,
        LL_FATAL_ERROR|LL_MODULE_ERROR|LL_ERROR|LL_WARNING|LL_INFORMATION,
        VerboseLevel & LOG_DEBUGGER_BIT
        );
#endif
}


BOOL
GetFilePath (
    IN      PCTSTR UserSpecifiedFile,
    OUT     PTSTR Buffer,
    IN      UINT BufferTchars
    )
{
    PTSTR tempBuffer = NULL;
    TCHAR infDir[MAX_MBCHAR_PATH];
    TCHAR modulePath[MAX_MBCHAR_PATH];
    TCHAR currentDir[MAX_MBCHAR_PATH];
    PTSTR p;
    PCTSTR userFile = NULL;
    PTSTR dontCare;

    __try {
        //
        // Locate the file using the full path specified by the user, or
        // if only a file spec was given, use the following priorities:
        //
        // 1. Current directory
        // 2. Directory where the tool is
        // 3. INF directory
        //
        // In all cases, return the full path to the file.
        //

        if (Buffer) {
            *Buffer = 0;
        } else {
            __leave;
        }

        tempBuffer = AllocText (BufferTchars);
        *tempBuffer = 0;

        if (!_tcsrchr (UserSpecifiedFile, TEXT('\\'))) {
            //
            // Compute INF directory, module directory and current directory
            //

            if (!GetWindowsDirectory (infDir, ARRAYSIZE(infDir) - 5)) {
                MYASSERT (FALSE);
                __leave;
            }

            StringCat (infDir, TEXT("\\inf"));

            if (!GetModuleFileName (NULL, modulePath, ARRAYSIZE(modulePath))) {
                MYASSERT (FALSE);
                __leave;
            }

            p = _tcsrchr (modulePath, TEXT('\\'));
            if (p) {
                *p = 0;
            } else {
                MYASSERT (FALSE);
                __leave;
            }

            if (!GetCurrentDirectory (ARRAYSIZE(currentDir), currentDir)) {
                MYASSERT (FALSE);
                __leave;
            }

            //
            // Let's see if it's in the current dir
            //

            userFile = JoinPaths (currentDir, UserSpecifiedFile);

            if (DoesFileExist (userFile)) {
                GetFullPathName (
                    userFile,
                    BufferTchars,
                    tempBuffer,
                    &dontCare
                    );
            } else {

                //
                // Let's try the module dir
                //

                FreePathString (userFile);
                userFile = JoinPaths (modulePath, UserSpecifiedFile);

                if (DoesFileExist (userFile)) {
                    GetFullPathName (
                        userFile,
                        BufferTchars,
                        tempBuffer,
                        &dontCare
                        );
                } else {
                    //
                    // Let's try the INF dir
                    //

                    FreePathString (userFile);
                    userFile = JoinPaths (infDir, UserSpecifiedFile);

                    if (DoesFileExist (userFile)) {
                        GetFullPathName (
                            userFile,
                            BufferTchars,
                            tempBuffer,
                            &dontCare
                            );
                    }
                }
            }

        } else {
            //
            // Use the full path that the user specified
            //

            GetFullPathName (
                UserSpecifiedFile,
                BufferTchars,
                tempBuffer,
                &dontCare
                );

            if (*tempBuffer && !DoesFileExist (tempBuffer)) {
                *tempBuffer = 0;
            }
        }

        //
        // Transfer output into caller's buffer.  Note the TCHAR conversion.
        //

        StringCopy (Buffer, tempBuffer);
    }
    __finally {
        if (userFile) {
            FreePathString (userFile);
        }

        if (tempBuffer) {
            FreeText (tempBuffer);
        }
    }

    return (Buffer && (*Buffer != 0));
}

VOID
WriteAppStatus (
    IN      PCTSTR AppJournal,
    IN      DWORD Status
    )
{
    HANDLE appJrnHandle;

    if (AppJournal && AppJournal [0]) {
        appJrnHandle = BfOpenFile (AppJournal);
        if (!appJrnHandle) {
            appJrnHandle = BfCreateFile (AppJournal);
        }
        if (appJrnHandle) {
            if (BfSetFilePointer (appJrnHandle, 0)) {
                BfWriteFile (appJrnHandle, (PBYTE)(&Status), sizeof (DWORD));
            }
            FlushFileBuffers (appJrnHandle);
            CloseHandle (appJrnHandle);
        }
    }
}

DWORD
ReadAppStatus (
    IN      PCTSTR AppJournal
    )
{
    HANDLE appJrnHandle;
    DWORD result = 0;

    if (AppJournal && AppJournal [0]) {
        appJrnHandle = BfOpenReadFile (AppJournal);
        if (appJrnHandle) {
            if (BfSetFilePointer (appJrnHandle, 0)) {
                if (!BfReadFile (appJrnHandle, (PBYTE)(&result), sizeof (DWORD))) {
                    result = 0;
                }
            }
            CloseHandle (appJrnHandle);
        }
    }
    return result;
}


VOID
SelectComponentsViaInf (
    IN      HINF Inf
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR data;

    //
    // Enable or disable components based on the unlocalized tag name,
    // or by the localized string
    //

    if (InfFindFirstLine (Inf, TEXT("Disabled Components"), NULL, &is)) {
        do {
            data = InfGetStringField (&is, 1);

            if (data) {
                if (!IsmSelectComponent (data, 0, FALSE)) {
                    IsmSelectComponent (data, COMPONENT_NAME, FALSE);
                }
            }

        } while (InfFindNextLine (&is));
    }

    if (InfFindFirstLine (Inf, TEXT("Enabled Components"), NULL, &is)) {
        do {
            data = InfGetStringField (&is, 1);

            if (data) {
                if (!IsmSelectComponent (data, 0, TRUE)) {
                    IsmSelectComponent (data, COMPONENT_NAME, TRUE);
                }
            }

        } while (InfFindNextLine (&is));
    }
}


PARSERESULT
ParseToolCmdLine (
    IN      BOOL ScanState,
    OUT     PTOOLARGS Args,
    IN      INT Argc,
    IN      PCTSTR Argv[]
    )
{
    INT i;
    PCTSTR infFileFromCmdLine;
    TCHAR fullInfPath[MAX_TCHAR_PATH];
    MULTISZ_ENUM e;
    HANDLE h;
    BOOL logCreated = FALSE;
    BOOL everythingOn = TRUE;
    BOOL xSwitch = FALSE;
#ifdef PRERELEASE
    DWORD tagSize;
#endif

    ZeroMemory (Args, sizeof (TOOLARGS));
    Args->VerboseLevel = -1;
    Args->TransportName = S_RELIABLE_STORAGE_TRANSPORT;

#ifdef PRERELEASE
    tagSize = ARRAYSIZE(Args->Tag);
    GetUserName (Args->Tag, &tagSize);
#endif

    for (i = 1 ; i < Argc ; i++) {
        if (Argv[i][0] == TEXT('-') || Argv[i][0] == '/') {
            switch ((CHARTYPE) _totlower ((CHARTYPE) _tcsnextc (&Argv[i][1]))) {

            case TEXT('i'):

                if (Argv[i][2] == TEXT('x') && !Argv[i][3]) {
                    if (ScanState) {
                        return PARSE_OTHER_ERROR;
                    }

                    if (Args->NoScanStateInfs) {
                        return PARSE_OTHER_ERROR;
                    }

                    Args->NoScanStateInfs = TRUE;
                    break;
                }

                if (Argv[i][2] == TEXT(':')) {
                    infFileFromCmdLine = &Argv[i][3];
                } else if (i + 1 < Argc) {
                    i++;
                    infFileFromCmdLine = Argv[i];
                } else {
                    return PARSE_OTHER_ERROR;
                }

                if (!GetFilePath (infFileFromCmdLine, fullInfPath, ARRAYSIZE(fullInfPath))) {
                    GbMultiSzAppend (&Args->BadInfs, infFileFromCmdLine);
                    break;
                }

                //
                // Make sure fullInfPath was not already specified
                //

                if (Args->InputInf.End) {
                    if (EnumFirstMultiSz (&e, (PCTSTR) Args->InputInf.Buf)) {
                        do {
                            if (StringIMatch (e.CurrentString, fullInfPath)) {
                                GbMultiSzAppend (&Args->MultiInfs, infFileFromCmdLine);
                                *fullInfPath = 0;
                                break;
                            }
                        } while (EnumNextMultiSz (&e));
                    }

                    if (*fullInfPath == 0) {
                        break;
                    }
                }

                //
                // INF file is valid
                //

                GbMultiSzAppend (&Args->InputInf, fullInfPath);
                break;

            case TEXT('l'):

                if (Args->LogFile) {
                    return PARSE_MULTI_LOG;
                }

                if (Argv[i][2] == TEXT(':')) {
                    Args->LogFile = &(Argv[i][3]);
                } else if (i + 1 < Argc) {
                    i++;
                    Args->LogFile = Argv[i];
                } else {
                    return PARSE_OTHER_ERROR;
                }

                h = BfCreateFile (Args->LogFile);
                if (!h) {
                    return PARSE_BAD_LOG;
                }

                CloseHandle (h);
                logCreated = TRUE;

                break;

            case TEXT('v'):

                if (Args->VerboseLevel >= 0) {
                    return PARSE_MULTI_VERBOSE;
                }

                if (Argv[i][2] == TEXT(':')) {
                    _stscanf (&(Argv[i][3]), TEXT("%d"), &Args->VerboseLevel);
                } else if (i + 1 < Argc) {
                    if (_tcsnextc (Argv[i + 1]) >= TEXT('0') &&
                        _tcsnextc (Argv[i + 1]) <= TEXT('9')
                        ) {
                        i++;
                        _stscanf (Argv[i], TEXT("%d"), &Args->VerboseLevel);
                    } else {
                        Args->VerboseLevel = 1;
                    }
                } else {
                    return PARSE_OTHER_ERROR;
                }

#ifndef PRERELEASE
                if (Args->VerboseLevel > 7) {
#else
                Args->VerboseLevel |= LOG_UPDATE_BIT;
                if (Args->VerboseLevel > 0x1F) {
#endif
                    return PARSE_OTHER_ERROR;
                }
                break;

            case TEXT('x'):
                if (xSwitch) {
                    return PARSE_OTHER_ERROR;
                }

                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                everythingOn = FALSE;
                xSwitch = TRUE;
                break;

            case TEXT('s'):
                if (Args->SystemOn) {
                    return PARSE_OTHER_ERROR;
                }

                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                Args->SystemOn = TRUE;
                everythingOn = FALSE;
                break;

            case TEXT('u'):
                if (Args->UserOn) {
                    return PARSE_OTHER_ERROR;
                }

                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                Args->UserOn = TRUE;
                everythingOn = FALSE;
                break;

            case TEXT('f'):
                if (Args->FilesOn) {
                    return PARSE_OTHER_ERROR;
                }

                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                Args->FilesOn = TRUE;
                everythingOn = FALSE;
                break;

            case TEXT('q'):
                if (ScanState) {
                    Args->OverwriteImage = TRUE;
                    Args->TestMode = TRUE;
                } else {
                    Args->CurrentUser = TRUE;
                }

                break;

            case TEXT('o'):
                if (!ScanState) {
                    return PARSE_OTHER_ERROR;
                }

                if (Args->OverwriteImage) {
                    return PARSE_OTHER_ERROR;
                }

                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                Args->OverwriteImage = TRUE;
                break;

            case TEXT('c'):
                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                if (ScanState) {
                    if (Args->ContinueOnError) {
                        return PARSE_OTHER_ERROR;
                    }

                    Args->ContinueOnError = TRUE;
                } else {
                    return PARSE_OTHER_ERROR;
                }

                break;

            case TEXT('d'):
                if (ScanState) {
                    return PARSE_OTHER_ERROR;
                }

                if (Args->DelayedOpsOn) {
                    return PARSE_OTHER_ERROR;
                }

                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                Args->DelayedOpsOn = TRUE;
                break;

#ifdef PRERELEASE
            case TEXT('t'):

                switch ((CHARTYPE) _totlower (Argv[i][2])) {

                case TEXT('f'):

                    if (Argv[i][3]) {
                        return PARSE_OTHER_ERROR;
                    }

                    if (Args->FullTransport) {
                        return PARSE_OTHER_ERROR;
                    }

                    Args->FullTransport = TRUE;
                    break;

                case TEXT('c'):
                    if (Argv[i][3]) {
                        return PARSE_OTHER_ERROR;
                    }

                    if (Args->Capabilities & CAPABILITY_COMPRESSED) {
                        return PARSE_OTHER_ERROR;
                    }

                    Args->Capabilities |= CAPABILITY_COMPRESSED;
                    break;

                case TEXT('a'):
                    if (Argv[i][3]) {
                        return PARSE_OTHER_ERROR;
                    }

                    if (Args->Capabilities & CAPABILITY_AUTOMATED) {
                        return PARSE_OTHER_ERROR;
                    }

                    Args->Capabilities |= CAPABILITY_AUTOMATED;
                    break;

                case TEXT('i'):
                    if (Argv[i][3] != TEXT(':')) {
                        return PARSE_OTHER_ERROR;
                    }

                    StackStringCopy (Args->Tag, &Argv[i][4]);
                    break;

                case 0:
                case TEXT(':'):
                    if (Args->TransportNameSpecified) {
                        return PARSE_OTHER_ERROR;
                    }

                    Args->TransportNameSpecified = TRUE;

                    if (Argv[i][2]) {
                        if (!Argv[i][3]) {
                            return PARSE_OTHER_ERROR;
                        }

                        Args->TransportName = &Argv[i][3];
                    } else {
                        if (i + 1 >= Argc) {
                            return PARSE_OTHER_ERROR;
                        } else {
                            i++;
                            Args->TransportName = Argv[i];
                        }
                    }

                    break;

                default:
                    return PARSE_OTHER_ERROR;
                }

                break;

            case TEXT('r'):
                if (ScanState) {
                    return PARSE_OTHER_ERROR;
                }

                if (Args->Recovery) {
                    return PARSE_OTHER_ERROR;
                }

                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                Args->Recovery = TRUE;
                break;

#endif

            default:
                return PARSE_OTHER_ERROR;

            }
        } else if (!Args->StoragePath) {
            Args->StoragePath = Argv[i];
        } else {
            return PARSE_OTHER_ERROR;
        }
    }

    if (!Args->StoragePath) {
        if (!Args->DelayedOpsOn) {
            return PARSE_MISSING_STORAGE_PATH;
        }
    }

    if (everythingOn) {
        Args->SystemOn = TRUE;
        Args->UserOn = TRUE;
        Args->FilesOn = TRUE;
    }

    if (Args->InputInf.Buf) {
        GbMultiSzAppend (&Args->InputInf, TEXT(""));
    }

    return PARSE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loader\cab.c ===
#include "pch.h"
#include <fdi.h>
#include <crtdbg.h>
#include <fcntl.h>
#include <stdio.h>
#include "loader.h"

// Types
typedef struct _UNPACKEDFILE
{
    PTSTR lpszFileName;
    PVOID nextFile;
} UNPACKEDFILESTRUCT, *LPUNPACKEDFILE;

// Globals
static ERF g_ERF;
static HFDI g_hFDI = NULL;
static LPUNPACKEDFILE g_lpFileList = NULL;

extern HINSTANCE g_hInstParent;
extern HWND g_hWndParent;

// Prototypes
VOID AddFileToList( PTSTR );


PVOID
DIAMONDAPI
CabAlloc (
    IN      ULONG Size
    )
{
    return ALLOC( Size );
}

VOID
DIAMONDAPI
CabFree (
    IN      PVOID Memory
    )
{
    FREE( Memory );
}

INT_PTR
DIAMONDAPI
CabOpen (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode
    )
{
    HANDLE fileHandle;

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    _ASSERT (oFlag == _O_BINARY);

    fileHandle = CreateFile (FileName,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_ARCHIVE,
                             NULL
                             );
    if (fileHandle == INVALID_HANDLE_VALUE)
    {
        return -1;
    }
    return (INT_PTR)fileHandle;
}

UINT
DIAMONDAPI
CabRead (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    )
{
    BOOL result;
    ULONG bytesRead;

    result = ReadFile ((HANDLE)FileHandle, Buffer, Size, &bytesRead, NULL);
    if (!result) {
        return ((UINT)(-1));
    }
    return bytesRead;
}

UINT
DIAMONDAPI
CabWrite (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    )
{
    BOOL result;
    DWORD bytesWritten;

    result = WriteFile ((HANDLE)FileHandle, Buffer, Size, &bytesWritten, NULL);
    if (!result) {
        return ((UINT)(-1));
    }
    return Size;
}

INT
DIAMONDAPI
CabClose (
    IN      INT_PTR FileHandle
    )
{
    CloseHandle ((HANDLE)FileHandle);
    return 0;
}

LONG
DIAMONDAPI
CabSeek (
    IN      INT_PTR FileHandle,
    IN      LONG Distance,
    IN      INT SeekType
    )
{
    DWORD result;
    DWORD seekType = FILE_BEGIN;

    switch (SeekType) {
    case SEEK_SET:
        seekType = FILE_BEGIN;
        break;
    case SEEK_CUR:
        seekType = FILE_CURRENT;
        break;
    case SEEK_END:
        seekType = FILE_END;
        break;
    }

    result = SetFilePointer ((HANDLE)FileHandle, Distance, NULL, seekType);

    if (result == INVALID_SET_FILE_POINTER) {
        return -1;
    }
    return ((LONG)(result));
}

INT_PTR
DIAMONDAPI
CabUnpackStatus
(
    IN        FDINOTIFICATIONTYPE fdiType,
    IN        FDINOTIFICATION *pfdiNotification
    )
{
    HANDLE destHandle = NULL;
    PTSTR destFileName = NULL;
    FILETIME localFileTime;
    FILETIME fileTime;
    BOOL fSkip = FALSE;
    PTSTR lpszDestPath = NULL;
    TCHAR destName [MAX_PATH];
    PTSTR destPtr = NULL;

    switch (fdiType)
    {
    case fdintCOPY_FILE:        // File to be copied
        // pfdin->psz1    = file name in cabinet
        // pfdin->cb      = uncompressed size of file
        // pfdin->date    = file date
        // pfdin->time    = file time
        // pfdin->attribs = file attributes
        // pfdin->iFolder = file's folder index

        if (_tcsicmp (pfdiNotification->psz1, TEXT("migwiz.exe.manifest")) == 0)
        {
            // Only copy the manifest if this OS is later than Whistler beta 1

            fSkip = TRUE;
            if (g_VersionInfo.dwMajorVersion >= 5 &&
                (g_VersionInfo.dwMinorVersion > 1 ||
                 (g_VersionInfo.dwMinorVersion == 1 &&
                  g_VersionInfo.dwBuildNumber >= 2424)))
            {
                fSkip = FALSE;
            }
        }

        if (!fSkip)
        {
            // let's look at the system and decide the destination name for the file
            ZeroMemory (destName, sizeof (destName));
            _tcsncpy (destName, pfdiNotification->psz1, MAX_PATH - 1);
            destPtr = _tcsrchr (pfdiNotification->psz1, TEXT('_'));
            if (destPtr) {
                if (_tcsncmp (destPtr, TEXT("_a."), 3) == 0) {
                    if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
                        // this is an ANSI file, don't copy it on NT
                        fSkip = TRUE;
                    } else {
                        // this is an ANSI file, rename it on Win9x
                        ZeroMemory (destName, sizeof (destName));
                        CopyMemory (destName, pfdiNotification->psz1, (UINT) (destPtr - pfdiNotification->psz1) * sizeof (TCHAR));
                        destPtr += 2;
                        _tcscat (destName, destPtr);
                    }
                }
                if (_tcsncmp (destPtr, TEXT("_u."), 3) == 0) {
                    if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
                        // this is an UNICODE file, don't copy it on NT
                        fSkip = TRUE;
                    } else {
                        // this is an UNICODE file, rename it on Win9x
                        ZeroMemory (destName, sizeof (destName));
                        CopyMemory (destName, pfdiNotification->psz1, (UINT) (destPtr - pfdiNotification->psz1) * sizeof (TCHAR));
                        destPtr += 2;
                        _tcscat (destName, destPtr);
                    }
                }
            }

            if (!fSkip) {

                SendMessage( g_hWndParent, WM_USER_UNPACKING_FILE, (WPARAM)NULL, (LPARAM)destName);

                lpszDestPath = GetDestPath();
                // Do not free lpszDestPath, because it is a pointer to a global
                if (lpszDestPath)
                {
                    destFileName = JoinPaths( lpszDestPath, destName);
                }
                if (destFileName)
                {
                    destHandle = CreateFile( destFileName,
                                             GENERIC_WRITE,
                                             0,
                                             NULL,
                                             CREATE_ALWAYS,
                                             FILE_ATTRIBUTE_TEMPORARY,
                                             NULL );
                    AddFileToList( destFileName );
                    FREE( destFileName );
                }
            }
        }
        return (INT_PTR)destHandle;

    case fdintCLOSE_FILE_INFO:  // close the file, set relevant info
        //            Called after all of the data has been written to a target file.
        //            This function must close the file and set the file date, time,
        //            and attributes.
        //        Entry:
        //            pfdin->psz1    = file name in cabinet
        //            pfdin->hf      = file handle
        //            pfdin->date    = file date
        //            pfdin->time    = file time
        //            pfdin->attribs = file attributes
        //            pfdin->iFolder = file's folder index
        //            pfdin->cb      = Run After Extract (0 - don't run, 1 Run)
        //        Exit-Success:
        //            Returns TRUE
        //        Exit-Failure:
        //            Returns FALSE, or -1 to abort;
        //
        //                IMPORTANT NOTE IMPORTANT:
        //                    pfdin->cb is overloaded to no longer be the size of
        //                    the file but to be a binary indicated run or not
        //
        //                IMPORTANT NOTE:
        //                    FDI assumes that the target file was closed, even if this
        //                    callback returns failure.  FDI will NOT attempt to use
        //                    the PFNCLOSE function supplied on FDICreate() to close
        //                    the file!

        if (DosDateTimeToFileTime (pfdiNotification->date, pfdiNotification->time, &localFileTime)) {
            if (LocalFileTimeToFileTime (&localFileTime, &fileTime)) {
                SetFileTime ((HANDLE)pfdiNotification->hf, &fileTime, &fileTime, &fileTime);
            }
        }
        CloseHandle ((HANDLE)pfdiNotification->hf);
//        attributes = (pfdiNotification->attribs & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE)) | FILE_ATTRIBUTE_TEMPORARY;
//        SetFileAttributes (destFile, attributes);
//        FreePathString (destFile);
        return TRUE;

    case fdintCABINET_INFO:
        // return success
        return 0;

    case fdintENUMERATE:
        // return success
        return 0;

    case fdintPARTIAL_FILE:
        // return failure
        return -1;

    case fdintNEXT_CABINET:
        // return failure
        return -1;

    default:
        break;
    }

    return 0;
}

VOID
AddFileToList( PTSTR lpszFilename )
{
    LPUNPACKEDFILE lpNewFile;

    lpNewFile = (LPUNPACKEDFILE)ALLOC( sizeof(UNPACKEDFILESTRUCT) );
    if (lpNewFile)
    {
        lpNewFile->lpszFileName = (PTSTR)ALLOC( (lstrlen(lpszFilename) + 1) * sizeof(TCHAR) );
        if (lpNewFile->lpszFileName)
        {
            lstrcpy( lpNewFile->lpszFileName, lpszFilename );
            lpNewFile->nextFile = g_lpFileList;

            g_lpFileList = lpNewFile;
        }
    }
}

VOID
CleanupTempFiles( VOID )
{
    LPUNPACKEDFILE lpFile = g_lpFileList;
    PTSTR lpszDestPath;

    while (lpFile)
    {
        g_lpFileList = (LPUNPACKEDFILE)lpFile->nextFile;
        if (lpFile->lpszFileName)
        {
            DeleteFile( lpFile->lpszFileName );
            FREE( lpFile->lpszFileName );
        }
        lpFile = g_lpFileList;
    }

    lpszDestPath = GetDestPath();
    if (lpszDestPath)
    {
        RemoveDirectory( lpszDestPath );
        // Do not free lpszDestPath, because it is a pointer to a global value
    }
}

ERRORCODE
Unpack( VOID )
{
    ERRORCODE ecResult = E_OK;
    PTSTR lpszCabFilename;
    PTSTR lpszDestPath;
    TCHAR szModulePath[MAX_PATH];
    TCHAR szDestFile[MAX_PATH];

    // Create the File Decompression Interface context
    g_hFDI = FDICreate( CabAlloc,
                        CabFree,
                        CabOpen,
                        CabRead,
                        CabWrite,
                        CabClose,
                        CabSeek,
                        cpuUNKNOWN,    // WARNING: Don't use auto-detect from a 16-bit Windows
                                    //            application!  Use GetWinFlags()!
                        &g_ERF );
    if (g_hFDI == NULL)
    {
        ecResult = E_UNPACK_FAILED;
        goto END;
    }

    // Create Dest Directory

    lpszDestPath = GetDestPath();
    // Do not free lpszDestPath, because it is a pointer to a global value

    if (!lpszDestPath)
    {
        ecResult = E_INVALID_PATH;
        goto END;
    }

    lpszCabFilename = GetResourceString( g_hInstParent, IDS_CABFILENAME );
    if (lpszCabFilename == NULL)
    {
        ecResult = E_INVALID_FILENAME;
    }
    else
    {
        // Unpack the CAB
        if (!FDICopy( g_hFDI,
                      lpszCabFilename,    // Only filename
                      GetModulePath(),    // Only path
                      0,
                      CabUnpackStatus,
                      NULL,
                      NULL ))
        {
            switch (g_ERF.erfOper)
            {
            case FDIERROR_CABINET_NOT_FOUND:
                ecResult = E_CAB_NOT_FOUND;
                break;
            case FDIERROR_NOT_A_CABINET:
            case FDIERROR_UNKNOWN_CABINET_VERSION:
            case FDIERROR_CORRUPT_CABINET:
                ecResult = E_CAB_CORRUPT;
                break;
            default:
                ecResult = E_UNPACK_FAILED;
                break;
            }

            goto END;
        }
        FREE( lpszCabFilename );
    }

    // Now copy migload.exe to the dest.  This is needed for creating wizard disks.
    if (GetModuleFileName( NULL, szModulePath, MAX_PATH )) {
        _tcscpy( szDestFile, lpszDestPath );
        _tcscat( szDestFile, TEXT("migload.exe"));
        CopyFile( szModulePath, szDestFile, FALSE );
    }

END:
    if (g_hFDI)
    {
        FDIDestroy( g_hFDI );
    }
    return ecResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loader\dialog.h ===
INT_PTR
CALLBACK
DlgProc (
    HWND Dlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loader\dialog.c ===
#include "pch.h"
#include "loader.h"
#include "resource.h"
#include "resrc1.h"
#include <winuser.h>
#include <commctrl.h>

#define ANIMATE_OPEN(x) SendDlgItemMessage(Dlg,IDC_ANIMATE1,ACM_OPEN,(WPARAM)NULL,(LPARAM)(LPTSTR)MAKEINTRESOURCE(x))
#define ANIMATE_PLAY()  SendDlgItemMessage(Dlg,IDC_ANIMATE1,ACM_PLAY,(WPARAM)-1,(LPARAM)MAKELONG(0,-1))
#define ANIMATE_STOP()  SendDlgItemMessage(Dlg,IDC_ANIMATE1,ACM_STOP,(WPARAM)0,(LPARAM)0);
#define ANIMATE_CLOSE() SendDlgItemMessage(Dlg,IDC_ANIMATE1,ACM_OPEN,(WPARAM)NULL,(LPARAM)NULL);

VOID
_CenterWindowOnDesktop (
    HWND WndToCenter
    )
{
    RECT  rcFrame, rcWindow;
    LONG  x, y, w, h;
    POINT point;
    HWND Desktop = GetDesktopWindow ();

    point.x = point.y = 0;
    ClientToScreen(Desktop, &point);
    GetWindowRect(WndToCenter, &rcWindow);
    GetClientRect(Desktop, &rcFrame);

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    x = point.x + ((rcFrame.right  - rcFrame.left + 1 - w) / 2);
    y = point.y + ((rcFrame.bottom - rcFrame.top  + 1 - h) / 2);

    //
    // Get the work area for the current desktop (i.e., the area that
    // the tray doesn't occupy).
    //
    if(!SystemParametersInfo (SPI_GETWORKAREA, 0, (PVOID)&rcFrame, 0)) {
        //
        // For some reason SPI failed, so use the full screen.
        //
        rcFrame.top = rcFrame.left = 0;
        rcFrame.right = GetSystemMetrics(SM_CXSCREEN);
        rcFrame.bottom = GetSystemMetrics(SM_CYSCREEN);
    }

    if(x + w > rcFrame.right) {
        x = rcFrame.right - w;
    } else if(x < rcFrame.left) {
        x = rcFrame.left;
    }
    if(y + h > rcFrame.bottom) {
        y = rcFrame.bottom - h;
    } else if(y < rcFrame.top) {
        y = rcFrame.top;
    }

    MoveWindow(WndToCenter, x, y, w, h, FALSE);
}

VOID
_DialogSetTextByResource( HWND hWnd, HINSTANCE hInst, DWORD dwResID, LPARAM Extra )
{
    PSTR lpszMsgFmtA;
    PWSTR lpszMsgFmtW;
    PSTR lpszNewTextA;
    PWSTR lpszNewTextW;

    if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        // WinNT
        lpszMsgFmtW = GetResourceStringW( hInst, dwResID );
        if (lpszMsgFmtW)
        {
            FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            lpszMsgFmtW,
                            0,
                            0,
                            (LPWSTR)(&lpszNewTextW),
                            0,
                            (va_list *)&Extra );
            FREE( lpszMsgFmtW );

            if (lpszNewTextW)
            {
                SetDlgItemTextW( hWnd, IDC_TEXT, (PWSTR)lpszNewTextW );
                LocalFree( lpszNewTextW );
            }
        }
    } else {
        // Win9x
        lpszMsgFmtA = GetResourceStringA( hInst, dwResID );
        if (lpszMsgFmtA)
        {
            FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            lpszMsgFmtA,
                            0,
                            0,
                            (LPSTR)(&lpszNewTextA),
                            0,
                            (va_list *)&Extra );
            FREE( lpszMsgFmtA );

            if (lpszNewTextA)
            {
                SetDlgItemTextA( hWnd, IDC_TEXT, (PSTR)lpszNewTextA );
                LocalFree( lpszNewTextA );
            }
        }
    }
}

VOID
_DisplayError( HWND hWnd, HINSTANCE hInst, DWORD ecValue, LPARAM Extra )
{
    ERRORMAPPINGSTRUCT ErrorMap[] = ERROR_MAPPING;
    DWORD dwArraySize;
    DWORD x;
    DWORD dwResId = IDS_MSG_SUCCESS;
    PSTR lpszMsgFmtA;
    PWSTR lpszMsgFmtW;
    PSTR lpszBoxTitleA;
    PWSTR lpszBoxTitleW;
    PSTR lpszNewTextA;
    PWSTR lpszNewTextW;

    dwArraySize = sizeof(ErrorMap) / sizeof(ERRORMAPPINGSTRUCT);
    for (x=0; x<dwArraySize; x++)
    {
        if (ecValue == ErrorMap[x].ecValue)
        {
            dwResId = ErrorMap[x].uResourceID;
            break;
        }
    }

    if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        // WinNT
        lpszMsgFmtW = GetResourceStringW( hInst, dwResId );
        if (lpszMsgFmtW)
        {
            FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            lpszMsgFmtW,
                            0,
                            0,
                            (LPWSTR)(&lpszNewTextW),
                            0,
                            (va_list *)&Extra );
            FREE( lpszMsgFmtW );

            if (lpszNewTextW)
            {
                lpszBoxTitleW = GetResourceStringW( hInst, IDS_WINDOWTITLE );
                if (lpszBoxTitleW)
                {
                    MessageBoxW( hWnd, lpszNewTextW, lpszBoxTitleW, MB_OK | MB_ICONERROR | MB_TASKMODAL );
                    FREE( lpszBoxTitleW );
                }
                LocalFree( lpszNewTextW );
            }
        }
    } else {
        // Win9x
        lpszMsgFmtA = GetResourceStringA( hInst, dwResId );
        if (lpszMsgFmtA)
        {
            FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            lpszMsgFmtA,
                            0,
                            0,
                            (LPSTR)(&lpszNewTextA),
                            0,
                            (va_list *)&Extra );
            FREE( lpszMsgFmtA );

            if (lpszNewTextA)
            {
                lpszBoxTitleA = GetResourceStringA( hInst, IDS_WINDOWTITLE );
                if (lpszBoxTitleA)
                {
                    MessageBoxA( hWnd, lpszNewTextA, lpszBoxTitleA, MB_OK | MB_ICONERROR | MB_TASKMODAL );
                    FREE( lpszBoxTitleA );
                }
                LocalFree( lpszNewTextA );
            }
        }
    }
}

BOOL
CALLBACK
_SetMigwizActive(
    HWND hWnd,
    LPARAM lParam
    )
{
    SetForegroundWindow( hWnd );
    return FALSE;
}

INT_PTR
CALLBACK
DlgProc (
    HWND Dlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    static HWND        hWndParent        = NULL;
    static HINSTANCE hInstParent    = NULL;
    static HCURSOR  Cursor            = NULL;
    static HWND        hWndAnim        = NULL;
    static DWORD    dwCurrentAnim    = 0;
    static DWORD    dwThreadId        = 0;

    switch (Msg)
    {
    case WM_ACTIVATE:
        if (dwThreadId != 0)
        {
            EnumThreadWindows( dwThreadId, _SetMigwizActive, (LPARAM)NULL );
        }
        break;
    case WM_INITDIALOG:
        hWndParent = ((LPTHREADSTARTUPINFO)lParam)->hWnd;
        hInstParent = ((LPTHREADSTARTUPINFO)lParam)->hInstance;

        ANIMATE_OPEN( IDA_STARTUP );
        ANIMATE_PLAY( );
        dwCurrentAnim = IDA_STARTUP;

        Cursor = SetCursor (LoadCursor (NULL, IDC_WAIT));
        ShowCursor (TRUE);
        _CenterWindowOnDesktop( Dlg );

        return TRUE;


    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:
            SendMessage( hWndParent, WM_USER_DIALOG_COMPLETE, wParam, 0 );
            return TRUE;
            break;
        }
        break;

    case WM_USER_UNPACKING_FILE:
        if (dwCurrentAnim == IDA_STARTUP)
        {
            ANIMATE_STOP();
            ANIMATE_CLOSE();
            ANIMATE_OPEN( IDA_FILECOPY );
            ANIMATE_PLAY();
            dwCurrentAnim = IDA_FILECOPY;
        }
        if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            // WinNT
            _DialogSetTextByResource( Dlg, hInstParent, IDS_MSG_UNPACKING_FILEW, lParam );
        } else {
            // Win9x
            _DialogSetTextByResource( Dlg, hInstParent, IDS_MSG_UNPACKING_FILEA, lParam );
        }
        break;

    case WM_USER_THREAD_ERROR:
        ANIMATE_STOP();
        ANIMATE_CLOSE();

        ShowWindow( Dlg, SW_HIDE );
        _DisplayError( Dlg, hInstParent, (DWORD)wParam, lParam );
        SendMessage( hWndParent, WM_USER_DIALOG_COMPLETE, wParam, 0 );
        break;

    case WM_USER_SUBTHREAD_CREATED:
        ShowWindow( Dlg, SW_HIDE );
        dwThreadId = (DWORD)lParam;
        break;

    case WM_USER_THREAD_COMPLETE:
        ANIMATE_STOP();
        ANIMATE_CLOSE();

        if ((ERRORCODE)lParam == E_OK)
        {
            SendMessage( hWndParent, WM_USER_DIALOG_COMPLETE, 0, 0 );
        }
        dwThreadId = 0;
        break;

    case WM_DESTROY:
        ShowCursor (FALSE);
        if (Cursor) {
            SetCursor (Cursor);
            Cursor = NULL;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loader\loader.h ===
#ifndef _LOADER_H_
#define _LOADER_H_

// NOTE: Currently REQUIRED_DLLS contains only new DLLs that are required at
//            startup of migwiz. It does not contain DLLs that are required already
//            to start this loader. It does not currently contain DLLs that are
//            automatically dynamically linked when a function is called in them.
// kernel32.dll
// msvcrt.dll
// user32.dll
// comctl32.dll
#define REQUIRED_DLLSA { \
    "advapi32.dll", \
    "comdlg32.dll", \
    "gdi32.dll",    \
    "msvcrt.dll",   \
    "ole32.dll",    \
    "setupapi.dll", \
    "shell32.dll",  \
    "shlwapi.dll",  \
}

#define REQUIRED_DLLSW { \
    L"advapi32.dll", \
    L"comdlg32.dll", \
    L"gdi32.dll",    \
    L"msvcrt.dll",   \
    L"ole32.dll",    \
    L"setupapi.dll", \
    L"shell32.dll",  \
    L"shlwapi.dll",  \
}

// Constants
#define WM_USER_THREAD_COMPLETE     (WM_APP + 1)
#define WM_USER_HIDE_WINDOW         (WM_APP + 2)
#define WM_USER_THREAD_ERROR        (WM_APP + 3)
#define WM_USER_DIALOG_COMPLETE     (WM_APP + 4)
#define WM_USER_UNPACKING_FILE      (WM_APP + 5)
#define WM_USER_SUBTHREAD_CREATED   (WM_APP + 6)

typedef enum _ERRORCODE
{
    E_OK,
    E_INVALID_PATH,
    E_INVALID_FILENAME,
    E_FILE_DOES_NOT_EXIST,
    E_PROCESS_CREATION_FAILED,
    E_THREAD_CREATION_FAILED,
    E_CAB_NOT_FOUND,
    E_CAB_CORRUPT,
    E_UNPACK_FAILED,
    E_DLL_NOT_FOUND,
    E_OLD_OS_VERSION,
    E_WRONG_LANGUAGE
} ERRORCODE;

#define ERROR_MAPPING {                                                       \
    { E_OK,                         IDS_MSG_SUCCESS                     },    \
    { E_INVALID_PATH,               IDS_MSG_E_INVALID_PATH              },    \
    { E_INVALID_FILENAME,           IDS_MSG_E_INVALID_FILENAME          },    \
    { E_FILE_DOES_NOT_EXIST,        IDS_MSG_E_FILE_DOES_NOT_EXIST       },    \
    { E_PROCESS_CREATION_FAILED,    IDS_MSG_E_PROCESS_CREATION_FAILED   },    \
    { E_THREAD_CREATION_FAILED,     IDS_MSG_E_THREAD_CREATION_FAILED    },    \
    { E_CAB_NOT_FOUND,              IDS_MSG_E_CAB_NOT_FOUND             },    \
    { E_CAB_CORRUPT,                IDS_MSG_E_CAB_CORRUPT               },    \
    { E_UNPACK_FAILED,              IDS_MSG_E_UNPACK_FAILED             },    \
    { E_DLL_NOT_FOUND,              IDS_MSG_E_DLL_NOT_FOUND             },    \
    { E_OLD_OS_VERSION,             IDS_MSG_E_OLD_OS_VERSION            },    \
    { E_WRONG_LANGUAGE,             IDS_MSG_E_WRONG_LANGUAGE            },    \
}

typedef struct _ERRORMAPPINGSTRUCT
{
    UINT ecValue;
    UINT uResourceID;
} ERRORMAPPINGSTRUCT, *LPERRORMAPPINGSTRUCT;

typedef struct _THREADSTARTUPINFO
{
    HWND hWnd;
    HINSTANCE hInstance;
    LPSTR lpCmdLine;
} THREADSTARTUPINFO, *LPTHREADSTARTUPINFO;

// Function prototypes

#define ALLOC(size) HeapAlloc( GetProcessHeap (), 0, size )
#define FREE(p)     HeapFree( GetProcessHeap (), 0, p )

BOOL InitLanguageDetection(VOID);


// Globals

extern OSVERSIONINFO g_VersionInfo;
extern BOOL g_IsLanguageMatched;


#endif /* _LOADER_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loader\lang.c ===
#include "pch.h"
#include "loader.h"
#include <stdlib.h>
#pragma hdrstop


#define ISNT()      (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
#define ISOSR2()    (LOWORD(g_VersionInfo.dwBuildNumber) > 1080)
#define BUILDNUM()  (g_VersionInfo.dwBuildNumber)

//
// Global variables defined here
//

//
// TargetNativeLangID : this is native language ID of running system
//
LANGID TargetNativeLangID;

//
// SourceNativeLangID : this is native language ID of new NT you want to install
//
LANGID SourceNativeLangID;

//
// g_IsLanguageMatched : if source and target language are matched (or compatible)
//
//                       1. if SourceNativeLangID == TargetNativeLangID
//
//                       2. if SourceNativeLangID's alternative ID == TargetNativeLangID
//
BOOL g_IsLanguageMatched;

typedef struct _tagAltSourceLocale {
    LANGID LangId;
    LANGID AltLangId;
    DWORD MajorOs;
    DWORD MinorOs;
    DWORD ExcludedOs;
} ALTSOURCELOCALE, *PALTSOURCELOCALE;

ALTSOURCELOCALE g_AltSourceLocale [] = {{0x00000C04, 0x00000409, 0x0200,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x0000040D, 0x00000409, 0x0200,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00000401, 0x00000409, 0x0200,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x0000041E, 0x00000409, 0x0200,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00000809, 0x00000409, 0x00FF,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x0000080A, 0x00000C0A, 0x00FF,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x0000040A, 0x00000C0A, 0x0300,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00000425, 0x00000409, 0x00FF,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00000801, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00000c01, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00001001, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00001401, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00001801, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00001c01, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00002001, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00002401, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00002801, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00002c01, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00003001, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00003401, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00003801, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00003c01, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00004001, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0,          0,          0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF}};

typedef struct _tagTrustedSourceLocale {
    LANGID LangId;
    DWORD MajorOs;
    DWORD MinorOs;
    DWORD ExcludedOs;
} TRUSTEDSOURCELOCALE, *PTRUSTEDSOURCELOCALE;

TRUSTEDSOURCELOCALE g_TrustedSourceLocale [] = {{0,          0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF}};

typedef struct _tagOSVERSIONMAJORID {
    PCTSTR Name;
    DWORD MajorId;
    DWORD Platform;
    DWORD Major;
    DWORD Minor;
} OSVERSIONMAJORID, *POSVERSIONMAJORID;

OSVERSIONMAJORID g_OsVersionMajorId [] = {{TEXT("Win95"),       0x0001, 1, 4, 0},
                                          {TEXT("Win98"),       0x0002, 1, 4, 10},
                                          {TEXT("WinME"),       0x0004, 1, 4, 90},
                                          {TEXT("WinNT351"),    0x0100, 2, 3, 51},
                                          {TEXT("WinNT40"),     0x0200, 2, 4, 0},
                                          {NULL,                0,      0, 0, 0}};

typedef struct _tagOSVERSIONMINORID {
    PCTSTR Name;
    DWORD MajorId;
    DWORD MinorId;
    DWORD Platform;
    DWORD Major;
    DWORD Minor;
    DWORD Build;
    PCTSTR CSDVer;
} OSVERSIONMINORID, *POSVERSIONMINORID;

OSVERSIONMINORID g_OsVersionMinorId [] = {{NULL, 0, 0, 0, 0, 0, 0, NULL}};

typedef struct _tagLANGINFO {
    LANGID LangID;
    INT    Count;
} LANGINFO,*PLANGINFO;

BOOL
TrustedDefaultUserLocale (
    LANGID LangID
    );

BOOL
CALLBACK
EnumLangProc(
    HANDLE hModule,     // resource-module handle
    LPCTSTR lpszType,   // pointer to resource type
    LPCTSTR lpszName,   // pointer to resource name
    WORD wIDLanguage,   // resource language identifier
    LONG_PTR lParam     // application-defined parameter
    )
/*++

Routine Description:

    Callback that counts versions stamps.

Arguments:

    Details of version enumerated version stamp. (Ignore.)

Return Value:

    Indirectly thru lParam: count, langID

--*/
{
    PLANGINFO LangInfo;

    LangInfo = (PLANGINFO) lParam;

    LangInfo->Count++;

    //
    // for localized build contains multiple resource,
    // it usually contains 0409 as backup lang.
    //
    // if LangInfo->LangID != 0 means we already assigned an ID to it
    //
    // so when wIDLanguage == 0x409, we keep the one we got from last time
    //
    if ((wIDLanguage == 0x409) && (LangInfo->LangID != 0)) {
        return TRUE;
    }

    LangInfo->LangID  = wIDLanguage;

    return TRUE;        // continue enumeration
}

LANGID
GetNTDLLNativeLangID (
    VOID
    )
/*++

Routine Description:

    This function is designed specifically for getting native lang of ntdll.dll

    This is not a generic function to get other module's language

    the assumption is:

    1. if only one language in resource then return this lang

    2. if two languages in resource then return non-US language

    3. if more than two languages, it's invalid in our case, but returns the last one.

Arguments:

    None

Return Value:

    Native lang ID in ntdll.dll

--*/
{
    LPCTSTR Type = (LPCTSTR) RT_VERSION;
    LPCTSTR Name = (LPCTSTR) 1;

    LANGINFO LangInfo;

    ZeroMemory(&LangInfo,sizeof(LangInfo));

    EnumResourceLanguages (
            GetModuleHandle(TEXT("ntdll.dll")),
            Type,
            Name,
            EnumLangProc,
            (LONG_PTR) &LangInfo
            );

    if ((LangInfo.Count > 2) || (LangInfo.Count < 1) ) {
        //
        // put error log here
        //
        // so far, for NT 3.51, only JPN has two language resources
    }

    return LangInfo.LangID;
}

BOOL
IsHongKongVersion (
    VOID
    )
/*++

Routine Description:

    Try to identify HongKong NT 4.0

    It based on:

    NTDLL's language is English and build is 1381 and
    pImmReleaseContext return TRUE

Arguments:


Return Value:

   Language ID of running system

--*/
{
    HMODULE hMod;
    BOOL bRet=FALSE;
    typedef BOOL (*IMMRELEASECONTEXT) (HWND,HANDLE);
    IMMRELEASECONTEXT pImmReleaseContext;

    LANGID TmpID = GetNTDLLNativeLangID();

    if ((g_VersionInfo.dwBuildNumber == 1381) &&
        (TmpID == 0x0409)){

        hMod = LoadLibrary(TEXT("imm32.dll"));

        if (hMod) {

            pImmReleaseContext = (IMMRELEASECONTEXT) GetProcAddress(hMod,"ImmReleaseContext");

            if (pImmReleaseContext) {
                bRet = pImmReleaseContext(NULL,NULL);
            }

            FreeLibrary(hMod);
        }
    }
    return (bRet);
}

LANGID
GetDefaultUserLangID (
    VOID
    )
{
    LONG            dwErr;
    HKEY            hkey;
    DWORD           dwSize;
    CHAR            buffer[512];
    LANGID          langid = 0;

    dwErr = RegOpenKeyEx( HKEY_USERS,
                          TEXT(".DEFAULT\\Control Panel\\International"),
                          0,
                          KEY_READ,
                          &hkey );

    if( dwErr == ERROR_SUCCESS ) {

        dwSize = sizeof(buffer);
        dwErr = RegQueryValueExA(hkey,
                                 "Locale",
                                 NULL,  //reserved
                                 NULL,  //type
                                 buffer,
                                 &dwSize );

        if(dwErr == ERROR_SUCCESS) {
            langid = LANGIDFROMLCID(strtoul(buffer,NULL,16));

        }
        RegCloseKey(hkey);
    }
    return langid;
}

LANGID
GetTargetNativeLangID (
    VOID
    )
/*++

Routine Description:

    Applies different rules to different platforms

    NT
        build number <= 1840           : check ntdll's language,
                                         we scaned all 3.51's ntdll on boneyard\intl,
                                         it looks like we can trust them.
        build number > 1840            : user MUI language

    Win9x
        use default user's resource language

Arguments:


Return Value:

   Language ID of running system

--*/
{
    LONG            dwErr;
    HKEY            hkey;
    DWORD           dwSize;
    CHAR            buffer[512];
    LANGID          rcLang;
    LANGID          langid = 0;


    // Find out if we are running on NT or WIN9X

    if( ISNT() ) {

        //
        // We're on NT, but which version?  GetSystemDefaultUILanguage() was broke until 1840...
        //
        if( g_VersionInfo.dwBuildNumber > 1840 ) {
        FARPROC     NT5API;

            //
            // Use the API to find out our locale.
            //

            if( NT5API = GetProcAddress( GetModuleHandle(TEXT("kernel32.dll")), "GetSystemDefaultUILanguage") ) {

                rcLang = (LANGID)NT5API();
                //
                // need to convert decimal to hex, LANGID to chr.
                //
                langid = rcLang;
            }
        } else {

                //
                // by looking into \\boneyard\intl, almost every ntdll.dll marked correct lang ID
                // so get langID from ntdll.dll
                //

                langid = GetNTDLLNativeLangID();

                if (langid == 0x0409) {

                    if (IsHongKongVersion()) {

                        langid = 0x0C04;

                    } else {
                        //
                        // if default user's locale is in [TrustedDefaultUserLocale]
                        //
                        // then this is a backdoor for some localized build that its ntdll.dll marked
                        //
                        // as English but can't be upgrade by US version.
                        //
                        LANGID DefaultUserLangID = GetDefaultUserLangID();

                        if (DefaultUserLangID  &&
                            TrustedDefaultUserLocale (DefaultUserLangID)) {

                            langid = DefaultUserLangID;
                        }
                    }
                }

        }
    } else {

        //
        // We're on Win9x.
        //
        dwErr = RegOpenKeyEx( HKEY_USERS,
                              TEXT(".Default\\Control Panel\\desktop\\ResourceLocale"),
                              0,
                              KEY_READ,
                              &hkey );

        if (dwErr == ERROR_SUCCESS) {

            dwSize = sizeof(buffer);
            dwErr = RegQueryValueExA( hkey,
                                     "",
                                     NULL,  //reserved
                                     NULL,  //type
                                     buffer,
                                     &dwSize );

            if(dwErr == ERROR_SUCCESS) {
                langid = LANGIDFROMLCID(strtoul(buffer,NULL,16));
            }
            RegCloseKey(hkey);
        }

        if ( dwErr != ERROR_SUCCESS ) {
           // Check HKLM\System\CurrentControlSet\Control\Nls\Locale

           dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                TEXT("System\\CurrentControlSet\\Control\\Nls\\Locale"),
                                0,
                                KEY_READ,
                                &hkey );

           if (dwErr == ERROR_SUCCESS) {

              dwSize = sizeof(buffer);
              dwErr = RegQueryValueExA( hkey,
                                        "",
                                        NULL,  //reserved
                                        NULL,  //type
                                        buffer,
                                        &dwSize );

              if (dwErr == ERROR_SUCCESS) {
                  langid = LANGIDFROMLCID(strtoul(buffer,NULL,16));
              }
              RegCloseKey(hkey);
           }
        }
    }

    return (langid);
}


LANGID
GetSourceNativeLangID (
    VOID
    )

/*++

Routine Description:

    [DefaultValues]
    Locale = xxxx

    every localized build has it's own Locale in intl.inf,

    so we use this value to identify source languag

Arguments:

Return Value:

   Language ID of source

--*/
{

    // BUGBUG - implement this by reading our own version info.

    LPCTSTR Type = (LPCTSTR) RT_VERSION;
    LPCTSTR Name = (LPCTSTR) 1;

    LANGINFO LangInfo;

    ZeroMemory(&LangInfo,sizeof(LangInfo));

    EnumResourceLanguages (
            NULL,   // our own module
            Type,
            Name,
            EnumLangProc,
            (LONG_PTR) &LangInfo
            );

    if ((LangInfo.Count > 2) || (LangInfo.Count < 1) ) {
        //
        // put error log here
        //
        // so far, for NT 3.51, only JPN has two language resources
    }

    return LangInfo.LangID;
}

DWORD
GetOsMajorId (
    VOID
    )
{
    POSVERSIONMAJORID p = g_OsVersionMajorId;

    while (p->Name) {
        if ((p->Platform == g_VersionInfo.dwPlatformId) &&
            (p->Major == g_VersionInfo.dwMajorVersion) &&
            (p->Minor == g_VersionInfo.dwMinorVersion)
            ) {
            return p->MajorId;
        }
        p++;
    }
    return 0;
}

DWORD
GetOsMinorId (
    VOID
    )
{
    POSVERSIONMINORID p = g_OsVersionMinorId;

    while (p->Name) {
        if ((p->Platform == g_VersionInfo.dwPlatformId) &&
            (p->Major == g_VersionInfo.dwMajorVersion) &&
            (p->Minor == g_VersionInfo.dwMinorVersion) &&
            (p->Build == g_VersionInfo.dwBuildNumber) &&
            ((p->CSDVer == NULL) || _tcsicmp (p->CSDVer, g_VersionInfo.szCSDVersion))
            ) {
            return p->MinorId;
        }
        p++;
    }
    return 0;
}

BOOL
TrustedDefaultUserLocale (
    LANGID LangID
    )
{
    PTRUSTEDSOURCELOCALE p = g_TrustedSourceLocale;

    while (p->LangId) {
        if ((!(p->ExcludedOs & GetOsMinorId ())) &&
            ((p->MinorOs & GetOsMinorId ()) || (p->MajorOs & GetOsMajorId ()))
           ) {
           return TRUE;
        }
        p++;
    }
    return FALSE;
}

BOOL
CheckLanguageVersion (
    LANGID SourceLangID,
    LANGID TargetLangID
    )
/*++

Routine Description:

    Check if the language of source NT is same as target NT or ,at least,

    compatibile

Arguments:

    Inf    handle of intl.inf

Return Value:

   TRUE  They are same or compatibile
   FALSE They are different

--*/
{
    PALTSOURCELOCALE p = g_AltSourceLocale;
    TCHAR TargetLangIDStr[9];

    LANGID SrcLANGID;
    LANGID DstLANGID;
    LANGID AltSourceLangID;

    //
    // If either one is 0, allow the upgrade. This is Windows 2000 Beta3 behavior.
    //
    if (SourceLangID == 0 || TargetLangID == 0) {
        return TRUE;
    }

    if (SourceLangID == TargetLangID) {
        return TRUE;
    }

    //
    // if Src != Dst, then we need to look up inf file to see
    //
    // if we can open a backdoor for Target language
    //

    //
    // use TargetLangID as key to find alternative SourceLangID
    //

    while (p->LangId) {
        //
        // Check if we found alternative locale
        //
        AltSourceLangID = LANGIDFROMLCID(p->AltLangId);
        if ((TargetLangID == p->LangId) &&
            (SourceLangID == AltSourceLangID)
            ) {
            //
            // We are here if we found alternative source lang,
            //
            // now check the version criteria
            //
            if ((!(p->ExcludedOs & GetOsMinorId ())) &&
                ((p->MinorOs & GetOsMinorId ()) || (p->MajorOs & GetOsMajorId ()))
               ) {
               return TRUE;
            }
        }
        p++;
    }
    return FALSE;
}


BOOL
InitLanguageDetection (
    VOID
    )
/*++

Routine Description:

    Initialize language detection and put the result in 3 global variables

    SourceNativeLangID  - LANGID of Source (NT is going to be installed)

    TargetNativeLangID  - LANGID of Target (OS system which is running)

    g_IsLanguageMatched - If language is not matched, then blocks upgrade

Arguments:

    None

Return Value:

   TRUE  init correctly
   FALSE init failed

--*/
{
    //
    // Init Global Variables
    //

    SourceNativeLangID  = GetSourceNativeLangID();

    TargetNativeLangID  = GetTargetNativeLangID();

    g_IsLanguageMatched = CheckLanguageVersion(SourceNativeLangID,TargetNativeLangID);

    if (!g_IsLanguageMatched) {
        if (SourceNativeLangID == 0x00000409) {
            // This is a localized system running an English wizard.
            // We want to allow that.
            g_IsLanguageMatched = TRUE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loader\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by loader.rc
//
#define IDS_WINDOWCLASS                 1
#define IDS_WINDOWTITLE                 2
#define IDS_MSG_STARTING                3
#define IDS_MIGWIZFILENAME              4
#define IDS_CABFILENAME                 5
#define IDS_MSG_SUCCESS                 6
#define IDS_MSG_E_INVALID_PATH          7
#define IDS_MSG_E_INVALID_FILENAME      8
#define IDS_MSG_E_FILE_DOES_NOT_EXIST   9
#define IDS_MSG_E_PROCESS_CREATION_FAILED 10
#define IDS_MSG_E_THREAD_CREATION_FAILED 11
#define IDS_MSG_E_CAB_NOT_FOUND         12
#define IDS_MSG_E_CAB_CORRUPT           13
#define IDS_MSG_E_UNPACK_FAILED         14
#define IDS_MSG_E_DLL_NOT_FOUND         15
#define IDS_MSG_E_OLD_OS_VERSION        16
#define IDS_MSG_UNPACKING_FILE          17
#define IDD_DIALOG1                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loader\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by visualc.rc
//
#define IDS_MSG_UNPACKING_FILEA         17
#define IDS_MSG_UNPACKING_FILEW         18
#define IDS_NEEDIE4                     19
#define IDS_MSG_E_WRONG_LANGUAGE        20
#define IDD_MIGWIZINIT                  101
#define IDA_FILECOPY                    104
#define IDA_STARTUP                     105
#define IDC_TEXT                        1002
#define IDC_WAIT_ANIM                   1003
#define IDC_WAIT_MARKER                 1004
#define IDC_ANIMATE1                    1005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loader\pch.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <windows.h>
#include <tchar.h>
//#include <malloc.h>
#include "resource.h"
#include "dialog.h"
#include "utils.h"
#include "cab.h"
#include "unpack.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loadstate\pch.h ===
#include "baseinc.h"
#include "allutils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loader\unpack.h ===
#include "loader.h"

DWORD
WINAPI
UnpackThread(
    IN      LPVOID lpParameter
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loader\unpack.c ===
#include "pch.h"
#include <stdio.h>
#include <stdlib.h>
#include "loader.h"
#include "resource.h"
#include "cab.h"

// Constants
typedef enum _MIGWIZLOC
{
    MWL_EXISTING,
    MWL_UNPACKED
} MIGWIZLOC;

// Globals
HWND g_hWndParent = NULL;
HINSTANCE g_hInstParent = NULL;
static LPSTR g_lpCmdLine = NULL;


VOID
HandleError( ERRORCODE ecValue, LPARAM lpszExtra )
{
    if (ecValue != E_OK)
    {
        SendMessage( g_hWndParent, WM_USER_THREAD_ERROR, (WPARAM)ecValue, lpszExtra );
    }
}

BOOL
pIsIE4Installed (
    VOID
    )
{
    LONG hResult;
    HKEY ieKey = NULL;
    DWORD valueType = REG_SZ;
    DWORD valueSize = 0;
    PTSTR valueData = NULL;
    PTSTR numPtr = NULL;
    PTSTR dotPtr = NULL;
    INT major = 0;
    INT minor = 0;
    TCHAR saved;
    BOOL result = FALSE;

    hResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Internet Explorer"), 0, KEY_QUERY_VALUE, &ieKey);
    if ((hResult == ERROR_SUCCESS) &&
        ieKey
        ) {
        hResult = RegQueryValueEx (ieKey, TEXT("Version"), NULL, &valueType, NULL, &valueSize);
        if ((hResult == ERROR_SUCCESS) || (hResult == ERROR_MORE_DATA)) {
            valueData = (PTSTR)HeapAlloc (GetProcessHeap (), 0, valueSize * 2);
            if (valueData) {
                hResult = RegQueryValueEx (ieKey, TEXT("Version"), NULL, &valueType, (PBYTE)valueData, &valueSize);
                if ((hResult == ERROR_SUCCESS) && (valueType == REG_SZ)) {
                    // let's see if it the version is the correct one
                    numPtr = valueData;
                    dotPtr = _tcschr (numPtr, TEXT('.'));
                    if (dotPtr) {
                        saved = *dotPtr;
                        *dotPtr = 0;
                        major = atoi (numPtr);
                        *dotPtr = saved;
                    } else {
                        major = atoi (numPtr);
                    }
                    if (dotPtr) {
                        numPtr = _tcsinc (dotPtr);
                        dotPtr = _tcschr (numPtr, TEXT('.'));
                        if (dotPtr) {
                            saved = *dotPtr;
                            *dotPtr = 0;
                            minor = atoi (numPtr);
                            *dotPtr = saved;
                        } else {
                            minor = atoi (numPtr);
                        }
                    }
                    if ((major >= 5) ||
                        ((major == 4) && (minor >= 71))
                        ) {
                        result = TRUE;
                    }
                }
                HeapFree (GetProcessHeap (), 0, valueData);
                valueData = NULL;
            }
        }
    }
    if (ieKey) {
        RegCloseKey (ieKey);
        ieKey = NULL;
    }
    return result;
}

ERRORCODE
CheckSystemRequirements( VOID )
{
    ERRORCODE dwRetval = E_OK;
    DWORD dwArraySize;
    DWORD x;
    HMODULE hDll;
    PSTR lpszDllListA[] = REQUIRED_DLLSA;
    PWSTR lpszDllListW[] = REQUIRED_DLLSW;
    DWORD dwVersion;

    //
    // Check OS version. Disallow Win32s and NT < 4.00
    //
    dwVersion = GetVersion();
    if((dwVersion & 0xff) < 4)
    {
        HandleError( E_OLD_OS_VERSION, 0 );
        return E_OLD_OS_VERSION;
    }

    // let's check to see if IE4 is installed on this machine
    if (!pIsIE4Installed ())
    {
        HandleError( E_OLD_OS_VERSION, 0 );
        return E_OLD_OS_VERSION;
    }

    // check if required DLLS exist
    if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        // WinNT
        dwArraySize = sizeof(lpszDllListW) / sizeof(PWSTR);
        for (x=0; x<dwArraySize; x++)
        {
            hDll = LoadLibraryW( lpszDllListW[x] );
            if (!hDll)
            {
                dwRetval = E_DLL_NOT_FOUND;
                HandleError( E_DLL_NOT_FOUND, (LPARAM)lpszDllListW[x] );
                break;
            }
            FreeLibrary( hDll );
        }
    } else {
        // Win9x
        dwArraySize = sizeof(lpszDllListA) / sizeof(PSTR);
        for (x=0; x<dwArraySize; x++)
        {
            hDll = LoadLibraryA( lpszDllListA[x] );
            if (!hDll)
            {
                dwRetval = E_DLL_NOT_FOUND;
                HandleError( E_DLL_NOT_FOUND, (LPARAM)lpszDllListA[x] );
                break;
            }
            FreeLibrary( hDll );
        }
    }

    if (InitLanguageDetection ()) {
        if (!g_IsLanguageMatched) {
            HandleError( E_WRONG_LANGUAGE, 0 );
            return E_WRONG_LANGUAGE;
        }
    }

    return dwRetval;
}

ERRORCODE
StartMigwiz( MIGWIZLOC mwlLocation )
{
    PTSTR lpszPath = NULL;
    PTSTR lpszMigwiz = NULL;
    PTSTR lpszFullName = NULL;
    STARTUPINFO startInfo;
    PROCESS_INFORMATION procInfo;
    ERRORCODE ecResult = E_OK;

    if (mwlLocation == MWL_EXISTING)
    {
        lpszPath = GetModulePath();
    }
    else  // mwlLocation == MWL_UNPACKED
    {
        lpszPath = GetDestPath();
    }

    if (lpszPath == NULL)
    {
        return E_INVALID_PATH;
    }

    lpszMigwiz = GetResourceString( g_hInstParent, IDS_MIGWIZFILENAME );
    if (lpszMigwiz != NULL)
    {
        lpszFullName = JoinPaths( lpszPath, lpszMigwiz );
        FREE( lpszMigwiz );
    }

    if (lpszFullName)
    {
        if (GetFileAttributes( lpszFullName ) != -1)
        {
            PTSTR lpszCommand = NULL;

            ZeroMemory( &startInfo, sizeof(STARTUPINFO) );
            startInfo.cb = sizeof(STARTUPINFO);

            if (g_lpCmdLine)
            {
                PTSTR lpszQuotedName;
                lpszQuotedName = ALLOC( (lstrlen(lpszFullName) + 3) * sizeof(TCHAR) );
                if (lpszQuotedName)
                {
                    lpszQuotedName[0] = TEXT('"');
                    lstrcpy( (lpszQuotedName+1), lpszFullName );
                    lstrcat( lpszQuotedName, TEXT("\"") );

                    lpszCommand = JoinText( lpszQuotedName, g_lpCmdLine, TEXT(' ') );
                    FREE( lpszQuotedName );
                }
            }

            if (CreateProcess( NULL,
                               lpszCommand ? lpszCommand : lpszFullName,
                               NULL,
                               NULL,
                               FALSE,
                               DETACHED_PROCESS,
                               NULL,
                               NULL,
                               &startInfo,
                               &procInfo ))
            {
                SendMessage( g_hWndParent, WM_USER_SUBTHREAD_CREATED, (WPARAM)NULL, (LPARAM)procInfo.dwThreadId );

                WaitForSingleObject( procInfo.hProcess, INFINITE );
            }
            else
            {
                ecResult = E_PROCESS_CREATION_FAILED;
            }
            FREE( lpszCommand );
        }
        else
        {
            ecResult = E_FILE_DOES_NOT_EXIST;
        }
        FREE( lpszFullName );
    }
    else
    {
        ecResult = E_INVALID_FILENAME;
    }

    return ecResult;
}

DWORD
WINAPI
UnpackThread(
    IN      LPVOID lpParameter
    )
{
    ERRORCODE ecResult = E_OK;

    g_hWndParent = ((LPTHREADSTARTUPINFO)lpParameter)->hWnd;
    g_hInstParent = ((LPTHREADSTARTUPINFO)lpParameter)->hInstance;
    g_lpCmdLine = ((LPTHREADSTARTUPINFO)lpParameter)->lpCmdLine;

    ecResult = CheckSystemRequirements();
    if (ecResult == E_OK)
    {
        // Don't worry if this StartMigwiz fails.  It's not an error yet
        if (StartMigwiz( MWL_EXISTING ) != E_OK)
        {
            ecResult = Unpack();
            if (ecResult == E_OK)
            {
                ecResult = StartMigwiz( MWL_UNPACKED );
                CleanupTempFiles();
            }
            HandleError( ecResult, 0 );
        }
    }

    UtilFree();

    SendMessage( g_hWndParent, WM_USER_THREAD_COMPLETE, (WPARAM)NULL, (LPARAM)ecResult );
    ExitThread( ecResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loadstate\sources.inc ===
!include ..\..\app.mk

MINORCOMP=loadstate

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\loadstate.c      \
    ..\loadstate.rc     \
    ..\logmsg.mc        \

# extra libs
TARGETLIBS= $(TARGETLIBS)                           \
            $(COBRA_ROOT)\lib\$(O)\utils.lib        \
            $(COBRA_ROOT)\bin\$(O)\migism.lib       \

PRECOMPILED_INCLUDE=..\pch.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loader\winmain.c ===
#include "pch.h"
#include "loader.h"
#include "resrc1.h"
#include <commctrl.h>
#include "dialog.h"

static HWND g_hWndDialog = NULL;
static HANDLE g_hThread = NULL;

OSVERSIONINFO g_VersionInfo;

LRESULT CALLBACK WndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    switch (message)
    {
    case WM_ACTIVATE:
        if (g_hWndDialog != NULL &&
            LOWORD(wParam) == WA_ACTIVE)
        {
            SetForegroundWindow( g_hWndDialog );
        }
        break;
    case WM_USER_DIALOG_COMPLETE:
        CloseHandle( g_hThread );
        DestroyWindow( g_hWndDialog );
        PostQuitMessage( 0 );
        break;
    default:
        return DefWindowProc( hWnd, message, wParam, lParam );
    }
    return 0;
}

int
APIENTRY
WinMain(HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPSTR     lpCmdLine,
        int       nCmdShow)
{
    WNDCLASSEXA wcxA;
    WNDCLASSEXW wcxW;
    MSG msg;
    PSTR lpszClassNameA = NULL;
    PSTR lpszWindowNameA = NULL;
    PWSTR lpszClassNameW = NULL;
    PWSTR lpszWindowNameW = NULL;
    DWORD dwResult = ERROR_SUCCESS;
    DWORD dwThreadID;
    THREADSTARTUPINFO StartInfo;
    HINSTANCE hInst;
    HWND hWnd;

    InitCommonControls();

    hInst = hInstance;

    //
    // let's get the current version info, we are going to need it later
    //
    ZeroMemory (&g_VersionInfo, sizeof(OSVERSIONINFO));
    g_VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx (&g_VersionInfo)) {
        g_VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        g_VersionInfo.dwMajorVersion = 4;
        g_VersionInfo.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS;
    }

    if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        // WinNT
        lpszClassNameW = GetResourceStringW( hInstance, IDS_WINDOWCLASS );
        lpszWindowNameW = GetResourceStringW( hInstance, IDS_WINDOWTITLE );
        hWnd = FindWindowW( lpszClassNameW, NULL );
        if (hWnd)
        {
            SetForegroundWindow( hWnd );
            goto END;
        }
        wcxW.cbSize = sizeof (WNDCLASSEXW);
        wcxW.style = CS_HREDRAW | CS_VREDRAW;
        wcxW.lpfnWndProc = (WNDPROC)WndProc;
        wcxW.cbClsExtra = 0;
        wcxW.cbWndExtra = 0;
        wcxW.hInstance = hInstance;
        wcxW.hIcon = NULL;
        wcxW.hCursor = LoadCursorA(NULL, IDC_ARROW);
        wcxW.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wcxW.lpszMenuName = NULL;
        wcxW.lpszClassName = lpszClassNameW;
        wcxW.hIconSm = NULL;
        if (!RegisterClassExW (&wcxW))
        {
            dwResult = GetLastError();
            goto END;
        }
        hWnd = CreateWindowW( lpszClassNameW,
                              lpszWindowNameW,
                              WS_OVERLAPPEDWINDOW,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              400,
                              300,
                              NULL,
                              NULL,
                              hInstance,
                              NULL );
        if (!hWnd)
        {
            dwResult = GetLastError();
            goto END;
        }
        StartInfo.hWnd = hWnd;
        StartInfo.hInstance = hInstance;
        g_hWndDialog = CreateDialogParamW( hInstance,
                                           MAKEINTRESOURCEW(IDD_MIGWIZINIT),
                                           hWnd,
                                           DlgProc,
                                           (LPARAM)&StartInfo );
        if (g_hWndDialog == NULL)
        {
            dwResult = GetLastError();
            goto END;
        }
    } else {
        // Win9x
        lpszClassNameA = GetResourceStringA( hInstance, IDS_WINDOWCLASS );
        lpszWindowNameA = GetResourceStringA( hInstance, IDS_WINDOWTITLE );
        hWnd = FindWindowA( lpszClassNameA, lpszWindowNameA );
        if (hWnd)
        {
            SetForegroundWindow( hWnd );
            goto END;
        }
        wcxA.cbSize = sizeof (WNDCLASSEXA);
        wcxA.style = CS_HREDRAW | CS_VREDRAW;
        wcxA.lpfnWndProc = (WNDPROC)WndProc;
        wcxA.cbClsExtra = 0;
        wcxA.cbWndExtra = 0;
        wcxA.hInstance = hInstance;
        wcxA.hIcon = NULL;
        wcxA.hCursor = LoadCursorA(NULL, IDC_ARROW);
        wcxA.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wcxA.lpszMenuName = NULL;
        wcxA.lpszClassName = lpszClassNameA;
        wcxA.hIconSm = NULL;
        if (!RegisterClassExA (&wcxA))
        {
            dwResult = GetLastError();
            goto END;
        }
        hWnd = CreateWindowA( lpszClassNameA,
                              lpszWindowNameA,
                              WS_OVERLAPPEDWINDOW,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              400,
                              300,
                              NULL,
                              NULL,
                              hInstance,
                              NULL );
        if (!hWnd)
        {
            dwResult = GetLastError();
            goto END;
        }
        StartInfo.hWnd = hWnd;
        StartInfo.hInstance = hInstance;
        g_hWndDialog = CreateDialogParamA( hInstance,
                                           MAKEINTRESOURCEA(IDD_MIGWIZINIT),
                                           hWnd,
                                           DlgProc,
                                           (LPARAM)&StartInfo );
        if (g_hWndDialog == NULL)
        {
            dwResult = GetLastError();
            goto END;
        }
    }

    // Create the Unpacking thread.
    // Note we pass along the Dialog's hwnd so the thread will report directly to it
    StartInfo.hWnd = g_hWndDialog;
    StartInfo.hInstance = hInstance;
    StartInfo.lpCmdLine = lpCmdLine;
    g_hThread = CreateThread( NULL,
                              0,
                              UnpackThread,
                              (PVOID)&StartInfo,
                              0,
                              &dwThreadID );
    if (g_hThread == NULL)
    {
        // TODO: Handle Error
        dwResult = GetLastError();
        goto END;
    }

    // Main message loop:
    while (GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
    dwResult = LOWORD(msg.wParam);

END:
    if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        // WinNT
        if (lpszClassNameW)
        {
            UnregisterClassW(lpszClassNameW, hInstance);
            FREE( lpszClassNameW );
        }
        if (lpszWindowNameW)
        {
            FREE( lpszWindowNameW );
        }
    } else {
        // Win9x
        if (lpszClassNameA)
        {
            UnregisterClassA(lpszClassNameA, hInstance);
            FREE( lpszClassNameA );
        }
        if (lpszWindowNameA)
        {
            FREE( lpszWindowNameA );
        }
    }
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loader\utils.h ===
#define JoinPaths(x,y) JoinText(x, y, TEXT('\\'))

PTSTR
GetResourceString( HINSTANCE hInstance, DWORD dwResID );

VOID CleanupTempFiles( VOID );

VOID UtilFree( VOID );

PTSTR
GetDestPath( VOID );

PTSTR
GetModulePath( VOID );

PTSTR
JoinText( PTSTR lpStr1, PTSTR lpStr2, TCHAR chSeparator );

PTSTR
GetResourceString( HINSTANCE hInstance, DWORD dwResID );

PSTR
GetResourceStringA( HINSTANCE hInstance, DWORD dwResID );

PWSTR
GetResourceStringW( HINSTANCE hInstance, DWORD dwResID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loader\utils.c ===
#include "pch.h"
#include "loader.h"

#define MAX_RESOURCE_LENGTH 2048
#define MIGWIZSUBDIR TEXT("usmt\\")

#define MINIMUM_DISK_SPACE 3000000

// Globals
static PTSTR g_lpszDestPath = NULL;
static PTSTR g_lpszModulePath = NULL;


PTSTR
GetModulePath( VOID )
{
    if (g_lpszModulePath == NULL)
    {
        TCHAR lpszPath[MAX_PATH + 1];
        DWORD dwResult;

        // Build the path where this exe resides
        dwResult = GetModuleFileName( NULL, lpszPath, MAX_PATH );
        if (dwResult > 0 &&
            dwResult < MAX_PATH)
        {
            LPTSTR ptr;
            TCHAR *lastWack = NULL;

            ptr = lpszPath;

            while (*ptr)
            {
                if (*ptr == TEXT('\\'))
                {
                    lastWack = ptr;
                }
                ptr = CharNext( ptr );
            }

            if (lastWack)
            {
                *(lastWack + 1) = 0;
                g_lpszModulePath = (PTSTR)ALLOC( (lstrlen(lpszPath) + 1) * sizeof(TCHAR) );
                if (g_lpszModulePath)
                {
                    lstrcpy( g_lpszModulePath, lpszPath );
                }
            }
        }
    }

    return g_lpszModulePath;
}

DWORD
pConvertDriveToBit (
    PCTSTR driveString
    )
{
    DWORD bit = 0;
    TCHAR driveLetter;

    if (driveString && *driveString) {
        driveLetter = (TCHAR)_totlower (*driveString);
        if (driveLetter >= TEXT('a') && driveLetter <= TEXT('z')) {
            bit = 0x1 << (driveLetter - TEXT('a'));
        }
    }
    return bit;
}

BOOL
pCreateMigwizDir( PCTSTR lpszPath )
{
    BOOL fResult = FALSE;

    if (g_lpszDestPath != NULL)
    {
        FREE( g_lpszDestPath );
    }

    g_lpszDestPath = (PTSTR)ALLOC( (lstrlen(lpszPath) + lstrlen(MIGWIZSUBDIR) + 1) * sizeof(TCHAR) );
    if (g_lpszDestPath)
    {
        lstrcpy( g_lpszDestPath, lpszPath );
        lstrcat( g_lpszDestPath, MIGWIZSUBDIR );

        if (!CreateDirectory( g_lpszDestPath, NULL ))
        {
            if (GetLastError() != ERROR_ALREADY_EXISTS)
            {
                FREE( g_lpszDestPath );
                g_lpszDestPath = NULL;
                return FALSE;
            }
        }
        fResult = TRUE;
    }

    return fResult;
}

PTSTR
GetDestPath( VOID )
{
    DWORD sectPerClust;
    DWORD bytesPerSect;
    DWORD freeClusters;
    DWORD totalClusters;
    ULONGLONG maxFreeDiskSpace = 0;
    ULONGLONG freeDiskSpace = 0;
    TCHAR szPath[MAX_PATH + 1];
    PTSTR lpDriveList = NULL;
    PCTSTR lpDrive;
    DWORD dwListLen;


    if (g_lpszDestPath == NULL)
    {
        // If %TEMP% has enough space, use it
        if (GetTempPath( MAX_PATH, szPath ))
        {
            TCHAR szTmpPath[4] = TEXT("?:\\");

            szTmpPath[0] = szPath[0];
            if (GetDiskFreeSpace( szTmpPath, &sectPerClust, &bytesPerSect, &freeClusters, &totalClusters ))
            {
                freeDiskSpace = Int32x32To64( (sectPerClust * bytesPerSect), freeClusters );
                if (freeDiskSpace > MINIMUM_DISK_SPACE)
                {
                    if (pCreateMigwizDir(szPath))
                    {
                        return g_lpszDestPath;
                    }
                }
            }
        }

        // Otherwise use the first drive with the enough space
        dwListLen = GetLogicalDriveStrings( 0, NULL ) + 1;
        lpDriveList = (PTSTR)ALLOC( dwListLen );
        GetLogicalDriveStrings( dwListLen, lpDriveList );
        lpDrive = lpDriveList;

        while (*lpDrive) {
            if (GetDriveType( lpDrive ) == DRIVE_FIXED)
            {
                if (GetDiskFreeSpace( lpDrive, &sectPerClust, &bytesPerSect, &freeClusters, &totalClusters ))
                {
                    freeDiskSpace = Int32x32To64( (sectPerClust * bytesPerSect), freeClusters );
                    if (freeDiskSpace > MINIMUM_DISK_SPACE)
                    {
                        if (pCreateMigwizDir( lpDrive ))
                        {
                            // We have a winner! Let's bail.
                            break;
                        }
                    }
                }
            }
            // Advance to the next drive in the drive list
            lpDrive = _tcschr( lpDrive, 0 ) + 1;
        }
        FREE(lpDriveList);
    }

    return g_lpszDestPath;
}

PTSTR
JoinText( PTSTR lpStr1, PTSTR lpStr2, TCHAR chSeparator )
{
    PTSTR lpResult;
    DWORD dwSize1;
    DWORD dwSize2;
    DWORD dwSize;
    BOOL fAddSep = TRUE;

    dwSize1 = lstrlen(lpStr1);
    if (lpStr1[dwSize1 - 1] == chSeparator)
    {
        fAddSep = FALSE;
    }

    dwSize2 = lstrlen(lpStr2);
    if (lpStr2[0] == chSeparator)
    {
        fAddSep = FALSE;
    }

    dwSize = dwSize1 + dwSize2 + (fAddSep ? 1 : 0);

    lpResult = (PTSTR)ALLOC((dwSize+1) * sizeof(TCHAR));
    if (lpResult)
    {
        lstrcpy( lpResult, lpStr1 );
        if (fAddSep)
        {
            lpResult[dwSize1] = chSeparator;
            dwSize1 += 1;
        }
        lstrcpy( lpResult+dwSize1, lpStr2 );
    }

    return lpResult;
}

PTSTR
GetResourceString( HINSTANCE hInstance, DWORD dwResID )
{
    TCHAR szTmpString[MAX_RESOURCE_LENGTH];
    DWORD dwStringLength;
    PTSTR lpszResultString = NULL;

    dwStringLength = LoadString( hInstance,
                                 dwResID,
                                 szTmpString,
                                 MAX_RESOURCE_LENGTH );
    if (dwStringLength > 0)
    {
        lpszResultString = (PTSTR)ALLOC( (dwStringLength+1) * sizeof(TCHAR) );
        if (lpszResultString)
        {
            lstrcpy( lpszResultString, szTmpString );
        }
    }

    return lpszResultString;
}

PSTR
GetResourceStringA( HINSTANCE hInstance, DWORD dwResID )
{
    CHAR szTmpString[MAX_RESOURCE_LENGTH];
    DWORD dwStringLength;
    PSTR lpszResultString = NULL;

    dwStringLength = LoadStringA( hInstance,
                                  dwResID,
                                  szTmpString,
                                  MAX_RESOURCE_LENGTH );
    if (dwStringLength > 0)
    {
        lpszResultString = (PSTR)ALLOC( (dwStringLength+1) * sizeof(CHAR) );
        if (lpszResultString)
        {
            lstrcpyA( lpszResultString, szTmpString );
        }
    }

    return lpszResultString;
}

PWSTR
GetResourceStringW( HINSTANCE hInstance, DWORD dwResID )
{
    WCHAR szTmpString[MAX_RESOURCE_LENGTH];
    DWORD dwStringLength;
    PWSTR lpszResultString = NULL;

    dwStringLength = LoadStringW( hInstance,
                                  dwResID,
                                  szTmpString,
                                  MAX_RESOURCE_LENGTH );
    if (dwStringLength > 0)
    {
        lpszResultString = (PWSTR)ALLOC( (dwStringLength+1) * sizeof(WCHAR) );
        if (lpszResultString)
        {
            lstrcpyW( lpszResultString, szTmpString );
        }
    }

    return lpszResultString;
}

VOID
UtilFree( VOID )
{
    if (g_lpszDestPath)
    {
        FREE( g_lpszDestPath );
        g_lpszDestPath = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\container.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  container.cpp
//
//      This file contains the complete implementation of an ActiveX
//      control container. This purpose of this container is to test
//      a single control being hosted.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <commctrl.h>
#include "container.h"

/**
 *  This method is the constructor for the Container object. 
 */
Container::Container()
{
    m_cRefs     = 1;
    m_hwnd      = NULL;
    m_punk      = NULL;

    memset(&m_rect, 0, sizeof(m_rect));
}

/** 
 *  This method is the destructor for the Container object.
 */
Container::~Container()
{
    if (m_punk)
    {
        m_punk->Release();
        m_punk=NULL;
    }
}

/**
 *  This method is called when the caller wants an interface pointer.
 *
 *  @param      riid        The interface being requested.
 *  @param      ppvObject   The resultant object pointer.
 *
 *  @return     HRESULT     S_OK, E_POINTER, E_NOINTERFACE
 */
STDMETHODIMP Container::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    if (!ppvObject)
        return E_POINTER;

    if (IsEqualIID(riid, IID_IOleClientSite))
        *ppvObject = (IOleClientSite *)this;
    else if (IsEqualIID(riid, IID_IOleInPlaceSite))
        *ppvObject = (IOleInPlaceSite *)this;
    else if (IsEqualIID(riid, IID_IOleInPlaceFrame))
        *ppvObject = (IOleInPlaceFrame *)this;
    else if (IsEqualIID(riid, IID_IOleInPlaceUIWindow))
        *ppvObject = (IOleInPlaceUIWindow *)this;
    else if (IsEqualIID(riid, IID_IOleControlSite))
        *ppvObject = (IOleControlSite *)this;
    else if (IsEqualIID(riid, IID_IOleWindow))
        *ppvObject = this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *ppvObject = (IDispatch *)this;
    else if (IsEqualIID(riid, IID_IUnknown))
        *ppvObject = this;
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

/**
 *  This method increments the current object count.
 *
 *  @return     ULONG       The new reference count.
 */
ULONG Container::AddRef(void)
{
    return ++m_cRefs;
}

/**
 *  This method decrements the object count and deletes if necessary.
 *
 *  @return     ULONG       Remaining ref count.
 */
ULONG Container::Release(void)
{
    if (--m_cRefs)
        return m_cRefs;

    delete this;
    return 0;
}

// ***********************************************************************
//  IOleClientSite
// ***********************************************************************

HRESULT Container::SaveObject()
{
    return E_NOTIMPL;
}

HRESULT Container::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER * ppMk)
{
    return E_NOTIMPL;
}

HRESULT Container::GetContainer(LPOLECONTAINER * ppContainer)
{
    return E_NOINTERFACE;
}

HRESULT Container::ShowObject()
{
    return S_OK;
}

HRESULT Container::OnShowWindow(BOOL fShow)
{
    return S_OK;
}

HRESULT Container::RequestNewObjectLayout()
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IOleWindow
// ***********************************************************************

HRESULT Container::GetWindow(HWND * lphwnd)
{
    if (!IsWindow(m_hwnd))
        return S_FALSE;

    *lphwnd = m_hwnd;
    return S_OK;
}

HRESULT Container::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IOleInPlaceSite
// ***********************************************************************

HRESULT Container::CanInPlaceActivate(void)
{
    return S_OK;
}

HRESULT Container::OnInPlaceActivate(void)
{
    return S_OK;
}

HRESULT Container::OnUIActivate(void)
{
    return S_OK;
}

HRESULT Container::GetWindowContext (IOleInPlaceFrame ** ppFrame, IOleInPlaceUIWindow ** ppIIPUIWin,
                                  LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    *ppFrame = (IOleInPlaceFrame *)this;
    *ppIIPUIWin = NULL;

    RECT rect;
    GetClientRect(m_hwnd, &rect);
    lprcPosRect->left       = 0;
    lprcPosRect->top        = 0;
    lprcPosRect->right      = rect.right;
    lprcPosRect->bottom     = rect.bottom;

    CopyRect(lprcClipRect, lprcPosRect);

    lpFrameInfo->cb             = sizeof(OLEINPLACEFRAMEINFO);
    lpFrameInfo->fMDIApp        = FALSE;
    lpFrameInfo->hwndFrame      = m_hwnd;
    lpFrameInfo->haccel         = 0;
    lpFrameInfo->cAccelEntries  = 0;

    (*ppFrame)->AddRef();
    return S_OK;
}

HRESULT Container::Scroll(SIZE scrollExtent)
{
    return E_NOTIMPL;
}

HRESULT Container::OnUIDeactivate(BOOL fUndoable)
{
    return E_NOTIMPL;
}

HRESULT Container::OnInPlaceDeactivate(void)
{
    return S_OK;
}

HRESULT Container::DiscardUndoState(void)
{
    return E_NOTIMPL;
}

HRESULT Container::DeactivateAndUndo(void)
{
    return E_NOTIMPL;
}

HRESULT Container::OnPosRectChange(LPCRECT lprcPosRect)
{
    return S_OK;
}

// ***********************************************************************
//  IOleInPlaceUIWindow
// ***********************************************************************

HRESULT Container::GetBorder(LPRECT lprectBorder)
{
    return E_NOTIMPL;
}

HRESULT Container::RequestBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    return E_NOTIMPL;
}

HRESULT Container::SetBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    return E_NOTIMPL;
}

HRESULT Container::SetActiveObject(IOleInPlaceActiveObject * pActiveObject, LPCOLESTR lpszObjName)
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IOleInPlaceFrame
// ***********************************************************************

HRESULT Container::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    return E_NOTIMPL;
}

HRESULT Container::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    return E_NOTIMPL;
}

HRESULT Container::RemoveMenus(HMENU hmenuShared)
{
    return E_NOTIMPL;
}

HRESULT Container::SetStatusText(LPCOLESTR pszStatusText)
{
    char status[MAX_PATH];              // ansi version of status text

    if (NULL == pszStatusText)
        return E_POINTER;

    WideCharToMultiByte(CP_ACP, 0, pszStatusText, -1, status, MAX_PATH, NULL, NULL);

    if (IsWindow(m_hwndStatus))
        SendMessage(m_hwndStatus, SB_SETTEXT, (WPARAM)0, (LPARAM)status);

    return (S_OK);
}

HRESULT Container::EnableModeless(BOOL fEnable)
{
    return E_NOTIMPL;
}

HRESULT Container::TranslateAccelerator(LPMSG lpmsg, WORD wID)
{
    return S_OK;
}

// ***********************************************************************
//  IOleControlSite
// ***********************************************************************

HRESULT Container::OnControlInfoChanged()
{
    return E_NOTIMPL;
}

HRESULT Container::LockInPlaceActive(BOOL fLock)
{
    return E_NOTIMPL;
}

HRESULT Container::GetExtendedControl(IDispatch **ppDisp)
{
    if (ppDisp == NULL)
        return E_INVALIDARG;

    *ppDisp = (IDispatch *)this;
    (*ppDisp)->AddRef();

    return S_OK;
}

HRESULT Container::TransformCoords(POINTL *pptlHimetric, POINTF *pptfContainer, DWORD dwFlags)
{
    return E_NOTIMPL;
}

HRESULT Container::TranslateAccelerator(LPMSG pMsg, DWORD grfModifiers)
{
    return S_FALSE;
}

HRESULT Container::OnFocus(BOOL fGotFocus)
{
    return E_NOTIMPL;
}

HRESULT Container::ShowPropertyFrame(void)
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IDispatch
// ***********************************************************************

HRESULT Container::GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)
{
    *rgdispid = DISPID_UNKNOWN;
    return DISP_E_UNKNOWNNAME;
}

HRESULT Container::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo)
{
    return E_NOTIMPL;
}

HRESULT Container::GetTypeInfoCount(unsigned int FAR * pctinfo)
{
    return E_NOTIMPL;
}

HRESULT Container::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR *pdispparams, VARIANT FAR *pvarResult, EXCEPINFO FAR * pexecinfo, unsigned int FAR *puArgErr)
{
    return DISP_E_MEMBERNOTFOUND;
}

// ***********************************************************************
//  Public (non-interface) Methods
// ***********************************************************************

/**
 *  This method will add an ActiveX control to the container. Note, for
 *  now, this container can only have one control.
 *
 *  @param  bstrClsid   The CLSID or PROGID of the control.
 *
 *  @return             No return value.
 */
void Container::add(BSTR bstrClsid)
{
    CLSID   clsid;          // CLSID of the control object
    HRESULT hr;             // return code

    CLSIDFromString(bstrClsid, &clsid);
    CoCreateInstance(clsid, 
                     NULL, 
                     CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, 
                     IID_IUnknown,
                     (PVOID *)&m_punk);

    if (!m_punk)
        return;

    IOleObject *pioo;
    hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
    if (FAILED(hr))
        return;

    pioo->SetClientSite(this);
    pioo->Release();

    IPersistStreamInit  *ppsi;
    hr = m_punk->QueryInterface(IID_IPersistStreamInit, (PVOID *)&ppsi);
    if (SUCCEEDED(hr))
    {
        ppsi->InitNew();
        ppsi->Release();
    }
}

/**
 *  This method will remove the control from the container.
 *
 *  @return             No return value.
 */
void Container::remove()
{
    if (!m_punk)
        return;

    HRESULT             hr;
    IOleObject          *pioo;
    IOleInPlaceObject   *pipo;

    hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
    if (SUCCEEDED(hr))
    {
        pioo->Close(OLECLOSE_NOSAVE);
        pioo->SetClientSite(NULL);
        pioo->Release();
    }

    hr = m_punk->QueryInterface(IID_IOleInPlaceObject, (PVOID *)&pipo);
    if (SUCCEEDED(hr))
    {
        pipo->UIDeactivate();
        pipo->InPlaceDeactivate();
        pipo->Release();
    }

    m_punk->Release();
    m_punk = NULL;
}

/**
 *  This method sets the parent window. This is used by the container
 *  so the control can parent itself.
 *
 *  @param  hwndParent  The parent window handle.
 *
 *  @return             No return value.
 */
void Container::setParent(HWND hwndParent)
{
    m_hwnd = hwndParent;
}

/**
 *  This method will set the location of the control.
 *  
 *  @param      x       The top left.
 *  @param      y       The top right.
 *  @param      width   The width of the control.
 *  @param      height  The height of the control.
 */
void Container::setLocation(int x, int y, int width, int height)
{
    m_rect.left     = x;
    m_rect.top      = y;
    m_rect.right    = width;
    m_rect.bottom   = height;

    if (!m_punk)
        return;

    HRESULT             hr;
    IOleInPlaceObject   *pipo;

    hr = m_punk->QueryInterface(IID_IOleInPlaceObject, (PVOID *)&pipo);
    if (FAILED(hr))
        return;

    pipo->SetObjectRects(&m_rect, &m_rect);
    pipo->Release();
}

/**
 *  Sets the visible state of the control.
 *
 *  @param  fVisible    TRUE=visible, FALSE=hidden
 *  @return             No return value.
 */
void Container::setVisible(BOOL fVisible)
{
    if (!m_punk)
        return;

    HRESULT     hr;
    IOleObject  *pioo;

    hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
    if (FAILED(hr))
        return;
    
    if (fVisible)
    {
        pioo->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, this, 0, m_hwnd, &m_rect);
        pioo->DoVerb(OLEIVERB_SHOW, NULL, this, 0, m_hwnd, &m_rect);
    }
    else
        pioo->DoVerb(OLEIVERB_HIDE, NULL, this, 0, m_hwnd, NULL);

    pioo->Release();
}

/**
 *  This sets the focus to the control (a.k.a. UIActivate)
 *
 *  @param  fFocus      TRUE=set, FALSE=remove
 *
 *  @return             No return value.
 */
void Container::setFocus(BOOL fFocus)
{
    if (!m_punk)
        return;

    HRESULT     hr;
    IOleObject  *pioo;

    if (fFocus)
    {
        hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
        if (FAILED(hr))
            return;

        pioo->DoVerb(OLEIVERB_UIACTIVATE, NULL, this, 0, m_hwnd, &m_rect);
        pioo->Release();
    }
}

/**
 *  If the container has an HWND for the status window (must be
 *  common control), then this method is used to tell the container.
 *
 *  @param  hwndStatus  Window handle of the status bar.
 *
 *  @return             No return value.
 */
void Container::setStatusWindow(HWND hwndStatus)
{
    m_hwndStatus = hwndStatus;
}

/**
 *  This method gives the control the opportunity to translate and use
 *  key strokes.
 *
 *  @param      msg     Key message.
 *
 *  @return             No return value.
 */
void Container::translateKey(MSG msg)
{
    if (!m_punk)
        return;

    HRESULT                 hr;
    IOleInPlaceActiveObject *pao;

    hr = m_punk->QueryInterface(IID_IOleInPlaceActiveObject, (PVOID *)&pao);
    if (FAILED(hr))
        return;

    pao->TranslateAccelerator(&msg);
    pao->Release();
}

/**
 *  Returns the IDispatch pointer of the contained control. Note, the
 *  caller is responsible for calling IDispatch::Release().
 *
 *  @return             Controls dispatch interface.
 */
IDispatch * Container::getDispatch()
{
    if (!m_punk)
        return NULL;

    HRESULT     hr;
    IDispatch   *pdisp;

    hr = m_punk->QueryInterface(IID_IDispatch, (PVOID *)&pdisp);
    return pdisp;
}

/**
 *  Returns the IUnknown interface pointer for the containd control. Note,
 *  the caller is responsible for calling IUnknown::Release().
 *
 *  @return             Controls unknown interface.
 */
IUnknown * Container::getUnknown()
{
    if (!m_punk)
        return NULL;

    m_punk->AddRef();
    return m_punk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\loadstate\loadstate.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    loadstate.c

Abstract:

    <abstract>

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "modules.h"
#include "trans.h"
#include <tlhelp32.h>
#include <shlobjp.h>
#ifdef DEBUG
#include <shellapi.h>
#endif

#include "logmsg.h"
#include "common.h"

#define DBG_LOADSTATE       "LoadState"

//
// Strings
//

// None

//
// Constants
//

#define LOG_VERBOSE_BIT  0x01
#define LOG_UNUSED_BIT   0x02   // for v1 compatibility, do not use
#define LOG_STATUS_BIT   0x04
#define LOG_DEBUGGER_BIT 0x08
#define LOG_UPDATE_BIT   0x10

#define LOADSTATE_LOAD      0x00000001
#define LOADSTATE_EXECUTE   0x00000002
#define LOADSTATE_COMPLETED 0x00000003

#define RETURN_SUCCESS     0
#define RETURN_FATAL_ERROR 1
#define RETURN_ERROR       2

//
// Macros
//

// None

//
// Types
//

typedef struct
{
    UINT cbSize;
    SHELLSTATE ss;
} REGSHELLSTATE, *PREGSHELLSTATE;

//
// Globals
//

PTSTR g_Explorer = NULL;
DWORD g_ReturnCode = ERROR_SUCCESS;
TCHAR g_JournalPath[MAX_PATH_PLUS_NUL];
BOOL g_Break;

#ifdef PRERELEASE
HANDLE g_CallbackEvent;
#endif

//
// Macro expansion list
//

#define REQUIRED_INFS       \
        DEFMAC(OSFILES,     TEXT("USMTDef.inf"))  \

//
// Private function prototypes
//

MESSAGECALLBACK pSaveMsgCallback;

PTSTR
pGetShellFolderPath (
    IN      INT Folder
    );

//
// Macro expansion definition
//

//
// This is the structure used for handling required infs
//
typedef struct {
    PCTSTR InfId;
    PCTSTR InfName;
} REQUIREDINF_STRUCT, *PREQUIREDINF_STRUCT;

//
// Declare a global array of required infs
//
#define DEFMAC(infid,infname) {TEXT(#infid),infname},
static REQUIREDINF_STRUCT g_RequiredInfs[] = {
                              REQUIRED_INFS
                              {NULL, NULL}
                              };
#undef DEFMAC

//
// Code
//

VOID
pCleanUpApp (
    VOID
    )
{
    IsmTerminate();

    if (g_JournalPath[0]) {
        DeleteFile (g_JournalPath);
        g_JournalPath[0] = 0;
    }

#ifdef PRERELEASE
    CloseHandle (g_CallbackEvent);
#endif
}


BOOL
WINAPI
CtrlCRoutine (
    IN      DWORD ControlSignal
    )
{
    PrintMsgOnConsole (MSG_EXITING);

    LOG ((LOG_WARNING, (PCSTR) MSG_TOOL_STOPPED));

    g_Break = TRUE;

    IsmSetCancel();
    while (IsmCurrentlyExecuting()) {
        Sleep (1000);
    }

    pCleanUpApp();

    printf ("\n");
    exit (1);
}


VOID
pHelpAndExit (
    VOID
    )
{
    PrintMsgOnConsole (MSG_HELP);

#ifdef PRERELEASE
    printf ("\nAdditional PRERELEASE options:\n\n"
            "/tf            Uses full transport instead of v1 transport\n"
            "/tc            Enable compression\n"
            "/ta            Enable automatic capability (for homenet transport)\n"
            "/ti:<tag>      Specify an identity tag for the homenet transprot\n"
            "               Default is user name\n"
            "/t:<name>      Specifies transport to use\n"
            "/r             Start in recovery mode\n"
            );
#endif

    UtTerminate ();
    exit (1);
}

VOID
pSwitchToClassicDesktop (
    IN      PCTSTR Args
    )
{
    HKEY key = NULL;
    TCHAR data[] = TEXT("0");

    //
    // The only thing that we need to do is to turn off:
    // HKCU\Software\Microsoft\Windows\CurrentVersion\ThemeManager [ThemeActive]
    //
    key = OpenRegKeyStr (TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager"));

    if (key) {

        RegSetValueEx (
            key,
            TEXT("ThemeActive"),
            0,
            REG_SZ,
            (PBYTE)data,
            sizeof (data)
            );

        CloseRegKey (key);
    }
}

VOID
pSwitchToClassicTaskBar (
    IN      PCTSTR Args
    )
{
    HKEY key = NULL;
    DWORD dataType;
    DWORD dataSize = 0;
    PBYTE data = NULL;
    PREGSHELLSTATE shellState = NULL;
    LONG result;

    //
    // The only thing that we need to do is to turn off the fStartPanelOn field in:
    // HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer [ShellState]
    //
    key = OpenRegKeyStr (TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"));

    if (key) {

        result = RegQueryValueEx (
                    key,
                    TEXT ("ShellState"),
                    NULL,
                    &dataType,
                    NULL,
                    &dataSize
                    );

        if ((result == ERROR_SUCCESS) || (result == ERROR_MORE_DATA)) {
            data = MemAllocUninit (dataSize);
            if (data) {
                result = RegQueryValueEx (
                            key,
                            TEXT ("ShellState"),
                            NULL,
                            &dataType,
                            data,
                            &dataSize
                            );
                if ((result == ERROR_SUCCESS) &&
                    (dataType == REG_BINARY) &&
                    (dataSize == sizeof (REGSHELLSTATE))
                    ) {
                    if (dataType == REG_BINARY) {
                        shellState = (PREGSHELLSTATE) data;
                        shellState->ss.fStartPanelOn = FALSE;
                        RegSetValueEx (
                            key,
                            TEXT("ShellState"),
                            0,
                            REG_BINARY,
                            (PBYTE)data,
                            dataSize
                            );
                    }
                }
                FreeAlloc (data);
            }
        }

        CloseRegKey (key);
    }
}

VOID
pRegisterFonts (
    IN      PCTSTR Args
    )
{
    WIN32_FIND_DATA findData;
    HANDLE findHandle = INVALID_HANDLE_VALUE;
    PTSTR fontDir = NULL;
    TCHAR fontPattern [MAX_PATH];
    //
    // Let's (re)register all the fonts (in case the user migrated some new ones).
    //
    fontDir = pGetShellFolderPath (CSIDL_FONTS);
    if (fontDir) {
        StringCopyTcharCount (fontPattern, fontDir, ARRAYSIZE (fontPattern) - 4);
        StringCat (fontPattern, TEXT("\\*.*"));
        findHandle = FindFirstFile (fontPattern, &findData);
        if (findHandle != INVALID_HANDLE_VALUE) {
            do {
                AddFontResource (findData.cFileName);
            } while (FindNextFile (findHandle, &findData));
            FindClose (findHandle);
        }
    }
}

BOOL
pLoadstateExecute (
    IN      PCTSTR ExecuteArgs
    )
{
    PCTSTR funcName = NULL;
    PCTSTR funcArgs = NULL;

    funcName = ExecuteArgs;
    if (!funcName || !(*funcName)) {
        return FALSE;
    }
    funcArgs = _tcschr (funcName, 0);
    if (funcArgs) {
        funcArgs ++;
        if (!(*funcArgs)) {
            funcArgs = NULL;
        }
    }
    // BUGBUG - temporary, make a macro expansion list out of it
    if (StringIMatch (funcName, TEXT("SwitchToClassicDesktop"))) {
        pSwitchToClassicDesktop (funcArgs);
    }
    if (StringIMatch (funcName, TEXT("SwitchToClassicTaskBar"))) {
        pSwitchToClassicTaskBar (funcArgs);
    }
    if (StringIMatch (funcName, TEXT("RegisterFonts"))) {
        pRegisterFonts (funcArgs);
    }
    return TRUE;
}

ULONG_PTR
pSaveMsgCallback (
    UINT Message,
    ULONG_PTR Arg
    )
{
#ifdef PRERELEASE
    PRMEDIA_EXTRADATA extraData;
#endif

    switch (Message) {

#ifdef PRERELEASE
    case TRANSPORTMESSAGE_READY_TO_CONNECT:
        {
            TCHAR msg[512];

            wsprintf (msg, TEXT("Do you want to connect to %s?"), Arg);
            if (MessageBox (NULL, msg, TEXT("Question For You"), MB_YESNO|MB_SYSTEMMODAL) == IDYES) {
                SetEvent (g_CallbackEvent);
                return APPRESPONSE_SUCCESS;
            }

            return APPRESPONSE_FAIL;
        }

    case TRANSPORTMESSAGE_RMEDIA_LOAD:
        extraData = (PRMEDIA_EXTRADATA) Arg;
        if (!extraData) {
            return (MessageBox (
                        NULL,
                        TEXT("Please insert the next media in your drive."),
                        TEXT("LoadState"),
                        MB_OKCANCEL
                        ) == IDOK);
        }
        if (extraData->MediaNumber == 1) {
            switch (extraData->LastError) {
            case RMEDIA_ERR_NOERROR:
                return TRUE;
            case RMEDIA_ERR_WRONGMEDIA:
                return (MessageBox (
                            NULL,
                            TEXT("You have inserted the wrong media.\n\nPlease insert the first media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_DISKFULL:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted does not have enough free space.\n\nPlease insert the first media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_WRITEPROTECT:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted is write protected.\n\nPlease insert the first media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_NOTREADY:
                return (MessageBox (
                            NULL,
                            TEXT("The drive is not ready for use. Please check the drive and make sure that a disk is inserted and that the drive door is closed."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_CRITICAL:
                return FALSE;
            default:
                return (MessageBox (
                            NULL,
                            TEXT("Your media is toast.\n\nPlease insert the first media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            }
        } else {
            switch (extraData->LastError) {
            case RMEDIA_ERR_NOERROR:
                return TRUE;
            case RMEDIA_ERR_WRONGMEDIA:
                return (MessageBox (
                            NULL,
                            TEXT("You have inserted the wrong media.\n\nPlease insert the next media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_DISKFULL:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted does not have enough free space.\n\nPlease insert the next media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_WRITEPROTECT:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted is write protected.\n\nPlease insert the next media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_NOTREADY:
                return (MessageBox (
                            NULL,
                            TEXT("The drive is not ready for use. Please check the drive and make sure that a disk is inserted and that the drive door is closed."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_CRITICAL:
                return FALSE;
            default:
                return (MessageBox (
                            NULL,
                            TEXT("Your media is toast.\n\nPlease insert the next media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            }
        }
#endif

    case ISMMESSAGE_EXECUTE_REFRESH:
        pLoadstateExecute ((PCTSTR) Arg);
        return APPRESPONSE_SUCCESS;

    default:
        break;
    }
    return FALSE;
}

BOOL
pIsUserAdmin (
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a member of the
    Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS expected to be
    able to open their own process and process token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    HANDLE token;
    DWORD bytesRequired;
    PTOKEN_GROUPS groups;
    BOOL b;
    DWORD i;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    PSID administratorsGroup;

    if (ISWIN9X()) {
        return TRUE;
    }

    //
    // Open the process token.
    //
    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &token)) {
        return FALSE;
    }

    b = FALSE;
    groups = NULL;

    //
    // Get group information.
    //
    if (!GetTokenInformation (token, TokenGroups, NULL, 0, &bytesRequired) &&
         GetLastError() == ERROR_INSUFFICIENT_BUFFER
         ) {

        groups = (PTOKEN_GROUPS) MemAllocUninit (bytesRequired);
        b = GetTokenInformation (token, TokenGroups, groups, bytesRequired, &bytesRequired);
    }

    if (b) {

        b = AllocateAndInitializeSid (
                &ntAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &administratorsGroup
                );

        if (b) {

            //
            // See if the user has the administrator group.
            //
            b = FALSE;
            for (i = 0 ; i < groups->GroupCount ; i++) {
                if (EqualSid (groups->Groups[i].Sid, administratorsGroup)) {
                    b = TRUE;
                    break;
                }
            }

            FreeSid (administratorsGroup);
        }
    }

    //
    // Clean up and return.
    //

    if (groups) {
        FreeAlloc (groups);
    }

    CloseHandle (token);

    return b;
}


VOID
pMyLogCallback (
    IN      PLOGARG LogArg
    )
{
    if (LogArg->Debug) {
        DEBUGDIRECT (LogArg->Type, LogArg->FormattedMessage);
    } else {
        if (StringIMatchA (LogArg->Type, LOG_ERROR)) {
            if (g_ReturnCode == RETURN_SUCCESS) {
                g_ReturnCode = RETURN_ERROR;
            }
        } else if (StringIMatchA (LogArg->Type, LOG_MODULE_ERROR) ||
                   StringIMatchA (LogArg->Type, LOG_FATAL_ERROR)) {
            g_ReturnCode = RETURN_FATAL_ERROR;
        }
        LOGDIRECT (LogArg->Type, LogArg->FormattedMessage);
    }
}

#ifdef DEBUG
VOID
pStopAndDisplayInfs (
    IN      PGROWBUFFER InputInfs,
    IN      BOOL Begin
    )
{
    MULTISZ_ENUM infEnum;

    if (MessageBox (
            NULL,
            TEXT("LoadState stopped. Do you want to display all loaded INFs?"),
            Begin?TEXT("LoadState-Begin"):TEXT("LoadState-End"),
            MB_YESNO
            ) == IDYES) {
        //
        // now let's open append all INF files and pass the HINF to
        // everybody.
        //
        if (EnumFirstMultiSz (&infEnum, (PCTSTR)InputInfs->Buf)) {
            do {
                ShellExecute (NULL, TEXT("open"), infEnum.CurrentString, NULL, NULL, SW_SHOWNORMAL);
            } while (EnumNextMultiSz (&infEnum));
        }
        MessageBox (NULL, TEXT("Press OK to continue..."), TEXT("LoadState-Begin"), MB_OK);
    }
}
#endif

BOOL
pOpenOrAppendInfFile (
    IN      HINF *InfHandle,
    IN      PCTSTR Filename
    )
{
    BOOL result = TRUE;

    if (*InfHandle == INVALID_HANDLE_VALUE) {
        *InfHandle = SetupOpenInfFile (Filename, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
        if (*InfHandle == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_FILE, Filename));
            result = FALSE;
        }
    } else {
        if (!SetupOpenAppendInfFile (Filename, *InfHandle, NULL)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_FILE, Filename));
            result = FALSE;
        }
    }
    return result;
}

PTSTR
pGetShellFolderPath (
    IN      INT Folder
    )
{
    PTSTR result = NULL;
    HRESULT hResult;
    BOOL b;
    LPITEMIDLIST localpidl = NULL;
    IMalloc *mallocFn;

    hResult = SHGetMalloc (&mallocFn);
    if (hResult != S_OK) {
        return NULL;
    }

    hResult = SHGetSpecialFolderLocation (NULL, Folder, &localpidl);

    if (hResult == S_OK) {

        result = (PTSTR) LocalAlloc (LPTR, MAX_PATH);
        if (result) {
             b = SHGetPathFromIDList (localpidl, result);

            if (b) {
                return result;
            }

            LocalFree (result);
        }
    }

    if (localpidl) {
        mallocFn->lpVtbl->Free (mallocFn, localpidl);
        localpidl = NULL;
    }

    return result;
}

VOID
__cdecl
_tmain (
    IN      INT Argc,
    IN      PCTSTR Argv[]
    )
{
    TCHAR appPath[MAX_PATH_PLUS_NUL];
    PCTSTR delayedCmd = NULL;
    TCHAR ismPath[MAX_PATH_PLUS_NUL];
    TCHAR infPath[MAX_PATH_PLUS_NUL];
    PTSTR iconLibRoot = NULL;
    TCHAR iconLibSrc[MAX_PATH] = TEXT("");
    TCHAR iconLibDest[MAX_PATH] = TEXT("");
    BOOL iconLibFound = FALSE;
    DWORD err;
    PTSTR p;
    MIG_TRANSPORTID transportId;
    MIG_TRANSPORTSTORAGEID transportStorageId;
    MULTISZ_ENUM infEnum;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_STRUCT infHandleStruct;
    MIG_OBJECTSTRINGHANDLE objectPattern;
    MIG_OBJECT_ENUM objectEnum;
    MULTISZ_ENUM e;
    DWORD appStatus;
    BOOL loadResult;
    BOOL storagePathIsValid = FALSE;
    BOOL terminateIsm = FALSE;
    BOOL logEnabled = FALSE;
    PCTSTR msg;
    PCTSTR argArray[1];
    BOOL fail;
    TOOLARGS args;

#ifdef PRERELEASE
    g_CallbackEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
#endif

    SET_RESETLOG();
    UtInitialize (NULL);

    SuppressAllLogPopups (TRUE);
    PrintMsgOnConsole (MSG_RUNNING);

    // initialize app journal path
    g_JournalPath [0] = 0;
    if (GetWindowsDirectory (g_JournalPath, ARRAYSIZE (g_JournalPath))) {
        StringCopy (AppendWack (g_JournalPath), TEXT("LOADSTATE.JRN"));
    }

    GetModuleFileName (NULL, appPath, ARRAYSIZE(appPath));
    delayedCmd = JoinText (appPath, TEXT(" /d"));
    p = _tcsrchr (appPath, TEXT('\\'));
    if (p) {
        *p = 0;
    }

    iconLibSrc [0] = 0;
    GetSystemDirectory (iconLibSrc, ARRAYSIZE(iconLibSrc));
    StringCopy (AppendWack (iconLibSrc), TEXT("usmt\\iconlib.dll"));

    //
    // Parse the command line
    //

    fail = TRUE;

    switch (ParseToolCmdLine (FALSE, &args, Argc, Argv)) {

    case PARSE_SUCCESS:
        fail = FALSE;
        break;

    case PARSE_MULTI_LOG:
        PrintMsgOnConsole (MSG_MULTI_LOG);
        g_ReturnCode = RETURN_FATAL_ERROR;
        goto END;

    case PARSE_BAD_LOG:
        argArray[0] = args.LogFile;
        msg = ParseMessageID (MSG_CANT_OPEN_LOG, argArray);
        if (msg) {
            _tprintf (TEXT("%s"), msg);
            FreeStringResource (msg);
        }

        g_ReturnCode = RETURN_FATAL_ERROR;
        goto END;

    default:
        break;
    }

    if (fail) {
        pHelpAndExit();
    }

#ifdef DEBUG
    {
        if (DoesFileExist (TEXT("C:\\LOADSTATE.BEGIN"))) {
            pStopAndDisplayInfs (&args.InputInf, TRUE);
        }
    }
#endif

    LogReInit (NULL, NULL, args.LogFile ? args.LogFile : TEXT("loadstate.log"), NULL);
    logEnabled = TRUE;

    //
    // Check requirements
    //

    if (args.BadInfs.End || args.MultiInfs.End) {
        SetLastError (ERROR_BAD_COMMAND);

        if (EnumFirstMultiSz (&e, (PCTSTR) args.BadInfs.Buf)) {
            do {
                LOG ((LOG_ERROR, (PCSTR) MSG_INF_FILE_NOT_FOUND, e.CurrentString));
            } while (EnumNextMultiSz (&e));
        }

        if (EnumFirstMultiSz (&e, (PCTSTR) args.MultiInfs.Buf)) {
            do {
                LOG ((LOG_ERROR, (PCSTR) MSG_INF_SPECIFIED_MORE_THAN_ONE, e.CurrentString));
            } while (EnumNextMultiSz (&e));
        }

        g_ReturnCode = RETURN_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CMD_LINE_ERROR));
        goto END;
    }

    if (!GetFilePath (TEXT("migism.inf"), ismPath, ARRAYSIZE(ismPath))) {
        g_ReturnCode = RETURN_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_ISM_INF_MISSING));
        goto END;
    }

    if (ISWIN9X()) {
        g_ReturnCode = RETURN_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_NT_REQUIRED));
        goto END;
    }

    if (!pIsUserAdmin() && !args.DelayedOpsOn) {
        g_ReturnCode = RETURN_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_ADMIN_REQUIRED));
        goto END;
    }

    //
    // Initialize ISM
    //

    if (!IsmInitialize (ismPath, pSaveMsgCallback, pMyLogCallback)) {
        g_ReturnCode = RETURN_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_START_ISM));
        goto END;
    }

    terminateIsm = TRUE;
    SetLogVerbosity (args.VerboseLevel);

    SetConsoleCtrlHandler (CtrlCRoutine, TRUE);

    // upload environment variables
    UploadEnvVars (PLATFORM_DESTINATION);

    // we will try to copy iconlib.dll from our directory into "Common AppData" directory
    // If we don't succeed, we will not set the S_ENV_ICONLIB env variable

    iconLibFound = FALSE;

    iconLibRoot = pGetShellFolderPath (CSIDL_COMMON_APPDATA);
    if (iconLibRoot) {
        __try {
            StringCopy (iconLibDest, iconLibRoot);
            StringCopy (AppendWack (iconLibDest), TEXT("Microsoft"));
            if (!CreateDirectory (iconLibDest, NULL)) {
                err = GetLastError ();
                if (err != ERROR_ALREADY_EXISTS) {
                    __leave;
                }
            }
            StringCopy (AppendWack (iconLibDest), TEXT("USMT"));
            if (!CreateDirectory (iconLibDest, NULL)) {
                err = GetLastError ();
                if (err != ERROR_ALREADY_EXISTS) {
                    __leave;
                }
            }
            StringCopy (AppendWack (iconLibDest), TEXT("iconlib.dll"));
            if (!CopyFile (iconLibSrc, iconLibDest, TRUE)) {
                err = GetLastError ();
                if (err != ERROR_FILE_EXISTS) {
                    __leave;
                }
            }
            iconLibFound = TRUE;
        }
        __finally {
            LocalFree (iconLibRoot);
            iconLibRoot = NULL;
        }
    }

    // Set the icon lib data
    if (iconLibFound) {
        IsmSetEnvironmentString (PLATFORM_DESTINATION, NULL, S_ENV_ICONLIB, iconLibDest);
    }

    infHandle = InitRequiredInfs (appPath, (PCSTR) MSG_CANT_OPEN_REQUIRED_FILE);

    if (infHandle != INVALID_HANDLE_VALUE) {
        infHandleStruct.Type = ENVENTRY_BINARY;
        infHandleStruct.EnvBinaryData = (PVOID)(&infHandle);
        infHandleStruct.EnvBinaryDataSize = sizeof (HINF);
        IsmSetEnvironmentValue (PLATFORM_DESTINATION, NULL, S_GLOBAL_INF_HANDLE, &infHandleStruct);
    }

    if (args.UserOn) {
        IsmSetEnvironmentFlag (PLATFORM_DESTINATION, NULL, S_ENV_HKCU_V1);
        IsmSetEnvironmentFlag (PLATFORM_DESTINATION, NULL, S_ENV_HKCU_ON);
    }

    if (args.FilesOn) {
        IsmSetEnvironmentFlag (PLATFORM_DESTINATION, NULL, S_ENV_ALL_FILES);
    }

    IsmSetPlatform (PLATFORM_DESTINATION);

    if (!args.CurrentUser) {
        IsmSetEnvironmentFlag (PLATFORM_DESTINATION, NULL, S_REQUIRE_DOMAIN_USER);
        IsmSetEnvironmentFlag (PLATFORM_DESTINATION, NULL, S_ENV_CREATE_USER);
    }

    //
    // Start ETM modules
    //

    if (!IsmStartEtmModules ()) {
        if (!IsmCheckCancel()) {
            LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_START_ETMS));
        }
        goto END;
    }

    if (args.DelayedOpsOn) {

        appStatus = ReadAppStatus (g_JournalPath);

        if ((appStatus != LOADSTATE_COMPLETED) &&
            (appStatus != LOADSTATE_EXECUTE) &&
            (appStatus != 0)
            ) {

            // unknown state, just cleanup the delayed ops journal
            IsmExecute (EXECUTETYPE_DELAYEDOPERATIONSCLEANUP);

        } else {

            IsmSetRollbackJournalType (FALSE);
            if (appStatus == LOADSTATE_EXECUTE) {
                IsmRollback ();
            }
            // write the app status
            WriteAppStatus (g_JournalPath, LOADSTATE_EXECUTE);
            IsmExecute (EXECUTETYPE_DELAYEDOPERATIONS);
            // write the app status
            WriteAppStatus (g_JournalPath, LOADSTATE_COMPLETED);
        }

    } else {

        //
        // Initialize transport
        //

        if (!IsmStartTransport ()) {
            if (!IsmCheckCancel()) {
                LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_START_TRANS));
            }
            goto END;
        }

        transportStorageId = IsmRegisterTransport (args.TransportName);

        if (args.FullTransport) {
            transportId = IsmSelectTransport (transportStorageId, TRANSPORTTYPE_FULL, args.Capabilities);
        } else {
            transportId = IsmSelectTransport (transportStorageId, TRANSPORTTYPE_LIGHT, args.Capabilities);
        }

        if (!transportId) {
            LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_TRANSPORT_UNAVAILABLE));
            goto END;
        }

#ifdef PRERELEASE

        IsmSetEnvironmentString (PLATFORM_DESTINATION, NULL, TRANSPORT_ENVVAR_HOMENET_TAG, args.Tag);

#endif

        if (!IsmSetTransportStorage (
                PLATFORM_DESTINATION,
                transportId,
                transportStorageId,
                args.Capabilities,
                args.StoragePath,
                &storagePathIsValid,
                NULL
                ) ||
                storagePathIsValid == FALSE) {
            if (!IsmCheckCancel()) {
                LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_TRANSPORT_STORAGE_INVALID, args.StoragePath));
            }
            goto END;
        }

#ifdef PRERELEASE
        if (args.Capabilities & CAPABILITY_AUTOMATED) {
            WaitForSingleObject (g_CallbackEvent, INFINITE);
        }
#endif

        appStatus = ReadAppStatus (g_JournalPath);

        if (appStatus != LOADSTATE_COMPLETED) {

            // if we need to, call IsmRollback
            if (appStatus == LOADSTATE_EXECUTE) {

                IsmRollback ();

                appStatus = LOADSTATE_LOAD;
            }

#ifdef PRERELEASE
            if (!args.Recovery) {
#endif
                // write the app status
                WriteAppStatus (g_JournalPath, LOADSTATE_LOAD);

                //
                // Recover the state
                //

                if (appStatus == LOADSTATE_LOAD) {
                    loadResult = IsmResumeLoad ();
                    if (!loadResult) {
                        loadResult = IsmLoad ();
                    }
                } else {
                    loadResult = IsmLoad ();
                }

                if (loadResult) {

                    // Load INFs that were specified in scanstate

                    if (!args.NoScanStateInfs) {
                        objectPattern = IsmCreateSimpleObjectPattern (TEXT("External"), FALSE, S_INF_OBJECT_NAME TEXT("*"), TRUE);

                        if (IsmEnumFirstSourceObject(&objectEnum, MIG_DATA_TYPE, objectPattern)) {
                            do {
                                if (IsmGetControlFile (objectEnum.ObjectTypeId, objectEnum.ObjectName, infPath)) {
                                    IsmAppendEnvironmentMultiSz (
                                        PLATFORM_DESTINATION,
                                        NULL,
                                        S_INF_FILE_MULTISZ,
                                        infPath
                                        );
                                    pOpenOrAppendInfFile (&infHandle, infPath);
                                }
                            } while (IsmEnumNextObject (&objectEnum));
                        }
                        IsmDestroyObjectHandle (objectPattern);
                    }

                    if (args.InputInf.Buf) {
                        //
                        // now let's open append all INF files and pass the HINF to
                        // everybody.
                        //
                        if (EnumFirstMultiSz (&infEnum, (PCTSTR)args.InputInf.Buf)) {
                            do {
                                IsmAppendEnvironmentMultiSz (
                                    PLATFORM_DESTINATION,
                                    NULL,
                                    S_INF_FILE_MULTISZ,
                                    infEnum.CurrentString
                                    );
                                pOpenOrAppendInfFile (&infHandle, infEnum.CurrentString);
                            } while (EnumNextMultiSz (&infEnum));
                        }
                    }

                    if (!args.FullTransport) {

                        //
                        // Execute the preparsing to populate components
                        //

                        if (IsmExecute (EXECUTETYPE_EXECUTESOURCE_PARSING)) {

                            IsmSelectMasterGroup (MASTERGROUP_ALL, TRUE);

                            if (!args.SystemOn) {
                                IsmSelectMasterGroup (MASTERGROUP_SYSTEM, FALSE);
                                IsmSelectMasterGroup (MASTERGROUP_USER, FALSE);
                                IsmSelectMasterGroup (MASTERGROUP_APP, FALSE);
                            }

                            SelectComponentsViaInf (infHandle);

                            //
                            // Execute data gather
                            //

                            if (!IsmExecute (EXECUTETYPE_EXECUTESOURCE)) {
                                if (!IsmCheckCancel()) {
                                    LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_EXECUTE_SOURCE));
                                }
                            }

                        } else {
                            if (!IsmCheckCancel()) {
                                LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_EXECUTE_SOURCE));
                            }
                        }
                    }

                    //
                    // Apply saved state
                    //

                    // write the app status
                    WriteAppStatus (g_JournalPath, LOADSTATE_EXECUTE);

                    IsmSetDelayedOperationsCommand (delayedCmd);

                    if (!IsmExecute (EXECUTETYPE_EXECUTEDESTINATION)) {
                        if (!IsmCheckCancel()) {
                            LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_EXECUTE_DEST));
                        }
                    }

                } else {
                    LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_FIND_SAVED_STATE));
                }

#ifdef PRERELEASE
            }
#endif
            // write the app status
            WriteAppStatus (g_JournalPath, LOADSTATE_COMPLETED);
        }
    }

    //
    // We're done!
    //

    SetupCloseInfFile (infHandle);

#ifdef DEBUG
    {
        if (DoesFileExist (TEXT("C:\\LOADSTATE.END"))) {
            pStopAndDisplayInfs (&args.InputInf, FALSE);
        }
    }
#endif

END:
    if (terminateIsm) {
        if (!g_Break) {
            pCleanUpApp();
        }
    }

    if (delayedCmd) {
        FreeText (delayedCmd);
        delayedCmd = NULL;
    }
    GbFree (&args.InputInf);
    GbFree (&args.BadInfs);
    GbFree (&args.MultiInfs);

    if (!g_Break) {
        if (g_ReturnCode != RETURN_SUCCESS) {
            if (logEnabled) {
                PrintMsgOnConsole (MSG_FAILED_WITH_LOG);
            } else {
                PrintMsgOnConsole (MSG_FAILED_NO_LOG);
            }
        } else {
            PrintMsgOnConsole (MSG_SUCCESS);
        }
    }

    UtTerminate ();

    while (g_Break) {
        // infinite loop, because we'll get terminated in the ctrl+c handler
        Sleep (50);
    }

    exit (g_ReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\cowsite.cpp ===
#include <objbase.h>
#pragma hdrstop

#include "cowsite.h"

void IUnknown_Set(IUnknown ** ppunk, IUnknown * punk)
{
    if (*ppunk)
        (*ppunk)->Release();

    *ppunk = punk;
    if (punk)
        punk->AddRef();
}

HRESULT CObjectWithSite::SetSite(IUnknown *punkSite)
{
    IUnknown_Set(&_punkSite, punkSite);
    return S_OK;
}

HRESULT CObjectWithSite::GetSite(REFIID riid, void **ppvSite)
{
    if (_punkSite)
        return _punkSite->QueryInterface(riid, ppvSite);

    *ppvSite = NULL;
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\cowsite.h ===
#ifndef _COWSITE_H_
#define _COWSITE_H_

#include <ocidl.h>

#define ATOMICRELEASE(p)   \
   {                       \
      IUnknown *pFoo = (IUnknown *)p;  \
      p = NULL;            \
      if (pFoo)            \
         pFoo->Release();  \
   }

class CObjectWithSite : public IObjectWithSite
{
public:
    CObjectWithSite()  {_punkSite = NULL;};
    virtual ~CObjectWithSite() {ATOMICRELEASE(_punkSite);}

    //*** IUnknown ****
    // (client must provide!)

    //*** IObjectWithSite ***
    STDMETHOD(SetSite)(IUnknown *punkSite);
    STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

protected:
    IUnknown*   _punkSite;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\iface.h ===
//
// Iface.h - 
//    Declarations of interfaces, IIDs, and CLSID
//    shared by the client and the component.
//
//
// Declaration of GUIDs for interfaces and component.
//   These constants are defined in GUIDs.cpp.
//
extern "C" const CLSID CLSID_MigWizEngine ;

const DISPID_GETREMOVECOUNT =       1001;
const DISPID_GETREMOVEDRIVE =       1002;
const DISPID_GETREMOVEDRIVEPRETTY = 1003;
const DISPID_CREATETOOLDISK =       1004;
const DISPID_CANCELTOOLDISK =       1005;
const DISPID_APPLYSETTINGS  =       1006;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\guids.cpp ===
//
// GUIDs.cpp
//   - Defines all IIDs and CLSIDs for the client and the component.
//     The declaration of these GUIDs is in Iface.h
//
#include <objbase.h>

// {E7562536-2D53-4f63-A749-84F7D4FC93E8}
extern "C" const CLSID CLSID_MigWizEngine = 
{ 0xe7562536, 0x2d53, 0x4f63, { 0xa7, 0x49, 0x84, 0xf7, 0xd4, 0xfc, 0x93, 0xe8 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\container.h ===
//////////////////////////////////////////////////////////////////////////
//
//  container.h
//
//      This file contains the complete class specification of an ActiveX
//      control container. This purpose of this container is to test
//      a single control being hosted.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#ifndef _CONTAINER_H_
#define _CONTAINER_H_

#include <ocidl.h>

class Container : public IOleClientSite, 
                  public IOleInPlaceSite,
                  public IOleInPlaceFrame,
                  public IOleControlSite,
                  public IDispatch
{
    private:
        ULONG       m_cRefs;        // ref count
        HWND        m_hwnd;         // window handle of the container
        HWND        m_hwndStatus;   // status window handle
        IUnknown    *m_punk;        // IUnknown of contained object
        RECT        m_rect;         // size of control

    public:
        Container();
        ~Container();

    public:
        // *** IUnknown Methods ***
        STDMETHOD(QueryInterface)(REFIID riid, PVOID *ppvObject);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        // *** IOleClientSite Methods ***
        STDMETHOD (SaveObject)();
        STDMETHOD (GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER *ppMk);
        STDMETHOD (GetContainer)(LPOLECONTAINER *ppContainer);
        STDMETHOD (ShowObject)();
        STDMETHOD (OnShowWindow)(BOOL fShow);
        STDMETHOD (RequestNewObjectLayout)();

        // *** IOleWindow Methods ***
        STDMETHOD (GetWindow) (HWND * phwnd);
        STDMETHOD (ContextSensitiveHelp) (BOOL fEnterMode);

        // *** IOleInPlaceSite Methods ***
        STDMETHOD (CanInPlaceActivate) (void);
        STDMETHOD (OnInPlaceActivate) (void);
        STDMETHOD (OnUIActivate) (void);
        STDMETHOD (GetWindowContext) (IOleInPlaceFrame ** ppFrame, IOleInPlaceUIWindow ** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
        STDMETHOD (Scroll) (SIZE scrollExtent);
        STDMETHOD (OnUIDeactivate) (BOOL fUndoable);
        STDMETHOD (OnInPlaceDeactivate) (void);
        STDMETHOD (DiscardUndoState) (void);
        STDMETHOD (DeactivateAndUndo) (void);
        STDMETHOD (OnPosRectChange) (LPCRECT lprcPosRect);

        // *** IOleInPlaceUIWindow Methods ***
        STDMETHOD (GetBorder)(LPRECT lprectBorder);
        STDMETHOD (RequestBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
        STDMETHOD (SetBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
        STDMETHOD (SetActiveObject)(IOleInPlaceActiveObject * pActiveObject,
                                    LPCOLESTR lpszObjName);

        // *** IOleInPlaceFrame Methods ***
        STDMETHOD (InsertMenus)(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
        STDMETHOD (SetMenu)(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
        STDMETHOD (RemoveMenus)(HMENU hmenuShared);
        STDMETHOD (SetStatusText)(LPCOLESTR pszStatusText);
        STDMETHOD (EnableModeless)(BOOL fEnable);
        STDMETHOD (TranslateAccelerator)(LPMSG lpmsg, WORD wID);

        // *** IOleControlSite Methods ***
        STDMETHOD (OnControlInfoChanged)(void);
        STDMETHOD (LockInPlaceActive)(BOOL fLock);
        STDMETHOD (GetExtendedControl)(IDispatch **ppDisp);
        STDMETHOD (TransformCoords)(POINTL *pptlHimetric, POINTF *pptfContainer, DWORD dwFlags);
        STDMETHOD (TranslateAccelerator)(LPMSG pMsg, DWORD grfModifiers);
        STDMETHOD (OnFocus)(BOOL fGotFocus);
        STDMETHOD (ShowPropertyFrame)(void);

        // *** IDispatch Methods ***
        STDMETHOD (GetIDsOfNames)(REFIID riid, OLECHAR FAR* FAR* rgszNames,	unsigned int cNames, LCID lcid,	DISPID FAR* rgdispid);
        STDMETHOD (GetTypeInfo)(unsigned int itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo);
        STDMETHOD (GetTypeInfoCount)(unsigned int FAR * pctinfo);
        STDMETHOD (Invoke)(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR *pdispparams, VARIANT FAR *pvarResult, EXCEPINFO FAR * pexecinfo, unsigned int FAR *puArgErr);

    public:
        void add(BSTR clsid);
        void remove();
        void setParent(HWND hwndParent);
        void setLocation(int x, int y, int width, int height);
        void setVisible(BOOL fVisible);
        void setFocus(BOOL fFocus);
        void setStatusWindow(HWND hwndStatus);
        void translateKey(MSG msg);
        IDispatch *getDispatch();
        IUnknown * getUnknown();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\dll.cpp ===
//
// dll.cpp
//
#include <iostream.h>
#include <objbase.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shlobj.h>

#include "cowsite.h"

#include "Iface.h"      // Interface declarations
#include "Registry.h"   // Registry helper functions
#include "migutil.h"
#include "migeng.h"
#include "migfact.h"
#include "migtask.h"
#include "migoobe.h"

///////////////////////////////////////////////////////////
//
// Global variables
//
HMODULE g_hModule = NULL;   // DLL module handle
static long g_cComponents = 0;     // Count of active components

// Friendly name of component
const char g_szFriendlyName[] = "Migration Wizard Engine";

// Version-independent ProgID
const char g_szVerIndProgID[] = "MigWiz";

// ProgID
const char g_szProgID[] = "MigWiz.1";

///////////////////////////////////////////////////////////
//
// Exported functions
//

STDAPI DllAddRef()
{
    InterlockedIncrement(&g_cComponents);
    return S_OK;
}

STDAPI DllRelease()
{
    InterlockedDecrement(&g_cComponents);
    return S_OK;
}

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if (g_cComponents == 0)
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    HRESULT hres;

    DllAddRef();
    if (IsEqualIID(clsid, CLSID_MigWizEngine))
    {
        hres = CMigFactory_Create(clsid, iid, ppv);
    }
    else
    {
        *ppv = NULL;
        hres = CLASS_E_CLASSNOTAVAILABLE;
    }

    DllRelease();
    return hres;
}

//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_MigWizEngine,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_MigWizEngine,
                            g_szVerIndProgID,
                            g_szProgID);
}


///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule;
        DisableThreadLibraryCalls((HMODULE)hModule);       // PERF: makes faster because we don't get thread msgs
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\main.cpp ===
#include "migwiz.h"
#include "migutil.h"
#include "resource.h"
#include "container.h"
#include <string.h>
#include <tchar.h>

typedef struct _THREADSTARTUPINFO
{
    HWND hWnd;
    HINSTANCE hInstance;
    LPTSTR lpCmdLine;
} THREADSTARTUPINFO, *LPTHREADSTARTUPINFO;

#define WINDOWCLASS TEXT("USMTCobraApp")
#define WINDOWNAME  TEXT("Migwiz")

#define ANOTHERUSER_RESLEN 100

BOOL g_ConfirmedLogOff = FALSE;
BOOL g_ConfirmedReboot = FALSE;
static HANDLE g_hThread = NULL;
static DWORD g_dwThreadId = 0;

Container *g_WebContainer = NULL;

DWORD
WINAPI
MigwizThread(
    IN      LPVOID lpParameter
    )
{
    HRESULT hr;
    TCHAR szAppPath[MAX_PATH] = TEXT("");
    TCHAR* pszAppPathOffset;

    CoInitialize(NULL);
    OleInitialize(NULL);

    GetModuleFileName (NULL, szAppPath, ARRAYSIZE(szAppPath));
    pszAppPathOffset = _tcsrchr (szAppPath, TEXT('\\'));
    if (pszAppPathOffset) {
        *pszAppPathOffset = 0;
        SetCurrentDirectory (szAppPath);
    }

    MigrationWizard* pMigWiz = new MigrationWizard();

    if (pMigWiz)
    {
        LPTSTR lpszUsername = NULL;
        LPTSTR lpszCmdLine = ((LPTHREADSTARTUPINFO)lpParameter)->lpCmdLine;

        if (lpszCmdLine && 0 == _tcsncmp (lpszCmdLine, TEXT("/t:"), 3))
        {
            // BUGBUG: need to make this more stable
            lpszUsername = lpszCmdLine + 3;
        }

        hr = pMigWiz->Init(((LPTHREADSTARTUPINFO)lpParameter)->hInstance, lpszUsername);

        if (SUCCEEDED(hr))
        {
            pMigWiz->Execute();
        }

        // ISSUE: leak
        //delete pMigWiz;
    }

    SendMessage (((LPTHREADSTARTUPINFO)lpParameter)->hWnd, WM_USER_THREAD_COMPLETE, NULL, NULL);

    OleUninitialize();
    CoUninitialize();

    return 0;
}

BOOL
CALLBACK
_SetMigwizActive(
    IN      HWND hWnd,
    IN      LPARAM lParam
    )
{
    SetForegroundWindow( hWnd );
    return FALSE;
}

LRESULT CALLBACK WndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    switch (message)
    {
    case WM_ACTIVATE:
        if (g_hThread != NULL && g_dwThreadId != 0)
        {
            EnumThreadWindows( g_dwThreadId, _SetMigwizActive, (LPARAM)NULL );
        }
        break;
    case WM_USER_THREAD_COMPLETE:
        CloseHandle( g_hThread );
        PostQuitMessage( 0 );
        break;
    default:
        return DefWindowProc( hWnd, message, wParam, lParam );
    }
    return 0;
}

LRESULT CALLBACK WebHostProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    switch (message)
    {
        case WM_SETFOCUS:
            if (g_WebContainer) {
                g_WebContainer->setFocus(TRUE);
                return 0;
            }
            break;
    }
    return DefWindowProc(hWnd, message, wParam, lParam);
}

INT
WINAPI
WinMain(
    IN      HINSTANCE    hInstance,
    IN      HINSTANCE    hPrevInstance,
    IN      LPSTR        lpszCmdLine,
    IN      INT          nCmdShow)
{
    WNDCLASSEX wcx;
    MSG msg;
    HANDLE hMutex = NULL;
    OSVERSIONINFO vi;

    HWND hwnd;
    DWORD dwResult = 0;
    THREADSTARTUPINFO StartInfo;

    PSID pSid = NULL;

    PTSTR commandLine = NULL;

#ifdef UNICODE
    commandLine = _ConvertToUnicode (CP_ACP, lpszCmdLine);
#else
    commandLine = lpszCmdLine;
#endif

    hwnd = FindWindow (WINDOWCLASS, WINDOWNAME);
    if (hwnd)
    {
        SetForegroundWindow (hwnd);
        goto END;
    }

    CoInitialize(NULL);
    OleInitialize(NULL);

    vi.dwOSVersionInfoSize = sizeof (vi);

    if (GetVersionEx (&vi) &&
        vi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
        vi.dwMajorVersion > 4)
    {
        hMutex = CreateMutex (NULL, TRUE, TEXT("Global\\migwiz.mutex"));
    }
    else
    {
        hMutex = CreateMutex (NULL, TRUE, TEXT("migwiz.mutex"));
    }

    if ((hMutex && GetLastError() == ERROR_ALREADY_EXISTS) ||
        (!hMutex && GetLastError() == ERROR_ACCESS_DENIED))
    {
        TCHAR szTmpBuf[512];
        PVOID lpBuf = NULL;
        LPTSTR lpUsername = NULL;

        lpUsername = (LPTSTR)LocalAlloc(LPTR, ANOTHERUSER_RESLEN * sizeof (TCHAR));
        LoadString (hInstance, IDS_ANOTHER_USER, lpUsername, ANOTHERUSER_RESLEN);

        LoadString (hInstance, IDS_ALREADY_RUN_USER, szTmpBuf, ARRAYSIZE(szTmpBuf));
        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       szTmpBuf,
                       0,
                       0,
                       (LPTSTR)&lpBuf,
                       0,
                       (va_list *)(&lpUsername));
        MessageBox (NULL, (LPCTSTR)lpBuf, NULL, MB_OK);
        LocalFree (lpBuf);
        LocalFree (lpUsername);

        goto END;
    }

    ZeroMemory (&wcx, sizeof (WNDCLASSEX));
    wcx.cbSize = sizeof (WNDCLASSEX);
    wcx.hInstance = hInstance;
    wcx.lpszClassName = WINDOWCLASS;
    wcx.lpfnWndProc = (WNDPROC)WndProc;
    if (!RegisterClassEx (&wcx))
    {
        dwResult = GetLastError();
        goto END;
    }

    ZeroMemory (&wcx, sizeof (WNDCLASSEX));
    wcx.cbSize = sizeof (WNDCLASSEX);
    wcx.hInstance = hInstance;
    wcx.lpszClassName = TEXT("WebHost");
    wcx.lpfnWndProc = (WNDPROC)WebHostProc;
    if (!RegisterClassEx (&wcx))
    {
        dwResult = GetLastError();
        goto END;
    }

    hwnd = CreateWindow (WINDOWCLASS,
                         WINDOWNAME,
                         WS_OVERLAPPEDWINDOW,
                         CW_USEDEFAULT,
                         CW_USEDEFAULT,
                         400, 300,
                         NULL, NULL,
                         hInstance,
                         NULL);
    if (!hwnd)
    {
        dwResult = GetLastError();
        goto END;
    }

    StartInfo.hWnd = hwnd;
    StartInfo.hInstance = hInstance;
    StartInfo.lpCmdLine = commandLine;

    g_hThread = CreateThread( NULL,
                              0,
                              MigwizThread,
                              (PVOID)&StartInfo,
                              0,
                              &g_dwThreadId );
    if (g_hThread == NULL)
    {
        dwResult = GetLastError();
        goto END;
    }

    // Main message loop:
    while (GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

END:
    OleUninitialize();
    CoUninitialize();

    if (hMutex)
    {
        CloseHandle (hMutex);
    }

    if (pSid)
    {
        LocalFree (pSid);
    }

#ifdef UNICODE
    if (commandLine)
    {
        LocalFree (commandLine);
    }
#endif

    if (g_ConfirmedReboot) {
        HANDLE token;
        TOKEN_PRIVILEGES newPrivileges;
        LUID luid;

        if (OpenProcessToken (GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &token)) {
            if (LookupPrivilegeValue (NULL, SE_SHUTDOWN_NAME, &luid)) {

                newPrivileges.PrivilegeCount = 1;
                newPrivileges.Privileges[0].Luid = luid;
                newPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                if (AdjustTokenPrivileges(
                        token,
                        FALSE,
                        &newPrivileges,
                        0,
                        NULL,
                        NULL
                        )) {
                    ExitWindowsEx (EWX_REBOOT, 0);
                }
            }
            CloseHandle (token);
        }
    } else if (g_ConfirmedLogOff) {
        ExitWindowsEx (EWX_LOGOFF, 0);
    }

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\migfact.cpp ===
/*****************************************************************************
 *
 *    migfact.cpp - IClassFactory interface
 *
 *****************************************************************************/
// includes

#include <iostream.h>
#include <objbase.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shlobj.h>

#include "cowsite.h"

#include "Iface.h"      // Interface declarations
#include "Registry.h"   // Registry helper functions
#include "migutil.h"
#include "migeng.h"
#include "migtask.h"
#include "migoobe.h"

/*****************************************************************************/
// macros

#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))

/*****************************************************************************/
// extern methods

STDAPI DllAddRef();
STDAPI DllRelease();

/*****************************************************************************/
// function prototypesb

HRESULT CMigWizEngine_Create(IID riid, LPVOID* ppvObj);

/*****************************************************************************
 *
 *    CMigFactory
 *
 *
 *****************************************************************************/

class CMigFactory       : public IClassFactory
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IClassFactory ***
    virtual STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    virtual STDMETHODIMP LockServer(BOOL fLock);

public:
    CMigFactory(REFCLSID rclsid);
    ~CMigFactory(void);

    // Friend Functions
    friend HRESULT CMigFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);

protected:
    int                     m_cRef;
    CLSID                   m_rclsid;
};



/*****************************************************************************
 *    IClassFactory::CreateInstance
 *****************************************************************************/

HRESULT CMigFactory::CreateInstance(IUnknown * punkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres = ResultFromScode(REGDB_E_CLASSNOTREG);

    if (!punkOuter)
    {
        if (IsEqualIID(m_rclsid, CLSID_MigWizEngine))
            hres = CMigWizEngine_Create(riid, ppvObj);
        else
            hres = E_FAIL;  //ASSERT(0);
    }
    else
    {        // Does anybody support aggregation any more?
        hres = ResultFromScode(CLASS_E_NOAGGREGATION);
    }

    if (FAILED(hres) && ppvObj)
    {
        *ppvObj = NULL; // Be Robust. NT #355186
    }
    
    return hres;
}

/*****************************************************************************
 *
 *    IClassFactory::LockServer
 *
 *    Locking the server is identical to
 *    creating an object and not releasing it until you want to unlock
 *    the server.
 *
 *****************************************************************************/

HRESULT CMigFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}

/*****************************************************************************
 *
 *    CFtpFactory_Create
 *
 *****************************************************************************/

HRESULT CMigFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    if (IsEqualIID(riid, IID_IClassFactory))
    {
        *ppvObj = (LPVOID) new CMigFactory(rclsid);
        hres = (*ppvObj) ? S_OK : E_OUTOFMEMORY;
    }
    else
        hres = ResultFromScode(E_NOINTERFACE);

    return hres;
}





/****************************************************\
    Constructor
\****************************************************/
CMigFactory::CMigFactory(REFCLSID rclsid) : m_cRef(1)
{
    m_rclsid = rclsid;
    DllAddRef();
}


/****************************************************\
    Destructor
\****************************************************/
CMigFactory::~CMigFactory()
{
    DllRelease();
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CMigFactory::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CMigFactory::Release()
{
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CMigFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppvObj = SAFECAST(this, IClassFactory *);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CMigWizEngine_Create(IID riid, LPVOID* ppvObj)
{
    HRESULT hres = E_OUTOFMEMORY;
    CMigWizEngine* pengine = new CMigWizEngine();

    *ppvObj = NULL;
    if (pengine)
    {
        hres = pengine->QueryInterface(riid, ppvObj);
        pengine->Release();
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\migeng.cpp ===
#include "migeng.h"
#include "migutil.h"
#include "miginf.h"

extern "C" {
    #include "log.h"
}


// Globals
HINF g_GlobalScriptHandle = INVALID_HANDLE_VALUE;
TCHAR g_HTMLLog[MAX_PATH] = TEXT("");
TCHAR g_HTMLAppList[MAX_PATH] = TEXT("");

extern MigrationWizard* g_migwiz;

HRESULT _Engine_UploadVars (MIG_PLATFORMTYPEID idPlatform)
{
    HRESULT hr = S_OK;

    PCTSTR envVars = NULL;
    PCTSTR envString;
    PTSTR envStringCopy;
    PTSTR p;

    envVars = (PCTSTR) GetEnvironmentStrings();

    if (envVars) {

        envString = envVars;

        while (*envString)
        {
            p = _tcschr (envString, 0);

            if (p)
            {
                envStringCopy = (PTSTR) IsmGetMemory (((UINT)(p - envString + 1)) * sizeof (TCHAR));

                _tcscpy (envStringCopy, envString);

                p = _tcschr (envStringCopy, TEXT('='));

                //
                // Get rid of empty environment strings or the dummy env string starting
                // with '='
                //
                if (p && p != envStringCopy)
                {
                    *p = 0;
                    p = _tcsinc (p);

                    if (p) {
                        IsmSetEnvironmentString (idPlatform, S_SYSENVVAR_GROUP, envStringCopy, p);
                    }
                }
                IsmReleaseMemory (envStringCopy);
            }
            envString = _tcschr (envString, 0);
            envString ++;
        }
    }

    return hr;
}

BOOL
pGetCurrentUser (
    OUT     PCTSTR *UserName,
    OUT     PCTSTR *UserDomain
    )
{
    HANDLE token;
    PTOKEN_USER tokenUser = NULL;
    SID_NAME_USE dontCare;
    DWORD bytesRequired;
    TCHAR userName[256];
    DWORD nameSize;
    TCHAR userDomain[256];
    DWORD domainSize;

    //
    // Open the process token.
    //
    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &token)) {
        return FALSE;
    }

    bytesRequired = 0;
    if (GetTokenInformation (token, TokenUser, NULL, 0, &bytesRequired)) {
        return FALSE;
    }

    if (GetLastError () != ERROR_INSUFFICIENT_BUFFER) {
        return FALSE;
    }

    tokenUser = (PTOKEN_USER) IsmGetMemory (bytesRequired);

    if (!GetTokenInformation (token, TokenUser, tokenUser, bytesRequired, &bytesRequired)) {
        IsmReleaseMemory (tokenUser);
        return FALSE;
    }

    nameSize = ARRAYSIZE (userName);
    domainSize = ARRAYSIZE (userDomain);

    ZeroMemory (userName, nameSize);
    ZeroMemory (userDomain, domainSize);

    LookupAccountSid (
        NULL,
        tokenUser->User.Sid,
        userName,
        &nameSize,
        userDomain,
        &domainSize,
        &dontCare
        );

    if (UserName) {
        *UserName = IsmDuplicateString (userName);
    }

    if (UserDomain) {
        *UserDomain = IsmDuplicateString (userDomain);
    }

    if (tokenUser) {
        IsmReleaseMemory (tokenUser);
        tokenUser = NULL;
    }

    return TRUE;
}

BOOL
pIsUserAdmin (
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a member of the
    Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS expected to be
    able to open their own process and process token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    HANDLE token;
    DWORD bytesRequired;
    PTOKEN_GROUPS groups;
    BOOL b;
    DWORD i;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    PSID administratorsGroup;

    //
    // Open the process token.
    //
    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &token)) {
        return FALSE;
    }

    b = FALSE;
    groups = NULL;

    //
    // Get group information.
    //
    if (!GetTokenInformation (token, TokenGroups, NULL, 0, &bytesRequired) &&
         GetLastError() == ERROR_INSUFFICIENT_BUFFER
         ) {

        groups = (PTOKEN_GROUPS) HeapAlloc (GetProcessHeap (), 0, bytesRequired);
        b = GetTokenInformation (token, TokenGroups, groups, bytesRequired, &bytesRequired);
    }

    if (b) {

        b = AllocateAndInitializeSid (
                &ntAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &administratorsGroup
                );

        if (b) {

            //
            // See if the user has the administrator group.
            //
            b = FALSE;
            for (i = 0 ; i < groups->GroupCount ; i++) {
                if (EqualSid (groups->Groups[i].Sid, administratorsGroup)) {
                    b = TRUE;
                    break;
                }
            }

            FreeSid (administratorsGroup);
        }
    }

    //
    // Clean up and return.
    //

    if (groups) {
        HeapFree (GetProcessHeap (), 0, groups);
    }

    CloseHandle (token);

    return b;
}

typedef BOOL (WINAPI GETDISKFREESPACEEX)(
                        LPCTSTR lpDirectoryName,
                        PULARGE_INTEGER lpFreeBytesAvailable,
                        PULARGE_INTEGER lpTotalNumberOfBytes,
                        PULARGE_INTEGER lpTotalNumberOfFreeBytes
                        );
typedef GETDISKFREESPACEEX *PGETDISKFREESPACEEX;

BOOL
pMightHaveDiskSpaceProblem (
    VOID
    )
{
    TCHAR tempStorage[MAX_PATH];
    PTSTR tempPtr = NULL;
    ULARGE_INTEGER thisMediaMaxSize;
    ULARGE_INTEGER dummy1, dummy2;
    PGETDISKFREESPACEEX pGetDiskFreeSpaceEx;
    DWORD sectPerClust;
    DWORD bytesPerSect;
    DWORD freeClusters;
    DWORD totalClusters;

    if (IsmGetTempStorage (tempStorage, ARRAYSIZE(tempStorage))) {

        if (tempStorage [0] == TEXT('\\')) {
            // this is a UNC path
            _tcscat (tempStorage, TEXT("\\"));
            tempPtr = _tcschr (tempStorage, TEXT('\\'));
            if (tempPtr) {
                tempPtr = _tcschr (tempStorage, TEXT('\\'));
                if (tempPtr) {
                    tempPtr = _tcschr (tempStorage, TEXT('\\'));
                    if (tempPtr) {
                        tempPtr = _tcschr (tempStorage, TEXT('\\'));
                        if (tempPtr) {
                            tempPtr ++;
                            *tempPtr = 0;
                        }
                    }
                }
            }
        } else {
            // this is a normal path
            tempPtr = _tcschr (tempStorage, TEXT('\\'));
            if (tempPtr) {
                tempPtr ++;
                *tempPtr = 0;
            }
        }

        // Find out if GetDiskFreeSpaceEx is supported
#ifdef UNICODE
        pGetDiskFreeSpaceEx = (PGETDISKFREESPACEEX) GetProcAddress( GetModuleHandle (TEXT("kernel32.dll")), "GetDiskFreeSpaceExW");
#else
        pGetDiskFreeSpaceEx = (PGETDISKFREESPACEEX) GetProcAddress( GetModuleHandle (TEXT("kernel32.dll")), "GetDiskFreeSpaceExA");
#endif
        if (pGetDiskFreeSpaceEx) {
            if (!pGetDiskFreeSpaceEx (tempStorage, &dummy1, &dummy2, &thisMediaMaxSize)) {
                return FALSE;
            }
        } else {
            if (GetDiskFreeSpace (tempStorage, &sectPerClust, &bytesPerSect, &freeClusters, &totalClusters)) {
                thisMediaMaxSize.QuadPart = Int32x32To64 ((sectPerClust * bytesPerSect), freeClusters);
            } else {
                DWORD err = GetLastError ();
                return FALSE;
            }
        }

        if ((thisMediaMaxSize.HighPart == 0) &&
            (thisMediaMaxSize.LowPart < 1024 * 1024)
            ) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
pAddExtensions (
    VOID
    )
{
    HKEY rootKey = NULL;
    LONG result;

    // open the root key
    result = RegOpenKeyEx (HKEY_CLASSES_ROOT, TEXT(""), 0, KEY_READ, &rootKey);

    if (result == ERROR_SUCCESS) {

        UINT index = 0;
        TCHAR extName [MAX_PATH + 1];

        // enumerate all subkeys
        while (result == ERROR_SUCCESS) {

            result = RegEnumKey (rootKey, index, extName, MAX_PATH + 1);
            if (result == ERROR_SUCCESS) {

                // see if this is an extension
                if (_tcsnextc (extName) == TEXT('.')) {

                    HKEY subKey = NULL;
                    PCTSTR extNamePtr = NULL;

                    extNamePtr = _tcsinc (extName);

                    if (extNamePtr) {

                        BOOL foundExtension = FALSE;
                        INFCONTEXT context;

                        if (SetupFindFirstLine (g_hMigWizInf, TEXT("EXT.Include"), extNamePtr, &context)) {
                            foundExtension = TRUE;
                        } else if (SetupFindFirstLine (g_hMigWizInf, TEXT("EXT.Exclude"), extNamePtr, &context)) {
                            foundExtension = FALSE;
                        } else {

                            // open it
                            result = RegOpenKeyEx (rootKey, extName, 0, KEY_READ, &subKey);
                            if (result == ERROR_SUCCESS) {

                                TCHAR progIdName [MAX_PATH + 1];
                                DWORD regType;
                                DWORD size = (MAX_PATH + 1) * sizeof (TCHAR);

                                // let's find the ProgId (query the default value)
                                result = RegQueryValueEx (subKey, NULL, NULL, &regType, (PBYTE)progIdName, &size);
                                if ((result == ERROR_SUCCESS) && (regType == REG_SZ)) {

                                    HKEY progIdKey = NULL;

                                    // let's open the prog ID key
                                    result = RegOpenKeyEx (rootKey, progIdName, 0, KEY_READ, &progIdKey);
                                    if (result == ERROR_SUCCESS) {

                                        HKEY shellKey = NULL;

                                        // open the shell subkey
                                        result = RegOpenKeyEx (progIdKey, TEXT("shell"), 0, KEY_READ, &shellKey);
                                        if (result == ERROR_SUCCESS) {

                                            UINT shellIdx = 0;
                                            TCHAR cmdName [MAX_PATH + 1];

                                            // enumerate all subkeys
                                            while (result == ERROR_SUCCESS) {

                                                result = RegEnumKey (shellKey, shellIdx, cmdName, MAX_PATH + 1);
                                                if (result == ERROR_SUCCESS) {

                                                    if ((_tcsicmp (cmdName, TEXT("open")) == 0) ||
                                                        (_tcsicmp (cmdName, TEXT("play")) == 0)
                                                        ) {

                                                        HKEY cmdKey = NULL;

                                                        // open it
                                                        result = RegOpenKeyEx (shellKey, cmdName, 0, KEY_READ, &cmdKey);
                                                        if (result == ERROR_SUCCESS) {

                                                            HKEY actionKey = NULL;

                                                            // open the "command" subkey
                                                            result = RegOpenKeyEx (cmdKey, TEXT("command"), 0, KEY_READ, &actionKey);
                                                            if (result == ERROR_SUCCESS) {

                                                                TCHAR commandLine [MAX_PATH + 1];
                                                                DWORD size = (MAX_PATH + 1) * sizeof (TCHAR);

                                                                // let's find the actual command line (query the default value)
                                                                result = RegQueryValueEx (actionKey, NULL, NULL, &regType, (PBYTE)commandLine, &size);
                                                                if ((result == ERROR_SUCCESS) && ((regType == REG_SZ) || (regType == REG_EXPAND_SZ))) {

                                                                    TCHAR exePath [MAX_PATH + 1];
                                                                    PTSTR exeStart = NULL;
                                                                    PTSTR exeStop = NULL;
                                                                    PTSTR exePtr = NULL;
                                                                    INFCONTEXT context;
                                                                    BOOL doubleCheck = FALSE;

                                                                    // now we have the command line. Let's see if the module that handle this command
                                                                    // is in our IGNORE list
                                                                    if (_tcsnextc (commandLine) == TEXT('\"')) {
                                                                        exeStart = _tcsinc (commandLine);
                                                                        if (exeStart) {
                                                                            exeStop = _tcschr (exeStart, TEXT('\"'));
                                                                        }
                                                                    } else {
                                                                        doubleCheck = TRUE;
                                                                        exeStart = commandLine;
                                                                        exeStop = _tcschr (exeStart, TEXT(' '));
                                                                        if (!exeStop) {
                                                                            exeStop = _tcschr (exeStart, 0);
                                                                        }
                                                                    }

                                                                    if (exeStart && exeStop) {
                                                                        CopyMemory (exePath, exeStart, (exeStop - exeStart) * sizeof (TCHAR));
                                                                        exePath [exeStop - exeStart] = 0;

                                                                        exePtr = _tcsrchr (exePath, TEXT('\\'));
                                                                        if (exePtr) {
                                                                            exePtr = _tcsinc (exePtr);
                                                                        }

                                                                        if (exePtr && !SetupFindFirstLine (g_hMigWizInf, TEXT("EXT.IgnoreEXE"), exePtr, &context)) {
                                                                            foundExtension = TRUE;
                                                                        }
                                                                    }
                                                                    if (foundExtension && doubleCheck) {
                                                                        exeStop = NULL;
                                                                        exeStart = _tcsrchr (commandLine, TEXT('\\'));
                                                                        if (exeStart) {
                                                                            exeStart = _tcsinc (exeStart);
                                                                            if (exeStart) {
                                                                                exeStop = _tcschr (exeStart, TEXT(' '));
                                                                                if (!exeStop) {
                                                                                    exeStop = _tcschr (exeStart, 0);
                                                                                }
                                                                            }
                                                                        }
                                                                        if (exeStart && exeStop) {
                                                                            CopyMemory (exePath, exeStart, (exeStop - exeStart) * sizeof (TCHAR));
                                                                            exePath [exeStop - exeStart] = 0;

                                                                            exePtr = _tcsrchr (exePath, TEXT('\\'));
                                                                            if (exePtr) {
                                                                                exePtr = _tcsinc (exePtr);
                                                                            } else {
                                                                                exePtr = exePath;
                                                                            }

                                                                            if (exePtr && SetupFindFirstLine (g_hMigWizInf, TEXT("EXT.IgnoreEXE"), exePtr, &context)) {
                                                                                foundExtension = FALSE;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                RegCloseKey (actionKey);
                                                            }
                                                            RegCloseKey (cmdKey);
                                                        }
                                                    }
                                                    result = ERROR_SUCCESS;
                                                }
                                                shellIdx ++;
                                            }
                                            RegCloseKey (shellKey);
                                        }
                                        RegCloseKey (progIdKey);
                                    }
                                }
                                RegCloseKey (subKey);
                            }
                        }
                        if (foundExtension) {

                            //
                            // Add the component to the engine, unless it already exists
                            //
                            // Check if it is already in the tree
                            if (!IsmIsComponentSelected (extName + 1, COMPONENT_EXTENSION)) {

                                // Not in the tree; select it if it exists as a component
                                if (!IsmSelectComponent (extName + 1, COMPONENT_EXTENSION, TRUE)) {

                                    // Not a component; add the component
                                    IsmAddComponentAlias (
                                        NULL,
                                        MASTERGROUP_FILES_AND_FOLDERS,
                                        extName + 1,
                                        COMPONENT_EXTENSION,
                                        FALSE
                                        );
                                }
                            }
                        }
                    }
                }
                result = ERROR_SUCCESS;
            }
            index ++;
        }
        RegCloseKey (rootKey);
    }
    return TRUE;
}

HRESULT Engine_Initialize (PCTSTR ptszInfPath,
                           BOOL   fSource,
                           BOOL   fNetworkSupport,
                           LPTSTR pszUsername,
                           PMESSAGECALLBACK pMessageCallback,
                           PBOOL  pfNetworkDetected)
{
    static HRESULT hr = E_FAIL;
    static BOOL fDidThis = FALSE;
    ERRUSER_EXTRADATA errExtraData;
    PTSTR iconLibRoot = NULL;
    TCHAR iconLibSrc[MAX_PATH] = TEXT("");
    TCHAR iconLibDest[MAX_PATH] = TEXT("");
    HANDLE iconLibHandle = INVALID_HANDLE_VALUE;
    BOOL iconLibFound = FALSE;
    DWORD err;
    PCTSTR userName = NULL;
    PCTSTR userDomain = NULL;
    PCTSTR currUserName = NULL;
    PCTSTR currUserDomain = NULL;
    ROLLBACK_USER_ERROR rollbackError;

    if (fDidThis) {
        return hr;
    }

    __try
    {
        TCHAR szLogPath[MAX_PATH];
        TCHAR szFullLogFile[MAX_PATH];
        DWORD dwLength;
        HRESULT hResult;
        PTSTR pszAppData;

        fDidThis = TRUE;

        LogDeleteOnNextInit();

        pszAppData = GetShellFolderPath (CSIDL_LOCAL_APPDATA, TEXT("LocalAppData"), FALSE, NULL);
        if (pszAppData) {
            wsprintf (szFullLogFile, TEXT("%s\\FASTWiz.log"), pszAppData);
            LogReInit (NULL, NULL, szFullLogFile, NULL );
            wsprintf (g_HTMLLog, TEXT("%s\\FASTWiz.html"), pszAppData);
            wsprintf (g_HTMLAppList, TEXT("%s\\FASTApp.html"), pszAppData);
            LocalFree (pszAppData);
        } else {
            dwLength = GetEnvironmentVariable (TEXT("USERPROFILE"), szLogPath, ARRAYSIZE(szLogPath));
            if (dwLength > 0 && dwLength < (MAX_PATH - 13) )
            {
                wsprintf (szFullLogFile, TEXT("%s\\FASTWiz.log"), szLogPath);
                LogReInit (NULL, NULL, szFullLogFile, NULL );
                wsprintf (g_HTMLLog, TEXT("%s\\FASTWiz.html"), szLogPath);
                wsprintf (g_HTMLAppList, TEXT("%s\\FASTApp.html"), szLogPath);
            }
            else if (g_migwiz->GetWin9X() && GetWindowsDirectory(szLogPath, ARRAYSIZE(szLogPath)))
            {
                wsprintf (szFullLogFile, TEXT("%s\\FASTWiz.log"), szLogPath);
                LogReInit (NULL, NULL, szFullLogFile, NULL);
                wsprintf (g_HTMLLog, TEXT("%s\\FASTWiz.html"), szLogPath);
                wsprintf (g_HTMLAppList, TEXT("%s\\FASTApp.html"), szLogPath);
            }
            else
            {
                LogReInit (NULL, NULL, TEXT("FASTWiz.log"), NULL);
                if (GetCurrentDirectory(ARRAYSIZE(g_HTMLLog), g_HTMLLog))
                {
                    PathAppend(g_HTMLLog, TEXT("FASTWiz.html"));
                    PathAppend(g_HTMLAppList, TEXT("FASTApp.html"));
                }
                else
                {
                    _tcscpy (g_HTMLLog, TEXT("FASTWiz.html"));
                    _tcscpy (g_HTMLAppList, TEXT("FASTApp.html"));
                }
            }
        }

#ifndef DEBUG
        SuppressAllLogPopups (TRUE);
#endif

        if (!IsmInitialize (ptszInfPath, pMessageCallback, NULL))
        {
            __leave;
        }

        hr = _Engine_UploadVars (fSource?PLATFORM_SOURCE:PLATFORM_DESTINATION);

        if (!SUCCEEDED(hr))
        {
            __leave;
        }

        hr = E_FAIL;

        if (!IsmSetPlatform (fSource?PLATFORM_SOURCE:PLATFORM_DESTINATION))
        {
            __leave;
        }

        if (!fSource)
        {
            // we will try to copy iconlib.dll from our directory into "Common AppData" directory
            // If we don't succeed, we will try to copy it to "Local AppData". If this one does
            // not succeed we will not set the S_ENV_ICONLIB env variable

            iconLibSrc [0] = 0;
            GetSystemDirectory (iconLibSrc, ARRAYSIZE(iconLibSrc));
            _tcscat (iconLibSrc, TEXT("\\usmt\\iconlib.dll"));

            iconLibFound = FALSE;

            iconLibRoot = GetShellFolderPath (CSIDL_COMMON_APPDATA, TEXT("AppData"), FALSE, NULL);
            if (iconLibRoot) {
                __try {
                    _tcscpy (iconLibDest, iconLibRoot);
                    _tcscat (iconLibDest, TEXT("\\Microsoft"));
                    if (!CreateDirectory (iconLibDest, NULL)) {
                        err = GetLastError ();
                        if (err != ERROR_ALREADY_EXISTS) {
                            __leave;
                        }
                    }
                    _tcscat (iconLibDest, TEXT("\\USMT"));
                    if (!CreateDirectory (iconLibDest, NULL)) {
                        err = GetLastError ();
                        if (err != ERROR_ALREADY_EXISTS) {
                            __leave;
                        }
                    }
                    _tcscat (iconLibDest, TEXT("\\iconlib.dll"));
                    if (!CopyFile (iconLibSrc, iconLibDest, TRUE)) {
                        err = GetLastError ();
                        if (err != ERROR_FILE_EXISTS) {
                            __leave;
                        }
                        // we found an iconlib.dll there. The only question now is: can we access it?
                        // Let's try to open the file with write mode.
                        iconLibHandle = CreateFile (
                                            iconLibDest,
                                            GENERIC_READ|GENERIC_WRITE,
                                            FILE_SHARE_READ|FILE_SHARE_WRITE,
                                            NULL,
                                            OPEN_EXISTING,
                                            FILE_ATTRIBUTE_NORMAL,
                                            NULL
                                            );
                        if (iconLibHandle == INVALID_HANDLE_VALUE) {
                            // something is wrong, we can't access this file
                            err = GetLastError ();
                            __leave;
                        }
                        CloseHandle (iconLibHandle);
                    }
                    iconLibFound = TRUE;
                }
                __finally {
                    LocalFree (iconLibRoot);
                    iconLibRoot = NULL;
                }
            }

            if (!iconLibFound) {
                iconLibRoot = GetShellFolderPath (CSIDL_LOCAL_APPDATA, TEXT("Local AppData"), TRUE, NULL);
                if (iconLibRoot) {
                    __try {
                        _tcscpy (iconLibDest, iconLibRoot);
                        _tcscat (iconLibDest, TEXT("\\Microsoft"));
                        if (!CreateDirectory (iconLibDest, NULL)) {
                            err = GetLastError ();
                            if (err != ERROR_ALREADY_EXISTS) {
                                __leave;
                            }
                        }
                        _tcscat (iconLibDest, TEXT("\\USMT"));
                        if (!CreateDirectory (iconLibDest, NULL)) {
                            err = GetLastError ();
                            if (err != ERROR_ALREADY_EXISTS) {
                                __leave;
                            }
                        }
                        _tcscat (iconLibDest, TEXT("\\iconlib.dll"));
                        if (!CopyFile (iconLibSrc, iconLibDest, TRUE)) {
                            err = GetLastError ();
                            if (err != ERROR_FILE_EXISTS) {
                                __leave;
                            }
                        }
                        iconLibFound = TRUE;
                    }
                    __finally {
                        LocalFree (iconLibRoot);
                        iconLibRoot = NULL;
                    }
                }
            }

            // Set the icon lib data
            if (iconLibFound) {
                IsmSetEnvironmentString (PLATFORM_DESTINATION, NULL, S_ENV_ICONLIB, iconLibDest);
            }
        }

        //
        // Enable HKR migration
        //
        IsmSetEnvironmentFlag (fSource?PLATFORM_SOURCE:PLATFORM_DESTINATION, NULL, S_ENV_HKCU_ON);

        //
        // Enable files migration
        //
        IsmSetEnvironmentFlag (fSource?PLATFORM_SOURCE:PLATFORM_DESTINATION, NULL, S_ENV_ALL_FILES);

        //
        // Start ETM modules
        //
        if (!IsmStartEtmModules ()) {
            __leave;
        }

        // Set up the username
        if (pszUsername)
        {
            IsmSetEnvironmentString (fSource?PLATFORM_SOURCE:PLATFORM_DESTINATION, NULL, TRANSPORT_ENVVAR_HOMENET_TAG, pszUsername);
        }

        //
        // Start the transport modules
        //
        if (!IsmStartTransport ()) {
            __leave;
        }

        // If we're network-enabled, start appropriate network stuff
        if (fNetworkSupport)
        {
            // try to detect another machine on network
            MIG_TRANSPORTSTORAGEID transportStorageId = IsmRegisterTransport (S_HOME_NETWORK_TRANSPORT);
            MIG_TRANSPORTID transportId = IsmSelectTransport (transportStorageId, TRANSPORTTYPE_FULL, 0);
            if (!transportId)
            {
                // Network is not supported
                fNetworkSupport = FALSE;
            }
            else
            {
                BOOL fNetworkDetected = FALSE;
                if (!IsmSetTransportStorage (
                        fSource ? PLATFORM_SOURCE : PLATFORM_DESTINATION,
                        transportId,
                        transportStorageId,
                        CAPABILITY_AUTOMATED,
                        NULL,
                        NULL,
                        pfNetworkDetected
                        ))
                {
                    // Network is not supported
                    fNetworkSupport = FALSE;
                }
            }
        }

        hr = S_OK;

        if (!fSource) {
            // now let's take care of the rollback if necessary
            __try {
                // get the current user name and domain
                if ((!pGetCurrentUser (&currUserName, &currUserDomain)) ||
                    (!currUserName) ||
                    (!currUserDomain)
                    ) {
                    __leave;
                }

                if (IsmSetRollbackJournalType (TRUE)) {
                    if (IsmDoesRollbackDataExist (&userName, &userDomain, NULL, NULL, NULL)) {
                        if ((StrCmpI (userName, currUserName) == 0) &&
                            (StrCmpI (userDomain, currUserDomain) == 0)
                            ) {
                            // disable cancel, write the UNDO message in the UI
                            DisableCancel ();
                            PostMessageForWizard (WM_USER_ROLLBACK, 0, 0);
                            IsmRollback ();
                            __leave;
                        }
                        if (pIsUserAdmin ()) {
                            // disable cancel, write the UNDO message in the UI
                            DisableCancel ();
                            PostMessageForWizard (WM_USER_ROLLBACK, 0, 0);
                            IsmRollback ();
                            __leave;
                        }
                        // display the message, we can't run
                        rollbackError.UserName = userName;
                        rollbackError.UserDomain = userDomain;
                        IsmSendMessageToApp (ISMMESSAGE_EXECUTE_ROLLBACK, (ULONG_PTR)&rollbackError);
                        IsmPreserveJournal (TRUE);
                        hr = E_FAIL;
                        __leave;
                    }
                }

                if (IsmSetRollbackJournalType (FALSE)) {
                    if (IsmDoesRollbackDataExist (NULL, NULL, NULL, NULL, NULL)) {
                        // disable cancel, write the UNDO message in the UI
                        DisableCancel ();
                        PostMessageForWizard (WM_USER_ROLLBACK, 0, 0);
                        IsmRollback ();
                        __leave;
                    }
                }
            }
            __finally {
                if (currUserName) {
                    IsmReleaseMemory (currUserName);
                    currUserName = NULL;
                }

                if (currUserDomain) {
                    IsmReleaseMemory (currUserDomain);
                    currUserDomain = NULL;
                }

                if (userName) {
                    IsmReleaseMemory (userName);
                    userName = NULL;
                }
                if (userDomain) {
                    IsmReleaseMemory (userDomain);
                    userDomain = NULL;
                }
            }

            // finally let's find a place for the rollback journal
            if (SUCCEEDED(hr)) {
                if ((!IsmSetRollbackJournalType (TRUE)) ||
                    (!IsmCanWriteRollbackJournal ())
                    ) {
                    if ((!IsmSetRollbackJournalType (FALSE)) ||
                        (!IsmCanWriteRollbackJournal ())
                        ) {
                        // log a warning - we can't create a rollback journal
                        // BUGBUG - log the warning
                    }
                }
            }
        }
        if (SUCCEEDED(hr)) {
            if (fSource) {
                pAddExtensions ();
            }
        }
    }
    __finally
    {
        // Empty
    }

    if (FAILED(hr)) {
        if (pMightHaveDiskSpaceProblem ()) {
            errExtraData.Error = ERRUSER_ERROR_DISKSPACE;
        } else {
            errExtraData.Error = ERRUSER_ERROR_UNKNOWN;
        }
        errExtraData.ErrorArea = ERRUSER_AREA_INIT;
        errExtraData.ObjectTypeId = 0;
        errExtraData.ObjectName = NULL;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&errExtraData));
        Engine_Terminate();
    }

    return hr;
}

HRESULT Engine_RegisterProgressBarCallback(PROGRESSBARFN pProgressCallback, ULONG_PTR pArg)
{
    static HRESULT hr = E_FAIL;
    if (FAILED(hr)) // only register once
    {
        hr = IsmRegisterProgressBarCallback(pProgressCallback, pArg) ? S_OK : E_FAIL;
    }

    return hr;
}

HRESULT Engine_AppendScript(BOOL fSource, PCTSTR ptszInfPath)
{
    HRESULT hr = E_FAIL;
    ENVENTRY_STRUCT infHandleStruct;

    if (g_GlobalScriptHandle == INVALID_HANDLE_VALUE)
    {
        g_GlobalScriptHandle = SetupOpenInfFile (ptszInfPath, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
        if (g_GlobalScriptHandle != INVALID_HANDLE_VALUE)
        {
            hr = S_OK;
        }
    }
    else
    {
        if (SetupOpenAppendInfFile (ptszInfPath, g_GlobalScriptHandle, NULL))
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        IsmAppendEnvironmentMultiSz (fSource?PLATFORM_SOURCE:PLATFORM_DESTINATION, NULL, S_INF_FILE_MULTISZ, ptszInfPath);
        infHandleStruct.Type = ENVENTRY_BINARY;
        infHandleStruct.EnvBinaryData = (PBYTE)(&g_GlobalScriptHandle);
        infHandleStruct.EnvBinaryDataSize = sizeof (HINF);
        IsmSetEnvironmentValue (fSource?PLATFORM_SOURCE:PLATFORM_DESTINATION, NULL, S_GLOBAL_INF_HANDLE, &infHandleStruct);
    }

    return hr;
}

BOOL _LocalPathIsRoot(LPTSTR pszPath)
{
    return (PathIsRoot(pszPath) ||
            ((2 == lstrlen(pszPath)) &&
             ((pszPath[0] >= TEXT('A') && pszPath[0] <= TEXT('Z')) || (pszPath[0] >= TEXT('a') && pszPath[0] <= TEXT('z'))) &&
             (pszPath[1] == TEXT(':'))));
}

HRESULT Engine_StartTransport (BOOL fSource, LPTSTR pszPath, PBOOL ImageIsValid, PBOOL ImageExists)
{
    ERRUSER_EXTRADATA errExtraData;
    HRESULT hr = E_FAIL;
    MIG_TRANSPORTID         transportId;
    MIG_TRANSPORTSTORAGEID  transportStorageId;
    LPTSTR                  pszStoragePath;
    TCHAR                   szRootPath[4] = TEXT("A:\\");
    PTSTR                   lpExpStore = NULL;
    BOOL                    retryTrans = TRUE;
    BOOL                    tryUncFirst = (!fSource);
    TCHAR                   szSerialStr[] = TEXT("COM");
    TCHAR                   szParallelStr[] = TEXT("LPT");

    if (ImageIsValid) {
        *ImageIsValid = FALSE;
    }
    if (ImageExists) {
        *ImageExists = FALSE;
    }

    __try
    {
        if (pszPath) {

            //
            // Normal transport
            //

            //
            // Pick the specified transport
            //

            lpExpStore = (PTSTR)IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, pszPath, NULL);

            if (!lpExpStore) {
                // BUGBUG - fatal error
                __leave;
            }

            while (retryTrans) {
                if (_IsRemovableOrCDDrive(lpExpStore[0]) && _LocalPathIsRoot(lpExpStore) && (!tryUncFirst))
                {
                    transportStorageId = IsmRegisterTransport (S_REMOVABLE_MEDIA_TRANSPORT);
                    szRootPath[0] = lpExpStore[0];
                    pszStoragePath = szRootPath;
                }
                else if ((_tcsnicmp (pszPath, szSerialStr, (sizeof (szSerialStr) / sizeof (TCHAR)) - 1) == 0) ||
                         (_tcsnicmp (pszPath, szParallelStr, (sizeof (szParallelStr) / sizeof (TCHAR)) - 1) == 0)
                         )
                {
                    transportStorageId = IsmRegisterTransport (S_DIRECT_CABLE_TRANSPORT);
                    pszStoragePath = lpExpStore;
                }
                else
                {
                    transportStorageId = IsmRegisterTransport (S_RELIABLE_STORAGE_TRANSPORT);
                    pszStoragePath = lpExpStore;
                }

                transportId = IsmSelectTransport (transportStorageId, TRANSPORTTYPE_FULL, 0);
                if (!transportId)
                {
                    // BUGBUG - fatal error
                    __leave;
                }

                if (!IsmSetTransportStorage (
                        fSource ? PLATFORM_SOURCE : PLATFORM_DESTINATION,
                        transportId,
                        transportStorageId,
                        CAPABILITY_COMPRESSED,
                        pszStoragePath,
                        ImageIsValid,
                        ImageExists
                        ))
                {
                    if (tryUncFirst) {
                        tryUncFirst = FALSE;
                        continue;
                    }
                    // BUGBUG - fatal error
                    __leave;
                }
                if ((!fSource && ImageIsValid && !(*ImageIsValid)) ||
                    (!fSource && ImageExists && !(*ImageExists))
                    ) {
                    if (tryUncFirst) {
                        tryUncFirst = FALSE;
                        continue;
                    }
                }
                retryTrans = FALSE;
            }

            IsmReleaseMemory (lpExpStore);
            lpExpStore = NULL;

        } else {
            // network transport
            transportStorageId = IsmRegisterTransport (S_HOME_NETWORK_TRANSPORT);
            transportId = IsmSelectTransport (transportStorageId, TRANSPORTTYPE_FULL, 0);
            if (!transportId)
            {
                // BUGBUG - fatal error
                __leave;
            }
            if (!IsmSetTransportStorage (
                    fSource ? PLATFORM_SOURCE : PLATFORM_DESTINATION,
                    transportId,
                    transportStorageId,
                    CAPABILITY_AUTOMATED,
                    NULL,
                    ImageIsValid,
                    ImageExists
                    ))
            {
                // BUGBUG - fatal error
                __leave;
            }

        }
        hr = S_OK;
    }
    __finally
    {
        if (lpExpStore) {
            IsmReleaseMemory (lpExpStore);
            lpExpStore = NULL;
        }
    }

    if (!SUCCEEDED(hr))
    {
        if (pMightHaveDiskSpaceProblem ()) {
            errExtraData.Error = ERRUSER_ERROR_DISKSPACE;
        } else {
            errExtraData.Error = ERRUSER_ERROR_UNKNOWN;
        }
        errExtraData.ErrorArea = ERRUSER_AREA_SAVE;
        errExtraData.ObjectTypeId = 0;
        errExtraData.ObjectName = NULL;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&errExtraData));
    }

    return hr;
}

HRESULT Engine_Parse ()
{
    ERRUSER_EXTRADATA errExtraData;

    //
    // Execute the preparsing
    //
    if (!IsmExecute (EXECUTETYPE_EXECUTESOURCE_PARSING))
    {
        if (pMightHaveDiskSpaceProblem ()) {
            errExtraData.Error = ERRUSER_ERROR_DISKSPACE;
        } else {
            errExtraData.Error = ERRUSER_ERROR_UNKNOWN;
        }
        errExtraData.ErrorArea = ERRUSER_AREA_GATHER;
        errExtraData.ObjectTypeId = 0;
        errExtraData.ObjectName = NULL;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&errExtraData));
        return E_FAIL;
    }

    return S_OK;
}

HRESULT Engine_SelectComponentSet (UINT uSelectionGroup)
{
    MIG_COMPONENT_ENUM mce;
    BOOL bSelected;
    BOOL bDefaultSetting;
    BOOL bDefaultFile;
    BOOL bCallIsm;
    TCHAR szComponentToSelect[256];
    UINT uGroupInUi;

    // uSelectionGroup is either
    //   MIGINF_SELECT_OOBE
    //   MIGINF_SELECT_SETTINGS
    //   MIGINF_SELECT_FILES
    //   MIGINF_SELECT_BOTH

    //
    // Enable all components for the type. Use the migwiz.inf to identify components
    // that are part of the single floppy or multi floppy configuration. Remove all
    // customized components.
    //
    // This loop pings the component name (such as RAS) or the alias name (such as DOC)
    // to determine if the component should be selected. It is optimized to stop pinging
    // after the component becomes selected (because a component might have many aliases).
    // We rely on the mce.Instance member, which will always be sequential, and will
    // always be 1 for the first alias of a component.
    //

    IsmRemoveAllUserSuppliedComponents();

    IsmSelectMasterGroup (MASTERGROUP_ALL, FALSE);

    if (IsmEnumFirstComponent (&mce, COMPONENTENUM_ALL_ALIASES, 0))
    {

        bSelected = FALSE;

        do {

            bCallIsm = FALSE;

            if (mce.GroupId == COMPONENT_EXTENSION) {
                bSelected = IsComponentEnabled (uSelectionGroup, TEXT("EXTENSIONS"));
                bCallIsm = bSelected;
            } else {
                if (mce.Instance == 1)
                {
                    bSelected = IsComponentEnabled (uSelectionGroup, mce.ComponentString);
                    bCallIsm = bSelected;
                }
                if (!bSelected)
                {
                    bSelected = IsComponentEnabled (uSelectionGroup, mce.LocalizedAlias);
                    bCallIsm = bSelected;
                }
            }
            if (bCallIsm)
            {
                IsmSelectComponent (mce.LocalizedAlias, mce.GroupId, bSelected);
                mce.SkipToNextComponent = TRUE;
            }

        } while (IsmEnumNextComponent (&mce));
    }
    return S_OK;
}

HRESULT Engine_Execute(BOOL fSource)
{
    ERRUSER_EXTRADATA errExtraData;

    HRESULT hr = E_FAIL;

    __try {
        if (fSource)
        {
            //
            // Enumerate the system, gather data and analyze
            //
            if (!IsmExecute (EXECUTETYPE_EXECUTESOURCE))
            {
                if (pMightHaveDiskSpaceProblem ()) {
                    errExtraData.Error = ERRUSER_ERROR_DISKSPACE;
                } else {
                    errExtraData.Error = ERRUSER_ERROR_UNKNOWN;
                }
                errExtraData.ErrorArea = ERRUSER_AREA_GATHER;
                errExtraData.ObjectTypeId = 0;
                errExtraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&errExtraData));
                __leave;
            }

            //
            // Finally, save the data
            //
            if (!IsmSave ()) {
                if (pMightHaveDiskSpaceProblem ()) {
                    errExtraData.Error = ERRUSER_ERROR_DISKSPACE;
                } else {
                    errExtraData.Error = ERRUSER_ERROR_UNKNOWN;
                }
                errExtraData.ErrorArea = ERRUSER_AREA_SAVE;
                errExtraData.ObjectTypeId = 0;
                errExtraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&errExtraData));
                __leave;
            }

            hr = S_OK;
        }
        else
        {
            //
            // Try and retrieve the data
            //
            if (!IsmLoad ()) {
                if (pMightHaveDiskSpaceProblem ()) {
                    errExtraData.Error = ERRUSER_ERROR_DISKSPACE;
                } else {
                    errExtraData.Error = ERRUSER_ERROR_UNKNOWN;
                }
                errExtraData.ErrorArea = ERRUSER_AREA_LOAD;
                errExtraData.ObjectTypeId = 0;
                errExtraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&errExtraData));
                __leave;
            }

            //
            // Apply saved state
            //
            if (!IsmExecute (EXECUTETYPE_EXECUTEDESTINATION)) {
                if (pMightHaveDiskSpaceProblem ()) {
                    errExtraData.Error = ERRUSER_ERROR_DISKSPACE;
                } else {
                    errExtraData.Error = ERRUSER_ERROR_UNKNOWN;
                }
                errExtraData.ErrorArea = ERRUSER_AREA_RESTORE;
                errExtraData.ObjectTypeId = 0;
                errExtraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&errExtraData));
                IsmRollback();
                __leave;
            }

            DisableCancel();

            hr = S_OK;
        }
    }
    __finally {
    }

    return hr;
}

HRESULT Engine_Cancel ()
{
    IsmSetCancel();

    return S_OK;
}

HRESULT Engine_Terminate ()
{
    static BOOL fDidThis = FALSE;

    if (fDidThis) {
        return E_FAIL;
    }

    fDidThis = TRUE;

    IsmTerminate();

    if (g_GlobalScriptHandle != INVALID_HANDLE_VALUE)
    {
        SetupCloseInfFile (g_GlobalScriptHandle);
        g_GlobalScriptHandle = INVALID_HANDLE_VALUE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\migeng.h ===
#ifndef MIGENG_H
#define MIGENG_H

#include "migwiz.h"
#include "shlwapi.h"
#include "setupapi.h"

// Engine
#include "ism.h"

#include "modules.h"
#include "trans.h"

HRESULT Engine_Initialize (PCTSTR ptszInfPath, BOOL fSource, BOOL fNetworkSupport, LPTSTR pszUsername,
                           MESSAGECALLBACK pMessageCallback, PBOOL pfNetworkDetected);

HRESULT Engine_AppendScript(BOOL fSource, PCTSTR ptszInfPath);

HRESULT Engine_StartTransport (BOOL fSource, LPTSTR pszPath, PBOOL ImageIsValid, PBOOL ImageExists);

HRESULT Engine_Parse ();

HRESULT Engine_SelectComponentSet (UINT uSelectionGroup);

HRESULT Engine_RegisterProgressBarCallback(PROGRESSBARFN pProgressCallback, ULONG_PTR pArg);

HRESULT Engine_Execute(BOOL fSource);

HRESULT Engine_Cancel();

HRESULT Engine_Terminate ();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\miginf.h ===
#ifndef _MIGINF_H_
#define _MIGINF_H_

#define INC_OLE2
#include <windows.h>
#include <windowsx.h>
#include <setupapi.h>
#include <shlobj.h>
#include <prsht.h>
#include <tchar.h>
#include <windef.h>
#include "resource.h"
#include "commdlg.h"
#include "shlwapi.h"
#include "shellapi.h"

#include "migwiz.h"

#define MIGINF_SELECT_OOBE      0
#define MIGINF_SELECT_SETTINGS  1
#define MIGINF_SELECT_FILES     2
#define MIGINF_SELECT_BOTH      3


extern HINF g_hMigWizInf;
extern BOOL g_fStoreToFloppy;

BOOL OpenAppInf (LPTSTR pszFileName);
VOID CloseAppInf (VOID);
BOOL IsComponentEnabled (UINT uType, PCTSTR szComponent);
BOOL GetAppsToInstall (VOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\miginf.cpp ===
#include "miginf.h"
#include "migutil.h"

#include "basetypes.h"
#include "utiltypes.h"
#include "objstr.h"

extern "C" {
#include "ism.h"
}

#include "modules.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) ((sizeof(x)) / (sizeof(x[0])))
#endif

HINF g_hMigWizInf = INVALID_HANDLE_VALUE;
POBJLIST g_HTMLApps;


BOOL OpenAppInf (LPTSTR pszFileName)
{
    if (g_hMigWizInf != INVALID_HANDLE_VALUE) {
        return TRUE;
    }

    if (!pszFileName)
    {
        TCHAR szFileName[MAX_PATH];
        PTSTR psz;
        if (!GetModuleFileName (NULL, szFileName, ARRAYSIZE(szFileName))) {
            return FALSE;
        }

        psz = _tcsrchr (szFileName, TEXT('\\'));
        if (!psz) {
            return FALSE;
        }

        lstrcpy (psz + 1, TEXT("migwiz.inf"));
        pszFileName = szFileName;
    }

    g_hMigWizInf = SetupOpenInfFile (pszFileName, NULL, INF_STYLE_WIN4|INF_STYLE_OLDNT, NULL);

    return g_hMigWizInf != INVALID_HANDLE_VALUE;
}


VOID CloseAppInf (VOID)
{
    if (g_hMigWizInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile (g_hMigWizInf);
        g_hMigWizInf = INVALID_HANDLE_VALUE;
    }
}


BOOL IsComponentEnabled (UINT uType, PCTSTR szComponent)
{
    BOOL bResult = FALSE;
    INFCONTEXT ic;

    //
    // script-based entries start with $, while module-based entries don't.
    // This ensures script components do not collide with anything else.
    // Remove the $ to simplify [Single Floppy] or [Multiple Floppy].
    //

    if (_tcsnextc (szComponent) == TEXT('$')) {
        szComponent = _tcsinc (szComponent);
    }

    if (g_hMigWizInf != INVALID_HANDLE_VALUE) {

        switch (uType) {

        case MIGINF_SELECT_OOBE:
            bResult = SetupFindFirstLine (g_hMigWizInf, TEXT("OOBE"), szComponent, &ic);
            break;

        case MIGINF_SELECT_SETTINGS:
            bResult = SetupFindFirstLine (g_hMigWizInf, TEXT("Settings Only"), szComponent, &ic);
            if (!g_fStoreToFloppy && !bResult)
            {
                bResult = SetupFindFirstLine (g_hMigWizInf, TEXT("Settings Only.Ext"), szComponent, &ic);
            }
            break;

        case MIGINF_SELECT_FILES:
            bResult = SetupFindFirstLine (g_hMigWizInf, TEXT("Files Only"), szComponent, &ic);
            if (!g_fStoreToFloppy && !bResult)
            {
                bResult = SetupFindFirstLine (g_hMigWizInf, TEXT("Files Only.Ext"), szComponent, &ic);
            }
            break;

        case MIGINF_SELECT_BOTH:
            bResult = SetupFindFirstLine (g_hMigWizInf, TEXT("Files and Settings"), szComponent, &ic);

            if (!g_fStoreToFloppy && !bResult)
            {
                bResult = SetupFindFirstLine (g_hMigWizInf, TEXT("Files and Settings.Ext"), szComponent, &ic);
            }
            break;

        default:
            bResult = TRUE;
            break;

        }
    }

    return bResult;
}

BOOL
GetAppsToInstall (
    VOID
    )
{
    INFCONTEXT ic;
    POBJLIST objList = NULL;
    BOOL fResult;
    LPTSTR p;

    MIG_COMPONENT_ENUM mce;

    _FreeObjectList(g_HTMLApps);
    g_HTMLApps = NULL;

    if (IsmEnumFirstComponent (&mce, COMPONENTENUM_ALIASES | COMPONENTENUM_ENABLED |
                               COMPONENTENUM_PREFERRED_ONLY, COMPONENT_NAME)) {
        do {
            if (IsmIsComponentSelected (mce.ComponentString, 0)) {
                p = _tcsinc(mce.ComponentString);
                if (SetupFindFirstLine (g_hMigWizInf, TEXT("AppsToInstallOnDest"), p, &ic)) {
                    objList = _AllocateObjectList (mce.LocalizedAlias);
                    objList->Next = g_HTMLApps;
                    g_HTMLApps = objList;
                }
            }
        } while (IsmEnumNextComponent (&mce));
    }
    return (objList != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\migoobe.cpp ===
//
// dll.cpp
//
#include <iostream.h>
#include <objbase.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shlobj.h>

#include "cowsite.h"

#include "Iface.h"      // Interface declarations
#include "Registry.h"   // Registry helper functions
#include "migutil.h"
#include "migeng.h"
#include "migtask.h"
#include "migoobe.h"


// DLL functions, declared in dll.cpp
STDAPI DllAddRef();
STDAPI DllRelease();

extern HMODULE g_hModule;

///////////////////////////////////////////////////////////
//
// Global variables
//
///////////////////////////////////////////////////////////
//
// Component
//


//
// Constructor
//
CMigWizEngine::CMigWizEngine() : m_cRef(1), m_fCancelled(TRUE), m_fUserApplying(FALSE), m_fInBackgroundThread(FALSE)
{
    DllAddRef();
}

//
// Destructor
//
CMigWizEngine::~CMigWizEngine()
{
    DllRelease();
}

//
// IUnknown implementation
//
STDMETHODIMP CMigWizEngine::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMigWizEngine, IObjectWithSite),
        QITABENT(CMigWizEngine, IMigrationWizardAuto),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CMigWizEngine::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CMigWizEngine::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

///////////////////////////////////////////////////////////

STDMETHODIMP CMigWizEngine::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** ppITypeInfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMigWizEngine::GetIDsOfNames(REFIID /*riid */, LPOLESTR* rgszNames,
    UINT cNames, LCID lcid, DISPID* rgdispid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMigWizEngine::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams,
                              VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMigWizEngine::GetTypeInfoCount(UINT* pctinfo)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////

HRESULT CMigWizEngine::_FireEvent (LPVOID lpParam, int iDISPID, DISPPARAMS* pdisp)
{
    HRESULT hr = E_FAIL;

    IDispatch* pDispatch = (IDispatch*)lpParam;

    if (pDispatch)
    {
        VARIANT varResult;
        DISPPARAMS disp = { NULL, NULL, 0, 0};
        if (pdisp == NULL)
        {
            pdisp = &disp;
        }

        hr = pDispatch->Invoke(iDISPID, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, pdisp, &varResult, NULL, NULL);

    }

    return hr;
}

HRESULT CMigWizEngine::_GetIDispatchStream(IStream** ppStream)
{
    HRESULT hr = E_FAIL;

    BOOL fDone = FALSE;

    if (_punkSite)
    {
        IConnectionPointContainer* pCPC;
        hr = _punkSite->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, &pCPC)); // get the connect point container

        if (SUCCEEDED(hr))
        {
            IEnumConnectionPoints* pEnum;

            hr = pCPC->EnumConnectionPoints(&pEnum); // get all the connection points

            if (SUCCEEDED(hr))
            {
                IConnectionPoint* pcp;
                while (!fDone)
                {
                    ULONG cpcp = 1;
                    if (FAILED(pEnum->Next(1, &pcp, &cpcp)) || 0 == cpcp)
                    {
                        break;
                    }
                    else
                    {
                        IID iidInterface;
                        if (SUCCEEDED ( pcp->GetConnectionInterface(&iidInterface) && // get only the connection point for DMigrationWizardAutoEvents
                            (DIID_DMigrationWizardAutoEvents == iidInterface)))
                        {
                            // now fire the event for all listeners on this connection point
                            IEnumConnections* pEnumConnections;
                            if (SUCCEEDED(pcp->EnumConnections(&pEnumConnections)))
                            {
                                CONNECTDATA rgcd[1];
                                ULONG ccd;
                                while (!fDone)
                                {
                                    if (FAILED(pEnumConnections->Next(ARRAYSIZE(rgcd), rgcd, &ccd)) || ccd == 0)
                                    {
                                        break;
                                    }
                                    else if (rgcd[0].pUnk)
                                    {
                                        IDispatch* pDispatch;
                                        if (SUCCEEDED(rgcd[0].pUnk->QueryInterface(IID_PPV_ARG(IDispatch, &pDispatch))))
                                        {
                                            if (SUCCEEDED(CoMarshalInterThreadInterfaceInStream(IID_IDispatch, pDispatch, ppStream)))
                                            {
                                                fDone = TRUE;
                                                hr = S_OK;
                                            }
                                            pDispatch->Release();
                                        }
                                        rgcd[0].pUnk->Release();
                                    }
                                }
                                pEnumConnections->Release();
                            }
                        }
                        pcp->Release();
                    }
                }
                pEnum->Release();
            }
            pCPC->Release();
        }
    }

    return hr;
}

HRESULT CMigWizEngine::_FireProgress(LPVOID lpParam, BSTR pszMsg, int iDone, int iTotal)
{
    VARIANTARG rgvarg[3];
    VARIANT varResult;
    VariantClear(&varResult);
    HRESULT hr = E_OUTOFMEMORY;

    DISPPARAMS disp = { rgvarg, NULL, ARRAYSIZE(rgvarg), 0};

    rgvarg[0].vt = VT_BSTR;
    rgvarg[0].bstrVal = SysAllocString(pszMsg);
    if (rgvarg[0].bstrVal)
    {
        rgvarg[1].vt = VT_I4;
        rgvarg[1].lVal = iDone;

        rgvarg[2].vt = VT_I4;
        rgvarg[2].lVal = iTotal;

        hr = _FireEvent(lpParam, 1, &disp);
        SysFreeString(rgvarg[0].bstrVal);
    }

    return hr;
}

HRESULT CMigWizEngine::_FireComplete(LPVOID lpParam, BSTR pszMsg)
{
    VARIANTARG rgvarg[1];
    DISPPARAMS disp = { rgvarg, NULL, ARRAYSIZE(rgvarg), 0};

    rgvarg[0].vt = VT_BSTR;
    rgvarg[0].bstrVal = SysAllocString(pszMsg);
    if (rgvarg[0].bstrVal)
    {

        _FireEvent(lpParam, 2, &disp);

        SysFreeString(rgvarg[0].bstrVal);
    }

    return S_OK;
}


typedef struct {
    IDispatch* pDispatch;
    CMigWizEngine* pengine;
} PROGRESSCALLBACKSTRUCT;

UINT ProgressCallback (LPVOID lpParam, UINT ui1, UINT ui2)
{

    PROGRESSCALLBACKSTRUCT* ppcs = (PROGRESSCALLBACKSTRUCT*)lpParam;

    ppcs->pengine->_FireProgress((LPVOID)(ppcs->pDispatch), SZ_MIGWIZPROGRESS_OK, ui1, ui2);

    return 0;
}

#define SZ_OOBEMODE     TEXT("OOBEMODE")
HRESULT CMigWizEngine::_CreateToolDiskThreadWorker ()
{
    HRESULT hr = E_FAIL;
    BOOL fNoDisk = FALSE;

    IDispatch* pDispatch;

    hr = CoGetInterfaceAndReleaseStream(m_pDispatchStream, IID_PPV_ARG(IDispatch, &pDispatch));
    if (SUCCEEDED(hr))
    {
        // copy the INF
        CHAR szDrivePathA[MAX_PATH];

        if (SUCCEEDED(_SHUnicodeToAnsi(m_pszDrivePath, szDrivePathA, ARRAYSIZE(szDrivePathA))))
        {
            CHAR szFilesPathA[MAX_PATH];
            if (SUCCEEDED(_SHUnicodeToAnsi(m_pszFilesPath, szFilesPathA, ARRAYSIZE(szFilesPathA))))
            {
                CHAR szManifestPathA[MAX_PATH];
                if (SUCCEEDED(_SHUnicodeToAnsi(m_pszManifestPath, szManifestPathA, ARRAYSIZE(szManifestPathA))))
                {
                    PROGRESSCALLBACKSTRUCT pcs;
                    pcs.pDispatch = pDispatch;
                    pDispatch->AddRef();
                    pcs.pengine = this;
                    this->AddRef();

                    if (SUCCEEDED(_CopyInfToDisk(szDrivePathA, szFilesPathA, szManifestPathA,
                                  ProgressCallback, (LPVOID)&pcs, NULL, NULL, g_hModule, &m_fCancelled, &fNoDisk)))
                    {
                        if (!m_fCancelled)
                        {
                            hr = S_OK;
                            IStream* pStream = NULL;
                            TCHAR szPath[MAX_PATH];
                            lstrcpy(szPath, szDrivePathA);
                            PathAppend(szPath, TEXT("oobemode.dat"));
                            if (SUCCEEDED(SHCreateStreamOnFile(szPath, STGM_WRITE | STGM_CREATE, &pStream)))
                            {
                                pStream->Write(SZ_OOBEMODE, sizeof(TCHAR) * (ARRAYSIZE(SZ_OOBEMODE) - 1), NULL);
                                pStream->Release();
                            }
                        }
                    }

                    pDispatch->Release();
                    this->Release();
                }
            }
        }


        m_fInBackgroundThread = FALSE;

        if (m_fCancelled)
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_CANCEL);
        }
        else if (fNoDisk)
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_NODISK);
        }
        else if (SUCCEEDED(hr))
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_OK);
        }
        else
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_FAIL);
        }
    }

    m_fCancelled = TRUE;

    SysFreeString(m_pszDrivePath);
    SysFreeString(m_pszFilesPath);
    SysFreeString(m_pszManifestPath);
    if (pDispatch)
    {
        pDispatch->Release();
    }
    Release();

    return 0;
}

DWORD WINAPI CMigWizEngine::_CreateToolDiskThread (LPVOID lpParam)
{
    if (lpParam)
    {
        ((CMigWizEngine*)lpParam)->_CreateToolDiskThreadWorker();
    }


    return 0;
}

STDMETHODIMP CMigWizEngine::CreateToolDisk(BSTR pszDrivePath, BSTR pszFilesPath, BSTR pszManifestPath)
{
    HRESULT hr = S_OK; // we always want to return S_OK

    if (!m_fInBackgroundThread)
    {
        m_fInBackgroundThread = TRUE;
        hr = S_OK;

        IStream* pDispatchStream;
        hr = _GetIDispatchStream(&pDispatchStream);

        if (SUCCEEDED(hr))
        {
            m_pszDrivePath = SysAllocString(pszDrivePath);
            m_pszFilesPath = SysAllocString(pszFilesPath);
            m_pszManifestPath = SysAllocString(pszManifestPath);

            if (m_pszDrivePath && m_pszFilesPath && m_pszManifestPath)
            {
                m_fCancelled = FALSE;
                m_pDispatchStream = pDispatchStream;
                m_pDispatchStream->AddRef();

                AddRef();
                if (!SHCreateThread(_CreateToolDiskThread, this, (CTF_COINIT | CTF_PROCESS_REF | CTF_FREELIBANDEXIT), NULL))
                {
                    Release();
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                SysFreeString(pszDrivePath); // SysFreeString doesn't mind being passed NULL
                SysFreeString(pszFilesPath);
                SysFreeString(pszManifestPath);
            }

            pDispatchStream->Release();
        }
    }

    return hr;
}

BOOL g_fApplyDiskNotFound;

ULONG_PTR MessageCallback (UINT uiMsg, ULONG_PTR pArg)
{
    PRMEDIA_EXTRADATA extraData;

    switch (uiMsg) {

    case TRANSPORTMESSAGE_SIZE_SAVED:
        return TRUE;

    case TRANSPORTMESSAGE_RMEDIA_LOAD:
        extraData = (PRMEDIA_EXTRADATA) pArg;
        if (!extraData) {
            return TRUE;
        } else {
            if (extraData->MediaNumber == 1) {
                switch (extraData->LastError) {
                case RMEDIA_ERR_NOERROR:
                    return TRUE;
                    break;
                case RMEDIA_ERR_WRONGMEDIA:
                    g_fApplyDiskNotFound = TRUE;
                    return FALSE;
                    break;
                case RMEDIA_ERR_DISKFULL:
                    return FALSE;
                    break;
                case RMEDIA_ERR_WRITEPROTECT:
                    return FALSE;
                    break;
                case RMEDIA_ERR_NOTREADY:
                    return FALSE;
                    break;
                case RMEDIA_ERR_CRITICAL:
                    return FALSE;
                    break;
                default:
                    return TRUE;
                }
            } else {
                switch (extraData->LastError) {
                case RMEDIA_ERR_NOERROR:
                    return TRUE;
                    break;
                case RMEDIA_ERR_WRONGMEDIA:
                    g_fApplyDiskNotFound = TRUE;
                    return FALSE;
                    break;
                case RMEDIA_ERR_DISKFULL:
                    return FALSE;
                    break;
                case RMEDIA_ERR_WRITEPROTECT:
                    return FALSE;
                    break;
                case RMEDIA_ERR_NOTREADY:
                    return FALSE;
                    break;
                case RMEDIA_ERR_CRITICAL:
                    return FALSE;
                    break;
                default:
                    return TRUE;
                }
            }
        }
    }

    return APPRESPONSE_SUCCESS;
}

#define PHASEWIDTH_APPLY_TRANSPORT     1000
#define PHASEWIDTH_APPLY_ANALYSIS      1000
#define PHASEWIDTH_APPLY_APPLY         1000
#define PHASEWIDTH_APPLY_TOTAL        (PHASEWIDTH_APPLY_TRANSPORT + PHASEWIDTH_APPLY_ANALYSIS + PHASEWIDTH_APPLY_APPLY)

typedef struct {
    CMigWizEngine* pEngine;
    IDispatch* pDispatch;
} APPLYPROGRESSCALLBACKSTRUCT;

VOID WINAPI ApplyProgressCallback (MIG_PROGRESSPHASE Phase, MIG_PROGRESSSTATE State, UINT uiWorkDone, UINT uiTotalWork, ULONG_PTR pArg)
{
    INT iWork = 0;
    INT iPhaseWidth = 0;
    INT iTotal = PHASEWIDTH_APPLY_TOTAL;

    APPLYPROGRESSCALLBACKSTRUCT* papcs = (APPLYPROGRESSCALLBACKSTRUCT*)pArg;

    switch (Phase)
    {
    case MIG_TRANSPORT_PHASE:
        iWork = 0;
        iPhaseWidth = PHASEWIDTH_APPLY_TRANSPORT;
        break;
    case MIG_ANALYSIS_PHASE:
        iWork = PHASEWIDTH_APPLY_TRANSPORT;
        iPhaseWidth = PHASEWIDTH_APPLY_ANALYSIS;
        break;
    case MIG_APPLY_PHASE:
        iWork = PHASEWIDTH_APPLY_TRANSPORT + PHASEWIDTH_APPLY_ANALYSIS;
        iPhaseWidth = PHASEWIDTH_APPLY_APPLY;
        break;
    }

    if (State == MIG_END_PHASE)
    {
        iWork += iPhaseWidth;
    }
    else if (uiTotalWork && uiWorkDone)
    {
        iWork += (iPhaseWidth * uiWorkDone) / uiTotalWork;
    }

    if (papcs && papcs->pEngine && papcs->pDispatch)
    {
        papcs->pEngine->_FireProgress(papcs->pDispatch, L"", iWork, iTotal);
    }
}

HRESULT CMigWizEngine::_ApplySettingsThreadWorker ()
{
    HRESULT hr = E_OUTOFMEMORY;

    g_fApplyDiskNotFound = FALSE; // set up

    IDispatch* pDispatch;

    hr = CoGetInterfaceAndReleaseStream(m_pDispatchStream, IID_PPV_ARG(IDispatch, &pDispatch));
    if (SUCCEEDED(hr))
    {
        APPLYPROGRESSCALLBACKSTRUCT apcs;
        apcs.pEngine = this;
        apcs.pEngine->AddRef();
        apcs.pDispatch = pDispatch;
        apcs.pDispatch->AddRef();

        if (SUCCEEDED(hr))
        {
            TCHAR szFloppyPath[4] = TEXT("A:\\");
            szFloppyPath[0] += (TCHAR)_GetFloppyNumber(TRUE);

            hr = _DoApply(szFloppyPath, NULL, NULL, &m_fCancelled, ApplyProgressCallback, (ULONG_PTR)&apcs);
        }

        apcs.pEngine->Release();
        apcs.pDispatch->Release();

        m_fInBackgroundThread = FALSE;

        if (m_fCancelled)
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_CANCEL);
        }
        else if (g_fApplyDiskNotFound)
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_NODISK);
        }
        else if (SUCCEEDED(hr))
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_OK);
        }
        else
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_FAIL);
        }
    }

    m_fCancelled = TRUE;
    m_fUserApplying = FALSE;

    Release();

    return hr;
}

DWORD WINAPI CMigWizEngine::_ApplySettingsThread (LPVOID lpParam)
{
    if (lpParam)
    {
        ((CMigWizEngine*)lpParam)->_ApplySettingsThreadWorker();
    }

    return 0;
}

STDMETHODIMP CMigWizEngine::ApplySettings(BSTR pszMigwizFiles)
{
    HRESULT hr = E_FAIL;

    if (!m_fInBackgroundThread)
    {
        m_fInBackgroundThread = TRUE;
        hr = S_OK;

        m_fUserApplying = TRUE;

        IStream* pDispatchStream;
        hr = _GetIDispatchStream(&pDispatchStream);

        if (SUCCEEDED(hr))
        {
            m_fCancelled = FALSE;

            CHAR szMigwizPathA[MAX_PATH];
            if (SUCCEEDED(_SHUnicodeToAnsi(pszMigwizFiles, szMigwizPathA, ARRAYSIZE(szMigwizPathA))))
            {
                hr = Engine_Initialize(szMigwizPathA, FALSE, FALSE, TEXT("OOBE"), MessageCallback, NULL);

                m_pDispatchStream = pDispatchStream;
                m_pDispatchStream->AddRef();
                AddRef();
                if (!SHCreateThread(_ApplySettingsThread, this, (CTF_COINIT | CTF_PROCESS_REF | CTF_FREELIBANDEXIT), NULL))
                {
                    Release();
                }
            }
            else
            {
                hr = E_FAIL;
            }


            pDispatchStream->Release();
        }
    }

    return hr;
}

STDMETHODIMP CMigWizEngine::Cancel()
{
    HRESULT hr = S_OK;

    m_fCancelled = TRUE;
    if (m_fUserApplying)
    {
        Engine_Cancel();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\migtask.h ===
#ifndef _MIGTASK_H_
#define _MIGTASK_H_

#include "ism.h"

typedef UINT(CALLBACK MESSAGECALLBACK2)(LPVOID lpParam, UINT ui1, UINT ui2);
typedef MESSAGECALLBACK2 *PMESSAGECALLBACK2;


HRESULT _CopyInfToDisk(LPCTSTR pctszDestPath, LPCTSTR pctszSourcePath, LPCTSTR pctszInfPath,
                       PMESSAGECALLBACK2 progressCallback, LPVOID lpParam,
                       HWND hwndProgessBar, HWND hwndParent, HINSTANCE hInstance,
                       BOOL* pfHasUserCancelled, DWORD* pfError);

HRESULT _DoCopy(LPTSTR tszTransportPath, HWND hwndProgress, HWND hwndPropSheet, BOOL* pfHasUserCancelled);

HRESULT _DoApply(LPTSTR tszTransportPath, HWND hwndProgress, HWND hwndPropSheet, BOOL* pfHasUserCancelled, PROGRESSBARFN pAltProgressFunction, ULONG_PTR puAltProgressParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\migoobe.h ===
#ifndef _MIGOOBE_H
#define _MIGOOBE_H

#include "cowsite.h"

class CMigWizEngine : public CObjectWithSite
                      ,public IMigrationWizardAuto
{
public:
    // Constructor
    CMigWizEngine();

    // Destructor
    virtual ~CMigWizEngine();

    // IUnknown
    virtual STDMETHODIMP QueryInterface(const IID& iid, void** ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();


protected:
    // IMigrationWizardAuto
    virtual STDMETHODIMP CreateToolDisk(BSTR pszDrivePath, BSTR pszFilesPath, BSTR pszManifestPath);
    virtual STDMETHODIMP ApplySettings(BSTR pszStore);
    virtual STDMETHODIMP Cancel();

    // IDispatch
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);
    virtual STDMETHODIMP GetTypeInfoCount(UINT FAR*  pctinfo);

protected:
    // helpers
    HRESULT _FireEvent(LPVOID lpParam, int iDISPID, DISPPARAMS* pdisp);
    HRESULT _FireProgress(LPVOID lpParam, BSTR pszMsg, int iDone, int iTotal);
    HRESULT _FireComplete(LPVOID lpParam, BSTR pszMsg);

    HRESULT _GetIDispatchStream (IStream** ppStream);

    HRESULT _CreateToolDiskThreadWorker();
    static DWORD WINAPI _CreateToolDiskThread (LPVOID lpParam);

    HRESULT _ApplySettingsThreadWorker();
    static DWORD WINAPI _ApplySettingsThread (LPVOID lpParam);


private:

    // Reference count
    long     m_cRef;
    BOOL     m_fUserApplying;
    BOOL     m_fInBackgroundThread; // only one background thread at a time, precludes more calls to CreateToolDisk, ApplySettings

    // _CreateToolDiskThread, _ApplySettingsThread
    BSTR     m_pszDrivePath;
    BSTR     m_pszFilesPath; 
    BSTR     m_pszManifestPath;
    BOOL     m_fCancelled;
    IStream* m_pDispatchStream;


    friend UINT ProgressCallback (LPVOID lpparam, UINT ui1, UINT ui2);
    friend VOID WINAPI ApplyProgressCallback (MIG_PROGRESSPHASE Phase, MIG_PROGRESSSTATE State, UINT uiWorkDone, UINT uiTotalWork, ULONG_PTR pArg);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\migutil.h ===
#ifndef _MIGUTIL_H_
#define _MIGUTIL_H_


#define MAX_LOADSTRING 1024

#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))

LPWSTR _ConvertToUnicode(UINT cp, LPCSTR pcszSource);
LPSTR _ConvertToAnsi(UINT cp, LPCWSTR pcwszSource);

HRESULT _SHAnsiToUnicode(LPSTR pszIn, LPWSTR pwszOut, UINT cchOut);
HRESULT _SHUnicodeToAnsi(LPWSTR pwszIn, LPSTR pszOut, UINT cchOut);

INT_PTR _ExclusiveDialogBox(HINSTANCE hInstance, LPCTSTR lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc);
int     _ExclusiveMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType);

int     _ComboBoxEx_AddString(HWND hwndBox, LPTSTR ptsz);
int     _ComboBoxEx_SetIconW(HWND hwndBox, LPWSTR wsz, UINT iDex);
HRESULT _ListView_AddDrives(HWND hwndList, LPTSTR pszNetworkName);

int     _GetRemovableDriveCount();
TCHAR   _GetRemovableDrive(int iDex);
LPTSTR  _GetRemovableDrivePretty(int iDex);
BOOL    _IsRemovableOrCDDrive(TCHAR chDrive);

BOOL    _IsValidStore(LPTSTR pszStore, BOOL bCreate, HINSTANCE hinst, HWND hwnd);

INT     _ComboBoxEx_AddDrives(HWND hwndBox);
INT     _ComboBoxEx_AddCOMPorts(HWND hwndBox, INT SelectedPort);

HRESULT _CreateAnimationCtrl(HWND hwndDlg, HINSTANCE hinst, UINT idMarker, UINT idAnim, UINT idAvi, HWND* pHwndAnim);


#define POPULATETREE_FLAGS_FOLDERS 0x1
#define POPULATETREE_FLAGS_FILES 0x2
#define POPULATETREE_FLAGS_FILETYPES 0x3
#define POPULATETREE_FLAGS_SETTINGS 0x4

VOID    _PopulateTree (HWND hwndTree, HTREEITEM hti, LPTSTR ptsz, UINT cch,
                       HRESULT (*fct)(HINSTANCE, BOOL, LPCTSTR, LPTSTR, UINT cchName),
                       DWORD dwFlags, HINSTANCE Instance, BOOL fNT4);

UINT    _ListView_InsertItem(HWND hwndList, LPTSTR ptsz);


HRESULT _GetPrettyFolderName(HINSTANCE Instance, BOOL fNT4, LPCTSTR pctszPath, LPTSTR ptszName, UINT cchName);
HRESULT _GetPrettyTypeName(LPCTSTR pctszType, LPTSTR ptszPrettyType, UINT cchPrettyType);

HANDLE _GetDeviceHandle(LPCTSTR psz, DWORD dwDesiredAccess, DWORD dwFileAttributes);

INT _GetFloppyNumber(BOOL fIsNT);
INT _DriveStrIsFloppy(BOOL fIsNT, PCTSTR psz);

typedef struct {
    LPTSTR pszPureName;
    BOOL fOverwrite;
} LV_DATASTRUCT;

BOOL _SetTextLoadString(HINSTANCE hInst, HWND hwnd, UINT idText);

VOID DisableCancel (VOID);

VOID EnableCancel (VOID);

VOID PostMessageForWizard (UINT Msg, WPARAM wParam, LPARAM lParam);

VOID _UpdateText (HWND hWnd, LPCTSTR  pszString);

BOOL
AppExecute (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR ExecuteArgs
    );

VOID
RestartExplorer (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    );

typedef struct {
    PCTSTR UserName;
    PCTSTR UserDomain;
} ROLLBACK_USER_ERROR, *PROLLBACK_USER_ERROR;

PTSTR
GetShellFolderPath (
    IN      INT Folder,
    IN      PCTSTR FolderStr,
    IN      BOOL UserFolder,
    OUT     LPITEMIDLIST *pidl  //OPTIONAL
    );

#define IPFL_USECALLBACK        0x0001
#define IPFL_USEDEFAULTS        0x0002

typedef HRESULT (CALLBACK *SHINVOKECALLBACK)(IDispatch *pdisp, struct SHINVOKEPARAMS *pinv);

#include <pshpack1.h>
    typedef struct SHINVOKEPARAMS {
        UINT flags;                     // mandatory
        DISPID dispidMember;            // mandatory
        const IID*piid;                 // IPFL_USEDEFAULTS will fill this in
        LCID lcid;                      // IPFL_USEDEFAULTS will fill this in
        WORD wFlags;                    // IPFL_USEDEFAULTS will fill this in
        DISPPARAMS * pdispparams;       // mandatory, may be NULL
        VARIANT * pvarResult;           // IPFL_USEDEFAULTS will fill this in
        EXCEPINFO * pexcepinfo;         // IPFL_USEDEFAULTS will fill this in
        UINT * puArgErr;                // IPFL_USEDEFAULTS will fill this in
        SHINVOKECALLBACK Callback;      // required if IPFL_USECALLBACK
    } SHINVOKEPARAMS, *LPSHINVOKEPARAMS;
#include <poppack.h>        /* Return to byte packing */

HRESULT IUnknown_CPContainerInvokeIndirect(IUnknown *punk, REFIID riidCP,
            SHINVOKEPARAMS *pinv);

VOID
_RemoveSpaces (
    IN      PTSTR szData,
    IN      UINT uDataCount
    );

HRESULT
OurSHBindToParent (
    IN      LPCITEMIDLIST pidl,
    IN      REFIID riid,
    OUT     VOID **ppv,
    OUT     LPCITEMIDLIST *ppidlLast
    );

typedef struct _TAG_OBJLIST {
    PTSTR ObjectName;
    PTSTR AlternateName;
    struct _TAG_OBJLIST *Next;
} OBJLIST, *POBJLIST;

POBJLIST
_AllocateObjectList (
    IN      PCTSTR ObjectName
    );

VOID
_FreeObjectList (
    IN      POBJLIST ObjectList
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\migwiz.cpp ===
#include "migwiz.h"
#include "migwnprc.h"
#include "migeng.h"
#include "migutil.h"
#include "miginf.h"
#include "shellapi.h"
#include "resource.h"


HINSTANCE g_hInstance = NULL;
BOOL g_fLastResponse; // did the user hit ok to the last callback message?
extern MigrationWizard* g_migwiz;
extern BOOL g_fHaveNet; // OLD COMPUTER ONLY: this means we can use the network
extern BOOL g_fReadFromNetwork; // NEW COMPUTER ONLY: this means go ahead and read from the network immediately
extern BOOL g_fStoreToNetwork; // OLD COMPUTER ONLY: this means we've selected to store to the network
extern HWND g_hwndCurrent;
extern CRITICAL_SECTION g_csDialogCritSection;
extern CRITICAL_SECTION g_AppInfoCritSection;
extern BOOL g_fUberCancel;
DWORD g_HTMLErrArea = 0;
DWORD g_HTMLErrInstr = 0;
PCTSTR g_HTMLErrObjectType = NULL;
PCTSTR g_HTMLErrObjectName = NULL;

POBJLIST g_HTMLWrnFile = NULL;
POBJLIST g_HTMLWrnAltFile = NULL;
POBJLIST g_HTMLWrnRas = NULL;
POBJLIST g_HTMLWrnNet = NULL;
POBJLIST g_HTMLWrnPrn = NULL;
POBJLIST g_HTMLWrnGeneral = NULL;

TCHAR g_szMultiDests[20 * MAX_PATH];
BOOL g_fReceivedMultiDest = FALSE; // we only respond to the first multi-dest message we receive

extern MIG_PROGRESSPHASE g_AppInfoPhase;
extern UINT g_AppInfoSubPhase;
extern MIG_OBJECTTYPEID g_AppInfoObjectTypeId;
extern TCHAR g_AppInfoObjectName [4096];
extern TCHAR g_AppInfoText [4096];

MigrationWizard::MigrationWizard() : _fInit(FALSE), _pszUsername(NULL)
{
}

MigrationWizard::~MigrationWizard()
{
    CloseAppInf();

    // Destroy the fonts
    if (_hTitleFont)
    {
        DeleteObject(_hTitleFont);
        DeleteObject(_h95HeaderFont);
    }

    if (_pszUsername)
    {
        LocalFree(_pszUsername);
    }

    if (_fDelCs) {
        DeleteCriticalSection (&g_csDialogCritSection);
        _fDelCs = FALSE;
    }
}

HRESULT MigrationWizard::Init(HINSTANCE hInstance, LPTSTR pszUsername)
{
    HRESULT hr;
    BOOL fWinXP = FALSE;

    _hInstance = hInstance;
    if (pszUsername)
    {
        _pszUsername = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pszUsername) + 1) * sizeof (TCHAR));
        if (_pszUsername)
        {
            lstrcpy(_pszUsername, pszUsername);
        }
    }

    __try {
        InitializeCriticalSection (&g_csDialogCritSection);
    } __except (EXCEPTION_CONTINUE_EXECUTION) {
        // Might raise an out of memory exception
        // -1 ignores
    }
    _fDelCs = TRUE;

    __try {
        InitializeCriticalSection (&g_AppInfoCritSection);
    } __except (EXCEPTION_CONTINUE_EXECUTION) {
        // Might raise an out of memory exception
        // -1 ignores
    }

    // do we run in OOBE mode?  check for oobemode.dat in the curr dir
    _fOOBEMode = FALSE; // default
    TCHAR szPath[MAX_PATH];
    if (GetCurrentDirectory(ARRAYSIZE(szPath), szPath))
    {
        PathAppend(szPath, TEXT("oobemode.dat"));
        HANDLE hFile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (INVALID_HANDLE_VALUE != hFile)
        {
            _fOOBEMode = TRUE;
            CloseHandle(hFile);
        }
    }

    OpenAppInf(NULL);

    // do we run in legacy mode? (collect-only)
    UINT uiVer = GetVersion();
    _fLegacyMode = (uiVer >= 0x80000000 || LOBYTE(LOWORD(uiVer)) < 5);
    _fWin9X      = (uiVer >= 0x80000000);
    _fWinNT4     = (uiVer <  0x80000000 && LOBYTE(LOWORD(uiVer)) == 4);
    fWinXP       = ((uiVer <  0x80000000) && (LOBYTE(LOWORD(uiVer)) == 5) && (HIBYTE(LOWORD(uiVer)) >= 1));

#ifndef PRERELEASE
    // in release mode, run legacy on for Win2k
    if (HIBYTE(LOWORD(uiVer)) < 1)
    {
        _fLegacyMode = TRUE;
    }
#endif

    // do we run with old-style wizard?
    _fOldStyle = (uiVer >= 0x80000000 || LOBYTE(LOWORD(uiVer)) < 5); // hack, for now win9x is old-style


    // Init common controls
    INITCOMMONCONTROLSEX icex;

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    if (fWinXP) {
        icex.dwICC = ICC_USEREX_CLASSES | ICC_LINK_CLASS;
    } else {
        icex.dwICC = ICC_USEREX_CLASSES;
    }
    InitCommonControlsEx(&icex);

    // Init the imagelist
    SHFILEINFO sfi = {0};
    _hil = (HIMAGELIST)SHGetFileInfo(TEXT(".txt"), FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(sfi),
                                     SHGFI_SMALLICON | SHGFI_SYSICONINDEX | SHGFI_USEFILEATTRIBUTES);

    //
    //Create the Wizard pages
    //
    hr = _CreateWizardPages();

    if (SUCCEEDED(hr))
    {
        //Create the property sheet

        _psh.hInstance =         _hInstance;
        _psh.hwndParent =        NULL;
        _psh.phpage =            _rghpsp;
        if (!_fOldStyle)
        {
            _psh.dwSize =            sizeof(_psh);
            _psh.dwFlags =           PSH_WIZARD97|PSH_WATERMARK|PSH_HEADER;
            _psh.pszbmWatermark =    MAKEINTRESOURCE(IDB_WATERMARK);
            _psh.pszbmHeader =       MAKEINTRESOURCE(IDB_BANNER);
        }
        else
        {
            _psh.dwSize =  PROPSHEETHEADER_V1_SIZE;
            _psh.dwFlags = PSH_WIZARD;
        }
        _psh.nStartPage =        0;
        _psh.nPages =            NUMPAGES;


        //Set up the font for the titles on the intro and ending pages
        NONCLIENTMETRICS ncm = {0};
        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

        //Create the intro/end title font
        LOGFONT TitleLogFont = ncm.lfMessageFont;
        // ISSUE: we don't want to do this, this can break us on non-English builds.
        TitleLogFont.lfWeight = FW_BOLD;
        lstrcpy(TitleLogFont.lfFaceName, TEXT("MS Shell Dlg"));

        HDC hdc = GetDC(NULL); //gets the screen DC
        TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * 12 / 72;
        _hTitleFont = CreateFontIndirect(&TitleLogFont);


        CHAR szFontSize[MAX_LOADSTRING];
        DWORD dwFontSize = 8;
        if (LoadStringA(g_hInstance, IDS_WIN9X_HEADER_FONTSIZE, szFontSize, ARRAYSIZE(szFontSize))) {
            dwFontSize = strtoul(szFontSize, NULL, 10);
        }

        TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * dwFontSize / 72;
        lstrcpy(TitleLogFont.lfFaceName, TEXT("MS Shell Dlg"));
        _h95HeaderFont = CreateFontIndirect(&TitleLogFont);

        ReleaseDC(NULL, hdc);

        g_hInstance = _hInstance; // HACK: allows message callback to get an hinstance to load strings
    }

    return hr;
}

HRESULT MigrationWizard::Execute()
{
    //Display the wizard
    PropertySheet(&_psh);

    return S_OK;
}


#define WIZDLG(name, dlgproc)   \
            psp.dwFlags = _fOldStyle ? PSP_DEFAULT : PSP_DEFAULT|PSP_USEHEADERTITLE;\
            psp.pszHeaderTitle = _fOldStyle ? NULL : MAKEINTRESOURCE(IDS_##name##TITLE);\
            psp.pszHeaderSubTitle = NULL;\
            psp.pszTemplate = MAKEINTRESOURCE(IDD_##name##);\
            psp.pfnDlgProc = ##dlgproc##;\
            _rghpsp[uiCounter++] =  CreatePropertySheetPage(&psp)

#define WIZDLG_TITLE(name, dlgproc)   \
            psp.dwFlags = _fOldStyle ? PSP_DEFAULT : PSP_DEFAULT|PSP_HIDEHEADER;\
            psp.pszHeaderTitle = NULL;\
            psp.pszHeaderSubTitle = NULL;\
            psp.pszTemplate = MAKEINTRESOURCE(IDD_##name##);\
            psp.pfnDlgProc = ##dlgproc##;\
            _rghpsp[uiCounter++] =  CreatePropertySheetPage(&psp)

HRESULT MigrationWizard::_CreateWizardPages()
{
    UINT uiCounter = 0;

    PROPSHEETPAGE psp = {0}; //defines the property sheet page
    psp.dwSize =        sizeof(psp);
    psp.hInstance =     _hInstance;
    psp.lParam =        (LPARAM)this;

    //Opening page

    if (_fOOBEMode)
    {
        WIZDLG_TITLE(INTROOOBE, _IntroOOBEDlgProc);
    }
    else if (!_fLegacyMode)
    {
        WIZDLG_TITLE(INTRO, _IntroDlgProc);
    }
    else
    {
        WIZDLG_TITLE(INTROLEGACY, _IntroLegacyDlgProc);
    }

    // Interior pages
    WIZDLG(GETSTARTED, _GetStartedDlgProc);
    WIZDLG(ASKCD, _AskCDDlgProc);
    WIZDLG(DISKPROGRESS, _DiskProgressDlgProc);
    WIZDLG(DISKINSTRUCTIONS, _InstructionsDlgProc);
    WIZDLG(CDINSTRUCTIONS, _CDInstructionsDlgProc);
    WIZDLG(PICKAPPLYSTORE, _PickApplyStoreDlgProc);
    WIZDLG(APPLYPROGRESS, _ApplyProgressDlgProc);
    WIZDLG(WAIT, _StartEngineDlgProc);
    WIZDLG(PICKMETHOD, _PickMethodDlgProc);
    WIZDLG(CUSTOMIZE, _CustomizeDlgProc);
    WIZDLG(PICKCOLLECTSTORE, _PickCollectStoreDlgProc);
    WIZDLG(COLLECTPROGRESS, _CollectProgressDlgProc);
    WIZDLG(DIRECTCABLE, _DirectCableDlgProc);
    WIZDLG(FAILCLEANUP, _CleanUpDlgProc);
    WIZDLG(APPINSTALL, _AppInstallDlgProc);

    //Final pages
    WIZDLG_TITLE(ENDAPPLY, _EndApplyDlgProc);
    WIZDLG_TITLE(ENDAPPLYFAIL, _EndFailDlgProc);
    WIZDLG_TITLE(ENDCOLLECT, _EndCollectDlgProc);
    WIZDLG_TITLE(ENDCOLLECTNET, _EndCollectNetDlgProc);
    WIZDLG_TITLE(ENDCOLLECTFAIL, _EndFailDlgProc);
    WIZDLG_TITLE(ENDOOBE, _EndOOBEDlgProc);

    return S_OK;
}

// this lets us know if the user cancelled
void MigrationWizard::ResetLastResponse()
{
    g_fLastResponse = TRUE;
}

BOOL MigrationWizard::GetLastResponse()
{
    return g_fLastResponse;
}

INT_PTR CALLBACK _WaitDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return 0;
}

INT_PTR CALLBACK _DisplayPasswordDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static PPASSWORD_DATA passwordData = NULL;
    DWORD waitResult;

    switch (uMsg)
    {
    case WM_INITDIALOG :
        {
            passwordData = (PPASSWORD_DATA) lParam;
            if (passwordData) {
                if (passwordData->Key) {
                    SendMessageA (GetDlgItem(hwndDlg, IDC_DISPLAY_PASSWORD), WM_SETTEXT, 0, (LPARAM)passwordData->Key);
                }
            }
            SetTimer (hwndDlg, NULL, 100, NULL);
        }

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDCANCEL:
            EndDialog(hwndDlg, FALSE);
            return TRUE;
        }
        break;

    case WM_TIMER:
        if (passwordData) {
            waitResult = WaitForSingleObject (passwordData->Event, 0);
            if (waitResult != WAIT_TIMEOUT) {
                EndDialog(hwndDlg, FALSE);
                return TRUE;
            }
        }
    }

    return 0;
}

INT_PTR CALLBACK _GatherPasswordDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static PPASSWORD_DATA passwordData = NULL;
    DWORD waitResult;

    switch (uMsg)
    {
    case WM_INITDIALOG :
        {
            passwordData = (PPASSWORD_DATA) lParam;
            if (passwordData) {
                if (passwordData->Key) {
                    SendMessageA (GetDlgItem(hwndDlg, IDC_GATHER_PASSWORD), WM_SETTEXT, 0, (LPARAM)passwordData->Key);
                }
                Edit_LimitText(GetDlgItem(hwndDlg, IDC_GATHER_PASSWORD), passwordData->KeySize - 1);
            }
        }

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            if (passwordData && passwordData->Key) {
                SendMessageA (GetDlgItem(hwndDlg, IDC_GATHER_PASSWORD), WM_GETTEXT, passwordData->KeySize, (LPARAM)passwordData->Key);
                EndDialog(hwndDlg, TRUE);
            } else {
                EndDialog(hwndDlg, FALSE);
            }
            return TRUE;
        case IDCANCEL:
            EndDialog(hwndDlg, FALSE);
            return TRUE;
        }
        break;
    }

    return 0;
}

INT_PTR CALLBACK _ChooseDestDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_NOTIFY :
        switch (((LPNMHDR)lParam)->code)
        {
        case NM_DBLCLK:
            // On this dialog, this message can only come from the listview.
            // If there is something selected, that means the user doubleclicked on an item
            // On a doubleclick we will trigger the OK button
            if (ListView_GetSelectedCount(GetDlgItem(hwndDlg, IDC_DESTPICKER_LIST)) > 0)
            {
                SendMessage (GetDlgItem(hwndDlg, IDOK), BM_CLICK, 0, 0);
            }
            break;
        case LVN_ITEMCHANGED:
            if (ListView_GetSelectedCount(GetDlgItem(hwndDlg, IDC_DESTPICKER_LIST)) > 0)
            {
                Button_Enable(GetDlgItem(hwndDlg, IDOK), TRUE);
            }
            else
            {
                Button_Enable(GetDlgItem(hwndDlg, IDOK), FALSE);
            }
            break;
        }
        break;

    case WM_INITDIALOG :
        {
            HWND hwndList = GetDlgItem(hwndDlg, IDC_DESTPICKER_LIST);
            ListView_DeleteAllItems(hwndList);

            LVCOLUMN lvcolumn;
            lvcolumn.mask = LVCF_WIDTH;
            lvcolumn.cx = 250; // BUGBUG: should read width from box
            ListView_InsertColumn(hwndList, 0, &lvcolumn);

            LVITEM lvitem = {0};
            lvitem.mask = LVIF_TEXT;

            Button_Enable(GetDlgItem(hwndDlg, IDOK), FALSE);

            LPTSTR pszPtr = g_szMultiDests;

            BOOL fDone = FALSE;
            while (*pszPtr != NULL)
            {
                lvitem.iItem = lvitem.iItem = ListView_GetItemCount(hwndList);
                lvitem.pszText = pszPtr;
                ListView_InsertItem(hwndList, &lvitem);
                pszPtr += (lstrlen(pszPtr) + 1);
            }
        }

        return TRUE;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            {
                UINT uiSelected = ListView_GetSelectionMark(GetDlgItem(hwndDlg, IDC_DESTPICKER_LIST));
                ListView_GetItemText(GetDlgItem(hwndDlg, IDC_DESTPICKER_LIST), uiSelected, 0, g_szMultiDests, ARRAYSIZE(g_szMultiDests));
                g_szMultiDests[lstrlen(g_szMultiDests) + 1] = 0; // double-null terminate the multi-sz
                EndDialog(hwndDlg, TRUE);
                return TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, FALSE);
            return TRUE;
            break;
        }
        break;
    }

    return 0;
}

BOOL
_ExclusiveMessageBoxVaArgs (
    IN      PTSTR pszTitle,
    IN      BOOL RetryCancel,
    IN      DWORD dwResourceId,
    ...
)
{
    TCHAR szErrMsg[MAX_LOADSTRING];
    TCHAR szErrStr[MAX_LOADSTRING];
    va_list args;

    LoadString(g_hInstance, dwResourceId, szErrMsg, ARRAYSIZE(szErrMsg));

    va_start (args, dwResourceId);
    FormatMessage (FORMAT_MESSAGE_FROM_STRING, szErrMsg, 0, 0, (LPTSTR)szErrStr, ARRAYSIZE (szErrStr), &args);
    va_end (args);

    if (RetryCancel) {
        return (IDRETRY == _ExclusiveMessageBox (g_hwndCurrent,szErrStr,pszTitle,MB_RETRYCANCEL));
    } else {
        return (IDOK == _ExclusiveMessageBox (g_hwndCurrent,szErrStr,pszTitle,MB_OKCANCEL));
    }
}

PCTSTR
pGenerateNewNode (
    IN      PCTSTR OldNode
    )
{
    PTSTR newNode;
    PTSTR newNodePtr;
    PCTSTR result = NULL;

    newNode = (PTSTR)LocalAlloc (LPTR, (_tcslen (TEXT ("%CSIDL_PERSONAL%\\")) + _tcslen (OldNode) + 1) * sizeof (TCHAR));
    if (newNode) {
        _tcscpy (newNode, TEXT("%CSIDL_PERSONAL%\\"));
        _tcscat (newNode, OldNode);
        newNodePtr = _tcschr (newNode, TEXT(':'));
        while (newNodePtr) {
            *newNodePtr = TEXT('_');
            newNodePtr = _tcschr (newNode, TEXT(':'));
        }
        result = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, newNode, NULL);
        LocalFree ((PVOID)newNode);
    }
    return result;
}

BOOL
pForceRestoreObject (
    IN      MIG_OBJECTSTRINGHANDLE EncodedFileName,
    IN OUT  POBJLIST ObjList
    )
{
    MIG_CONTENT objectContent;
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    PCTSTR newNode = NULL;
    MIG_OBJECTSTRINGHANDLE newFileName;
    BOOL result = FALSE;

    if (IsmAcquireObject (MIG_FILE_TYPE | PLATFORM_SOURCE, EncodedFileName, &objectContent)) {
        // let's build the new name for this file
        if (IsmCreateObjectStringsFromHandle (EncodedFileName, &node, &leaf)) {
            if (node && leaf) {
                newNode = pGenerateNewNode (node);
                if (newNode) {
                    newFileName = IsmCreateObjectHandle (newNode, leaf);
                    if (newFileName) {
                        result = IsmReplacePhysicalObject (
                                    MIG_FILE_TYPE | PLATFORM_DESTINATION,
                                    newFileName,
                                    &objectContent
                                    );
                        if (result && ObjList) {
                            ObjList->AlternateName = (PTSTR)LocalAlloc (LPTR, (_tcslen (newFileName) + 1) * sizeof (TCHAR));
                            if (ObjList->AlternateName) {
                                _tcscpy (ObjList->AlternateName, newFileName);
                            }
                        }
                        IsmDestroyObjectHandle (newFileName);
                    }
                    IsmReleaseMemory (newNode);
                }
            }
            if (node) {
                IsmDestroyObjectString (node);
                node = NULL;
            }
            if (leaf) {
                IsmDestroyObjectString (leaf);
                leaf = NULL;
            }
        }
        IsmReleaseObject (&objectContent);
    }
    return result;
}

ULONG_PTR MessageCallback (UINT uiMsg, ULONG_PTR pArg)
{
    PRMEDIA_EXTRADATA extraData;
    PTRANSCOPY_ERROR transCopyError;
    PERRUSER_EXTRADATA errExtraData;
    PROLLBACK_USER_ERROR rollbackError;
    PPASSWORD_DATA passwordData;
    PMIG_APPINFO appInfo;
    PQUESTION_DATA questionData;
    int msgBoxReturn;
    TCHAR szTitle[MAX_LOADSTRING];
    LoadString(g_hInstance, IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
    TCHAR szErrMsg[MAX_LOADSTRING];
    TCHAR szErrStr[MAX_LOADSTRING];
    POBJLIST wrnObj = NULL;
    PCTSTR objectType = NULL;
    PCTSTR objectName = NULL;
    static DWORD dwTypeID = 0;

    switch (uiMsg)
    {
    case MODULEMESSAGE_ASKQUESTION:
        questionData = (PQUESTION_DATA) pArg;
        if (questionData) {
            if (MessageBox (g_hwndCurrent, questionData->Question, szTitle, questionData->MessageStyle) == questionData->WantedResult) {
                return APPRESPONSE_SUCCESS;
            } else {
                return APPRESPONSE_FAIL;
            }
        }
        return APPRESPONSE_SUCCESS;

    case ISMMESSAGE_APP_INFO:
    case ISMMESSAGE_APP_INFO_NOW:
        appInfo = (PMIG_APPINFO) pArg;
        if (appInfo) {
            EnterCriticalSection(&g_AppInfoCritSection);
            g_AppInfoPhase = appInfo->Phase;
            g_AppInfoSubPhase = appInfo->SubPhase;
            g_AppInfoObjectTypeId = appInfo->ObjectTypeId;
            if (appInfo->ObjectName) {
                _tcsncpy (g_AppInfoObjectName, appInfo->ObjectName, 4096);
            } else {
                g_AppInfoObjectName [0] = 0;
            }
            if (appInfo->Text) {
                _tcsncpy (g_AppInfoText, appInfo->Text, 4096);
            } else {
                g_AppInfoText [0] = 0;
            }
            LeaveCriticalSection(&g_AppInfoCritSection);
            if (uiMsg == ISMMESSAGE_APP_INFO_NOW) {
                SendMessage (g_hwndCurrent, WM_USER_STATUS, 0, 0);
            }
        }
        return APPRESPONSE_SUCCESS;

    case TRANSPORTMESSAGE_OLD_STORAGE:
        LoadString(g_hInstance, IDS_ENGERR_IMAGE_OLDFORMAT, szErrMsg, ARRAYSIZE(szErrMsg));
        _ExclusiveMessageBox (g_hwndCurrent, szErrMsg, szTitle, MB_OK);
        return 0;

    case TRANSPORTMESSAGE_IMAGE_EXISTS:
        LoadString(g_hInstance, IDS_ENGERR_IMAGE_EXISTS, szErrMsg, ARRAYSIZE(szErrMsg));
        g_fLastResponse = (IDYES == _ExclusiveMessageBox (g_hwndCurrent, szErrMsg, szTitle, MB_YESNO));
        return g_fLastResponse;

    case TRANSPORTMESSAGE_SIZE_SAVED:
        return APPRESPONSE_SUCCESS;

    case TRANSPORTMESSAGE_RMEDIA_LOAD:
    case TRANSPORTMESSAGE_RMEDIA_SAVE:
        extraData = (PRMEDIA_EXTRADATA) pArg;
        if (!extraData) {
            LoadString(g_hInstance, IDS_ENGERR_NEXT_MEDIA, szErrMsg, ARRAYSIZE(szErrMsg));
            g_fLastResponse = (IDOK == _ExclusiveMessageBox (g_hwndCurrent,szErrMsg,szTitle,MB_OKCANCEL));
        } else {
            switch (extraData->LastError)
            {
            case RMEDIA_ERR_NOERROR:
                if (uiMsg == TRANSPORTMESSAGE_RMEDIA_LOAD) {
                    g_fLastResponse = _ExclusiveMessageBoxVaArgs (
                                            szTitle,
                                            FALSE,
                                            IDS_ENGERR_INSERT_DEST_MEDIA_NUMBER,
                                            extraData->MediaNumber
                                            );
                } else {
                    if (extraData->MediaNumber == 1) {
                        DOUBLE sizeMB = (DOUBLE) extraData->TotalImageSize / (1024 * 1024);
                        UINT intMB = (UINT) sizeMB;
                        UINT decMB = (UINT) ((sizeMB - intMB) * 100);
                        UINT sizeF = (UINT) (sizeMB / 1.44);
                        UINT sizeZ = (UINT) (sizeMB / 100);
                        if (sizeF < 1) {
                            LoadString(g_hInstance, IDS_ENGERR_INSERT_FIRST_MEDIA1, szErrMsg, ARRAYSIZE(szErrMsg));
                            wsprintf (szErrStr, szErrMsg, intMB, decMB);
                        } else if (sizeZ < 1) {
                            LoadString(g_hInstance, IDS_ENGERR_INSERT_FIRST_MEDIA2, szErrMsg, ARRAYSIZE(szErrMsg));
                            wsprintf (szErrStr, szErrMsg, intMB, decMB, 1 + sizeF);
                        } else {
                            LoadString(g_hInstance, IDS_ENGERR_INSERT_FIRST_MEDIA3, szErrMsg, ARRAYSIZE(szErrMsg));
                            wsprintf (szErrStr, szErrMsg, intMB, decMB, 1 + sizeF, 1 + sizeZ);
                        }
                        g_fLastResponse = (IDOK == _ExclusiveMessageBox (g_hwndCurrent,szErrStr,szTitle,MB_OKCANCEL));
                    } else {
                        UINT iDisks;
                        ULONGLONG ullBytesPerDisk;
                        ullBytesPerDisk = extraData->TotalImageWritten / (extraData->MediaNumber - 1);
                        if (ullBytesPerDisk) {
                            iDisks = (UINT)(extraData->TotalImageSize / ullBytesPerDisk) + 1;
                            g_fLastResponse = _ExclusiveMessageBoxVaArgs (
                                                    szTitle,
                                                    FALSE,
                                                    IDS_ENGERR_INSERT_MEDIA_NUMBER,
                                                    extraData->MediaNumber,
                                                    iDisks
                                                    );
                        } else {
                            LoadString(g_hInstance, IDS_ENGERR_NEXT_MEDIA, szErrMsg, ARRAYSIZE(szErrMsg));
                            g_fLastResponse = (IDOK == _ExclusiveMessageBox (g_hwndCurrent,szErrMsg,szTitle,MB_OKCANCEL));
                        }
                    }
                }
                break;
            case RMEDIA_ERR_WRONGMEDIA:
                g_fLastResponse = _ExclusiveMessageBoxVaArgs (szTitle,
                                                              TRUE,
                                                              IDS_ENGERR_WRONG_MEDIA,
                                                              extraData->MediaNumber);
                break;
            case RMEDIA_ERR_USEDMEDIA:
                g_fLastResponse = _ExclusiveMessageBoxVaArgs (szTitle,
                                                              FALSE,
                                                              IDS_ENGERR_USED_MEDIA,
                                                              extraData->MediaNumber);
                break;
            case RMEDIA_ERR_DISKFULL:
                LoadString(g_hInstance, IDS_ENGERR_FULL, szErrMsg, ARRAYSIZE(szErrMsg));
                g_fLastResponse = (IDRETRY == _ExclusiveMessageBox (g_hwndCurrent,szErrMsg,szTitle,MB_RETRYCANCEL));
                break;
            case RMEDIA_ERR_NOTREADY:
                LoadString(g_hInstance, IDS_ENGERR_NOTREADY, szErrMsg, ARRAYSIZE(szErrMsg));
                g_fLastResponse = (IDRETRY == _ExclusiveMessageBox (g_hwndCurrent,szErrMsg,szTitle,MB_RETRYCANCEL));
                break;
            case RMEDIA_ERR_WRITEPROTECT:
                LoadString(g_hInstance, IDS_ENGERR_WRITEPROTECT, szErrMsg, ARRAYSIZE(szErrMsg));
                g_fLastResponse = (IDRETRY == _ExclusiveMessageBox (g_hwndCurrent,szErrMsg,szTitle,MB_RETRYCANCEL));
                break;
            case RMEDIA_ERR_CRITICAL:
                g_fLastResponse = FALSE;
                break;
            default:
                LoadString(g_hInstance, IDS_ENGERR_TOAST, szErrMsg, ARRAYSIZE(szErrMsg));
                g_fLastResponse = (IDRETRY == _ExclusiveMessageBox (g_hwndCurrent,szErrMsg,szTitle,MB_RETRYCANCEL));
            }
            return g_fLastResponse;
        }

    case TRANSPORTMESSAGE_READY_TO_CONNECT:
        // this message is received only on the new machine
        g_fReadFromNetwork = TRUE; // this means go ahead and read from the network immediately
        PropSheet_PressButton(GetParent(g_hwndCurrent), PSBTN_NEXT);
        return APPRESPONSE_SUCCESS;

    case TRANSPORTMESSAGE_MULTIPLE_DESTS:
        // this is received only on the old machine
        {
            if (g_fReceivedMultiDest)
            {
                return APPRESPONSE_SUCCESS;
            }
            else
            {
                g_fReceivedMultiDest = TRUE;
                ULONG_PTR uiRetVal = APPRESPONSE_FAIL;
                g_fHaveNet = FALSE; // disable network unless user chooses a destination
                TCHAR szDestinations[20 * MAX_PATH];
                if (IsmGetEnvironmentMultiSz (
                        PLATFORM_DESTINATION,
                        NULL,
                        TRANSPORT_ENVVAR_HOMENET_DESTINATIONS,
                        szDestinations,
                        ARRAYSIZE(szDestinations),
                        NULL
                        ))
                {
                    memcpy(g_szMultiDests, szDestinations, sizeof(TCHAR) * ARRAYSIZE(szDestinations));
                    if (_ExclusiveDialogBox(g_hInstance, MAKEINTRESOURCE(IDD_DESTPICKER), g_hwndCurrent, _ChooseDestDlgProc))
                    {
                        IsmSetEnvironmentMultiSz (
                            PLATFORM_DESTINATION,
                            NULL,
                            TRANSPORT_ENVVAR_HOMENET_DESTINATIONS,
                            g_szMultiDests
                            );
                        uiRetVal = APPRESPONSE_SUCCESS;
                        g_fHaveNet = TRUE; // re-enable network
                    }
                    else
                    {
                        g_fUberCancel = TRUE;
                        Engine_Cancel();
                    }
                }

                return uiRetVal;
            }
        }

    case ISMMESSAGE_EXECUTE_PREPROCESS:
        if (!g_migwiz->GetOOBEMode()) {
            AppExecute (g_migwiz->GetInstance(), g_hwndCurrent, (PCTSTR) pArg);
        }
        return APPRESPONSE_SUCCESS;

    case ISMMESSAGE_EXECUTE_REFRESH:
        if (!g_migwiz->GetOOBEMode() && !g_fUberCancel) {
            AppExecute (g_migwiz->GetInstance(), g_hwndCurrent, (PCTSTR) pArg);
        }
        return APPRESPONSE_SUCCESS;

    case ISMMESSAGE_EXECUTE_POSTPROCESS:
        if (!g_migwiz->GetOOBEMode()) {
            AppExecute (g_migwiz->GetInstance(), g_hwndCurrent, (PCTSTR) pArg);
        }
        return APPRESPONSE_SUCCESS;

    case ISMMESSAGE_EXECUTE_ROLLBACK:
        rollbackError = (PROLLBACK_USER_ERROR) pArg;
        if (rollbackError) {
            LoadString(g_hInstance, IDS_CANTROLLBACK, szErrMsg, ARRAYSIZE(szErrMsg));
            wsprintf (szErrStr, szErrMsg, rollbackError->UserDomain, rollbackError->UserName);
            _ExclusiveMessageBox (g_hwndCurrent,szErrStr,szTitle,MB_OK);
        }
        return APPRESPONSE_SUCCESS;

    case TRANSPORTMESSAGE_SRC_COPY_ERROR:
        transCopyError = (PTRANSCOPY_ERROR) pArg;
        if (transCopyError) {
            if (StrCmpI (transCopyError->ObjectType, TEXT("File")) == 0) {
                if ((transCopyError->Error == ERROR_SHARING_VIOLATION) ||
                    (transCopyError->Error == ERROR_LOCK_VIOLATION) ||
                    (transCopyError->Error == 0x80090020)   // found this on a WinME machine, when a file was locked
                    ) {
                    LoadString(g_hInstance, IDS_ENGERR_COPYSOURCE, szErrMsg, ARRAYSIZE(szErrMsg));
                    wsprintf (szErrStr, szErrMsg, transCopyError->ObjectName);
                    msgBoxReturn = _ExclusiveMessageBox (g_hwndCurrent,szErrStr,szTitle,MB_ABORTRETRYIGNORE | MB_DEFBUTTON2);
                    if (msgBoxReturn == IDRETRY) {
                        return APPRESPONSE_SUCCESS;
                    }
                    if (msgBoxReturn == IDIGNORE) {
                        return APPRESPONSE_IGNORE;
                    }
                    return APPRESPONSE_FAIL;
                }
                // we don't really know what was the problem here.
                // Let's just continue, at the end we will tell the
                // user about this file and he will copy it manually.
                return APPRESPONSE_IGNORE;
            }
        }
        return APPRESPONSE_FAIL;

    case MODULEMESSAGE_DISPLAYERROR:
        errExtraData = (PERRUSER_EXTRADATA) pArg;
        if (errExtraData && !g_HTMLErrArea) {
            switch (errExtraData->ErrorArea) {
                case ERRUSER_AREA_INIT:
                    g_HTMLErrArea = IDS_ERRORAREA_INIT;
                    break;
                case ERRUSER_AREA_GATHER:
                    g_HTMLErrArea = IDS_ERRORAREA_GATHER;
                    break;
                case ERRUSER_AREA_SAVE:
                    g_HTMLErrArea = IDS_ERRORAREA_SAVE;
                    break;
                case ERRUSER_AREA_LOAD:
                    g_HTMLErrArea = IDS_ERRORAREA_LOAD;
                    break;
                case ERRUSER_AREA_RESTORE:
                    g_HTMLErrArea = IDS_ERRORAREA_RESTORE;
                    break;
                default:
                    g_HTMLErrArea = IDS_ERRORAREA_UNKNOWN;
            }
            switch (errExtraData->Error) {
                case ERRUSER_ERROR_NOTRANSPORTPATH:
                    g_HTMLErrInstr = IDS_ERROR_NOTRANSPORTPATH;
                    break;
                case ERRUSER_ERROR_TRANSPORTPATHBUSY:
                case ERRUSER_ERROR_CANTEMPTYDIR:
                case ERRUSER_ERROR_ALREADYEXISTS:
                case ERRUSER_ERROR_CANTCREATEDIR:
                case ERRUSER_ERROR_CANTCREATESTATUS:
                case ERRUSER_ERROR_CANTWRITETODESTPATH:
                    g_HTMLErrInstr = IDS_ERROR_TRANSPORTNOACCESS;
                    break;
                case ERRUSER_ERROR_CANTCREATETEMPDIR:
                case ERRUSER_ERROR_CANTCREATECABFILE:
                case ERRUSER_ERROR_CANTSAVEINTERNALDATA:
                    g_HTMLErrInstr = IDS_ERROR_TRANSPORTINTERNALERROR;
                    break;
                case ERRUSER_ERROR_TRANSPORTINVALIDIMAGE:
                case ERRUSER_ERROR_CANTOPENSTATUS:
                case ERRUSER_ERROR_CANTREADIMAGE:
                    g_HTMLErrInstr = IDS_ERROR_TRANSPORTNOVALIDSOURCE;
                    break;
                case ERRUSER_ERROR_CANTFINDDESTINATION:
                case ERRUSER_ERROR_CANTSENDTODEST:
                    g_HTMLErrInstr = IDS_ERROR_HOMENETINVALIDDEST;
                    break;
                case ERRUSER_ERROR_CANTFINDSOURCE:
                case ERRUSER_ERROR_CANTRECEIVEFROMSOURCE:
                case ERRUSER_ERROR_INVALIDDATARECEIVED:
                    g_HTMLErrInstr = IDS_ERROR_HOMENETINVALIDSRC;
                    break;
                case ERRUSER_ERROR_NOENCRYPTION:
                    g_HTMLErrInstr = IDS_ERROR_HOMENETINVALIDENC;
                    break;
                case ERRUSER_ERROR_CANTUNPACKIMAGE:
                    g_HTMLErrInstr = IDS_ERROR_TRANSPORTINTERNALERROR;
                    break;
                case ERRUSER_ERROR_CANTSAVEOBJECT:
                case ERRUSER_ERROR_CANTRESTOREOBJECT:
                    if (errExtraData->ErrorArea == ERRUSER_AREA_SAVE) {
                        g_HTMLErrInstr = IDS_ERROR_CANTSAVEOBJECT;
                    } else {
                        g_HTMLErrInstr = IDS_ERROR_CANTRESTOREOBJECT;
                    }
                    if (errExtraData->ObjectTypeId && errExtraData->ObjectName) {
                        objectType = IsmGetObjectTypeName (errExtraData->ObjectTypeId);
                        if (objectType) {
                            objectName = IsmGetNativeObjectName (errExtraData->ObjectTypeId, errExtraData->ObjectName);
                            if (objectName) {
                                if (StrCmpI (objectType, TEXT("File")) == 0) {
                                    wrnObj = _AllocateObjectList (objectName);
                                    wrnObj->Next = g_HTMLWrnFile;
                                    g_HTMLWrnFile = wrnObj;
                                } else if (StrCmpI (objectType, TEXT("RasConnection")) == 0) {
                                    wrnObj = _AllocateObjectList (objectName);
                                    wrnObj->Next = g_HTMLWrnRas;
                                    g_HTMLWrnRas = wrnObj;
                                } else if (StrCmpI (objectType, TEXT("MappedDrives")) == 0) {
                                    wrnObj = _AllocateObjectList (objectName);
                                    wrnObj->Next = g_HTMLWrnNet;
                                    g_HTMLWrnNet = wrnObj;
                                } else if (StrCmpI (objectType, TEXT("Printers")) == 0) {
                                    wrnObj = _AllocateObjectList (objectName);
                                    wrnObj->Next = g_HTMLWrnPrn;
                                    g_HTMLWrnPrn = wrnObj;
                                }
                                IsmReleaseMemory (objectName);
                                objectName = NULL;
                            }
                            objectType = NULL;
                        }
                    }
                    break;
                case ERRUSER_WARNING_OUTLOOKRULES:
                    g_HTMLErrInstr = IDS_ERROR_CANTRESTOREOBJECT;
                    LoadString(g_hInstance, IDS_WARNING_OUTLOOKRULES, szErrMsg, ARRAYSIZE(szErrMsg));
                    wrnObj = _AllocateObjectList (szErrMsg);
                    wrnObj->Next = g_HTMLWrnGeneral;
                    g_HTMLWrnGeneral = wrnObj;
                    break;
                case ERRUSER_WARNING_OERULES:
                    g_HTMLErrInstr = IDS_ERROR_CANTRESTOREOBJECT;
                    LoadString(g_hInstance, IDS_WARNING_OERULES, szErrMsg, ARRAYSIZE(szErrMsg));
                    wrnObj = _AllocateObjectList (szErrMsg);
                    wrnObj->Next = g_HTMLWrnGeneral;
                    g_HTMLWrnGeneral = wrnObj;
                    break;
                case ERRUSER_ERROR_DISKSPACE:
                    g_HTMLErrInstr = IDS_ERROR_DISKSPACE;
                    break;
            }
        }
        return APPRESPONSE_SUCCESS;

    case MODULEMESSAGE_DISPLAYWARNING:
        errExtraData = (PERRUSER_EXTRADATA) pArg;
        if (errExtraData) {
            switch (errExtraData->Error) {
                case ERRUSER_ERROR_CANTSAVEOBJECT:
                case ERRUSER_ERROR_CANTRESTOREOBJECT:
                    if (errExtraData->ObjectTypeId && errExtraData->ObjectName) {
                        objectType = IsmGetObjectTypeName (errExtraData->ObjectTypeId);
                        if (objectType) {
                            objectName = IsmGetNativeObjectName (errExtraData->ObjectTypeId, errExtraData->ObjectName);
                            if (objectName) {
                                if (StrCmpI (objectType, TEXT("File")) == 0) {
                                    // If we are restoring this file, we are going to try
                                    // to write it to a default location where the user
                                    // can find it later
                                    if (errExtraData->Error == ERRUSER_ERROR_CANTRESTOREOBJECT) {
                                        wrnObj = _AllocateObjectList (objectName);
                                        if (pForceRestoreObject (errExtraData->ObjectName, wrnObj)) {
                                            wrnObj->Next = g_HTMLWrnAltFile;
                                            g_HTMLWrnAltFile = wrnObj;
                                        } else {
                                            wrnObj->Next = g_HTMLWrnFile;
                                            g_HTMLWrnFile = wrnObj;
                                        }
                                    } else {
                                        wrnObj = _AllocateObjectList (objectName);
                                        wrnObj->Next = g_HTMLWrnFile;
                                        g_HTMLWrnFile = wrnObj;
                                    }
                                } else if (StrCmpI (objectType, TEXT("RasConnection")) == 0) {
                                    wrnObj = _AllocateObjectList (objectName);
                                    wrnObj->Next = g_HTMLWrnRas;
                                    g_HTMLWrnRas = wrnObj;
                                } else if (StrCmpI (objectType, TEXT("MappedDrives")) == 0) {
                                    wrnObj = _AllocateObjectList (objectName);
                                    wrnObj->Next = g_HTMLWrnNet;
                                    g_HTMLWrnNet = wrnObj;
                                } else if (StrCmpI (objectType, TEXT("Printers")) == 0) {
                                    wrnObj = _AllocateObjectList (objectName);
                                    wrnObj->Next = g_HTMLWrnPrn;
                                    g_HTMLWrnPrn = wrnObj;
                                }
                                IsmReleaseMemory (objectName);
                                objectName = NULL;
                            }
                            objectType = NULL;
                        }
                    }
                    break;
            }
        }
        return APPRESPONSE_SUCCESS;

    case TRANSPORTMESSAGE_NET_DISPLAY_PASSWORD:
        passwordData = (PPASSWORD_DATA) pArg;
        if (passwordData) {
            DialogBoxParam (
                g_hInstance,
                MAKEINTRESOURCE(IDD_DISPLAY_PASSWORD),
                g_hwndCurrent,
                _DisplayPasswordDlgProc,
                (LPARAM)passwordData
                );
        }
        return APPRESPONSE_SUCCESS;

    case TRANSPORTMESSAGE_NET_GATHER_PASSWORD:
        passwordData = (PPASSWORD_DATA) pArg;
        if (passwordData) {
            if (DialogBoxParam (
                    g_hInstance,
                    MAKEINTRESOURCE(IDD_GATHER_PASSWORD),
                    g_hwndCurrent,
                    _GatherPasswordDlgProc,
                    (LPARAM)passwordData
                    )) {
                return APPRESPONSE_SUCCESS;
            }
        }
        return APPRESPONSE_FAIL;
    }
    return FALSE;
}

HRESULT MigrationWizard::_InitEngine(BOOL fSource, BOOL* pfNetworkDetected)
{
    HRESULT hr;

    TCHAR szAppPath[MAX_PATH] = TEXT("");
    TCHAR* pszAppPathOffset;

    GetModuleFileName (NULL, szAppPath, ARRAYSIZE(szAppPath));
    pszAppPathOffset = _tcsrchr (szAppPath, TEXT('\\'));
    if (pszAppPathOffset) {
        pszAppPathOffset ++;
    } else {
        pszAppPathOffset = szAppPath;
    }
    _tcsncpy (pszAppPathOffset, TEXT("migism.inf"), ARRAYSIZE(szAppPath) - (pszAppPathOffset - szAppPath));


    hr = Engine_Initialize(szAppPath, fSource, TRUE, _pszUsername, MessageCallback, pfNetworkDetected);

    if (SUCCEEDED(hr))
    {
        _fInit = TRUE;

        _tcsncpy (pszAppPathOffset, TEXT("migwiz.inf"), ARRAYSIZE(szAppPath) - (pszAppPathOffset - szAppPath));
        hr = Engine_AppendScript(fSource, szAppPath);

        if (SUCCEEDED(hr))
        {
            _tcsncpy (pszAppPathOffset, TEXT("usmtdef.inf"), ARRAYSIZE(szAppPath) - (pszAppPathOffset - szAppPath));
            hr = Engine_AppendScript(fSource, szAppPath);
        }

        if (SUCCEEDED(hr))
        {
            _tcsncpy (pszAppPathOffset, TEXT("migapp.inf"), ARRAYSIZE(szAppPath) - (pszAppPathOffset - szAppPath));
            hr = Engine_AppendScript(fSource, szAppPath);
        }

        if (SUCCEEDED(hr))
        {
            _tcsncpy (pszAppPathOffset, TEXT("migsys.inf"), ARRAYSIZE(szAppPath) - (pszAppPathOffset - szAppPath));
            hr = Engine_AppendScript(fSource, szAppPath);
        }

        if (SUCCEEDED(hr))
        {
            _tcsncpy (pszAppPathOffset, TEXT("miguser.inf"), ARRAYSIZE(szAppPath) - (pszAppPathOffset - szAppPath));
            hr = Engine_AppendScript(fSource, szAppPath);
        }

        if (SUCCEEDED(hr))
        {
            _tcsncpy (pszAppPathOffset, TEXT("sysfiles.inf"), ARRAYSIZE(szAppPath) - (pszAppPathOffset - szAppPath));
            hr = Engine_AppendScript(fSource, szAppPath);
        }

        if (fSource)
        {
            if (SUCCEEDED(hr))
            {
                hr = Engine_Parse();
            }
        }
    }

    return hr;
}

HRESULT MigrationWizard::SelectComponentSet(UINT uSelectionGroup)
{
    if (_fOOBEMode)
    {
        Engine_SelectComponentSet(MIGINF_SELECT_OOBE);
    }
    else
    {
        Engine_SelectComponentSet(uSelectionGroup);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\migwiz.h ===
#ifndef _MIGWIZ_HXX_
#define _MIGWIZ_HXX_

#include <shlobj.h>

#define NUMPAGES 22

#define ENGINE_RULE_MAXLEN 4000

#define ENGINE_NOTINIT              0
#define ENGINE_INITGATHER           1
#define ENGINE_INITAPPLY            2

// custom window messages

#define WM_USER_FINISHED        (WM_APP + 1)
#define WM_USER_CANCELLED       (WM_APP + 2)
#define WM_USER_THREAD_COMPLETE (WM_APP + 3)
#define WM_USER_CANCEL_PENDING  (WM_APP + 4)
#define WM_USER_STATUS          (WM_APP + 5)
#define WM_USER_ROLLBACK        (WM_APP + 6)

// device bit entries

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x) / sizeof((x)[0]))
#endif

class MigrationWizard
{
public:
    MigrationWizard();
    ~MigrationWizard();

    HRESULT Init(HINSTANCE hinstance, LPTSTR pszUsername);
    HRESULT Execute();

    HINSTANCE  GetInstance()     { return _hInstance; }
    HFONT      GetTitleFont()    { return _hTitleFont; }
    HFONT      Get95HeaderFont() { return _h95HeaderFont; }
    HIMAGELIST GetImageList()    { return _hil; }

    BOOL GetLegacy()   { return _fLegacyMode; }
    BOOL GetWin9X()    { return _fWin9X; }
    BOOL GetWinNT4()   { return _fWinNT4; }
    BOOL GetOOBEMode() { return _fOOBEMode; }
    BOOL GetOldStyle() { return _fOldStyle; }

    void ResetLastResponse();
    BOOL GetLastResponse();

    HRESULT SelectComponentSet(UINT uSelectionGroup);

private:  // helper functions
    HRESULT _CreateWizardPages();
    HRESULT _InitEngine(BOOL fSource, BOOL* pfNetworkDetected);

protected: // friend WinProcs
    friend INT_PTR CALLBACK _CollectProgressDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend DWORD WINAPI     _CollectProgressDlgProcThread (LPVOID lpParam);
    friend INT_PTR CALLBACK _ApplyProgressDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend DWORD WINAPI     _ApplyProgressDlgProcThread (LPVOID lpParam);
    friend INT_PTR CALLBACK _DiskProgressDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK _PickMethodDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend DWORD WINAPI     _StartEngineDlgProcThread (LPVOID lpParam);

    // other friend functions
    friend BOOL             _HandleCancel (HWND hwndDlg, BOOL PressNext);

private:
    LPTSTR          _pszUsername;       // username specified
    HFONT           _hTitleFont;        // The title font for the Welcome and Completion pages
    HFONT           _h95HeaderFont;     // The title font for the Wizard 95 interior page header titles
    HINSTANCE       _hInstance;         // HInstance the wizard is run in
    HPROPSHEETPAGE  _rghpsp[NUMPAGES];  // an array to hold the page's HPROPSHEETPAGE handles
    PROPSHEETHEADER _psh;               // defines the property sheet
    HIMAGELIST      _hil;               // shell's small image list
    BOOL            _fInit;             // has the engine been initialized yet
    BOOL            _fOOBEMode;         // are we running on from an OOBE floppy?
    BOOL            _fLegacyMode;       // are we running on a downlevel (non-whistler) machine?
    BOOL            _fWin9X;            // are we running on a Win9X machine?
    BOOL            _fWinNT4;           // are we running on a WinNT4 machine?
    BOOL            _fOldStyle;         // are we running the old-style wizard?
    BOOL            _fDelCs;            // delete critical section on terminate?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\migtask.cpp ===
#include <windowsx.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <stdio.h>
#include <winioctl.h>
#include "resource.h"

#include "migtask.h"
#include "migwiz.h"
#include "migwnprc.h"
#include "migutil.h"
#include "miginf.h"
#include "migeng.h"

extern "C" {
#include "cablib.h"
}

#define MAX_LOADSTRING 1024

extern BOOL g_fUberCancel;

CCABHANDLE g_hCabHandle = NULL;
#define S_MIGWIZCAB TEXT("migwiz.cab")
#define S_TOOLDISK TEXT("DSK%05X")
#define S_DONOTCOMPRESS TEXT("NO_COMPRESS")
#define S_DONOTFAIL TEXT("NO_FAIL")

typedef struct {
    HWND hwndProgress;
    HWND hwndPropSheet;
    BOOL fSource;
    BOOL* pfHasUserCancelled;
} PROGRESSCALLBACKSTRUCT;

#define PHASEWIDTH_S_BEGINGAP                 200
#define PHASEWIDTH_S_ENDGAP                   200
#define PHASEWIDTH_S_QUEUE_HIGHPRIORITY       200
#define PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY    200
#define PHASEWIDTH_S_GATHER_HIGHPRIORITY      400
#define PHASEWIDTH_S_QUEUE_GATHER             800
#define PHASEWIDTH_S_ESTIMATE_GATHER          800
#define PHASEWIDTH_S_GATHER_GATHER           2400
#define PHASEWIDTH_S_ANALYSIS                 200
#define PHASEWIDTH_S_TRANSPORT               5000
#define PHASEWIDTH_S_TOTAL                   (PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY \
                                            + PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY + PHASEWIDTH_S_GATHER_HIGHPRIORITY \
                                            + PHASEWIDTH_S_QUEUE_GATHER + PHASEWIDTH_S_ESTIMATE_GATHER \
                                            + PHASEWIDTH_S_GATHER_GATHER + PHASEWIDTH_S_ANALYSIS \
                                            + PHASEWIDTH_S_TRANSPORT + PHASEWIDTH_S_ENDGAP)

#define PHASEWIDTH_D_BEGINGAP                 150
#define PHASEWIDTH_D_ENDGAP                   150
#define PHASEWIDTH_D_TRANSPORT               2000
#define PHASEWIDTH_D_QUEUE_HIGHPRIORITY        50
#define PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY     50
#define PHASEWIDTH_D_GATHER_HIGHPRIORITY      100
#define PHASEWIDTH_D_QUEUE_GATHER              50
#define PHASEWIDTH_D_ESTIMATE_GATHER           50
#define PHASEWIDTH_D_GATHER_GATHER            100
#define PHASEWIDTH_D_ANALYSIS                 500
#define PHASEWIDTH_D_APPLY                   5000
#define PHASEWIDTH_D_TOTAL                   (PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                                            + PHASEWIDTH_D_QUEUE_HIGHPRIORITY + PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY \
                                            + PHASEWIDTH_D_GATHER_HIGHPRIORITY + PHASEWIDTH_D_QUEUE_GATHER \
                                            + PHASEWIDTH_D_ESTIMATE_GATHER + PHASEWIDTH_D_GATHER_GATHER \
                                            + PHASEWIDTH_D_ANALYSIS + PHASEWIDTH_D_APPLY \
                                            + PHASEWIDTH_D_ENDGAP)

VOID WINAPI ProgressCallback (MIG_PROGRESSPHASE Phase, MIG_PROGRESSSTATE State, UINT uiWorkDone, UINT uiTotalWork, ULONG_PTR pArg)
{
    PROGRESSCALLBACKSTRUCT* ppcs = (PROGRESSCALLBACKSTRUCT*)pArg;

    if (!g_fUberCancel) {
        INT iWork = 0;
        INT iPhaseWidth = 0;
        INT iTotal = ppcs->fSource ? PHASEWIDTH_S_TOTAL : PHASEWIDTH_D_TOTAL;

        if (ppcs->fSource)
        {
            switch (Phase)
            {
            case MIG_HIGHPRIORITYQUEUE_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP;
                iPhaseWidth = PHASEWIDTH_S_QUEUE_HIGHPRIORITY;
                break;
            case MIG_HIGHPRIORITYESTIMATE_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY;
                iPhaseWidth = PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY;
                break;
            case MIG_HIGHPRIORITYGATHER_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY \
                      + PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY;
                iPhaseWidth = PHASEWIDTH_S_GATHER_HIGHPRIORITY;
                break;
            case MIG_GATHERQUEUE_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY \
                      + PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY + PHASEWIDTH_S_GATHER_HIGHPRIORITY;
                iPhaseWidth = PHASEWIDTH_S_QUEUE_GATHER;
                break;
            case MIG_GATHERESTIMATE_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY \
                      + PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY + PHASEWIDTH_S_GATHER_HIGHPRIORITY \
                      + PHASEWIDTH_S_QUEUE_GATHER;
                iPhaseWidth = PHASEWIDTH_S_ESTIMATE_GATHER;
                break;
            case MIG_GATHER_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY \
                      + PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY + PHASEWIDTH_S_GATHER_HIGHPRIORITY \
                      + PHASEWIDTH_S_QUEUE_GATHER + PHASEWIDTH_S_ESTIMATE_GATHER;
                iPhaseWidth = PHASEWIDTH_S_GATHER_GATHER;
                break;
            case MIG_ANALYSIS_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY \
                      + PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY + PHASEWIDTH_S_GATHER_HIGHPRIORITY \
                      + PHASEWIDTH_S_QUEUE_GATHER + PHASEWIDTH_S_ESTIMATE_GATHER \
                      + PHASEWIDTH_S_GATHER_GATHER;
                iPhaseWidth = PHASEWIDTH_S_ANALYSIS;
                break;
            case MIG_TRANSPORT_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY \
                      + PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY + PHASEWIDTH_S_GATHER_HIGHPRIORITY \
                      + PHASEWIDTH_S_QUEUE_GATHER + PHASEWIDTH_S_ESTIMATE_GATHER \
                      + PHASEWIDTH_S_GATHER_GATHER + PHASEWIDTH_S_ANALYSIS;
                iPhaseWidth = PHASEWIDTH_S_TRANSPORT;
                break;
            }
        }
        else
        {
            switch (Phase)
            {
            case MIG_TRANSPORT_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP;
                iPhaseWidth = PHASEWIDTH_D_TRANSPORT;
                break;
            case MIG_HIGHPRIORITYQUEUE_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT;
                iPhaseWidth = PHASEWIDTH_D_QUEUE_HIGHPRIORITY;
                break;
            case MIG_HIGHPRIORITYESTIMATE_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                       +PHASEWIDTH_D_QUEUE_HIGHPRIORITY;
                iPhaseWidth = PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY;
                break;
            case MIG_HIGHPRIORITYGATHER_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                      + PHASEWIDTH_D_QUEUE_HIGHPRIORITY + PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY;
                iPhaseWidth = PHASEWIDTH_D_GATHER_HIGHPRIORITY;
                break;
            case MIG_GATHERQUEUE_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                      + PHASEWIDTH_D_QUEUE_HIGHPRIORITY + PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY \
                      + PHASEWIDTH_D_GATHER_HIGHPRIORITY;
                iPhaseWidth = PHASEWIDTH_D_QUEUE_GATHER;
                break;
            case MIG_GATHERESTIMATE_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                      + PHASEWIDTH_D_QUEUE_HIGHPRIORITY + PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY \
                      + PHASEWIDTH_D_GATHER_HIGHPRIORITY + PHASEWIDTH_D_QUEUE_GATHER;
                iPhaseWidth = PHASEWIDTH_D_ESTIMATE_GATHER;
                break;
            case MIG_GATHER_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                      + PHASEWIDTH_D_QUEUE_HIGHPRIORITY + PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY \
                      + PHASEWIDTH_D_GATHER_HIGHPRIORITY + PHASEWIDTH_D_QUEUE_GATHER \
                      + PHASEWIDTH_D_ESTIMATE_GATHER;
                iPhaseWidth = PHASEWIDTH_D_GATHER_GATHER;
                break;
            case MIG_ANALYSIS_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                      + PHASEWIDTH_D_QUEUE_HIGHPRIORITY + PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY \
                      + PHASEWIDTH_D_GATHER_HIGHPRIORITY + PHASEWIDTH_D_QUEUE_GATHER \
                      + PHASEWIDTH_D_ESTIMATE_GATHER + PHASEWIDTH_D_GATHER_GATHER;
                iPhaseWidth = PHASEWIDTH_D_ANALYSIS;
                break;
            case MIG_APPLY_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                      + PHASEWIDTH_D_QUEUE_HIGHPRIORITY + PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY \
                      + PHASEWIDTH_D_GATHER_HIGHPRIORITY + PHASEWIDTH_D_QUEUE_GATHER \
                      + PHASEWIDTH_D_ESTIMATE_GATHER + PHASEWIDTH_D_GATHER_GATHER \
                      + PHASEWIDTH_D_ANALYSIS;
                iPhaseWidth = PHASEWIDTH_D_APPLY;
                break;
            }
        }

        if (State == MIG_END_PHASE)
        {
            iWork += iPhaseWidth;
        }
        else if (uiTotalWork && uiWorkDone)
        {
            iWork += (iPhaseWidth * uiWorkDone) / uiTotalWork;
        }

        SendMessage(ppcs->hwndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, iTotal));
        SendMessage(ppcs->hwndProgress, PBM_SETPOS, iWork, 0);

    }
}


VOID WINAPI pFillProgressBar (ULONG_PTR pArg)
{
    PROGRESSCALLBACKSTRUCT* ppcs = (PROGRESSCALLBACKSTRUCT*)pArg;

    if (!g_fUberCancel) {
        INT iWork = ppcs->fSource ? PHASEWIDTH_S_TOTAL : PHASEWIDTH_D_TOTAL;
        INT iTotal = ppcs->fSource ? PHASEWIDTH_S_TOTAL : PHASEWIDTH_D_TOTAL;

        SendMessage(ppcs->hwndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, iTotal));
        SendMessage(ppcs->hwndProgress, PBM_SETPOS, iWork, 0);
    }
}


//////////////////////////////////////////////////////////
// prepare data

HRESULT _DoCopy(LPTSTR tszTransportPath, HWND hwndProgress, HWND hwndPropSheet, BOOL* pfHasUserCancelled)
{
    HRESULT hr = E_OUTOFMEMORY;

    PROGRESSCALLBACKSTRUCT* ppcs = (PROGRESSCALLBACKSTRUCT*)CoTaskMemAlloc(sizeof(PROGRESSCALLBACKSTRUCT));
    if (ppcs)
    {
        ppcs->hwndProgress = hwndProgress;
        ppcs->hwndPropSheet = hwndPropSheet;
        ppcs->fSource = TRUE;
        ppcs->pfHasUserCancelled = pfHasUserCancelled;
        hr = Engine_RegisterProgressBarCallback (ProgressCallback, (ULONG_PTR)ppcs);
    }


    if (SUCCEEDED(hr))
    {
        // start the transport
        hr = Engine_StartTransport (TRUE, tszTransportPath, NULL, NULL); // start non-network transport

        if (SUCCEEDED(hr))
        {
            hr = Engine_Execute(TRUE);
        }

        if (SUCCEEDED(hr))
        {
            Engine_Terminate();
        }
    }

    if (ppcs) {
        pFillProgressBar ((ULONG_PTR)ppcs);
    }

    return hr;
}

//////////////////////////////////////////////////////////
// apply data

HRESULT _DoApply(LPTSTR tszTransportPath, HWND hwndProgress, HWND hwndPropSheet, BOOL* pfHasUserCancelled,
                 PROGRESSBARFN pAltProgressFunction, ULONG_PTR puAltProgressParam)
{
    HRESULT hr;
    PROGRESSCALLBACKSTRUCT* ppcs = NULL;
    BOOL imageIsValid = FALSE, imageExists = FALSE;

    if (NULL != pAltProgressFunction)
    {
        hr = Engine_RegisterProgressBarCallback(pAltProgressFunction, puAltProgressParam);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        ppcs = (PROGRESSCALLBACKSTRUCT*)CoTaskMemAlloc(sizeof(PROGRESSCALLBACKSTRUCT));
        if (ppcs)
        {
            ppcs->hwndProgress = hwndProgress;
            ppcs->hwndPropSheet = hwndPropSheet;
            ppcs->fSource = FALSE;
            ppcs->pfHasUserCancelled = pfHasUserCancelled;
            hr = Engine_RegisterProgressBarCallback(ProgressCallback, (ULONG_PTR)ppcs);
        }
    }

    if (SUCCEEDED(hr))
    {
        if (tszTransportPath) // if not network
        {
            hr = Engine_StartTransport(FALSE, tszTransportPath, &imageIsValid, &imageExists); // start non-network transport
        }
        else
        {
            // it's network
            imageIsValid = TRUE;
            imageExists = TRUE;
        }

        if (SUCCEEDED(hr) && imageIsValid && imageExists)
        {
            hr = Engine_Execute(FALSE);

            if (SUCCEEDED(hr))
            {
                Engine_Terminate();
            }
        }
    }

    if (ppcs)
    {
        pFillProgressBar ((ULONG_PTR)ppcs);
    }

    return hr;
}

//////////////////////////////////////////////////////////
// create tool disk data

BOOL _CopyFileToDisk(LPCTSTR pctszSrcFname, LPCTSTR pctszSrcPath, LPCTSTR pctszDestPath, LPCTSTR pctszDestFname,
                     HINSTANCE hInstance, HWND hwndParent,
                     BOOL fCompress, BOOL fFailOnError)
{
    TCHAR tszSysDir[MAX_PATH];
    TCHAR tszFnameSrc[MAX_PATH];
    TCHAR tszFnameDest[MAX_PATH];
    UINT uFnameTchars;
    BOOL fCopySuccess = FALSE;

    if (pctszDestFname == NULL ||
        *pctszDestFname == NULL)
    {
        pctszDestFname = pctszSrcFname;
    }

    uFnameTchars = lstrlen (pctszSrcFname) + 1;

    // Build Source path+filename
    StrCpyN(tszFnameSrc, pctszSrcPath, ARRAYSIZE(tszFnameSrc) - uFnameTchars);
    PathAppend(tszFnameSrc, pctszSrcFname);

    if (!fCompress)
    {
        // Build Dest path+filename
        StrCpyN(tszFnameDest, pctszDestPath, ARRAYSIZE(tszFnameDest) - uFnameTchars);
        PathAppend(tszFnameDest, pctszDestFname);
    }

    // if source file does not exist, try using the system directory (case is shfolder.dll)
    if (0xFFFFFFFF == GetFileAttributes (tszFnameSrc))
    {
        GetSystemDirectory (tszSysDir, ARRAYSIZE(tszSysDir));
        StrCpyN(tszFnameSrc, tszSysDir, ARRAYSIZE(tszFnameSrc) - uFnameTchars);
        PathAppend(tszFnameSrc, pctszSrcFname);
    }

    if (fCompress)
    {
        // Add to migwiz.cab
        fCopySuccess = CabAddFileToCabinet( g_hCabHandle, tszFnameSrc, pctszDestFname );
    }
    else
    {
        // do the actual copy
        fCopySuccess = CopyFile(tszFnameSrc, tszFnameDest, FALSE);
    }

    if (fFailOnError) {
        return fCopySuccess;
    }
    return TRUE;
}

VOID
pDisplayCopyError (
    HWND hwndParent,
    HINSTANCE hInstance,
    DWORD Error
    )
{
    UINT resId;
    TCHAR szMigrationWizardTitle[MAX_LOADSTRING];

    LoadString(hInstance, IDS_MIGWIZTITLE, szMigrationWizardTitle, ARRAYSIZE(szMigrationWizardTitle));

    if (hwndParent) // Stand-alone wizard mode
    {
        TCHAR szErrDiskLoad[MAX_LOADSTRING];
        resId = IDS_ERRORDISK;
        if (Error == ERROR_WRITE_PROTECT) {
            resId = IDS_ENGERR_WRITEPROTECT;
        }
        if (Error == ERROR_NOT_READY) {
            resId = IDS_ENGERR_NOTREADY;
        }
        if (Error == ERROR_DISK_FULL) {
            resId = IDS_ENGERR_FULL;
        }
        LoadString(hInstance, resId, szErrDiskLoad, ARRAYSIZE(szErrDiskLoad));
        _ExclusiveMessageBox(hwndParent, szErrDiskLoad, szMigrationWizardTitle, MB_OK);
    }
}

HRESULT _CopyInfToDisk(LPCTSTR pctszDestPath, LPCTSTR pctszSourcePath, LPCTSTR pctszInfPath,
                       PMESSAGECALLBACK2 progressCallback, LPVOID lpparam,
                       HWND hwndProgressBar, HWND hwndParent, HINSTANCE hInstance,
                       BOOL* pfHasUserCancelled, DWORD* pfError)
{
    HRESULT hr = S_OK;
    TCHAR szCabPath [MAX_PATH];

    if (pfError) {
        *pfError = ERROR_SUCCESS;
    }

    __try {

        // copy the actual files over
        OpenAppInf((LPTSTR)pctszInfPath);

        if (INVALID_HANDLE_VALUE != g_hMigWizInf)
        {
            INFCONTEXT context;
            LONG cLinesProcessed = 0;
            LONG cLines = SetupGetLineCount(g_hMigWizInf, TEXT("CopyFiles")) + 1;  // Last one is for closing the CAB

            if (SetupFindFirstLine(g_hMigWizInf, TEXT("CopyFiles"), NULL, &context))
            {
                if (!pctszDestPath) {
                    hr = E_FAIL;
                    __leave;
                }

                if (_tcslen(pctszDestPath) + _tcslen(S_MIGWIZCAB) + 1 >= MAX_PATH) {
                    hr = E_FAIL;
                    __leave;
                }

                // Delete the existing CAB that might be on the disk
                StrCpy (szCabPath, pctszDestPath);
                StrCat (szCabPath, S_MIGWIZCAB);
                SetFileAttributes (szCabPath, FILE_ATTRIBUTE_NORMAL);
                if (!DeleteFile (szCabPath)) {
                    if (GetLastError () != ERROR_FILE_NOT_FOUND) {
                        if (pfError) {
                            *pfError = GetLastError ();
                        }
                        hr = E_FAIL;
                        __leave;
                    }
                }

                g_hCabHandle = CabCreateCabinet( pctszDestPath, S_MIGWIZCAB, S_TOOLDISK, IsmGetTempFile, 0 );
                if (g_hCabHandle)
                {
                    do
                    {
                        TCHAR szFname[MAX_PATH];

                        if (*pfHasUserCancelled) {
                            hr = E_ABORT;
                            __leave;
                        }

                        if (SetupGetStringField(&context, 1, szFname, ARRAYSIZE(szFname), NULL))
                        {
                            TCHAR szDestFname[MAX_PATH] = TEXT("");
                            BOOL fCompress = TRUE;
                            BOOL fFailOnError = TRUE;
                            if (SetupGetStringField(&context, 2, szDestFname, ARRAYSIZE(szDestFname), NULL))
                            {
                                if (!StrCmpI(szDestFname, S_DONOTCOMPRESS))
                                {
                                    fCompress = FALSE;
                                    *szDestFname = 0;
                                }
                                else if (!StrCmpI(szDestFname, S_DONOTFAIL))
                                {
                                    fFailOnError = FALSE;
                                    *szDestFname = 0;
                                }
                                else
                                {
                                    TCHAR szCompress[MAX_PATH];
                                    if (SetupGetStringField(&context, 3, szCompress, ARRAYSIZE(szCompress), NULL))
                                    {
                                        if (!StrCmpI(szCompress, S_DONOTCOMPRESS))
                                        {
                                            fCompress = FALSE;
                                            *szCompress = 0;
                                        }
                                        else if (!StrCmpI(szDestFname, S_DONOTFAIL))
                                        {
                                            fFailOnError = FALSE;
                                            *szCompress = 0;
                                        }
                                    }
                                }
                            }
                            if (!_CopyFileToDisk(szFname, pctszSourcePath, pctszDestPath, szDestFname,
                                            hInstance, hwndParent, fCompress, fFailOnError))
                            {
                                if (pfError) {
                                    *pfError = GetLastError ();
                                }
                                hr = E_FAIL;
                            }

                            cLinesProcessed++;

                            if (hwndProgressBar) // Stand-alone wizard mode
                            {
                                SendMessage(hwndProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, cLines));
                                SendMessage(hwndProgressBar, PBM_SETPOS, cLinesProcessed, 0);
                            }

                            if (progressCallback) // OOBE mode
                            {
                                progressCallback(lpparam, cLinesProcessed, cLines);
                            }
                        }
                    } while (SetupFindNextLine(&context, &context));

                    if (*pfHasUserCancelled) {
                        hr = E_ABORT;
                        __leave;
                    }

                    if (!CabFlushAndCloseCabinet(g_hCabHandle)) {
                        if (pfError) {
                            *pfError = GetLastError ();
                        }
                        hr = E_FAIL;
                        __leave;
                    };

                    if (*pfHasUserCancelled) {
                        hr = E_ABORT;
                        __leave;
                    }

                    // Now that the CAB is complete, show the progress bar as finished
                    if (hwndProgressBar) // Stand-alone wizard mode
                    {
                        SendMessage(hwndProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, cLines));
                        SendMessage(hwndProgressBar, PBM_SETPOS, cLines, 0);
                    }

                    if (progressCallback) // OOBE mode
                    {
                        progressCallback(lpparam, cLines, cLines);
                    }
                } else {
                    if (pfError) {
                        *pfError = GetLastError ();
                    }
                    hr = E_FAIL;
                    __leave;
                }
            }
        } else {
            if (pfError) {
                *pfError = ERROR_INTERNAL_ERROR;
            }
            hr = E_FAIL;
            __leave;
        }
    }
    __finally {
    }

    if (hwndParent)
    {
        if (!SUCCEEDED(hr) && (hr != E_ABORT)) {
            pDisplayCopyError (hwndParent, hInstance, *pfError);
            SendMessage(hwndParent, WM_USER_CANCELLED, 0, 0);
        } else {
            SendMessage(hwndParent, WM_USER_FINISHED, 0, 0);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\migutil.cpp ===
#include <windowsx.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <stdio.h>
#include <winioctl.h>
#include "resource.h"
#include "migutil.h"
#include "migwiz.h"
#include <tlhelp32.h>
#include <tchar.h>
#include <shlobjp.h>

extern "C" {
#include "ism.h"
#include "modules.h"
}

PTSTR g_Explorer = NULL;

/////////////////
// definitions

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) ((sizeof(x)) / (sizeof(x[0])))
#endif

CRITICAL_SECTION g_csDialogCritSection;
BOOL g_fUberCancel;
BOOL g_LogOffSystem = FALSE;
BOOL g_RebootSystem = FALSE;
BOOL g_OFStatus = FALSE;

//////////////////////////////////////////////////////////////////////////////////////

LPSTR _ConvertToAnsi(UINT cp, LPCWSTR pcwszSource)
{
    // Locals
    HRESULT     hr=S_OK;
    INT         cchNarrow;
    INT         cchWide;
    LPSTR       pszDup=NULL;

    // No Source
    if (pcwszSource == NULL)
        goto exit;

    // Length
    cchWide = lstrlenW(pcwszSource) + 1;

    // Determine how much space is needed for translated widechar
    cchNarrow = WideCharToMultiByte(cp, 0, pcwszSource, cchWide, NULL, 0, NULL, NULL);

    // Error
    if (cchNarrow == 0)
        goto exit;

    // Alloc temp buffer
    pszDup = (LPSTR)LocalAlloc(LPTR, cchNarrow + 1);
    if (NULL == pszDup)
    {
        goto exit;
    }

    // Do the actual translation
    cchNarrow = WideCharToMultiByte(cp, 0, pcwszSource, cchWide, pszDup, cchNarrow + 1, NULL, NULL);

    // Error
    if (cchNarrow == 0)
    {
        if (NULL != pszDup)
        {
            free(pszDup);
        }
        goto exit;
    }

exit:
    // Done
    return(pszDup);
}

//////////////////////////////////////////////////////////////////////////////////////

LPWSTR _ConvertToUnicode(UINT cp, LPCSTR pcszSource)
{
    // Locals
    HRESULT     hr=S_OK;
    INT         cchNarrow;
    INT         cchWide;
    LPWSTR      pwszDup=NULL;

    // No Source
    if (pcszSource == NULL)
        goto exit;

    // Length
    cchNarrow = lstrlenA(pcszSource) + 1;

    // Determine how much space is needed for translated widechar
    cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, NULL, 0);

    // Error
    if (cchWide == 0)
        goto exit;

    // Alloc temp buffer
    pwszDup = (LPWSTR)LocalAlloc(LPTR, cchWide * sizeof (WCHAR));
    if (NULL == pwszDup)
    {
        goto exit;
    }

    // Do the actual translation
    cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, pwszDup, cchWide+1);

    // Error
    if (cchWide == 0)
    {
        if (NULL != pwszDup)
        {
            free(pwszDup);
        }
        goto exit;
    }

exit:
    // Done
    return pwszDup;
}

//////////////////////////////////////////////////////////////////////////////////////

HRESULT _SHUnicodeToAnsi(LPWSTR pwszIn, LPSTR pszOut, UINT cchOut)
{
    // Locals
    HRESULT     hr = E_INVALIDARG;
    INT         cchNarrow;
    INT         cchWide;

    // No Source
    if (pwszIn && pszOut)
    {
        // Length
        cchWide = lstrlenW(pwszIn) + 1;

        // Determine how much space is needed for translated widechar
        cchNarrow = WideCharToMultiByte(CP_ACP, 0, pwszIn, cchWide, NULL, 0, NULL, NULL);

        // Error
        if (cchNarrow > 0)
        {

            // Do the actual translation
            cchNarrow = WideCharToMultiByte(CP_ACP, 0, pwszIn, cchWide, pszOut, cchNarrow + 1, NULL, NULL);

            if (cchNarrow)
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////

HRESULT _SHAnsiToUnicode(LPSTR pszIn, LPWSTR pwszOut, UINT cchOut)
{
    // Locals
    HRESULT     hr = E_INVALIDARG;
    INT         cchNarrow;
    INT         cchWide;

    // No Source
    if (pszIn && pwszOut)
    {

        // Length
        cchNarrow = lstrlenA(pszIn) + 1;

        // Determine how much space is needed for translated widechar
        cchWide = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszIn, cchNarrow, NULL, 0);

        // Error
        if (cchWide > 0)
        {

            // Do the actual translation
            cchWide = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszIn, cchNarrow, pwszOut, cchWide+1);

            if (cchWide > 0)
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////

#ifdef UNICODE
#define _StrRetToBuf _StrRetToBufW
#else
#define _StrRetToBuf _StrRetToBufA
#endif

#ifdef NONAMELESSUNION
#define NAMELESS_MEMBER(member) DUMMYUNIONNAME.##member
#else
#define NAMELESS_MEMBER(member) member
#endif

#define STRRET_OLESTR  STRRET_WSTR          // same as STRRET_WSTR
#define STRRET_OFFPTR(pidl,lpstrret) ((LPSTR)((LPBYTE)(pidl)+(lpstrret)->NAMELESS_MEMBER(uOffset)))

STDAPI _StrRetToBufA(STRRET *psr, LPCITEMIDLIST pidl, LPSTR pszBuf, UINT cchBuf)
{
    HRESULT hres = E_FAIL;

    switch (psr->uType)
    {
    case STRRET_WSTR:
        {
            LPWSTR pszStr = psr->pOleStr;   // temp copy because SHUnicodeToAnsi may overwrite buffer
            if (pszStr)
            {
                _SHUnicodeToAnsi(pszStr, pszBuf, cchBuf);
                CoTaskMemFree(pszStr);

                // Make sure no one thinks things are allocated still
                psr->uType = STRRET_CSTR;
                psr->cStr[0] = 0;

                hres = S_OK;
            }
        }
        break;

    case STRRET_CSTR:
        StrCpyNA (pszBuf, psr->cStr, cchBuf);
        hres = S_OK;
        break;

    case STRRET_OFFSET:
        if (pidl)
        {
            StrCpyNA (pszBuf, STRRET_OFFPTR(pidl, psr), cchBuf);
            hres = S_OK;
        }
        break;
    }

    if (FAILED(hres) && cchBuf)
        *pszBuf = 0;

    return hres;
}

STDAPI _StrRetToBufW(STRRET *psr, LPCITEMIDLIST pidl, LPWSTR pszBuf, UINT cchBuf)
{
    HRESULT hres = E_FAIL;

    switch (psr->uType)
    {
    case STRRET_WSTR:
        {
            LPWSTR pwszTmp = psr->pOleStr;
            if (pwszTmp)
            {
                StrCpyNW(pszBuf, pwszTmp, cchBuf);
                CoTaskMemFree(pwszTmp);

                // Make sure no one thinks things are allocated still
                psr->uType = STRRET_CSTR;
                psr->cStr[0] = 0;

                hres = S_OK;
            }
        }
        break;

    case STRRET_CSTR:
        _SHAnsiToUnicode(psr->cStr, pszBuf, cchBuf);
        hres = S_OK;
        break;

    case STRRET_OFFSET:
        if (pidl)
        {
            _SHAnsiToUnicode(STRRET_OFFPTR(pidl, psr), pszBuf, cchBuf);
            hres = S_OK;
        }
        break;
    }

    if (FAILED(hres) && cchBuf)
        *pszBuf = 0;

    return hres;
}

//////////////////////////////////////////////////////////////////////////////////////


INT_PTR _ExclusiveDialogBox(HINSTANCE hInstance, LPCTSTR lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc)
{
    INT_PTR iRetVal = -1;
    EnterCriticalSection(&g_csDialogCritSection);
    if (!g_fUberCancel)
    {
        iRetVal = DialogBoxParam(hInstance, lpTemplate, hWndParent, lpDialogFunc, (LPARAM)hWndParent);
    }
    LeaveCriticalSection(&g_csDialogCritSection);
    return iRetVal;
}

int _ExclusiveMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)
{
    int iRetVal = -1;
    EnterCriticalSection(&g_csDialogCritSection);
    if (!g_fUberCancel)
    {
        iRetVal = MessageBox(hWnd, lpText, lpCaption, uType);
    }
    LeaveCriticalSection(&g_csDialogCritSection);
    return iRetVal;
}

//////////////////////////////////////////////////////////////////////////////////////

int _ComboBoxEx_AddString(HWND hwndBox, LPTSTR ptsz)
{
    COMBOBOXEXITEM item = {0};

    item.mask = CBEIF_TEXT;
    item.iItem = ComboBox_GetCount(hwndBox);
    item.pszText = ptsz;

    return (INT) SendMessage(hwndBox, CBEM_INSERTITEM, 0, (LONG_PTR)&item);
}

//////////////////////////////////////////////////////////////////////////////////////

int _ComboBoxEx_SetItemData(HWND hwndBox, UINT iDex, LPARAM lParam)
{
    COMBOBOXEXITEM item = {0};

    item.mask = CBEIF_LPARAM;
    item.iItem = iDex;
    item.lParam = lParam;

    return (INT) SendMessage(hwndBox, CBEM_SETITEM, 0, (LONG_PTR)&item);
}

//////////////////////////////////////////////////////////////////////////////////////

int _ComboBoxEx_SetIcon(HWND hwndBox, LPTSTR sz, UINT iDex)
{
    SHFILEINFO sfi = {0};
    COMBOBOXEXITEM item = {0};

    DWORD dwFlags = SHGFI_SMALLICON | SHGFI_SYSICONINDEX | SHGFI_USEFILEATTRIBUTES;

    if (SHGetFileInfo(sz, FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(sfi), dwFlags)) {

        item.mask = CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
        item.iItem = iDex;
        item.iImage = sfi.iIcon;
        item.iSelectedImage = sfi.iIcon;

        return (INT) SendMessage(hwndBox, CBEM_SETITEM, 0, (LONG_PTR)&item);
    }
    return -1;
}

//////////////////////////////////////////////////////////////////////////////////////

int _GetRemovableDriveCount()
{
    int iCount = 0;
    TCHAR szDrive[4] = TEXT("A:\\");
    for (UINT uiCount = 0; uiCount < 26; uiCount++)
    {
        szDrive[0] = TEXT('A') + uiCount;

        if (DRIVE_REMOVABLE == GetDriveType(szDrive))
        {
            iCount++;
        }
    }

    return iCount;
}

//////////////////////////////////////////////////////////////////////////////////////

TCHAR _GetRemovableDrive(int iDex)
{
    int iCount = iDex;

    TCHAR szDrive[4] = TEXT("?:\\");
    for (UINT uiCount = 0; uiCount < 26; uiCount++)
    {
        szDrive[0] = TEXT('A') + uiCount;

        if (DRIVE_REMOVABLE == GetDriveType(szDrive))
        {
            if (!(iCount--))
            {
                return szDrive[0];
            }
        }
    }

    // ASSERT(FALSE);
    return '0'; // ERROR
}

//////////////////////////////////////////////////////////////////////////////////////

LPTSTR _GetRemovableDrivePretty(int iDex)
{
    HRESULT hr;
    LPTSTR pszRetVal = NULL;

    WCHAR wszDrive[4] = L"A:\\";
    wszDrive[0] = L'A' + _GetRemovableDrive(iDex) - TEXT('A');

    IShellFolder* psfDesktop;
    hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlDrive;
        hr = psfDesktop->ParseDisplayName(NULL, NULL, wszDrive, NULL, &pidlDrive, NULL);
        if (SUCCEEDED(hr))
        {
            STRRET strret;
            hr = psfDesktop->GetDisplayNameOf(pidlDrive, SHGDN_INFOLDER, &strret);
            if (SUCCEEDED(hr))
            {
                TCHAR szDisplayName[MAX_PATH];
                if (SUCCEEDED(_StrRetToBuf(&strret, pidlDrive, szDisplayName, ARRAYSIZE(szDisplayName))))
                {
                    pszRetVal = StrDup(szDisplayName);
                }
            }
        }
    }

    return pszRetVal;
}

//////////////////////////////////////////////////////////////////////////////////////

BOOL _IsRemovableOrCDDrive(TCHAR chDrive)
{
    UINT result = 0;
    if ( (chDrive >= TEXT('A') && chDrive <= TEXT('Z')) || (chDrive >= TEXT('a') && chDrive <= TEXT('z')))
    {
        TCHAR szDrive[4] = TEXT("A:\\");
        szDrive[0] = chDrive;
        result = GetDriveType (szDrive);
        return ((result == DRIVE_REMOVABLE) || (result == DRIVE_CDROM));
    }
    return FALSE;
}

BOOL _IsValidDrive(TCHAR chDrive)
{
    UINT result;

    if ( (chDrive >= TEXT('A') && chDrive <= TEXT('Z')) || (chDrive >= TEXT('a') && chDrive <= TEXT('z')))
    {
        TCHAR szDrive[4] = TEXT("A:\\");
        szDrive[0] = chDrive;
        result = GetDriveType(szDrive);
        if ((result == DRIVE_UNKNOWN) ||
            (result == DRIVE_NO_ROOT_DIR)
            ) {
            return FALSE;
        }
        return TRUE;
    }
    return FALSE;
}

BOOL _IsValidStorePath(PCTSTR pszStore)
{
    return (((pszStore[1] == TEXT(':')) && (pszStore[2] == TEXT('\\')) && (_IsValidDrive (pszStore [0]))) ||
            ((pszStore[0] == TEXT('\\')) && (pszStore[1] == TEXT('\\')) && (_tcschr (pszStore + 2, TEXT('\\')) != NULL)));
}

BOOL _CreateFullDirectory(PCTSTR pszPath)
{
    TCHAR pathCopy [MAX_PATH];
    PTSTR p;
    BOOL b = TRUE;

    StrCpyN (pathCopy, pszPath, ARRAYSIZE(pathCopy));

    //
    // Advance past first directory
    //

    if (pathCopy[1] == TEXT(':') && pathCopy[2] == TEXT('\\')) {
        //
        // <drive>:\ case
        //

        p = _tcschr (&pathCopy[3], TEXT('\\'));

    } else if (pathCopy[0] == TEXT('\\') && pathCopy[1] == TEXT('\\')) {

        //
        // UNC case
        //

        p = _tcschr (pathCopy + 2, TEXT('\\'));
        if (p) {
            p = _tcschr (p + 1, TEXT('\\'));
            if (p) {
                p = _tcsinc (p);
                if (p) {
                    p = _tcschr (p, TEXT('\\'));
                }
            }
        }

    } else {

        //
        // Relative dir case
        //

        p = _tcschr (pathCopy, TEXT('\\'));
    }

    //
    // Make all directories along the path
    //

    while (p) {

        *p = 0;
        b = CreateDirectory (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }

        if (!b) {
            break;
        }

        *p = TEXT('\\');
        p = _tcsinc (p);
        if (p) {
            p = _tcschr (p + 1, TEXT('\\'));
        }
    }

    //
    // At last, make the FullPath directory
    //

    if (b) {
        b = CreateDirectory (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }
    }

    return b;
}

PTSTR
pGoBack (
    IN      PTSTR LastChar,
    IN      PTSTR FirstChar,
    IN      UINT NumWacks
    )
{
    LastChar = _tcsdec (FirstChar, LastChar);
    while (NumWacks && LastChar && (LastChar >= FirstChar)) {
        if (_tcsnextc (LastChar) == TEXT('\\')) {
            NumWacks --;
        }
        LastChar = _tcsdec (FirstChar, LastChar);
    }
    if (NumWacks) {
        return NULL;
    }
    return LastChar + 2;
}

UINT
pCountDots (
    IN      PCTSTR PathSeg
    )
{
    UINT numDots = 0;

    while (PathSeg && *PathSeg) {
        if (_tcsnextc (PathSeg) != TEXT('.')) {
            return 0;
        }
        numDots ++;
        PathSeg = _tcsinc (PathSeg);
    }
    return numDots;
}

PCTSTR
_SanitizePath (
    IN      PCTSTR FileSpec
    )
{
    TCHAR pathSeg [MAX_PATH];
    PCTSTR wackPtr;
    UINT dotNr;
    PTSTR newPath = (PTSTR)IsmDuplicateString (FileSpec);
    PTSTR newPathPtr = newPath;
    BOOL firstPass = TRUE;
    UINT max;
    BOOL removeLastWack = FALSE;

    do {
        removeLastWack = FALSE;

        ZeroMemory (pathSeg, sizeof (pathSeg));

        wackPtr = _tcschr (FileSpec, TEXT('\\'));

        if (wackPtr) {
            if (firstPass && (wackPtr == FileSpec)) {
                // this one starts with a wack, let's see if we have double wacks
                wackPtr = _tcsinc (wackPtr);
                if (!wackPtr) {
                    IsmReleaseMemory (newPath);
                    return NULL;
                }
                if (_tcsnextc (wackPtr) == TEXT('\\')) {
                    // this one starts with a double wack
                    wackPtr = _tcsinc (wackPtr);
                    if (!wackPtr) {
                        IsmReleaseMemory (newPath);
                        return NULL;
                    }
                    wackPtr = _tcschr (wackPtr, TEXT('\\'));
                } else {
                    wackPtr = _tcschr (wackPtr, TEXT('\\'));
                }
            }
            firstPass = FALSE;
            if (wackPtr) {
                max = (wackPtr - FileSpec) * sizeof (TCHAR);
                CopyMemory (pathSeg, FileSpec, min (MAX_PATH * sizeof (TCHAR), max));
                FileSpec = _tcsinc (wackPtr);
            } else {
                max = _tcslen (FileSpec) * sizeof (TCHAR);
                CopyMemory (pathSeg, FileSpec, min (MAX_PATH * sizeof (TCHAR), max));
            }
        } else {
            max = _tcslen (FileSpec) * sizeof (TCHAR);
            if (max == 0) {
                removeLastWack = TRUE;
            }
            CopyMemory (pathSeg, FileSpec, min (MAX_PATH * sizeof (TCHAR), max));
        }

        if (*pathSeg) {
            dotNr = pCountDots (pathSeg);
            if (dotNr>1) {

                newPathPtr = pGoBack (newPathPtr, newPath, dotNr);

                if (newPathPtr == NULL) {
                    IsmReleaseMemory (newPath);
                    return NULL;
                }
            } else if (dotNr != 1) {
                _tcscpy (newPathPtr, pathSeg);
                newPathPtr = _tcschr (newPathPtr, 0);
                if (wackPtr) {
                    *newPathPtr = TEXT('\\');
                    //we increment this because we know that \ is a single byte character.
                    newPathPtr ++;
                }
            } else {
                removeLastWack = TRUE;
            }
        }
    } while (wackPtr);

    if (removeLastWack && (newPathPtr > newPath)) {
        newPathPtr --;
    }
    *newPathPtr = 0;

    return newPath;
}

BOOL _IsValidStore(LPTSTR pszStore, BOOL bCreate, HINSTANCE hinst, HWND hwnd)
{
    TCHAR szSerialStr[] = TEXT("COM");
    TCHAR szParallelStr[] = TEXT("LPT");
    PTSTR lpExpStore;
    PCTSTR sanitizedStore;
    BOOL fValid = FALSE;
    //
    //  Skip past leading space, since PathIsDirectory() on Win9x
    //  incorrectly assumes spaces are a valid dir.
    //

    while (_istspace (*pszStore))
        pszStore++;

    //
    //  No relative paths allowed.
    //

    if (*pszStore == TEXT('.'))
        return FALSE;

    if ((_tcsnicmp (pszStore, szSerialStr, (sizeof (szSerialStr) / sizeof (TCHAR)) - 1) == 0) ||
        (_tcsnicmp (pszStore, szParallelStr, (sizeof (szParallelStr) / sizeof (TCHAR)) - 1) == 0)
        ) {
        return TRUE;
    }

    lpExpStore = (PTSTR)IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, pszStore, NULL);

    sanitizedStore = _SanitizePath (lpExpStore);

    if (sanitizedStore) {

        if (PathIsDirectory(sanitizedStore)) // if a normal directory
        {
            fValid = TRUE;
        }
        else if (lstrlen(sanitizedStore) == 3 && sanitizedStore[1] == TEXT(':') && sanitizedStore[2] == TEXT('\\') && _IsRemovableOrCDDrive(sanitizedStore[0]))
        {
            fValid = TRUE;
        }
        else if (lstrlen(sanitizedStore) == 2 && sanitizedStore[1] == TEXT(':') && _IsRemovableOrCDDrive(sanitizedStore[0]))
        {
            fValid = TRUE;
        }
        else
        {
            if ((bCreate) && (_IsValidStorePath (sanitizedStore))) {
                TCHAR szTitle[MAX_LOADSTRING];
                TCHAR szLoadString[MAX_LOADSTRING];
                LoadString(hinst, IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
                LoadString(hinst, IDS_ASKCREATEDIR, szLoadString, ARRAYSIZE(szLoadString));
                if (_ExclusiveMessageBox(hwnd, szLoadString, szTitle, MB_YESNO) == IDYES) {
                    if (_CreateFullDirectory (sanitizedStore)) {
                        fValid = TRUE;
                    }
                }
            }
        }

        if (fValid) {
            _tcsncpy (pszStore, sanitizedStore, MAX_PATH);
        }

        IsmReleaseMemory (sanitizedStore);
        sanitizedStore = NULL;
    }

    IsmReleaseMemory (lpExpStore);

    return fValid;
}

//////////////////////////////////////////////////////////////////////////////////////

INT _ComboBoxEx_AddDrives(HWND hwndBox)
{
    INT result = -1;

    ComboBox_ResetContent(hwndBox);

    WCHAR wszDrive[4] = L"A:\\";
    TCHAR szDrive[4] = TEXT("A:\\");

    for (UINT uiCount = 0; uiCount < (UINT)_GetRemovableDriveCount(); uiCount++)
    {
        szDrive[0] = _GetRemovableDrive(uiCount);

        int iDex = _ComboBoxEx_AddString(hwndBox, _GetRemovableDrivePretty(uiCount));
        _ComboBoxEx_SetIcon(hwndBox, szDrive, iDex);
        _ComboBoxEx_SetItemData(hwndBox, iDex, (LPARAM)StrDup(szDrive));
        result = 0;
    }
    ComboBox_SetCurSel(hwndBox, result);
    return result;
}

//////////////////////////////////////////////////////////////////////////////////////

BOOL
pIsComPortAccessible (
    PCTSTR ComPort
    )
{
    HANDLE comPortHandle = NULL;

    comPortHandle = CreateFile (ComPort, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (comPortHandle != INVALID_HANDLE_VALUE) {
        CloseHandle (comPortHandle);
        return TRUE;
    }
    return FALSE;
}

INT _ComboBoxEx_AddCOMPorts(HWND hwndBox, INT SelectedPort)
{
    INT iDex;
    INT index = 1;
    INT added = -1;
    TCHAR comPort [] = TEXT("COM0");

    if (hwndBox) {
        // clear the combo box content
        SendMessage (hwndBox, CB_RESETCONTENT, 0, 0);
    }

    while (index < 10) {
        comPort [ARRAYSIZE(comPort) - 2] ++;
        if (pIsComPortAccessible (comPort)) {
            if (hwndBox) {
                iDex = SendMessage (hwndBox, CB_ADDSTRING, 0, (LPARAM)comPort);
                SendMessage (hwndBox, CB_SETITEMDATA, (WPARAM)iDex, (LPARAM)StrDup(comPort));
            }
            added ++;
        }
        index ++;
    }
    if (added == -1) {
        return -1;
    }
    if ((added >= SelectedPort) && (SelectedPort != -1)) {
        if (hwndBox) {
            ComboBox_SetCurSel(hwndBox, SelectedPort);
        }
        return SelectedPort;
    }
    if (hwndBox) {
        // We want nothing to be selected in this combo box, this
        // is intentional.
        ComboBox_SetCurSel(hwndBox, -1);
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////////////

int _GetIcon(LPTSTR psz)
{
    SHFILEINFO sfi = {0};

    SHGetFileInfo(psz, FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(sfi), SHGFI_SMALLICON | SHGFI_SYSICONINDEX);

    return sfi.iIcon;
}

//////////////////////////////////////////////////////////////////////////////////////

HRESULT _ListView_AddDrives(HWND hwndList, LPTSTR pszNetworkName)
{
    HRESULT hr = E_FAIL;

    if (ListView_DeleteAllItems(hwndList))
    {
        LVITEM item = {0};
        item.mask = LVIF_IMAGE | LVIF_PARAM | LVIF_TEXT;

        if (pszNetworkName)
        {
            item.iItem = 0; // first item
            item.pszText = pszNetworkName;
            item.iImage = 0; // ISSUE: 0 is icon for sharing, is there a better way to do this?
            item.lParam = NULL;
            ListView_InsertItem(hwndList, &item);
        }

        IShellFolder* psfDesktop;
        hr = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hr))
        {
            WCHAR wszDrive[4] = L"?:\\";
            TCHAR tszDrive[4] = TEXT("?:\\");
            for (int iDrive = 0; iDrive < _GetRemovableDriveCount(); iDrive++)
            {
                tszDrive[0] = _GetRemovableDrive(iDrive);
                wszDrive[0] = L'A' + tszDrive[0] - TEXT('A');

                LPITEMIDLIST pidlDrive;
                hr = psfDesktop->ParseDisplayName(NULL, NULL, wszDrive, NULL, &pidlDrive, NULL);
                if (SUCCEEDED(hr))
                {
                    STRRET strret;
                    hr = psfDesktop->GetDisplayNameOf(pidlDrive, SHGDN_INFOLDER, &strret);
                    if (SUCCEEDED(hr))
                    {
                        TCHAR szDisplayName[MAX_PATH];
                        hr = _StrRetToBuf(&strret, pidlDrive, szDisplayName, ARRAYSIZE(szDisplayName));
                        if (SUCCEEDED(hr))
                        {
                            item.iItem = 27; // this will force adding at the end
                            item.pszText = szDisplayName;
                            item.iImage = _GetIcon(tszDrive);
                            item.lParam = (LPARAM)StrDup(tszDrive);

                            ListView_InsertItem(hwndList, &item);
                        }
                    }
                }
            }
        }
    }
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////

HRESULT _CreateAnimationCtrl(HWND hwndDlg, HINSTANCE hinst, UINT idMarker, UINT idAnim, UINT idAvi, HWND* pHwndAnim)
{
    HWND hwndAnim = NULL;
    RECT rc, rc1, rc2, rc3;
    POINT pt31, pt32;
    LONG tempXY = 0;
    PWORD tempX, tempY;
    POINT pt;

    // Create the animation control.
    hwndAnim = Animate_Create(hwndDlg, (ULONG_PTR) idAnim, WS_CHILD | ACS_TRANSPARENT, hinst);

    // Get the screen coordinates of the specified control button.
    GetWindowRect(GetDlgItem(hwndDlg, idMarker), &rc);

    // Get the screen coordinates of the specified control button.
    GetWindowRect(hwndAnim, &rc1);

    // Convert the coordinates of the lower-left corner to
    // client coordinates.
    pt.x = rc.left;
    pt.y = rc.bottom;
    ScreenToClient(hwndDlg, &pt);

    // Position the animation control below the Stop button.
    SetWindowPos(hwndAnim, 0, pt.x, pt.y + 20, 0, 0, SWP_NOZORDER | SWP_NOSIZE);

    // Get the screen coordinates of the specified control button.
    GetWindowRect(hwndAnim, &rc2);

    // Open the AVI clip, and show the animation control.
    Animate_Open(hwndAnim, MAKEINTRESOURCE(idAvi));
    ShowWindow(hwndAnim, SW_SHOW);
    Animate_Play(hwndAnim, 0, -1, -1);

    // Get the screen coordinates of the specified control button.
    GetWindowRect(hwndAnim, &rc3);

    pt31.x = rc3.left;
    pt31.y = rc3.top;
    pt32.x = rc3.right;
    pt32.y = rc3.bottom;
    ScreenToClient(hwndDlg, &pt31);
    ScreenToClient(hwndDlg, &pt32);
    rc3.left = pt31.x;
    rc3.top = pt31.y;
    rc3.right = pt32.x;
    rc3.bottom = pt32.y;

    tempXY = GetDialogBaseUnits ();
    tempX = (PWORD)(&tempXY);
    tempY = tempX + 1;

    rc3.left = MulDiv (rc3.left, 4, *tempX);
    rc3.right = MulDiv (rc3.right, 4, *tempX);
    rc3.top = MulDiv (rc3.top, 8, *tempY);
    rc3.bottom = MulDiv (rc3.bottom, 8, *tempY);

    *pHwndAnim = hwndAnim;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////

#define USER_SHELL_FOLDERS                                                                                               \
    DEFMAC(CSIDL_ADMINTOOLS, TEXT("Administrative Tools"), -1, IDS_CSIDL_ADMINTOOLS)                                     \
    DEFMAC(CSIDL_ALTSTARTUP, TEXT("AltStartup"), -1, IDS_CSIDL_ALTSTARTUP)                                               \
    DEFMAC(CSIDL_APPDATA, TEXT("AppData"), -1, IDS_CSIDL_APPDATA)                                                        \
    DEFMAC(CSIDL_BITBUCKET, TEXT("RecycleBinFolder"), -1, IDS_CSIDL_BITBUCKET)                                           \
    DEFMAC(CSIDL_CONNECTIONS, TEXT("ConnectionsFolder"), -1, IDS_CSIDL_CONNECTIONS)                                      \
    DEFMAC(CSIDL_CONTROLS, TEXT("ControlPanelFolder"), -1, IDS_CSIDL_CONTROLS)                                           \
    DEFMAC(CSIDL_COOKIES, TEXT("Cookies"), -1, IDS_CSIDL_COOKIES)                                                        \
    DEFMAC(CSIDL_DESKTOP, TEXT("Desktop"), -1, IDS_CSIDL_DESKTOP)                                                        \
    DEFMAC(CSIDL_DESKTOPDIRECTORY, TEXT("Desktop"), -1, IDS_CSIDL_DESKTOPDIRECTORY)                                      \
    DEFMAC(CSIDL_DRIVES, TEXT("DriveFolder"), -1, IDS_CSIDL_DRIVES)                                                      \
    DEFMAC(CSIDL_FAVORITES, TEXT("Favorites"), -1, IDS_CSIDL_FAVORITES)                                                  \
    DEFMAC(CSIDL_FONTS, TEXT("Fonts"), -1, IDS_CSIDL_FONTS)                                                              \
    DEFMAC(CSIDL_HISTORY, TEXT("History"), -1, IDS_CSIDL_HISTORY)                                                        \
    DEFMAC(CSIDL_INTERNET, TEXT("InternetFolder"), -1, IDS_CSIDL_INTERNET)                                               \
    DEFMAC(CSIDL_INTERNET_CACHE, TEXT("Cache"), -1, IDS_CSIDL_INTERNET_CACHE)                                            \
    DEFMAC(CSIDL_LOCAL_APPDATA, TEXT("Local AppData"), -1, IDS_CSIDL_LOCAL_APPDATA)                                      \
    DEFMAC(CSIDL_MYDOCUMENTS, TEXT("My Documents"), -1, IDS_CSIDL_MYDOCUMENTS)                                           \
    DEFMAC(CSIDL_MYMUSIC, TEXT("My Music"), -1, IDS_CSIDL_MYMUSIC)                                                       \
    DEFMAC(CSIDL_MYPICTURES, TEXT("My Pictures"), -1, IDS_CSIDL_MYPICTURES)                                              \
    DEFMAC(CSIDL_MYVIDEO, TEXT("My Video"), -1, IDS_CSIDL_MYVIDEO)                                                       \
    DEFMAC(CSIDL_NETHOOD, TEXT("NetHood"), -1, IDS_CSIDL_NETHOOD)                                                        \
    DEFMAC(CSIDL_NETWORK, TEXT("NetworkFolder"), -1, IDS_CSIDL_NETWORK)                                                  \
    DEFMAC(CSIDL_PERSONAL, TEXT("Personal"), -1, IDS_CSIDL_PERSONAL)                                                     \
    DEFMAC(CSIDL_PROFILE, TEXT("Profile"), -1, IDS_CSIDL_PROFILE)                                                        \
    DEFMAC(CSIDL_PROGRAM_FILES, TEXT("ProgramFiles"), -1, IDS_CSIDL_PROGRAM_FILES)                                       \
    DEFMAC(CSIDL_PROGRAM_FILESX86, TEXT("ProgramFilesX86"), -1, IDS_CSIDL_PROGRAM_FILESX86)                              \
    DEFMAC(CSIDL_PROGRAM_FILES_COMMON, TEXT("CommonProgramFiles"), -1, IDS_CSIDL_PROGRAM_FILES_COMMON)                   \
    DEFMAC(CSIDL_PROGRAM_FILES_COMMONX86, TEXT("CommonProgramFilesX86"), -1, IDS_CSIDL_PROGRAM_FILES_COMMONX86)          \
    DEFMAC(CSIDL_PROGRAMS, TEXT("Programs"), -1, IDS_CSIDL_PROGRAMS)                                                     \
    DEFMAC(CSIDL_RECENT, TEXT("Recent"), -1, IDS_CSIDL_RECENT)                                                           \
    DEFMAC(CSIDL_SENDTO, TEXT("SendTo"), -1, IDS_CSIDL_SENDTO)                                                           \
    DEFMAC(CSIDL_STARTMENU, TEXT("Start Menu"), -1, IDS_CSIDL_STARTMENU)                                                 \
    DEFMAC(CSIDL_STARTUP, TEXT("Startup"), -1, IDS_CSIDL_STARTUP)                                                        \
    DEFMAC(CSIDL_SYSTEM, TEXT("System"), -1, IDS_CSIDL_SYSTEM)                                                           \
    DEFMAC(CSIDL_SYSTEMX86, TEXT("SystemX86"), -1, IDS_CSIDL_SYSTEMX86)                                                  \
    DEFMAC(CSIDL_TEMPLATES, TEXT("Templates"), -1, IDS_CSIDL_TEMPLATES)                                                  \
    DEFMAC(CSIDL_WINDOWS, TEXT("Windows"), -1, IDS_CSIDL_WINDOWS)                                                        \

#define COMMON_SHELL_FOLDERS                                                                                                \
    DEFMAC(CSIDL_COMMON_ADMINTOOLS, TEXT("Common Administrative Tools"), CSIDL_ADMINTOOLS, IDS_CSIDL_COMMON_ADMINTOOLS)     \
    DEFMAC(CSIDL_COMMON_ALTSTARTUP, TEXT("Common AltStartup"), CSIDL_ALTSTARTUP, IDS_CSIDL_COMMON_ALTSTARTUP)               \
    DEFMAC(CSIDL_COMMON_APPDATA, TEXT("Common AppData"), CSIDL_APPDATA, IDS_CSIDL_COMMON_APPDATA)                           \
    DEFMAC(CSIDL_COMMON_DESKTOPDIRECTORY, TEXT("Common Desktop"), CSIDL_DESKTOP, IDS_CSIDL_COMMON_DESKTOPDIRECTORY)         \
    DEFMAC(CSIDL_COMMON_DOCUMENTS, TEXT("Common Documents"), CSIDL_PERSONAL, IDS_CSIDL_COMMON_DOCUMENTS)                    \
    DEFMAC(CSIDL_COMMON_FAVORITES, TEXT("Common Favorites"), CSIDL_FAVORITES, IDS_CSIDL_COMMON_FAVORITES)                   \
    DEFMAC(CSIDL_COMMON_PROGRAMS, TEXT("Common Programs"), CSIDL_PROGRAMS, IDS_CSIDL_COMMON_PROGRAMS)                       \
    DEFMAC(CSIDL_COMMON_STARTMENU, TEXT("Common Start Menu"), CSIDL_STARTMENU, IDS_CSIDL_COMMON_STARTMENU)                  \
    DEFMAC(CSIDL_COMMON_STARTUP, TEXT("Common Startup"), CSIDL_STARTUP, IDS_CSIDL_COMMON_STARTUP)                           \
    DEFMAC(CSIDL_COMMON_TEMPLATES, TEXT("Common Templates"), CSIDL_TEMPLATES, IDS_CSIDL_COMMON_TEMPLATES)                   \

//
// This is the structure used for handling CSIDLs
//
typedef struct {
    INT DirId;
    PCTSTR DirStr;
    INT AltDirId;
    UINT DirResId;
    BOOL DirUser;
} CSIDL_STRUCT, *PCSIDL_STRUCT;

#define DEFMAC(did,dstr,adid,rid) {did,dstr,adid,rid,TRUE},
static CSIDL_STRUCT g_UserShellFolders[] = {
                              USER_SHELL_FOLDERS
                              {-1, NULL, -1, 0, FALSE}
                              };
#undef DEFMAC
#define DEFMAC(did,dstr,adid,rid) {did,dstr,adid,rid,FALSE},
static CSIDL_STRUCT g_CommonShellFolders[] = {
                              COMMON_SHELL_FOLDERS
                              {-1, NULL, -1, 0, FALSE}
                              };
#undef DEFMAC


PTSTR
pFindSfPath (
    IN      PCTSTR FolderStr,
    IN      BOOL UserFolder
    )
{
    HKEY key = NULL;
    PTSTR data;
    PTSTR expData;
    DWORD expDataSize;
    PTSTR result = NULL;
    LONG lResult;
    DWORD dataType;
    DWORD dataSize;

    if (!result) {
        if (UserFolder) {
            lResult = RegOpenKey (HKEY_CURRENT_USER, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders"), &key);
        } else {
            lResult = RegOpenKey (HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders"), &key);
        }

        if ((lResult == ERROR_SUCCESS) && key) {

            dataSize = 0;
            lResult = RegQueryValueEx (key, FolderStr, NULL, &dataType, NULL, &dataSize);
            if ((lResult == ERROR_SUCCESS) &&
                ((dataType == REG_SZ) || (dataType == REG_EXPAND_SZ))
                ) {
                data = (PTSTR)LocalAlloc (LPTR, dataSize);
                if (data) {
                    lResult = RegQueryValueEx (key, FolderStr, NULL, &dataType, (LPBYTE)data, &dataSize);
                    if (lResult == ERROR_SUCCESS) {
                        expDataSize = ExpandEnvironmentStrings (data, NULL, 0);
                        if (expDataSize) {
                            expData = (PTSTR)LocalAlloc (LPTR, (expDataSize + 1) * sizeof (TCHAR));
                            expDataSize = ExpandEnvironmentStrings (data, expData, expDataSize);
                            if (!expDataSize) {
                                LocalFree (expData);
                                expData = NULL;
                            }
                        }
                        if (expDataSize) {
                            result = expData;
                            LocalFree (data);
                        } else {
                            result = data;
                        }
                    } else {
                        LocalFree (data);
                    }
                }
            }

            CloseHandle (key);
        }
    }

    if (result && !(*result)) {
        LocalFree (result);
        result = NULL;
    }

    if (!result) {
        if (UserFolder) {
            lResult = RegOpenKey (HKEY_CURRENT_USER, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"), &key);
        } else {
            lResult = RegOpenKey (HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"), &key);
        }

        if ((lResult == ERROR_SUCCESS) && key) {

            dataSize = 0;
            lResult = RegQueryValueEx (key, FolderStr, NULL, &dataType, NULL, &dataSize);
            if ((lResult == ERROR_SUCCESS) &&
                ((dataType == REG_SZ) || (dataType == REG_EXPAND_SZ))
                ) {
                data = (PTSTR)LocalAlloc (LPTR, dataSize);
                if (data) {
                    lResult = RegQueryValueEx (key, FolderStr, NULL, &dataType, (LPBYTE)data, &dataSize);
                    if (lResult == ERROR_SUCCESS) {
                        expDataSize = ExpandEnvironmentStrings (data, NULL, 0);
                        if (expDataSize) {
                            expData = (PTSTR)LocalAlloc (LPTR, (expDataSize + 1) * sizeof (TCHAR));
                            expDataSize = ExpandEnvironmentStrings (data, expData, expDataSize);
                            if (!expDataSize) {
                                LocalFree (expData);
                                expData = NULL;
                            }
                        }
                        if (expDataSize) {
                            result = expData;
                            LocalFree (data);
                        } else {
                            result = data;
                        }
                    } else {
                        LocalFree (data);
                    }
                }
            }

            CloseHandle (key);
        }
    }

    if (result && !(*result)) {
        LocalFree (result);
        result = NULL;
    }

    return (PTSTR) result;
}

PTSTR
GetShellFolderPath (
    IN      INT Folder,
    IN      PCTSTR FolderStr,
    IN      BOOL UserFolder,
    OUT     LPITEMIDLIST *pidl  //OPTIONAL
    )
{
    PTSTR result = NULL;
    HRESULT hResult;
    BOOL b;
    LPITEMIDLIST localpidl = NULL;
    IMalloc *mallocFn;

    if (pidl) {
        *pidl = NULL;
    }

    hResult = SHGetMalloc (&mallocFn);
    if (hResult != S_OK) {
        return NULL;
    }

    hResult = SHGetSpecialFolderLocation (NULL, Folder, &localpidl);

    if (hResult == S_OK) {

        result = (PTSTR) LocalAlloc (LPTR, MAX_PATH);

        if (result) {

            b = SHGetPathFromIDList (localpidl, result);

            if (b) {
                if (pidl) {
                    *pidl = localpidl;
                }
                return result;
            }

            LocalFree (result);
            result = NULL;
        }
    }

    if (FolderStr) {
        result = pFindSfPath (FolderStr, UserFolder);
    }

    mallocFn->Free (localpidl);
    localpidl = NULL;

    return result;
}

typedef HRESULT (WINAPI SHBINDTOPARENT)(LPCITEMIDLIST pidl, REFIID riid, VOID **ppv, LPCITEMIDLIST *ppidlLast);
typedef SHBINDTOPARENT *PSHBINDTOPARENT;

HRESULT
OurSHBindToParent (
    IN      LPCITEMIDLIST pidl,
    IN      REFIID riid,
    OUT     VOID **ppv,
    OUT     LPCITEMIDLIST *ppidlLast
    )
{
    HRESULT hr = E_FAIL;
    HMODULE lib;
    PSHBINDTOPARENT shBindToParent = NULL;

    lib = LoadLibrary (TEXT("shell32.dll"));
    if (lib) {
        shBindToParent = (PSHBINDTOPARENT)GetProcAddress (lib, "SHBindToParent");
        if (shBindToParent) {
            hr = shBindToParent (pidl, riid, ppv, ppidlLast);
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////
// if pctszPath corresponds to the path of one of the CSIDL_XXXX entries, then return
//   its "pretty name", else return the standard path name

HRESULT _GetPrettyFolderName (HINSTANCE Instance, BOOL fNT4, LPCTSTR pctszPath, LPTSTR ptszName, UINT cchName)
{
    UINT itemsIndex = 0;
    PCSIDL_STRUCT items[2] = {g_UserShellFolders, g_CommonShellFolders};
    PCSIDL_STRUCT p;
    IMalloc *mallocFn;
    LPITEMIDLIST pidl = NULL;
    LPCITEMIDLIST pidlLast = NULL;
    IShellFolder* psf = NULL;
    HRESULT hr = S_OK;
    PTSTR szPath = NULL;
    PTSTR szAltPath = NULL;
    STRRET strret;
    TCHAR szDisplay1[2048];
    TCHAR szDisplay2[2048];
    BOOL checkAlternate = FALSE;
    BOOL found = FALSE;

    // First, we look to find the corresponding CSIDL if we can
    // If we can't we will just copy the IN path to the OUT path.

    for (itemsIndex = 0; itemsIndex < 2; itemsIndex ++) {

        p = items [itemsIndex];

        while (!found && (p->DirId >= 0)) {

            szDisplay1 [0] = 0;
            szDisplay2 [0] = 0;
            pidl = NULL;
            pidlLast = NULL;
            szPath = NULL;
            psf = NULL;

            szPath = GetShellFolderPath (p->DirId, p->DirStr, p->DirUser, &pidl);

            if (szPath && (0 == StrCmpI(pctszPath, szPath))) {

                found = TRUE;

                if (pidl) {

                    hr = OurSHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);

                    if (SUCCEEDED(hr) && psf && pidlLast) {

                        hr = psf->GetDisplayNameOf (pidlLast, SHGDN_NORMAL, &strret);

                        if (SUCCEEDED (hr)) {

                            hr = _StrRetToBuf (&strret, pidlLast, szDisplay1, ARRAYSIZE(szDisplay1));

                            if (!SUCCEEDED (hr) || (0 == StrCmpI (szDisplay1, pctszPath))) {
                                // Failed or we just got back the complete folder spec. We don't need that!
                                szDisplay1 [0] = 0;
                            }
                        }
                    }

                    if (psf) {
                        psf->Release ();
                        psf = NULL;
                    }
                }
            }

            if (pidl) {
                hr = SHGetMalloc (&mallocFn);
                if (SUCCEEDED (hr)) {
                    mallocFn->Free (pidl);
                    pidl = NULL;
                }
            }

            if (szPath) {
                LocalFree (szPath);
                szPath = NULL;
            }

            if (szDisplay1 [0] && (p->AltDirId >= 0)) {

                szPath = GetShellFolderPath (p->AltDirId, NULL, TRUE, &pidl);

                if (pidl && szPath) {

                    hr = OurSHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);

                    if (SUCCEEDED(hr) && psf && pidlLast) {

                        hr = psf->GetDisplayNameOf (pidlLast, SHGDN_INFOLDER, &strret);

                        if (SUCCEEDED (hr)) {

                            hr = _StrRetToBuf (&strret, pidlLast, szDisplay2, ARRAYSIZE(szDisplay2));

                            if (!SUCCEEDED (hr)) {
                                szDisplay2 [0] = 0;
                            }
                        }
                    }

                    if (psf) {
                        psf->Release ();
                        psf = NULL;
                    }

                }

                if (pidl) {
                    hr = SHGetMalloc (&mallocFn);
                    if (SUCCEEDED (hr)) {
                        mallocFn->Free (pidl);
                        pidl = NULL;
                    }
                }

                if (szPath) {
                    LocalFree (szPath);
                    szPath = NULL;
                }

            }

            if (found) {

                if ((!szDisplay1 [0]) || (0 == StrCmpI (szDisplay1, szDisplay2))) {
                    // we need to use the resource ID
                    if (!LoadString (Instance, p->DirResId, ptszName, cchName)) {
                        StrCpyN (ptszName, pctszPath, cchName);
                    }
                } else {
                    StrCpyN (ptszName, szDisplay1, cchName);
                }

                break;
            }

            p ++;
        }

        if (found) {
            break;
        }
    }

    if (!found) {
        StrCpyN (ptszName, pctszPath, cchName);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////

VOID _PopulateTree (HWND hwndTree, HTREEITEM hti, LPTSTR ptsz, UINT cch,
                    HRESULT (*fct)(HINSTANCE, BOOL, LPCTSTR, LPTSTR, UINT cchName),
                    DWORD dwFlags, HINSTANCE Instance, BOOL fNT4)
{
    if (hwndTree && hti && ptsz)
    {
        // ISSUE: resolve flickering, this doesn't fix it
        EnableWindow (hwndTree, FALSE);

        TCHAR szDisplay[2048];
        TCHAR szClean[2048];
        TCHAR* ptszPtr = ptsz;
        TCHAR* ptszParam = NULL;

        while (*ptsz && (ptszPtr < (ptsz + cch)))
        {
            szDisplay[0] = 0;
            BOOL fOK = TRUE;

            LV_DATASTRUCT* plvds = (LV_DATASTRUCT*)LocalAlloc(LPTR, sizeof(LV_DATASTRUCT));
            if (plvds)
            {
                plvds->fOverwrite = FALSE;

                StrCpyN(szClean, ptszPtr, ARRAYSIZE(szClean));

                LPITEMIDLIST pidl = NULL;
                // if this is a filetype, restore the "*." before it, add pretty name
                if (dwFlags == POPULATETREE_FLAGS_FILETYPES)
                {
                    TCHAR szPretty[2048];
                    if (FAILED(_GetPrettyTypeName(szClean, szPretty, ARRAYSIZE(szPretty))))
                    {
                        szPretty[0] = 0;
                    }
                    memmove(szClean + 2, szClean, sizeof(szClean) - (2 * sizeof(TCHAR)));
                    *szClean = TEXT('*');
                    *(szClean + 1) = TEXT('.');
                    if (szPretty[0])
                    {
                        lstrcpy(szClean + lstrlen(szClean), TEXT(" - "));
                        lstrcpy(szClean + lstrlen(szClean), szPretty);
                    }
                }

                if (fOK)
                {
                    if (szDisplay[0]) // if we already have a display name, use that and store the clean name
                    {
                        plvds->pszPureName = StrDup(szClean);
                    }
                    else
                    {
                        if (fct) // if there's a pretty-fying function, use it
                        {
                            fct(Instance, fNT4, szClean, szDisplay, ARRAYSIZE(szDisplay));
                            plvds->pszPureName = StrDup(szClean);
                        }
                        else if (POPULATETREE_FLAGS_FILETYPES) // ISSUE: this is hacky, clean this up
                        {
                            StrCpyN(szDisplay, szClean, ARRAYSIZE(szDisplay));
                            plvds->pszPureName = StrDup(ptsz);
                        }
                        else
                        {
                            StrCpyN(szDisplay, szClean, ARRAYSIZE(szDisplay));
                        }
                    }

                    TV_INSERTSTRUCT tis = {0};
                    tis.hParent = hti;
                    tis.hInsertAfter = TVI_SORT;
                    tis.item.mask  = TVIF_TEXT | TVIF_PARAM;
                    tis.item.lParam = (LPARAM)plvds;

                    tis.item.pszText = szDisplay;

                    TreeView_InsertItem(hwndTree, &tis);
                }

                ptszPtr += (1 + lstrlen(ptszPtr));
            }
        }
        EnableWindow (hwndTree, TRUE);
    }
}

//////////////////////////////////////////////////////////////////////////////////////

UINT _ListView_InsertItem(HWND hwndList, LPTSTR ptsz)
{
    LVITEM lvitem = {0};

    lvitem.mask = LVIF_TEXT;
    lvitem.iItem = ListView_GetItemCount(hwndList);
    lvitem.pszText = ptsz;

    return ListView_InsertItem(hwndList, &lvitem);
}

//////////////////////////////////////////////////////////////////////////////////////

HRESULT _GetPrettyTypeName(LPCTSTR pctszType, LPTSTR ptszPrettyType, UINT cchPrettyType)
{
    HRESULT hr = E_FAIL;
    BOOL found = FALSE;

    TCHAR tszTypeName[MAX_PATH];
    LPTSTR ptszType;

    TCHAR szTypeName[MAX_PATH];
    DWORD cchTypeName = MAX_PATH;
    TCHAR szCmdLine[MAX_PATH];
    DWORD cchCmdLine = MAX_PATH;
    DWORD dwType = REG_SZ;

    if (TEXT('*') == pctszType[0] && TEXT('.') == pctszType[1])
    {
        ptszType = (LPTSTR)pctszType + 1;
    }
    else
    {
        tszTypeName[0] = TEXT('.');
        lstrcpy(tszTypeName + 1, pctszType);
        ptszType = tszTypeName;
    }

    // let's find the progId
    if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, ptszType, NULL, &dwType, szTypeName, &cchTypeName))
    {
        LONG result;
        DWORD cchPrettyName = cchPrettyType;
        PTSTR cmdPtr, resIdPtr;
        INT resId;
        HMODULE dllModule;

        // let's see if this progId has the FriendlyTypeName value name
        if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, szTypeName, TEXT("FriendlyTypeName"), &dwType, szCmdLine, &cchCmdLine)) {

            cmdPtr = szCmdLine;
            if (_tcsnextc (cmdPtr) == TEXT('@')) {
                cmdPtr = _tcsinc (cmdPtr);
            }
            if (cmdPtr) {
                resIdPtr = _tcsrchr (cmdPtr, TEXT(','));
                if (resIdPtr) {
                    *resIdPtr = 0;
                    resIdPtr ++;
                }
            }
            if (cmdPtr && resIdPtr) {
                resId = _ttoi (resIdPtr);
                if (resId < 0) {
                    // let's load the resource string from that PE file
                    // use resIdPtr to access the string resource
                    dllModule = LoadLibraryEx (cmdPtr, NULL, LOAD_LIBRARY_AS_DATAFILE);
                    if (dllModule) {
                        found = (LoadString (dllModule, (UINT)(-resId), ptszPrettyType, cchPrettyName) > 0);
                        hr = S_OK;
                        FreeLibrary (dllModule);
                    }
                }
            }
        }

        if ((!found) && (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, szTypeName, NULL, &dwType, ptszPrettyType, &cchPrettyName)))
        {
            hr = S_OK;
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////

BOOL _DriveIdIsFloppyNT(int iDrive)
{
    BOOL fRetVal = FALSE;

    HANDLE hDevice;
    UINT i;
    TCHAR szTemp[] = TEXT("\\\\.\\a:");

    if (iDrive >= 0 && iDrive < 26)
    {
        szTemp[4] += (TCHAR)iDrive;

        hDevice = CreateFile(szTemp, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL, OPEN_EXISTING, 0, NULL);
        if (INVALID_HANDLE_VALUE != hDevice)
        {
            DISK_GEOMETRY rgGeometry[15];
            DWORD cbIn = sizeof(rgGeometry);
            DWORD cbReturned;

            if (DeviceIoControl(hDevice, IOCTL_DISK_GET_MEDIA_TYPES,
                                NULL, 0, rgGeometry, cbIn, &cbReturned, NULL))
            {
                UINT cStructReturned = cbReturned / sizeof(DISK_GEOMETRY);
                for (i = 0; i < cStructReturned; i++)
                {
                    switch (rgGeometry[i].MediaType)
                    {
                    case F5_1Pt2_512:
                    case F3_1Pt44_512:
                    case F3_2Pt88_512:
                    case F3_20Pt8_512:
                    case F3_720_512:
                    case F5_360_512:
                    case F5_320_512:
                    case F5_320_1024:
                    case F5_180_512:
                    case F5_160_512:
                        fRetVal = TRUE;
                        break;
                    case Unknown:
                    case RemovableMedia:
                    case FixedMedia:
                    default:
                        break;
                    }
                }
            }
            CloseHandle (hDevice);
        }
    }

    return fRetVal;
}

///////////////////////////////////////////

#define DEVPB_DEVTYP_525_0360   0
#define DEVPB_DEVTYP_525_1200   1
#define DEVPB_DEVTYP_350_0720   2
#define DEVPB_DEVTYP_350_1440   7
#define DEVPB_DEVTYP_350_2880   9
#define DEVPB_DEVTYP_FIXED      5
#define DEVPB_DEVTYP_NECHACK    4       // for 3rd FE floppy
#define DEVPB_DEVTYP_350_120M   6

#define CARRY_FLAG      0x01
#define VWIN32_DIOC_DOS_IOCTL       1


// DIOCRegs
// Structure with i386 registers for making DOS_IOCTLS
// vwin32 DIOC handler interprets lpvInBuffer , lpvOutBuffer to be this struc.
// and does the int 21
// reg_flags is valid only for lpvOutBuffer->reg_Flags
typedef struct DIOCRegs {
    DWORD   reg_EBX;
    DWORD   reg_EDX;
    DWORD   reg_ECX;
    DWORD   reg_EAX;
    DWORD   reg_EDI;
    DWORD   reg_ESI;
    DWORD   reg_Flags;
} DIOC_REGISTERS;

#pragma pack(1)
typedef struct _DOSDPB {
   BYTE    specialFunc;    //
   BYTE    devType;        //
   WORD    devAttr;        //
   WORD    cCyl;           // number of cylinders
   BYTE    mediaType;      //
   WORD    cbSec;          // Bytes per sector
   BYTE    secPerClus;     // Sectors per cluster
   WORD    cSecRes;        // Reserved sectors
   BYTE    cFAT;           // FATs
   WORD    cDir;           // Root Directory Entries
   WORD    cSec;           // Total number of sectors in image
   BYTE    bMedia;         // Media descriptor
   WORD    secPerFAT;      // Sectors per FAT
   WORD    secPerTrack;    // Sectors per track
   WORD    cHead;          // Heads
   DWORD   cSecHidden;     // Hidden sectors
   DWORD   cTotalSectors;  // Total sectors, if cbSec is zero
   BYTE    reserved[6];    //
} DOSDPB, *PDOSDPB;
#pragma pack()



BOOL _DriveIOCTL(int iDrive, int cmd, void *pvIn, DWORD dwIn, void *pvOut, DWORD dwOut, BOOL fFileSystem = FALSE,
                          HANDLE handle = INVALID_HANDLE_VALUE)
{
    BOOL fHandlePassedIn = TRUE;
    BOOL fSuccess = FALSE;
    DWORD dwRead;

    if (INVALID_HANDLE_VALUE == handle)
    {
        handle = CreateFileA("\\\\.\\VWIN32", 0, 0, 0, 0,
                           FILE_FLAG_DELETE_ON_CLOSE, 0);
        fHandlePassedIn = FALSE;
    }

    if (INVALID_HANDLE_VALUE != handle)
    {
        DIOC_REGISTERS reg;

        //
        // On non-NT, we talk to VWIN32, issuing reads (which are converted
        // internally to DEVIOCTLs)
        //
        //  this is a real hack (talking to VWIN32) on NT we can just
        //  open the device, we dont have to go through VWIN32
        //
        reg.reg_EBX = (DWORD)iDrive + 1;  // make 1 based drive number
        reg.reg_EDX = (DWORD)(ULONG_PTR)pvOut; // out buffer
        reg.reg_ECX = cmd;              // device specific command code
        reg.reg_EAX = 0x440D;           // generic read ioctl
        reg.reg_Flags = 0x0001;     // flags, assume error (carry)

        DeviceIoControl(handle, VWIN32_DIOC_DOS_IOCTL, &reg, sizeof(reg), &reg, sizeof(reg), &dwRead, NULL);

        fSuccess = !(reg.reg_Flags & 0x0001);
        if (!fHandlePassedIn)
            CloseHandle(handle);
    }

    return fSuccess;
}

BOOL _DriveIdIsFloppy9X(int iDrive)
{
    DOSDPB SupportedGeometry;      // s/b big enough for all
    BOOL fRet = FALSE;

    SupportedGeometry.specialFunc = 0;

    if (_DriveIOCTL(iDrive, 0x860, NULL, 0, &SupportedGeometry, sizeof(SupportedGeometry)))
    {
        switch( SupportedGeometry.devType )
        {
            case DEVPB_DEVTYP_525_0360:
            case DEVPB_DEVTYP_525_1200:
            case DEVPB_DEVTYP_350_0720:
            case DEVPB_DEVTYP_350_1440:
            case DEVPB_DEVTYP_350_2880:
                fRet = TRUE;
                break;

            case DEVPB_DEVTYP_FIXED:
            case DEVPB_DEVTYP_NECHACK:        // for 3rd FE floppy
            case DEVPB_DEVTYP_350_120M:
                fRet = FALSE;
                break;
        }
    }

    return fRet;
}



///////////////////////////////////////////

BOOL _DriveIdIsFloppy(BOOL fIsNT, int iDrive)
{
    if (fIsNT)
    {
        return _DriveIdIsFloppyNT(iDrive);
    }
    else
    {
        return _DriveIdIsFloppy9X(iDrive);
    }
}

///////////////////////////////////////////
BOOL _DriveStrIsFloppy(BOOL fIsNT, PCTSTR pszPath)
{
    int iDrive;

    iDrive = towlower(pszPath[0]) - TEXT('a');

    return _DriveIdIsFloppy(fIsNT, iDrive);
}

///////////////////////////////////////////

INT _GetFloppyNumber(BOOL fIsNT)
{
    static int iFloppy = -1;
    static bool fInit = FALSE;

    if (!fInit)
    {
        DWORD dwLog = GetLogicalDrives();

        for (int i = 0; i < 26; i++)
        {
            if( !((dwLog >> i) & 0x01) || !_DriveIdIsFloppy(fIsNT, i) )
            {
                break;
            }
            else
            {
                iFloppy = i;
            }
        }
        fInit = TRUE;
    }

    return iFloppy;
}

////////////////////////////////////////////////////////
/*
 * StrCmpN      - Compare n bytes
 *
 * returns   See lstrcmp return values.
 */
#ifdef BIG_ENDIAN
#define READNATIVEWORD(x) MAKEWORD(*(char*)(x), *(char*)((char*)(x) + 1))
#else
#define READNATIVEWORD(x) MAKEWORD(*(char*)((char*)(x) + 1), *(char*)(x))
#endif

/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}

BOOL _SetTextLoadString(HINSTANCE hInst, HWND hwnd, UINT idText)
{
    TCHAR sz[MAX_LOADSTRING];
    if (LoadString(hInst, idText, sz, ARRAYSIZE(sz)))
    {
        SendMessage(hwnd, WM_SETTEXT, 0, (LPARAM)sz);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

typedef HANDLE (WINAPI CREATETOOLHELP32SNAPSHOT)(DWORD dwFlags, DWORD th32ProcessID);
typedef CREATETOOLHELP32SNAPSHOT *PCREATETOOLHELP32SNAPSHOT;

#ifdef UNICODE

typedef BOOL (WINAPI PROCESS32FIRST)(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
typedef BOOL (WINAPI PROCESS32NEXT)(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);

#else

typedef BOOL (WINAPI PROCESS32FIRST)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
typedef BOOL (WINAPI PROCESS32NEXT)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);

#endif

typedef PROCESS32FIRST *PPROCESS32FIRST;
typedef PROCESS32NEXT *PPROCESS32NEXT;


VOID
KillExplorer (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    HANDLE h, h1;
    PROCESSENTRY32 pe;
    TCHAR szExplorerPath[MAX_PATH];
    PCREATETOOLHELP32SNAPSHOT dynCreateToolhelp32Snapshot;
    PPROCESS32FIRST dynProcess32First;
    PPROCESS32NEXT dynProcess32Next;
    HMODULE lib;

    lib = LoadLibrary (TEXT("kernel32.dll"));

    if (!lib) {
        return;
    }

    dynCreateToolhelp32Snapshot = (PCREATETOOLHELP32SNAPSHOT) GetProcAddress (lib, "CreateToolhelp32Snapshot");

#ifdef UNICODE
    dynProcess32First = (PPROCESS32FIRST) GetProcAddress (lib, "Process32FirstW");
    dynProcess32Next = (PPROCESS32NEXT) GetProcAddress (lib, "Process32NextW");
#else
    dynProcess32First = (PPROCESS32FIRST) GetProcAddress (lib, "Process32First");
    dynProcess32Next = (PPROCESS32NEXT) GetProcAddress (lib, "Process32Next");
#endif

    __try {
        if (!dynCreateToolhelp32Snapshot || !dynProcess32Next || !dynProcess32First) {
            __leave;
        }

        h = dynCreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, 0);

        if (h == INVALID_HANDLE_VALUE) {
            __leave;
        }

        GetWindowsDirectory (szExplorerPath, MAX_PATH);
        PathAppend (szExplorerPath, TEXT("explorer.exe"));

        pe.dwSize = sizeof (PROCESSENTRY32);

        if (dynProcess32First (h, &pe)) {
            do {
                if (!StrCmpI (pe.szExeFile, TEXT("explorer.exe")) ||
                    !StrCmpI (pe.szExeFile, szExplorerPath)
                    ) {

                    h1 = OpenProcess (PROCESS_TERMINATE, FALSE, pe.th32ProcessID);

                    if (h1) {
                        g_Explorer = StrDup (szExplorerPath);
                        TerminateProcess (h1, 1);
                        CloseHandle (h1);
                        break;
                    }
                }
            } while (dynProcess32Next (h, &pe));
        }

        CloseHandle (h);
    }
    __finally {
        FreeLibrary (lib);
    }
}


typedef enum {
    MS_MAX_PATH,
    MS_NO_ARG,
    MS_BOOL,
    MS_INT,
    MS_RECT,
    MS_BLOB
} METRICSTYLE;


VOID
__RefreshMetric (
    IN      METRICSTYLE msStyle,
    IN      UINT uGetMetricId,
    IN      UINT uSetMetricId,
    IN      UINT uBlobSize
    )
{
    BYTE byBuffer[MAX_PATH * 4];
    PVOID blob;

    switch (msStyle) {

    case MS_NO_ARG:
        SystemParametersInfo (uSetMetricId, 0, NULL, SPIF_SENDCHANGE);
        break;

    case MS_BLOB:
        blob = LocalAlloc (LPTR, uBlobSize);
        if (blob) {
            if (SystemParametersInfo (uGetMetricId, uBlobSize, blob, SPIF_UPDATEINIFILE)) {
                SystemParametersInfo (uSetMetricId, 0, blob, SPIF_SENDCHANGE);
            }

            LocalFree (blob);
        }
        break;

    case MS_RECT:
        if (SystemParametersInfo (uGetMetricId, 0, byBuffer, SPIF_UPDATEINIFILE)) {
            SystemParametersInfo (uSetMetricId, 0, byBuffer, SPIF_SENDCHANGE);
        }
        break;

    case MS_BOOL:
        if (SystemParametersInfo (uGetMetricId, 0, byBuffer, SPIF_UPDATEINIFILE)) {
            SystemParametersInfo (uSetMetricId, *((BOOL *) byBuffer), NULL, SPIF_SENDCHANGE);
        }
        break;

    case MS_INT:
        if (SystemParametersInfo (uGetMetricId, 0, byBuffer, SPIF_UPDATEINIFILE)) {
            SystemParametersInfo (uSetMetricId, *((UINT *) byBuffer), NULL, SPIF_SENDCHANGE);
        }
        break;

    case MS_MAX_PATH:
        if (SystemParametersInfo (uGetMetricId, MAX_PATH, byBuffer, SPIF_UPDATEINIFILE)) {
            SystemParametersInfo (uSetMetricId, 0, byBuffer, SPIF_SENDCHANGE);
        }
        break;

    }

    return;
}

VOID
SwitchToClassicDesktop (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    LONG result;
    HKEY key = NULL;
    TCHAR data[] = TEXT("0");

    //
    // The only thing that we need to do is to turn off:
    // HKCU\Software\Microsoft\Windows\CurrentVersion\ThemeManager [ThemeActive]
    //
    result = RegOpenKeyEx (
                HKEY_CURRENT_USER,
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager"),
                0,
                KEY_WRITE,
                &key
                );
    if ((result == ERROR_SUCCESS) &&
        (key)
        ) {

        result = RegSetValueEx (
                    key,
                    TEXT("ThemeActive"),
                    0,
                    REG_SZ,
                    (PBYTE)data,
                    sizeof (data)
                    );

        RegCloseKey (key);
    }
}

typedef struct
{
    UINT cbSize;
    SHELLSTATE ss;
} REGSHELLSTATE, *PREGSHELLSTATE;

VOID
SwitchToClassicTaskBar (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    HKEY key = NULL;
    DWORD dataType;
    DWORD dataSize = 0;
    PBYTE data = NULL;
    PREGSHELLSTATE shellState = NULL;
    LONG result;

    //
    // The only thing that we need to do is to turn off the fStartPanelOn field in:
    // HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer [ShellState]
    //
    result = RegOpenKeyEx (
                HKEY_CURRENT_USER,
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                0,
                KEY_READ | KEY_WRITE,
                &key
                );
    if ((result == ERROR_SUCCESS) &&
        (key)
        ) {

        result = RegQueryValueEx (
                    key,
                    TEXT ("ShellState"),
                    NULL,
                    &dataType,
                    NULL,
                    &dataSize
                    );

        if ((result == ERROR_SUCCESS) || (result == ERROR_MORE_DATA)) {
            data = (PBYTE) LocalAlloc (LPTR, dataSize);
            if (data) {
                result = RegQueryValueEx (
                            key,
                            TEXT ("ShellState"),
                            NULL,
                            &dataType,
                            data,
                            &dataSize
                            );
                if ((result == ERROR_SUCCESS) &&
                    (dataType == REG_BINARY) &&
                    (dataSize == sizeof (REGSHELLSTATE))
                    ) {
                    if (dataType == REG_BINARY) {
                        shellState = (PREGSHELLSTATE) data;
                        shellState->ss.fStartPanelOn = FALSE;
                        RegSetValueEx (
                            key,
                            TEXT("ShellState"),
                            0,
                            REG_BINARY,
                            (PBYTE)data,
                            dataSize
                            );
                    }
                }
                LocalFree (data);
            }
        }

        RegCloseKey (key);
    }
}

VOID
RegisterFonts (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    WIN32_FIND_DATA findData;
    HANDLE findHandle = INVALID_HANDLE_VALUE;
    PTSTR fontDir = NULL;
    TCHAR fontPattern [MAX_PATH];
    //
    // Let's (re)register all the fonts (in case the user migrated some new ones).
    //
    fontDir = GetShellFolderPath (CSIDL_FONTS, NULL, TRUE, NULL);
    if (fontDir) {
        StrCpyN (fontPattern, fontDir, ARRAYSIZE (fontPattern) - 4);
        StrCat (fontPattern, TEXT("\\*.*"));
        findHandle = FindFirstFile (fontPattern, &findData);
        if (findHandle != INVALID_HANDLE_VALUE) {
            do {
                AddFontResource (findData.cFileName);
            } while (FindNextFile (findHandle, &findData));
            FindClose (findHandle);
        }
    }
}

VOID
RefreshMetrics (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    //
    // Refresh all system metrics
    //
    __RefreshMetric (MS_NO_ARG, 0, SPI_SETCURSORS, 0);
    __RefreshMetric (MS_NO_ARG, 0, SPI_SETDESKPATTERN, 0);
    __RefreshMetric (MS_MAX_PATH, SPI_GETDESKWALLPAPER, SPI_SETDESKWALLPAPER, 0);
    __RefreshMetric (MS_BOOL, SPI_GETFONTSMOOTHING, SPI_SETFONTSMOOTHING, 0);
    __RefreshMetric (MS_RECT, SPI_GETWORKAREA, SPI_SETWORKAREA, 0);
    __RefreshMetric (MS_BLOB, SPI_GETICONMETRICS, SPI_SETICONMETRICS, sizeof (ICONMETRICS));
    __RefreshMetric (MS_NO_ARG, 0, SPI_SETICONS, 0);
    __RefreshMetric (MS_BLOB, SPI_GETICONTITLELOGFONT, SPI_SETICONTITLELOGFONT, sizeof (LOGFONT));
    __RefreshMetric (MS_BOOL, SPI_GETICONTITLEWRAP, SPI_SETICONTITLEWRAP, 0);
    __RefreshMetric (MS_BOOL, SPI_GETBEEP, SPI_SETBEEP, 0);
    __RefreshMetric (MS_BOOL, SPI_GETKEYBOARDCUES, SPI_SETKEYBOARDCUES, 0);
    __RefreshMetric (MS_INT, SPI_GETKEYBOARDDELAY, SPI_SETKEYBOARDDELAY, 0);
    __RefreshMetric (MS_BOOL, SPI_GETKEYBOARDPREF, SPI_SETKEYBOARDPREF, 0);
    __RefreshMetric (MS_INT, SPI_GETKEYBOARDSPEED, SPI_SETKEYBOARDSPEED, 0);
    //__RefreshMetric (MS_BOOL, SPI_GETMOUSEBUTTONSWAP, SPI_SETMOUSEBUTTONSWAP, 0);
    __RefreshMetric (MS_INT, SPI_GETMOUSEHOVERHEIGHT, SPI_SETMOUSEHOVERHEIGHT, 0);
    __RefreshMetric (MS_INT, SPI_GETMOUSEHOVERTIME, SPI_SETMOUSEHOVERTIME, 0);
    __RefreshMetric (MS_INT, SPI_GETMOUSEHOVERWIDTH, SPI_SETMOUSEHOVERWIDTH, 0);
    __RefreshMetric (MS_INT, SPI_GETMOUSESPEED, SPI_SETMOUSESPEED, 0);
    __RefreshMetric (MS_INT, SPI_GETMOUSETRAILS, SPI_SETMOUSETRAILS, 0);
    //__RefreshMetric (MS_INT, SPI_GETDOUBLECLICKTIME, SPI_SETDOUBLECLICKTIME, 0);
    //__RefreshMetric (MS_INT, SPI_GETDOUBLECLKHEIGHT, SPI_SETDOUBLECLKHEIGHT, 0);
    //__RefreshMetric (MS_INT, SPI_GETDOUBLECLKWIDTH, SPI_SETDOUBLECLKWIDTH, 0);
    __RefreshMetric (MS_BOOL, SPI_GETSNAPTODEFBUTTON, SPI_SETSNAPTODEFBUTTON, 0);
    __RefreshMetric (MS_INT, SPI_GETWHEELSCROLLLINES, SPI_SETWHEELSCROLLLINES, 0);
    __RefreshMetric (MS_BOOL, SPI_GETMENUDROPALIGNMENT, SPI_SETMENUDROPALIGNMENT, 0);
    __RefreshMetric (MS_BOOL, SPI_GETMENUFADE, SPI_SETMENUFADE, 0);
    __RefreshMetric (MS_BOOL, SPI_GETMENUSHOWDELAY, SPI_SETMENUSHOWDELAY, 0);
    __RefreshMetric (MS_BOOL, SPI_GETLOWPOWERACTIVE, SPI_SETLOWPOWERACTIVE, 0);
    __RefreshMetric (MS_INT, SPI_GETLOWPOWERTIMEOUT, SPI_SETLOWPOWERTIMEOUT, 0);
    __RefreshMetric (MS_BOOL, SPI_GETPOWEROFFACTIVE, SPI_SETPOWEROFFACTIVE, 0);
    __RefreshMetric (MS_INT, SPI_GETPOWEROFFTIMEOUT, SPI_SETPOWEROFFTIMEOUT, 0);
    __RefreshMetric (MS_BOOL, SPI_GETSCREENSAVEACTIVE, SPI_SETSCREENSAVEACTIVE, 0);
    __RefreshMetric (MS_INT, SPI_GETSCREENSAVETIMEOUT, SPI_SETSCREENSAVETIMEOUT, 0);
    __RefreshMetric (MS_BOOL, SPI_GETCOMBOBOXANIMATION, SPI_SETCOMBOBOXANIMATION, 0);
    __RefreshMetric (MS_BOOL, SPI_GETCURSORSHADOW, SPI_SETCURSORSHADOW, 0);
    __RefreshMetric (MS_BOOL, SPI_GETGRADIENTCAPTIONS, SPI_SETGRADIENTCAPTIONS, 0);
    __RefreshMetric (MS_BOOL, SPI_GETHOTTRACKING, SPI_SETHOTTRACKING, 0);
    __RefreshMetric (MS_BOOL, SPI_GETLISTBOXSMOOTHSCROLLING, SPI_SETLISTBOXSMOOTHSCROLLING, 0);
    __RefreshMetric (MS_BOOL, SPI_GETSELECTIONFADE, SPI_SETSELECTIONFADE, 0);
    __RefreshMetric (MS_BOOL, SPI_GETTOOLTIPANIMATION, SPI_SETTOOLTIPANIMATION, 0);
    __RefreshMetric (MS_BOOL, SPI_GETTOOLTIPFADE, SPI_SETTOOLTIPFADE, 0);
    __RefreshMetric (MS_BOOL, SPI_GETUIEFFECTS, SPI_SETUIEFFECTS, 0);
    __RefreshMetric (MS_BOOL, SPI_GETACTIVEWINDOWTRACKING, SPI_SETACTIVEWINDOWTRACKING, 0);
    __RefreshMetric (MS_BOOL, SPI_GETACTIVEWNDTRKZORDER, SPI_SETACTIVEWNDTRKZORDER, 0);
    __RefreshMetric (MS_INT, SPI_GETACTIVEWNDTRKTIMEOUT, SPI_SETACTIVEWNDTRKTIMEOUT, 0);
    __RefreshMetric (MS_BLOB, SPI_GETANIMATION, SPI_SETANIMATION, sizeof (ANIMATIONINFO));
    __RefreshMetric (MS_INT, SPI_GETBORDER, SPI_SETBORDER, 0);
    __RefreshMetric (MS_INT, SPI_GETCARETWIDTH, SPI_SETCARETWIDTH, 0);
    __RefreshMetric (MS_BOOL, SPI_GETDRAGFULLWINDOWS, SPI_SETDRAGFULLWINDOWS, 0);
    __RefreshMetric (MS_INT, SPI_GETFOREGROUNDFLASHCOUNT, SPI_SETFOREGROUNDFLASHCOUNT, 0);
    __RefreshMetric (MS_INT, SPI_GETFOREGROUNDLOCKTIMEOUT, SPI_SETFOREGROUNDLOCKTIMEOUT, 0);
    __RefreshMetric (MS_BLOB, SPI_GETMINIMIZEDMETRICS, SPI_SETMINIMIZEDMETRICS, sizeof (MINIMIZEDMETRICS));
    __RefreshMetric (MS_BLOB, SPI_GETNONCLIENTMETRICS, SPI_SETNONCLIENTMETRICS, sizeof (NONCLIENTMETRICS));
    __RefreshMetric (MS_BOOL, SPI_GETSHOWIMEUI, SPI_SETSHOWIMEUI, 0);

    // SPI_SETMOUSE
    // SPI_SETDRAGHEIGHT
    // SPI_SETDRAGWIDTH

    __RefreshMetric (MS_BLOB, SPI_GETACCESSTIMEOUT, SPI_SETACCESSTIMEOUT, sizeof (ACCESSTIMEOUT));
    __RefreshMetric (MS_BLOB, SPI_GETFILTERKEYS, SPI_SETFILTERKEYS, sizeof (FILTERKEYS));
    __RefreshMetric (MS_BLOB, SPI_GETHIGHCONTRAST, SPI_SETHIGHCONTRAST, sizeof (HIGHCONTRAST));
    __RefreshMetric (MS_BLOB, SPI_GETMOUSEKEYS, SPI_SETMOUSEKEYS, sizeof (MOUSEKEYS));
    __RefreshMetric (MS_BLOB, SPI_GETSERIALKEYS, SPI_SETSERIALKEYS, sizeof (SERIALKEYS));
    __RefreshMetric (MS_BOOL, SPI_GETSHOWSOUNDS, SPI_SETSHOWSOUNDS, 0);
    __RefreshMetric (MS_BLOB, SPI_GETSOUNDSENTRY, SPI_SETSOUNDSENTRY, sizeof (SOUNDSENTRY));
    __RefreshMetric (MS_BLOB, SPI_GETSTICKYKEYS, SPI_SETSTICKYKEYS, sizeof (STICKYKEYS));
    __RefreshMetric (MS_BLOB, SPI_GETTOGGLEKEYS, SPI_SETTOGGLEKEYS, sizeof (TOGGLEKEYS));
}

VOID
AskForLogOff (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    g_LogOffSystem = TRUE;
}

VOID
AskForReboot (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    g_RebootSystem = TRUE;
}

VOID
SaveOFStatus (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    HKEY key = NULL;
    LONG lResult;
    DWORD dataType;
    DWORD dataSize;
    DWORD data;

    lResult = RegOpenKey (HKEY_CURRENT_USER, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Applets\\SysTray"), &key);
    if ((lResult == ERROR_SUCCESS) && key) {
        dataSize = 0;
        lResult = RegQueryValueEx (key, TEXT("Services"), NULL, &dataType, NULL, &dataSize);
        if ((lResult == ERROR_SUCCESS) && (dataType == REG_DWORD)) {
            lResult = RegQueryValueEx (key, TEXT("Services"), NULL, &dataType, (LPBYTE)(&data), &dataSize);
            if (lResult == ERROR_SUCCESS) {
                g_OFStatus = ((data & 0x00000008) != 0);
            }
        }
        CloseHandle (key);
    }
}

VOID
RebootOnOFStatusChange (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    HKEY key = NULL;
    LONG lResult;
    DWORD dataType;
    DWORD dataSize;
    DWORD data;

    lResult = RegOpenKey (HKEY_CURRENT_USER, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Applets\\SysTray"), &key);
    if ((lResult == ERROR_SUCCESS) && key) {
        dataSize = 0;
        lResult = RegQueryValueEx (key, TEXT("Services"), NULL, &dataType, NULL, &dataSize);
        if ((lResult == ERROR_SUCCESS) && (dataType == REG_DWORD)) {
            lResult = RegQueryValueEx (key, TEXT("Services"), NULL, &dataType, (LPBYTE)(&data), &dataSize);
            if (lResult == ERROR_SUCCESS) {
                if (g_OFStatus && ((data & 0x00000008) == 0)) {
                    AskForReboot (Instance, hwndDlg, NULL);
                }
                if ((!g_OFStatus) && ((data & 0x00000008) != 0)) {
                    AskForReboot (Instance, hwndDlg, NULL);
                }
            }
        }
        CloseHandle (key);
    }
}

typedef BOOL (WINAPI LOCKSETFOREGROUNDWINDOW)(UINT uLockCode);
typedef LOCKSETFOREGROUNDWINDOW *PLOCKSETFOREGROUNDWINDOW;

VOID
RestartExplorer (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    BOOL bResult;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    HMODULE lib;
    PLOCKSETFOREGROUNDWINDOW dynLockSetForegroundWindow;

    if (g_Explorer) {

        //
        // Start explorer.exe
        //

        ZeroMemory( &si, sizeof(STARTUPINFO) );
        si.cb = sizeof(STARTUPINFO);

        lib = LoadLibrary (TEXT("user32.dll"));
        if (lib) {

            dynLockSetForegroundWindow = (PLOCKSETFOREGROUNDWINDOW) GetProcAddress (lib, "LockSetForegroundWindow");

            if (dynLockSetForegroundWindow) {
                // let's lock this so Explorer does not steal our focus
                dynLockSetForegroundWindow (LSFW_LOCK);
            }

            FreeLibrary (lib);
        }

        bResult = CreateProcess(
                        NULL,
                        g_Explorer,
                        NULL,
                        NULL,
                        FALSE,
                        CREATE_NEW_PROCESS_GROUP,
                        NULL,
                        NULL,
                        &si,
                        &pi
                        );

        if (bResult) {
            CloseHandle (pi.hProcess);
            CloseHandle (pi.hThread);
        }
    }
}

BOOL
AppExecute (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR ExecuteArgs
    )
{
    PCTSTR funcName = NULL;
    PCTSTR funcArgs = NULL;

    funcName = ExecuteArgs;
    if (!funcName || !(*funcName)) {
        return FALSE;
    }
    funcArgs = StrChrI (funcName, 0);
    if (funcArgs) {
        funcArgs ++;
        if (!(*funcArgs)) {
            funcArgs = NULL;
        }
    }
    // BUGBUG - temporary, make a macro expansion list out of it
    if (0 == StrCmpI (funcName, TEXT("KillExplorer"))) {
        KillExplorer (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("RefreshMetrics"))) {
        RefreshMetrics (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("AskForLogOff"))) {
        AskForLogOff (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("AskForReboot"))) {
        AskForReboot (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("RestartExplorer"))) {
        RestartExplorer (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("SwitchToClassicDesktop"))) {
        SwitchToClassicDesktop (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("SwitchToClassicTaskBar"))) {
        SwitchToClassicTaskBar (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("RegisterFonts"))) {
        RegisterFonts (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("SaveOFStatus"))) {
        SaveOFStatus (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("RebootOnOFStatusChange"))) {
        RebootOnOFStatusChange (Instance, hwndDlg, funcArgs);
    }
    return TRUE;
}

////////////////////////////////////////////////////


//
//  Obtaining a connection point sink is supposed to be easy.  You just
//  QI for the interface.  Unfortunately, too many components are buggy.
//
//  mmc.exe faults if you QI for IDispatch
//  and punkCB is non-NULL.  And if you do pass in NULL,
//  it returns S_OK but fills punkCB with NULL anyway.
//  Somebody must've had a rough day.
//
//  Java responds only to its dispatch ID and not IID_IDispatch, even
//  though the dispatch ID is derived from IID_IDispatch.
//
//  The Explorer Band responds only to IID_IDispatch and not to
//  the dispatch ID.
//

HRESULT GetConnectionPointSink(IUnknown *pUnk, const IID *piidCB, IUnknown **ppunkCB)
{
    HRESULT hr = E_NOINTERFACE;
    *ppunkCB = NULL;                // Pre-zero it to work around MMC
    if (piidCB)                     // Optional interface (Java/ExplBand)
    {
        hr = pUnk->QueryInterface(*piidCB, (void **) ppunkCB);
        if (*ppunkCB == NULL)       // Clean up behind MMC
            hr = E_NOINTERFACE;
    }
    return hr;
}

//
//  Enumerate the connection point sinks, calling the callback for each one
//  found.
//
//  The callback function is called once for each sink.  The IUnknown is
//  whatever interface we could get from the sink (either piidCB or piidCB2).
//

typedef HRESULT (CALLBACK *ENUMCONNECTIONPOINTSPROC)(
    /* [in, iid_is(*piidCB)] */ IUnknown *psink, LPARAM lParam);

HRESULT EnumConnectionPointSinks(
    IConnectionPoint *pcp,              // IConnectionPoint victim
    const IID *piidCB,                  // Interface for callback
    const IID *piidCB2,                 // Alternate interface for callback
    ENUMCONNECTIONPOINTSPROC EnumProc,  // Callback procedure
    LPARAM lParam)                      // Refdata for callback
{
    HRESULT hr;
    IEnumConnections * pec;

    if (pcp)
        hr = pcp->EnumConnections(&pec);
    else
        hr = E_NOINTERFACE;

    if (SUCCEEDED(hr))
    {
        CONNECTDATA cd;
        ULONG cFetched;

        while (S_OK == (hr = pec->Next(1, &cd, &cFetched)))
        {
            IUnknown *punkCB;

            //ASSERT(1 == cFetched);

            hr = GetConnectionPointSink(cd.pUnk, piidCB, &punkCB);
            if (FAILED(hr))
                hr = GetConnectionPointSink(cd.pUnk, piidCB2, &punkCB);

            if (SUCCEEDED(hr))
            {
                hr = EnumProc(punkCB, lParam);
                punkCB->Release();
            }
            else
            {
                hr = S_OK;      // Pretend callback succeeded
            }
            cd.pUnk->Release();
            if (FAILED(hr)) break; // Callback asked to stop
        }
        pec->Release();
        hr = S_OK;
    }

    return hr;
}

//
//  Send out the callback (if applicable) and then do the invoke if the
//  callback said that was a good idea.
//
//  Parameters:
//
//      pcp          -  IConnectionPoint whose sinks are to be Invoke()d.
//                      If this parameter is NULL, the function does nothing.
//      pinv         -  Structure containing parameters to INVOKE.

HRESULT CALLBACK EnumInvokeCallback(IUnknown *psink, LPARAM lParam)
{
    IDispatch *pdisp = (IDispatch *)psink;
    LPSHINVOKEPARAMS pinv = (LPSHINVOKEPARAMS)lParam;
    HRESULT hr;

    if (pinv->Callback)
    {
        // Now see if the callback wants to do pre-vet the pdisp.
        // It can return S_FALSE to skip this callback or E_FAIL to
        // stop the invoke altogether
        hr = pinv->Callback(pdisp, pinv);
        if (hr != S_OK) return hr;
    }

    pdisp->Invoke(pinv->dispidMember, *pinv->piid, pinv->lcid,
                  pinv->wFlags, pinv->pdispparams, pinv->pvarResult,
                  pinv->pexcepinfo, pinv->puArgErr);

    return S_OK;
}


//
//  QI's for IConnectionPointContainer and then does the FindConnectionPoint.
//
//  Parameters:
//
//      punk         -  The object who might be an IConnectionPointContainer.
//                      This parameter may be NULL, in which case the
//                      operation fails.
//      riidCP       -  The connection point interface to locate.
//      pcpOut       -  Receives the IConnectionPoint, if any.

HRESULT IUnknown_FindConnectionPoint(IUnknown *punk, REFIID riidCP,
                                      IConnectionPoint **pcpOut)
{
    HRESULT hr;

    *pcpOut = NULL;

    if (punk)
    {
        IConnectionPointContainer *pcpc;
        hr = punk->QueryInterface(IID_IConnectionPointContainer, (void **)&pcpc);
        if (SUCCEEDED(hr))
        {
            hr = pcpc->FindConnectionPoint(riidCP, pcpOut);
            pcpc->Release();
        }
    }
    else
        hr = E_NOINTERFACE;

    return hr;
}

//
//  IConnectionPoint_InvokeIndirect
//
//  Given a connection point, call the IDispatch::Invoke for each
//  connected sink.
//
//  The return value merely indicates whether the command was dispatched.
//  If any particular sink fails the IDispatch::Invoke, we will still
//  return S_OK, since the command was indeed dispatched.
//
//  Parameters:
//
//      pcp          -  IConnectionPoint whose sinks are to be Invoke()d.
//                      If this parameter is NULL, the function does nothing.
//      pinv         -  Structure containing parameters to INVOKE.
//                      The pdispparams field can be NULL; we will turn it
//                      into a real DISPPARAMS for you.
//
//  The SHINVOKEPARAMS.flags field can contain the following flags.
//
//      IPFL_USECALLBACK    - The callback field contains a callback function
//                            Otherwise, it will be set to NULL.
//      IPFL_USEDEFAULT     - Many fields in the SHINVOKEPARAMS will be set to
//                            default values to save the caller effort:
//
//                  riid            =   IID_NULL
//                  lcid            =   0
//                  wFlags          =   DISPATCH_METHOD
//                  pvarResult      =   NULL
//                  pexcepinfo      =   NULL
//                  puArgErr        =   NULL
//

HRESULT IConnectionPoint_InvokeIndirect(
    IConnectionPoint *pcp,
    SHINVOKEPARAMS *pinv)
{
    HRESULT hr;
    DISPPARAMS dp = { 0 };
    IID iidCP;

    if (pinv->pdispparams == NULL)
        pinv->pdispparams = &dp;

    if (!(pinv->flags & IPFL_USECALLBACK))
    {
        pinv->Callback = NULL;
    }

    if (pinv->flags & IPFL_USEDEFAULTS)
    {
        pinv->piid            =  &IID_NULL;
        pinv->lcid            =   0;
        pinv->wFlags          =   DISPATCH_METHOD;
        pinv->pvarResult      =   NULL;
        pinv->pexcepinfo      =   NULL;
        pinv->puArgErr        =   NULL;
    }

    // Try both the interface they actually connected on,
    // as well as IDispatch.  Apparently Java responds only to
    // the connecting interface, and ExplBand responds only to
    // IDispatch, so we have to try both.  (Sigh.  Too many buggy
    // components in the system.)

    hr = EnumConnectionPointSinks(pcp,
                                  (pcp->GetConnectionInterface(&iidCP) == S_OK) ? &iidCP : NULL,
                                  &IID_IDispatch,
                                  EnumInvokeCallback,
                                  (LPARAM)pinv);

    // Put the original NULL back so the caller can re-use the SHINVOKEPARAMS.
    if (pinv->pdispparams == &dp)
        pinv->pdispparams = NULL;

    return hr;
}

//
//  Given an IUnknown, query for its connection point container,
//  find the corresponding connection point, package up the
//  invoke parameters, and call the IDispatch::Invoke for each
//  connected sink.
//
//  See IConnectionPoint_InvokeParam for additional semantics.
//
//  Parameters:
//
//      punk         -  Object that might be an IConnectionPointContainer
//      riidCP       -  ConnectionPoint interface to request
//      pinv         -  Arguments for the Invoke.
//

HRESULT IUnknown_CPContainerInvokeIndirect(IUnknown *punk, REFIID riidCP,
                SHINVOKEPARAMS *pinv)
{
    IConnectionPoint *pcp;
    HRESULT hr = IUnknown_FindConnectionPoint(punk, riidCP, &pcp);
    if (SUCCEEDED(hr))
    {
        hr = IConnectionPoint_InvokeIndirect(pcp, pinv);
        pcp->Release();
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////////////////

VOID
_UpdateText(
    IN      HWND hWnd,
    IN      LPCTSTR pcszString
)
{
    TCHAR szCurString[MAX_LOADSTRING];

    if (pcszString)
    {
        SendMessage (hWnd, WM_GETTEXT, (WPARAM)MAX_LOADSTRING, (LPARAM)szCurString);
        if (StrCmp (pcszString, szCurString))
        {
            SendMessage (hWnd, WM_SETTEXT, 0, (LPARAM)pcszString);
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////

VOID
_RemoveSpaces (
    IN      PTSTR szData,
    IN      UINT uDataCount
    )
{
    UINT curr;
    PTSTR currPtr;
    PTSTR lastSpace;
    BOOL isSpace;

    // First trim the spaces at the beginning
    if (!szData) {
        return;
    }
    curr = _tcsnextc (szData);
    while (curr == TEXT(' ')) {
        currPtr = _tcsinc (szData);
        memmove (szData, currPtr, uDataCount * sizeof(TCHAR) - (UINT)((currPtr - szData) * sizeof (TCHAR)));
        curr = _tcsnextc (szData);
    }

    // Now trim the trailing spaces
    lastSpace = NULL;
    currPtr = szData;
    curr = _tcsnextc (szData);
    while (curr) {
        if (curr == TEXT(' ')) {
            if (!lastSpace) {
                lastSpace = currPtr;
            }
        } else {
            if (lastSpace) {
                lastSpace = NULL;
            }
        }
        currPtr = _tcsinc (currPtr);
        curr = _tcsnextc (currPtr);
    }
    if (lastSpace) {
        *lastSpace = 0;
    }
}

POBJLIST
_AllocateObjectList (
    IN      PCTSTR ObjectName
    )
{
    POBJLIST objList;

    objList = (POBJLIST)LocalAlloc (LPTR, sizeof (OBJLIST));
    if (objList) {
        ZeroMemory (objList, sizeof (OBJLIST));
        objList->ObjectName = (PTSTR)LocalAlloc (LPTR, (_tcslen (ObjectName) + 1) * sizeof (TCHAR));
        if (objList->ObjectName) {
            _tcscpy (objList->ObjectName, ObjectName);
        }
    }
    return objList;
}

VOID
pFreeObjects (
    IN        POBJLIST ObjectList
    )
{
    if (ObjectList->Next) {
        pFreeObjects(ObjectList->Next);
        LocalFree(ObjectList->Next);
        ObjectList->Next = NULL;
    }
    if (ObjectList->ObjectName) {
        LocalFree(ObjectList->ObjectName);
        ObjectList->ObjectName = NULL;
    }
}


VOID
_FreeObjectList (
    IN      POBJLIST ObjectList
    )
{
    if (ObjectList) {
        pFreeObjects(ObjectList);
        LocalFree(ObjectList);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\pch.h ===
#include "ism.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\scanstate\pch.h ===
#include "baseinc.h"
#include "allutils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\migwnprc.h ===
#ifndef _MIGWNPRC_H_
#define _MIGWNPRC_H_

#include <shlobj.h>

// core dialog
INT_PTR CALLBACK _RootDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam, DWORD dwEnabled, BOOL fTitle, UINT uiTitleID);

// util dialogs
INT_PTR CALLBACK _FileTypeDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// intro, end dialogs
INT_PTR CALLBACK _IntroDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _IntroLegacyDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _IntroOOBEDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _StartEngineDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _GetStartedDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _EndApplyDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _EndCollectDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _EndCollectNetDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _EndFailDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _EndOOBEDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);

// collection dialogs
INT_PTR CALLBACK _CustomizeDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _PickMethodDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _PickCollectStoreDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _FinalNotesDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _CollectProgressDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _CleanUpDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _AppInstallDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// application dialogs
INT_PTR CALLBACK _AskCDDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _DiskProgressDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _CDInstructionsDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _InstructionsDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _AskCompleteDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _PickApplyStoreDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _ApplyProgressDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _DirectCableDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by visualc.rc
//
#define IDS_GETSTARTEDTITLE             1
#define IDS_DISKPROGRESSTITLE           5
#define IDS_DISKINSTRUCTIONSTITLE       7
#define IDS_PICKAPPLYSTORETITLE         9
#define IDS_APPLYPROGRESSTITLE          11
#define IDS_PICKMETHODTITLE             13
#define IDS_CUSTOMIZETITLE              15
#define IDS_PICKCOLLECTSTORETITLE       17
#define IDS_DIRECTCABLETITLE            18
#define IDS_COLLECTPROGRESSTITLE        21
#define IDS_DISKPLEASE                  23
#define IDS_NODISK                      24
#define IDS_MIGWIZTITLE                 25
#define IDS_STOPDISK                    26
#define IDS_ERRORDISK                   27
#define IDS_ENGERR_IMAGE_EXISTS         28
#define IDS_ENGERR_NEXT_MEDIA           30
#define IDS_ENGERR_TOAST                31
#define IDS_COLS_EXTENSIONS             32
#define IDS_COLS_FILETYPES              33
#define IDS_PICK_FOLDERS                35
#define IDS_PICK_FILES                  36
#define IDS_PICK_TYPES                  37
#define IDS_ADDAFOLDER                  38
#define IDS_PICKAFILE                   39
#define IDS_OPENFILEFILTER_ALL          40
#define IDS_ENGERR_INSERT_MEDIA_NUMBER  41
#define IDS_ENGERR_INSERT_MEDIA_ONLY    42
#define IDS_ENGERR_FULL                 49
#define IDS_NONETWORK                   70
#define IDS_WAITTITLE                   73
#define IDS_ENGERR_WRONG_MEDIA          75
#define IDS_PICKSETTINGS                82
#define IDD_INTRO                       101
#define IDD_ENDCOLLECT                  102
#define IDD_GETSTARTED                  103
#define IDD_CUSTOMIZE                   104
#define IDB_BANNER                      105
#define IDD_PICKMETHOD                  105
#define IDB_WATERMARK                   106
#define IDD_ENDAPPLY                    107
#define IDD_PICKCOLLECTSTORE            109
#define IDD_COLLECTPROGRESS             111
#define IDD_DISKINSTRUCTIONS            113
#define IDD_APPLYPROGRESS               115
#define IDD_FILETYPEPICKER              116
#define IDD_DISKPROGRESS                117
#define IDD_PICKAPPLYSTORE              118
#define IDD_INTROLEGACY                 119
#define IDD_ENDCOLLECTFAIL              124
#define IDD_INTROOOBE                   125
#define IDD_ENDOOBE                     126
#define IDD_WAIT                        127
#define IDD_SETTINGPICKER               128
#define IDA_STARTUP                     129
#define IDD_FAILCLEANUP                 130
#define IDS_FAILCLEANUPTITLE            131
#define IDD_DESTPICKER                  131
#define IDD_ASKCD                       133
#define IDS_MAKETOOLDISK_INSERT         134
#define IDD_CDINSTRUCTIONS              134
#define IDS_ENTERDEST                   135
#define IDS_ENGERR_COPYSOURCE           136
#define IDD_ENDAPPLYFAIL                136
#define IDS_ENGERR_COPYFAILED           137
#define IDS_ASKCDTITLE                  138
#define IDB_SMEXCLAMATION               140
#define IDS_CDINSTRUCTIONSTITLE         142
#define IDS_ENGERR_NOTREADY             144
#define IDS_ENGERR_WRITEPROTECT         145
#define IDS_CSIDL_APPDATA               146
#define IDS_CSIDL_ADMINTOOLS            147
#define IDS_CSIDL_ALTSTARTUP            148
#define IDD_ENDCOLLECTNET               148
#define IDS_CSIDL_BITBUCKET             149
#define IDS_CSIDL_CONTROLS              150
#define IDS_CSIDL_COOKIES               151
#define IDS_CSIDL_DESKTOP               152
#define IDS_CSIDL_DESKTOPDIRECTORY      153
#define IDS_CSIDL_DRIVES                154
#define IDS_CSIDL_FAVORITES             155
#define IDS_CSIDL_FONTS                 156
#define IDS_CSIDL_HISTORY               157
#define IDS_CSIDL_INTERNET              158
#define IDS_CSIDL_INTERNET_CACHE        159
#define IDS_CSIDL_LOCAL_APPDATA         160
#define IDS_CSIDL_MYPICTURES            161
#define IDS_CSIDL_NETHOOD               162
#define IDS_CSIDL_NETWORK               163
#define IDS_CSIDL_PERSONAL              164
#define IDS_CSIDL_PROFILE               165
#define IDS_CSIDL_PROGRAM_FILES         166
#define IDS_CSIDL_PROGRAM_FILES_COMMON  167
#define IDS_CSIDL_PROGRAMS              168
#define IDS_CSIDL_RECENT                169
#define IDS_CSIDL_SENDTO                170
#define IDS_CSIDL_STARTMENU             171
#define IDS_CSIDL_STARTUP               172
#define IDS_CSIDL_SYSTEM                173
#define IDS_CSIDL_TEMPLATES             174
#define IDS_CSIDL_WINDOWS               175
#define IDS_CSIDL_MYDOCUMENTS           176
#define IDS_CSIDL_MYMUSIC               177
#define IDS_CSIDL_MYVIDEO               178
#define IDS_CSIDL_SYSTEMX86             179
#define IDS_CSIDL_PROGRAM_FILESX86      180
#define IDS_CSIDL_PROGRAM_FILES_COMMONX86 181
#define IDS_CSIDL_CONNECTIONS           182
#define IDS_CSIDL_COMMON_ADMINTOOLS     183
#define IDS_CSIDL_COMMON_ALTSTARTUP     184
#define IDS_CSIDL_COMMON_APPDATA        185
#define IDS_CSIDL_COMMON_DESKTOPDIRECTORY 186
#define IDS_CSIDL_COMMON_DOCUMENTS      187
#define IDS_CSIDL_COMMON_FAVORITES      188
#define IDS_CSIDL_COMMON_PROGRAMS       189
#define IDS_CSIDL_COMMON_STARTMENU      190
#define IDS_CSIDL_COMMON_STARTUP        191
#define IDS_CSIDL_COMMON_TEMPLATES      192
#define IDS_ASKFORLOGOFF                193
#define IDS_COLLECT_REGISTRY            194
#define IDS_COLLECT_FILE_FMT            195
#define IDS_APPLY_REGISTRY              196
#define IDS_APPLY_FILE_FMT              197
#define IDS_ALREADY_RUN_USER            198
#define IDS_ANOTHER_USER                199
#define IDS_CANTROLLBACK                200
#define IDS_PICKAFOLDER                 201
#define IDS_MIGWIZLNK_TITLE             202
#define IDS_MIGWIZLNK_INFO              203
#define IDS_ENGERR_INSERT_DEST_MEDIA_NUMBER 204
#define IDS_ENGERR_INSERT_FIRST_MEDIA   205
#define IDS_ERROR_PATHTOOLONG           206
#define IDS_ASKCREATEDIR                207
#define IDS_ERRORHTML_BEGIN             208
#define IDS_ERRORHTML_END               209
#define IDS_ERRORAREA_INIT              210
#define IDS_ERRORAREA_GATHER            211
#define IDS_ERRORAREA_SAVE              212
#define IDS_ERRORAREA_LOAD              213
#define IDS_ERRORAREA_RESTORE           214
#define IDS_ERRORAREA_UNKNOWN           215
#define IDS_ERROR_NOTRANSPORTPATH       216
#define IDS_ERROR_TRANSPORTNOACCESS     217
#define IDS_ERROR_TRANSPORTINTERNALERROR 218
#define IDS_ERROR_TRANSPORTNOVALIDSOURCE 219
#define IDS_ERROR_HOMENETINVALIDDEST    220
#define IDS_ERROR_HOMENETINVALIDSRC     221
#define IDS_ERROR_CANTSAVEOBJECT        222
#define IDS_ERROR_CANTRESTOREOBJECT     223
#define IDS_ERROR_DISKSPACE             224
#define IDS_COLLECT_BEGIN               225
#define IDS_COLLECT_END                 226
#define IDS_COLLECTNET_BEGIN            227
#define IDS_COLLECTNET_END              228
#define IDS_APPLY_BEGIN                 229
#define IDS_APPLY_END                   230
#define IDS_WARNING_RESTORE             231
#define IDS_WARNING_RESTOREFILE1        232
#define IDS_WARNING_RESTOREFILE2        233
#define IDS_WARNING_RESTORERAS1         234
#define IDS_WARNING_RESTORERAS2         235
#define IDS_WARNING_RESTORENET1         236
#define IDS_WARNING_RESTORENET2         237
#define IDS_WARNING_RESTOREPRN1         238
#define IDS_WARNING_RESTOREPRN2         239
#define IDS_WARNING_SAVE                240
#define IDS_WARNING_SAVEFILE1           241
#define IDS_WARNING_SAVEFILE2           242
#define IDS_WARNING_SAVERAS1            243
#define IDS_WARNING_SAVERAS2            244
#define IDS_WARNING_SAVENET1            245
#define IDS_WARNING_SAVENET2            246
#define IDS_WARNING_SAVEPRN1            247
#define IDS_WARNING_SAVEPRN2            248
#define IDS_ENGERR_IMAGE_OLDFORMAT      249
#define IDS_STORAGEEMPTY                250
#define IDS_STORAGEINVALID              251
#define IDS_ASKFORREBOOT                252
#define IDS_DISKSPACEWARNING            253
#define IDS_ENGERR_USED_MEDIA           254
#define IDS_ERRORHTML_SAVEFILE1         255
#define IDS_ERRORHTML_SAVEFILE2         256
#define IDS_ERRORHTML_SAVERAS1          257
#define IDS_ERRORHTML_SAVERAS2          258
#define IDS_ERRORHTML_SAVENET1          259
#define IDS_ERRORHTML_SAVENET2          260
#define IDS_ERRORHTML_SAVEPRN1          261
#define IDS_ERRORHTML_SAVEPRN2          262
#define IDS_CONFIRMCANCEL               263
#define IDS_NOMORE_SETTINGS             264
#define IDS_ENGERR_INSERT_FIRST_MEDIA1  265
#define IDD_DISPLAY_PASSWORD            265
#define IDS_ENGERR_INSERT_FIRST_MEDIA2  266
#define IDD_GATHER_PASSWORD             266
#define IDS_ENGERR_INSERT_FIRST_MEDIA3  267
#define IDD_DIRECTCABLE                 267
#define IDS_WARNING_RESTOREALTFILE1     268
#define IDS_WARNING_RESTOREALTFILE2     269
#define IDD_DIRECTCABLE_WAIT            269
#define IDS_ERROR_HOMENETINVALIDENC     270
#define IDS_WARNING_RESTOREGENERAL1     271
#define IDS_WARNING_RESTOREGENERAL2     272
#define IDD_APPINSTALL                  272
#define IDS_WARNING_OUTLOOKRULES        273
#define IDS_APPINFO_QUEUE               274
#define IDS_APPINFO_GATHER1             275
#define IDS_APPINFO_GATHER2             276
#define IDS_APPINFO_APPLY               277
#define IDS_APPINFO_ORGANIZING          278
#define IDS_APPINFO_TRANSPORT           279
#define IDS_APPINFO_TR_CONNECTING1      279
#define IDS_APPINFO_TR_CONNECTING2      280
#define IDS_APPINFO_TR_NETPREPARING     281
#define IDS_APPINFO_TR_PREPARING        282
#define IDS_APPINFO_TR_COMPRESSING      283
#define IDS_APPINFO_TR_TRANSPORTING     284
#define IDS_APPINFO_TR_MEDIAWRITING     285
#define IDS_APPINFO_TR_FINISHING        286
#define IDS_WARNING_OERULES             287
#define IDS_WIN9X_HEADER_FONTSIZE       288
#define IDS_APPINFO_TR_UNCOMPRESSING    289
#define IDS_APPINSTALLTITLE             290
#define IDS_APPINSTALL_BEGIN            291
#define IDS_APPINSTALL_END              292
#define IDC_INTRO_TITLE                 1000
#define IDC_ENDCOLLECT_TITLE            1000
#define IDC_GETSTARTED_TEXT1            1000
#define IDC_INTRO_TEXT1                 1001
#define IDC_GETSTARTED_RADIOOLD         1001
#define IDC_INTRO_TEXT2                 1002
#define IDC_GETSTARTED_RADIONEW         1002
#define IDC_GETSTARTED_GROUP            1003
#define IDC_CUSTOMIZE_ADDFOLDERS        1003
#define IDC_INTRO_TEXT3                 1003
#define IDC_CUSTOMIZE_ADDTYPES          1004
#define IDC_CUSTOMIZE_ADDFILE           1005
#define IDC_CUSTOMIZE_ADDSETTING        1006
#define IDC_INTRO_TEXT4                 1006
#define IDC_CUSTOMIZE_REMOVE            1007
#define IDC_WIZ95DIVIDER                1009
#define IDC_WIZ95TITLE                  1010
#define IDC_WIZ95SUBTITLE               1011
#define IDC_WIZ95WATERMARK              1012
#define IDC_INSTRUCTIONS_TEXT1          1038
#define IDC_INSTRUCTIONS_TEXT2          1040
#define IDC_INSTRUCTIONS_TEXT3          1041
#define IDC_APPLYPROGRESS_TEXT1         1048
#define IDC_APPLYPROGRESS_PROGRESS      1049
#define IDC_COLLECTPROGRESS_PROGRESS    1050
#define IDC_ENDCOLLECT_TEXT1            1051
#define IDC_ENDCOLLECT_TEXT2            1052
#define IDC_ENDCOLLECT_TEXT3            1053
#define IDC_ENDCOLLECT_TEXT4            1054
#define IDC_FILETYPE_TEXT1              1055
#define IDC_FILETYPE_LIST               1056
#define IDC_COLLECTPROGRESS_MARKER      1057
#define IDC_APPLYPROGRESS_MARKER        1058
#define IDC_DISKPROGRESS_TEXT1          1075
#define IDC_DISKPROGRESS_MARKER         1076
#define IDC_DISKPROGRESS_PROGRESS       1078
#define IDC_PICKAPPLYSTORE_RADIO1       1092
#define IDC_PICKAPPLYSTORE_RADIO2       1093
#define IDC_PICKAPPLYSTORE_RADIO3       1094
#define IDC_PICKAPPLYSTORE_GROUP        1095
#define IDC_ENDAPPLY_TITLE              1097
#define IDC_ENDAPPLY_TEXT1              1098
#define IDC_CUSTOMIZE_TREE              1099
#define IDC_ENDAPPLY_TEXT2              1099
#define IDC_INTROLEGACY_TITLE           1100
#define IDC_INTROLEGACY_TEXT2           1101
#define IDC_INTROLEGACY_TEXT1           1102
#define IDC_CUSTOMIZE_TEXT              1103
#define IDC_INTROLEGACY_TEXT3           1104
#define IDC_COLLECTPROGRESS_TEXT2       1107
#define IDC_INSTRUCTIONS_TEXT4          1108
#define IDC_INSTRUCTIONS_TEXT5          1109
#define IDC_ENDFAIL_TITLE               1135
#define IDC_ENDFAIL_TEXT1               1136
#define IDC_ENDFAIL_TEXT2               1137
#define IDC_INTROOOBE_TITLE             1138
#define IDC_ENDOOBE_TITLE               1139
#define IDC_ENDOOBE_TEXT1               1140
#define IDC_WAIT_TEXT1                  1144
#define IDC_WAIT_MARKER                 1145
#define IDC_PICKCOLLECTSTORE_RADIO1     1146
#define IDC_WAIT_TEXT2                  1146
#define IDC_PICKCOLLECTSTORE_RADIO3     1147
#define IDC_PICKCOLLECTSTORE_RADIO2     1148
#define IDC_PICKCOLLECTSTORE_GROUP      1149
#define IDC_PICKCOLLECTSTORE_EDIT       1150
#define IDC_PICKCOLLECTSTORE_BROWSE     1151
#define IDC_PICKCOLLECTSTORE_RADIO4     1152
#define IDC_PICKCOLLECTSTORE_TEXT1      1155
#define IDC_PICKAPPLYSTORE_TEXT         1156
#define IDC_PICKAPPLYSTORE_EDIT         1158
#define IDC_PICKAPPLYSTORE_BROWSE       1159
#define IDC_PICKMETHOD_TEXT1            1162
#define IDC_PICKMETHOD_RADIO1           1163
#define IDC_PICKMETHOD_RADIO2           1164
#define IDC_PICKMETHOD_RADIO3           1165
#define IDC_PICKMETHOD_GROUP            1166
#define IDC_PICKMETHOD_CUSTOMIZE        1167
#define IDC_PICKMETHOD_TEXT2            1170
#define IDC_PICKMETHOD_TREE             1172
#define IDC_PICKCOLLECTSTORE_TEXT2      1173
#define IDC_SETTINGPICKER_TEXT1         1174
#define IDC_SETTINGPICKER_LIST          1175
#define IDC_DESTPICKER_TEXT1            1176
#define IDC_DESTPICKER_LIST             1177
#define IDC_GETSTARTED_DESCOLD          1178
#define IDC_ASKCD_TEXT2                 1179
#define IDC_ASKCD_RADIO1                1180
#define IDC_ASKCD_RADIO2                1181
#define IDC_ASKCD_RADIO3                1182
#define IDC_ASKCD_RADIO                 1183
#define IDC_ASKCD_RADIO4                1183
#define IDC_CDINSTRUCTIONS_TEXT2        1185
#define IDC_CDINSTRUCTIONS_TEXT3        1186
#define IDC_CDINSTRUCTIONS_TEXT4        1187
#define IDC_CDINSTRUCTIONS_TEXT5        1188
#define IDC_CDINSTRUCTIONS_TEXT6        1190
#define IDC_CDINSTRUCTIONS_TEXT7        1191
#define IDC_CDINSTRUCTIONS_TEXT8        1192
#define IDC_FILETYPEEDIT                1198
#define IDC_FILETYPEEDITLABEL           1199
#define IDC_COLLECTPROGRESS_ANIM        1200
#define IDC_PICKFILETYPETEXT1           1200
#define IDC_DISKPROGRESS_ANIM           1201
#define IDC_PICKFILETYPETEXT2           1201
#define IDC_APPLYPROGRESS_ANIM          1202
#define IDC_WAIT_ANIM                   1203
#define IDC_GETSTARTED_DESCNEW          1204
#define IDC_ASKCD_TEXT1                 1205
#define IDC_CDINSTRUCTIONS_TEXT1        1206
#define IDC_PICKCOLLECTSTORE_TEXT3      1207
#define IDC_ENDCOLLECTNET_TEXT1         1207
#define IDC_PICKCOLLECTSTORE_TEXT4      1208
#define IDC_ENDCOLLECTNET_TEXT2         1208
#define IDC_PICKCOLLECTSTORE_TEXT5      1209
#define IDC_ENDCOLLECTNET_TEXT4         1209
#define IDC_CDINSTRUCTIONS_TEXT_5       1210
#define IDC_PROGRESS_STATUS             1211
#define IDC_WEBHOST                     1211
#define IDC_PICKMETHOD_TEXT3            1211
#define IDC_WAIT_ANIMATE1               1212
#define IDC_APPLYPROGRESS_STATUS        1213
#define IDC_WAIT_ANIMATE2               1213
#define IDC_CDINSTRUCTIONS_ICON         1214
#define IDC_PROGRESS_ANIMATE3           1214
#define IDC_INSTRUCTIONS_ICON           1215
#define IDC_PROGRESS_ANIMATE2           1215
#define IDC_PICKMETHOD_WARNINGICON      1216
#define IDC_PROGRESS_ANIMATE1           1216
#define IDC_PICKCOLLECTSTORE_COMBO      1217
#define IDC_INTRO_TEXT5                 1218
#define IDC_PICKAPPLYSTORE_COMBO        1219
#define IDC_DISPLAY_PASSWORD            1220
#define IDC_GATHER_PASSWORD             1221
#define IDC_DIRECTC_COMSELECT           1222
#define IDC_DIRECTC_AUTO                1223
#define IDC_DIRECTCABLE_SUCCESSTEXT     1225
#define IDC_DIRECTCABLE_FAILURETEXT     1226
#define IDC_DIRECTCABLE_WAIT_ANIMATE    1226
#define IDC_DIRECTCABLE_WAIT_TEXT1      1227
#define IDC_DIRECTCABLE_WAIT_TEXT2      1228
#define IDC_DIRECTCABLE_ICONYES         1229
#define IDC_DIRECTCABLE_ICONNO          1230
#define IDC_DIRECTC_LABELPORT           1231
#define IDC_ASKCD_COMBO                 1232
#define IDC_APPWEBHOST                  1233
#define IDA_FILECOPY                    2000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        273
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1234
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\sources.inc ===
!include ..\..\app.mk

MINORCOMP=migwiz

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\main.cpp         \
    ..\migwiz.cpp       \
    ..\migeng.cpp       \
    ..\miginf.cpp       \
    ..\migtask.cpp      \
    ..\migutil.cpp      \
    ..\migwnprc.cpp     \
    ..\container.cpp    \
    ..\migwiz.rc

# app settings
UMENTRY=winmain
UMTYPE=windows

# extra libs
TARGETLIBS= $(SDK_LIB_PATH)\ShFolder.Lib                \
            $(TARGETLIBS)                               \
            $(COBRA_ROOT)\bin\$(O)\migism.lib           \
            $(COBRA_ROOT)\bin\$(O)\log.lib              \
            $(SHELL_LIB_PATH)\shlwapip.lib              \
            $(COBRA_ROOT)\lib\$(O)\cablib.lib           \
            $(SDK_LIB_PATH)\cabinet.lib                 \

PRECOMPILED_INCLUDE=..\pch.h

# target
TARGETNAME=migwiz
TARGETTYPE=PROGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\migwnprc.cpp ===
#define INC_OLE2
#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <prsht.h>
#include <tchar.h>
#include <windef.h>
#include "resource.h"
#include "commdlg.h"
#include "shlwapi.h"
#include "shellapi.h"

#include "migwiz.h"
#include "miginf.h"
#include "migutil.h"
#include "migtask.h"
#include "migeng.h"

#include "basetypes.h"
#include "utiltypes.h"
#include "objstr.h"
#include "container.h"

extern "C" {
#include "ism.h"
#include "main.h"
}

#include "modules.h"

#define ENGINE_RULE_MAXLEN  4000
#define ENGINE_TIMEOUT      180000

#define DOWNSHIFT_PIXEL_OFFSET  60
#define UPSHIFT_PIXEL_OFFSET    -11
#define PATH_SAFETY_CHARS       26

#define ANIMATE_OPEN(w,c,x) SendDlgItemMessage(w,c,ACM_OPEN,(WPARAM)NULL,(LPARAM)(LPTSTR)MAKEINTRESOURCE(x))
#define ANIMATE_PLAY(w,c)   SendDlgItemMessage(w,c,ACM_PLAY,(WPARAM)-1,(LPARAM)MAKELONG(0,-1))
#define ANIMATE_STOP(w,c)   SendDlgItemMessage(w,c,ACM_STOP,(WPARAM)0,(LPARAM)0);
#define ANIMATE_CLOSE(w,c)  SendDlgItemMessage(w,c,ACM_OPEN,(WPARAM)NULL,(LPARAM)NULL);

///////////////////////////////////////////////////////////////
// globals

extern BOOL g_LogOffSystem;
extern BOOL g_RebootSystem;
extern BOOL g_ConfirmedLogOff;
extern BOOL g_ConfirmedReboot;

MigrationWizard* g_migwiz;

HTREEITEM g_htiFolders;
HTREEITEM g_htiFiles;
HTREEITEM g_htiSettings;
HTREEITEM g_htiTypes;

// ISSUE: embed selections within the migration wizard

BOOL g_fStoreToNetwork;  // OLD COMPUTER ONLY: this means we've selected to store to the network
BOOL g_fStoreToFloppy;   // OLD COMPUTER ONLY: this means we've selected to store to floppies
BOOL g_fStoreToCable;    // this means we've selected direct cable transport

BOOL g_fReadFromNetwork; // NEW COMPUTER ONLY: this means go ahead and read from the network immediately
TCHAR g_szStore[MAX_PATH];
BOOL g_NextPressed;

BOOL g_fHaveWhistlerCD = FALSE;
BOOL g_fAlreadyCollected = FALSE;

TCHAR g_szToolDiskDrive[MAX_PATH];

INT g_iEngineInit = ENGINE_NOTINIT;

BOOL g_fCustomize; // used to store whether we've customized or not to help with navigation
BOOL g_fOldComputer; // used to store whether we're on the old computer or not to help with navigation
BOOL g_fHaveJaz = FALSE;
BOOL g_fHaveZip = FALSE;
BOOL g_fHaveNet = FALSE;
BOOL g_hInitResult = E_FAIL;
BOOL g_fCancelPressed = FALSE;
BOOL g_fPickMethodReset = TRUE; // used to trigger a re-default of the PickMethod page
BOOL g_fCustomizeComp = FALSE; // if the user has some customization
BOOL g_CompleteLogOff = FALSE;
BOOL g_CompleteReboot = FALSE;

HWND g_hwndCurrent;

extern BOOL g_fUberCancel; // has the user has confirmed cancel?

HWND g_hwndDlg;
HWND g_hwndWizard;
UINT g_uChosenComponent = (UINT) -1;

HANDLE g_TerminateEvent = NULL;
CRITICAL_SECTION g_AppInfoCritSection;

MIG_PROGRESSPHASE g_AppInfoPhase;
UINT g_AppInfoSubPhase;
MIG_OBJECTTYPEID g_AppInfoObjectTypeId;
TCHAR g_AppInfoObjectName [4096];
TCHAR g_AppInfoText [4096];

extern Container *g_WebContainer;
extern TCHAR g_HTMLAppList[MAX_PATH];
extern TCHAR g_HTMLLog[MAX_PATH];
extern DWORD g_HTMLErrArea;
extern DWORD g_HTMLErrInstr;
extern PCTSTR g_HTMLErrObjectType;
extern PCTSTR g_HTMLErrObjectName;
extern POBJLIST g_HTMLApps;
extern POBJLIST g_HTMLWrnFile;
extern POBJLIST g_HTMLWrnAltFile;
extern POBJLIST g_HTMLWrnRas;
extern POBJLIST g_HTMLWrnNet;
extern POBJLIST g_HTMLWrnPrn;
extern POBJLIST g_HTMLWrnGeneral;

DWORD g_BaudRate [] = {CBR_110,
                       CBR_300,
                       CBR_600,
                       CBR_1200,
                       CBR_2400,
                       CBR_4800,
                       CBR_9600,
                       CBR_14400,
                       CBR_19200,
                       CBR_38400,
                       CBR_56000,
                       CBR_57600,
                       CBR_115200,
                       CBR_128000,
                       CBR_256000,
                       0};

// environment variables

BOOL _ShiftControl (HWND hwndControl, HWND hwndDlg, DWORD dwOffset)
{

    RECT rc;
    POINT pt;
    LONG lExStyles;

    GetWindowRect(hwndControl, &rc);
    // This should really be done once per dialog, not once per control
    lExStyles = GetWindowLong (hwndDlg, GWL_EXSTYLE);

    if (lExStyles & WS_EX_LAYOUTRTL)
    {
        pt.x = rc.right;
    }
    else
    {
        pt.x = rc.left;
    }

    pt.y = rc.top;
    ScreenToClient(hwndDlg, &pt);

    SetWindowPos(hwndControl, 0, pt.x, pt.y + dwOffset, 0, 0, SWP_NOZORDER | SWP_NOSIZE);

    return TRUE;
}

BOOL CALLBACK _DownshiftControl (HWND hwndControl, LPARAM lParam)
{
    return _ShiftControl(hwndControl, (HWND)lParam, DOWNSHIFT_PIXEL_OFFSET);
}

BOOL CALLBACK _UpshiftControl (HWND hwndControl, LPARAM lParam)
{
    return _ShiftControl(hwndControl, (HWND)lParam, UPSHIFT_PIXEL_OFFSET);
}

VOID _OldStylify (HWND hwndDlg, UINT uTitleStrID)
{
    HWND hwnd;

    // First, shift everything down
    EnumChildWindows(hwndDlg, _DownshiftControl, (LPARAM)hwndDlg);

    // Add a divider bar
    CreateWindow(TEXT("STATIC"),
                 NULL,
                 WS_CHILD | WS_VISIBLE | SS_SUNKEN,
                 0, 45,
                 515, 2,
                 hwndDlg,
                 (HMENU)IDC_WIZ95DIVIDER,
                 g_migwiz->GetInstance(),
                 NULL);

    // Add the Title
    hwnd = CreateWindow(TEXT("STATIC"),
                        NULL,
                        WS_CHILD | WS_VISIBLE,
                        11, 0,
                        475, 15,
                        hwndDlg,
                        (HMENU)IDC_WIZ95TITLE,
                        g_migwiz->GetInstance(),
                        NULL);
    // Set the Title font
    SetWindowFont(hwnd, g_migwiz->Get95HeaderFont(), TRUE);
    // Set the title string
    if (uTitleStrID != 0)
    {
        _SetTextLoadString(g_migwiz->GetInstance(), hwnd, uTitleStrID);
    }
}

// For Welcome and Completing pages
VOID _OldStylifyTitle (HWND hwndDlg)
{
    HWND hwnd;
    HANDLE hBitmap;

    // First, shift everything up
    EnumChildWindows(hwndDlg, _UpshiftControl, (LPARAM)hwndDlg);

    // Create the bitmap window
    hwnd = CreateWindow(TEXT("STATIC"),
                        NULL,
                        WS_CHILD | WS_VISIBLE | SS_BITMAP,
                        0, 0,
                        152, 290,
                        hwndDlg,
                        (HMENU)IDC_WIZ95WATERMARK,
                        g_migwiz->GetInstance(),
                        NULL);
    hBitmap = LoadImage(g_migwiz->GetInstance(),
                        MAKEINTRESOURCE(IDB_WATERMARK),
                        IMAGE_BITMAP,
                        0, 0,
                        LR_SHARED);
    SendMessage(hwnd, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)hBitmap);
    hBitmap = (HANDLE)SendMessage(hwnd, STM_GETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)NULL);
}

HTREEITEM __GetRootType (HWND hwndTree)
{
    TV_INSERTSTRUCT tisTypes;
    TCHAR szPickTypes[MAX_LOADSTRING];

    if (!g_htiTypes) {

        tisTypes.hParent = NULL;
        tisTypes.hInsertAfter = TVI_ROOT;
        tisTypes.item.mask  = TVIF_TEXT | TVIF_STATE;
        tisTypes.item.state = TVIS_EXPANDED;
        tisTypes.item.stateMask = TVIS_EXPANDED;

        LoadString(g_migwiz->GetInstance(), IDS_PICK_TYPES, szPickTypes, ARRAYSIZE(szPickTypes));
        tisTypes.item.pszText = szPickTypes;

        g_htiTypes = TreeView_InsertItem(hwndTree, &tisTypes);
    }

    return g_htiTypes;
}

HTREEITEM __GetRootFolder (HWND hwndTree)
{
    TV_INSERTSTRUCT tisFolders;
    TCHAR szPickFolders[MAX_LOADSTRING];

    if (!g_htiFolders) {

        tisFolders.hParent = NULL;
        tisFolders.hInsertAfter = TVI_ROOT;
        tisFolders.item.mask  = TVIF_TEXT | TVIF_STATE;
        tisFolders.item.state = TVIS_EXPANDED;
        tisFolders.item.stateMask = TVIS_EXPANDED;

        LoadString(g_migwiz->GetInstance(), IDS_PICK_FOLDERS, szPickFolders, ARRAYSIZE(szPickFolders));
        tisFolders.item.pszText = szPickFolders;

        g_htiFolders = TreeView_InsertItem(hwndTree, &tisFolders);
    }

    return g_htiFolders;
}

HTREEITEM __GetRootFile (HWND hwndTree)
{
    TV_INSERTSTRUCT tisFiles;
    TCHAR szPickFiles[MAX_LOADSTRING];

    if (!g_htiFiles) {

        tisFiles.hParent = NULL;
        tisFiles.hInsertAfter = TVI_ROOT;
        tisFiles.item.mask  = TVIF_TEXT | TVIF_STATE;
        tisFiles.item.state = TVIS_EXPANDED;
        tisFiles.item.stateMask = TVIS_EXPANDED;

        LoadString(g_migwiz->GetInstance(), IDS_PICK_FILES, szPickFiles, ARRAYSIZE(szPickFiles));
        tisFiles.item.pszText = szPickFiles;

        g_htiFiles = TreeView_InsertItem(hwndTree, &tisFiles);
    }

    return g_htiFiles;
}

HTREEITEM __GetRootSetting (HWND hwndTree)
{
    TV_INSERTSTRUCT tisSettings;
    TCHAR szPickSettings[MAX_LOADSTRING];

    if (!g_htiSettings) {

        tisSettings.hParent = NULL;
        tisSettings.hInsertAfter = TVI_ROOT;
        tisSettings.item.mask  = TVIF_TEXT | TVIF_STATE;
        tisSettings.item.state = TVIS_EXPANDED;
        tisSettings.item.stateMask = TVIS_EXPANDED;

        LoadString(g_migwiz->GetInstance(), IDS_PICKSETTINGS, szPickSettings, ARRAYSIZE(szPickSettings));
        tisSettings.item.pszText = szPickSettings;

        g_htiSettings = TreeView_InsertItem(hwndTree, &tisSettings);
    }

    return g_htiSettings;
}

HRESULT _AddType (HWND hwndTree, LPCTSTR lpszFileType, LPCTSTR lpszFileTypePretty)
{
    HRESULT hr = E_OUTOFMEMORY;
    TCHAR tszCombine[2000];

    if (_tcslen(lpszFileType) + _tcslen(lpszFileTypePretty) + 6 >= 2000) {
        return E_FAIL;
    }

    // ISSUE: potential for overflow, but wnsprintf doesn't work on downlevel.  Ideas?
    lstrcpy(tszCombine, TEXT("*."));
    lstrcat(tszCombine, lpszFileType);
    if (lpszFileTypePretty && *lpszFileTypePretty)
    {
        lstrcat(tszCombine, TEXT(" - "));
        lstrcat(tszCombine, lpszFileTypePretty);
    }

    TV_INSERTSTRUCT tis = {0};
    tis.hParent = __GetRootType(hwndTree);
    tis.hInsertAfter = TVI_SORT;
    tis.item.mask  = TVIF_TEXT | TVIF_PARAM;
    tis.item.pszText = tszCombine;
    tis.item.lParam = (LPARAM)LocalAlloc(LPTR, sizeof(LV_DATASTRUCT));
    if (tis.item.lParam)
    {
        ((LV_DATASTRUCT*)tis.item.lParam)->fOverwrite = FALSE;
        ((LV_DATASTRUCT*)tis.item.lParam)->pszPureName = StrDup(lpszFileType);
        if (!((LV_DATASTRUCT*)tis.item.lParam)->pszPureName)
        {
            LocalFree((HLOCAL)tis.item.lParam);
        }
        else
        {
            //
            // Add the component to the engine and tree control, unless it already exists
            //

            // Check if it is already in the tree
            if (!IsmIsComponentSelected (lpszFileType, COMPONENT_EXTENSION)) {
                // Not in the tree; select it if it exists as a component
                if (!IsmSelectComponent (lpszFileType, COMPONENT_EXTENSION, TRUE)) {

                    // Not a component; add the component
                    IsmAddComponentAlias (
                        NULL,
                        MASTERGROUP_FILES_AND_FOLDERS,
                        lpszFileType,
                        COMPONENT_EXTENSION,
                        TRUE
                        );
                }

                TreeView_InsertItem(hwndTree, &tis);

                // if the user hits BACK we will remember that the user customized stuff
                g_fCustomizeComp = TRUE;
            }

            hr = S_OK;
        }
    }

    return hr;
}

VOID
CopyStorePath(LPTSTR pszIn, LPTSTR pszOut)
{
    TCHAR *ptsLastSpace = NULL;

    *pszOut = '\0';
    if( ! pszIn )
        return;

    //
    //  Step 1: Skip over leading white space
    //

    while( *pszIn && _istspace(*pszIn) )
        pszIn = _tcsinc(pszIn);


    //
    //  Step 2: Copy the string, stripping out quotes and keeping
    //          track of the last space after valid text in order
    //          to strip out trailing space.
    //

    while( *pszIn )
    {
        if( _tcsnextc(pszIn) == '\"' )
        {
            pszIn = _tcsinc(pszIn);
            continue;
        }

        if( _istspace(*pszIn) )
        {
            if( ! ptsLastSpace )
            {
                ptsLastSpace = pszOut;
            }
        }
        else
        {
            ptsLastSpace = NULL;
        }

#ifdef UNICODE
        *pszOut++ = *pszIn++;
#else
        if( isleadbyte(*pszIn) )
        {
            *pszOut++ = *pszIn++;
        }
        *pszOut++ = *pszIn++;
#endif

    }

    //
    //  Step 3: Terminate the output string correctly
    //

    if( ptsLastSpace )
    {
        *ptsLastSpace = '\0';
    }
    else
    {
        *pszOut = '\0';
    }

    return;
}




BOOL _IsNetworkPath(LPTSTR pszPath)
{
    TCHAR tszDriveName[4] = TEXT("?:\\");
    tszDriveName[0] = pszPath[0];
    return ((pszPath[0] == '\\' && pszPath[1] == '\\') || DRIVE_REMOTE == GetDriveType(tszDriveName));
}

int CALLBACK
AddFolderCallback (
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam,
    LPARAM lpData
    )
{
    HRESULT hr = S_OK;
    TCHAR tszFolderName[MAX_PATH];
    IMalloc *mallocFn = NULL;
    IShellFolder *psfParent = NULL;
    IShellLink *pslLink = NULL;
    LPCITEMIDLIST pidl;
    LPCITEMIDLIST pidlRelative = NULL;
    LPITEMIDLIST pidlReal = NULL;

    if (uMsg == BFFM_SELCHANGED) {

        hr = SHGetMalloc (&mallocFn);
        if (!SUCCEEDED (hr)) {
            mallocFn = NULL;
        }

        pidl = (LPCITEMIDLIST) lParam;
        pidlReal = NULL;

        if (pidl) {

            hr = OurSHBindToParent (pidl, IID_IShellFolder, (void **)&psfParent, &pidlRelative);

            if (SUCCEEDED(hr)) {
                hr = psfParent->GetUIObjectOf (hwnd, 1, &pidlRelative, IID_IShellLink, NULL, (void **)&pslLink);
                if (SUCCEEDED(hr)) {
                    hr = pslLink->GetIDList (&pidlReal);
                    if (!SUCCEEDED(hr)) {
                        pidlReal = NULL;
                    }
                    pslLink->Release ();
                }
                pidlRelative = NULL;
                psfParent->Release ();
            }

            if (SHGetPathFromIDList(pidlReal?pidlReal:pidl, tszFolderName) == TRUE)
            {
                if ((tszFolderName[0] == 0) ||
                    (_IsNetworkPath(tszFolderName))
                    ) {
                    SendMessage (hwnd, BFFM_ENABLEOK, 0, 0);
                }
            } else {
                SendMessage (hwnd, BFFM_ENABLEOK, 0, 0);
            }

            if (pidlReal) {
                if (mallocFn) {
                    mallocFn->Free ((void *)pidlReal);
                }
                pidlReal = NULL;
            }
        }

        if (mallocFn) {
            mallocFn->Release ();
            mallocFn = NULL;
        }
    }
    return 0;
}

HRESULT _AddFolder (HWND hwndDlg, HWND hwndTree)
{
    HRESULT hr = S_OK;
    TCHAR tszFolderName[MAX_PATH];

    IMalloc *mallocFn = NULL;
    IShellFolder *psfParent = NULL;
    IShellLink *pslLink = NULL;
    LPCITEMIDLIST pidl;
    LPCITEMIDLIST pidlRelative = NULL;
    LPITEMIDLIST pidlReal = NULL;

    TCHAR szPick[MAX_LOADSTRING];

    hr = SHGetMalloc (&mallocFn);
    if (!SUCCEEDED (hr)) {
        mallocFn = NULL;
    }

    LoadString(g_migwiz->GetInstance(), IDS_ADDAFOLDER, szPick, ARRAYSIZE(szPick));
    BROWSEINFO brwsinf = { hwndDlg, NULL, NULL, szPick, BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE, AddFolderCallback, 0, 0 };
    // loop until we get pidl or cancel cancels
    BOOL fDone = FALSE;
    while (!fDone)
    {
        pidl = SHBrowseForFolder(&brwsinf);
        if (pidl)
        {
            hr = OurSHBindToParent (pidl, IID_IShellFolder, (void **)&psfParent, &pidlRelative);

            if (SUCCEEDED(hr)) {
                hr = psfParent->GetUIObjectOf (hwndDlg, 1, &pidlRelative, IID_IShellLink, NULL, (void **)&pslLink);
                if (SUCCEEDED(hr)) {
                    hr = pslLink->GetIDList (&pidlReal);
                    if (SUCCEEDED(hr)) {
                        if (mallocFn) {
                            mallocFn->Free ((void *)pidl);
                        }
                        pidl = pidlReal;
                        pidlReal = NULL;
                    }
                    pslLink->Release ();
                }
                pidlRelative = NULL;
                psfParent->Release ();
            }

            if (SHGetPathFromIDList(pidl, tszFolderName))
            {
                fDone = TRUE; // user chose a valid folder
            }
        }
        else
        {
            fDone = TRUE; // user cancelled
        }
    }

    if (pidl)
    {
        TCHAR tszPrettyFolderName[MAX_PATH];
        hr = _GetPrettyFolderName (
                    g_migwiz->GetInstance(),
                    g_migwiz->GetWinNT4(),
                    tszFolderName,
                    tszPrettyFolderName,
                    ARRAYSIZE(tszPrettyFolderName)
                    );
        if (SUCCEEDED(hr))
        {
            hr = E_OUTOFMEMORY;

            SHFILEINFO sfi = {0};
            SHGetFileInfo((PCTSTR) (pidlReal?pidlReal:pidl), FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(sfi), SHGFI_SMALLICON | SHGFI_SYSICONINDEX | SHGFI_PIDL);

            TV_INSERTSTRUCT tis = {0};
            tis.hParent = __GetRootFolder (hwndTree);
            tis.hInsertAfter = TVI_SORT;
            tis.item.mask  = TVIF_TEXT | TVIF_PARAM;
            tis.item.pszText = tszPrettyFolderName;
            tis.item.lParam = (LPARAM)LocalAlloc(LPTR, sizeof(LV_DATASTRUCT));
            if (tis.item.lParam)
            {
                ((LV_DATASTRUCT*)tis.item.lParam)->fOverwrite = FALSE;
                ((LV_DATASTRUCT*)tis.item.lParam)->pszPureName = StrDup(tszFolderName);
                if (!((LV_DATASTRUCT*)tis.item.lParam)->pszPureName)
                {
                    LocalFree((HLOCAL)tis.item.lParam);
                }
                else
                {
                    //
                    // Add the component to the engine and tree control, unless it already exists
                    //

                    // Check if it is already in the tree
                    if (!IsmIsComponentSelected (tszFolderName, COMPONENT_FOLDER)) {

                        // Not in the tree; select it if it exists as a component
                        if (!IsmSelectComponent (tszFolderName, COMPONENT_FOLDER, TRUE)) {

                            // Not a component; add the component
                            IsmAddComponentAlias (
                                NULL,
                                MASTERGROUP_FILES_AND_FOLDERS,
                                tszFolderName,
                                COMPONENT_FOLDER,
                                TRUE
                                );
                        }

                        TreeView_InsertItem(hwndTree, &tis);

                        // if the user hits BACK we will remember that the user customized stuff
                        g_fCustomizeComp = TRUE;
                    }

                    hr = S_OK;
                }
            }
        }
        if (mallocFn) {
            mallocFn->Free ((void *)pidl);
        }
        pidl = NULL;
    }

    if (mallocFn) {
        mallocFn->Release ();
        mallocFn = NULL;
    }

    return hr;
}

HRESULT _AddSetting (HWND hwndTree, LPTSTR lpszSetting)
{
    HRESULT hr = E_OUTOFMEMORY;

    TV_INSERTSTRUCT tis = {0};
    tis.hParent = __GetRootSetting(hwndTree);
    tis.hInsertAfter = TVI_SORT;
    tis.item.mask  = TVIF_TEXT | TVIF_PARAM;
    tis.item.pszText = lpszSetting;
    tis.item.lParam = (LPARAM)LocalAlloc(LPTR, sizeof(LV_DATASTRUCT));
    if (tis.item.lParam)
    {
        ((LV_DATASTRUCT*)tis.item.lParam)->pszPureName = NULL;
        ((LV_DATASTRUCT*)tis.item.lParam)->fOverwrite = FALSE;

        //
        // Add the component to the engine and tree control, unless it already exists
        //

        // Check if it is already in the tree
        if (!IsmIsComponentSelected (lpszSetting, COMPONENT_NAME)) {

            // Not in the tree; select it if it exists as a component
            if (!IsmSelectComponent (lpszSetting, COMPONENT_NAME, TRUE)) {

                // Not a component; add the component
                IsmAddComponentAlias (
                    NULL,
                    MASTERGROUP_FILES_AND_FOLDERS,
                    lpszSetting,
                    COMPONENT_NAME,
                    TRUE
                    );
            }
            TreeView_InsertItem(hwndTree, &tis);

            // if the user hits BACK we will remember that the user customized stuff
            g_fCustomizeComp = TRUE;
        }
        hr = S_OK;
    }
    return hr;
}

HRESULT _AddFile (HWND hwndDlg, HWND hwndTree)
{
    TCHAR szCurrDir[MAX_PATH] = TEXT("");
    TCHAR szPath[MAX_PATH];
    szPath[0] = TEXT('\0');
    TCHAR szPick[MAX_LOADSTRING];
    TCHAR szAll[MAX_LOADSTRING + 6];
    HRESULT hr = S_OK;
    BOOL fDone = FALSE;
    BOOL fGotFile = FALSE;
    PTSTR mydocsDir = NULL;
    PTSTR lpstrFilter;
    DWORD dwLength;

    LoadString(g_migwiz->GetInstance(), IDS_PICKAFILE, szPick, ARRAYSIZE(szPick));
    dwLength = LoadString(g_migwiz->GetInstance(), IDS_OPENFILEFILTER_ALL, szAll, MAX_LOADSTRING);
    memcpy (szAll + dwLength, TEXT("\0*.*\0\0"), 6 * sizeof (TCHAR));
    OPENFILENAME of = {
        g_migwiz->GetLegacy() ? OPENFILENAME_SIZE_VERSION_400 : sizeof(OPENFILENAME), // DWORD        lStructSize;
        hwndDlg,                               // HWND         hwndOwner;
        NULL,                                  // HINSTANCE    hInstance;
        szAll,                                 // LPCTSTR      lpstrFilter;
        NULL,                                  // LPTSTR       lpstrCustomFilter;
        NULL,                                  // DWORD        nMaxCustFilter;
        1,                                     // DWORD        nFilterIndex;
        szPath,                                // LPTSTR       lpstrFile;
        MAX_PATH,                              // DWORD        nMaxFile;
        NULL,                                  // LPTSTR       lpstrFileTitle;
        NULL,                                  // DWORD        nMaxFileTitle;
        NULL,                                  // LPCTSTR      lpstrInitialDir;
        szPick,                                // LPCTSTR      lpstrTitle;
        OFN_NODEREFERENCELINKS | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NONETWORKBUTTON | OFN_HIDEREADONLY, // DWORD        Flags;
        0,                                     // WORD         nFileOffset;
        0,                                     // WORD         nFileExtension;
        NULL,                                  // LPCTSTR      lpstrDefExt;
        NULL,                                  // LPARAM       lCustData;
        NULL,                                  // LPOFNHOOKPROC lpfnHook;
        NULL,                                  // LPCTSTR      lpTemplateName;
    };

    while (!fDone)
    {
        // we need to set the current directory to be in "My Documents" for this dialog
        // to work properly. If we don't the dialog will open in the current directory
        // which is the temp dir where we copied the wizard.

        if (GetCurrentDirectory(ARRAYSIZE(szCurrDir), szCurrDir)) {
            mydocsDir = GetShellFolderPath (CSIDL_MYDOCUMENTS, TEXT("My Documents"), TRUE, NULL);
            if (!mydocsDir) {
                mydocsDir = GetShellFolderPath (CSIDL_PERSONAL, TEXT("Personal"), TRUE, NULL);
            }
            if (mydocsDir) {
                SetCurrentDirectory (mydocsDir);
                LocalFree (mydocsDir);
            }
        }
        fGotFile = GetOpenFileName(&of);
        if (szCurrDir [0]) {
            SetCurrentDirectory (szCurrDir);
        }
        if (!fGotFile)
        {
            fDone = TRUE;
        }
        else
        {
            if (_IsNetworkPath(szPath))
            {
                // if LoadStrings fail, we default to english
                TCHAR szNoNetworkMsg[MAX_LOADSTRING];
                TCHAR szNoNetworkCaption[MAX_LOADSTRING] = TEXT("Files and Settings Transfer Wizard");
                if (!LoadString(g_migwiz->GetInstance(), IDS_NONETWORK, szNoNetworkMsg, ARRAYSIZE(szPick)))
                {
                    StrCpyN(szNoNetworkMsg, TEXT("Network files and folders cannot be transferred.  Please choose again."), ARRAYSIZE(szNoNetworkMsg));
                }
                if (!LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szNoNetworkCaption, ARRAYSIZE(szPick)))
                {
                    StrCpyN(szNoNetworkCaption, TEXT("Files and Settings Transfer Wizard"), ARRAYSIZE(szNoNetworkMsg));
                }
                _ExclusiveMessageBox(hwndDlg, szNoNetworkMsg, szNoNetworkCaption, MB_OK);
            }
            else
            {
                fDone = TRUE; // user chose a non-network folder
            }
        }
    }

    if (fGotFile)
    {
        hr = E_OUTOFMEMORY;

        TV_INSERTSTRUCT tis = {0};
        tis.hParent = __GetRootFile (hwndTree);
        tis.hInsertAfter = TVI_SORT;
        tis.item.mask  = TVIF_TEXT | TVIF_PARAM;
        tis.item.pszText = szPath;
        tis.item.lParam = (LPARAM)LocalAlloc(LPTR, sizeof(LV_DATASTRUCT));
        if (tis.item.lParam)
        {
            ((LV_DATASTRUCT*)tis.item.lParam)->pszPureName = NULL;
            ((LV_DATASTRUCT*)tis.item.lParam)->fOverwrite = FALSE;

            //
            // Add the component to the engine and tree control, unless it already exists
            //

            // Check if it is already in the tree
            if (!IsmIsComponentSelected (szPath, COMPONENT_FILE)) {

                // Not in the tree; select it if it exists as a component
                if (!IsmSelectComponent (szPath, COMPONENT_FILE, TRUE)) {

                    // Not a component; add the component
                    IsmAddComponentAlias (
                        NULL,
                        MASTERGROUP_FILES_AND_FOLDERS,
                        szPath,
                        COMPONENT_FILE,
                        TRUE
                        );
                }

                TreeView_InsertItem(hwndTree, &tis);

                // if the user hits BACK we will remember that the user customized stuff
                g_fCustomizeComp = TRUE;
            }

            hr = S_OK;
        }
    }

    return hr;
}


///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _FileTypeDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static bool fDoneInit;
    static HWND hwndParent;
    switch (uMsg)
    {
    case WM_NOTIFY :
        switch (((LPNMHDR)lParam)->code)
        {
        case NM_DBLCLK:
            // On this dialog, this message can only come from the listview.
            // If there is something selected, that means the user doubleclicked on an item
            // On a doubleclick we will trigger the OK button
            if (ListView_GetSelectedCount(GetDlgItem(hwndDlg, IDC_FILETYPE_LIST)) > 0)
            {
                SendMessage (GetDlgItem(hwndDlg, IDOK), BM_CLICK, 0, 0);
            }
            break;
        case LVN_ITEMCHANGED:
            {
                if (fDoneInit) // ignore messages during WM_INITDIALOG
                {
                    if (ListView_GetSelectedCount(GetDlgItem(hwndDlg, IDC_FILETYPE_LIST)) > 0)
                    {
                        Button_Enable(GetDlgItem(hwndDlg, IDOK), TRUE);
                    }
                    else
                    {
                        Button_Enable(GetDlgItem(hwndDlg, IDOK), FALSE);
                    }
                }
            }
            break;
        }
        break;

    case WM_INITDIALOG :
        {
            fDoneInit = FALSE;
            hwndParent = (HWND)lParam;
            HWND hwndList = GetDlgItem(hwndDlg, IDC_FILETYPE_LIST);
            ListView_DeleteAllItems(hwndList);
            Button_Enable(GetDlgItem(hwndDlg, IDOK), FALSE);

            LVCOLUMN lvcolumn;
            lvcolumn.mask = LVCF_TEXT | LVCF_WIDTH;
            lvcolumn.cx = 75;
            TCHAR szColumn[MAX_LOADSTRING];
            LoadString(g_migwiz->GetInstance(), IDS_COLS_EXTENSIONS, szColumn, ARRAYSIZE(szColumn));
            lvcolumn.pszText = szColumn;
            ListView_InsertColumn(hwndList, 0, &lvcolumn);
            lvcolumn.cx = 235;
            LoadString(g_migwiz->GetInstance(), IDS_COLS_FILETYPES, szColumn, ARRAYSIZE(szColumn));
            lvcolumn.pszText = szColumn;
            ListView_InsertColumn(hwndList, 1, &lvcolumn);

            DWORD dwRetVal = ERROR_SUCCESS;
            UINT i = 0;
            BOOL fImageListSet = FALSE;

            // 1.  insert all the extensions
            while (ERROR_SUCCESS == dwRetVal)
            {
                TCHAR szKeyName[MAX_PATH];
                DWORD cchKeyName = ARRAYSIZE(szKeyName);
                dwRetVal = RegEnumKeyEx(HKEY_CLASSES_ROOT, i++, szKeyName, &cchKeyName,
                                        NULL, NULL, NULL, NULL);
                if (dwRetVal == ERROR_SUCCESS && cchKeyName > 0)
                {
                    if (szKeyName[0] == TEXT('.'))// &&
                        //!IsmIsComponentSelected(szKeyName + 1, COMPONENT_EXTENSION))
                    {
                        INFCONTEXT context;

                        // read the screened extensions from MIGWIZ.INF and
                        // don't add it if it's there
                        if (!SetupFindFirstLine (g_hMigWizInf, TEXT("Screened Extensions"), szKeyName+1, &context)) {
                            _ListView_InsertItem(hwndList, szKeyName+1);
                        }
                    }
                }
            }


            // 2.  remove all the extensions already in the engine
            MIG_COMPONENT_ENUM mce;
            int iFoundItem;
            LVFINDINFO findinfo;
            findinfo.flags = LVFI_STRING;
            findinfo.vkDirection = VK_DOWN;

            if (IsmEnumFirstComponent (&mce, COMPONENTENUM_ALIASES|COMPONENTENUM_ENABLED, COMPONENT_EXTENSION))
            {
                do
                {
                    findinfo.psz = mce.LocalizedAlias;

                    iFoundItem = ListView_FindItem(hwndList, -1, &findinfo);
                    if (-1 != iFoundItem)
                    {
                        ListView_DeleteItem(hwndList, iFoundItem);
                    }

                    mce.SkipToNextComponent = TRUE;

                } while (IsmEnumNextComponent (&mce));
            }

            // 3.  add the extensions in the engine, but removed, yet not in the registry
            if (IsmEnumFirstComponent (&mce, COMPONENTENUM_ALIASES|COMPONENTENUM_DISABLED, COMPONENT_EXTENSION))
            {
                do
                {
                    findinfo.psz = mce.LocalizedAlias;

                    iFoundItem = ListView_FindItem(hwndList, -1, &findinfo);
                    if (-1 == iFoundItem)
                    {
                        _ListView_InsertItem(hwndList, (LPTSTR)mce.LocalizedAlias);
                    }

                    mce.SkipToNextComponent = TRUE;

                } while (IsmEnumNextComponent (&mce));
            }

            // 3.  add in the *. and the pretty names
            TCHAR szName[MAX_PATH];
            TCHAR szPrettyName[MAX_PATH];
            LVITEM lvitem = {0};
            lvitem.mask = LVIF_TEXT;
            lvitem.pszText = szName;
            lvitem.cchTextMax = ARRAYSIZE(szName);


            int cListView = ListView_GetItemCount(hwndList);

            for (int j = 0; j < cListView; j++)
            {
                lvitem.iItem = j;
                ListView_GetItem(hwndList, &lvitem);
                memmove(szName + 2, szName, sizeof(szName) - (2 * sizeof(TCHAR)));
                szName[0] = '*';
                szName[1] = '.';

                ListView_SetItemText(hwndList, j, 0, szName);

                if (SUCCEEDED(_GetPrettyTypeName(szName, szPrettyName, ARRAYSIZE(szPrettyName))))
                {
                    ListView_SetItemText(hwndList, j, 1, szPrettyName);
                }
            }

            ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT);

            Edit_LimitText(GetDlgItem(hwndDlg, IDC_FILETYPEEDIT), MAX_PATH - 4);

            fDoneInit = TRUE;
        }
        return TRUE;
        break;

    case WM_COMMAND:
        if (HIWORD(wParam) == EN_CHANGE)
        {

            Button_Enable(GetDlgItem(hwndDlg, IDOK), TRUE);
            break;
        }

        switch (LOWORD(wParam))
        {
        case IDOK:
            {
                HWND hwndTree = GetDlgItem(hwndParent, IDC_CUSTOMIZE_TREE);
                HWND hwndList = GetDlgItem(hwndDlg, IDC_FILETYPE_LIST);
                UINT cSelCount = ListView_GetSelectedCount(hwndList);
                INT iIndex = -1;
                TCHAR szFileType[MAX_PATH];
                TCHAR szFileTypePretty[MAX_PATH];

                for (UINT x=0; x < cSelCount; x++)
                {
                    iIndex = ListView_GetNextItem(hwndList, iIndex, LVNI_SELECTED);
                    if (iIndex == -1)
                    {
                        break;
                    }

                    // add "doc", not "*.doc"
                    ListView_GetItemText(hwndList, iIndex, 0, szFileType, ARRAYSIZE(szFileType));
                    memmove(szFileType, szFileType + 2, sizeof(szFileType) - (2 * sizeof(TCHAR)));

                    ListView_GetItemText(hwndList, iIndex, 1, szFileTypePretty, ARRAYSIZE(szFileTypePretty));

                    _AddType(hwndTree, szFileType, szFileTypePretty);
                }

                // Now check the edit box
                SendMessage(GetDlgItem(hwndDlg, IDC_FILETYPEEDIT), WM_GETTEXT,
                            (WPARAM)ARRAYSIZE(szFileType), (LPARAM)szFileType);
                if (*szFileType)
                {
                    szFileTypePretty [0] = 0;
                    _RemoveSpaces (szFileType, ARRAYSIZE (szFileType));
                    _GetPrettyTypeName(szFileType, szFileTypePretty, ARRAYSIZE(szFileTypePretty));
                    if (szFileType[0] == TEXT('*') && szFileType[1] == TEXT('.'))
                    {
                        _AddType(hwndTree, szFileType + 2, szFileTypePretty);
                    }
                    else
                    {
                        _AddType(hwndTree, szFileType, szFileTypePretty);
                    }
                }

                EndDialog(hwndDlg, 1);
                return TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, 0);
            return TRUE;
            break;
        }
        break;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _SettingDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND hwndParent;
    switch (uMsg)
    {
    case WM_NOTIFY :
        switch (((LPNMHDR)lParam)->code)
        {
        case NM_DBLCLK:
            // On this dialog, this message can only come from the listview.
            // If there is something selected, that means the user doubleclicked on an item
            // On a doubleclick we will trigger the OK button
            if (ListView_GetSelectedCount(GetDlgItem(hwndDlg, IDC_SETTINGPICKER_LIST)) > 0)
            {
                SendMessage (GetDlgItem(hwndDlg, IDOK), BM_CLICK, 0, 0);
            }
            break;
        case LVN_ITEMCHANGED:
            if (ListView_GetSelectedCount(GetDlgItem(hwndDlg, IDC_SETTINGPICKER_LIST)) > 0)
            {
                Button_Enable(GetDlgItem(hwndDlg, IDOK), TRUE);
            }
            else
            {
                Button_Enable(GetDlgItem(hwndDlg, IDOK), FALSE);
            }
            break;
        }
        break;

    case WM_INITDIALOG :
        {
            BOOL fListEmpty = TRUE;
            hwndParent = (HWND)lParam;
            HWND hwndList = GetDlgItem(hwndDlg, IDC_SETTINGPICKER_LIST);
            ListView_DeleteAllItems(hwndList);

            LVCOLUMN lvcolumn;
            lvcolumn.mask = LVCF_WIDTH;
            lvcolumn.cx = 250; // BUGBUG: should read width from box
            ListView_InsertColumn(hwndList, 0, &lvcolumn);

            Button_Enable(GetDlgItem(hwndDlg, IDOK), FALSE);

            MIG_COMPONENT_ENUM mce;
            if (IsmEnumFirstComponent (&mce, COMPONENTENUM_ALIASES | COMPONENTENUM_DISABLED |
                                       COMPONENTENUM_PREFERRED_ONLY, COMPONENT_NAME))
            {
                do
                {
                    if (MASTERGROUP_SYSTEM == mce.MasterGroup || MASTERGROUP_APP == mce.MasterGroup)
                    {
                        _ListView_InsertItem(hwndList, (PTSTR) mce.LocalizedAlias);
                        fListEmpty = FALSE;
                    }
                }
                while (IsmEnumNextComponent (&mce));
            }
            if (fListEmpty) {
                TCHAR szNothingToAdd[MAX_LOADSTRING];

                LoadString(g_migwiz->GetInstance(), IDS_NOMORE_SETTINGS, szNothingToAdd, ARRAYSIZE(szNothingToAdd));
                _ListView_InsertItem(hwndList, szNothingToAdd);
                EnableWindow (hwndList, FALSE);
            }
        }

        return TRUE;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            {
                HWND hwndTree = GetDlgItem(hwndParent, IDC_CUSTOMIZE_TREE);
                HWND hwndList = GetDlgItem(hwndDlg, IDC_SETTINGPICKER_LIST);
                TCHAR szSetting[MAX_PATH];
                INT iIndex = -1;
                UINT cSelCount = ListView_GetSelectedCount(hwndList);

                for (UINT x=0; x < cSelCount; x++)
                {
                    iIndex = ListView_GetNextItem(hwndList, iIndex, LVNI_SELECTED);
                    if (iIndex == -1)
                    {
                        break;
                    }

                    ListView_GetItemText(hwndList, iIndex, 0, szSetting, ARRAYSIZE(szSetting));
                    _AddSetting(hwndTree, szSetting);
                }

                EndDialog(hwndDlg, TRUE);
                return TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, FALSE);
            return TRUE;
            break;
        }
        break;
    }

    return 0;
}

///////////////////////////////////////////////////////////////

VOID _SetIcons (HWND hwnd)
{
    HICON hIcon;
    HINSTANCE hInstance = g_migwiz->GetInstance();

    if (!hwnd || !hInstance)
    {
        return;
    }

    hIcon = LoadIcon (hInstance, MAKEINTRESOURCE (2000));
    if (hIcon) {
        SendMessage (hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
        SendMessage (hwnd, WM_SETICON, ICON_SMALL, NULL);
    }

    SetWindowLong (hwnd, GWL_STYLE, WS_BORDER | WS_CAPTION);
    RedrawWindow (hwnd, NULL, NULL, RDW_INVALIDATE | RDW_INTERNALPAINT | RDW_ERASE);
}

VOID _SetPageHandles (HWND hwndPage)
{
    g_hwndDlg = hwndPage;
    g_hwndWizard = g_hwndDlg ? GetParent (hwndPage) : NULL;
}


VOID _NextWizardPage (HWND hwndCurrentPage)
{
    //
    // We only want to advance the page in the UI thread context
    //

    if (!g_NextPressed && g_hwndWizard) {
        if (PropSheet_GetCurrentPageHwnd (g_hwndWizard) == hwndCurrentPage) {
            PropSheet_PressButton(g_hwndWizard, PSBTN_NEXT);
            g_NextPressed = TRUE;
        }
    }
}

VOID _PrevWizardPage (VOID)
{
    //
    // We only want to advance the page in the UI thread context
    //

    if (g_hwndWizard) {
        PropSheet_PressButton(g_hwndWizard, PSBTN_BACK);
    }
}

INT_PTR CALLBACK _RootDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam, DWORD dwEnabled, BOOL fTitle, UINT uiTitleID)
{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        {
            g_migwiz = (MigrationWizard*) ((LPPROPSHEETPAGE) lParam) -> lParam;

            if (fTitle)
            {
                HWND hwndControl = GetDlgItem(hwndDlg, uiTitleID);
                SetWindowFont(hwndControl, g_migwiz->GetTitleFont(), TRUE);
            }
            break;
        }

    case WM_NOTIFY :
        {
        switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE : //Enable the Back and/or Next button
                g_hwndCurrent = hwndDlg;
                g_NextPressed = FALSE;
                PropSheet_SetWizButtons(GetParent(hwndDlg), dwEnabled);
                _SetPageHandles (hwndDlg);
                break;
            default :
                break;
            }
        }
        break;

    default:
        break;
    }
    return 0;
}

///////////////////////////////////////////////////////////////

VOID
pSetEvent (
    IN      HANDLE *Event
    )
{
    if (!*Event) {
        *Event = CreateEvent (NULL, TRUE, TRUE, NULL);
    } else {
        SetEvent (*Event);
    }
}

VOID
pResetEvent (
    IN      HANDLE *Event
    )
{
    if (!*Event) {
        *Event = CreateEvent (NULL, TRUE, FALSE, NULL);
    } else {
        ResetEvent (*Event);
    }
}

BOOL
pIsEventSet (
    IN      HANDLE *Event
    )
{
    DWORD result;

    if (!*Event) {
        *Event = CreateEvent (NULL, TRUE, TRUE, NULL);
        return TRUE;
    }
    result = WaitForSingleObject (*Event, 0);
    return (result == WAIT_OBJECT_0);
}

BOOL _HandleCancel (HWND hwndDlg, BOOL fStopNow, BOOL fConfirm)
{
    if (fConfirm)
    {
        TCHAR szConfirm[MAX_LOADSTRING];
        TCHAR szTitle[MAX_LOADSTRING];

        LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
        LoadString(g_migwiz->GetInstance(), IDS_CONFIRMCANCEL, szConfirm, ARRAYSIZE(szConfirm));
        if (IDNO == _ExclusiveMessageBox(hwndDlg, szConfirm, szTitle, MB_YESNO | MB_DEFBUTTON2))
        {
            // Do not exit
            SetWindowLong(hwndDlg, DWLP_MSGRESULT, TRUE);
            return TRUE;
        }
    }

    g_fUberCancel = TRUE;
    g_fCancelPressed = TRUE;
    Engine_Cancel();

    if (fStopNow)
    {
        // Exit now
        SetWindowLong(hwndDlg, DWLP_MSGRESULT, FALSE);
        return FALSE;
    }

    SendMessage (g_hwndCurrent, WM_USER_CANCEL_PENDING, 0, (LPARAM) E_ABORT);

    // Do not exit
    SetWindowLong(hwndDlg, DWLP_MSGRESULT, TRUE);
    return TRUE;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _IntroDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_NEXT, TRUE, IDC_INTRO_TITLE);

    switch (uMsg)
    {
    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            {
            static BOOL fInit = FALSE;
            if (!fInit)
            {
                _SetIcons (g_hwndWizard);
                fInit = TRUE;
            }
            break;
            }
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, TRUE, FALSE);
            break;
        case PSN_WIZNEXT:
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ENDCOLLECTFAIL);
            }
            else
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_GETSTARTED);
            }
            return TRUE;
            break;
        }
        case NM_CLICK:
            if (wParam == IDC_INTRO_TEXT3) {
                TCHAR szAppPath[MAX_PATH] = TEXT("");
                LONG appPathSize;
                TCHAR szHtmlPath[MAX_PATH] = TEXT("");
                TCHAR szCmdLine[MAX_PATH * 3] = TEXT("");
                BOOL bResult;
                LONG lResult;
                STARTUPINFO si;
                PROCESS_INFORMATION pi;

                PNMLINK nmLink = (PNMLINK) lParam;
                if (_wcsicmp (nmLink->item.szID, L"StartHelp") == 0) {
                    if (GetWindowsDirectory (szHtmlPath, ARRAYSIZE(szHtmlPath))) {
                        // let's get the path to iexplore.exe
                        appPathSize = MAX_PATH;
                        lResult = RegQueryValue (
                                    HKEY_LOCAL_MACHINE,
                                    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE"),
                                    szAppPath,
                                    &appPathSize
                                    );
                        if (lResult == ERROR_SUCCESS) {
                            _tcscat (szHtmlPath, TEXT("\\Help\\migwiz.htm"));

                            if (_tcsnextc (szAppPath) != TEXT('\"')) {
                                _tcscpy (szCmdLine, TEXT("\""));
                                _tcscat (szCmdLine, szAppPath);
                                _tcscat (szCmdLine, TEXT("\" "));
                            } else {
                                _tcscpy (szCmdLine, szAppPath);
                                _tcscat (szCmdLine, TEXT(" "));
                            }
                            _tcscat (szCmdLine, szHtmlPath);

                            ZeroMemory( &si, sizeof(STARTUPINFO) );
                            si.cb = sizeof(STARTUPINFO);
                            bResult = CreateProcess(
                                        NULL,
                                        szCmdLine,
                                        NULL,
                                        NULL,
                                        FALSE,
                                        0,
                                        NULL,
                                        NULL,
                                        &si,
                                        &pi
                                        );
                            if (bResult) {
                                CloseHandle (pi.hProcess);
                                CloseHandle (pi.hThread);
                            }
                        }
                    }
                }
            }
            break;
        break;
    }

    return 0;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _IntroLegacyDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_NEXT, TRUE, IDC_INTROLEGACY_TITLE);

    switch (uMsg)
    {
    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            {
            static BOOL fInit = FALSE;

            g_fOldComputer = TRUE; // we are on the old machine

            if (!fInit)
            {
                _SetIcons (g_hwndWizard);
                fInit = TRUE;
            }
            break;
            }
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, TRUE, FALSE);
            break;
        case PSN_WIZNEXT:
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ENDCOLLECTFAIL);
            }
            else
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_WAIT);
            }
            return TRUE;
            break;
        }
        break;
    }

    return 0;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _IntroOOBEDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_NEXT, TRUE, IDC_INTROOOBE_TITLE);

    switch (uMsg)
    {
    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            break;
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, TRUE, FALSE);
            break;
        case PSN_WIZNEXT:
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ENDCOLLECTFAIL);
            }
            else
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKMETHOD); // go on with prepare
            }
            return TRUE;
            break;
        }
        break;
    }

    return 0;
}

///////////////////////////////////////////////////////////////

VOID DisableCancel (VOID)
{
    if (g_hwndWizard) {
        SetFocus (GetDlgItem (g_hwndWizard, IDOK));
        EnableWindow (GetDlgItem (g_hwndWizard, IDCANCEL), FALSE);
    }
}

VOID EnableCancel (VOID)
{
    if (g_hwndWizard) {
        EnableWindow (GetDlgItem (g_hwndWizard, IDCANCEL), TRUE);
    }
}

VOID PostMessageForWizard (
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (g_hwndCurrent) {
        PostMessage (g_hwndCurrent, Msg, wParam, lParam);
    }
}

BOOL
pWriteStrResToFile (
    IN      HANDLE FileHandle,
    IN      DWORD StrId
    )
{
    TCHAR strFromRes[MAX_LOADSTRING] = TEXT("");
    INT strLen = 0;
    DWORD written;

    strLen = LoadString (g_migwiz->GetInstance(), StrId, strFromRes, ARRAYSIZE(strFromRes));
    if (strLen) {
        WriteFile (FileHandle, strFromRes, (_tcslen (strFromRes) + 1) * sizeof (TCHAR), &written, NULL);
        return TRUE;
    }
    return FALSE;
}

BOOL
pGenerateHTMLWarnings (
    IN      HANDLE FileHandle,
    IN      DWORD BeginId,
    IN      DWORD EndId,
    IN      DWORD AreaId,
    IN      DWORD InstrId,
    IN      DWORD WrnId,
    IN      DWORD WrnFileId1,
    IN      DWORD WrnFileId2,
    IN      DWORD WrnAltFileId1,
    IN      DWORD WrnAltFileId2,
    IN      DWORD WrnRasId1,
    IN      DWORD WrnRasId2,
    IN      DWORD WrnNetId1,
    IN      DWORD WrnNetId2,
    IN      DWORD WrnPrnId1,
    IN      DWORD WrnPrnId2,
    IN      DWORD WrnGeneralId1,
    IN      DWORD WrnGeneralId2
    )
{
    TCHAR szLoadStr[MAX_LOADSTRING];
    DWORD objTypes = 0;
    POBJLIST objList = NULL;
    DWORD written;

#ifdef UNICODE
    ((PBYTE)szLoadStr) [0] = 0xFF;
    ((PBYTE)szLoadStr) [1] = 0xFE;
    WriteFile (FileHandle, szLoadStr, 2, &written, NULL);
#endif

    pWriteStrResToFile (FileHandle, BeginId);

    if (AreaId) {
        pWriteStrResToFile (FileHandle, AreaId);
        if (InstrId) {
            pWriteStrResToFile (FileHandle, InstrId);
        }
    }

    // let's see if we have some object that could not be restored
    objTypes = 0;
    if (g_HTMLWrnFile) {
        objTypes ++;
    }
    if (g_HTMLWrnAltFile) {
        objTypes ++;
    }
    if (g_HTMLWrnRas) {
        objTypes ++;
    }
    if (g_HTMLWrnNet) {
        objTypes ++;
    }
    if (g_HTMLWrnPrn) {
        objTypes ++;
    }
    if (g_HTMLWrnGeneral) {
        objTypes ++;
    }
    if (objTypes) {
        if (objTypes > 1) {
            if (WrnId) {
                pWriteStrResToFile (FileHandle, WrnId);
            }
        }
        if (g_HTMLWrnFile) {
            if (objTypes > 1) {
                pWriteStrResToFile (FileHandle, WrnFileId1);
            } else {
                pWriteStrResToFile (FileHandle, WrnFileId2);
            }

            _tcscpy (szLoadStr, TEXT("<UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

            objList = g_HTMLWrnFile;
            while (objList) {
                if (objList->ObjectName) {
                    _tcscpy (szLoadStr, TEXT("<LI>"));
                    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
                    WriteFile (FileHandle, objList->ObjectName, (_tcslen (objList->ObjectName) + 1) * sizeof (TCHAR), &written, NULL);
                }
                objList = objList->Next;
            }

            _tcscpy (szLoadStr, TEXT("</UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
        }
        if (g_HTMLWrnAltFile) {
            if (objTypes > 1) {
                pWriteStrResToFile (FileHandle, WrnAltFileId1);
            } else {
                pWriteStrResToFile (FileHandle, WrnAltFileId2);
            }

            _tcscpy (szLoadStr, TEXT("<UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

            objList = g_HTMLWrnAltFile;
            while (objList) {
                if (objList->ObjectName) {
                    _tcscpy (szLoadStr, TEXT("<LI>"));
                    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
                    WriteFile (FileHandle, objList->ObjectName, (_tcslen (objList->ObjectName) + 1) * sizeof (TCHAR), &written, NULL);
                }
                objList = objList->Next;
            }

            _tcscpy (szLoadStr, TEXT("</UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
        }
        if (g_HTMLWrnRas) {
            if (objTypes > 1) {
                pWriteStrResToFile (FileHandle, WrnRasId1);
            } else {
                pWriteStrResToFile (FileHandle, WrnRasId2);
            }

            _tcscpy (szLoadStr, TEXT("<UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

            objList = g_HTMLWrnRas;
            while (objList) {
                if (objList->ObjectName) {
                    _tcscpy (szLoadStr, TEXT("<LI>"));
                    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
                    WriteFile (FileHandle, objList->ObjectName, (_tcslen (objList->ObjectName) + 1) * sizeof (TCHAR), &written, NULL);
                }
                objList = objList->Next;
            }

            _tcscpy (szLoadStr, TEXT("</UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
        }
        if (g_HTMLWrnNet) {
            if (objTypes > 1) {
                pWriteStrResToFile (FileHandle, WrnNetId1);
            } else {
                pWriteStrResToFile (FileHandle, WrnNetId2);
            }

            _tcscpy (szLoadStr, TEXT("<UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

            objList = g_HTMLWrnNet;
            while (objList) {
                if (objList->ObjectName) {
                    _tcscpy (szLoadStr, TEXT("<LI>"));
                    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
                    WriteFile (FileHandle, objList->ObjectName, (_tcslen (objList->ObjectName) + 1) * sizeof (TCHAR), &written, NULL);
                }
                objList = objList->Next;
            }

            _tcscpy (szLoadStr, TEXT("</UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
        }
        if (g_HTMLWrnPrn) {
            if (objTypes > 1) {
                pWriteStrResToFile (FileHandle, WrnPrnId1);
            } else {
                pWriteStrResToFile (FileHandle, WrnPrnId2);
            }

            _tcscpy (szLoadStr, TEXT("<UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

            objList = g_HTMLWrnPrn;
            while (objList) {
                if (objList->ObjectName) {
                    _tcscpy (szLoadStr, TEXT("<LI>"));
                    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
                    WriteFile (FileHandle, objList->ObjectName, (_tcslen (objList->ObjectName) + 1) * sizeof (TCHAR), &written, NULL);
                }
                objList = objList->Next;
            }

            _tcscpy (szLoadStr, TEXT("</UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
        }
        if (g_HTMLWrnGeneral) {
            if (objTypes > 1) {
                pWriteStrResToFile (FileHandle, WrnGeneralId1);
            } else {
                pWriteStrResToFile (FileHandle, WrnGeneralId2);
            }
            _tcscpy (szLoadStr, TEXT("<UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

            objList = g_HTMLWrnGeneral;
            while (objList) {
                if (objList->ObjectName) {
                    _tcscpy (szLoadStr, TEXT("<LI>"));
                    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
                    WriteFile (FileHandle, objList->ObjectName, (_tcslen (objList->ObjectName) + 1) * sizeof (TCHAR), &written, NULL);
                }
                objList = objList->Next;
            }
            _tcscpy (szLoadStr, TEXT("</UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
        }
    }

    pWriteStrResToFile (FileHandle, EndId);

    return TRUE;
}

INT_PTR CALLBACK _EndCollectDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    IWebBrowser2    *m_pweb = NULL;            // IE4 IWebBrowser interface pointer
    IUnknown        *punk = NULL;
    HWND webHostWnd = NULL;
    HANDLE hHTMLLog = INVALID_HANDLE_VALUE;
    PWSTR szTarget;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylifyTitle(hwndDlg);
        }
        if (!g_fCancelPressed) {
            webHostWnd = GetDlgItem (hwndDlg, IDC_WEBHOST);
            if (webHostWnd) {
                // Now let's generate the failure HTML file.
                if (*g_HTMLLog) {
                    hHTMLLog = CreateFile (g_HTMLLog, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
                    if (hHTMLLog != INVALID_HANDLE_VALUE) {
                        pGenerateHTMLWarnings (
                            hHTMLLog,
                            IDS_COLLECT_BEGIN,
                            IDS_COLLECT_END,
                            0,
                            0,
                            IDS_WARNING_SAVE,
                            IDS_WARNING_SAVEFILE1,
                            IDS_WARNING_SAVEFILE2,
                            IDS_WARNING_SAVEFILE1,
                            IDS_WARNING_SAVEFILE2,
                            IDS_WARNING_SAVERAS1,
                            IDS_WARNING_SAVERAS2,
                            IDS_WARNING_SAVENET1,
                            IDS_WARNING_SAVENET2,
                            IDS_WARNING_SAVEPRN1,
                            IDS_WARNING_SAVEPRN2,
                            0,
                            0
                            );
                        g_WebContainer = new Container();
                        if (g_WebContainer)
                        {
                            g_WebContainer->setParent(webHostWnd);
                            g_WebContainer->add(L"Shell.Explorer");
                            g_WebContainer->setVisible(TRUE);
                            g_WebContainer->setFocus(TRUE);

                            //
                            //  get the IWebBrowser2 interface and cache it.
                            //
                            punk = g_WebContainer->getUnknown();
                            if (punk)
                            {
                                punk->QueryInterface(IID_IWebBrowser2, (PVOID *)&m_pweb);
                                if (m_pweb) {
#ifdef UNICODE
                                    m_pweb->Navigate(g_HTMLLog, NULL, NULL, NULL, NULL);
#else
                                    szTarget = _ConvertToUnicode (CP_ACP, g_HTMLLog);
                                    if (szTarget) {
                                        m_pweb->Navigate(szTarget, NULL, NULL, NULL, NULL);
                                        LocalFree ((HLOCAL)szTarget);
                                        szTarget = NULL;
                                    }
#endif
                                }
                                punk->Release();
                                punk = NULL;
                            }
                        }
                        // We intentionally want to keep this file open for the life of the wizard.
                        // With this we eliminate the possibility for someone to overwrite the
                        // content of the HTML file therefore forcing us to show something else
                        // maybe even run some malicious script.
                        // CloseHandle (hHTMLLog);
                    }
                } else {
                    ShowWindow(webHostWnd, SW_HIDE);
                }
            }
        }
        break;

    case WM_DESTROY:
        if (m_pweb)
            m_pweb->Release();
            m_pweb = NULL;

        //
        //  tell the container to remove IE4 and then
        //  release our reference to the container.
        //
        if (g_WebContainer)
        {
            g_WebContainer->remove();
            g_WebContainer->Release();
            g_WebContainer = NULL;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            DisableCancel();
            break;
        }
        break;
    }

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_FINISH, TRUE, IDC_ENDCOLLECT_TITLE);

    return 0;
}

INT_PTR CALLBACK _EndCollectNetDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static IWebBrowser2    *m_pweb = NULL;            // IE4 IWebBrowser interface pointer
    IUnknown        *punk = NULL;
    HWND webHostWnd = NULL;
    HANDLE hHTMLLog = INVALID_HANDLE_VALUE;
    PWSTR szTarget;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylifyTitle(hwndDlg);
        }
        if (!g_fCancelPressed) {
            webHostWnd = GetDlgItem (hwndDlg, IDC_WEBHOST);
            if (webHostWnd) {
                // Now let's generate the failure HTML file.
                if (*g_HTMLLog) {
                    hHTMLLog = CreateFile (g_HTMLLog, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
                    if (hHTMLLog != INVALID_HANDLE_VALUE) {
                        pGenerateHTMLWarnings (
                            hHTMLLog,
                            IDS_COLLECTNET_BEGIN,
                            IDS_COLLECTNET_END,
                            0,
                            0,
                            IDS_WARNING_SAVE,
                            IDS_WARNING_SAVEFILE1,
                            IDS_WARNING_SAVEFILE2,
                            IDS_WARNING_SAVEFILE1,
                            IDS_WARNING_SAVEFILE2,
                            IDS_WARNING_SAVERAS1,
                            IDS_WARNING_SAVERAS2,
                            IDS_WARNING_SAVENET1,
                            IDS_WARNING_SAVENET2,
                            IDS_WARNING_SAVEPRN1,
                            IDS_WARNING_SAVEPRN2,
                            0,
                            0
                            );
                        g_WebContainer = new Container();
                        if (g_WebContainer)
                        {
                            g_WebContainer->setParent(webHostWnd);
                            g_WebContainer->add(L"Shell.Explorer");
                            g_WebContainer->setVisible(TRUE);
                            g_WebContainer->setFocus(TRUE);

                            //
                            //  get the IWebBrowser2 interface and cache it.
                            //
                            punk = g_WebContainer->getUnknown();
                            if (punk)
                            {
                                punk->QueryInterface(IID_IWebBrowser2, (PVOID *)&m_pweb);
                                if (m_pweb) {
#ifdef UNICODE
                                    m_pweb->Navigate(g_HTMLLog, NULL, NULL, NULL, NULL);
#else
                                    szTarget = _ConvertToUnicode (CP_ACP, g_HTMLLog);
                                    if (szTarget) {
                                        m_pweb->Navigate(szTarget, NULL, NULL, NULL, NULL);
                                        LocalFree ((HLOCAL)szTarget);
                                        szTarget = NULL;
                                    }
#endif
                                }
                                punk->Release();
                                punk = NULL;
                            }
                        }
                        // We intentionally want to keep this file open for the life of the wizard.
                        // With this we eliminate the possibility for someone to overwrite the
                        // content of the HTML file therefore forcing us to show something else
                        // maybe even run some malicious script.
                        // CloseHandle (hHTMLLog);
                    }
                } else {
                    ShowWindow(webHostWnd, SW_HIDE);
                }
            }
        }
        break;

    case WM_DESTROY:
        if (m_pweb)
            m_pweb->Release();
            m_pweb = NULL;

        //
        //  tell the container to remove IE4 and then
        //  release our reference to the container.
        //
        if (g_WebContainer)
        {
            g_WebContainer->remove();
            g_WebContainer->Release();
            g_WebContainer = NULL;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            DisableCancel();
            break;
        }
        break;
    }

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_FINISH, TRUE, IDC_ENDCOLLECT_TITLE);

    return 0;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _EndOOBEDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_FINISH, TRUE, IDC_ENDOOBE_TITLE);
    return 0;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _EndApplyDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    IWebBrowser2    *m_pweb = NULL;            // IE4 IWebBrowser interface pointer
    IUnknown        *punk = NULL;
    HWND webHostWnd = NULL;
    HANDLE hHTMLLog = INVALID_HANDLE_VALUE;
    PWSTR szTarget;
    TCHAR szAskForLogOff[MAX_LOADSTRING] = TEXT("");
    TCHAR szAskForReboot[MAX_LOADSTRING] = TEXT("");
    TCHAR szTitle[MAX_LOADSTRING] = TEXT("");

    switch (uMsg)
    {
    case WM_INITDIALOG:
        if (!g_fCancelPressed) {
            webHostWnd = GetDlgItem (hwndDlg, IDC_WEBHOST);
            if (webHostWnd) {
                // Now let's generate the failure HTML file.
                if (*g_HTMLLog) {
                    hHTMLLog = CreateFile (g_HTMLLog, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
                    if (hHTMLLog != INVALID_HANDLE_VALUE) {
                        pGenerateHTMLWarnings (
                            hHTMLLog,
                            IDS_APPLY_BEGIN,
                            IDS_APPLY_END,
                            0,
                            0,
                            IDS_WARNING_RESTORE,
                            IDS_WARNING_RESTOREFILE1,
                            IDS_WARNING_RESTOREFILE2,
                            IDS_WARNING_RESTOREALTFILE1,
                            IDS_WARNING_RESTOREALTFILE2,
                            IDS_WARNING_RESTORERAS1,
                            IDS_WARNING_RESTORERAS2,
                            IDS_WARNING_RESTORENET1,
                            IDS_WARNING_RESTORENET2,
                            IDS_WARNING_RESTOREPRN1,
                            IDS_WARNING_RESTOREPRN2,
                            IDS_WARNING_RESTOREGENERAL1,
                            IDS_WARNING_RESTOREGENERAL2
                            );
                        g_WebContainer = new Container();
                        if (g_WebContainer)
                        {
                            g_WebContainer->setParent(webHostWnd);
                            g_WebContainer->add(L"Shell.Explorer");
                            g_WebContainer->setVisible(TRUE);
                            g_WebContainer->setFocus(TRUE);

                            //
                            //  get the IWebBrowser2 interface and cache it.
                            //
                            punk = g_WebContainer->getUnknown();
                            if (punk)
                            {
                                punk->QueryInterface(IID_IWebBrowser2, (PVOID *)&m_pweb);
                                if (m_pweb) {
#ifdef UNICODE
                                    m_pweb->Navigate(g_HTMLLog, NULL, NULL, NULL, NULL);
#else
                                    szTarget = _ConvertToUnicode (CP_ACP, g_HTMLLog);
                                    if (szTarget) {
                                        m_pweb->Navigate(szTarget, NULL, NULL, NULL, NULL);
                                        LocalFree ((HLOCAL)szTarget);
                                        szTarget = NULL;
                                    }
#endif
                                }
                                punk->Release();
                                punk = NULL;
                            }
                        }
                        // We intentionally want to keep this file open for the life of the wizard.
                        // With this we eliminate the possibility for someone to overwrite the
                        // content of the HTML file therefore forcing us to show something else
                        // maybe even run some malicious script.
                        // CloseHandle (hHTMLLog);
                    }
                } else {
                    ShowWindow(webHostWnd, SW_HIDE);
                }
            }
        }
        break;

    case WM_DESTROY:
        if (m_pweb)
            m_pweb->Release();
            m_pweb = NULL;

        //
        //  tell the container to remove IE4 and then
        //  release our reference to the container.
        //
        if (g_WebContainer)
        {
            g_WebContainer->remove();
            g_WebContainer->Release();
            g_WebContainer = NULL;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            DisableCancel();
            break;

        case PSN_WIZFINISH:
            ShowWindow(g_hwndWizard, SW_HIDE);
            if (g_CompleteReboot) {
                g_CompleteReboot = FALSE;
                g_CompleteLogOff = FALSE;
                if (LoadString(g_migwiz->GetInstance(),
                               IDS_MIGWIZTITLE,
                               szTitle,
                               ARRAYSIZE(szTitle))) {
                    if (LoadString(g_migwiz->GetInstance(),
                                   IDS_ASKFORREBOOT,
                                   szAskForReboot,
                                   ARRAYSIZE(szAskForReboot))) {
                        if (_ExclusiveMessageBox(g_hwndWizard, szAskForReboot, szTitle, MB_YESNO) == IDYES) {
                            g_ConfirmedReboot = TRUE;
                        }
                    }
                }
            } else if (g_CompleteLogOff) {
                g_CompleteLogOff = FALSE;
                if (LoadString(g_migwiz->GetInstance(),
                               IDS_MIGWIZTITLE,
                               szTitle,
                               ARRAYSIZE(szTitle))) {
                    if (LoadString(g_migwiz->GetInstance(),
                                   IDS_ASKFORLOGOFF,
                                   szAskForLogOff,
                                   ARRAYSIZE(szAskForLogOff))) {
                        if (_ExclusiveMessageBox(g_hwndWizard, szAskForLogOff, szTitle, MB_YESNO) == IDYES) {
                            g_ConfirmedLogOff = TRUE;
                        }
                    }
                }
            }
        }
        break;
    }

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_FINISH, TRUE, IDC_ENDAPPLY_TITLE);
    return 0;
}

///////////////////////////////////////////////////////////////

typedef struct {
    BOOL fSource;
    HWND hwndDlg;
} CLEANUPSTRUCT;

DWORD WINAPI _FailureCleanUpThread (LPVOID lpParam)
{
    CLEANUPSTRUCT* pcsStruct = (CLEANUPSTRUCT*)lpParam;
    DWORD result = WAIT_OBJECT_0;
    HRESULT hResult = ERROR_SUCCESS;

    //
    // Wait for the current thread to finish
    //
    if (g_TerminateEvent)
    {
        result = WaitForSingleObject (g_TerminateEvent, ENGINE_TIMEOUT);
    }

    //
    // Terminate the engine
    //

    if (result == WAIT_OBJECT_0) {
        hResult = Engine_Terminate ();
    }

    SendMessage (pcsStruct->hwndDlg, WM_USER_THREAD_COMPLETE, 0, (LPARAM) hResult);

    LocalFree(pcsStruct);

    return 0;
}

INT_PTR CALLBACK _CleanUpDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hResult;

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, 0, FALSE, 0);
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_FAILCLEANUPTITLE);
        }
        break;

    case WM_NOTIFY :
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            DisableCancel();
            {
                ANIMATE_OPEN(hwndDlg,IDC_WAIT_ANIMATE2,IDA_STARTUP);
                ANIMATE_PLAY(hwndDlg,IDC_WAIT_ANIMATE2);

                CLEANUPSTRUCT* pcsStruct = (CLEANUPSTRUCT*)LocalAlloc(LPTR, sizeof(CLEANUPSTRUCT));
                if (pcsStruct)
                {
                    pcsStruct->fSource = g_fOldComputer;
                    pcsStruct->hwndDlg = hwndDlg;

                    SHCreateThread(_FailureCleanUpThread, pcsStruct, 0, NULL);
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, g_fOldComputer?IDD_ENDCOLLECTFAIL:IDD_ENDAPPLYFAIL);
                }
            }
            return TRUE;
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            ANIMATE_STOP(hwndDlg,IDC_WAIT_ANIMATE2);
            ANIMATE_CLOSE(hwndDlg,IDC_WAIT_ANIMATE2);
            if (g_fCancelPressed)
            {
                // User aborted
                PostQuitMessage( 0 );
            }
            else
            {
                // Error condition
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, g_fOldComputer?IDD_ENDCOLLECTFAIL:IDD_ENDAPPLYFAIL);
            }
            return TRUE;
            break;
        }
        break;

    case WM_USER_THREAD_COMPLETE:
        hResult = (HRESULT) lParam;
        if (FAILED(hResult))
        {
            g_fUberCancel = TRUE;
        }
        _NextWizardPage (hwndDlg);
        break;

    default:
        break;
    }

    return 0;
}

INT_PTR CALLBACK _EndFailDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    IWebBrowser2    *m_pweb = NULL;            // IE4 IWebBrowser interface pointer
    IUnknown        *punk = NULL;
    HWND webHostWnd = NULL;
    HANDLE hHTMLLog = INVALID_HANDLE_VALUE;
    TCHAR szLoadStr[MAX_LOADSTRING];
    DWORD written;
    PWSTR szTarget;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylifyTitle(hwndDlg);
        }
        if (!g_fCancelPressed) {
            webHostWnd = GetDlgItem (hwndDlg, IDC_WEBHOST);
            if (webHostWnd) {
                // Now let's generate the failure HTML file.
                if (*g_HTMLLog) {
                    hHTMLLog = CreateFile (g_HTMLLog, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
                    if (hHTMLLog != INVALID_HANDLE_VALUE) {
                        pGenerateHTMLWarnings (
                            hHTMLLog,
                            IDS_ERRORHTML_BEGIN,
                            IDS_ERRORHTML_END,
                            g_HTMLErrArea?g_HTMLErrArea:IDS_ERRORAREA_UNKNOWN,
                            g_HTMLErrInstr,
                            0,
                            IDS_ERRORHTML_SAVEFILE1,
                            IDS_ERRORHTML_SAVEFILE2,
                            IDS_ERRORHTML_SAVEFILE1,
                            IDS_ERRORHTML_SAVEFILE2,
                            IDS_ERRORHTML_SAVERAS1,
                            IDS_ERRORHTML_SAVERAS2,
                            IDS_ERRORHTML_SAVENET1,
                            IDS_ERRORHTML_SAVENET2,
                            IDS_ERRORHTML_SAVEPRN1,
                            IDS_ERRORHTML_SAVEPRN2,
                            0,
                            0
                            );
                        g_WebContainer = new Container();
                        if (g_WebContainer)
                        {
                            g_WebContainer->setParent(webHostWnd);
                            g_WebContainer->add(L"Shell.Explorer");
                            g_WebContainer->setVisible(TRUE);
                            g_WebContainer->setFocus(TRUE);

                            //
                            //  get the IWebBrowser2 interface and cache it.
                            //
                            punk = g_WebContainer->getUnknown();
                            if (punk)
                            {
                                punk->QueryInterface(IID_IWebBrowser2, (PVOID *)&m_pweb);
                                if (m_pweb) {
#ifdef UNICODE
                                    m_pweb->Navigate(g_HTMLLog, NULL, NULL, NULL, NULL);
#else
                                    szTarget = _ConvertToUnicode (CP_ACP, g_HTMLLog);
                                    if (szTarget) {
                                        m_pweb->Navigate(szTarget, NULL, NULL, NULL, NULL);
                                        LocalFree ((HLOCAL)szTarget);
                                        szTarget = NULL;
                                    }
#endif
                                }
                                punk->Release();
                                punk = NULL;
                            }
                        }
                        // We intentionally want to keep this file open for the life of the wizard.
                        // With this we eliminate the possibility for someone to overwrite the
                        // content of the HTML file therefore forcing us to show something else
                        // maybe even run some malicious script.
                        // CloseHandle (hHTMLLog);
                    }
                } else {
                    ShowWindow(webHostWnd, SW_HIDE);
                }
            }
        }
        break;

    case WM_DESTROY:
        if (m_pweb)
            m_pweb->Release();
            m_pweb = NULL;

        //
        //  tell the container to remove IE4 and then
        //  release our reference to the container.
        //
        if (g_WebContainer)
        {
            g_WebContainer->remove();
            g_WebContainer->Release();
            g_WebContainer = NULL;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            DisableCancel();
            break;
        }
        break;
    }

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_FINISH, TRUE, IDC_ENDFAIL_TITLE);
    return 0;
}

///////////////////////////////////////////////////////////////

typedef struct {
    PBOOL pfHaveNet;
    BOOL fSource;
    HWND hwndDlg;
} STARTENGINESTRUCT;

DWORD WINAPI _StartEngineDlgProcThread (LPVOID lpParam)
{
    STARTENGINESTRUCT* pseStruct = (STARTENGINESTRUCT*)lpParam;
    HRESULT hResult;

    hResult = g_migwiz->_InitEngine(pseStruct->fSource, pseStruct->pfHaveNet);

    SendMessage (pseStruct->hwndDlg, WM_USER_THREAD_COMPLETE, 0, (LPARAM) hResult);

    pSetEvent (&g_TerminateEvent);

    LocalFree(pseStruct);

    return 0;
}

INT_PTR CALLBACK _StartEngineDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hResult;

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, 0, FALSE, 0);
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_WAITTITLE);
        }
        break;
    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, FALSE, TRUE);
            break;
        case PSN_SETACTIVE:
            if ((ENGINE_INITGATHER == g_iEngineInit && g_fOldComputer) ||
                (ENGINE_INITAPPLY == g_iEngineInit && !g_fOldComputer))
            {
                PropSheet_PressButton(GetParent(hwndDlg), PSBTN_NEXT);
            }
            else
            {
                ANIMATE_OPEN(hwndDlg,IDC_WAIT_ANIMATE1,IDA_STARTUP);
                ANIMATE_PLAY(hwndDlg,IDC_WAIT_ANIMATE1);

                STARTENGINESTRUCT* pseStruct = (STARTENGINESTRUCT*)LocalAlloc(LPTR, sizeof(STARTENGINESTRUCT));
                if (pseStruct)
                {
                    pseStruct->fSource = g_fOldComputer;
                    pseStruct->pfHaveNet = &g_fHaveNet;
                    pseStruct->hwndDlg = hwndDlg;

                    SHCreateThread(_StartEngineDlgProcThread, pseStruct, 0, NULL);
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, g_fOldComputer?IDD_ENDCOLLECTFAIL:IDD_ENDAPPLYFAIL);
                }
            }
            return TRUE;
            break;
        case PSN_WIZNEXT:
            ANIMATE_STOP(hwndDlg,IDC_WAIT_ANIMATE1);
            ANIMATE_CLOSE(hwndDlg,IDC_WAIT_ANIMATE1);
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
            }
            else if (g_fOldComputer)
            {
                g_iEngineInit = ENGINE_INITGATHER;
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKCOLLECTSTORE); // go on with prepare
            }
            else
            {
                g_iEngineInit = ENGINE_INITAPPLY;
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ASKCD); // go on with apply
            }

            return TRUE;
            break;
        case PSN_WIZBACK:
            // ISSUE: we should assert here or something, this should never happen
            ANIMATE_STOP(hwndDlg,IDC_WAIT_ANIMATE1);
            ANIMATE_CLOSE(hwndDlg,IDC_WAIT_ANIMATE1);
            if (g_fOldComputer)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, g_migwiz->GetLegacy() ? IDD_INTROLEGACY : IDD_GETSTARTED);
            }
            else
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_GETSTARTED);
            }
            return TRUE;
            break;
        }
        break;

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pResetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    case WM_USER_THREAD_COMPLETE:

        hResult = (HRESULT) lParam;

        if (FAILED(hResult))
        {
            g_fUberCancel = TRUE;
        }

        EnableCancel ();

        _NextWizardPage (hwndDlg);

        break;

    case WM_USER_ROLLBACK:

        // Hide IDC_WAIT_TEXT1 and show IDC_WAIT_TEXT2
        ShowWindow(GetDlgItem(hwndDlg, IDC_WAIT_TEXT1), SW_HIDE);
        ShowWindow(GetDlgItem(hwndDlg, IDC_WAIT_TEXT2), SW_SHOW);
        break;

    default:
        break;
    }

    return 0;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _GetStartedDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static UINT uiSelectedStart = 2; // 1=old, 2=new

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK | PSWIZB_NEXT, FALSE, 0);
    switch (uMsg)
    {
    case WM_INITDIALOG:
        Button_SetCheck(GetDlgItem(hwndDlg,IDC_GETSTARTED_RADIONEW), BST_CHECKED);
        Button_SetCheck(GetDlgItem(hwndDlg,IDC_GETSTARTED_RADIOOLD), BST_UNCHECKED);
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_GETSTARTED_RADIOOLD:
            uiSelectedStart = 1;
            break;
        case IDC_GETSTARTED_RADIONEW:
            uiSelectedStart = 2;
            break;
        }
        break;
    case WM_NOTIFY :
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, TRUE, FALSE);
            break;

        case PSN_WIZNEXT:
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ENDAPPLYFAIL);
            }
            else
            {
                g_fOldComputer = (uiSelectedStart == 1);

                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_WAIT); // go on with prepare
            }

            return TRUE;
            break;

        case PSN_WIZBACK:
            SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_INTRO);
            return TRUE;
            break;
        }
        break;

    default:
        break;
    }

    return 0;
}

///////////////////////////////////////////////////////////////

VOID _CleanTreeView(HWND hwndTree)
{
    if (hwndTree)
    {
        HTREEITEM rghti[4] = { g_htiFolders, g_htiFiles, g_htiSettings, g_htiTypes };

        HTREEITEM hti;
        TVITEM item = {0};
        item.mask = TVIF_PARAM | TVIF_HANDLE;

        for (int i = 0; i < ARRAYSIZE(rghti); i++)
        {
            hti = rghti[i];

            if (hti)
            {
                hti = TreeView_GetChild(hwndTree, hti);

                while (hti)
                {
                    item.hItem = hti;
                    if (TreeView_GetItem(hwndTree, &item))
                    {
                        if (item.lParam)
                        {
                            if (((LV_DATASTRUCT*)item.lParam)->pszPureName)
                            {
                                LocalFree(((LV_DATASTRUCT*)item.lParam)->pszPureName);
                            }
                            LocalFree((HLOCAL)item.lParam);
                        }
                    }
                    hti = TreeView_GetNextItem(hwndTree, hti, TVGN_NEXT);
                }
            }
        }
        TreeView_DeleteAllItems(hwndTree);
    }
}

VOID __PopulateFilesDocumentsCollected (HWND hwndTree, UINT uiRadio)
{
    MIG_COMPONENT_ENUM mce;

    _CleanTreeView(hwndTree); // ISSUE: we should free the memory of all elements in this tree

    g_htiFolders = NULL;
    g_htiFiles = NULL;
    g_htiTypes = NULL;
    g_htiSettings = NULL;

    if (IsmEnumFirstComponent (&mce, COMPONENTENUM_ALIASES|COMPONENTENUM_ENABLED|
                               COMPONENTENUM_PREFERRED_ONLY, 0))
    {
        do {
            switch (mce.GroupId)
            {

            case COMPONENT_FOLDER:
                _PopulateTree (
                    hwndTree,
                    __GetRootFolder (hwndTree),
                    (PTSTR) mce.LocalizedAlias,
                    lstrlen (mce.LocalizedAlias) + 1,
                    _GetPrettyFolderName,
                    POPULATETREE_FLAGS_FOLDERS,
                    g_migwiz->GetInstance(),
                    g_migwiz->GetWinNT4()
                    );
                mce.SkipToNextComponent = TRUE;
                break;

            case COMPONENT_FILE:
                _PopulateTree (
                    hwndTree,
                    __GetRootFile (hwndTree),
                    (PTSTR) mce.LocalizedAlias,
                    lstrlen (mce.LocalizedAlias) + 1,
                    NULL,
                    POPULATETREE_FLAGS_FILES,
                    g_migwiz->GetInstance(),
                    g_migwiz->GetWinNT4()
                    );
                mce.SkipToNextComponent = TRUE;
                break;

            case COMPONENT_EXTENSION:
                _PopulateTree (
                    hwndTree,
                    __GetRootType (hwndTree),
                    (PTSTR) mce.LocalizedAlias,
                    lstrlen (mce.LocalizedAlias) + 1,
                    NULL,
                    POPULATETREE_FLAGS_FILETYPES,
                    g_migwiz->GetInstance(),
                    g_migwiz->GetWinNT4()
                    );
                mce.SkipToNextComponent = TRUE;
                break;

            case COMPONENT_NAME:
                _PopulateTree (
                    hwndTree,
                    __GetRootSetting (hwndTree),
                    (PTSTR) mce.LocalizedAlias,
                    lstrlen (mce.LocalizedAlias) + 1,
                    NULL,
                    POPULATETREE_FLAGS_SETTINGS,
                    g_migwiz->GetInstance(),
                    g_migwiz->GetWinNT4()
                    );
                mce.SkipToNextComponent = TRUE;
                break;
            }

        } while (IsmEnumNextComponent (&mce));
    }
}

///////////////////////////////////////////////////////////////

typedef struct {
    BOOL Valid;
    PCTSTR PortName;
    DWORD PortSpeed;
    HANDLE Event;
    HANDLE Thread;
} DIRECTCABLE_DATA, *PDIRECTCABLE_DATA;

typedef struct {
    DWORD Signature;
    DWORD MaxSpeed;
} DIRECTSEND_DATA, *PDIRECTSEND_DATA;

typedef struct {
    HWND hwndCombo;
    PDIRECTCABLE_DATA DirectCableData;
} AUTODETECT_DATA, *PAUTODETECT_DATA;

HANDLE
UIOpenAndSetPort (
    IN      PCTSTR ComPort,
    OUT     PDWORD MaxSpeed
    )
{
    HANDLE result = INVALID_HANDLE_VALUE;
    COMMTIMEOUTS commTimeouts;
    DCB dcb;
    UINT index;

    // let's open the port. If we can't we just exit with error;
    result = CreateFile (ComPort, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (result == INVALID_HANDLE_VALUE) {
        return result;
    }

    // we want 10 sec timeout for both read and write
    commTimeouts.ReadIntervalTimeout = 0;
    commTimeouts.ReadTotalTimeoutMultiplier = 0;
    commTimeouts.ReadTotalTimeoutConstant = 3000;
    commTimeouts.WriteTotalTimeoutMultiplier = 0;
    commTimeouts.WriteTotalTimeoutConstant = 3000;
    SetCommTimeouts (result, &commTimeouts);

    // let's set some comm state data
    if (GetCommState (result, &dcb)) {
        dcb.fBinary = 1;
        dcb.fParity = 1;
        dcb.ByteSize = 8;
        dcb.fOutxCtsFlow = 1;
        dcb.fTXContinueOnXoff = 1;
        dcb.fRtsControl = 2;
        dcb.fAbortOnError = 1;
        dcb.Parity = 0;
        // let's first see the max speed
        if (MaxSpeed) {
            *MaxSpeed = 0;
            index = 0;
            while (TRUE) {
                dcb.BaudRate = g_BaudRate [index];
                if (dcb.BaudRate == 0) {
                    break;
                }
                if (!SetCommState (result, &dcb)) {
                    break;
                }
                *MaxSpeed = g_BaudRate [index];
                index ++;
            }
        }
        dcb.BaudRate = CBR_110;
        if (!SetCommState (result, &dcb)) {
            CloseHandle (result);
            result = INVALID_HANDLE_VALUE;
            return result;
        }
    } else {
        CloseHandle (result);
        result = INVALID_HANDLE_VALUE;
        return result;
    }

    return result;
}

#define ACK             0x16
#define NAK             0x15
#define SOH             0x01
#define EOT             0x04
#define BLOCKSIZE       (sizeof (DIRECTSEND_DATA))
#define DIRECTTR_SIG    0x55534D33  //USM2

BOOL
UISendBlockToHandle (
    IN      HANDLE DeviceHandle,
    IN      PCBYTE Buffer,
    IN      HANDLE Event
    )
{
    BOOL result = TRUE;
    BYTE buffer [4 + BLOCKSIZE];
    BYTE signal;
    BYTE currBlock = 0;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = FALSE;
    UINT index;

    // let's start the protocol

    // We are going to listen for the NAK(15h) signal.
    // As soon as we get it we are going to send a 4 + BLOCKSIZE bytes block having:
    // 1 byte - SOH (01H)
    // 1 byte - block number
    // 1 byte - FF - block number
    // BLOCKSIZE bytes of data
    // 1 byte - checksum - sum of all BLOCKSIZE bytes of data
    // After the block is sent, we are going to wait for ACK(16h). If we don't get
    // it after timeout or if we get something else we are going to send the block again.

    // wait for NAK
    while ((!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
            (numRead != 1) ||
            (signal != NAK)
            ) &&
           (!pIsEventSet (&Event))
           );

    repeat = FALSE;
    while (TRUE) {
        if (pIsEventSet (&Event)) {
            result = FALSE;
            break;
        }
        if (!repeat) {
            // prepare the next block
            currBlock ++;
            if (currBlock == 0) {
                result = TRUE;
            }
            buffer [0] = SOH;
            buffer [1] = currBlock;
            buffer [2] = 0xFF - currBlock;
            CopyMemory (buffer + 3, Buffer, BLOCKSIZE);

            // compute the checksum
            buffer [sizeof (buffer) - 1] = 0;
            signal = 0;
            for (index = 0; index < sizeof (buffer) - 1; index ++) {
                signal += buffer [index];
            }
            buffer [sizeof (buffer) - 1] = signal;
        }

        // now send the block to the other side
        if (!WriteFile (DeviceHandle, buffer, sizeof (buffer), &numWritten, NULL) ||
            (numWritten != sizeof (buffer))
            ) {
            repeat = TRUE;
        } else {
            repeat = FALSE;
        }

        if (pIsEventSet (&Event)) {
            result = FALSE;
            break;
        }

        if (repeat) {
            // we could not send the data last time
            // let's just wait for a NAK for 10 sec and then send it again
            ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL);
        } else {
            // we sent it OK. We need to wait for an ACK to come. If we timeout
            // or we get something else, we will repeat the block.
            if (!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
                (numRead != sizeof (signal)) ||
                (signal != ACK)
                ) {
                repeat = TRUE;
            } else {
                // we are done with data, send the EOT signal
                signal = EOT;
                WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
                break;
            }
        }
    }

    if (result) {
        // we are done here. However, let's listen one more timeout for a
        // potential NAK. If we get it, we'll repeat the EOT signal
        while (ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) &&
            (numRead == 1)
            ) {
            if (signal == NAK) {
                signal = EOT;
                WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
            }
        }
    }

    return result;
}

BOOL
UIReceiveBlockFromHandle (
    IN      HANDLE DeviceHandle,
    OUT     PBYTE Buffer,
    IN      HANDLE Event
    )
{
    BOOL result = TRUE;
    BYTE buffer [4 + BLOCKSIZE];
    BYTE signal;
    BYTE currBlock = 1;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = TRUE;
    UINT index;

    // finally let's start the protocol

    // We are going to send an NAK(15h) signal.
    // After that we are going to listen for a block.
    // If we don't get the block in time, or the block is wrong size
    // or it has a wrong checksum we are going to send a NAK signal,
    // otherwise we are going to send an ACK signal
    // One exception. If the block size is 1 and the block is actually the
    // EOT signal it means we are done.

    ZeroMemory (Buffer, BLOCKSIZE);

    while (TRUE) {
        if (pIsEventSet (&Event)) {
            result = FALSE;
            break;
        }
        if (repeat) {
            // send the NAK
            signal = NAK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        } else {
            // send the ACK
            signal = ACK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        }
        if (pIsEventSet (&Event)) {
            result = FALSE;
            break;
        }
        repeat = TRUE;
        // let's read the data block
        if (ReadFile (DeviceHandle, buffer, sizeof (buffer), &numRead, NULL)) {
            if ((numRead == 1) &&
                (buffer [0] == EOT)
                ) {
                // we are done
                break;
            }
            if (numRead == sizeof (buffer)) {
                // compute the checksum
                signal = 0;
                for (index = 0; index < sizeof (buffer) - 1; index ++) {
                    signal += buffer [index];
                }
                if (buffer [sizeof (buffer) - 1] == signal) {
                    repeat = FALSE;
                    // checksum is correct, let's see if this is the right block
                    if (currBlock < buffer [1]) {
                        // this is a major error, the sender is ahead of us,
                        // we have to fail
                        result = FALSE;
                        break;
                    }
                    if (currBlock == buffer [1]) {
                        CopyMemory (Buffer, buffer + 3, BLOCKSIZE);
                        currBlock ++;
                    }
                }
            }
        }
    }

    return result;
}

DWORD WINAPI _DirectCableConnectThread (LPVOID lpParam)
{
    PDIRECTCABLE_DATA directCableData;
    HANDLE comHandle = INVALID_HANDLE_VALUE;
    DIRECTSEND_DATA sendData;
    DIRECTSEND_DATA receiveData;

    directCableData = (PDIRECTCABLE_DATA) lpParam;
    if (directCableData) {
        sendData.Signature = DIRECTTR_SIG;
        // open the COM port and set the timeout and speed
        comHandle = UIOpenAndSetPort (directCableData->PortName, &(sendData.MaxSpeed));
        if (comHandle) {
            // send the message to the COM port
            if (g_fOldComputer) {
                if (UISendBlockToHandle (comHandle, (PCBYTE)(&sendData), directCableData->Event)) {
                    if (UIReceiveBlockFromHandle (comHandle, (PBYTE)(&receiveData), directCableData->Event)) {
                        if (sendData.Signature == receiveData.Signature) {
                            directCableData->Valid = TRUE;
                            directCableData->PortSpeed = min (sendData.MaxSpeed, receiveData.MaxSpeed);
                        }
                    }
                }
            } else {
                if (UIReceiveBlockFromHandle (comHandle, (PBYTE)(&receiveData), directCableData->Event)) {
                    if (UISendBlockToHandle (comHandle, (PCBYTE)(&sendData), directCableData->Event)) {
                        if (sendData.Signature == receiveData.Signature) {
                            directCableData->Valid = TRUE;
                            directCableData->PortSpeed = min (sendData.MaxSpeed, receiveData.MaxSpeed);
                        }
                    }
                }
            }
            CloseHandle (comHandle);
            comHandle = INVALID_HANDLE_VALUE;
        }
    }
    pSetEvent (&(directCableData->Event));
    ExitThread (0);
}

INT_PTR CALLBACK _DirectCableWaitDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static PDIRECTCABLE_DATA directCableData = NULL;
    DWORD waitResult;

    switch (uMsg)
    {
    case WM_INITDIALOG :
        directCableData = (PDIRECTCABLE_DATA) lParam;
        SetTimer (hwndDlg, NULL, 100, NULL);
        ANIMATE_OPEN(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE,IDA_STARTUP);
        ANIMATE_PLAY(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDCANCEL:
            if (directCableData) {
                pSetEvent (&(directCableData->Event));
                waitResult = WaitForSingleObject (directCableData->Thread, 0);
                if (waitResult == WAIT_OBJECT_0) {
                    // the thread is done
                    ANIMATE_STOP(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE);
                    ANIMATE_CLOSE(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE);
                    EndDialog(hwndDlg, FALSE);
                } else {
                    // Let's change the static text
                    ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_WAIT_TEXT1), SW_HIDE);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_WAIT_TEXT2), SW_SHOW);
                }
            } else {
                ANIMATE_STOP(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE);
                ANIMATE_CLOSE(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE);
                EndDialog(hwndDlg, FALSE);
            }
            return TRUE;
        }
        break;

    case WM_TIMER:
        if (directCableData) {
            if (pIsEventSet (&(directCableData->Event))) {
                waitResult = WaitForSingleObject (directCableData->Thread, 0);
                if (waitResult == WAIT_OBJECT_0) {
                    // the thread is done
                    ANIMATE_STOP(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE);
                    ANIMATE_CLOSE(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE);
                    EndDialog(hwndDlg, FALSE);
                }
                break;
            }
        }
    }

    return 0;
}

DWORD WINAPI _DetectPortThread (LPVOID lpParam)
{
    PDIRECTCABLE_DATA directCableData;
    HANDLE comHandle = INVALID_HANDLE_VALUE;
    DIRECTSEND_DATA sendData;
    DIRECTSEND_DATA receiveData;
    HANDLE event = NULL;
    BOOL result = FALSE;

    directCableData = (PDIRECTCABLE_DATA) lpParam;
    if (directCableData) {

        // let's set the termination event
        event = directCableData->Event;

        sendData.Signature = DIRECTTR_SIG;
        // open the COM port and set the timeout and speed
        comHandle = UIOpenAndSetPort (directCableData->PortName, &(sendData.MaxSpeed));
        if (comHandle) {
            // send the message to the COM port
            if (g_fOldComputer) {
                if (UISendBlockToHandle (comHandle, (PCBYTE)(&sendData), directCableData->Event)) {
                    if (UIReceiveBlockFromHandle (comHandle, (PBYTE)(&receiveData), directCableData->Event)) {
                        if (sendData.Signature == receiveData.Signature) {
                            result = TRUE;
                            directCableData->Valid = TRUE;
                            directCableData->PortSpeed = min (sendData.MaxSpeed, receiveData.MaxSpeed);
                        }
                    }
                }
            } else {
                if (UIReceiveBlockFromHandle (comHandle, (PBYTE)(&receiveData), directCableData->Event)) {
                    if (UISendBlockToHandle (comHandle, (PCBYTE)(&sendData), directCableData->Event)) {
                        if (sendData.Signature == receiveData.Signature) {
                            result = TRUE;
                            directCableData->Valid = TRUE;
                            directCableData->PortSpeed = min (sendData.MaxSpeed, receiveData.MaxSpeed);
                        }
                    }
                }
            }
            CloseHandle (comHandle);
            comHandle = INVALID_HANDLE_VALUE;
        }
    }

    if ((!result) && event) {
        // we failed, let's wait until the master tells us to quit
        WaitForSingleObject (event, INFINITE);
    }
    ExitThread (0);
}

DWORD WINAPI _AutoDetectThread (LPVOID lpParam)
{
    PAUTODETECT_DATA autoDetectData = NULL;
    PCTSTR comPort = NULL;
    UINT numPorts = 0;
    PHANDLE threadArray;
    PDIRECTCABLE_DATA directCableArray;
    UINT index = 0;
    DWORD threadId;
    DWORD waitResult;

    autoDetectData = (PAUTODETECT_DATA) lpParam;
    if (!autoDetectData) {
        return FALSE;
    }

    if (!autoDetectData->DirectCableData) {
        return FALSE;
    }
    autoDetectData->DirectCableData->Valid = FALSE;

    if (!autoDetectData->hwndCombo) {
        return FALSE;
    }

    numPorts = SendMessage (autoDetectData->hwndCombo, CB_GETCOUNT, 0, 0);
    if (numPorts) {
        threadArray = (PHANDLE)LocalAlloc(LPTR, numPorts * sizeof(HANDLE));
        if (threadArray) {
            directCableArray = (PDIRECTCABLE_DATA)LocalAlloc(LPTR, numPorts * sizeof(DIRECTCABLE_DATA));
            if (directCableArray) {
                // let's start the threads, one for every port.
                index = 0;
                while (index < numPorts) {
                    comPort = NULL;
                    comPort = (PCTSTR)SendMessage (autoDetectData->hwndCombo, CB_GETITEMDATA, (WPARAM)index, 0);
                    directCableArray [index].Valid = FALSE;
                    directCableArray [index].PortName = comPort;
                    directCableArray [index].PortSpeed = 0;
                    directCableArray [index].Event = autoDetectData->DirectCableData->Event;
                    threadArray [index] = CreateThread (
                                                NULL,
                                                0,
                                                _DetectPortThread,
                                                &(directCableArray [index]),
                                                0,
                                                &threadId
                                                );
                    index ++;
                }

                // let's wait for at least one thread to finish
                waitResult = WaitForMultipleObjects (numPorts, threadArray, FALSE, INFINITE);
                index = waitResult - WAIT_OBJECT_0;
                if ((index < numPorts) && (!pIsEventSet (&(autoDetectData->DirectCableData->Event)))) {
                    // probably a good com port
                    autoDetectData->DirectCableData->Valid = directCableArray [index].Valid;
                    autoDetectData->DirectCableData->PortName = directCableArray [index].PortName;
                    autoDetectData->DirectCableData->PortSpeed = directCableArray [index].PortSpeed;
                }

                // we found the thread, now let's signal the event and wait for all threads to finish
                pSetEvent (&(autoDetectData->DirectCableData->Event));
                WaitForMultipleObjects (numPorts, threadArray, TRUE, INFINITE);

                // let's close all thread handles
                index = 0;
                while (index < numPorts) {
                    CloseHandle (threadArray [index]);
                    index ++;
                }
                LocalFree (directCableArray);
            } else {
                LocalFree (threadArray);
                return FALSE;
            }
            LocalFree (threadArray);
        } else {
            return FALSE;
        }
    }

    return TRUE;
}

INT_PTR CALLBACK _DirectCableDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static INT  iSelectedPort = -1;        // Which COM port is selected
    INT lastPort;
    HWND hwndCombo;
    DIRECTCABLE_DATA directCableData;
    AUTODETECT_DATA autoDetectData;
    HANDLE threadHandle;
    DWORD threadId;
    DWORD waitResult;

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK, FALSE, 0);

    switch (uMsg)
    {
    case WM_INITDIALOG:

        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_DIRECTCABLETITLE);
        }

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_DIRECTC_COMSELECT:
            if (HIWORD(wParam) == CBN_SELCHANGE) {
                // clear the error or success area
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_SUCCESSTEXT), SW_HIDE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONYES), SW_HIDE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_FAILURETEXT), SW_HIDE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONNO), SW_HIDE);
                // see if the combo box has a real COM port selected. If yes, enable the Next Button
                hwndCombo = GetDlgItem(hwndDlg, IDC_DIRECTC_COMSELECT);
                lastPort = iSelectedPort;
                iSelectedPort = ComboBox_GetCurSel (hwndCombo);
                if (iSelectedPort >= 0) {
                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                }
                if (lastPort != iSelectedPort) {
                    // clear the store, we need to revalidate the COM port
                    g_szStore [0] = 0;
                }
            }
            break;
        case IDC_DIRECTC_AUTO:
            // clear the error or success area
            ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_SUCCESSTEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONYES), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_FAILURETEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONNO), SW_HIDE);

            hwndCombo = GetDlgItem(hwndDlg, IDC_DIRECTC_COMSELECT);
            ZeroMemory (&directCableData, sizeof (DIRECTCABLE_DATA));
            directCableData.Event = CreateEvent (NULL, TRUE, FALSE, NULL);
            autoDetectData.hwndCombo = hwndCombo;
            autoDetectData.DirectCableData = &directCableData;

            // Start the connection thread
            threadHandle = CreateThread (NULL, 0, _AutoDetectThread, &autoDetectData, 0, &threadId);

            directCableData.Thread = threadHandle;

            // Start the Please wait dialog
            DialogBoxParam (
                g_migwiz->GetInstance(),
                MAKEINTRESOURCE(IDD_DIRECTCABLE_WAIT),
                g_hwndCurrent,
                _DirectCableWaitDlgProc,
                (LPARAM)(&directCableData)
                );

            pSetEvent (&(directCableData.Event));

            // wait for the thread to finish
            waitResult = WaitForSingleObject (threadHandle, INFINITE);

            // Close thread handle
            CloseHandle (threadHandle);

            // Verify that the connection worked
            if (directCableData.Valid && directCableData.PortName) {
                // select the appropriate com port in the drop-down list
                UINT numPorts;
                UINT index = 0;
                PCTSTR comPort = NULL;

                numPorts = SendMessage (hwndCombo, CB_GETCOUNT, 0, 0);
                if (numPorts) {
                    while (index < numPorts) {
                        comPort = (LPTSTR)ComboBox_GetItemData (hwndCombo, index);
                        if (_tcsicmp (comPort, directCableData.PortName) == 0) {
                            break;
                        }
                        index ++;
                    }
                }
                ComboBox_SetCurSel (hwndCombo, index);
                iSelectedPort = index;

                // build the transport string
                if (directCableData.PortSpeed) {
                    wsprintf (g_szStore, TEXT("%s:%u"), directCableData.PortName, directCableData.PortSpeed);
                } else {
                    wsprintf (g_szStore, TEXT("%s"), directCableData.PortName);
                }

                // write the success in the error/success area
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_SUCCESSTEXT), SW_SHOW);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONYES), SW_SHOW);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_FAILURETEXT), SW_HIDE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONNO), SW_HIDE);

                // enable the Next button
                PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
            } else {
                // clear the transport string
                g_szStore [0] = 0;

                // write the failure in the error/success area
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_SUCCESSTEXT), SW_HIDE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONYES), SW_HIDE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_FAILURETEXT), SW_SHOW);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONNO), SW_SHOW);

                // preserve the state of the Next button
            }
            break;
        }
        break;

    case WM_NOTIFY :
    {
    switch (((LPNMHDR)lParam)->code)
        {
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, FALSE, FALSE);
            break;
        case PSN_WIZBACK:
            if (g_fOldComputer) {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKCOLLECTSTORE);
            } else {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKAPPLYSTORE);
            }
            return TRUE;
            break;
        case PSN_WIZNEXT:
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
            }
            else {
                // run the COM port test, if we haven't done it already
                if (!g_szStore [0]) {

                    // clear the error or success area
                    ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_SUCCESSTEXT), SW_HIDE);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONYES), SW_HIDE);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_FAILURETEXT), SW_HIDE);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONNO), SW_HIDE);

                    // Get the COM port from the IDC_DIRECTC_COMSELECT
                    hwndCombo = GetDlgItem(hwndDlg, IDC_DIRECTC_COMSELECT);
                    iSelectedPort = ComboBox_GetCurSel (hwndCombo);
                    directCableData.Valid = FALSE;
                    directCableData.PortName = (LPTSTR)ComboBox_GetItemData (hwndCombo, iSelectedPort);
                    directCableData.PortSpeed = 0;
                    directCableData.Event = CreateEvent (NULL, TRUE, FALSE, NULL);

                    // Start the connection thread
                    threadHandle = CreateThread (NULL, 0, _DirectCableConnectThread, &directCableData, 0, &threadId);

                    directCableData.Thread = threadHandle;

                    // Start the Please wait dialog
                    DialogBoxParam (
                        g_migwiz->GetInstance(),
                        MAKEINTRESOURCE(IDD_DIRECTCABLE_WAIT),
                        g_hwndCurrent,
                        _DirectCableWaitDlgProc,
                        (LPARAM)(&directCableData)
                        );

                    pSetEvent (&(directCableData.Event));

                    // wait for the thread to finish
                    waitResult = WaitForSingleObject (threadHandle, INFINITE);

                    // Close thread handle
                    CloseHandle (threadHandle);

                    // Verify that the connection worked
                    if (directCableData.Valid) {
                        // build the transport string
                        if (directCableData.PortSpeed) {
                            wsprintf (g_szStore, TEXT("%s:%u"), directCableData.PortName, directCableData.PortSpeed);
                        } else {
                            wsprintf (g_szStore, TEXT("%s"), directCableData.PortName);
                        }

                        // write the success in the error/success area
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_SUCCESSTEXT), SW_SHOW);
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONYES), SW_SHOW);
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_FAILURETEXT), SW_HIDE);
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONNO), SW_HIDE);

                        // enable the Next button
                        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    } else {
                        // clear the transport string
                        g_szStore [0] = 0;

                        // write the failure in the error/success area
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_SUCCESSTEXT), SW_HIDE);
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONYES), SW_HIDE);
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_FAILURETEXT), SW_SHOW);
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONNO), SW_SHOW);

                        // preserve the state of the Next button

                        // refuse the Next advance
                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, -1);
                        return -1;
                    }
                }

                if (g_fOldComputer) {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKMETHOD);
                } else {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPLYPROGRESS);
                }
            }
            return TRUE;
            break;
        case PSN_SETACTIVE:
            g_fCustomize = FALSE;

            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);

            // let's build the list of COM ports
            iSelectedPort = _ComboBoxEx_AddCOMPorts (GetDlgItem(hwndDlg, IDC_DIRECTC_COMSELECT), iSelectedPort);

            Button_Enable (GetDlgItem (hwndDlg, IDC_DIRECTC_COMSELECT), (-1 != iSelectedPort));
            Button_Enable (GetDlgItem (hwndDlg, IDC_DIRECTC_AUTO), (-1 != iSelectedPort));

            // see if the combo box has a real COM port selected. If yes, enable the Next Button
            if (ComboBox_GetCurSel (GetDlgItem(hwndDlg, IDC_DIRECTC_COMSELECT)) >= 0) {
                PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
            } else {
                iSelectedPort = -1;
            }

            break;
        }
    }
    break;

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pSetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    }

    return 0;
}

///////////////////////////////////////////////////////////////

void _PickMethodDlgProc_Prepare(HWND hwndTree, UINT uiRadio, UINT uiSel, PUINT puiLast, PUINT pselLast)
{
    if ((uiSel != -1) && (*pselLast == uiSel) && (*puiLast == uiRadio)) {
        return;
    }

    switch (uiSel)
    {
    case 0:
        g_migwiz->SelectComponentSet(MIGINF_SELECT_SETTINGS);
        break;
    case 1:
        g_migwiz->SelectComponentSet(MIGINF_SELECT_FILES);
        break;
    case 2:
        g_migwiz->SelectComponentSet(MIGINF_SELECT_BOTH);
        break;
    }
    __PopulateFilesDocumentsCollected(hwndTree, uiRadio);

    *puiLast = uiRadio;
    *pselLast = uiSel;
    g_uChosenComponent = uiRadio;
}

INT_PTR CALLBACK _PickMethodDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK | PSWIZB_NEXT, FALSE, 0);

    static UINT uiLast = (UINT) -1;
    static UINT selLast = (UINT) -1;
    UINT uiSet;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        HANDLE hBitmap;

        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_PICKMETHODTITLE);
        }

        // Display the mini exclamation mark
        hBitmap = LoadImage(g_migwiz->GetInstance(),
                            MAKEINTRESOURCE(IDB_SMEXCLAMATION),
                            IMAGE_BITMAP,
                            0, 0,
                            LR_LOADTRANSPARENT | LR_SHARED | LR_LOADMAP3DCOLORS);
        SendDlgItemMessage(hwndDlg, IDC_PICKMETHOD_WARNINGICON, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)hBitmap);
        TreeView_SetBkColor(GetDlgItem(hwndDlg, IDC_PICKMETHOD_TREE), GetSysColor(COLOR_3DFACE));
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_PICKMETHOD_RADIO1:
            _PickMethodDlgProc_Prepare(GetDlgItem(hwndDlg, IDC_PICKMETHOD_TREE), 0, 0, &uiLast, &selLast);
            break;
        case IDC_PICKMETHOD_RADIO2:
            _PickMethodDlgProc_Prepare(GetDlgItem(hwndDlg, IDC_PICKMETHOD_TREE), 1, 1, &uiLast, &selLast);
            break;
        case IDC_PICKMETHOD_RADIO3:
            _PickMethodDlgProc_Prepare(GetDlgItem(hwndDlg, IDC_PICKMETHOD_TREE), 2, 2, &uiLast, &selLast);
            break;
        case IDC_PICKMETHOD_CUSTOMIZE:
            if (!Button_GetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_CUSTOMIZE))) {
                _PickMethodDlgProc_Prepare(GetDlgItem(hwndDlg, IDC_PICKMETHOD_TREE), uiLast, uiLast, &uiLast, &selLast);
            }
            break;
        }
        break;

    case WM_NOTIFY :
    {
    switch (((LPNMHDR)lParam)->code)
        {
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, FALSE, FALSE);
            break;
        case PSN_WIZBACK:
            if (g_fStoreToCable) {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_DIRECTCABLE);
            } else {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKCOLLECTSTORE);
            }
            return TRUE;
            break;
        case PSN_WIZNEXT:
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
            }
            else if (Button_GetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_CUSTOMIZE)))
            {
                g_fCustomize = TRUE;
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_CUSTOMIZE);
            }
            else if (GetAppsToInstall() == TRUE)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPINSTALL);
            }
            else
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_COLLECTPROGRESS);
            }
            return TRUE;
            break;
        case PSN_SETACTIVE:
            g_fCustomize = FALSE;

            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);

            Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_RADIO1), BST_UNCHECKED);
            Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_RADIO2), BST_UNCHECKED);
            Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_RADIO3), BST_UNCHECKED);

            ShowWindow(GetDlgItem(hwndDlg, IDC_PICKMETHOD_TEXT2), (g_fStoreToFloppy ? SW_SHOW : SW_HIDE));
            ShowWindow(GetDlgItem(hwndDlg, IDC_PICKMETHOD_WARNINGICON), (g_fStoreToFloppy ? SW_SHOW : SW_HIDE));

            if (g_fPickMethodReset == TRUE || uiLast == (UINT) -1)
            {
                // Always refresh the tree
                uiLast = -1;
                uiSet = g_fStoreToFloppy ? 0 : 2;
                g_fPickMethodReset = FALSE;
            }
            else
            {
                uiSet = uiLast;
            }

            switch (uiSet)
            {
            case 0:
                Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_RADIO1), BST_CHECKED);
                break;
            case 1:
                Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_RADIO2), BST_CHECKED);
                break;
            case 2:
                Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_RADIO3), BST_CHECKED);
                break;
            }
            _PickMethodDlgProc_Prepare(GetDlgItem(hwndDlg, IDC_PICKMETHOD_TREE), uiSet, g_fCustomizeComp?-1:uiSet, &uiLast, &selLast);

            break;
        case TVN_ITEMEXPANDINGA:
        case TVN_ITEMEXPANDINGW:
            // Disable selecting and expand/compress
            SetWindowLong(hwndDlg, DWLP_MSGRESULT, TRUE);
            return TRUE;
            break;
        case NM_CUSTOMDRAW:
            {
            LPNMTVCUSTOMDRAW lpNMCustomDraw = (LPNMTVCUSTOMDRAW) lParam;

            // Do not allow highlighting of anything in this treeview

            switch (lpNMCustomDraw->nmcd.dwDrawStage)
            {
                case CDDS_PREPAINT:
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW);
                    return CDRF_NOTIFYITEMDRAW;
                    break;
                case CDDS_ITEMPREPAINT:
                    lpNMCustomDraw->clrText = GetSysColor(COLOR_WINDOWTEXT);
                    lpNMCustomDraw->clrTextBk = GetSysColor(COLOR_3DFACE);
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                    return CDRF_NEWFONT;
                    break;
            }
            }
            break;
        }
    }
    break;

    case WM_USER_CANCEL_PENDING:
        g_fUberCancel = TRUE;
        pSetEvent (&g_TerminateEvent);
        _NextWizardPage (hwndDlg);
        break;
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK _CustomizeDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HTREEITEM htiSelected = NULL;
    UINT treeCount = 0;
    UINT rootCount = 0;
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK | PSWIZB_NEXT, FALSE, 0);

    HWND hwndTree = GetDlgItem(hwndDlg, IDC_CUSTOMIZE_TREE);
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_CUSTOMIZETITLE);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CUSTOMIZE_ADDFOLDERS:
            _AddFolder(hwndDlg, hwndTree);

            // Hack to hide shell bug#309872
            RedrawWindow(hwndTree, NULL, NULL, RDW_INVALIDATE | RDW_ERASENOW);

            break;
        case IDC_CUSTOMIZE_ADDTYPES:
            _ExclusiveDialogBox(g_migwiz->GetInstance(),
                                MAKEINTRESOURCE(IDD_FILETYPEPICKER),
                                hwndDlg,
                                _FileTypeDlgProc);

            // Hack to hide shell bug#309872
            RedrawWindow(hwndTree, NULL, NULL, RDW_INVALIDATE | RDW_ERASENOW);

            break;
        case IDC_CUSTOMIZE_ADDSETTING:
            _ExclusiveDialogBox(g_migwiz->GetInstance(),
                                MAKEINTRESOURCE(IDD_SETTINGPICKER),
                                hwndDlg,
                                _SettingDlgProc);

            // Hack to hide shell bug#309872
            RedrawWindow(hwndTree, NULL, NULL, RDW_INVALIDATE | RDW_ERASENOW);

            break;
        case IDC_CUSTOMIZE_ADDFILE:
            _AddFile(hwndDlg, hwndTree);

            // Hack to hide shell bug#309872
            RedrawWindow(hwndTree, NULL, NULL, RDW_INVALIDATE | RDW_ERASENOW);

            break;
        case IDC_CUSTOMIZE_REMOVE:
            if (htiSelected != g_htiFiles &&
                htiSelected != g_htiFolders &&
                htiSelected != g_htiTypes &&
                htiSelected != g_htiSettings)
            {
                TVITEM item = {0};
                HTREEITEM htiParent;

                item.mask = TVIF_HANDLE | TVIF_TEXT | TVIF_PARAM;
                item.hItem = htiSelected;
                TCHAR szText[MAX_PATH];
                item.pszText = szText;
                item.cchTextMax = ARRAYSIZE(szText);
                if (TreeView_GetItem(hwndTree, &item))
                {
                    if (item.lParam)
                    {
                        LV_DATASTRUCT* plvds = (LV_DATASTRUCT*)item.lParam;

                        // first disable the ISM component
                        htiParent = TreeView_GetParent(hwndTree, htiSelected);

                        if (htiParent == g_htiFiles) {

                            IsmSelectComponent (item.pszText, COMPONENT_FILE, FALSE);

                        } else if (htiParent == g_htiFolders) {

                            IsmSelectComponent (
                                plvds->pszPureName ? plvds->pszPureName : item.pszText,
                                COMPONENT_FOLDER,
                                FALSE
                                );

                        } else if (htiParent == g_htiTypes) {

                            IsmSelectComponent (
                                plvds->pszPureName ? plvds->pszPureName : item.pszText,
                                COMPONENT_EXTENSION,
                                FALSE
                                );

                        } else if (htiParent == g_htiSettings) {

                            IsmSelectComponent (item.pszText, COMPONENT_NAME, FALSE);

                        }


                        // second delete the memory associated with the item
                        if (plvds->pszPureName)
                        {
                            LocalFree(plvds->pszPureName);
                        }
                        LocalFree(plvds);

                        // if the user hits BACK we will remember that the user customized stuff
                        g_fCustomizeComp = TRUE;
                    }
                }
                // third, delete the item itself
                TreeView_DeleteItem(hwndTree, htiSelected);
            }
            break;
        }

        rootCount = 0;
        if (g_htiFolders)
        {
            rootCount ++;
        }
        if (g_htiFiles)
        {
            rootCount ++;
        }
        if (g_htiSettings)
        {
            rootCount ++;
        }
        if (g_htiTypes)
        {
            rootCount ++;
        }

        treeCount = TreeView_GetCount (hwndTree);
        if (treeCount <= rootCount)
        {
            // Disable the NEXT button
            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
        }
        else
        {
            // Enable the NEXT button
            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
        }
        break;
    case WM_NOTIFY :
        {
            switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE:
                {
                __PopulateFilesDocumentsCollected(hwndTree, g_uChosenComponent);

                rootCount = 0;
                if (g_htiFolders)
                {
                    rootCount ++;
                }
                if (g_htiFiles)
                {
                    rootCount ++;
                }
                if (g_htiSettings)
                {
                    rootCount ++;
                }
                if (g_htiTypes)
                {
                    rootCount ++;
                }
                if (TreeView_GetCount (hwndTree) <= rootCount)
                {
                    // Disable the NEXT button
                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
                }
                else
                {
                    // Enable the NEXT button
                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                }
                break;
                }
            case PSN_QUERYCANCEL:
                return _HandleCancel(hwndDlg, FALSE, FALSE);
                break;
            case PSN_WIZBACK:
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKMETHOD);
                return TRUE;
                break;
            case PSN_WIZNEXT:
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else if (GetAppsToInstall() == TRUE)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPINSTALL);
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_COLLECTPROGRESS);
                }
                return TRUE;
                break;
            case TVN_ITEMEXPANDINGA:
            case TVN_ITEMEXPANDINGW:
                return TRUE;
                break;
            case TVN_SELCHANGED:
                {
                    htiSelected = ((NM_TREEVIEW*)lParam)->itemNew.hItem;

                    if (htiSelected == NULL ||
                        htiSelected == g_htiFiles ||
                        htiSelected == g_htiFolders ||
                        htiSelected == g_htiTypes ||
                        htiSelected == g_htiSettings)
                    {
                        // Disable the REMOVE key
                        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOMIZE_REMOVE), FALSE);
                    }
                    else
                    {
                        // Enable the REMOVE key
                        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOMIZE_REMOVE), TRUE);
                    }
                }
                break;
            }
            break;
        }

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pSetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    }

    return 0;
}

///////////////////////////////////////////////////////////////

int CALLBACK
PickCollectCallback (
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam,
    LPARAM lpData
    )
{
    HRESULT hr = S_OK;
    TCHAR tszFolderName[MAX_PATH];
    IMalloc *mallocFn = NULL;
    IShellFolder *psfParent = NULL;
    IShellLink *pslLink = NULL;
    LPCITEMIDLIST pidl;
    LPCITEMIDLIST pidlRelative = NULL;
    LPITEMIDLIST pidlReal = NULL;

    if (uMsg == BFFM_SELCHANGED) {

        hr = SHGetMalloc (&mallocFn);
        if (!SUCCEEDED (hr)) {
            mallocFn = NULL;
        }

        pidl = (LPCITEMIDLIST) lParam;
        pidlReal = NULL;

        if (pidl) {

            hr = OurSHBindToParent (pidl, IID_IShellFolder, (void **)&psfParent, &pidlRelative);

            if (SUCCEEDED(hr)) {
                hr = psfParent->GetUIObjectOf (hwnd, 1, &pidlRelative, IID_IShellLink, NULL, (void **)&pslLink);
                if (SUCCEEDED(hr)) {
                    hr = pslLink->GetIDList (&pidlReal);
                    if (!SUCCEEDED(hr)) {
                        pidlReal = NULL;
                    }
                    pslLink->Release ();
                }
                pidlRelative = NULL;
                psfParent->Release ();
            }

            if (SHGetPathFromIDList(pidlReal?pidlReal:pidl, tszFolderName))
            {
                if (tszFolderName[0] == 0) {
                    SendMessage (hwnd, BFFM_ENABLEOK, 0, 0);
                }
            } else {
                SendMessage (hwnd, BFFM_ENABLEOK, 0, 0);
            }

            if (pidlReal) {
                if (mallocFn) {
                    mallocFn->Free ((void *)pidlReal);
                }
                pidlReal = NULL;
            }
        }

        if (mallocFn) {
            mallocFn->Release ();
            mallocFn = NULL;
        }
    }
    return 0;
}

INT_PTR CALLBACK _PickCollectStoreDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static UINT uiSelected = 0;
    static INT  iSelectedDrive = -1;        // Which removeable media drive is selected
    BOOL imageIsValid;
    BOOL imageExists;
    TCHAR szTitle[MAX_LOADSTRING];
    TCHAR szLoadString[MAX_LOADSTRING];
    HRESULT hr = E_FAIL;

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_NEXT, FALSE, 0);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_PICKCOLLECTSTORETITLE);
        }
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {

        case IDC_PICKCOLLECTSTORE_RADIO1:
            // Direct cable

        case IDC_PICKCOLLECTSTORE_RADIO2:
            // Network

            // Disable Browse button
            Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_BROWSE), FALSE);
            Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), FALSE);

            // Disable the edit box
            Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), FALSE);
            Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), TRUE);

            // Disable the drive selector
            EnableWindow (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), FALSE);
            break;

        case IDC_PICKCOLLECTSTORE_RADIO3:
            // Floppy

            // Disable Browse button
            Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_BROWSE), FALSE);
            Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), FALSE);

            // Disable the edit box
            Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), FALSE);
            Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), TRUE);

            // Enable the drive selector
            EnableWindow (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), TRUE);

            break;

        case IDC_PICKCOLLECTSTORE_RADIO4:
            {
            // Other

            // Enable the Browse button
            Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_BROWSE), TRUE);
            Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), TRUE);

            // Enable the edit box
            HWND hwndEdit = GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT);
            Edit_Enable(hwndEdit, TRUE);
            Edit_SetReadOnly(hwndEdit, FALSE);
            Edit_LimitText(hwndEdit, MAX_PATH - PATH_SAFETY_CHARS);

            // Disable the drive selector
            EnableWindow (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), FALSE);
            break;
            }

        case IDC_PICKCOLLECTSTORE_BROWSE:
            {
                HRESULT hr = S_OK;
                IMalloc *mallocFn = NULL;
                IShellFolder *psfParent = NULL;
                IShellLink *pslLink = NULL;
                LPCITEMIDLIST pidl;
                LPCITEMIDLIST pidlRelative = NULL;
                LPITEMIDLIST pidlReal = NULL;
                TCHAR szFolder[MAX_PATH];
                TCHAR szPick[MAX_LOADSTRING];

                hr = SHGetMalloc (&mallocFn);
                if (!SUCCEEDED (hr)) {
                    mallocFn = NULL;
                }

                LoadString(g_migwiz->GetInstance(), IDS_PICKAFOLDER, szPick, ARRAYSIZE(szPick));
                BROWSEINFO brwsinf = { hwndDlg, NULL, NULL, szPick, BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE, PickCollectCallback, 0, 0 };

                pidl = SHBrowseForFolder(&brwsinf);
                if (pidl)
                {
                    hr = OurSHBindToParent (pidl, IID_IShellFolder, (void **)&psfParent, &pidlRelative);

                    if (SUCCEEDED(hr)) {
                        hr = psfParent->GetUIObjectOf (hwndDlg, 1, &pidlRelative, IID_IShellLink, NULL, (void **)&pslLink);
                        if (SUCCEEDED(hr)) {
                            hr = pslLink->GetIDList (&pidlReal);
                            if (SUCCEEDED(hr)) {
                                if (mallocFn) {
                                    mallocFn->Free ((void *)pidl);
                                }
                                pidl = pidlReal;
                                pidlReal = NULL;
                            }
                            pslLink->Release ();
                        }
                        pidlRelative = NULL;
                        psfParent->Release ();
                    }

                    if (SHGetPathFromIDList(pidl, szFolder))
                    {
                        if (_tcslen(szFolder) > MAX_PATH - PATH_SAFETY_CHARS) {
                            TCHAR szTitle[MAX_LOADSTRING];
                            LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
                            TCHAR szMsg[MAX_LOADSTRING];
                            LoadString(g_migwiz->GetInstance(), IDS_ERROR_PATHTOOLONG, szMsg, ARRAYSIZE(szMsg));
                            _ExclusiveMessageBox(hwndDlg, szMsg, szTitle, MB_OK);
                        } else {
                            SendMessage(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), WM_SETTEXT, 0, (LPARAM)szFolder);
                        }
                    }

                    if (mallocFn) {
                        mallocFn->Free ((void *)pidl);
                    }
                    pidl = NULL;
                }

                if (mallocFn) {
                    mallocFn->Release ();
                    mallocFn = NULL;
                }
            }
            break;
        }
        break;
    case WM_NOTIFY :
        {
            switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE:
                INT currDrive;
                INT comPort;

                // enable direct cable transport if available
                comPort = _ComboBoxEx_AddCOMPorts (NULL, 0);
                Button_Enable (GetDlgItem (hwndDlg, IDC_PICKCOLLECTSTORE_RADIO1), (-1 != comPort));

                // enable network if present
                Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO2), g_fHaveNet);
                Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT3), g_fHaveNet);

                // get removable drives list and enable radio if any
                SendMessage(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), CBEM_SETIMAGELIST, 0, (LPARAM)g_migwiz->GetImageList());
                currDrive = _ComboBoxEx_AddDrives (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO));

                Button_Enable (GetDlgItem (hwndDlg, IDC_PICKCOLLECTSTORE_RADIO3), (-1 != currDrive));
                Static_Enable (GetDlgItem (hwndDlg, IDC_PICKCOLLECTSTORE_TEXT2), (-1 != currDrive));

                // set the selected drive if any
                if ((currDrive != -1) && (iSelectedDrive != -1)) {
                    ComboBox_SetCurSel(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), iSelectedDrive);
                    currDrive = iSelectedDrive;
                }

                if ((uiSelected == 0 || uiSelected == 2) && g_fHaveNet)
                {
                    // Home Network
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO1), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO2), BST_CHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO3), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO4), BST_UNCHECKED);

                    // disable folder box, browse button
                    Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_BROWSE), FALSE);
                    Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), FALSE);
                    Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), FALSE);
                    Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), TRUE);
                    // Disable the drive selector
                    EnableWindow (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), FALSE);
                } else if ((uiSelected == 0 || uiSelected == 1) && (-1 != comPort)) {
                    // Direct cable
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO1), BST_CHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO2), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO3), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO4), BST_UNCHECKED);

                    // disable folder box, browse button
                    Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_BROWSE), FALSE);
                    Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), FALSE);
                    Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), FALSE);
                    Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), TRUE);
                    // Disable the drive selector
                    EnableWindow (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), FALSE);
                }
                else if ((uiSelected == 0 || uiSelected == 3) && (-1 != currDrive))
                {
                    // Floppy
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO1), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO2), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO3), BST_CHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO4), BST_UNCHECKED);

                    // disable folder box, browse button
                    Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_BROWSE), FALSE);
                    Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), FALSE);
                    Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), FALSE);
                    Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), TRUE);

                    // Enable the drive selector
                    EnableWindow (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), TRUE);
                }
                else
                {
                    // Other
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO1), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO2), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO3), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO4), BST_CHECKED);
                    Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), TRUE);

                    // Disable the drive selector
                    EnableWindow (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), FALSE);

                    // Enable folder box, browse button
                    Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_BROWSE), TRUE);
                    Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), TRUE);

                    HWND hwndEdit = GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT);
                    Edit_Enable(hwndEdit, TRUE);
                    Edit_SetReadOnly(hwndEdit, FALSE);
                    Edit_LimitText(hwndEdit, MAX_PATH - PATH_SAFETY_CHARS);
                }

                // Reset my globals
                g_szStore[0] = 0;

                break;

            case PSN_QUERYCANCEL:
                return _HandleCancel(hwndDlg, FALSE, FALSE);
                break;

            case PSN_WIZNEXT:
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else
                {
                    if (Button_GetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO1))) // direct cable
                    {
                        g_fStoreToNetwork = FALSE;
                        g_fStoreToCable = TRUE;
                        if (uiSelected != 1)
                        {
                            g_fCustomizeComp = FALSE;
                            uiSelected = 1;
                        }
                    }
                    else if (Button_GetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO2))) // network
                    {
                        g_fStoreToNetwork = TRUE;
                        g_fStoreToCable = FALSE;
                        if (uiSelected != 2)
                        {
                            g_fCustomizeComp = FALSE;
                            uiSelected = 2;
                        }
                    }
                    else if (Button_GetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO3))) // floppy
                    {
                        LPTSTR pszDrive;
                        TCHAR szFloppyPath[4] = TEXT("A:\\");

                        g_fStoreToNetwork = FALSE;
                        g_fStoreToCable = FALSE;

                        HWND hwndCombo = GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO);
                        iSelectedDrive = ComboBox_GetCurSel(hwndCombo);
                        pszDrive = (LPTSTR)ComboBox_GetItemData(hwndCombo, iSelectedDrive);

                        szFloppyPath[0] = pszDrive[0];
                        lstrcpy(g_szStore, szFloppyPath);
                        if (uiSelected != 3)
                        {
                            g_fCustomizeComp = FALSE;
                            uiSelected = 3;
                        }
                    }
                    else // other
                    {
                        TCHAR   tsTemp[MAX_PATH + 1];

                        g_fStoreToNetwork = FALSE;
                        g_fStoreToCable = FALSE;

                        SendMessage(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), WM_GETTEXT,
                            (WPARAM)ARRAYSIZE(tsTemp), (LPARAM)tsTemp);
                        if (uiSelected != 4)
                        {
                            g_fCustomizeComp = FALSE;
                            uiSelected = 4;
                        }

                        CopyStorePath(tsTemp, g_szStore);
                    }

                    if (g_fStoreToNetwork)
                    {
                        if (g_fStoreToFloppy) {
                            g_fStoreToFloppy = FALSE;
                            g_fPickMethodReset = TRUE;
                        }
                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKMETHOD);
                        return TRUE;
                    }

                    if (g_fStoreToCable) {
                        if (g_fStoreToFloppy) {
                            g_fStoreToFloppy = FALSE;
                            g_fPickMethodReset = TRUE;
                        }
                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_DIRECTCABLE);
                        return TRUE;
                    }

                    if (!_IsValidStore(g_szStore, TRUE, g_migwiz->GetInstance(), hwndDlg)) // not a valid directory!  stay right here.
                    {
                        LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
                        LoadString(g_migwiz->GetInstance(), IDS_ENTERDEST, szLoadString, ARRAYSIZE(szLoadString));
                        _ExclusiveMessageBox(hwndDlg, szLoadString, szTitle, MB_OK);

                        HWND hwndEdit = GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT);
                        SetFocus(hwndEdit);
                        SendMessage(hwndEdit, EM_SETSEL, 0, -1);

                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, -1);
                        return -1;
                    }

                    hr = Engine_StartTransport (TRUE, g_szStore, &imageIsValid, &imageExists);
                    if ((!SUCCEEDED (hr)) || (!imageIsValid)) {

                        LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
                        LoadString(g_migwiz->GetInstance(), IDS_ENTERDEST, szLoadString, ARRAYSIZE(szLoadString));
                        _ExclusiveMessageBox (hwndDlg, szLoadString, szTitle, MB_OK);

                        HWND hwndEdit = GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT);
                        SetFocus(hwndEdit);
                        SendMessage(hwndEdit, EM_SETSEL, 0, -1);

                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, -1);
                        return -1;
                    }

                    BOOL oldFloppy = g_fStoreToFloppy;
                    g_fStoreToFloppy = _DriveStrIsFloppy(!g_migwiz->GetWin9X(), g_szStore);

                    if (oldFloppy != g_fStoreToFloppy) {
                        g_fPickMethodReset = TRUE;
                    }

                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKMETHOD);
                }
                return TRUE;
                break;
            }
            break;
        }

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pSetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    default:
        break;
    }
    return 0;
}

///////////////////////////////////////////////////////////////

typedef struct {
    HWND  hwndProgressBar;
    HWND  hwndPropPage;
} COLLECTPROGRESSSTRUCT;

DWORD WINAPI _CollectProgressDlgProcThread (LPVOID lpParam)
{
    COLLECTPROGRESSSTRUCT* pcps = (COLLECTPROGRESSSTRUCT*)lpParam;
    HRESULT hResult;
    BOOL fHasUserCancelled = FALSE;

    hResult = _DoCopy(g_fStoreToNetwork ? NULL : g_szStore, pcps->hwndProgressBar, pcps->hwndPropPage, &fHasUserCancelled);

    if (fHasUserCancelled) {
        hResult = E_FAIL;
    }

    SendMessage (pcps->hwndPropPage, WM_USER_THREAD_COMPLETE, 0, (LPARAM) hResult);

    pSetEvent (&g_TerminateEvent);

    CoTaskMemFree(pcps);

    return 0;
}


INT_PTR CALLBACK _CollectProgressDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hResult;
    LONG lExStyles;
    HWND hwnd;

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, 0, FALSE, 0);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_COLLECTPROGRESSTITLE);
        }

        // RTL progress bar for RTL dialogs
        lExStyles = GetWindowLong (hwndDlg, GWL_EXSTYLE);
        if (lExStyles & WS_EX_LAYOUTRTL)
        {
            hwnd = GetDlgItem(hwndDlg, IDC_COLLECTPROGRESS_PROGRESS);
            lExStyles = GetWindowLongA(hwnd, GWL_EXSTYLE);
            lExStyles |= WS_EX_LAYOUTRTL;       // toggle layout
            SetWindowLongA(hwnd, GWL_EXSTYLE, lExStyles);
            InvalidateRect(hwnd, NULL, TRUE);   // redraw
        }

        // Let's set an update timer to 3 sec.
        SetTimer (hwndDlg, 0, 3000, NULL);
        break;

    case WM_USER_FINISHED:
        if (g_migwiz->GetLastResponse() == TRUE) // we didn't cancel to get here
        {
            _NextWizardPage (hwndDlg);
        }
        return TRUE;
        break;

    case WM_USER_CANCELLED:
        g_fUberCancel = TRUE;
        _NextWizardPage (hwndDlg);
        return TRUE;
        break;

    case WM_NOTIFY :
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            {
                // blank progress bar
                SendMessage(GetDlgItem(hwndDlg, IDC_COLLECTPROGRESS_PROGRESS), PBM_SETRANGE, 0, 100);
                SendMessage(GetDlgItem(hwndDlg, IDC_COLLECTPROGRESS_PROGRESS), PBM_SETPOS, 0, 0);

                ANIMATE_OPEN(hwndDlg,IDC_PROGRESS_ANIMATE2,IDA_FILECOPY);
                ANIMATE_PLAY(hwndDlg,IDC_PROGRESS_ANIMATE2);

                g_migwiz->ResetLastResponse();
                COLLECTPROGRESSSTRUCT* pcps = (COLLECTPROGRESSSTRUCT*)CoTaskMemAlloc(sizeof(COLLECTPROGRESSSTRUCT));
                if (pcps)
                {
                    pcps->hwndProgressBar = GetDlgItem(hwndDlg, IDC_COLLECTPROGRESS_PROGRESS);
                    pcps->hwndPropPage = hwndDlg;
                    SHCreateThread(_CollectProgressDlgProcThread, pcps, 0, NULL);
                }
            }
            break;

        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, FALSE, TRUE);
            break;

        case PSN_WIZBACK:
            // ISSUE: we should NEVER get here
            ANIMATE_STOP(hwndDlg,IDC_PROGRESS_ANIMATE2);
            ANIMATE_CLOSE(hwndDlg,IDC_PROGRESS_ANIMATE2);
            SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
            return TRUE;
            break;

        case PSN_WIZNEXT:
            ANIMATE_STOP(hwndDlg,IDC_PROGRESS_ANIMATE2);
            ANIMATE_CLOSE(hwndDlg,IDC_PROGRESS_ANIMATE2);
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
            }
            else if (g_migwiz->GetOOBEMode())
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ENDOOBE);
            }
            else
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, (g_fStoreToNetwork || g_fStoreToCable) ? IDD_ENDCOLLECTNET : IDD_ENDCOLLECT);
            }
            return TRUE;
            break;
        }
        break;

    case WM_USER_CANCEL_PENDING:
        g_fUberCancel = TRUE;
        pResetEvent (&g_TerminateEvent);
        _NextWizardPage (hwndDlg);
        break;

    case WM_USER_THREAD_COMPLETE:
        hResult = (HRESULT) lParam;
        if (FAILED(hResult))
        {
            g_fUberCancel = TRUE;
        }
        _NextWizardPage (hwndDlg);
        break;

    case WM_USER_STATUS:
    case WM_TIMER:
        INT nResult = 0;
        PTSTR szStatusString = NULL;
        TCHAR szTmpStatus[MAX_LOADSTRING];
        PCTSTR nativeObjectName;
        HWND hwndText = GetDlgItem(hwndDlg, IDC_PROGRESS_STATUS);

        // Let's update the status
        EnterCriticalSection(&g_AppInfoCritSection);
        switch (g_AppInfoPhase) {
            case MIG_HIGHPRIORITYQUEUE_PHASE:
            case MIG_HIGHPRIORITYESTIMATE_PHASE:
            case MIG_GATHERQUEUE_PHASE:
            case MIG_GATHERESTIMATE_PHASE:
            case MIG_ANALYSIS_PHASE:
                nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_QUEUE, szTmpStatus, MAX_LOADSTRING);
                _UpdateText (hwndText, szTmpStatus);
                break;
            case MIG_HIGHPRIORITYGATHER_PHASE:
            case MIG_GATHER_PHASE:
                if (g_AppInfoObjectTypeId != MIG_FILE_TYPE) {
                    nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_GATHER1, szTmpStatus, MAX_LOADSTRING);
                    _UpdateText (hwndText, szTmpStatus);
                } else {
                    nativeObjectName = IsmGetNativeObjectName (g_AppInfoObjectTypeId, g_AppInfoObjectName);
                    if (nativeObjectName) {
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_GATHER2, szTmpStatus, MAX_LOADSTRING);
                        if (nResult) {
                            FormatMessage (
                                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                szTmpStatus,
                                0,
                                0,
                                (LPTSTR)&szStatusString,
                                0,
                                (va_list *)&nativeObjectName);
                        }
                        if (szStatusString) {
                            _UpdateText (hwndText, szStatusString);
                            LocalFree (szStatusString);
                        }
                        IsmReleaseMemory (nativeObjectName);
                    }
                }
                break;
            case MIG_TRANSPORT_PHASE:
                switch (g_AppInfoSubPhase) {
                    case SUBPHASE_CONNECTING1:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_CONNECTING1, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                    case SUBPHASE_CONNECTING2:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_CONNECTING2, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                    case SUBPHASE_NETPREPARING:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_NETPREPARING, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                    case SUBPHASE_PREPARING:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_PREPARING, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                    case SUBPHASE_COMPRESSING:
                        if (g_AppInfoObjectTypeId != MIG_FILE_TYPE) {
                            nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_PREPARING, szTmpStatus, MAX_LOADSTRING);
                            _UpdateText (hwndText, szTmpStatus);
                        } else {
                            nativeObjectName = IsmGetNativeObjectName (g_AppInfoObjectTypeId, g_AppInfoObjectName);
                            if (nativeObjectName) {
                                nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_COMPRESSING, szTmpStatus, MAX_LOADSTRING);
                                if (nResult) {
                                    FormatMessage (
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        szTmpStatus,
                                        0,
                                        0,
                                        (LPTSTR)&szStatusString,
                                        0,
                                        (va_list *)&nativeObjectName);
                                }
                                if (szStatusString) {
                                    _UpdateText (hwndText, szStatusString);
                                    LocalFree (szStatusString);
                                }
                                IsmReleaseMemory (nativeObjectName);
                            }
                        }
                        break;
                    case SUBPHASE_TRANSPORTING:
                        if (g_AppInfoObjectTypeId != MIG_FILE_TYPE) {
                            nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_PREPARING, szTmpStatus, MAX_LOADSTRING);
                            _UpdateText (hwndText, szTmpStatus);
                        } else {
                            nativeObjectName = IsmGetNativeObjectName (g_AppInfoObjectTypeId, g_AppInfoObjectName);
                            if (nativeObjectName) {
                                nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_TRANSPORTING, szTmpStatus, MAX_LOADSTRING);
                                if (nResult) {
                                    FormatMessage (
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        szTmpStatus,
                                        0,
                                        0,
                                        (LPTSTR)&szStatusString,
                                        0,
                                        (va_list *)&nativeObjectName);
                                }
                                if (szStatusString) {
                                    _UpdateText (hwndText, szStatusString);
                                    LocalFree (szStatusString);
                                }
                                IsmReleaseMemory (nativeObjectName);
                            }
                        }
                        break;
                    case SUBPHASE_MEDIAWRITING:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_MEDIAWRITING, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                    case SUBPHASE_FINISHING:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_FINISHING, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                    case SUBPHASE_CABLETRANS:
                        if (g_AppInfoText) {
                            _UpdateText (hwndText, g_AppInfoText);
                        }
                        break;
                    default:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_PREPARING, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                }
                break;
            default:
                break;
        }
        LeaveCriticalSection(&g_AppInfoCritSection);
        break;

    }

    return 0;
}

///////////////////////////////////////////////////////////////

typedef struct {
    HWND hwndProgressBar;
    HWND hwndPropPage;
    HINSTANCE hInstance;
    LPTSTR pszDrive;
    LPTSTR pszCurrDir;
    LPTSTR pszInf;
    BOOL *pfHasUserCancelled;
    DWORD pfError;
} DISKPROGRESSSTRUCT;

DWORD WINAPI _DiskProgressDlgProcThread (LPVOID lpParam)
{
    DISKPROGRESSSTRUCT* pdps = (DISKPROGRESSSTRUCT*)lpParam;

    UtInitialize( NULL );

    _CopyInfToDisk (
        pdps->pszDrive,
        pdps->pszCurrDir,
        pdps->pszInf,
        NULL,
        NULL,
        pdps->hwndProgressBar,
        pdps->hwndPropPage,
        pdps->hInstance,
        pdps->pfHasUserCancelled,
        &pdps->pfError
        );

    UtTerminate();

    return 0;
}


BOOL
pReallyCancel (
    HWND hwndParent,
    HINSTANCE hInstance
    )
{
    TCHAR szMigrationWizardTitle[MAX_LOADSTRING];
    BOOL result = FALSE;

    LoadString(hInstance, IDS_MIGWIZTITLE, szMigrationWizardTitle, ARRAYSIZE(szMigrationWizardTitle));

    if (hwndParent) // Stand-alone wizard mode
    {
        TCHAR szStopDisk[MAX_LOADSTRING];
        LoadString(hInstance, IDS_STOPDISK, szStopDisk, ARRAYSIZE(szStopDisk));
        if (IDYES == _ExclusiveMessageBox(hwndParent, szStopDisk, szMigrationWizardTitle, MB_YESNO | MB_DEFBUTTON2))
        {
            result = TRUE;
        }
    }
    return result;
}

INT_PTR CALLBACK _DiskProgressDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL fHasUserCancelled = FALSE;
    static DWORD fError = ERROR_SUCCESS;
    HWND hwnd;
    LONG lExStyles;

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, 0, FALSE, 0);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            // RTL progress bar for RTL dialogs
            lExStyles = GetWindowLong (hwndDlg, GWL_EXSTYLE);
            if (lExStyles & WS_EX_LAYOUTRTL)
            {
                hwnd = GetDlgItem(hwndDlg, IDC_COLLECTPROGRESS_PROGRESS);
                lExStyles = GetWindowLongA(hwnd, GWL_EXSTYLE);
                lExStyles |= WS_EX_LAYOUTRTL;       // toggle layout
                SetWindowLongA(hwnd, GWL_EXSTYLE, lExStyles);
                InvalidateRect(hwnd, NULL, TRUE);   // redraw
            }
            break;
        case WM_USER_FINISHED:
            if (fHasUserCancelled) {
                PropSheet_PressButton(GetParent(hwndDlg), PSBTN_BACK);
            } else {
                PropSheet_PressButton(GetParent(hwndDlg), PSBTN_NEXT);
            }
            return TRUE;
            break;
        case WM_USER_CANCELLED:
            PropSheet_PressButton(GetParent(hwndDlg), PSBTN_BACK);
            return TRUE;
            break;
        case WM_NOTIFY :
        {
        switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE:
                {
                    // blank progress bar
                    SendMessage(GetDlgItem(hwndDlg, IDC_DISKPROGRESS_PROGRESS), PBM_SETRANGE, 0, 100);
                    SendMessage(GetDlgItem(hwndDlg, IDC_DISKPROGRESS_PROGRESS), PBM_SETPOS, 0, 0);

                    ANIMATE_OPEN(hwndDlg,IDC_PROGRESS_ANIMATE1,IDA_FILECOPY);
                    ANIMATE_PLAY(hwndDlg,IDC_PROGRESS_ANIMATE1);

                    TCHAR szCurrDir[MAX_PATH];
                    if (GetCurrentDirectory(ARRAYSIZE(szCurrDir), szCurrDir))
                    {

                        DISKPROGRESSSTRUCT* pdps = (DISKPROGRESSSTRUCT*)CoTaskMemAlloc(sizeof(DISKPROGRESSSTRUCT));
                        fHasUserCancelled = FALSE;
                        pdps->hwndProgressBar = GetDlgItem(hwndDlg, IDC_DISKPROGRESS_PROGRESS);
                        pdps->hwndPropPage = hwndDlg;
                        pdps->hInstance = g_migwiz->GetInstance();
                        pdps->pszDrive = (LPTSTR)CoTaskMemAlloc(sizeof(TCHAR) * (1 + lstrlen(g_szToolDiskDrive)));
                        StrCpy(pdps->pszDrive, g_szToolDiskDrive);
                        pdps->pszCurrDir = (LPTSTR)CoTaskMemAlloc(sizeof(TCHAR) * (1 + lstrlen(szCurrDir)));
                        StrCpy(pdps->pszCurrDir, szCurrDir);
                        pdps->pszInf = NULL; // means choose default
                        pdps->pfHasUserCancelled = &fHasUserCancelled;

                        SHCreateThread(_DiskProgressDlgProcThread, pdps, 0, NULL);

                        fError = pdps->pfError;
                    }
                }
                break;
            case PSN_QUERYCANCEL:
                fHasUserCancelled = pReallyCancel (hwndDlg, g_migwiz->GetInstance());
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, TRUE);
                return TRUE;
                break;
            case PSN_WIZBACK:
                ANIMATE_STOP(hwndDlg,IDC_PROGRESS_ANIMATE1);
                ANIMATE_CLOSE(hwndDlg,IDC_PROGRESS_ANIMATE1);
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ASKCD);
                return TRUE;
                break;
            case PSN_WIZNEXT:
                ANIMATE_STOP(hwndDlg,IDC_PROGRESS_ANIMATE1);
                ANIMATE_CLOSE(hwndDlg,IDC_PROGRESS_ANIMATE1);
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else if (g_fReadFromNetwork)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPLYPROGRESS); // just got a net connect, skip ahead
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_DISKINSTRUCTIONS);
                }
                return TRUE;
                break;
            default :
                break;
            }
        }
        break;
    }

    return 0;
}
///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _InstructionsDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // just highlight the title
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK | PSWIZB_NEXT, FALSE, 0);

    switch (uMsg)
    {
    case WM_NOTIFY:
        {
        switch (((LPNMHDR)lParam)->code)
            {
            case PSN_QUERYCANCEL:
                return _HandleCancel(hwndDlg, FALSE, FALSE);
                break;
            case PSN_WIZBACK:
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ASKCD);
                return TRUE;
                break;
            case PSN_WIZNEXT:
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else if (g_fReadFromNetwork)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPLYPROGRESS);
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKAPPLYSTORE);
                }
                return TRUE;
                break;
            }
        }
        break;

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pSetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    }

    return 0;
}

///////////////////////////////////////////////////////////////

int CALLBACK
PickApplyCallback (
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam,
    LPARAM lpData
    )
{
    HRESULT hr = S_OK;
    TCHAR tszFolderName[MAX_PATH];
    IMalloc *mallocFn = NULL;
    IShellFolder *psfParent = NULL;
    IShellLink *pslLink = NULL;
    LPCITEMIDLIST pidl;
    LPCITEMIDLIST pidlRelative = NULL;
    LPITEMIDLIST pidlReal = NULL;

    if (uMsg == BFFM_SELCHANGED) {

        hr = SHGetMalloc (&mallocFn);
        if (!SUCCEEDED (hr)) {
            mallocFn = NULL;
        }

        pidl = (LPCITEMIDLIST) lParam;
        pidlReal = NULL;

        if (pidl) {

            hr = OurSHBindToParent (pidl, IID_IShellFolder, (void **)&psfParent, &pidlRelative);

            if (SUCCEEDED(hr)) {
                hr = psfParent->GetUIObjectOf (hwnd, 1, &pidlRelative, IID_IShellLink, NULL, (void **)&pslLink);
                if (SUCCEEDED(hr)) {
                    hr = pslLink->GetIDList (&pidlReal);
                    if (!SUCCEEDED(hr)) {
                        pidlReal = NULL;
                    }
                    pslLink->Release ();
                }
                pidlRelative = NULL;
                psfParent->Release ();
            }

            if (SHGetPathFromIDList(pidlReal?pidlReal:pidl, tszFolderName))
            {
                if (tszFolderName[0] == 0) {
                    SendMessage (hwnd, BFFM_ENABLEOK, 0, 0);
                }
            } else {
                SendMessage (hwnd, BFFM_ENABLEOK, 0, 0);
            }

            if (pidlReal) {
                if (mallocFn) {
                    mallocFn->Free ((void *)pidlReal);
                }
                pidlReal = NULL;
            }
        }

        if (mallocFn) {
            mallocFn->Release ();
            mallocFn = NULL;
        }
    }
    return 0;
}

INT_PTR CALLBACK _PickApplyStoreDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL imageIsValid;
    BOOL imageExists;
    TCHAR szTitle[MAX_LOADSTRING];
    TCHAR szLoadString[MAX_LOADSTRING];
    HWND hwndEdit;
    HRESULT hr = E_FAIL;
    static INT  iSelectedDrive = -1;        // Which removeable media drive is selected

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK | PSWIZB_NEXT, FALSE, 0);
    static UINT uiSelected = 0;

    switch (uMsg)
    {
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_PICKAPPLYSTORE_RADIO1:  // Direct cable
            Button_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_BROWSE), FALSE);
            Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), FALSE);
            Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), TRUE);

            uiSelected = 1;

            // Disable the drive selector
            EnableWindow (GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), FALSE);
            break;

        case IDC_PICKAPPLYSTORE_RADIO2:  // Floppy
            Button_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_BROWSE), FALSE);
            Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), FALSE);
            Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), TRUE);

            uiSelected = 2;

            // Enable the drive selector
            EnableWindow (GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), TRUE);
            break;

        case IDC_PICKAPPLYSTORE_RADIO3:  // Other
            Button_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_BROWSE), TRUE);
            Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), TRUE);
            Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), FALSE);
            Edit_LimitText(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), MAX_PATH - PATH_SAFETY_CHARS);

            uiSelected = 3;

            // Disable the drive selector
            EnableWindow (GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), FALSE);
            break;

        case IDC_PICKAPPLYSTORE_BROWSE:
            {
                HRESULT hr = S_OK;
                IMalloc *mallocFn = NULL;
                IShellFolder *psfParent = NULL;
                IShellLink *pslLink = NULL;
                LPCITEMIDLIST pidl;
                LPCITEMIDLIST pidlRelative = NULL;
                LPITEMIDLIST pidlReal = NULL;
                TCHAR szFolder[MAX_PATH];
                TCHAR szPick[MAX_LOADSTRING];

                hr = SHGetMalloc (&mallocFn);
                if (!SUCCEEDED (hr)) {
                    mallocFn = NULL;
                }

                LoadString(g_migwiz->GetInstance(), IDS_PICKAFOLDER, szPick, ARRAYSIZE(szPick));
                BROWSEINFO brwsinf = { hwndDlg, NULL, NULL, szPick, BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE, PickApplyCallback, 0, 0 };

                pidl = SHBrowseForFolder(&brwsinf);
                if (pidl)
                {
                    hr = OurSHBindToParent (pidl, IID_IShellFolder, (void **)&psfParent, &pidlRelative);

                    if (SUCCEEDED(hr)) {
                        hr = psfParent->GetUIObjectOf (hwndDlg, 1, &pidlRelative, IID_IShellLink, NULL, (void **)&pslLink);
                        if (SUCCEEDED(hr)) {
                            hr = pslLink->GetIDList (&pidlReal);
                            if (SUCCEEDED(hr)) {
                                if (mallocFn) {
                                    mallocFn->Free ((void *)pidl);
                                }
                                pidl = pidlReal;
                                pidlReal = NULL;
                            }
                            pslLink->Release ();
                        }
                        pidlRelative = NULL;
                        psfParent->Release ();
                    }

                    if (SHGetPathFromIDList(pidl, szFolder))
                    {
                        SendMessage(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), WM_SETTEXT, 0, (LPARAM)szFolder);
                    }

                    if (mallocFn) {
                        mallocFn->Free ((void *)pidl);
                    }
                    pidl = NULL;
                }

                if (mallocFn) {
                    mallocFn->Release ();
                    mallocFn = NULL;
                }
            }
            break;
        }
        break;
    case WM_NOTIFY :
        {
            switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE:
                if (g_fReadFromNetwork)
                {
                    PropSheet_PressButton(GetParent(hwndDlg), PSWIZB_NEXT);
                }
                else
                {
                    BOOL fFloppyDetected;
                    INT currDrive;
                    INT comPort;

                    // enable direct cable transport if available
                    comPort = _ComboBoxEx_AddCOMPorts (NULL, 0);
                    Button_Enable (GetDlgItem (hwndDlg, IDC_PICKAPPLYSTORE_RADIO1), (-1 != comPort));

                    SendMessage(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), CBEM_SETIMAGELIST, 0, (LPARAM)g_migwiz->GetImageList());
                    currDrive = _ComboBoxEx_AddDrives (GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO));

                    Button_Enable (GetDlgItem (hwndDlg, IDC_PICKAPPLYSTORE_RADIO2), (-1 != currDrive));
                    fFloppyDetected = (-1 != currDrive);

                    // set the selected drive if any
                    if ((currDrive != -1) && (iSelectedDrive != -1)) {
                        ComboBox_SetCurSel(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), iSelectedDrive);
                        currDrive = iSelectedDrive;
                    }

                    if ((uiSelected == 0 || uiSelected == 1) && (-1 != comPort))
                    {
                        // check Direct cable button
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO1), BST_CHECKED);
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO2), BST_UNCHECKED);
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO3), BST_UNCHECKED);

                        // disable folder box, browse button
                        Button_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_BROWSE), FALSE);
                        Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), FALSE);
                        Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), TRUE);

                        // disable the drive selector
                        EnableWindow (GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), FALSE);
                    }
                    else if ((uiSelected == 0 || uiSelected == 2) && fFloppyDetected)
                    {
                        // check Floppy button
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO1), BST_UNCHECKED);
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO2), BST_CHECKED);
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO3), BST_UNCHECKED);

                        // disable folder box, browse button
                        Button_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_BROWSE), FALSE);
                        Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), FALSE);
                        Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), TRUE);

                        // Enable the drive selector
                        EnableWindow (GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), TRUE);
                    }
                    else  // Other
                    {
                        // check Other button
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO1), BST_UNCHECKED);
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO2), BST_UNCHECKED);
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO3), BST_CHECKED);

                        // enable folder box, browse button
                        Button_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_BROWSE), TRUE);
                        Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), TRUE);
                        Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), FALSE);
                        Edit_LimitText(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), MAX_PATH - PATH_SAFETY_CHARS);

                        // disable the drive selector
                        EnableWindow (GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), FALSE);
                    }

                }
                break;
            case PSN_QUERYCANCEL:
                return _HandleCancel(hwndDlg, FALSE, FALSE);
                break;
            case PSN_WIZBACK:
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else
                {
                    if (g_fHaveWhistlerCD)
                    {
                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_CDINSTRUCTIONS);
                    }
                    else if (g_fAlreadyCollected)
                    {
                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ASKCD);
                    }
                    else
                    {
                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_DISKINSTRUCTIONS);
                    }
                }
                return TRUE;
                break;
            case PSN_WIZNEXT:
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else if (g_fReadFromNetwork)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPLYPROGRESS);
                }
                else
                {
                    if (Button_GetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO1))) // direct cable
                    {
                        g_fStoreToCable = TRUE;

                        if (uiSelected != 1)
                        {
                            uiSelected = 1;
                        }
                    }
                    else if (Button_GetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO2))) // floppy
                    {
                        LPTSTR pszDrive;

                        g_fStoreToCable = FALSE;

                        HWND hwndCombo = GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO);
                        iSelectedDrive = ComboBox_GetCurSel(hwndCombo);
                        pszDrive = (LPTSTR)ComboBox_GetItemData(hwndCombo, iSelectedDrive);

                        lstrcpy(g_szStore, pszDrive);

                        if (uiSelected != 2)
                        {
                            uiSelected = 2;
                        }
                    }
                    else // other
                    {
                        TCHAR tsTemp[MAX_PATH + 1];

                        g_fStoreToCable = FALSE;

                        SendMessage(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), WM_GETTEXT,
                            (WPARAM)ARRAYSIZE(tsTemp), (LPARAM)tsTemp);
                        CopyStorePath(tsTemp, g_szStore);

                        if (uiSelected != 3)
                        {
                            uiSelected = 3;
                        }
                    }

                    if (g_fStoreToCable) {
                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_DIRECTCABLE);
                        return TRUE;
                    }

                    if (!_IsValidStore(g_szStore, FALSE, g_migwiz->GetInstance(), NULL))  // need a valid directory!  stay right here.
                    {
                        LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
                        LoadString(g_migwiz->GetInstance(), IDS_ENTERDEST, szLoadString, ARRAYSIZE(szLoadString));
                        _ExclusiveMessageBox(hwndDlg, szLoadString, szTitle, MB_OK);

                        hwndEdit = GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT);
                        SetFocus(hwndEdit);
                        SendMessage(hwndEdit, EM_SETSEL, 0, -1);

                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, -1);
                        return -1;
                    }

                    hr = Engine_StartTransport (FALSE, g_szStore, &imageIsValid, &imageExists);
                    if ((!SUCCEEDED (hr)) || (!imageIsValid) || (!imageExists)) {

                        LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
                        if (!imageExists) {
                            LoadString(g_migwiz->GetInstance(), IDS_STORAGEEMPTY, szLoadString, ARRAYSIZE(szLoadString));
                        } else {
                            LoadString(g_migwiz->GetInstance(), IDS_STORAGEINVALID, szLoadString, ARRAYSIZE(szLoadString));
                        }
                        _ExclusiveMessageBox (hwndDlg, szLoadString, szTitle, MB_OK);

                        hwndEdit = GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT);
                        SetFocus(hwndEdit);
                        SendMessage(hwndEdit, EM_SETSEL, 0, -1);

                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, -1);
                        return -1;
                    }

                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPLYPROGRESS);
                }
                return TRUE;
                break;
            }
            break;
        }

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pSetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    default:
        break;
    }
    return 0;
}

///////////////////////////////////////////////////////////////

typedef struct {
    HWND hwndProgressBar;
    HWND hwndPropPage;
} APPLYPROGRESSSTRUCT;

BOOL CALLBACK
pSendQueryEndSession (
    HWND hwnd,
    LPARAM lParam
    )
{
    DWORD_PTR result;

    if (hwnd == (HWND)lParam) {
        return TRUE;
    }

    SetForegroundWindow (hwnd);

    if (SendMessageTimeout (
            hwnd,
            WM_QUERYENDSESSION,
            0,
            ENDSESSION_LOGOFF,
            SMTO_ABORTIFHUNG|SMTO_NORMAL|SMTO_NOTIMEOUTIFNOTHUNG,
            1000,
            &result
            )) {
        if (result) {

            SendMessageTimeout (
                hwnd,
                WM_ENDSESSION,
                TRUE,
                ENDSESSION_LOGOFF,
                SMTO_ABORTIFHUNG|SMTO_NORMAL|SMTO_NOTIMEOUTIFNOTHUNG,
                1000,
                &result
                );

            return TRUE;
        }
    }
    return FALSE;
}

BOOL
pLogOffSystem (
    VOID
    )
{
    HWND topLevelWnd = NULL;
    HWND tempWnd = NULL;

    if (g_hwndCurrent) {
        tempWnd = g_hwndCurrent;
        while (tempWnd) {
            topLevelWnd = tempWnd;
            tempWnd = GetParent (tempWnd);
        }
    }

    // first we enumerate all top level windows and send them WM_QUERYENDSESSION
    if (!EnumWindows (pSendQueryEndSession, (LPARAM)topLevelWnd)) {
        return FALSE;
    }

    // finally we call ExitWindowsEx forcing the Log off
    return ExitWindowsEx (EWX_LOGOFF, EWX_FORCE);
}

DWORD WINAPI _ApplyProgressDlgProcThread (LPVOID lpParam)
{
    APPLYPROGRESSSTRUCT* paps = (APPLYPROGRESSSTRUCT*)lpParam;
    BOOL fHasUserCancelled = FALSE;
    HRESULT hResult;

    hResult = _DoApply(g_fReadFromNetwork ? NULL : g_szStore, paps->hwndProgressBar, paps->hwndPropPage, &fHasUserCancelled, NULL, 0);

    if (fHasUserCancelled) {
        hResult = E_FAIL;
    } else {
        if (SUCCEEDED(hResult)) {
            if (g_RebootSystem) {
                g_CompleteReboot = TRUE;
            }
            if (g_LogOffSystem) {
                g_CompleteLogOff = TRUE;
            }
        }
    }

    SendMessage (paps->hwndPropPage, WM_USER_THREAD_COMPLETE, 0, (LPARAM) hResult);

    pSetEvent (&g_TerminateEvent);

    return hResult;
}

INT_PTR CALLBACK _ApplyProgressDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hResult;
    HWND hwnd;
    LONG lExStyles;

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, 0, FALSE, 0);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // RTL progress bar for RTL dialogs
        lExStyles = GetWindowLong (hwndDlg, GWL_EXSTYLE);
        if (lExStyles & WS_EX_LAYOUTRTL)
        {
            hwnd = GetDlgItem(hwndDlg, IDC_COLLECTPROGRESS_PROGRESS);
            lExStyles = GetWindowLongA(hwnd, GWL_EXSTYLE);
            lExStyles |= WS_EX_LAYOUTRTL;       // toggle layout
            SetWindowLongA(hwnd, GWL_EXSTYLE, lExStyles);
            InvalidateRect(hwnd, NULL, TRUE);   // redraw
        }

        // Let's set an update timer to 3 sec.
        SetTimer (hwndDlg, 0, 3000, NULL);

        break;
    case WM_USER_FINISHED:
        PropSheet_PressButton(GetParent(hwndDlg), PSBTN_NEXT);
        return TRUE;
        break;

    case WM_USER_CANCELLED:
        g_fUberCancel = TRUE;
        _NextWizardPage (hwndDlg);
        return TRUE;
        break;

    case WM_NOTIFY :
        {
        switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE:
                {
                    // blank progress bar
                    SendMessage(GetDlgItem(hwndDlg, IDC_DISKPROGRESS_PROGRESS), PBM_SETRANGE, 0, 100);
                    SendMessage(GetDlgItem(hwndDlg, IDC_DISKPROGRESS_PROGRESS), PBM_SETPOS, 0, 0);

                    ANIMATE_OPEN(hwndDlg,IDC_PROGRESS_ANIMATE3,IDA_FILECOPY);
                    ANIMATE_PLAY(hwndDlg,IDC_PROGRESS_ANIMATE3);

                    APPLYPROGRESSSTRUCT* paps = (APPLYPROGRESSSTRUCT*)CoTaskMemAlloc(sizeof(APPLYPROGRESSSTRUCT));
                    paps->hwndProgressBar = GetDlgItem(hwndDlg, IDC_APPLYPROGRESS_PROGRESS);
                    paps->hwndPropPage = hwndDlg;

                    // Lanuch apply thread
                    SHCreateThread(_ApplyProgressDlgProcThread, paps, 0, NULL);
                }
                break;
            case PSN_QUERYCANCEL:
                return _HandleCancel(hwndDlg, FALSE, TRUE);
                break;
            case PSN_WIZBACK:
                ANIMATE_STOP(hwndDlg,IDC_PROGRESS_ANIMATE3);
                ANIMATE_CLOSE(hwndDlg,IDC_PROGRESS_ANIMATE3);
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKAPPLYSTORE);
                return TRUE;
                break;
            case PSN_WIZNEXT:
                ANIMATE_STOP(hwndDlg,IDC_PROGRESS_ANIMATE3);
                ANIMATE_CLOSE(hwndDlg,IDC_PROGRESS_ANIMATE3);
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ENDAPPLY);
                }
                return TRUE;
                break;
            default :
                break;
            }
        }
        break;

    case WM_USER_CANCEL_PENDING:
        g_fUberCancel = TRUE;
        pResetEvent (&g_TerminateEvent);
        _NextWizardPage (hwndDlg);
        break;

    case WM_USER_THREAD_COMPLETE:
        hResult = (HRESULT) lParam;
        if (FAILED(hResult))
        {
            g_fUberCancel = TRUE;
        }
        _NextWizardPage (hwndDlg);
        break;

    case WM_USER_STATUS:
    case WM_TIMER:
        INT nResult = 0;
        PTSTR szStatusString = NULL;
        TCHAR szTmpStatus[MAX_LOADSTRING];
        PCTSTR nativeObjectName;
        HWND hwndText = GetDlgItem(hwndDlg, IDC_APPLYPROGRESS_STATUS);

        // Let's update the status
        EnterCriticalSection(&g_AppInfoCritSection);
        switch (g_AppInfoPhase) {
            case MIG_TRANSPORT_PHASE:
                switch (g_AppInfoSubPhase) {
                    case SUBPHASE_CONNECTING2:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_CONNECTING2, szTmpStatus, MAX_LOADSTRING);
                        if (nResult) {
                            _UpdateText (hwndText, szTmpStatus);
                        }
                        break;
                    case SUBPHASE_NETPREPARING:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_NETPREPARING, szTmpStatus, MAX_LOADSTRING);
                        if (nResult) {
                            _UpdateText (hwndText, szTmpStatus);
                        }
                        break;
                    case SUBPHASE_CABLETRANS:
                        if (g_AppInfoText) {
                            _UpdateText (hwndText, g_AppInfoText);
                        }
                        break;
                    case SUBPHASE_UNCOMPRESSING:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_UNCOMPRESSING, szTmpStatus, MAX_LOADSTRING);
                        if (nResult) {
                            _UpdateText (hwndText, szTmpStatus);
                        }
                    default:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_ORGANIZING, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                }
                break;
            case MIG_HIGHPRIORITYQUEUE_PHASE:
            case MIG_HIGHPRIORITYESTIMATE_PHASE:
            case MIG_HIGHPRIORITYGATHER_PHASE:
            case MIG_GATHERQUEUE_PHASE:
            case MIG_GATHERESTIMATE_PHASE:
            case MIG_GATHER_PHASE:
            case MIG_ANALYSIS_PHASE:
                nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_ORGANIZING, szTmpStatus, MAX_LOADSTRING);
                _UpdateText (hwndText, szTmpStatus);
                break;
            case MIG_APPLY_PHASE:
                nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_APPLY, szTmpStatus, MAX_LOADSTRING);
                _UpdateText (hwndText, szTmpStatus);
                break;
            default:
                break;
        }
        LeaveCriticalSection(&g_AppInfoCritSection);

        break;

    }

    return 0;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _AskCDDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static UINT uiSelected = 1;  // 1=MakeDisk, 2=HaveDisk, 3:UseCD, 4:Collected
    static INT  iSelectedDrive = -1;        // Which removeable media drive is selected

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_NEXT, FALSE, 0);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        uiSelected = 1;
        Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO1), BST_CHECKED);
        Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO2), BST_UNCHECKED);
        Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO3), BST_UNCHECKED);
        break;
    case WM_COMMAND:
        if (BN_CLICKED == HIWORD(wParam))
        {
            switch (LOWORD(wParam))
            {
            case IDC_ASKCD_RADIO1:
                uiSelected = 1;
                break;
            case IDC_ASKCD_RADIO2:
                uiSelected = 2;
                break;
            case IDC_ASKCD_RADIO3:
                uiSelected = 3;
                break;
            case IDC_ASKCD_RADIO4:
                uiSelected = 4;
                break;
            }

            BOOL fActivate = (1 == uiSelected);
            EnableWindow (GetDlgItem (hwndDlg, IDC_ASKCD_COMBO), fActivate);
        }
        break;
    case WM_NOTIFY :
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            // Reinit my globals
            g_fAlreadyCollected = FALSE;
            g_fHaveWhistlerCD = FALSE;

            // Check for HomeLan
            if (g_fReadFromNetwork)
            {
                PropSheet_PressButton(GetParent(hwndDlg), PSWIZB_NEXT);
            }
            else
            {
                HWND hwndCombo = GetDlgItem(hwndDlg, IDC_ASKCD_COMBO);

                SendMessage(hwndCombo, CBEM_SETIMAGELIST, 0, (LPARAM)g_migwiz->GetImageList());
                _ComboBoxEx_AddDrives (hwndCombo);

                if (ComboBox_GetCount(hwndCombo) > 0) {
                    EnableWindow (hwndCombo, (1 == uiSelected));
                    Button_Enable (GetDlgItem(hwndDlg, IDC_ASKCD_RADIO1), TRUE);

                    if( iSelectedDrive != -1 )
                    {
                        ComboBox_SetCurSel(hwndCombo, iSelectedDrive);
                    }
                } else {
                    // No floppy drives exist.  Disable the creation option
                    if (uiSelected == 1) {
                        uiSelected = 3;
                    }
                    EnableWindow (hwndCombo, FALSE);
                    Button_Enable (GetDlgItem(hwndDlg, IDC_ASKCD_RADIO1), FALSE);
                }

                Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO1), BST_UNCHECKED);
                Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO2), BST_UNCHECKED);
                Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO3), BST_UNCHECKED);
                Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO4), BST_UNCHECKED);
                switch (uiSelected)
                {
                case 1: // Create wizard disk
                    Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO1), BST_CHECKED);
                    break;
                case 2: // I already have wizard disk
                    Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO2), BST_CHECKED);
                    break;
                case 3: // I will use the CD
                    Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO3), BST_CHECKED);
                    break;
                case 4: // I already have the stuff collected
                    Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO4), BST_CHECKED);
                    break;
                }
            }
            break;
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, FALSE, FALSE);
            break;
        case PSN_WIZNEXT:
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
            }
            else if (g_fReadFromNetwork)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPLYPROGRESS);
            }
            else
            {
                switch (uiSelected)
                {
                case 1: // Create wizard disk
                    {
                        LPTSTR pszDrive;
                        HWND hwndRemoveCombo = GetDlgItem(hwndDlg, IDC_ASKCD_COMBO);
                        iSelectedDrive = ComboBox_GetCurSel(hwndRemoveCombo);
                        pszDrive = (LPTSTR)ComboBox_GetItemData(hwndRemoveCombo, iSelectedDrive);
                        StrCpyN(g_szToolDiskDrive, pszDrive, ARRAYSIZE(g_szToolDiskDrive));

                        TCHAR szTitle[MAX_LOADSTRING];
                        LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
                        TCHAR szMsg[MAX_LOADSTRING];
                        LoadString(g_migwiz->GetInstance(), IDS_MAKETOOLDISK_INSERT, szMsg, ARRAYSIZE(szMsg));
                        if (IDOK == _ExclusiveMessageBox(hwndDlg, szMsg, szTitle, MB_OKCANCEL))
                        {
                            SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_DISKPROGRESS);
                        }
                        else
                        {
                            SetWindowLong(hwndDlg, DWLP_MSGRESULT, -1); // stay right here
                        }
                        return TRUE;
                    }
                    break;
                case 2: // I already have wizard disk
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_DISKINSTRUCTIONS);
                    return TRUE;
                case 3: // I will use the CD
                    g_fHaveWhistlerCD = TRUE;
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_CDINSTRUCTIONS);
                    return TRUE;
                case 4: // I already have the stuff collected
                    g_fAlreadyCollected = TRUE;
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKAPPLYSTORE);
                    return TRUE;
                }
            }
            return TRUE;
            break;
        }
        break;

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pSetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    }

    return 0;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _CDInstructionsDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // just highlight the title
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK | PSWIZB_NEXT, FALSE, 0);

    switch (uMsg)
    {
    case WM_NOTIFY:
        {
        switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE:
                if (g_fReadFromNetwork)
                {
                    PropSheet_PressButton(GetParent(hwndDlg), PSWIZB_NEXT);
                }
                else
                {
                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                }
                break;
            case PSN_QUERYCANCEL:
                return _HandleCancel(hwndDlg, FALSE, FALSE);
                break;
            case PSN_WIZBACK:
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ASKCD);
                return TRUE;
                break;
            case PSN_WIZNEXT:
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else if (g_fReadFromNetwork)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPLYPROGRESS);
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKAPPLYSTORE);
                }
                return TRUE;
                break;
            }
        }
        break;

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pSetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    }

    return 0;
}

VOID
pGenerateHTMLAppList (HANDLE FileHandle)
{
    TCHAR szLoadStr[MAX_LOADSTRING];
    POBJLIST objList = NULL;
    DWORD written;

#ifdef UNICODE
    ((PBYTE)szLoadStr) [0] = 0xFF;
    ((PBYTE)szLoadStr) [1] = 0xFE;
    WriteFile (FileHandle, szLoadStr, 2, &written, NULL);
#endif

    pWriteStrResToFile (FileHandle, IDS_APPINSTALL_BEGIN);

    _tcscpy (szLoadStr, TEXT("<UL>\n"));
    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

    objList = g_HTMLApps;

    while (objList) {
        if (objList->ObjectName) {
            _tcscpy (szLoadStr, TEXT("<LI>"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
            WriteFile (FileHandle, objList->ObjectName, (_tcslen (objList->ObjectName) + 1) * sizeof (TCHAR), &written, NULL);
        }
        objList = objList->Next;
    }

    _tcscpy (szLoadStr, TEXT("</UL>\n"));
    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

    pWriteStrResToFile (FileHandle, IDS_APPINSTALL_END);
}


INT_PTR CALLBACK _AppInstallDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    IWebBrowser2    *m_pweb = NULL;            // IE4 IWebBrowser interface pointer
    IUnknown        *punk = NULL;
    HWND webHostWnd = NULL;
    HANDLE hHTMLAppList = INVALID_HANDLE_VALUE;
    PWSTR szTarget;

    // just highlight the title
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK | PSWIZB_NEXT, FALSE, 0);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_APPINSTALLTITLE);
        }
        break;

    case WM_DESTROY:
        if (m_pweb)
            m_pweb->Release();
            m_pweb = NULL;

        //
        //  tell the container to remove IE4 and then
        //  release our reference to the container.
        //
        if (g_WebContainer)
        {
            g_WebContainer->remove();
            g_WebContainer->Release();
            g_WebContainer = NULL;
        }
        break;
    case WM_NOTIFY:
        {
        switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE:
                if (!g_fCancelPressed) {
                    webHostWnd = GetDlgItem (hwndDlg, IDC_APPWEBHOST);
                    if (webHostWnd) {
                        // Now let's generate the failure HTML file.
                        if (*g_HTMLAppList) {
                            hHTMLAppList = CreateFile (g_HTMLAppList,
                                                       GENERIC_READ|GENERIC_WRITE,
                                                       FILE_SHARE_READ,
                                                       NULL,
                                                       CREATE_ALWAYS,
                                                       0,
                                                       NULL);
                            if (hHTMLAppList != INVALID_HANDLE_VALUE) {
                                pGenerateHTMLAppList (hHTMLAppList);
                                if (g_WebContainer)
                                {
                                    g_WebContainer->remove();
                                    g_WebContainer->Release();
                                    g_WebContainer = NULL;
                                }
                                g_WebContainer = new Container();
                                if (g_WebContainer)
                                {
                                    g_WebContainer->setParent(webHostWnd);
                                    g_WebContainer->add(L"Shell.Explorer");
                                    g_WebContainer->setVisible(TRUE);
                                    g_WebContainer->setFocus(TRUE);

                                    //
                                    //  get the IWebBrowser2 interface and cache it.
                                    //
                                    punk = g_WebContainer->getUnknown();
                                    if (punk)
                                    {
                                        punk->QueryInterface(IID_IWebBrowser2, (PVOID *)&m_pweb);
                                        if (m_pweb) {
#ifdef UNICODE
                                            m_pweb->Navigate(g_HTMLAppList, NULL, NULL, NULL, NULL);
#else
                                            szTarget = _ConvertToUnicode (CP_ACP, g_HTMLAppList);
                                            if (szTarget) {
                                                m_pweb->Navigate(szTarget, NULL, NULL, NULL, NULL);
                                                LocalFree ((HLOCAL)szTarget);
                                                szTarget = NULL;
                                            }
#endif
                                        }
                                        punk->Release();
                                        punk = NULL;
                                    }
                                }
                                // We intentionally want to keep this file open for the life of the wizard.
                                // With this we eliminate the possibility for someone to overwrite the
                                // content of the HTML file therefore forcing us to show something else
                                // maybe even run some malicious script.
                                // CloseHandle (hHTMLAppList);
                            }

                        } else {
                            ShowWindow(webHostWnd, SW_HIDE);
                        }
                    }
                }
                break;
            case PSN_QUERYCANCEL:
                return _HandleCancel(hwndDlg, FALSE, FALSE);
                break;
            case PSN_WIZBACK:
                if (g_fCustomize == TRUE) {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_CUSTOMIZE);
                } else {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKMETHOD);
                }
                return TRUE;
                break;
            case PSN_WIZNEXT:
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_COLLECTPROGRESS);
                }
                return TRUE;
            }
        }
        break;
    case WM_USER_CANCEL_PENDING:
        g_fUberCancel = TRUE;
        pSetEvent (&g_TerminateEvent);
        _NextWizardPage (hwndDlg);
        break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\scanstate\sources.inc ===
!include ..\..\app.mk

MINORCOMP=scanstate

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\scanstate.c      \
    ..\scanstate.rc     \
    ..\logmsg.mc        \

# extra libs
TARGETLIBS= $(TARGETLIBS)                           \
            $(COBRA_ROOT)\lib\$(O)\utils.lib        \
            $(COBRA_ROOT)\bin\$(O)\migism.lib       \

PRECOMPILED_INCLUDE=..\pch.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\registry.h ===
#ifndef __Registry_H__
#define __Registry_H__
//
// Registry.h
//   - Helper functions registering and unregistering a component.
//

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const char* szFriendlyName,
                       const char* szVerIndProgID,
                       const char* szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid,
                         const char* szVerIndProgID,
                         const char* szProgID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\migwiz\registry.cpp ===
//
// Registry.cpp
//

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const char* pszPath,
                    const char* szSubkey,
                    const char* szValue) ;

// Convert a CLSID into a char string.
void CLSIDtochar(const CLSID& clsid, 
                 char* szCLSID,
                 int length) ;

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const char* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const char* szFriendlyName, // Friendly Name
                       const char* szVerIndProgID, // Programmatic
                       const char* szProgID)       //   IDs
{
	// Get server location.
	char szModule[512] ;
	DWORD dwResult =
		::GetModuleFileName(hModule, 
		                    szModule,
		                    sizeof(szModule)/sizeof(char)) ;
	assert(dwResult != 0) ;

	// Convert the CLSID into a char.
	char szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

	// Build the key CLSID\\{...}
	char szKey[64] ;
	strcpy(szKey, "CLSID\\") ;
	strcat(szKey, szCLSID) ;
  
	// Add the CLSID to the registry.
	setKeyAndValue(szKey, NULL, szFriendlyName) ;

	// Add the server filename subkey under the CLSID key.
	setKeyAndValue(szKey, "InprocServer32", szModule) ;

	// Add the ProgID subkey under the CLSID key.
	setKeyAndValue(szKey, "ProgID", szProgID) ;

	// Add the version-independent ProgID subkey under CLSID key.
	setKeyAndValue(szKey, "VersionIndependentProgID",
	               szVerIndProgID) ;

	// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szVerIndProgID, "CLSID", szCLSID) ;
	setKeyAndValue(szVerIndProgID, "CurVer", szProgID) ;

	// Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szProgID, "CLSID", szCLSID) ;

	return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid,         // Class ID
                      const char* szVerIndProgID, // Programmatic
                      const char* szProgID)       //   IDs
{
	// Convert the CLSID into a char.
	char szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

	// Build the key CLSID\\{...}
	char szKey[64] ;
	strcpy(szKey, "CLSID\\") ;
	strcat(szKey, szCLSID) ;

	// Delete the CLSID Key - CLSID\{...}
	LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the version-independent ProgID Key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the ProgID key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a char string.
void CLSIDtochar(const CLSID& clsid,
                 char* szCLSID,
                 int length)
{
	assert(length >= CLSID_STRING_SIZE) ;
	// Get CLSID
	LPOLESTR wszCLSID = NULL ;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
	assert(SUCCEEDED(hr)) ;

	// Covert from wide characters to non-wide.
	wcstombs(szCLSID, wszCLSID, length) ;

	// Free memory.
	CoTaskMemFree(wszCLSID) ;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const char* lpszKeyChild)  // Key to delete
{
	// Open the child.
	HKEY hKeyChild ;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
	                         KEY_ALL_ACCESS, &hKeyChild) ;
	if (lRes != ERROR_SUCCESS)
	{
		return lRes ;
	}

	// Enumerate all of the decendents of this child.
	FILETIME time ;
	char szBuffer[256] ;
	DWORD dwSize = 256 ;
	while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
	                    NULL, NULL, &time) == S_OK)
	{
		// Delete the decendents of this child.
		lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
		if (lRes != ERROR_SUCCESS)
		{
			// Cleanup before exiting.
			RegCloseKey(hKeyChild) ;
			return lRes;
		}
		dwSize = 256 ;
	}

	// Close the child.
	RegCloseKey(hKeyChild) ;

	// Delete this child.
	return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const char* szKey,
                    const char* szSubkey,
                    const char* szValue)
{
	HKEY hKey;
	char szKeyBuf[1024] ;

	// Copy keyname into buffer.
	strcpy(szKeyBuf, szKey) ;

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
		strcat(szKeyBuf, "\\") ;
		strcat(szKeyBuf, szSubkey ) ;
	}

	// Create and open key and subkey.
	long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
	                              szKeyBuf, 
	                              0, NULL, REG_OPTION_NON_VOLATILE,
	                              KEY_ALL_ACCESS, NULL, 
	                              &hKey, NULL) ;
	if (lResult != ERROR_SUCCESS)
	{
		return FALSE ;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueEx(hKey, NULL, 0, REG_SZ, 
		              (BYTE *)szValue, 
		              strlen(szValue)+1) ;
	}

	RegCloseKey(hKey) ;
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\attrib.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    attrib.c

Abstract:

    Implements the attribute interface for the ISM.  Attributes are caller-defined
    flags that are associated with objects, for purposes of understanding and
    organizing state.

Author:

    Jim Schmidt (jimschm) 01-Feb-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_ATTRIB      "Attrib"

//
// Strings
//

#define S_PERSISTENT_ATTRIBUTE          TEXT("$PERSISTENT")
#define S_APPLY_ATTRIBUTE               TEXT("$APPLY")
#define S_ABANDONED_ATTRIBUTE           TEXT("$ABANDONED")
#define S_NONCRITICAL_ATTRIBUTE         TEXT("$NONCRITICAL")

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PUINT LinkageList;
    UINT Count;
    UINT Index;
} OBJECTATTRIBUTE_HANDLE, *POBJECTATTRIBUTE_HANDLE;

typedef struct {
    PUINT LinkageList;
    UINT Count;
    UINT Index;
    PCTSTR ObjectFromMemdb;
} OBJECTWITHATTRIBUTE_HANDLE, *POBJECTWITHATTRIBUTE_HANDLE;

//
// Globals
//

MIG_ATTRIBUTEID g_PersistentAttributeId = 0;
MIG_ATTRIBUTEID g_ApplyAttributeId = 0;
MIG_ATTRIBUTEID g_AbandonedAttributeId = 0;
MIG_ATTRIBUTEID g_NonCriticalAttributeId = 0;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

PCTSTR
pGetAttributeNameForDebugMsg (
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    static TCHAR name[256];

    if (!IsmGetAttributeName (AttributeId, name, ARRAYSIZE(name), NULL, NULL, NULL)) {
        StringCopy (name, TEXT("<invalid attribute>"));
    }

    return name;
}


PCTSTR
pAttributePathFromId (
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    return MemDbGetKeyFromHandle ((UINT) AttributeId, 0);
}


VOID
pAttributePathFromName (
    IN      PCTSTR AttributeName,
    OUT     PTSTR Path
    )
{
    wsprintf (Path, TEXT("Attrib\\%s"), AttributeName);
}


MIG_ATTRIBUTEID
IsmRegisterAttribute (
    IN      PCTSTR AttributeName,
    IN      BOOL Private
    )

/*++

Routine Description:

  IsmRegisterAttribute creates a public or private attribute and returns the
  ID to the caller. If the attribute already exists, then the existing ID is
  returned to the caller.

Arguments:

  AttribName    - Specifies the attribute name to register.
  Private       - Specifies TRUE if the attribute is owned by the calling module
                  only, or FALSE if it is shared by all modules. If TRUE is
                  specified, the caller must be in an ISM callback function.

Return Value:

  The ID of the attribute, or 0 if the registration failed.

--*/

{
    TCHAR attribPath[MEMDB_MAX];
    TCHAR decoratedName[MEMDB_MAX];
    UINT offset;

    if (!g_CurrentGroup && Private) {
        DEBUGMSG ((DBG_ERROR, "IsmRegisterAttribute called for private attribute outside of ISM-managed context"));
        return 0;
    }

    if (!IsValidCNameWithDots (AttributeName)) {
        DEBUGMSG ((DBG_ERROR, "attribute name \"%s\" is illegal", AttributeName));
        return 0;
    }

#ifdef DEBUG
    if (Private && !IsValidCName (g_CurrentGroup)) {
        DEBUGMSG ((DBG_ERROR, "group name \"%s\" is illegal", g_CurrentGroup));
        return 0;
    }
#endif

    if (Private) {
        wsprintf (decoratedName, TEXT("%s:%s"), g_CurrentGroup, AttributeName);
    } else {
        wsprintf (decoratedName, S_COMMON TEXT(":%s"), AttributeName);
    }

    pAttributePathFromName (decoratedName, attribPath);

    if (!MarkGroupIds (attribPath)) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s conflicts with previously registered attribute",
            attribPath
            ));
        return 0;
    }

    offset = MemDbSetKey (attribPath);

    if (!offset) {
        EngineError ();
        return 0;
    }

    return (MIG_ATTRIBUTEID) offset;
}


BOOL
RegisterInternalAttributes (
    VOID
    )
{
    TCHAR attribPath[MEMDB_MAX];
    TCHAR decoratedName[MEMDB_MAX];
    UINT offset;

    wsprintf (decoratedName, S_COMMON TEXT(":%s"), S_PERSISTENT_ATTRIBUTE);
    pAttributePathFromName (decoratedName, attribPath);

    if (!MarkGroupIds (attribPath)) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s conflicts with previously registered attribute",
            attribPath
            ));
        return 0;
    }

    offset = MemDbSetKey (attribPath);
    if (!offset) {
        EngineError ();
        return FALSE;
    }

    g_PersistentAttributeId = (MIG_ATTRIBUTEID) offset;

    wsprintf (decoratedName, S_COMMON TEXT(":%s"), S_APPLY_ATTRIBUTE);
    pAttributePathFromName (decoratedName, attribPath);

    if (!MarkGroupIds (attribPath)) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s conflicts with previously registered attribute",
            attribPath
            ));
        return 0;
    }

    offset = MemDbSetKey (attribPath);
    if (!offset) {
        EngineError ();
        return FALSE;
    }

    g_ApplyAttributeId = (MIG_ATTRIBUTEID) offset;

    wsprintf (decoratedName, S_COMMON TEXT(":%s"), S_ABANDONED_ATTRIBUTE);
    pAttributePathFromName (decoratedName, attribPath);

    if (!MarkGroupIds (attribPath)) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s conflicts with previously registered attribute",
            attribPath
            ));
        return 0;
    }

    offset = MemDbSetKey (attribPath);
    if (!offset) {
        EngineError ();
        return FALSE;
    }

    g_AbandonedAttributeId = (MIG_ATTRIBUTEID) offset;

    wsprintf (decoratedName, S_COMMON TEXT(":%s"), S_NONCRITICAL_ATTRIBUTE);
    pAttributePathFromName (decoratedName, attribPath);

    if (!MarkGroupIds (attribPath)) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s conflicts with previously registered attribute",
            attribPath
            ));
        return 0;
    }

    offset = MemDbSetKey (attribPath);
    if (!offset) {
        EngineError ();
        return FALSE;
    }

    g_NonCriticalAttributeId = (MIG_ATTRIBUTEID) offset;

    return TRUE;
}


BOOL
IsmGetAttributeName (
    IN      MIG_ATTRIBUTEID AttributeId,
    OUT     PTSTR AttributeName,            OPTIONAL
    IN      UINT AttributeNameBufChars,
    OUT     PBOOL Private,                  OPTIONAL
    OUT     PBOOL BelongsToMe,              OPTIONAL
    OUT     PUINT ObjectReferences          OPTIONAL
    )

/*++

Routine Description:

  IsmGetAttributeName obtains the attribute text name from a numeric ID. It
  also identifies private and owned attributes.

Arguments:

  AttributeId           - Specifies the attribute ID to look up.
  AttributeName         - Receives the attribute name. The name is filled for
                          all valid AttributeId values, even when the return
                          value is FALSE.
  AttributeNameBufChars - Specifies the number of TCHARs that AttributeName
                          can hold, including the nul terminator.
  Private               - Receives TRUE if the attribute is private, or FALSE
                          if it is public.
  BelongsToMe           - Receives TRUE if the attribute is private and
                          belongs to the caller, FALSE otherwise.
  ObjectReferences      - Receives the number of objects that reference the
                          attribute


Return Value:

  TRUE if the attribute is public, or if the attribute is private and belongs to
  the caller.

  FALSE if the attribute is private and belongs to someone else. AttributeName,
  Private and BelongsToMe are valid in this case.

  FALSE if AttributeId is not valid. Attributename, Private and BelongsToMe are
  not modified in this case.  Do not use this function to test if AttributeId
  is valid or not.

--*/


  {
    PCTSTR attribPath = NULL;
    PCTSTR start;
    PTSTR p, q;
    BOOL privateAttribute = FALSE;
    BOOL groupMatch = FALSE;
    BOOL result = FALSE;
    UINT references;
    PUINT linkageList;

    __try {
        //
        // Get the attribute path from memdb, then parse it for group and name
        //

        attribPath = pAttributePathFromId (AttributeId);
        if (!attribPath) {
            __leave;
        }

        p = _tcschr (attribPath, TEXT('\\'));
        if (!p) {
            __leave;
        }

        start = _tcsinc (p);
        p = _tcschr (start, TEXT(':'));

        if (!p) {
            __leave;
        }

        q = _tcsinc (p);
        *p = 0;

        if (StringIMatch (start, S_COMMON)) {

            //
            // This attribute is a global attribute.
            //

            privateAttribute = FALSE;
            groupMatch = TRUE;

        } else if (g_CurrentGroup) {

            //
            // This attribute is private. Check if it is ours.
            //

            privateAttribute = TRUE;

            if (StringIMatch (start, g_CurrentGroup)) {
                groupMatch = TRUE;
            } else {
                groupMatch = FALSE;
            }
        } else {

            //
            // This is a private attribute, but the caller is not
            // a module that can own attributes.
            //

            DEBUGMSG ((DBG_WARNING, "IsmGetAttributeName: Caller cannot own private attributes"));
        }

        //
        // Copy the name to the buffer, update outbound BOOLs, set result
        //

        if (AttributeName && AttributeNameBufChars >= sizeof (TCHAR)) {
            StringCopyByteCount (AttributeName, q, AttributeNameBufChars * sizeof (TCHAR));
        }

        if (Private) {
            *Private = privateAttribute;
        }

        if (BelongsToMe) {
            *BelongsToMe = privateAttribute && groupMatch;
        }

        if (ObjectReferences) {
            linkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                AttributeId,
                                ATTRIBUTE_INDEX,
                                &references
                                );

            references /= SIZEOF(KEYHANDLE);

            if (linkageList) {
                MemDbReleaseMemory (linkageList);
                INVALID_POINTER (linkageList);
            } else {
                references = 0;
            }

            *ObjectReferences = references;
        }

        if (groupMatch) {
            result = TRUE;
        }
    }
    __finally {
        if (attribPath) {       //lint !e774
            MemDbReleaseMemory (attribPath);
            attribPath = NULL;
        }
    }
    return result;
}


MIG_ATTRIBUTEID
IsmGetAttributeGroup (
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    return (MIG_ATTRIBUTEID) GetGroupOfId ((KEYHANDLE) AttributeId);
}


BOOL
pSetAttributeOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId,
    IN      BOOL QueryOnly
    )
{
    BOOL result = FALSE;

    __try {
        //
        // Test if object is locked, then if not locked, add linkage
        //

        if (TestLock (ObjectId, (KEYHANDLE) AttributeId)) {

            SetLastError (ERROR_LOCKED);
            DEBUGMSG ((
                DBG_WARNING,
                "Can't set attribute %s on %s because of lock",
                pGetAttributeNameForDebugMsg (AttributeId),
                GetObjectNameForDebugMsg (ObjectId)
                ));

            __leave;

        }

        if (QueryOnly) {
            result = TRUE;
            __leave;
        }

        result = MemDbAddDoubleLinkageByKeyHandle (
                    ObjectId,
                    AttributeId,
                    ATTRIBUTE_INDEX
                    );
        if (!result) {
            EngineError ();
        }
    }
    __finally {
    }

    return result;
}


BOOL
pSetAttributeGroup (
    IN      KEYHANDLE AttributeId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    MYASSERT (IsItemId (AttributeId));

    return pSetAttributeOnObjectId (
                (MIG_OBJECTID) Arg,
                (MIG_ATTRIBUTEID) AttributeId,
                FirstPass
                );
}


BOOL
IsmSetAttributeOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    RECURSERETURN rc;

    //
    // If AttributeId is a group, set all attribs in the group
    //

    rc = RecurseForGroupItems (
                AttributeId,
                pSetAttributeGroup,
                (ULONG_PTR) ObjectId,
                FALSE,
                FALSE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pSetAttributeOnObjectId (ObjectId, AttributeId, FALSE);
}


BOOL
IsmSetAttributeOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = GetObjectIdForModification (ObjectTypeId, EncodedObjectName);

    if (objectId) {
        result = IsmSetAttributeOnObjectId (objectId, AttributeId);
    }

    return result;
}


BOOL
IsmMakePersistentObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    BOOL result;

    if (IsmIsPersistentObjectId (ObjectId)) {
        return TRUE;
    }

    result = pSetAttributeOnObjectId (ObjectId, g_PersistentAttributeId, FALSE);

    if (result) {

        g_TotalObjects.PersistentObjects ++;

        result = MemDbGetValueByHandle (ObjectId, &objectTypeId);

        if (result) {

            if ((objectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
                g_SourceObjects.PersistentObjects ++;
            } else {
                g_DestinationObjects.PersistentObjects ++;
            }
            IncrementPersistentObjectCount (objectTypeId);
        }

        result = TRUE;
    }

    return result;
}


BOOL
IsmMakePersistentObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, FALSE);

    if (objectId) {
        result = IsmMakePersistentObjectId (objectId);
    }

    return result;
}


BOOL
IsmMakeApplyObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    BOOL result;

    if (IsmIsApplyObjectId (ObjectId)) {
        return TRUE;
    }

    if (!IsmMakePersistentObjectId (ObjectId)) {
        return FALSE;
    }

    result = pSetAttributeOnObjectId (ObjectId, g_ApplyAttributeId, FALSE);

    if (result) {

        g_TotalObjects.ApplyObjects ++;

        result = MemDbGetValueByHandle (ObjectId, &objectTypeId);

        if (result) {

            if ((objectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
                g_SourceObjects.ApplyObjects ++;
            } else {
                g_DestinationObjects.ApplyObjects ++;
            }
            IncrementApplyObjectCount (objectTypeId);
        }

        result = TRUE;
    }

    return result;
}

BOOL
IsmMakeApplyObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, FALSE);

    if (objectId) {
        result = IsmMakeApplyObjectId (objectId);
    }

    return result;
}


BOOL
IsmAbandonObjectIdOnCollision (
    IN      MIG_OBJECTID ObjectId
    )
{
    BOOL result;

    if (IsmIsObjectIdAbandonedOnCollision (ObjectId)) {
        return TRUE;
    }

    result = pSetAttributeOnObjectId (ObjectId, g_AbandonedAttributeId, FALSE);

    return result;
}

BOOL
IsmAbandonObjectOnCollision (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, FALSE);

    if (objectId) {
        result = IsmAbandonObjectIdOnCollision (objectId);
    }

    return result;
}


BOOL
IsmMakeNonCriticalObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    if (IsmIsNonCriticalObjectId (ObjectId)) {
        return TRUE;
    }

    return pSetAttributeOnObjectId (ObjectId, g_NonCriticalAttributeId, FALSE);
}


BOOL
IsmMakeNonCriticalObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, FALSE);

    if (objectId) {
        result = IsmMakeNonCriticalObjectId (objectId);
    }

    return result;
}


VOID
IsmLockAttribute (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    LockHandle (ObjectId, (KEYHANDLE) AttributeId);
}


BOOL
pClearAttributeOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId,
    IN      BOOL QueryOnly
    )
{
    PCTSTR groupKey = NULL;
    PCTSTR enumKey = NULL;
    BOOL result = FALSE;

    __try {

        if (TestLock (ObjectId, (KEYHANDLE) AttributeId)) {

            SetLastError (ERROR_LOCKED);
            DEBUGMSG ((
                DBG_ERROR,
                "Can't clear attribute %s on %s because of lock",
                pGetAttributeNameForDebugMsg (AttributeId),
                GetObjectNameForDebugMsg (ObjectId)
                ));

            __leave;

        }

        if (QueryOnly) {
            result = TRUE;
            __leave;
        }

        result = MemDbDeleteDoubleLinkageByKeyHandle (
                    ObjectId,
                    AttributeId,
                    ATTRIBUTE_INDEX
                    );
    }
    __finally {
        if (groupKey) {
            MemDbReleaseMemory (groupKey);
            INVALID_POINTER (groupKey);
        }

        if (enumKey) {
            FreeText (enumKey);
            INVALID_POINTER (enumKey);
        }
    }

    return result;
}


BOOL
pClearAttributeGroup (
    IN      KEYHANDLE AttributeId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    return pClearAttributeOnObjectId (
                (MIG_OBJECTID) Arg,
                (MIG_ATTRIBUTEID) AttributeId,
                FirstPass
                );
}


BOOL
IsmClearAttributeOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    RECURSERETURN rc;

    //
    // If AttributeId is a group, set all attribs in the group
    //

    rc = RecurseForGroupItems (
                AttributeId,
                pClearAttributeGroup,
                (ULONG_PTR) ObjectId,
                FALSE,
                FALSE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pClearAttributeOnObjectId (ObjectId, AttributeId, FALSE);
}


BOOL
IsmClearAttributeOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmClearAttributeOnObjectId (objectId, AttributeId);
    }

    return result;
}


BOOL
IsmClearPersistenceOnObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    BOOL result;

    if (!IsmIsPersistentObjectId (ObjectId)) {
        return TRUE;
    }

    if (!IsmClearApplyOnObjectId (ObjectId)) {
        return FALSE;
    }

    result = pClearAttributeOnObjectId (ObjectId, g_PersistentAttributeId, FALSE);

    if (result) {

        g_TotalObjects.PersistentObjects --;

        result = MemDbGetValueByHandle (ObjectId, &objectTypeId);

        if (result) {

            if ((objectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
                g_SourceObjects.PersistentObjects --;
            } else {
                g_DestinationObjects.PersistentObjects --;
            }
            DecrementPersistentObjectCount (objectTypeId);
        }

        result = TRUE;
    }

    return result;
}


BOOL
IsmClearPersistenceOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmClearPersistenceOnObjectId (objectId);
    }

    return result;
}


BOOL
IsmClearApplyOnObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    BOOL result;

    if (!IsmIsApplyObjectId (ObjectId)) {
        return TRUE;
    }

    result = pClearAttributeOnObjectId (ObjectId, g_ApplyAttributeId, FALSE);

    if (result) {

        g_TotalObjects.ApplyObjects --;

        result = MemDbGetValueByHandle (ObjectId, &objectTypeId);

        if (result) {

            if ((objectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
                g_SourceObjects.ApplyObjects --;
            } else {
                g_DestinationObjects.ApplyObjects --;
            }
            DecrementApplyObjectCount (objectTypeId);
        }

        result = TRUE;
    }

    return result;
}


BOOL
IsmClearApplyOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmClearApplyOnObjectId (objectId);
    }

    return result;
}


BOOL
IsmClearAbandonObjectIdOnCollision (
    IN      MIG_OBJECTID ObjectId
    )
{
    BOOL result;

    if (!IsmIsObjectIdAbandonedOnCollision (ObjectId)) {
        return TRUE;
    }

    result = pClearAttributeOnObjectId (ObjectId, g_AbandonedAttributeId, FALSE);

    return result;
}


BOOL
IsmClearAbandonObjectOnCollision (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmClearAbandonObjectIdOnCollision (objectId);
    }

    return result;
}


BOOL
IsmClearNonCriticalFlagOnObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    if (!IsmIsNonCriticalObjectId (ObjectId)) {
        return TRUE;
    }

    return pClearAttributeOnObjectId (ObjectId, g_NonCriticalAttributeId, FALSE);
}


BOOL
IsmClearNonCriticalFlagOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmClearNonCriticalFlagOnObjectId (objectId);
    }

    return result;
}


BOOL
pIsAttributeSetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    return MemDbTestDoubleLinkageByKeyHandle (
                ObjectId,
                AttributeId,
                ATTRIBUTE_INDEX
                );
}


BOOL
pQueryAttributeGroup (
    IN      KEYHANDLE AttributeId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    return pIsAttributeSetOnObjectId (
                (MIG_OBJECTID) Arg,
                (MIG_ATTRIBUTEID) AttributeId
                );
}


BOOL
IsmIsAttributeSetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    RECURSERETURN rc;

    //
    // If AttributeId is a group, query all properties in the group
    //

    rc = RecurseForGroupItems (
                AttributeId,
                pQueryAttributeGroup,
                (ULONG_PTR) ObjectId,
                TRUE,
                TRUE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pIsAttributeSetOnObjectId (ObjectId, AttributeId);
}


BOOL
IsmIsAttributeSetOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmIsAttributeSetOnObjectId (objectId, AttributeId);
    }

    return FALSE;
}


BOOL
IsmIsPersistentObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    return pIsAttributeSetOnObjectId (ObjectId, g_PersistentAttributeId);
}


BOOL
IsmIsPersistentObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmIsPersistentObjectId (objectId);
    }

    return FALSE;
}


BOOL
IsmIsApplyObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    return pIsAttributeSetOnObjectId (ObjectId, g_ApplyAttributeId);
}


BOOL
IsmIsApplyObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmIsApplyObjectId (objectId);
    }

    return FALSE;
}


BOOL
IsmIsObjectIdAbandonedOnCollision (
    IN      MIG_OBJECTID ObjectId
    )
{
    return pIsAttributeSetOnObjectId (ObjectId, g_AbandonedAttributeId);
}


BOOL
IsmIsObjectAbandonedOnCollision (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmIsObjectIdAbandonedOnCollision (objectId);
    }

    return FALSE;
}


BOOL
IsmIsNonCriticalObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    return pIsAttributeSetOnObjectId (ObjectId, g_NonCriticalAttributeId);
}


BOOL
IsmIsNonCriticalObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmIsNonCriticalObjectId (objectId);
    }

    return FALSE;
}


BOOL
IsmEnumFirstObjectAttributeById (
    OUT     PMIG_OBJECTATTRIBUTE_ENUM EnumPtr,
    IN      MIG_OBJECTID ObjectId
    )
{
    POBJECTATTRIBUTE_HANDLE handle;
    BOOL result = TRUE;

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTATTRIBUTE_ENUM));

    EnumPtr->Handle = MemAllocZeroed (sizeof (OBJECTATTRIBUTE_HANDLE));
    handle = (POBJECTATTRIBUTE_HANDLE) EnumPtr->Handle;

    handle->LinkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                ObjectId,
                                ATTRIBUTE_INDEX,
                                &handle->Count
                                );

    handle->Count = handle->Count / SIZEOF(KEYHANDLE);

    if (!handle->LinkageList || !handle->Count) {
        IsmAbortObjectAttributeEnum (EnumPtr);
        result = FALSE;
    } else {

        result = IsmEnumNextObjectAttribute (EnumPtr);
    }

    return result;
}


BOOL
IsmEnumFirstObjectAttribute (
    OUT     PMIG_OBJECTATTRIBUTE_ENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmEnumFirstObjectAttributeById (EnumPtr, objectId);
    }

    return FALSE;
}


BOOL
IsmEnumNextObjectAttribute (
    IN OUT  PMIG_OBJECTATTRIBUTE_ENUM EnumPtr
    )
{
    POBJECTATTRIBUTE_HANDLE handle;
    BOOL result = FALSE;
    BOOL mine;

    handle = (POBJECTATTRIBUTE_HANDLE) EnumPtr->Handle;
    if (!handle) {
        return FALSE;
    }

    do {

        MYASSERT (!result);

        //
        // Check if we hit the end
        //

        if (handle->Index >= handle->Count) {
            break;
        }

        //
        // Return the next attribute
        //

        EnumPtr->AttributeId = (MIG_ATTRIBUTEID) handle->LinkageList[handle->Index];
        handle->Index++;

        result = IsmGetAttributeName (
                        EnumPtr->AttributeId,
                        NULL,
                        0,
                        &EnumPtr->Private,
                        &mine,
                        NULL
                        );

        //
        // Continue when the attribute is not owned by the caller
        //

        if (result && EnumPtr->Private && !mine) {
            result = FALSE;
        }

        //
        // Continue when we are talking about reserved persistent/apply attribute
        //
        if (result) {
            if (EnumPtr->AttributeId == g_PersistentAttributeId ||
                EnumPtr->AttributeId == g_ApplyAttributeId ||
                EnumPtr->AttributeId == g_AbandonedAttributeId ||
                EnumPtr->AttributeId == g_NonCriticalAttributeId
                ) {
                result = FALSE;
            }
        }

    } while (!result);

    if (!result) {
        IsmAbortObjectAttributeEnum (EnumPtr);
    }

    return result;
}


VOID
IsmAbortObjectAttributeEnum (
    IN OUT  PMIG_OBJECTATTRIBUTE_ENUM EnumPtr
    )
{
    POBJECTATTRIBUTE_HANDLE handle;

    if (EnumPtr->Handle) {

        handle = (POBJECTATTRIBUTE_HANDLE) EnumPtr->Handle;

        if (handle->LinkageList) {
            MemDbReleaseMemory (handle->LinkageList);
            INVALID_POINTER (handle->LinkageList);
        }

        MemFree (g_hHeap, 0, EnumPtr->Handle);
        INVALID_POINTER (EnumPtr->Handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTATTRIBUTE_ENUM));
}


BOOL
IsmEnumFirstObjectWithAttribute (
    OUT     PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    POBJECTWITHATTRIBUTE_HANDLE handle;
    BOOL result = FALSE;

    __try {
        if (!IsItemId ((KEYHANDLE) AttributeId)) {
            DEBUGMSG ((DBG_ERROR, "IsmEnumFirstObjectWithAttribute: invalid attribute id"));
            __leave;
        }

        ZeroMemory (EnumPtr, sizeof (MIG_OBJECTWITHATTRIBUTE_ENUM));

        EnumPtr->Handle = MemAllocZeroed (sizeof (OBJECTWITHATTRIBUTE_HANDLE));
        handle = (POBJECTWITHATTRIBUTE_HANDLE) EnumPtr->Handle;

        handle->LinkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                    AttributeId,
                                    ATTRIBUTE_INDEX,
                                    &handle->Count
                                    );

        handle->Count = handle->Count / SIZEOF(KEYHANDLE);

        if (!handle->LinkageList || !handle->Count) {
            IsmAbortObjectWithAttributeEnum (EnumPtr);
            __leave;
        } else {
            result = IsmEnumNextObjectWithAttribute (EnumPtr);
        }
    }
    __finally {
    }

    return result;
}


BOOL
IsmEnumNextObjectWithAttribute (
    IN OUT  PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    POBJECTWITHATTRIBUTE_HANDLE handle;
    PCTSTR objectPath = NULL;
    BOOL result = FALSE;
    PTSTR p;

    __try {
        handle = (POBJECTWITHATTRIBUTE_HANDLE) EnumPtr->Handle;
        if (!handle) {
            __leave;
        }

        do {

            //
            // Check if enum is done
            //

            if (handle->Index >= handle->Count) {
                break;
            }

            //
            // Get the next object id from the linkage list
            //

            EnumPtr->ObjectId = handle->LinkageList[handle->Index];
            handle->Index++;

            if (handle->ObjectFromMemdb) {
                MemDbReleaseMemory (handle->ObjectFromMemdb);
                INVALID_POINTER (handle->ObjectFromMemdb);
            }

            handle->ObjectFromMemdb = MemDbGetKeyFromHandle ((KEYHANDLE) EnumPtr->ObjectId, 0);

            if (!handle->ObjectFromMemdb) {
                MYASSERT (FALSE);   // this error shouldn't happen -- but don't give up
                continue;
            }

            //
            // Turn the object id into a name
            //

            p = _tcschr (handle->ObjectFromMemdb, TEXT('\\'));

            if (p) {
                result = TRUE;
                EnumPtr->ObjectName = _tcsinc (p);
                *p = 0;
                EnumPtr->ObjectTypeId = GetObjectTypeId (handle->ObjectFromMemdb);
            }
        } while (!result);
    }
    __finally {
    }

    if (!result) {
        IsmAbortObjectWithAttributeEnum (EnumPtr);
    }

    return result;
}


VOID
IsmAbortObjectWithAttributeEnum (
    IN      PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    POBJECTWITHATTRIBUTE_HANDLE handle;

    if (EnumPtr->Handle) {
        handle = (POBJECTWITHATTRIBUTE_HANDLE) EnumPtr->Handle;

        if (handle->ObjectFromMemdb) {
            MemDbReleaseMemory (handle->ObjectFromMemdb);
            INVALID_POINTER (handle->ObjectFromMemdb);
        }

        if (handle->LinkageList) {
            MemDbReleaseMemory (handle->LinkageList);
            INVALID_POINTER (handle->LinkageList);
        }

        FreeAlloc (EnumPtr->Handle);
        INVALID_POINTER (EnumPtr->Handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTWITHATTRIBUTE_ENUM));
}


BOOL
IsmEnumFirstPersistentObject (
    OUT     PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    return IsmEnumFirstObjectWithAttribute (EnumPtr, g_PersistentAttributeId);
}


BOOL
IsmEnumNextPersistentObject (
    IN OUT  PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    return IsmEnumNextObjectWithAttribute (EnumPtr);
}


VOID
IsmAbortPersistentObjectEnum (
    IN      PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    IsmAbortObjectWithAttributeEnum (EnumPtr);
}


BOOL
IsmEnumFirstApplyObject (
    OUT     PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    return IsmEnumFirstObjectWithAttribute (EnumPtr, g_ApplyAttributeId);
}


BOOL
IsmEnumNextApplyObject (
    IN OUT  PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    return IsmEnumNextObjectWithAttribute (EnumPtr);
}


VOID
IsmAbortApplyObjectEnum (
    IN      PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    IsmAbortObjectWithAttributeEnum (EnumPtr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\env.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    env.c

Abstract:

    Implements ISM environment variable support

Author:

    Jim Schmidt (jimschm) 01-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_ISMENV          "IsmEnv"

//
// Strings
//

#define S_MEMDB_ENV_ROOT_SRC        TEXT("EnvSrc")
#define S_MEMDB_ENV_ROOT_DEST       TEXT("EnvDest")

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    ENVENTRY_TYPE Type;
    UINT DataSize;
    BYTE Data[];
} ENVIRONMENT_ENTRY, *PENVIRONMENT_ENTRY;

//
// Globals
//

GROWBUFFER g_AppendBuffer = INIT_GROWBUFFER;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

BOOL
pGetEnvironmentValue (
    IN      UINT Platform,
    IN OUT  KEYHANDLE *KeyHandle,       OPTIONAL
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PBYTE Data,                 OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded,       OPTIONAL
    OUT     PENVENTRY_TYPE DataType     OPTIONAL
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
InitializeEnv (
    VOID
    )
{
    return TRUE;
}

VOID
TerminateEnv (
    VOID
    )
{
    GbFree (&g_AppendBuffer);
}

BOOL
EnvEnumerateFirstEntry (
    OUT     PENV_ENTRY_ENUM EnvEntryEnum,
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Pattern
    )
{
    PCTSTR pattern = NULL;
    PENVIRONMENT_ENTRY envEntry;
    UINT dataSize;
    BOOL result = FALSE;

    if (Platform == PLATFORM_CURRENT) {
        Platform = g_IsmCurrentPlatform;
    }
    if (Platform == PLATFORM_SOURCE) {
        pattern = JoinPaths (S_MEMDB_ENV_ROOT_SRC, Pattern);
    } else {
        pattern = JoinPaths (S_MEMDB_ENV_ROOT_DEST, Pattern);
    }

    ZeroMemory (EnvEntryEnum, sizeof (PENV_ENTRY_ENUM));

    EnvEntryEnum->Platform = Platform;

    if (MemDbEnumFirst (&EnvEntryEnum->Handle, pattern, ENUMFLAG_NORMAL, 1, ENUMLEVEL_ALLLEVELS)) {

        envEntry = (PENVIRONMENT_ENTRY) MemDbGetUnorderedBlob (EnvEntryEnum->Handle.FullKeyName, 0, NULL);
        EnvEntryEnum->EnvEntryType = envEntry->Type;
        EnvEntryEnum->EnvEntryGroup = DuplicatePathString (EnvEntryEnum->Handle.KeyName, 0);
        EnvEntryEnum->EnvEntryName = _tcschr (EnvEntryEnum->EnvEntryGroup, TEXT('\\'));

        if (EnvEntryEnum->EnvEntryName) {
            *((PTSTR)(EnvEntryEnum->EnvEntryName)) = 0;
            EnvEntryEnum->EnvEntryName ++;
        } else {
            EnvEntryEnum->EnvEntryName = EnvEntryEnum->EnvEntryGroup;
            EnvEntryEnum->EnvEntryGroup = NULL;
        }

#ifdef UNICODE
        EnvEntryEnum->EnvEntryDataSize = envEntry->DataSize;
        if (envEntry->DataSize) {
            EnvEntryEnum->EnvEntryData = IsmGetMemory (envEntry->DataSize);
            CopyMemory (EnvEntryEnum->EnvEntryData, envEntry->Data, envEntry->DataSize);
        } else {
            EnvEntryEnum->EnvEntryData = NULL;
        }
#else
        if (envEntry->Type == ENVENTRY_STRING) {
            dataSize = SizeOfStringA ((PCSTR)envEntry->Data) * 2;
            EnvEntryEnum->EnvEntryData = IsmGetMemory (dataSize);
            ZeroMemory (EnvEntryEnum->EnvEntryData, dataSize);
            DirectDbcsToUnicodeN (
                (PWSTR)EnvEntryEnum->EnvEntryData,
                (PSTR)envEntry->Data,
                SizeOfStringA ((PCSTR)envEntry->Data)
                );
            EnvEntryEnum->EnvEntryDataSize = SizeOfStringW ((PWSTR)EnvEntryEnum->EnvEntryData);
        } else if (envEntry->Type == ENVENTRY_MULTISZ) {
            dataSize = SizeOfMultiSzA ((PCSTR)envEntry->Data) * 2;
            EnvEntryEnum->EnvEntryData = IsmGetMemory (dataSize);
            ZeroMemory (EnvEntryEnum->EnvEntryData, dataSize);
            DirectDbcsToUnicodeN (
                (PWSTR)EnvEntryEnum->EnvEntryData,
                (PSTR)envEntry->Data,
                SizeOfMultiSzA ((PCSTR)envEntry->Data)
                );
            EnvEntryEnum->EnvEntryDataSize = SizeOfMultiSzW ((PWSTR)EnvEntryEnum->EnvEntryData);
        } else {
            EnvEntryEnum->EnvEntryDataSize = envEntry->DataSize;
            if (envEntry->DataSize) {
                EnvEntryEnum->EnvEntryData = IsmGetMemory (envEntry->DataSize);
                CopyMemory (EnvEntryEnum->EnvEntryData, envEntry->Data, envEntry->DataSize);
            } else {
                EnvEntryEnum->EnvEntryData = NULL;
            }
        }
#endif

        MemDbReleaseMemory (envEntry);
        result = TRUE;
    }

    FreePathString (pattern);
    return result;
}

BOOL
EnvEnumerateNextEntry (
    IN OUT  PENV_ENTRY_ENUM EnvEntryEnum
    )
{
    PENVIRONMENT_ENTRY envEntry;
    UINT dataSize;
    BOOL result = FALSE;

    if (EnvEntryEnum->EnvEntryData) {
        IsmReleaseMemory (EnvEntryEnum->EnvEntryData);
        EnvEntryEnum->EnvEntryData = NULL;
    }
    if (EnvEntryEnum->EnvEntryGroup) {
        FreePathString (EnvEntryEnum->EnvEntryGroup);
        EnvEntryEnum->EnvEntryGroup = NULL;
        EnvEntryEnum->EnvEntryName = NULL;
    }
    if (EnvEntryEnum->EnvEntryName) {
        FreePathString (EnvEntryEnum->EnvEntryName);
        EnvEntryEnum->EnvEntryName = NULL;
    }
    if (MemDbEnumNext (&EnvEntryEnum->Handle)) {

        envEntry = (PENVIRONMENT_ENTRY) MemDbGetUnorderedBlob (EnvEntryEnum->Handle.FullKeyName, 0, NULL);
        EnvEntryEnum->EnvEntryType = envEntry->Type;
        EnvEntryEnum->EnvEntryGroup = DuplicatePathString (EnvEntryEnum->Handle.KeyName, 0);
        EnvEntryEnum->EnvEntryName = _tcschr (EnvEntryEnum->EnvEntryGroup, TEXT('\\'));

        if (EnvEntryEnum->EnvEntryName) {
            *((PTSTR)(EnvEntryEnum->EnvEntryName)) = 0;
            EnvEntryEnum->EnvEntryName ++;
        } else {
            EnvEntryEnum->EnvEntryName = EnvEntryEnum->EnvEntryGroup;
            EnvEntryEnum->EnvEntryGroup = NULL;
        }

#ifdef UNICODE
        EnvEntryEnum->EnvEntryDataSize = envEntry->DataSize;
        if (envEntry->DataSize) {
            EnvEntryEnum->EnvEntryData = IsmGetMemory (envEntry->DataSize);
            CopyMemory (EnvEntryEnum->EnvEntryData, envEntry->Data, envEntry->DataSize);
        } else {
            EnvEntryEnum->EnvEntryData = NULL;
        }
#else
        if (envEntry->Type == ENVENTRY_STRING) {
            dataSize = SizeOfStringW ((PCWSTR)envEntry->Data) * 2;
            EnvEntryEnum->EnvEntryData = IsmGetMemory (dataSize);
            ZeroMemory (EnvEntryEnum->EnvEntryData, dataSize);
            DirectUnicodeToDbcsN (
                (PSTR)EnvEntryEnum->EnvEntryData,
                (PWSTR)envEntry->Data,
                SizeOfStringW ((PCWSTR)envEntry->Data)
                );
            EnvEntryEnum->EnvEntryDataSize = SizeOfStringW ((PWSTR)EnvEntryEnum->EnvEntryData);
        } else if (envEntry->Type == ENVENTRY_MULTISZ) {
            dataSize = SizeOfMultiSzW ((PCWSTR)envEntry->Data) * 2;
            EnvEntryEnum->EnvEntryData = IsmGetMemory (dataSize);
            ZeroMemory (EnvEntryEnum->EnvEntryData, dataSize);
            DirectUnicodeToDbcsN (
                (PSTR)EnvEntryEnum->EnvEntryData,
                (PWSTR)envEntry->Data,
                SizeOfMultiSzW ((PCWSTR)envEntry->Data)
                );
            EnvEntryEnum->EnvEntryDataSize = SizeOfMultiSzW ((PWSTR)EnvEntryEnum->EnvEntryData);
        } else {
            EnvEntryEnum->EnvEntryDataSize = envEntry->DataSize;
            if (envEntry->DataSize) {
                EnvEntryEnum->EnvEntryData = IsmGetMemory (envEntry->DataSize);
                CopyMemory (EnvEntryEnum->EnvEntryData, envEntry->Data, envEntry->DataSize);
            } else {
                EnvEntryEnum->EnvEntryData = NULL;
            }
        }
#endif

        MemDbReleaseMemory (envEntry);
        result = TRUE;
    } else {
        MemDbAbortEnum (&EnvEntryEnum->Handle);
    }

    return result;
}

VOID
AbortEnvEnumerateEntry (
    IN OUT  PENV_ENTRY_ENUM EnvEntryEnum
    )
{
    if (EnvEntryEnum->EnvEntryData) {
        IsmReleaseMemory (EnvEntryEnum->EnvEntryData);
        EnvEntryEnum->EnvEntryData = NULL;
    }
    if (EnvEntryEnum->EnvEntryGroup) {
        FreePathString (EnvEntryEnum->EnvEntryGroup);
        EnvEntryEnum->EnvEntryGroup = NULL;
        EnvEntryEnum->EnvEntryName = NULL;
    }
    if (EnvEntryEnum->EnvEntryName) {
        FreePathString (EnvEntryEnum->EnvEntryName);
        EnvEntryEnum->EnvEntryName = NULL;
    }
    MemDbAbortEnum (&EnvEntryEnum->Handle);

    ZeroMemory (EnvEntryEnum, sizeof (PENV_ENTRY_ENUM));
}

VOID
EnvInvalidateCallbacks (
    VOID
    )
{
    GROWBUFFER envBuff = INIT_GROWBUFFER;
    PCTSTR pattern = NULL;
    MEMDB_ENUM e;
    MULTISZ_ENUM se;
    BOOL toDelete = FALSE;
    PENVIRONMENT_ENTRY envEntry;

    pattern = JoinPaths (S_MEMDB_ENV_ROOT_SRC, TEXT("*"));

    if (MemDbEnumFirst (&e, pattern, ENUMFLAG_NORMAL, 0, ENUMLEVEL_ALLLEVELS)) {
        do {
            envEntry = (PENVIRONMENT_ENTRY) MemDbGetUnorderedBlob (e.FullKeyName, 0, NULL);
            if (envEntry->Type == ENVENTRY_CALLBACK) {
                GbMultiSzAppend (&envBuff, e.FullKeyName);
                toDelete = TRUE;
            }
            MemDbReleaseMemory (envEntry);
        } while (MemDbEnumNext (&e));
        MemDbAbortEnum (&e);
    }
    if (toDelete && EnumFirstMultiSz (&se, (PCTSTR) envBuff.Buf)) {
        do {
            MemDbDeleteKey (se.CurrentString);
        } while (EnumNextMultiSz (&se));
    }
    FreePathString (pattern);
}


VOID
pEnvSave (
    IN      PCTSTR Pattern,
    IN OUT  PGROWLIST GrowList
    )
{
    MEMDB_ENUM e;
    PENVIRONMENT_ENTRY envEntry;
    UINT strSize;
    PBYTE listStruct;

    if (MemDbEnumFirst (&e, Pattern, ENUMFLAG_NORMAL, 0, ENUMLEVEL_ALLLEVELS)) {
        do {
            envEntry = (PENVIRONMENT_ENTRY) MemDbGetUnorderedBlob (e.FullKeyName, 0, NULL);

            strSize = SizeOfString (e.FullKeyName);
            listStruct = PmGetMemory (g_IsmPool, strSize + sizeof (ENVIRONMENT_ENTRY) + envEntry->DataSize);

            CopyMemory (listStruct, e.FullKeyName, strSize);
            CopyMemory (listStruct + strSize, envEntry, sizeof (ENVIRONMENT_ENTRY) + envEntry->DataSize);

            GlAppend (GrowList, listStruct, strSize + sizeof (ENVIRONMENT_ENTRY) + envEntry->DataSize);
            PmReleaseMemory (g_IsmPool, listStruct);
            MemDbReleaseMemory (envEntry);

        } while (MemDbEnumNext (&e));
    }
}


BOOL
EnvSaveEnvironment (
    IN OUT  PGROWLIST GrowList
    )
{
    pEnvSave (S_MEMDB_ENV_ROOT_SRC TEXT("\\*"), GrowList);
    pEnvSave (S_MEMDB_ENV_ROOT_DEST TEXT("\\*"), GrowList);

    return TRUE;
}


BOOL
EnvRestoreEnvironment (
    IN      PGROWLIST GrowList
    )
{
    UINT listSize, i;
    PBYTE listStruct;
    PCTSTR memdbName;
    PENVIRONMENT_ENTRY envEntry;

    listSize = GlGetSize (GrowList);

    for (i = 0; i < listSize; i ++) {

        listStruct = GlGetItem (GrowList, i);
        memdbName = (PCTSTR) listStruct;

        if (!MemDbTestKey (memdbName)) {
            envEntry = (PENVIRONMENT_ENTRY) (GetEndOfString ((PCTSTR) listStruct) + 1);
            if (!MemDbSetUnorderedBlob (
                    memdbName,
                    0,
                    (PBYTE) envEntry,
                    sizeof (ENVIRONMENT_ENTRY) + envEntry->DataSize
                    )) {
                EngineError ();
            }
        }
    }

    return TRUE;
}

BOOL
IsmSetEnvironmentValue (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PENVENTRY_STRUCT VariableData   OPTIONAL
    )
{
    PCTSTR memdbName = NULL;
    BOOL result = FALSE;
    KEYHANDLE kh;
    PENVIRONMENT_ENTRY envEntry = NULL;
    UINT dataSize;
    PCVOID dataPtr;
    DATAHANDLE dh;
    BOOL destPlatform = FALSE;
#ifndef UNICODE
    PWSTR unicodeData = NULL;
#endif

    if ((Platform != PLATFORM_SOURCE) &&
        (Platform != PLATFORM_DESTINATION)
        ) {
        DEBUGMSG ((DBG_ERROR, "Environment variable specified with no platform."));
        return FALSE;
    }

    destPlatform = (Platform == PLATFORM_DESTINATION);

    __try {
        //
        // Validate arguments
        //

        if (!VariableName || !(*VariableName)) {
            DEBUGMSG ((DBG_ERROR, "Invalid variable name"));
            SetLastError (ERROR_INVALID_PARAMETER);
            __leave;
        }

        //
        // Build decorated name by joining current group with variable name,
        // then build memdb key
        //

        memdbName = JoinPathsInPoolEx ((
                        NULL,
                        destPlatform?S_MEMDB_ENV_ROOT_DEST:S_MEMDB_ENV_ROOT_SRC,
                        Group?Group:VariableName,
                        Group?VariableName:NULL,
                        NULL
                        ));

        kh = MemDbSetKey (memdbName);
        if (!kh) {
            DEBUGMSG ((DBG_ERROR, "Error while adding environment variable into database"));
            EngineError ();
            __leave;
        }
        MemDbDeleteUnorderedBlobByKeyHandle (kh, 0);

        if (VariableData->Type == ENVENTRY_STRING) {
            if (VariableData->EnvString == NULL) {
                dataSize = sizeof (TCHAR);
                dataPtr = TEXT("");
            } else {
#ifdef UNICODE
                dataSize = SizeOfStringW (VariableData->EnvString);
                dataPtr = VariableData->EnvString;
#else
                dataSize = SizeOfStringA (VariableData->EnvString) * 2;
                unicodeData = IsmGetMemory (dataSize);
                if (unicodeData) {
                    ZeroMemory (unicodeData, dataSize);
                    DirectDbcsToUnicodeN (
                        unicodeData,
                        VariableData->EnvString,
                        SizeOfStringA (VariableData->EnvString)
                        );
                    dataSize = SizeOfStringW (unicodeData);
                    dataPtr = unicodeData;
                } else {
                    dataSize = sizeof (WCHAR);
                    dataPtr = L"";
                }
#endif
            }
        } else if (VariableData->Type == ENVENTRY_MULTISZ) {
            if (VariableData->MultiSz == NULL) {
                dataSize = sizeof (TCHAR);
                dataPtr = TEXT("");
            } else {
#ifdef UNICODE
                dataSize = SizeOfMultiSzW (VariableData->MultiSz);
                dataPtr = VariableData->MultiSz;
#else
                dataSize = SizeOfMultiSzA (VariableData->MultiSz) * 2;
                unicodeData = IsmGetMemory (dataSize);
                if (unicodeData) {
                    ZeroMemory (unicodeData, dataSize);
                    DirectDbcsToUnicodeN (
                        unicodeData,
                        VariableData->MultiSz,
                        SizeOfMultiSzA (VariableData->MultiSz)
                        );
                    dataSize = SizeOfMultiSzW (unicodeData);
                    dataPtr = unicodeData;
                } else {
                    dataSize = sizeof (WCHAR);
                    dataPtr = L"";
                }
#endif
            }
        } else if (VariableData->Type == ENVENTRY_CALLBACK) {
            dataSize = sizeof (PENVENTRYCALLBACK);
            dataPtr = (&VariableData->EnvCallback);
        } else if (VariableData->Type == ENVENTRY_BINARY) {
            dataSize = VariableData->EnvBinaryDataSize;
            dataPtr = VariableData->EnvBinaryData;
        } else {
            DEBUGMSG ((DBG_ERROR, "Invalid variable data type"));
            SetLastError (ERROR_INVALID_PARAMETER);
            __leave;
        }

        envEntry = (PENVIRONMENT_ENTRY) MemAllocUninit (sizeof (ENVIRONMENT_ENTRY) + dataSize);
        envEntry->Type = VariableData->Type;
        envEntry->DataSize = dataSize;
        if (envEntry->DataSize) {
            CopyMemory (envEntry->Data, dataPtr, envEntry->DataSize);
        }

        dh = MemDbSetUnorderedBlob (memdbName, 0, (PBYTE) envEntry, sizeof (ENVIRONMENT_ENTRY) + envEntry->DataSize);

        result = (dh != 0);

        if (!result) {
            EngineError ();
        }
    }
    __finally {
        if (memdbName) {
            FreePathString (memdbName);
            memdbName = NULL;
        }

        if (envEntry) {
            FreeAlloc (envEntry);
            envEntry = NULL;
        }

#ifndef UNICODE
        if (unicodeData) {
            IsmReleaseMemory (unicodeData);
            unicodeData = NULL;
        }
#endif
    }

    return result;
}

BOOL
IsmSetEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    )
{
    ENVENTRY_STRUCT envEntry;

    envEntry.Type = ENVENTRY_STRING;
    envEntry.EnvString = VariableValue;
    return IsmSetEnvironmentValue (
                Platform,
                Group,
                VariableName,
                &envEntry
                );
}

BOOL
IsmSetEnvironmentMultiSz (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    )
{
    ENVENTRY_STRUCT envEntry;

    envEntry.Type = ENVENTRY_MULTISZ;
    envEntry.MultiSz = VariableValue;
    return IsmSetEnvironmentValue (
                Platform,
                Group,
                VariableName,
                &envEntry
                );
}

BOOL
IsmAppendEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    )
{
    ENVENTRY_STRUCT envEntry;
    ENVENTRY_TYPE type;
    KEYHANDLE kh = 0;
    UINT multiSzNeeded;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            VariableName,
            NULL,
            0,
            &multiSzNeeded,
            &type
            )) {
        if (type != ENVENTRY_MULTISZ) {
            return FALSE;
        }
        g_AppendBuffer.End = 0;
        GbGrow (&g_AppendBuffer, multiSzNeeded);
        if (pGetEnvironmentValue (
                Platform,
                &kh,
                Group,
                VariableName,
                g_AppendBuffer.Buf,
                multiSzNeeded,
                NULL,
                NULL
                )) {
            if (g_AppendBuffer.End) {
                g_AppendBuffer.End -= sizeof (TCHAR);
            }
            GbMultiSzAppend (&g_AppendBuffer, VariableValue);
            envEntry.Type = ENVENTRY_MULTISZ;
            envEntry.MultiSz = (PCTSTR) g_AppendBuffer.Buf;
            return IsmSetEnvironmentValue (
                        Platform,
                        Group,
                        VariableName,
                        &envEntry
                        );
        }
    } else {
        g_AppendBuffer.End = 0;
        GbMultiSzAppend (&g_AppendBuffer, VariableValue);
        envEntry.Type = ENVENTRY_MULTISZ;
        envEntry.MultiSz = (PCTSTR) g_AppendBuffer.Buf;
        return IsmSetEnvironmentValue (
                    Platform,
                    Group,
                    VariableName,
                    &envEntry
                    );
    }
    return FALSE;
}

BOOL
IsmAppendEnvironmentMultiSz (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    )
{
    ENVENTRY_STRUCT envEntry;
    ENVENTRY_TYPE type;
    KEYHANDLE kh = 0;
    UINT multiSzNeeded;
    MULTISZ_ENUM multiSzEnum;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            VariableName,
            NULL,
            0,
            &multiSzNeeded,
            &type
            )) {
        if (type != ENVENTRY_MULTISZ) {
            return FALSE;
        }
        g_AppendBuffer.End = 0;
        GbGrow (&g_AppendBuffer, multiSzNeeded);
        if (pGetEnvironmentValue (
                Platform,
                &kh,
                Group,
                VariableName,
                g_AppendBuffer.Buf,
                multiSzNeeded,
                NULL,
                NULL
                )) {
            if (g_AppendBuffer.End) {
                g_AppendBuffer.End -= sizeof (TCHAR);
            }
            if (EnumFirstMultiSz (&multiSzEnum, VariableValue)) {
                do {
                    GbMultiSzAppend (&g_AppendBuffer, multiSzEnum.CurrentString);
                } while (EnumNextMultiSz (&multiSzEnum));
            }
            envEntry.Type = ENVENTRY_MULTISZ;
            envEntry.MultiSz = (PCTSTR) g_AppendBuffer.Buf;
            return IsmSetEnvironmentValue (
                        Platform,
                        Group,
                        VariableName,
                        &envEntry
                        );
        }
    } else {
        envEntry.Type = ENVENTRY_MULTISZ;
        envEntry.MultiSz = VariableValue;
        return IsmSetEnvironmentValue (
                    Platform,
                    Group,
                    VariableName,
                    &envEntry
                    );
    }
    return FALSE;
}

BOOL
IsmSetEnvironmentCallback (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PENVENTRYCALLBACK VariableCallback
    )
{
    ENVENTRY_STRUCT envEntry;

    envEntry.Type = ENVENTRY_CALLBACK;
    envEntry.EnvCallback = VariableCallback;
    return IsmSetEnvironmentValue (
                Platform,
                Group,
                VariableName,
                &envEntry
                );
}

BOOL
IsmSetEnvironmentData (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCBYTE VariableData,
    IN      UINT VariableDataSize
    )
{
    ENVENTRY_STRUCT envEntry;

    envEntry.Type = ENVENTRY_BINARY;
    envEntry.EnvBinaryData = VariableData;
    envEntry.EnvBinaryDataSize = VariableDataSize;
    return IsmSetEnvironmentValue (
                Platform,
                Group,
                VariableName,
                &envEntry
                );
}

BOOL
IsmSetEnvironmentFlag (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName
    )
{
    ENVENTRY_STRUCT envEntry;

    envEntry.Type = ENVENTRY_BINARY;
    envEntry.EnvBinaryData = NULL;
    envEntry.EnvBinaryDataSize = 0;
    return IsmSetEnvironmentValue (
                Platform,
                Group,
                VariableName,
                &envEntry
                );
}

BOOL
pGetEnvironmentValue (
    IN      MIG_PLATFORMTYPEID Platform,
    IN OUT  KEYHANDLE *KeyHandle,       OPTIONAL
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PBYTE Data,                 OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded,       OPTIONAL
    OUT     PENVENTRY_TYPE DataType     OPTIONAL
    )
{
    PCTSTR memdbName = NULL;
    BOOL result = FALSE;
    KEYHANDLE kh = 0;
    PENVIRONMENT_ENTRY envEntry;
    UINT sizeNeeded;
    GROWBUFFER tempBuffer = INIT_GROWBUFFER;
    BOOL destPlatform = FALSE;
    UINT dataSize;
#ifndef UNICODE
    PSTR ansiData = NULL;
#endif

    if ((Platform != PLATFORM_SOURCE) &&
        (Platform != PLATFORM_DESTINATION)
        ) {
        DEBUGMSG ((DBG_ERROR, "Environment variable specified with no platform."));
        return FALSE;
    }

    destPlatform = (Platform == PLATFORM_DESTINATION);

    __try {
        //
        // IsmGetEnvironmentValue will call this worker with KeyHandle set to NULL, but
        // IsmGetEnvironmentString will call this worker with a valid KeyHandle. This
        // is done to eliminate double-validation and double-lookup of the memdb key.
        //

        if (!KeyHandle || !(*KeyHandle)) {
            //
            // Validate arguments
            //

            if (!VariableName && !(*VariableName)) {
                DEBUGMSG ((DBG_ERROR, "Can't get value of invalid variable name"));
                SetLastError (ERROR_INVALID_PARAMETER);
                __leave;
            }

            memdbName = JoinPathsInPoolEx ((
                            NULL,
                            destPlatform?S_MEMDB_ENV_ROOT_DEST:S_MEMDB_ENV_ROOT_SRC,
                            Group?Group:VariableName,
                            Group?VariableName:NULL,
                            NULL
                            ));

            kh = MemDbGetHandleFromKey (memdbName);

            if (KeyHandle) {
                *KeyHandle = kh;
            }

        } else {
            kh = *KeyHandle;
        }

        //
        // If no variable exists, return FALSE
        //

        if (!kh) {
            SetLastError (ERROR_SUCCESS);
            __leave;
        }

        //
        // Otherwise get the binary data
        //

        envEntry = NULL;

        if (!MemDbGetUnorderedBlobByKeyHandleEx (kh, 0, &tempBuffer, &sizeNeeded)) {
            //
            // No variable exists, return FALSE
            //
            if (DataSizeNeeded) {
                *DataSizeNeeded = 0;
            }
            if (DataType) {
                *DataType = ENVENTRY_NONE;
            }
            SetLastError (ERROR_SUCCESS);
            __leave;
        }

        envEntry = (PENVIRONMENT_ENTRY) tempBuffer.Buf;

        if (DataType) {
            *DataType = envEntry->Type;
        }

#ifdef UNICODE
        if (DataSizeNeeded) {
            *DataSizeNeeded = envEntry->DataSize;
        }

        if (DataSize) {
            if (DataSize < envEntry->DataSize) {
                SetLastError (ERROR_INSUFFICIENT_BUFFER);
            } else {
                CopyMemory (Data, envEntry->Data, envEntry->DataSize);
            }
        }
#else
        if (envEntry->Type == ENVENTRY_STRING) {

            dataSize = SizeOfStringW ((PCWSTR)envEntry->Data);
            ansiData = IsmGetMemory (dataSize);
            if (ansiData) {
                ZeroMemory (ansiData, dataSize);
                DirectUnicodeToDbcsN (
                    ansiData,
                    (PWSTR)envEntry->Data,
                    SizeOfStringW ((PCWSTR)envEntry->Data)
                    );

                dataSize = SizeOfStringA (ansiData);

                if (DataSizeNeeded) {
                    *DataSizeNeeded = dataSize;
                }

                if (DataSize) {
                    if (DataSize < dataSize) {
                        SetLastError (ERROR_INSUFFICIENT_BUFFER);
                    } else {
                        CopyMemory (Data, ansiData, dataSize);
                    }
                }
                IsmReleaseMemory (ansiData);
                ansiData = NULL;
            }

        } else if (envEntry->Type == ENVENTRY_MULTISZ) {

            dataSize = SizeOfMultiSzW ((PCWSTR)envEntry->Data);
            ansiData = IsmGetMemory (dataSize);
            if (ansiData) {
                ZeroMemory (ansiData, dataSize);
                DirectUnicodeToDbcsN (
                    ansiData,
                    (PWSTR)envEntry->Data,
                    SizeOfMultiSzW ((PCWSTR)envEntry->Data)
                    );

                dataSize = SizeOfMultiSzA (ansiData);

                if (DataSizeNeeded) {
                    *DataSizeNeeded = dataSize;
                }

                if (DataSize) {
                    if (DataSize < dataSize) {
                        SetLastError (ERROR_INSUFFICIENT_BUFFER);
                    } else {
                        CopyMemory (Data, ansiData, dataSize);
                    }
                }
                IsmReleaseMemory (ansiData);
                ansiData = NULL;
            }

        } else {

            if (DataSizeNeeded) {
                *DataSizeNeeded = envEntry->DataSize;
            }

            if (DataSize) {
                if (DataSize < envEntry->DataSize) {
                    SetLastError (ERROR_INSUFFICIENT_BUFFER);
                } else {
                    CopyMemory (Data, envEntry->Data, envEntry->DataSize);
                }
            }
        }
#endif
        result = TRUE;
    }
    __finally {

        if (memdbName) {
            FreePathString (memdbName);
            memdbName = NULL;
        }

        GbFree (&tempBuffer);
    }

    return result;
}

BOOL
IsmGetEnvironmentValue (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PBYTE Data,                 OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded,       OPTIONAL
    OUT     PENVENTRY_TYPE DataType     OPTIONAL
    )
{
    return pGetEnvironmentValue (
                Platform,
                NULL,
                Group,
                VariableName,
                Data,
                DataSize,
                DataSizeNeeded,
                DataType
                );
}

BOOL
IsmGetEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PTSTR VariableValue,        OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded        OPTIONAL
    )
{
    KEYHANDLE kh = 0;
    ENVENTRY_TYPE type;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            VariableName,
            NULL,
            0,
            NULL,
            &type
            )) {
        if (type != ENVENTRY_STRING) {
            return FALSE;
        }
        if (pGetEnvironmentValue (
                Platform,
                &kh,
                Group,
                VariableName,
                (PBYTE) VariableValue,
                DataSize,
                DataSizeNeeded,
                NULL
                )) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
IsmGetEnvironmentMultiSz (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PTSTR VariableValue,        OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded        OPTIONAL
    )
{
    KEYHANDLE kh = 0;
    ENVENTRY_TYPE type;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            VariableName,
            NULL,
            0,
            NULL,
            &type
            )) {
        if (type != ENVENTRY_MULTISZ) {
            return FALSE;
        }
        if (pGetEnvironmentValue (
                Platform,
                &kh,
                Group,
                VariableName,
                (PBYTE) VariableValue,
                DataSize,
                DataSizeNeeded,
                NULL
                )) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
IsmGetEnvironmentCallback (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                           OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PENVENTRYCALLBACK *VariableCallback     OPTIONAL
    )
{
    KEYHANDLE kh = 0;
    ENVENTRY_TYPE type;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            VariableName,
            NULL,
            0,
            NULL,
            &type
            )) {
        if (type != ENVENTRY_CALLBACK) {
            return FALSE;
        }
        if (pGetEnvironmentValue (
                Platform,
                &kh,
                Group,
                VariableName,
                (PBYTE)VariableCallback,
                sizeof (PENVENTRYCALLBACK),
                NULL,
                NULL
                )) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
IsmGetEnvironmentData (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PBYTE VariableData,         OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded        OPTIONAL
    )
{
    KEYHANDLE kh = 0;
    ENVENTRY_TYPE type;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            VariableName,
            NULL,
            0,
            NULL,
            &type
            )) {
        if (type != ENVENTRY_BINARY) {
            return FALSE;
        }
        if (pGetEnvironmentValue (
                Platform,
                &kh,
                Group,
                VariableName,
                VariableData,
                DataSize,
                DataSizeNeeded,
                NULL
                )) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
IsmIsEnvironmentFlagSet (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName
    )
{
    KEYHANDLE kh = 0;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            VariableName,
            NULL,
            0,
            NULL,
            NULL
            )) {
        return TRUE;
    }
    return FALSE;
}

BOOL
IsmDeleteEnvironmentVariable (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName
    )
{
    BOOL result = FALSE;
    PCTSTR memdbName = NULL;
    BOOL destPlatform = FALSE;

    if ((Platform != PLATFORM_SOURCE) &&
        (Platform != PLATFORM_DESTINATION)
        ) {
        DEBUGMSG ((DBG_ERROR, "Environment variable specified with no platform."));
        return FALSE;
    }

    destPlatform = (Platform == PLATFORM_DESTINATION);

    __try {
        //
        // Validate arguments
        //

        if (!(*VariableName)) {
            DEBUGMSG ((DBG_ERROR, "Invalid variable name"));
            SetLastError (ERROR_INVALID_PARAMETER);
            __leave;
        }

        //
        // Build decorated name by joining current group with variable name,
        // then build memdb key
        //

        memdbName = JoinPathsInPoolEx ((
                        NULL,
                        destPlatform?S_MEMDB_ENV_ROOT_DEST:S_MEMDB_ENV_ROOT_SRC,
                        Group?Group:VariableName,
                        Group?VariableName:NULL,
                        NULL
                        ));

        //
        // Now delete the memdb key
        //

        result = MemDbDeleteKey (memdbName);
    }
    __finally {

        if (memdbName) {
            FreePathString (memdbName);
            memdbName = NULL;
        }
    }

    return result;
}

BOOL
pGetEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR EnvString,
    OUT     PTSTR EnvValue,             OPTIONAL
    IN      UINT EnvValueSize,
    OUT     PUINT EnvValueSizeNeeded,   OPTIONAL
    IN      PCTSTR EnvStringContext     OPTIONAL
    )
{
    KEYHANDLE kh = 0;
    ENVENTRY_TYPE type;
    PENVENTRYCALLBACK callback = NULL;
    TCHAR buffer[1024];
    UINT sizeNeeded;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            EnvString,
            (PBYTE) buffer,
            sizeof (buffer),
            &sizeNeeded,
            &type
            )) {
        if (type == ENVENTRY_STRING) {
            if (!EnvValue) {
                if (EnvValueSizeNeeded) {
                    *EnvValueSizeNeeded = sizeNeeded;
                }
                return TRUE;
            }
            if ((sizeNeeded <= sizeof (buffer)) && (sizeNeeded <= EnvValueSize)) {
                StringCopy (EnvValue, buffer);
                if (EnvValueSizeNeeded) {
                    *EnvValueSizeNeeded = sizeNeeded;
                }
                return TRUE;
            }
            return pGetEnvironmentValue (
                        Platform,
                        &kh,
                        Group,
                        EnvString,
                        (PBYTE)EnvValue,
                        EnvValueSize,
                        EnvValueSizeNeeded,
                        NULL
                        );
        } else if (type == ENVENTRY_CALLBACK) {
            if (sizeNeeded == sizeof (PENVENTRYCALLBACK)) {
                callback = (PENVENTRYCALLBACK) buffer;
                return callback (
                            EnvString,
                            EnvValue,
                            EnvValueSize,
                            EnvValueSizeNeeded,
                            EnvStringContext
                            );
            }
        }
        return FALSE;
    }
    return FALSE;
}

PCTSTR
TrackedIsmExpandEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR SrcString,
    IN      PCTSTR Context
            TRACKING_DEF
    )
{
    UINT ch;
    PTSTR strCopy;
    PTSTR srcString;
    PTSTR envBegin = NULL;
    PTSTR envStrBegin;
    PTSTR envEnd;
    CHARTYPE savedCh;
    BOOL envMode = FALSE;
    UINT strSize;
    UINT maxSize;
    GROWBUFFER envBuff = INIT_GROWBUFFER;
    PCTSTR result = NULL;

    TRACK_ENTER();

    strCopy = PmDuplicateString (g_IsmPool, SrcString);
    srcString = strCopy;

    while (*srcString) {
        ch = _tcsnextc (srcString);
        if (ch == TEXT('%')) {
            if (envMode) {
                envEnd = srcString;
                envStrBegin = _tcsinc (envBegin);
                savedCh = *envEnd;
                *envEnd = 0;
                maxSize = (UINT) ((envBuff.Size - envBuff.End) * sizeof (TCHAR));
                if (pGetEnvironmentString (Platform, Group, envStrBegin, (PTSTR) (envBuff.Buf + envBuff.End), maxSize, &strSize, Context)) {
                    if (maxSize < strSize) {
                        pGetEnvironmentString (Platform, Group, envStrBegin, (PTSTR) GbGrow (&envBuff, strSize), strSize, &strSize, Context);
                    } else {
                        envBuff.End += strSize;
                    }
                    if (strSize) {
                        //we know that the routine above also adds the terminating null character
                        //so we need to pull it out.
                        envBuff.End -= sizeof (TCHAR);
                    }
                    *envEnd = (TCHAR) savedCh;
                } else {
                    *envEnd = (TCHAR) savedCh;
                    envEnd = _tcsinc (envEnd);
                    strSize = (UINT) ((envEnd - envBegin) * sizeof (TCHAR));
                    CopyMemory (GbGrow (&envBuff, strSize), envBegin, strSize);
                }
                envMode = FALSE;
            } else {
                envBegin = srcString;
                envMode = TRUE;
            }
            srcString = _tcsinc (srcString);
        } else {
            envEnd = _tcsinc (srcString);
            if (!envMode) {
                strSize = (UINT) ((envEnd - srcString) * sizeof (TCHAR));
                CopyMemory (GbGrow (&envBuff, strSize), srcString, strSize);
            }
            srcString = envEnd;
        }
    }
    if (envMode && envBegin) {
        strSize = (UINT) ((srcString - envBegin) * sizeof (TCHAR));
        CopyMemory (GbGrow (&envBuff, strSize), envBegin, strSize);
    }

    CopyMemory (GbGrow (&envBuff, sizeof (TCHAR)), srcString, sizeof (TCHAR));

    PmReleaseMemory (g_IsmPool, strCopy);

    result = PmDuplicateString (g_IsmPool, (PCTSTR) envBuff.Buf);
    GbFree (&envBuff);

    TRACK_LEAVE();

    return result;
}


BOOL
IsmSetTransportVariable (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    IN      PCTSTR KeyData
    )
{
    PCTSTR variable;
    BOOL result = FALSE;

    if (!Section || !Key || !KeyData) {
        DEBUGMSG ((DBG_ERROR, "Section, key and key data are required for IsmSetTransportVariable"));
        return FALSE;
    }

    variable = JoinPaths (Section, Key);

    result = IsmSetEnvironmentString (Platform, S_TRANSPORT_PREFIX, variable, KeyData);

    FreePathString (variable);

    return result;
}


BOOL
IsmGetTransportVariable (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    OUT     PTSTR KeyData,                      OPTIONAL
    IN      UINT KeyDataBufferSizeInBytes
    )
{
    PCTSTR variable;
    BOOL result = FALSE;

    if (!Section || !Key) {
        DEBUGMSG ((DBG_ERROR, "Section, key and key data are required for IsmSetTransportVariable"));
        return FALSE;
    }

    variable = JoinPaths (Section, Key);

    result = IsmGetEnvironmentString (
                Platform,
                S_TRANSPORT_PREFIX,
                variable,
                KeyData,
                KeyDataBufferSizeInBytes,
                NULL
                );

    FreePathString (variable);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\app\scanstate\scanstate.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    scanstate.c

Abstract:

    Implements the app layer of the v1 compatibility app.

Author:

    Jim Schmidt (jimschm) 14-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "modules.h"
#include "trans.h"
#include "v2app.h"
#include <lm.h>
#ifdef DEBUG
#include <shellapi.h>
#endif
#include "logmsg.h"
#include "common.h"

#define DBG_SCANSTATE       "ScanState"

//
// Strings
//

// None

//
// Constants
//

#define LOG_VERBOSE_BIT  0x01
#define LOG_UNUSED_BIT   0x02   // for v1 compatibility, do not use
#define LOG_STATUS_BIT   0x04
#define LOG_DEBUGGER_BIT 0x08
#define LOG_UPDATE_BIT   0x10

#define SCANSTATE_SAVE      0x00000001
#define SCANSTATE_COMPLETED 0x00000002

#define RETURN_SUCCESS     0
#define RETURN_FATAL_ERROR 1
#define RETURN_ERROR       2

//
// Macros
//

// None

//
// Types
//

typedef NET_API_STATUS(WINAPI NETWKSTAGETINFO)(PWSTR, DWORD, PBYTE *);
typedef NETWKSTAGETINFO *PNETWKSTAGETINFO;

typedef NET_API_STATUS(WINAPI NETAPIBUFFERFREE)(PVOID);
typedef NETAPIBUFFERFREE *PNETAPIBUFFERFREE;

//
// Globals
//

BOOL g_OverwriteImage = FALSE;
BOOL g_ContinueOnError = FALSE;
DWORD g_ReturnCode = RETURN_SUCCESS;
TCHAR g_JournalPath[MAX_PATH_PLUS_NUL];
BOOL g_Break;
BOOL g_TestMode;

//
// Macro expansion list
//

#define REQUIRED_INFS       \
        DEFMAC(OSFILES,     TEXT("USMTDef.inf"))  \

//
// Private function prototypes
//

#ifdef PRERELEASE
MESSAGECALLBACK pSaveMsgCallback;
#endif

//
// Macro expansion definition
//

//
// This is the structure used for required infs
//
typedef struct {
    PCTSTR InfId;
    PCTSTR InfName;
} REQUIREDINF_STRUCT, *PREQUIREDINF_STRUCT;

//
// Declare a global array of required infs
//
#define DEFMAC(infid,infname) {TEXT(#infid),infname},
static REQUIREDINF_STRUCT g_RequiredInfs[] = {
                              REQUIRED_INFS
                              {NULL, NULL}
                              };
#undef DEFMAC

//
// Code
//

VOID
pHelpAndExit (
    VOID
    )
{
    PrintMsgOnConsole (MSG_HELP);

#ifdef PRERELEASE
    printf ("\nAdditional PRERELEASE options:\n\n"
            "/tf            Uses full transport instead of v1 transport\n"
            "/tc            Enable compression\n"
            "/ta            Enable automatic capability (for homenet transport)\n"
            "/ti:<tag>      Specify an identity tag for the homenet transport\n"
            "               Default is user name\n"
            "/t:<name>      Specifies transport to use\n"
            );
#endif

    TerminateAppCommon();
    UtTerminate ();
    exit (1);
}


VOID
pCleanUpApp (
    VOID
    )
{
    IsmTerminate();

    if (g_JournalPath[0]) {
        DeleteFile (g_JournalPath);
        g_JournalPath[0] = 0;
    }
}


BOOL
WINAPI
CtrlCRoutine (
    IN      DWORD ControlSignal
    )
{
    PrintMsgOnConsole (MSG_EXITING);

    LOG ((LOG_WARNING, (PCSTR) MSG_TOOL_STOPPED));

    g_Break = TRUE;

    IsmSetCancel();
    while (IsmCurrentlyExecuting()) {
        Sleep (1000);
    }

    pCleanUpApp();

    printf ("\n");
    exit (1);
}


ULONG_PTR
pSaveMsgCallback (
    UINT Message,
    ULONG_PTR Arg
    )
{
    PTRANSCOPY_ERROR transCopyError;
#ifdef PRERELEASE
    PRMEDIA_EXTRADATA extraData;
#endif

    switch (Message) {

    case TRANSPORTMESSAGE_IMAGE_EXISTS:
        return g_OverwriteImage;

    case TRANSPORTMESSAGE_SRC_COPY_ERROR:
        transCopyError = (PTRANSCOPY_ERROR) Arg;
        if (transCopyError) {
            if (StringIMatch (transCopyError->ObjectType, TEXT("File"))) {
                if ((transCopyError->Error == ERROR_FILE_NOT_FOUND) ||
                    (transCopyError->Error == ERROR_PATH_NOT_FOUND) ||
                    (transCopyError->Error == ERROR_ACCESS_DENIED)  ||
                    (transCopyError->Error == ERROR_INVALID_NAME)
                    ) {
                    return APPRESPONSE_IGNORE;
                }
            }
        }
        return APPRESPONSE_FAIL;

#ifdef PRERELEASE
    case TRANSPORTMESSAGE_RMEDIA_SAVE:
        extraData = (PRMEDIA_EXTRADATA) Arg;
        if (!extraData) {
            return (MessageBox (
                        NULL,
                        TEXT("Please insert the next media in your drive."),
                        TEXT("ScanState"),
                        MB_OKCANCEL
                        ) == IDOK);
        }
        if (extraData->MediaNumber == 1) {
            switch (extraData->LastError) {
            case RMEDIA_ERR_NOERROR:
                return TRUE;
            case RMEDIA_ERR_WRONGMEDIA:
                return (MessageBox (
                            NULL,
                            TEXT("You have inserted the wrong media.\n\nPlease insert the first media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_DISKFULL:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted does not have enough free space.\n\nPlease insert the first media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_WRITEPROTECT:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted is write protected.\n\nPlease insert the first media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_NOTREADY:
                return (MessageBox (
                            NULL,
                            TEXT("The drive is not ready for use. Please check the drive and make sure that a disk is inserted and that the drive door is closed."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_CRITICAL:
                return FALSE;
            default:
                return (MessageBox (
                            NULL,
                            TEXT("Your media is toast.\n\nPlease insert the first media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            }
        } else {
            switch (extraData->LastError) {
            case RMEDIA_ERR_NOERROR:
                return TRUE;
            case RMEDIA_ERR_WRONGMEDIA:
                return (MessageBox (
                            NULL,
                            TEXT("You have inserted the wrong media.\n\nPlease insert the next media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_DISKFULL:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted does not have enough free space.\n\nPlease insert the next media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_WRITEPROTECT:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted is write protected.\n\nPlease insert the next media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_NOTREADY:
                return (MessageBox (
                            NULL,
                            TEXT("The drive is not ready for use. Please check the drive and make sure that a disk is inserted and that the drive door is closed."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_CRITICAL:
                return FALSE;
            default:
                return (MessageBox (
                            NULL,
                            TEXT("Your media is toast.\n\nPlease insert the next media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            }
        }
#endif
    }
    return FALSE;
}

VOID
pMyLogCallback (
    IN      PLOGARG LogArg
    )
{
    if (LogArg->Debug) {
        DEBUGDIRECT (LogArg->Type, LogArg->FormattedMessage);
    } else {
        if (StringIMatchA (LogArg->Type, LOG_ERROR)) {
            if (g_ReturnCode == RETURN_SUCCESS) {
                g_ReturnCode = RETURN_ERROR;
            }
            if (!g_ContinueOnError) {
                IsmSetCancel();
            }
        } else if (StringIMatchA (LogArg->Type, LOG_FATAL_ERROR) ||
                   StringIMatchA (LogArg->Type, LOG_MODULE_ERROR)) {
            g_ReturnCode = RETURN_FATAL_ERROR;
        }
        LOGDIRECT (LogArg->Type, LogArg->FormattedMessage);
    }
}

#ifdef DEBUG
VOID
pStopAndDisplayInfs (
    IN      PGROWBUFFER InputInfs,
    IN      BOOL Begin
    )
{
    MULTISZ_ENUM infEnum;

    if (MessageBox (
            NULL,
            TEXT("ScanState stopped. Do you want to display all loaded INFs?"),
            Begin?TEXT("ScanState-Begin"):TEXT("ScanState-End"),
            MB_YESNO
            ) == IDYES) {
        //
        // now let's open append all INF files and pass the HINF to
        // everybody.
        //
        if (EnumFirstMultiSz (&infEnum, (PCTSTR)InputInfs->Buf)) {
            do {
                ShellExecute (NULL, TEXT("open"), infEnum.CurrentString, NULL, NULL, SW_SHOWNORMAL);
            } while (EnumNextMultiSz (&infEnum));
        }
        MessageBox (NULL, TEXT("Press OK to continue..."), TEXT("ScanState-Begin"), MB_OK);
    }
}
#endif


BOOL
pIsIE4Installed (
    VOID
    )
{
    LONG hResult;
    REGSAM prevMode;
    HKEY ieKey = NULL;
    DWORD valueType = REG_SZ;
    DWORD valueSize = 0;
    PTSTR valueData = NULL;
    PTSTR numPtr = NULL;
    PTSTR dotPtr = NULL;
    INT major = 0;
    INT minor = 0;
    TCHAR saved;
    BOOL result = FALSE;

    prevMode = SetRegOpenAccessMode (KEY_READ);

    ieKey = OpenRegKeyStr (TEXT("HKLM\\Software\\Microsoft\\Internet Explorer"));

    SetRegOpenAccessMode (prevMode);

    if (ieKey) {
        hResult = RegQueryValueEx (ieKey, TEXT("Version"), NULL, &valueType, NULL, &valueSize);
        if ((hResult == ERROR_SUCCESS) || (hResult == ERROR_MORE_DATA)) {
            valueData = (PTSTR)HeapAlloc (GetProcessHeap (), 0, valueSize * 2);
            if (valueData) {
                hResult = RegQueryValueEx (ieKey, TEXT("Version"), NULL, &valueType, (PBYTE)valueData, &valueSize);
                if ((hResult == ERROR_SUCCESS) && (valueType == REG_SZ)) {
                    // let's see if it the version is the correct one
                    numPtr = valueData;
                    dotPtr = _tcschr (numPtr, TEXT('.'));
                    if (dotPtr) {
                        saved = *dotPtr;
                        *dotPtr = 0;
                        major = _ttoi (numPtr);
                        *dotPtr = saved;
                    } else {
                        major = _ttoi (numPtr);
                    }
                    if (dotPtr) {
                        numPtr = _tcsinc (dotPtr);
                        dotPtr = _tcschr (numPtr, TEXT('.'));
                        if (dotPtr) {
                            saved = *dotPtr;
                            *dotPtr = 0;
                            minor = _ttoi (numPtr);
                            *dotPtr = saved;
                        } else {
                            minor = _ttoi (numPtr);
                        }
                    }
                    if ((major >= 5) ||
                        ((major == 4) && (minor >= 71))
                        ) {
                        result = TRUE;
                    }
                }
                HeapFree (GetProcessHeap (), 0, valueData);
                valueData = NULL;
            }
        }
        CloseRegKey (ieKey);
    }
    return result;
}

BOOL
pCheckSystemRequirements (
    VOID
    )
{
    HKEY domainLogonKey;
    PDWORD data;
    BOOL result = TRUE;
    TCHAR userName[MAX_USER_NAME];
    DWORD size;
    NET_API_STATUS rc;
    PWKSTA_INFO_102 buffer;
    HANDLE netApi32Lib;
    PNETWKSTAGETINFO netWkstaGetInfo;
    PNETAPIBUFFERFREE netApiBufferFree;
    BYTE sid[256];
    DWORD sidSize = 256;
    WCHAR domain[256];
    DWORD domainSize = 256;
    SID_NAME_USE use;

    if (!ISNT()) {
        //
        // Require the Log On To Domain setting to be checked
        //

        SetLastError (ERROR_SUCCESS);

        domainLogonKey = OpenRegKeyStr (TEXT("HKLM\\Network\\Logon"));
        if (!domainLogonKey) {
            LOG ((LOG_ERROR, (PCSTR) MSG_NETWORK_LOGON_KEY));
            return FALSE;
        }

        data = (PDWORD) GetRegValueBinary (domainLogonKey, TEXT("LMLogon"));
        if (!data) {
            LOG ((LOG_ERROR, (PCSTR) MSG_NETWORK_LMLOGON_KEY));
            result = FALSE;
        } else {

            if (!(*data)) {
                LOG ((LOG_ERROR, (PCSTR) MSG_NO_DOMAIN_LOGON));
                result = FALSE;
            }

            FreeAlloc (data);
        }

        CloseRegKey (domainLogonKey);

    } else {
        //
        // Require domain membership
        //

        netApi32Lib = LoadLibrary (TEXT("netapi32.dll"));
        if (netApi32Lib) {
            netWkstaGetInfo = (PNETWKSTAGETINFO) GetProcAddress (netApi32Lib, "NetWkstaGetInfo");
            netApiBufferFree = (PNETAPIBUFFERFREE) GetProcAddress (netApi32Lib, "NetApiBufferFree");
        } else {
            netWkstaGetInfo = NULL;
            netApiBufferFree = NULL;
        }

        if (!netWkstaGetInfo || !netApiBufferFree) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_LOAD_NETAPI32));
            result = FALSE;
        } else {

            rc = netWkstaGetInfo (NULL, 102, (PBYTE *) &buffer);

            if (rc == NO_ERROR) {
                result = buffer->wki102_langroup && (buffer->wki102_langroup[0] != 0);
                if (result) {
                    DEBUGMSGW ((DBG_SCANSTATE, "Getting account type of %s", buffer->wki102_langroup));

                    sidSize = ARRAYSIZE(sid);
                    domainSize = ARRAYSIZE(domain);

                    result = LookupAccountNameW (
                                    NULL,
                                    buffer->wki102_langroup,
                                    sid,
                                    &sidSize,
                                    domain,
                                    &domainSize,
                                    &use
                                    );
                    DEBUGMSG ((DBG_SCANSTATE, "Account type result is %u (use=%u)", result, use));

                    LOG_IF ((!result, LOG_ERROR, (PCSTR) MSG_NOT_JOINED_TO_DOMAIN));

                }
                ELSE_DEBUGMSG ((DBG_SCANSTATE, "No langroup specified"));

                netApiBufferFree (buffer);
            } else {
                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_GET_WORKSTATION_PROPS));
                result = FALSE;
            }
        }

        if (netApi32Lib) {
            FreeLibrary (netApi32Lib);
        }
    }

    // let's check to see if IE4 is installed on this machine
    if (result && !pIsIE4Installed ()) {
        LOG ((LOG_ERROR, (PCSTR) MSG_NEED_IE4));
        return FALSE;
    }

    //
    // Make sure a user name is specified
    //

    if (result) {
        size = ARRAYSIZE(userName);
        if (!GetUserName (userName, &size)) {
            result = FALSE;
        } else if (*userName == 0) {
            result = FALSE;
        }

        LOG_IF ((!result, LOG_ERROR, (PCSTR) MSG_LOGGED_ON_USER_REQUIRED));
    }

    return result;
}


VOID
__cdecl
_tmain (
    IN      INT Argc,
    IN      PCTSTR Argv[]
    )
{
    TCHAR appPath[MAX_PATH_PLUS_NUL];
    TCHAR ismPath[MAX_PATH_PLUS_NUL];
    PTSTR p;
    MIG_TRANSPORTID transportId;
    MIG_TRANSPORTSTORAGEID transportStorageId;
    MULTISZ_ENUM infEnum;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_STRUCT infHandleStruct;
    INT numInfs = 0;
    PTSTR buffer;
    MULTISZ_ENUM e;
    DWORD appStatus;
    BOOL skipExecute = FALSE;
    BOOL storagePathIsValid = FALSE;
    BOOL imageExists = FALSE;
    BOOL terminateIsm = FALSE;
    BOOL logEnabled = FALSE;
    PCTSTR msg;
    PCTSTR argArray[1];
    TOOLARGS args;
    BOOL fail;

    ZeroMemory (&args, sizeof (args));

    SET_RESETLOG();
    UtInitialize (NULL);
    InitAppCommon();

    SuppressAllLogPopups (TRUE);

    PrintMsgOnConsole (MSG_RUNNING);

    // initialize app journal path
    g_JournalPath[0] = 0;
    if (GetWindowsDirectory (g_JournalPath, ARRAYSIZE (g_JournalPath))) {
        StringCopy (AppendWack (g_JournalPath), TEXT("SCANSTATE.JRN"));
    }

    GetModuleFileName (NULL, appPath, ARRAYSIZE(appPath));
    p = _tcsrchr (appPath, TEXT('\\'));
    if (p) {
        *p = 0;
    }

    //
    // Parse the command line
    //

    fail = TRUE;

    switch (ParseToolCmdLine (TRUE, &args, Argc, Argv)) {

    case PARSE_SUCCESS:
        fail = FALSE;
        break;

    case PARSE_MULTI_LOG:
        PrintMsgOnConsole (MSG_MULTI_LOG);
        g_ReturnCode = RETURN_FATAL_ERROR;
        goto END;

    case PARSE_BAD_LOG:
        argArray[0] = args.LogFile;
        msg = ParseMessageID (MSG_CANT_OPEN_LOG, argArray);
        if (msg) {
            _tprintf (TEXT("%s"), msg);
            FreeStringResource (msg);
        }

        g_ReturnCode = RETURN_FATAL_ERROR;
        goto END;

    default:
        break;
    }

    if (fail) {
        pHelpAndExit();
    }

    g_TestMode = args.TestMode;
    g_OverwriteImage = args.OverwriteImage;
    g_ContinueOnError = args.ContinueOnError;

#ifdef DEBUG
    {
        if (DoesFileExist (TEXT("C:\\SCANSTATE.BEGIN"))) {
            pStopAndDisplayInfs (&args.InputInf, TRUE);
        }
    }
#endif

    LogReInit (NULL, NULL, (args.LogFile ? args.LogFile : TEXT("scanstate.log")), NULL);
    logEnabled = TRUE;

    //
    // Check requirements
    //

    if (args.BadInfs.End || args.MultiInfs.End) {
        SetLastError (ERROR_BAD_COMMAND);

        if (EnumFirstMultiSz (&e, (PCTSTR) args.BadInfs.Buf)) {
            do {
                LOG ((LOG_ERROR, (PCSTR) MSG_INF_FILE_NOT_FOUND, e.CurrentString));
            } while (EnumNextMultiSz (&e));
        }

        if (EnumFirstMultiSz (&e, (PCTSTR) args.MultiInfs.Buf)) {
            do {
                LOG ((LOG_ERROR, (PCSTR) MSG_INF_SPECIFIED_MORE_THAN_ONE, e.CurrentString));
            } while (EnumNextMultiSz (&e));
        }

        g_ReturnCode = RETURN_FATAL_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CMD_LINE_ERROR));
        goto END;
    }

    if (!GetFilePath (TEXT("migism.inf"), ismPath, ARRAYSIZE(ismPath))) {
        g_ReturnCode = RETURN_FATAL_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_ISM_INF_MISSING));
        goto END;
    }

    if (!g_TestMode) {
        if (!pCheckSystemRequirements()) {
            g_ReturnCode = RETURN_FATAL_ERROR;
            goto END;
        }
    }

    //
    // Initialize ISM
    //

    if (!IsmInitialize (ismPath, pSaveMsgCallback, pMyLogCallback)) {
        g_ReturnCode = RETURN_FATAL_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_START_ISM));
        goto END;
    }

    terminateIsm = TRUE;
    SetLogVerbosity (args.VerboseLevel);

    SetConsoleCtrlHandler (CtrlCRoutine, TRUE);

    IsmSetPlatform (PLATFORM_SOURCE);

    // upload environment variables
    UploadEnvVars (PLATFORM_SOURCE);

    infHandle = InitRequiredInfs (appPath, (PCSTR) MSG_CANT_OPEN_REQUIRED_FILE);

    if (args.InputInf.Buf) {
        IsmSetEnvironmentData (
            PLATFORM_SOURCE,
            NULL,
            S_INF_FILE_MULTISZ,
            args.InputInf.Buf,
            (WORD) args.InputInf.End
            );

        //
        // now let's open append all INF files and pass the HINF to
        // everybody.
        //
        if (EnumFirstMultiSz (&infEnum, (PCTSTR)args.InputInf.Buf)) {
            buffer = DuplicateTextEx (NULL, S_INF_OBJECT_NAME, 2, &p);  // Up to 2 digits of numbers
            do {
                if (infHandle == INVALID_HANDLE_VALUE) {
                    infHandle = SetupOpenInfFile (infEnum.CurrentString, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
                    if (infHandle == INVALID_HANDLE_VALUE) {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_FILE, infEnum.CurrentString));
                    }
                } else {
                    if (!SetupOpenAppendInfFile (infEnum.CurrentString, infHandle, NULL)) {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_FILE, infEnum.CurrentString));
                    }
                }

                // Save Inf for right side use
                if (numInfs < 100) {
                   numInfs++;
                   _stprintf(p, TEXT("%d"), numInfs);
                   IsmAddControlFile (buffer, infEnum.CurrentString);
                }
            } while (EnumNextMultiSz (&infEnum));
            FreeText (buffer);
        }
    }

    if (infHandle != INVALID_HANDLE_VALUE) {
        infHandleStruct.Type = ENVENTRY_BINARY;
        infHandleStruct.EnvBinaryData = (PVOID)(&infHandle);
        infHandleStruct.EnvBinaryDataSize = sizeof (HINF);
        IsmSetEnvironmentValue (PLATFORM_SOURCE, NULL, S_GLOBAL_INF_HANDLE, &infHandleStruct);
    }

    if (args.UserOn) {
        IsmSetEnvironmentFlag (PLATFORM_SOURCE, NULL, S_ENV_HKCU_V1);
        IsmSetEnvironmentFlag (PLATFORM_SOURCE, NULL, S_ENV_HKCU_ON);
    }

    if (args.FilesOn) {
        IsmSetEnvironmentFlag (PLATFORM_SOURCE, NULL, S_ENV_ALL_FILES);
    }

    //
    // Start ETM modules
    //

    if (!IsmStartEtmModules ()) {
        if (!IsmCheckCancel()) {
            LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_START_ETMS));
        }
        goto END;
    }

    //
    // Initialize transport
    //

    if (!IsmStartTransport ()) {
        if (!IsmCheckCancel()) {
            LOG ((LOG_FATAL_ERROR, "Can't start the transport."));
        }
        goto END;
    }

    transportStorageId = IsmRegisterTransport (args.TransportName);

    if (args.FullTransport) {
        transportId = IsmSelectTransport (transportStorageId, TRANSPORTTYPE_FULL, args.Capabilities);
    } else {
        transportId = IsmSelectTransport (transportStorageId, TRANSPORTTYPE_LIGHT, args.Capabilities);
    }

    if (!args.TransportNameSpecified) {
        BfCreateDirectory (args.StoragePath);
    }

    if (!transportId) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_TRANSPORT_UNAVAILABLE));
        goto END;
    }

#ifdef PRERELEASE

    IsmSetEnvironmentString (PLATFORM_SOURCE, NULL, TRANSPORT_ENVVAR_HOMENET_TAG, args.Tag);

#endif

    if (!IsmSetTransportStorage (
            PLATFORM_SOURCE,
            transportId,
            transportStorageId,
            args.Capabilities,
            args.StoragePath,
            &storagePathIsValid,
            &imageExists
            ) || storagePathIsValid == FALSE
            ) {

        if (!IsmCheckCancel()) {
            LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_TRANSPORT_STORAGE_INVALID, args.StoragePath));
        }

        goto END;
    }

#ifdef PRERELEASE
    if (args.Capabilities & CAPABILITY_AUTOMATED) {
        if (!imageExists) {
            LOG ((
                LOG_FATAL_ERROR,
                "Can't select %s as the transport; need to run loadstate first.",
                args.TransportName
                ));
            goto END;
        }
    }
#endif

    appStatus = ReadAppStatus (g_JournalPath);

    if (appStatus == SCANSTATE_SAVE) {
        skipExecute = IsmResumeSave ();
    }

    if (!skipExecute) {

        //
        // Execute the preparsing to populate the components
        //

        if (IsmExecute (args.FullTransport?EXECUTETYPE_EXECUTESOURCE_PARSING:EXECUTETYPE_VIRTUALCOMPUTER_PARSING)) {

            IsmSelectMasterGroup (MASTERGROUP_ALL, TRUE);

            if (!args.SystemOn) {
                IsmSelectMasterGroup (MASTERGROUP_SYSTEM, FALSE);
                IsmSelectMasterGroup (MASTERGROUP_USER, FALSE);
                IsmSelectMasterGroup (MASTERGROUP_APP, FALSE);
            }

            SelectComponentsViaInf (infHandle);

            //
            // Enumerate the system, gather data and analyze
            //

            if (IsmExecute (args.FullTransport?EXECUTETYPE_EXECUTESOURCE:EXECUTETYPE_VIRTUALCOMPUTER)) {
                //
                // Display report
                //

                //
                // Save the state
                //

                // write the app status
                WriteAppStatus (g_JournalPath, SCANSTATE_SAVE);

                if (!IsmSave ()) {
                    if (!IsmCheckCancel()) {
                        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_SAVE));
                    }
                }

                // write the app status
                WriteAppStatus (g_JournalPath, SCANSTATE_COMPLETED);

            } else {
                if (!IsmCheckCancel()) {
                    LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_EXECUTE_SOURCE));
                }
            }

        } else {
            if (!IsmCheckCancel()) {
                LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_EXECUTE_SOURCE));
            }
        }
    }

    //
    // We're done!
    //

    SetupCloseInfFile (infHandle);

#ifdef DEBUG
    {
        if (DoesFileExist (TEXT("C:\\SCANSTATE.END"))) {
            pStopAndDisplayInfs (&args.InputInf, FALSE);
        }
    }
#endif


END:
    if (terminateIsm) {
        if (!g_Break) {
            pCleanUpApp();
        }
    }

    GbFree (&args.BadInfs);
    GbFree (&args.MultiInfs);
    GbFree (&args.InputInf);

    if (!g_Break) {
        if (g_ReturnCode != RETURN_SUCCESS) {
            if (logEnabled) {
                PrintMsgOnConsole (MSG_FAILED_WITH_LOG);
            } else {
                PrintMsgOnConsole (MSG_FAILED_NO_LOG);
            }
        } else {
            PrintMsgOnConsole (MSG_SUCCESS);
        }
    }

    TerminateAppCommon();
    UtTerminate ();

    while (g_Break) {
        // infinite loop, because we'll get terminated in the ctrl+c handler
        Sleep (50);
    }

    exit (g_ReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\components.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    components.c

Abstract:

    Implements a set of APIs for the purposes of allowing the application layer to select
    module functionality.

Author:

    Jim Schmidt (jimschm) 07-Aug-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_COMP     "Comp"

//
// Strings
//

#define S_COMPONENT_ROOT            TEXT("Components")
#define S_USER_SUPPLIED             TEXT("User")
#define S_MODULE_SUPPLIED           TEXT("Module")

//
// Constants
//

#define MAX_COMPONENT_SPEC          127
#define MAX_COMPONENT_SPEC_PLUS_NUL (MAX_COMPONENT_SPEC+1)

#define MAX_CONTROLLED_NODE_SIZE    (MAX_COMPONENT_SPEC_PLUS_NUL +  \
                                     ARRAYSIZE(S_COMPONENT_ROOT) +  \
                                     ARRAYSIZE(S_MODULE_SUPPLIED) + 16)

#define MEMDB_FLAG_PREFERRED        1
#define MEMDB_FLAG_SELECTED         1

//
// Macros
//

// none

//
// Types
//

typedef enum {
    CES_DONE = 0,
    CES_FIRST_COMPONENT,
    CES_NEXT_COMPONENT,
    CES_FIRST_ALIAS,
    CES_NEXT_ALIAS,
    CES_CHECK_ALIAS_FLAGS
} COMPONENTENUMSTATE;

typedef struct {
    MEMDB_ENUM ComponentEnumStruct;
    MEMDB_ENUM AliasEnumStruct;
    BOOL EnumAliases;
    UINT GroupIdFilter;
    BOOL EnumEnabled;
    BOOL EnumDisabled;
    BOOL EnumPreferredOnly;
    BOOL EnumNonPreferredOnly;
    COMPONENTENUMSTATE State;
} COMPONENTENUM_HANDLE, *PCOMPONENTENUM_HANDLE;

//
// Globals
//

// none

//
// Macro expansion list
//

// none

//
// Private function prototypes
//

// none

//
// Macro expansion definition
//

// none

//
// Code
//


BOOL
pCheckCompChar (
    IN      CHARTYPE Char,
    IN      BOOL CheckDecoration
    )
{
    //
    // Process decoration chars
    //

    if (Char == TEXT('$') || Char == TEXT('@') || Char == TEXT('~') || Char == TEXT('#')) {
        return CheckDecoration;
    }

    if (CheckDecoration) {
        return FALSE;
    }

    //
    // Block illegal chars
    //

    if (Char == TEXT('\"') || Char == TEXT('*') || Char == TEXT('?') || Char== TEXT('\\') ||
        Char == TEXT('%') || Char == TEXT(';')
        ) {
        return FALSE;
    }

    //
    // Make sure char is printable
    //

    if (Char < 33 || Char > 126) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pCheckComponentName (
    IN      PCTSTR ComponentString
    )
{
    BOOL result = FALSE;
    PCTSTR end;
    PCTSTR begin;

    //
    // Check for a non-empty spec
    //

    if (ComponentString && ComponentString[0]) {

        //
        // Allow for decoration
        //

        end = ComponentString;

        while (pCheckCompChar ((CHARTYPE) _tcsnextc (end), TRUE)) {
            end = _tcsinc (end);
        }

        //
        // Now enforce the name character set: non-decorated characters and no
        // more than MAX_COMPONENT_SPEC characters. Allow spaces in the middle.
        //

        begin = end;

        while (*end) {
            if (!pCheckCompChar ((CHARTYPE) _tcsnextc (end), FALSE)) {
                if (_tcsnextc (end) == TEXT(' ')) {
                    if (!end[1] || end == begin) {
                        break;
                    }
                } else {
                    break;
                }
            }

            end = _tcsinc (end);
        }

        if (!(*end) && *begin) {
            if (end - ComponentString <= MAX_COMPONENT_SPEC) {
                result = TRUE;
            }
        }
    }

    if (!result) {
        SetLastError (ERROR_INVALID_PARAMETER);
        DEBUGMSG ((DBG_ERROR, "%s is not a valid component name", ComponentString));
    }

    return result;
}

BOOL
pFindComponent (
    IN      PCTSTR LocalizedAlias,
    IN      UINT ComponentGroupId,
    OUT     PCTSTR *ComponentKey,           OPTIONAL
    OUT     PCTSTR *AliasKey                OPTIONAL
    )
{
    MEMDB_ENUM component;
    PCTSTR memdbNode = NULL;
    PCTSTR encodedUserAlias;
    PCTSTR encodedModuleAlias;
    TCHAR number[32];
    BOOL result = FALSE;

    //
    // Find the component based on the localized alias
    //

    wsprintf (number, TEXT("\\%s\\%04u"), S_USER_SUPPLIED, ComponentGroupId);
    encodedUserAlias = JoinPaths (number, LocalizedAlias);

    wsprintf (number, TEXT("\\%s\\%04u"), S_MODULE_SUPPLIED, ComponentGroupId);
    encodedModuleAlias = JoinPaths (number, LocalizedAlias);

    if (MemDbEnumFirst (
            &component,
            S_COMPONENT_ROOT TEXT("\\*"),
            ENUMFLAG_ALL,
            1,
            1
            )) {

        do {
            memdbNode = JoinText (component.FullKeyName, encodedModuleAlias);

            if (MemDbTestKey (memdbNode)) {
                break;
            }

            FreeText (memdbNode);
            memdbNode = NULL;

            memdbNode = JoinText (component.FullKeyName, encodedUserAlias);

            if (MemDbTestKey (memdbNode)) {
                break;
            }

            FreeText (memdbNode);
            memdbNode = NULL;

        } while (MemDbEnumNext (&component));
    }

    if (memdbNode) {

        if (ComponentKey) {
            *ComponentKey = DuplicateText (component.FullKeyName);
        }

        if (AliasKey) {
            *AliasKey = memdbNode;
            memdbNode = NULL;
        }

        MemDbAbortEnum (&component);
        result = TRUE;
    }

    FreeText (memdbNode);
    INVALID_POINTER (memdbNode);

    FreePathString (encodedUserAlias);
    INVALID_POINTER (encodedUserAlias);

    FreePathString (encodedModuleAlias);
    INVALID_POINTER (encodedModuleAlias);

    return result;
}


BOOL
WINAPI
IsmSelectPreferredAlias (
    IN      PCTSTR ComponentString,
    IN      PCTSTR LocalizedAlias,          OPTIONAL
    IN      UINT ComponentGroupId           OPTIONAL
    )

/*++

Routine Description:

  IsmSelectPreferredAlias marks a specific alias as the "preferred" one, so
  that the UI knows what to display. If LocalizedAlias is not specified, none
  of the aliases are preferred.

  A component can have only one preferred localized alias. If another alias is
  selected as preferred, it will be deselected automatically.

Arguments:

  ComponentString  - Specifies the non-displayed component identifier
  LocalizedAlias   - Specifies the displayable string to mark as "preferred,"
                     or NULL to remove the preferred flag from the component.
  ComponentGroupId - Specifies the group ID for LocalizedAlias. Required if
                     LocalizedAlias is not NULL.

Return Value:

  TRUE if selection (or deselection) succeeded, FALSE if LocalizedAlias does
  not exist.

--*/

{
    MEMDB_ENUM e;
    TCHAR number[32];
    PCTSTR memdbNode = NULL;
    PCTSTR baseOfPattern;
    PCTSTR enumPattern;
    PCTSTR groupedAlias;
    BOOL result;

    if (!ComponentString || (LocalizedAlias && !ComponentGroupId)) {
        MYASSERT (FALSE);
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    result = (LocalizedAlias == NULL);

    //
    // Build enumeration string Components\<component>\*
    //

    baseOfPattern = JoinPaths (S_COMPONENT_ROOT, ComponentString);
    enumPattern = JoinPaths (baseOfPattern, TEXT("*"));
    FreePathString (baseOfPattern);
    INVALID_POINTER (baseOfPattern);

    if (LocalizedAlias) {
        wsprintf (number, TEXT("%04u"), ComponentGroupId);
        groupedAlias = JoinPaths (number, LocalizedAlias);
    } else {
        groupedAlias = NULL;
    }

    if (MemDbEnumFirst (
            &e,
            enumPattern,
            ENUMFLAG_NORMAL,
            3,
            ENUMLEVEL_ALLLEVELS
            )) {
        do {
            if (groupedAlias && StringIMatch (e.KeyName, groupedAlias)) {
                MemDbSetFlags (e.FullKeyName, MEMDB_FLAG_PREFERRED, MEMDB_FLAG_PREFERRED);
                result = TRUE;
            } else {
                MemDbSetFlags (e.FullKeyName, 0, MEMDB_FLAG_PREFERRED);
            }
        } while (MemDbEnumNext (&e));
    }

    FreePathString (enumPattern);
    INVALID_POINTER (enumPattern);

    FreePathString (groupedAlias);
    INVALID_POINTER (groupedAlias);

    return result;
}


BOOL
WINAPI
IsmAddComponentAlias (
    IN      PCTSTR ComponentString,         OPTIONAL
    IN      UINT MasterGroup,
    IN      PCTSTR LocalizedAlias,
    IN      UINT ComponentGroupId,
    IN      BOOL UserSupplied
    )

/*++

Routine Description:

  IsmAddComponentAlias associates a display string (LocalizedAlias) with a
  logical component tag (ComponentString).

Arguments:

  ComponentString  - Specifies the identifier of the component. This
                     identifier is not used for display purposes.
  MasterGroup      - Specifies a MASTERGROUP_xxx constant, which organizes
                     the components into major groups such as system settings
                     and app settings (to simplify selection).
  LocalizedAliais  - The displayable text. It is a localized component name,
                     a path, a file, etc.
  ComponentGroupId - An arbitrary numeric ID defined outside of the ISM. This
                     ID is used to implement requirements specific to the app
                     layer. It allows for arbitrary idenfication and grouping.
  UserSupplied     - Specifies TRUE if the end-user supplied this info, FALSE
                     if it is built into the migration package.

Return Value:

  A flag indicating success or failure.

--*/

 {
    PCTSTR memdbNode;
    TCHAR workNode[MAX_CONTROLLED_NODE_SIZE];
    static UINT sequencer = 0;
    TCHAR madeUpComponent[MAX_COMPONENT_SPEC_PLUS_NUL];
    BOOL b;
    BOOL newComponent = FALSE;

    //
    // Components are kept in memdb in the form of
    //
    //  Component\<Module|User>\<GroupId>\<LocalizedAlias> = <preferred flag>
    //
    // <GroupId> is stored as a 4 digit number (such as 0001)
    //
    // Component\<Module|User> = <enable/disable>,<master group>
    //

    //
    // Validate arguments
    //

    if (ComponentGroupId > 9999) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!ComponentString || !ComponentString[0]) {

        wsprintf (madeUpComponent, TEXT("Component %u"), ++sequencer);
        ComponentString = madeUpComponent;

    } else if (!pCheckComponentName (ComponentString)) {
        return FALSE;
    }

    if (!MasterGroup || MasterGroup >= MASTERGROUP_ALL) {
        SetLastError (ERROR_INVALID_PARAMETER);
        DEBUGMSG ((DBG_ERROR, "MasterGroup is invalid"));
        return FALSE;
    }

    //
    // See if the component already exists
    //

    wsprintf (workNode, TEXT("%s\\%s"), S_COMPONENT_ROOT, ComponentString);

    if (pFindComponent (LocalizedAlias, ComponentGroupId, &memdbNode, NULL)) {

        if (StringIMatch (workNode, memdbNode)) {
            DEBUGMSG ((DBG_VERBOSE, "Alias %s already exists; not adding it again", LocalizedAlias));
        } else {
            DEBUGMSG ((
                DBG_WARNING,
                "Alias %s is in use by component %s; not adding it again",
                LocalizedAlias,
                _tcschr (memdbNode, TEXT('\\')) + 1
                ));
        }

        FreeText (memdbNode);
        return FALSE;
    }

    //
    // Create the component if it doesn't exist, and then add the alias
    //

    if (!MemDbTestKey (workNode)) {
        if (!MemDbSetValueAndFlags (workNode, MasterGroup, MEMDB_FLAG_SELECTED, MEMDB_FLAG_SELECTED)) {
            EngineError ();
            return FALSE;
        }

        newComponent = TRUE;
    }

    wsprintf (
        workNode,
        TEXT("%s\\%s\\%s\\%04u"),
        S_COMPONENT_ROOT,
        ComponentString,
        UserSupplied ? S_USER_SUPPLIED : S_MODULE_SUPPLIED,
        ComponentGroupId
        );

    memdbNode = JoinPaths (workNode, LocalizedAlias);

    if (newComponent) {
        b = MemDbSetFlags (memdbNode, MEMDB_FLAG_PREFERRED, MEMDB_FLAG_PREFERRED);
    } else {
        b = MemDbSetKey (memdbNode);
    }

    FreePathString (memdbNode);

    if (!b) {
        EngineError ();
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
IsmSelectComponent (
    IN      PCTSTR ComponentOrAlias,
    IN      UINT ComponentGroupId,      OPTIONAL
    IN      BOOL Enable
    )
{
    PCTSTR memdbNode = NULL;
    UINT flags;
    BOOL b;

    if (ComponentGroupId > 9999) {
        SetLastError (ERROR_INVALID_PARAMETER);
        DEBUGMSG ((DBG_ERROR, "Invalid component group"));
        return FALSE;
    }

    if (!ComponentOrAlias || !ComponentOrAlias[0]) {
        SetLastError (ERROR_INVALID_PARAMETER);
        DEBUGMSG ((DBG_ERROR, "Invalid localized alias"));
        return FALSE;
    }

    if (!ComponentGroupId) {
        if (!pCheckComponentName (ComponentOrAlias)) {
            return FALSE;
        }

        memdbNode = JoinText (S_COMPONENT_ROOT TEXT("\\"), ComponentOrAlias);
        if (!MemDbTestKey (memdbNode)) {
            FreeText (memdbNode);
            return FALSE;
        }

    } else {

        if (!pFindComponent (ComponentOrAlias, ComponentGroupId, &memdbNode, NULL)) {
            SetLastError (ERROR_NO_SUCH_ALIAS);
            return FALSE;
        }
    }

    flags = Enable ? MEMDB_FLAG_SELECTED : 0;
    b = MemDbSetFlags (memdbNode, flags, MEMDB_FLAG_SELECTED);
    FreeText (memdbNode);

    if (!b) {
        EngineError ();
        return FALSE;
    }

    return TRUE;
}


BOOL
pEnumWorker (
    IN OUT  PMIG_COMPONENT_ENUM EnumPtr,
    IN OUT  PCOMPONENTENUM_HANDLE Handle
    )
{
    BOOL result = FALSE;
    PCTSTR pattern;
    PCTSTR p;
    BOOL enabled;

    while (Handle->State != CES_DONE) {

        switch (Handle->State) {

        case CES_FIRST_COMPONENT:

            if (!MemDbEnumFirst (
                    &Handle->ComponentEnumStruct,
                    S_COMPONENT_ROOT TEXT("\\*"),
                    ENUMFLAG_ALL,
                    1,
                    1
                    )) {
                Handle->State = CES_DONE;
            } else {
                if (Handle->EnumAliases) {
                    Handle->State = CES_FIRST_ALIAS;
                } else {
                    Handle->State = CES_NEXT_COMPONENT;
                    result = TRUE;
                }
            }
            break;

        case CES_FIRST_ALIAS:

            enabled = ((Handle->ComponentEnumStruct.Flags  & MEMDB_FLAG_SELECTED) != 0);

            if ((!Handle->EnumEnabled && enabled) ||
                (!Handle->EnumDisabled && !enabled)
                ) {
                Handle->State = CES_NEXT_COMPONENT;
                continue;
            }

            EnumPtr->Instance = 0;

            pattern = JoinPaths (Handle->ComponentEnumStruct.FullKeyName, TEXT("*"));

            if (!MemDbEnumFirst (
                    &Handle->AliasEnumStruct,
                    pattern,
                    ENUMFLAG_NORMAL,
                    4,
                    ENUMLEVEL_ALLLEVELS
                    )) {
                Handle->State = CES_NEXT_COMPONENT;
            } else {
                Handle->State = CES_CHECK_ALIAS_FLAGS;
            }

            FreePathString (pattern);
            break;

        case CES_NEXT_ALIAS:
            if (EnumPtr->SkipToNextComponent) {
                MemDbAbortEnum (&Handle->AliasEnumStruct);
                Handle->State = CES_NEXT_COMPONENT;
                EnumPtr->SkipToNextComponent = FALSE;
                break;
            }

            if (!MemDbEnumNext (&Handle->AliasEnumStruct)) {
                Handle->State = CES_NEXT_COMPONENT;
            } else {
                Handle->State = CES_CHECK_ALIAS_FLAGS;
            }
            break;

        case CES_CHECK_ALIAS_FLAGS:
            EnumPtr->Preferred = ((Handle->AliasEnumStruct.Flags & MEMDB_FLAG_PREFERRED) != 0);
            Handle->State = CES_NEXT_ALIAS;

            if (Handle->EnumPreferredOnly) {
                result = EnumPtr->Preferred;
            } else if (Handle->EnumNonPreferredOnly) {
                result = !EnumPtr->Preferred;
            } else {
                result = TRUE;
            }

            break;

        case CES_NEXT_COMPONENT:
            if (!MemDbEnumNext (&Handle->ComponentEnumStruct)) {
                Handle->State = CES_DONE;
            } else {
                if (Handle->EnumAliases) {
                    Handle->State = CES_FIRST_ALIAS;
                } else {
                    Handle->State = CES_NEXT_COMPONENT;
                    result = TRUE;
                }
            }
            break;

        default:
            Handle->State = CES_DONE;
            break;
        }

        if (result) {

            //
            // Fill in all of the caller enum struct fields
            //

            EnumPtr->SkipToNextComponent = FALSE;
            EnumPtr->ComponentString = Handle->ComponentEnumStruct.KeyName;
            EnumPtr->Enabled = ((Handle->ComponentEnumStruct.Flags  & MEMDB_FLAG_SELECTED) != 0);
            EnumPtr->MasterGroup =  Handle->ComponentEnumStruct.Value;

            if (Handle->EnumAliases) {
                p = _tcschr (Handle->AliasEnumStruct.FullKeyName, TEXT('\\'));
                MYASSERT (p);

                if (p) {
                    p = _tcschr (p + 1, TEXT('\\'));
                    MYASSERT (p);
                }

                if (p) {
                    p++;
                    if (_totlower (p[0]) == TEXT('u')) {
                        EnumPtr->UserSupplied = TRUE;
                    } else {
                        EnumPtr->UserSupplied = FALSE;
                    }

                    p = _tcschr (p, TEXT('\\'));
                    MYASSERT (p);
                }

                if (p) {
                    p++;
                    EnumPtr->GroupId = _tcstoul (p, (PTSTR *) (&p), 10);
                    MYASSERT (p && p[0] == TEXT('\\'));
                }

                if (p) {
                    EnumPtr->LocalizedAlias = p + 1;
                }

                //
                // If group ID filter was specified, loop until a match is found
                //

                if (Handle->GroupIdFilter && Handle->GroupIdFilter != EnumPtr->GroupId) {
                    result = FALSE;
                    continue;
                }

            } else {
                EnumPtr->Preferred = FALSE;
                EnumPtr->UserSupplied = FALSE;
                EnumPtr->GroupId = 0;
                EnumPtr->LocalizedAlias = NULL;
            }

            EnumPtr->Instance++;
            break;
        }
    }

    if (!result) {
        IsmAbortComponentEnum (EnumPtr);
    }

    return result;
}


BOOL
WINAPI
IsmEnumFirstComponent (
    OUT     PMIG_COMPONENT_ENUM EnumPtr,
    IN      DWORD Flags,
    IN      UINT GroupIdFilter                  OPTIONAL
    )
{
    PCOMPONENTENUM_HANDLE handle;

    ZeroMemory (EnumPtr, sizeof (MIG_COMPONENT_ENUM));

    if (Flags & (COMPONENTENUM_PREFERRED_ONLY|COMPONENTENUM_NON_PREFERRED_ONLY)) {
        if (!(Flags & COMPONENTENUM_ALIASES)) {
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if ((Flags & (COMPONENTENUM_PREFERRED_ONLY|COMPONENTENUM_NON_PREFERRED_ONLY)) ==
            (COMPONENTENUM_PREFERRED_ONLY|COMPONENTENUM_NON_PREFERRED_ONLY)
            ) {
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    EnumPtr->Handle = MemAllocUninit (sizeof (COMPONENTENUM_HANDLE));
    handle = (PCOMPONENTENUM_HANDLE) EnumPtr->Handle;
    handle->EnumAliases = Flags & COMPONENTENUM_ALIASES ? TRUE : FALSE;
    handle->EnumEnabled = Flags & COMPONENTENUM_ENABLED ? TRUE : FALSE;
    handle->EnumDisabled = Flags & COMPONENTENUM_DISABLED ? TRUE : FALSE;
    handle->GroupIdFilter = GroupIdFilter;
    handle->EnumPreferredOnly = Flags & COMPONENTENUM_PREFERRED_ONLY;
    handle->EnumNonPreferredOnly = Flags & COMPONENTENUM_NON_PREFERRED_ONLY;

    handle->State = CES_FIRST_COMPONENT;

    return pEnumWorker (EnumPtr, handle);
}


BOOL
WINAPI
IsmEnumNextComponent (
    IN OUT  PMIG_COMPONENT_ENUM EnumPtr
    )
{
    PCOMPONENTENUM_HANDLE handle;

    handle = (PCOMPONENTENUM_HANDLE) EnumPtr->Handle;
    return pEnumWorker (EnumPtr, handle);
}


VOID
WINAPI
IsmAbortComponentEnum (
    IN      PMIG_COMPONENT_ENUM EnumPtr         ZEROED
    )
{
    PCOMPONENTENUM_HANDLE handle;

    handle = (PCOMPONENTENUM_HANDLE) EnumPtr->Handle;
    if (handle) {
        if (handle->State == CES_NEXT_COMPONENT) {
            MemDbAbortEnum (&handle->ComponentEnumStruct);
        }

        if (handle->EnumAliases) {
            if (handle->State == CES_NEXT_ALIAS) {
                MemDbAbortEnum (&handle->AliasEnumStruct);
            }
        }

        FreeAlloc (handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_COMPONENT_ENUM));
}


VOID
WINAPI
IsmRemoveAllUserSuppliedComponents (
    VOID
    )
{
    MEMDB_ENUM e;
    MULTISZ_ENUM listEnum;
    GROWBUFFER list = INIT_GROWBUFFER;

    //
    // Collect all the components that have user-supplied aliases. Then after
    // enum completes, delete them. We don't delete during the enum because it
    // is never a good idea to delete the item just enumerated, and then try
    // to continue enumerating.
    //

    if (MemDbEnumFirst (
            &e,
            S_COMPONENT_ROOT TEXT("\\*\\") S_USER_SUPPLIED TEXT("\\*"),
            ENUMFLAG_ALL,
            2,
            2
            )) {

        do {
            GbMultiSzAppend (&list, e.FullKeyName);
        } while (MemDbEnumNext (&e));
    }

    if (EnumFirstMultiSz (&listEnum, (PCTSTR) list.Buf)) {
        do {
            MemDbDeleteTree (listEnum.CurrentString);
        } while (EnumNextMultiSz (&listEnum));
    }

    GbFree (&list);
}


BOOL
WINAPI
IsmSelectMasterGroup (
    IN      UINT MasterGroup,
    IN      BOOL Enable
    )
{
    MEMDB_ENUM e;
    UINT flags;

    if (MasterGroup > MASTERGROUP_ALL) {
        SetLastError (ERROR_INVALID_PARAMETER);
        DEBUGMSG ((DBG_ERROR, "Can't select invalid MasterGroup"));
        return FALSE;
    }

    //
    // Enumerate all components and mark them enabled or disabled
    // depending on the master group
    //

    if (MemDbEnumFirst (
            &e,
            S_COMPONENT_ROOT TEXT("\\*"),
            ENUMFLAG_NORMAL,
            1,
            1
            )) {

        do {
            if (MasterGroup == MASTERGROUP_ALL ||
                MasterGroup == e.Value
                ) {
                flags = Enable ? MEMDB_FLAG_SELECTED : 0;
            } else {
                flags = 0;
            }

            if (!MemDbSetFlags (e.FullKeyName, flags, MEMDB_FLAG_SELECTED)) {
                EngineError ();
                MemDbAbortEnum (&e);
                return FALSE;
            }

        } while (MemDbEnumNext (&e));
    }

    return TRUE;
}


BOOL
WINAPI
IsmIsComponentSelected (
    IN      PCTSTR ComponentOrAlias,
    IN      UINT ComponentGroupId           OPTIONAL
    )
{
    UINT flags = 0;
    TCHAR memdbNode[MAX_CONTROLLED_NODE_SIZE];
    PCTSTR componentNode;

    if (!ComponentGroupId) {
        if (!pCheckComponentName (ComponentOrAlias)) {
            return FALSE;
        }

        wsprintf (memdbNode, TEXT("%s\\%s"), S_COMPONENT_ROOT, ComponentOrAlias);
        MemDbGetFlags (memdbNode, &flags);
    } else {
        if (pFindComponent (ComponentOrAlias, ComponentGroupId, &componentNode, NULL)) {
            MemDbGetFlags (componentNode, &flags);
            FreeText (componentNode);
        }
    }

    return (flags & MEMDB_FLAG_SELECTED) != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\datatype.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    datatype.c

Abstract:

    Implements all callbacks for data type

Author:

    Calin Negreanu (calinn) 09-Apr-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_DATATYPE        "DataType"

//
// Strings
//

// none

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// none

//
// Globals
//

MIG_OBJECTTYPEID g_DataTypeId = 0;
HASHTABLE g_DataTable = NULL;
GROWBUFFER g_DataConversionBuff = INIT_GROWBUFFER;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

TYPE_CONVERTOBJECTTOMULTISZ ConvertDataToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToData;
TYPE_ACQUIREPHYSICALOBJECT AcquirePhysicalData;
TYPE_RELEASEPHYSICALOBJECT ReleasePhysicalData;

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
DataTypeAddObject (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR ObjectLocation,
    IN      BOOL MakePersistent
    )
{
    PCTSTR objectLocation;
    BOOL result = TRUE;

    objectLocation = DuplicatePathString (ObjectLocation, 0);
    HtAddStringEx (g_DataTable, ObjectName, &objectLocation, FALSE);
    if (MakePersistent) {
        result = IsmMakePersistentObject (g_DataTypeId, ObjectName);
    }

    return result;
}

BOOL
AcquirePhysicalData (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PTSTR objectLocation;
    HASHITEM rc;
    PWIN32_FIND_DATA findData;
#ifndef UNICODE
    PWIN32_FIND_DATAW findDataW;
#endif
    BOOL result = FALSE;

    ObjectContent->Details.DetailsSize = 0;
    ObjectContent->Details.DetailsData = NULL;

    rc = HtFindStringEx (g_DataTable, ObjectName, &objectLocation, FALSE);
    if (rc) {
        if ((ContentType == CONTENTTYPE_ANY) ||
            (ContentType == CONTENTTYPE_FILE) ||
            (ContentType == CONTENTTYPE_DETAILS_ONLY)
            ) {
            ObjectContent->ContentInFile = TRUE;
            ObjectContent->FileContent.ContentPath = objectLocation;
            ObjectContent->FileContent.ContentSize = BfGetFileSize (objectLocation);

            findData = IsmGetMemory (sizeof (WIN32_FIND_DATA));
            if (findData) {
                ZeroMemory (findData, sizeof (WIN32_FIND_DATA));
                if (DoesFileExistEx (objectLocation, findData)) {
                    ObjectContent->Details.DetailsSize = sizeof (WIN32_FIND_DATA);
                    ObjectContent->Details.DetailsData = findData;
#ifndef UNICODE
                    // we need to convert the ANSI findData into UNICODE one
                    findDataW = IsmGetMemory (sizeof (WIN32_FIND_DATAW));
                    if (findDataW) {
                        findDataW->dwFileAttributes = findData->dwFileAttributes;
                        CopyMemory (&(findDataW->ftCreationTime), &(findData->ftCreationTime), sizeof (FILETIME));
                        CopyMemory (&(findDataW->ftLastAccessTime), &(findData->ftLastAccessTime), sizeof (FILETIME));
                        CopyMemory (&(findDataW->ftLastWriteTime), &(findData->ftLastWriteTime), sizeof (FILETIME));
                        findDataW->nFileSizeHigh = findData->nFileSizeHigh;
                        findDataW->nFileSizeLow = findData->nFileSizeLow;
                        findDataW->dwReserved0 = findData->dwReserved0;
                        findDataW->dwReserved1 = findData->dwReserved1;
                        DirectDbcsToUnicodeN (findDataW->cFileName, findData->cFileName, MAX_PATH);
                        DirectDbcsToUnicodeN (findDataW->cAlternateFileName, findData->cAlternateFileName, 14);
                        ObjectContent->Details.DetailsSize = sizeof (WIN32_FIND_DATAW);
                        ObjectContent->Details.DetailsData = findDataW;
                        IsmReleaseMemory (findData);
                    } else {
                        IsmReleaseMemory (findData);
                        ObjectContent->Details.DetailsSize = 0;
                        ObjectContent->Details.DetailsData = NULL;
                    }
#endif
                }
            }
            result = TRUE;
        }
    }
    if (!result) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }
    return result;
}

BOOL
ReleasePhysicalData (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    if (ObjectContent->Details.DetailsData) {
        IsmReleaseMemory (ObjectContent->Details.DetailsData);
    }
    ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    return TRUE;
}

VOID
InitDataType (
    VOID
    )
{
    TYPE_REGISTER dataTypeData;

    g_DataTable = HtAllocWithData (sizeof (PCTSTR));

    ZeroMemory (&dataTypeData, sizeof (TYPE_REGISTER));
    dataTypeData.ConvertObjectToMultiSz = ConvertDataToMultiSz;
    dataTypeData.ConvertMultiSzToObject = ConvertMultiSzToData;
    dataTypeData.AcquirePhysicalObject = AcquirePhysicalData;
    dataTypeData.ReleasePhysicalObject = ReleasePhysicalData;

    g_DataTypeId = IsmRegisterObjectType (
                        S_DATATYPE,
                        FALSE,
                        TRUE,
                        &dataTypeData
                        );
    MYASSERT (g_DataTypeId);
}

VOID
DoneDataType (
    VOID
    )
{
    HASHTABLE_ENUM e;

    if (!g_DataTable) {
        return;
    }

    if (EnumFirstHashTableString (&e, g_DataTable)) {
        do {
            if (e.ExtraData) {
                DeleteFile (*((PCTSTR *) (e.ExtraData)));
                FreePathString (*((PCTSTR *) (e.ExtraData)));
            }
        } while (EnumNextHashTableString (&e));
    }

    HtFree (g_DataTable);
    g_DataTable = NULL;
}

PCTSTR
ConvertDataToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node;
    PCTSTR leaf;
    PTSTR result = NULL;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        g_DataConversionBuff.End = 0;
        GbCopyString (&g_DataConversionBuff, node);
        GbCopyQuotedString (&g_DataConversionBuff, leaf);
        GbCopyString (&g_DataConversionBuff, TEXT(""));

        result = IsmGetMemory (g_DataConversionBuff.End);
        CopyMemory (result, g_DataConversionBuff.Buf, g_DataConversionBuff.End);

        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    return result;
}

BOOL
ConvertMultiSzToData (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    )
{
#define indexExt  0
#define indexFile 1
    MULTISZ_ENUM multiSzEnum;
    PCTSTR dir = NULL;
    PCTSTR file = NULL;
    UINT index = 0;

    g_DataConversionBuff.End = 0;

    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }

    if (EnumFirstMultiSz (&multiSzEnum, ObjectMultiSz)) {
        do {
            if (index == indexExt) {
                dir = multiSzEnum.CurrentString;
            } else if (index == indexFile) {
                file = multiSzEnum.CurrentString;
            }
            index++;
        } while (EnumNextMultiSz (&multiSzEnum));
    }

    if (!file) {
        return FALSE;
    }

    if (ObjectContent) {
        ObjectContent->ObjectTypeId = MIG_FILE_TYPE;
        ObjectContent->ContentInFile = TRUE;
    }

    *ObjectName = IsmCreateObjectHandle(dir, file);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\filetype.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    filetype.c

Abstract:

    Implements all callbacks for file type

Author:

    Calin Negreanu (calinn) 09-Apr-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"
#include <winioctl.h>

#define DBG_FILETYPE        "FileType"

//
// Strings
//

// none

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    HANDLE FileHandle;
    HANDLE MapHandle;
} FILEACQUIREHANDLE, *PFILEACQUIREHANDLE;

//
// Globals
//

MIG_OBJECTTYPEID g_FileTypeId = 0;
GROWBUFFER g_FileConversionBuff = INIT_GROWBUFFER;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstPhysicalFile;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextPhysicalFile;
TYPE_ABORTENUMCURRENTPHYSICALNODE AbortEnumCurrentDir;
TYPE_ABORTENUMPHYSICALOBJECT AbortEnumPhysicalFile;
TYPE_CONVERTOBJECTTOMULTISZ ConvertFileToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToFile;
TYPE_GETNATIVEOBJECTNAME GetNativeFileName;
TYPE_ACQUIREPHYSICALOBJECT AcquirePhysicalFile;
TYPE_RELEASEPHYSICALOBJECT ReleasePhysicalFile;
TYPE_DOESPHYSICALOBJECTEXIST DoesPhysicalFileExist;
TYPE_REMOVEPHYSICALOBJECT RemovePhysicalFile;
TYPE_CREATEPHYSICALOBJECT CreatePhysicalFile;
TYPE_REPLACEPHYSICALOBJECT ReplacePhysicalFile;

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pSetCompression (
    IN      PCTSTR NativePath
    )
{
    HANDLE fileHandle;
    USHORT compression = COMPRESSION_FORMAT_DEFAULT;
    DWORD bytesReturned;

    fileHandle = CreateFile (
                    NativePath,
                    GENERIC_READ|GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
    if (fileHandle != INVALID_HANDLE_VALUE) {
        DeviceIoControl (
            fileHandle,
            FSCTL_SET_COMPRESSION,
            &compression,
            sizeof (USHORT),
            NULL,
            0,
            &bytesReturned,
            NULL
            );
        CloseHandle (fileHandle);
    }

    return FALSE;
}

BOOL
pFileTypeEnumWorker (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PFILETREE_ENUM handle;

    handle = (PFILETREE_ENUM) EnumPtr->EtmHandle;

    EnumPtr->ObjectName = handle->EncodedFullName;
    EnumPtr->NativeObjectName = handle->NativeFullName;
    EnumPtr->Level = handle->CurrentLevel;
    EnumPtr->SubLevel = handle->CurrentLevel - handle->FileEnumInfo.RootLevel;
    EnumPtr->IsNode = (handle->Attributes & FILE_ATTRIBUTE_DIRECTORY);
    EnumPtr->IsLeaf = !EnumPtr->IsNode;
    if (EnumPtr->IsNode) {
        EnumPtr->ObjectNode = EnumPtr->NativeObjectName;
        EnumPtr->ObjectLeaf = NULL;
    } else {
        EnumPtr->ObjectNode = handle->Location;
        EnumPtr->ObjectLeaf = handle->Name;
    }

    MYASSERT ((EnumPtr->ObjectTypeId & ~PLATFORM_MASK) == g_FileTypeId);
    EnumPtr->Details.DetailsData = &handle->LastNode->FindData;

    return TRUE;
}

BOOL
EnumFirstPhysicalFile (
    PMIG_TYPEOBJECTENUM EnumPtr,
    MIG_OBJECTSTRINGHANDLE Pattern,
    UINT MaxLevel
    )
{
    PFILETREE_ENUM handle;
    BOOL result;

    if (!Pattern) {
        return FALSE;
    }

    handle = (PFILETREE_ENUM) IsmGetMemory (sizeof (FILETREE_ENUM));
    EnumPtr->EtmHandle = (LONG_PTR) handle;

    EnumPtr->Details.DetailsSize = sizeof (WIN32_FIND_DATA);

    result = EnumFirstFileInTreeEx (
                handle,
                Pattern,
                DRIVEENUM_FIXED,
                TRUE,
                TRUE,
                TRUE,
                TRUE,
                MaxLevel == NODE_LEVEL_MAX ? FILEENUM_ALL_SUBLEVELS : MaxLevel,
                FALSE,
                NULL
                );

    if (result) {
        result = pFileTypeEnumWorker (EnumPtr);
    } else {
        AbortEnumPhysicalFile (EnumPtr);
    }

    return result;
}

BOOL
EnumNextPhysicalFile (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PFILETREE_ENUM handle;
    BOOL result;

    handle = (PFILETREE_ENUM) EnumPtr->EtmHandle;

    result = EnumNextFileInTree (handle);

    if (result) {
        result = pFileTypeEnumWorker (EnumPtr);
    } else {
        AbortEnumPhysicalFile (EnumPtr);
    }

    return result;
}

VOID
AbortEnumCurrentDir (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PFILETREE_ENUM handle;

    handle = (PFILETREE_ENUM) EnumPtr->EtmHandle;

    if (handle) {
        handle->ControlFlags |= FECF_SKIPSUBDIRS|FECF_SKIPFILES;
    }
}

VOID
AbortEnumPhysicalFile (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PFILETREE_ENUM handle;

    handle = (PFILETREE_ENUM) EnumPtr->EtmHandle;

    if (handle) {
        AbortEnumFileInTree (handle);
        IsmReleaseMemory (handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}

PCTSTR
ConvertFileToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node, leaf;
    PWIN32_FIND_DATAW findData;
    DWORD size;
    PTSTR result = NULL;
    BOOL bresult = TRUE;
    PCSTR convertedStr;
    TCHAR buff[3];

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        g_FileConversionBuff.End = 0;

        GbCopyString (&g_FileConversionBuff, TEXT("\""));
        GbAppendString (&g_FileConversionBuff, node);
        if (leaf) {
            GbAppendString (&g_FileConversionBuff, TEXT("\\"));
            GbAppendString (&g_FileConversionBuff, leaf);
            GbAppendString (&g_FileConversionBuff, TEXT("\""));
        } else {
            GbAppendString (&g_FileConversionBuff, TEXT("\""));
        }

        MYASSERT (ObjectContent->Details.DetailsSize == sizeof (WIN32_FIND_DATAW));
        if ((ObjectContent->Details.DetailsSize == sizeof (WIN32_FIND_DATAW)) &&
            (ObjectContent->Details.DetailsData)
            ) {

            // let's save the WIN32_FIND_DATAW structure
            findData = (PWIN32_FIND_DATAW)ObjectContent->Details.DetailsData;
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->dwFileAttributes
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->ftCreationTime.dwLowDateTime
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->ftCreationTime.dwHighDateTime
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->ftLastAccessTime.dwLowDateTime
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->ftLastAccessTime.dwHighDateTime
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->ftLastWriteTime.dwLowDateTime
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->ftLastWriteTime.dwHighDateTime
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->nFileSizeHigh
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->nFileSizeLow
                );
#ifdef UNICODE
            GbCopyQuotedString (&g_FileConversionBuff, findData->cFileName);
            GbCopyQuotedString (&g_FileConversionBuff, findData->cAlternateFileName);
#else
            convertedStr = ConvertWtoA (findData->cFileName);
            if (convertedStr) {
                GbCopyQuotedString (&g_FileConversionBuff, convertedStr);
                FreeConvertedStr (convertedStr);
            } else {
                GbCopyQuotedString (&g_FileConversionBuff, TEXT(""));
            }
            convertedStr = ConvertWtoA (findData->cAlternateFileName);
            if (convertedStr) {
                GbCopyQuotedString (&g_FileConversionBuff, convertedStr);
                FreeConvertedStr (convertedStr);
            } else {
                GbCopyQuotedString (&g_FileConversionBuff, TEXT(""));
            }
#endif
            if ((!ObjectContent->ContentInFile) &&
                (ObjectContent->MemoryContent.ContentSize) &&
                (ObjectContent->MemoryContent.ContentBytes)
                ) {
                // write it in binary format
                size = 0;
                while (size < ObjectContent->MemoryContent.ContentSize) {
                    wsprintf (
                        buff,
                        TEXT("%2X"),
                        ObjectContent->MemoryContent.ContentBytes [size]
                        );
                    GbCopyString (&g_FileConversionBuff, buff);
                    size ++;
                }
            }

        } else {
            bresult = FALSE;
        }

        if (bresult) {
            GbCopyString (&g_FileConversionBuff, TEXT(""));
            result = IsmGetMemory (g_FileConversionBuff.End);
            CopyMemory (result, g_FileConversionBuff.Buf, g_FileConversionBuff.End);
        }

        g_FileConversionBuff.End = 0;

        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    return result;
}

BOOL
ConvertMultiSzToFile (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    )
{
#define indexFile   0
#define indexAttr   1
#define indexCtLdt  2
#define indexCtHdt  3
#define indexAtLdt  4
#define indexAtHdt  5
#define indexWtLdt  6
#define indexWtHdt  7
#define indexFsh    8
#define indexFsl    9
#define indexCFile  10
#define indexAFile  11
#define indexData   12
    MULTISZ_ENUM multiSzEnum;
    PCTSTR file = NULL;
    WIN32_FIND_DATAW findData;
    DWORD dummy;
    PTSTR filePtr, dirPtr;
    UINT index;

    g_FileConversionBuff.End = 0;

    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }

    ZeroMemory (&findData, sizeof (WIN32_FIND_DATAW));

    if (EnumFirstMultiSz (&multiSzEnum, ObjectMultiSz)) {
        index = 0;
        do {
            if (index == indexFile) {
                file = multiSzEnum.CurrentString;
            }
            if (index == indexAttr) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.dwFileAttributes));
            }
            if (index == indexCtLdt) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.ftCreationTime.dwLowDateTime));
            }
            if (index == indexCtHdt) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.ftCreationTime.dwHighDateTime));
            }
            if (index == indexAtLdt) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.ftLastAccessTime.dwLowDateTime));
            }
            if (index == indexAtHdt) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.ftLastAccessTime.dwHighDateTime));
            }
            if (index == indexWtLdt) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.ftLastWriteTime.dwLowDateTime));
            }
            if (index == indexWtHdt) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.ftLastWriteTime.dwHighDateTime));
            }
            if (index == indexFsh) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.nFileSizeHigh));
            }
            if (index == indexFsl) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.nFileSizeLow));
            }
            if (index == indexCFile) {
                if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
#ifdef UNICODE
                    StringCopyTcharCount (findData.cFileName, multiSzEnum.CurrentString, MAX_PATH);
#else
                    DirectDbcsToUnicodeN (findData.cFileName, multiSzEnum.CurrentString, MAX_PATH);
#endif
                }
            }
            if (index == indexAFile) {
                if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
#ifdef UNICODE
                    StringCopyTcharCount (findData.cAlternateFileName, multiSzEnum.CurrentString, 14);
#else
                    DirectDbcsToUnicodeN (findData.cAlternateFileName, multiSzEnum.CurrentString, 14);
#endif
                }
            }
            if (index >= indexData) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                *((PBYTE)GbGrow (&g_FileConversionBuff, sizeof (BYTE))) = (BYTE)dummy;
            }
            index ++;
        } while (EnumNextMultiSz (&multiSzEnum));
    }

    if (!file) {
        return FALSE;
    }

    if (ObjectContent) {

        ObjectContent->ObjectTypeId = MIG_FILE_TYPE;

        if (g_FileConversionBuff.End == 0) {
            ObjectContent->ContentInFile = TRUE;
            ObjectContent->FileContent.ContentSize = ((LONGLONG) findData.nFileSizeHigh << 32) | findData.nFileSizeLow;
        } else {
            ObjectContent->ContentInFile = FALSE;
            ObjectContent->MemoryContent.ContentSize = g_FileConversionBuff.End;
            ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            CopyMemory (
                (PBYTE)ObjectContent->MemoryContent.ContentBytes,
                g_FileConversionBuff.Buf,
                ObjectContent->MemoryContent.ContentSize
                );
            g_FileConversionBuff.End = 0;
        }

        ObjectContent->Details.DetailsSize = sizeof (WIN32_FIND_DATAW);
        ObjectContent->Details.DetailsData = IsmGetMemory (sizeof (WIN32_FIND_DATAW));
        CopyMemory ((PBYTE)ObjectContent->Details.DetailsData, &findData, sizeof (WIN32_FIND_DATAW));
    }

    if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        *ObjectName = IsmCreateObjectHandle (file, NULL);
    } else {
        dirPtr = DuplicatePathString (file, 0);
        filePtr = _tcsrchr (dirPtr, TEXT('\\'));
        if (filePtr) {
            *filePtr = 0;
            filePtr ++;
        }
        *ObjectName = IsmCreateObjectHandle (dirPtr, filePtr);
        FreePathString (dirPtr);
    }

    return TRUE;
}

PCTSTR
GetNativeFileName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node = NULL, leaf = NULL, tmp = NULL;
    UINT size;
    PTSTR result = NULL;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (node) {
            tmp = JoinPaths (node, leaf);
        } else {
            tmp = DuplicatePathString (leaf, 0);
        }
        if (tmp) {
            size = SizeOfString (tmp);
            if (size) {
                result = IsmGetMemory (size);
                CopyMemory (result, tmp, size);
            }
            FreePathString (tmp);
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
pIsDriveOnly (
    IN      PCTSTR FileName
    )
{
    return (FileName && FileName[0] && (FileName[1]==TEXT(':')) && (!FileName[2]));
}

BOOL
AcquirePhysicalFile (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PFILEACQUIREHANDLE handle;
    PWIN32_FIND_DATA findData;
#ifndef UNICODE
    PWIN32_FIND_DATAW findDataW;
#endif
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    PTSTR nativeFileName = NULL;
    BOOL result = FALSE;

    __try {

        handle = IsmGetMemory (sizeof (FILEACQUIREHANDLE));
        ZeroMemory (handle, sizeof (FILEACQUIREHANDLE));
        ObjectContent->EtmHandle = handle;

        findData = IsmGetMemory (sizeof (WIN32_FIND_DATA));
        ZeroMemory (findData, sizeof (WIN32_FIND_DATA));
        ObjectContent->Details.DetailsSize = sizeof (WIN32_FIND_DATA);
        ObjectContent->Details.DetailsData = findData;

        ObsSplitObjectString (ObjectName, &node, &leaf);
        nativeFileName = JoinPaths (node, leaf);

        if (!nativeFileName) {
            __leave;
        }

        if (pIsDriveOnly (nativeFileName)) {
            switch (ContentType) {
                case CONTENTTYPE_MEMORY:
                    ObjectContent->ContentInFile = FALSE;
                    result = TRUE;
                    break;
                case CONTENTTYPE_DETAILS_ONLY:
                case CONTENTTYPE_FILE:
                case CONTENTTYPE_ANY:
                    ObjectContent->ContentInFile = TRUE;
                    result = TRUE;
                    break;
                default:
                    DEBUGMSG ((DBG_WHOOPS, "Illegal ContentType in AcquirePhysicalFile: %d", ContentType));
            }
            findData->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
            StringCopy (findData->cFileName, nativeFileName);
            StringCopy (findData->cAlternateFileName, nativeFileName);

        } else if (DoesFileExistEx (nativeFileName, findData)) {
            if (findData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                switch (ContentType) {
                    case CONTENTTYPE_MEMORY:
                        ObjectContent->ContentInFile = FALSE;
                        result = TRUE;
                        break;
                    case CONTENTTYPE_DETAILS_ONLY:
                    case CONTENTTYPE_FILE:
                    case CONTENTTYPE_ANY:
                        ObjectContent->ContentInFile = TRUE;
                        result = TRUE;
                        break;
                    default:
                        DEBUGMSG ((DBG_WHOOPS, "Illegal ContentType in AcquirePhysicalFile: %d", ContentType));
                }
            } else {
                switch (ContentType) {
                    case CONTENTTYPE_MEMORY:
                        ObjectContent->ContentInFile = FALSE;
                        if ((!MemoryContentLimit) ||
                            ((MemoryContentLimit >= findData->nFileSizeLow) &&
                             (!findData->nFileSizeHigh)
                             )
                            ) {

                            ObjectContent->MemoryContent.ContentBytes = MapFileIntoMemory (
                                                                            nativeFileName,
                                                                            &handle->FileHandle,
                                                                            &handle->MapHandle
                                                                            );
                            if (ObjectContent->MemoryContent.ContentBytes) {
                                ObjectContent->MemoryContent.ContentSize = findData->nFileSizeLow;
                                result = TRUE;
                            } else {
                                if (findData->nFileSizeLow == 0) {
                                    result = TRUE;
                                }
                            }
                        }
                        break;
                    case CONTENTTYPE_DETAILS_ONLY:
                    case CONTENTTYPE_FILE:
                    case CONTENTTYPE_ANY:
                        ObjectContent->ContentInFile = TRUE;
                        ObjectContent->FileContent.ContentPath = PmDuplicateString (g_IsmPool, nativeFileName);
                        ObjectContent->FileContent.ContentSize = (LONGLONG) ((PWIN32_FIND_DATA)(ObjectContent->Details.DetailsData))->nFileSizeLow +
                                                                ((LONGLONG) ((PWIN32_FIND_DATA)(ObjectContent->Details.DetailsData))->nFileSizeHigh * 0x100000000);
                        result = TRUE;
                        break;
                    default:
                        DEBUGMSG ((DBG_WHOOPS, "Illegal ContentType in AcquirePhysicalFile: %d", ContentType));
                }
            }
        }
    }
    __finally {
        if (nativeFileName) {
            FreePathString (nativeFileName);
            nativeFileName = NULL;
        }

        ObsFree (node);
        node = NULL;

        ObsFree (leaf);
        leaf = NULL;
    }

    if (!result) {
        IsmReleaseMemory (findData);
        findData = NULL;
        IsmReleaseMemory (handle);
        handle = NULL;
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    } else {
#ifndef UNICODE
        // we need to convert the ANSI findData into UNICODE one
        findDataW = IsmGetMemory (sizeof (WIN32_FIND_DATAW));
        if (findDataW) {
            findDataW->dwFileAttributes = findData->dwFileAttributes;
            CopyMemory (&(findDataW->ftCreationTime), &(findData->ftCreationTime), sizeof (FILETIME));
            CopyMemory (&(findDataW->ftLastAccessTime), &(findData->ftLastAccessTime), sizeof (FILETIME));
            CopyMemory (&(findDataW->ftLastWriteTime), &(findData->ftLastWriteTime), sizeof (FILETIME));
            findDataW->nFileSizeHigh = findData->nFileSizeHigh;
            findDataW->nFileSizeLow = findData->nFileSizeLow;
            findDataW->dwReserved0 = findData->dwReserved0;
            findDataW->dwReserved1 = findData->dwReserved1;
            DirectDbcsToUnicodeN (findDataW->cFileName, findData->cFileName, MAX_PATH);
            DirectDbcsToUnicodeN (findDataW->cAlternateFileName, findData->cAlternateFileName, 14);
            ObjectContent->Details.DetailsSize = sizeof (WIN32_FIND_DATAW);
            ObjectContent->Details.DetailsData = findDataW;
            IsmReleaseMemory (findData);
        } else {
            IsmReleaseMemory (findData);
            ObjectContent->Details.DetailsSize = 0;
            ObjectContent->Details.DetailsData = NULL;
        }
#endif
    }
    return result;
}

BOOL
ReleasePhysicalFile (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PFILEACQUIREHANDLE handle;
    BOOL result = TRUE;

    handle = (PFILEACQUIREHANDLE) ObjectContent->EtmHandle;

    if (handle) {
        if (ObjectContent->ContentInFile) {
            if (ObjectContent->FileContent.ContentPath) {
                IsmReleaseMemory (ObjectContent->FileContent.ContentPath);
            }
        } else {
            if (ObjectContent->MemoryContent.ContentBytes) {
                if (handle->FileHandle && handle->MapHandle) {
                    UnmapFile (
                        ObjectContent->MemoryContent.ContentBytes,
                        handle->MapHandle,
                        handle->FileHandle
                        );
                }
            }
        }
        IsmReleaseMemory (handle);
    }
    if (ObjectContent->Details.DetailsData) {
        IsmReleaseMemory (ObjectContent->Details.DetailsData);
    }
    ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    return result;
}

BOOL
DoesPhysicalFileExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    PTSTR nativeFileName = NULL;
    BOOL result;

    ObsSplitObjectString (ObjectName, &node, &leaf);
    nativeFileName = JoinPaths (node, leaf);

    if (pIsDriveOnly (nativeFileName)) {
        result = TRUE;
    } else {
        result = DoesFileExist (nativeFileName);
    }

    FreePathString (nativeFileName);
    nativeFileName = NULL;

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    return result;
}

BOOL
RemovePhysicalFile (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    PTSTR nativeFileName = NULL;
    WIN32_FIND_DATA findData;
    BOOL result = FALSE;

    ObsSplitObjectString (ObjectName, &node, &leaf);
    nativeFileName = JoinPaths (node, leaf);

    if (pIsDriveOnly (nativeFileName)) {
        result = TRUE;
    } else if (DoesFileExistEx (nativeFileName, &findData)) {
        if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            // we do attempt to remove empty directories.
            // there is no problem in recording an operation that
            // will potentially fail (if the dir is not empty).
            IsmRecordOperation (
                JRNOP_DELETE,
                g_FileTypeId,
                ObjectName
                );

            result = RemoveDirectory (nativeFileName);
        } else {
            if (SetFileAttributes (nativeFileName, FILE_ATTRIBUTE_NORMAL)) {

                // record file deletion
                IsmRecordOperation (
                    JRNOP_DELETE,
                    g_FileTypeId,
                    ObjectName
                    );

                result = DeleteFile (nativeFileName);
            } else {
                PushError ();
                SetFileAttributes (nativeFileName, findData.dwFileAttributes);
                PopError ();
            }
        }
    } else {
        SetLastError (ERROR_FILE_NOT_FOUND);
    }

    PushError ();

    FreePathString (nativeFileName);
    nativeFileName = NULL;

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    PopError ();

    return result;
}

BOOL
pTrackedCreateDirectory (
    IN      PCTSTR DirName
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    PTSTR pathCopy;
    PTSTR p;
    BOOL result = TRUE;

    pathCopy = DuplicatePathString (DirName, 0);

    //
    // Advance past first directory
    //

    if (pathCopy[1] == TEXT(':') && pathCopy[2] == TEXT('\\')) {
        //
        // <drive>:\ case
        //

        p = _tcschr (&pathCopy[3], TEXT('\\'));

    } else if (pathCopy[0] == TEXT('\\') && pathCopy[1] == TEXT('\\')) {

        //
        // UNC case
        //

        p = _tcschr (pathCopy + 2, TEXT('\\'));
        if (p) {
            p = _tcschr (p + 1, TEXT('\\'));
        }

    } else {

        //
        // Relative dir case
        //

        p = _tcschr (pathCopy, TEXT('\\'));
    }

    //
    // Make all directories along the path
    //

    while (p) {

        *p = 0;

        if (!DoesFileExist (pathCopy)) {

            // record directory creation
            objectName = IsmCreateObjectHandle (pathCopy, NULL);
            IsmRecordOperation (
                JRNOP_CREATE,
                g_FileTypeId,
                objectName
                );
            IsmDestroyObjectHandle (objectName);

            result = CreateDirectory (pathCopy, NULL);
            if (!result) {
                break;
            }
        }

        *p = TEXT('\\');
        p = _tcschr (p + 1, TEXT('\\'));
    }

    //
    // At last, make the FullPath directory
    //

    if (result) {
        if (!DoesFileExist (pathCopy)) {

            // record directory creation
            objectName = IsmCreateObjectHandle (pathCopy, NULL);
            IsmRecordOperation (
                JRNOP_CREATE,
                g_FileTypeId,
                objectName
                );
            IsmDestroyObjectHandle (objectName);

            result = CreateDirectory (pathCopy, NULL);
        } else {
            result = FALSE;
            SetLastError (ERROR_ALREADY_EXISTS);
        }
    }

    FreePathString (pathCopy);

    return result;
}

BOOL
pSetFileTime (
    IN      PCTSTR FileName,
    IN      FILETIME *CreationTime,
    IN      FILETIME *LastAccessTime,
    IN      FILETIME *LastWriteTime
    )
{
    HANDLE fileHandle;
    BOOL result = FALSE;

    fileHandle = BfOpenFile (FileName);
    if (fileHandle) {
        result = SetFileTime (fileHandle, CreationTime, LastAccessTime, LastWriteTime);
        CloseHandle (fileHandle);
    }
    return result;
}

BOOL
CreatePhysicalFile (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    PTSTR nativeFileName = NULL;
    PWIN32_FIND_DATAW findData;
    HANDLE fileHandle;
    BOOL result = FALSE;
    DWORD attribs;

    if (!ObjectContent) {
        return FALSE;
    }

    ObsSplitObjectString (ObjectName, &node, &leaf);
    nativeFileName = JoinPaths (node, leaf);

    findData = (PWIN32_FIND_DATAW) (ObjectContent->Details.DetailsData);
    MYASSERT (findData);

    if (pIsDriveOnly (nativeFileName)) {
        result = TRUE;
    } else {
        if (!DoesFileExist (nativeFileName)) {

            if (findData) {
                if (findData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    if (pTrackedCreateDirectory (nativeFileName)) {
                        result = SetFileAttributes (nativeFileName, findData->dwFileAttributes);
                        if (!result) {
                            PushError ();
                            RemoveDirectory (nativeFileName);
                            PopError ();
                        }
                        if (result) {
                            if (findData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) {
                                pSetCompression (nativeFileName);
                            }
                        }
                        if (result) {
                            pSetFileTime (
                                nativeFileName,
                                &findData->ftCreationTime,
                                &findData->ftLastAccessTime,
                                &findData->ftLastWriteTime
                                );
                        }
                    }
                } else {
                    if (ObjectContent->ContentInFile) {

                        pTrackedCreateDirectory (node);

                        // record file creation
                        IsmRecordOperation (
                            JRNOP_CREATE,
                            g_FileTypeId,
                            ObjectName
                            );

                        if (ObjectContent->FileContent.ContentPath) {
                            if (CopyFile (ObjectContent->FileContent.ContentPath, nativeFileName, TRUE)) {

                                result = SetFileAttributes (nativeFileName, findData->dwFileAttributes);
                                if (!result) {
                                    PushError ();
                                    DeleteFile (nativeFileName);
                                    PopError ();
                                }
                                if (result) {
                                    if (findData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) {
                                        pSetCompression (nativeFileName);
                                    }
                                }
                                if (result) {
                                    pSetFileTime (
                                        nativeFileName,
                                        &findData->ftCreationTime,
                                        &findData->ftLastAccessTime,
                                        &findData->ftLastWriteTime
                                        );
                                }
                            }
                        } else {
                            // just an empty  file
                            fileHandle = BfCreateFile (nativeFileName);
                            if (fileHandle) {

                                CloseHandle (fileHandle);
                                result = SetFileAttributes (nativeFileName, findData->dwFileAttributes);
                                if (!result) {
                                    PushError ();
                                    DeleteFile (nativeFileName);
                                    PopError ();
                                }
                                if (result) {
                                    if (findData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) {
                                        pSetCompression (nativeFileName);
                                    }
                                }
                                if (result) {
                                    pSetFileTime (
                                        nativeFileName,
                                        &findData->ftCreationTime,
                                        &findData->ftLastAccessTime,
                                        &findData->ftLastWriteTime
                                        );
                                }
                            }
                        }
                    } else {
                        pTrackedCreateDirectory (node);

                        // record file creation
                        IsmRecordOperation (
                            JRNOP_CREATE,
                            g_FileTypeId,
                            ObjectName
                            );

                        fileHandle = BfCreateFile (nativeFileName);
                        if (fileHandle) {

                            result = BfWriteFile (fileHandle, ObjectContent->MemoryContent.ContentBytes, ObjectContent->MemoryContent.ContentSize);
                            CloseHandle (fileHandle);

                            if (!result) {
                                DeleteFile (nativeFileName);
                            } else {
                                result = SetFileAttributes (nativeFileName, findData->dwFileAttributes);
                                if (!result) {
                                    PushError ();
                                    DeleteFile (nativeFileName);
                                    PopError ();
                                }
                                if (result) {
                                    if (findData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) {
                                        pSetCompression (nativeFileName);
                                    }
                                }
                                if (result) {
                                    pSetFileTime (
                                        nativeFileName,
                                        &findData->ftCreationTime,
                                        &findData->ftLastAccessTime,
                                        &findData->ftLastWriteTime
                                        );
                                }
                            }
                        }
                    }
                }
            } else {
                SetLastError (ERROR_INVALID_DATA);
            }
        } else {
            SetLastError (ERROR_ALREADY_EXISTS);
        }
    }

    PushError ();

    FreePathString (nativeFileName);
    nativeFileName = NULL;

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    PopError ();

    return result;
}

BOOL
ReplacePhysicalFile (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    PTSTR nativeFileName = NULL;
    PWIN32_FIND_DATAW findData;
    BOOL result = FALSE;
    DWORD attribs;

    if (!ObjectContent) {
        return FALSE;
    }

    ObsSplitObjectString (ObjectName, &node, &leaf);
    nativeFileName = JoinPaths (node, leaf);

    findData = (PWIN32_FIND_DATAW) (ObjectContent->Details.DetailsData);
    MYASSERT (findData);

    if (pIsDriveOnly (nativeFileName)) {
        result = TRUE;
    } else {
        if (leaf) {
            result = TRUE;
            if (DoesPhysicalFileExist (ObjectName)) {
                result = RemovePhysicalFile (ObjectName);
            }
            if (result) {
                result = CreatePhysicalFile (ObjectName, ObjectContent);
            }
        } else {
            if (DoesPhysicalFileExist (ObjectName)) {
                if (findData) {
                    result = SetFileAttributes (nativeFileName, findData->dwFileAttributes);
                    if (result) {
                        if (findData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) {
                            pSetCompression (nativeFileName);
                        }
                    }
                    if (result) {
                        pSetFileTime (
                            nativeFileName,
                            &findData->ftCreationTime,
                            &findData->ftLastAccessTime,
                            &findData->ftLastWriteTime
                            );
                    }
                } else {
                    SetLastError (ERROR_INVALID_DATA);
                }
            } else {
                result = CreatePhysicalFile (ObjectName, ObjectContent);
            }
        }
    }

    PushError ();

    FreePathString (nativeFileName);
    nativeFileName = NULL;

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    PopError ();

    return result;
}

VOID
InitFileType (
    VOID
    )
{
    TYPE_REGISTER fileTypeData;

    ZeroMemory (&fileTypeData, sizeof (TYPE_REGISTER));

    fileTypeData.EnumFirstPhysicalObject = EnumFirstPhysicalFile;
    fileTypeData.EnumNextPhysicalObject = EnumNextPhysicalFile;
    fileTypeData.AbortEnumCurrentPhysicalNode = AbortEnumCurrentDir;
    fileTypeData.AbortEnumPhysicalObject = AbortEnumPhysicalFile;
    fileTypeData.ConvertObjectToMultiSz = ConvertFileToMultiSz;
    fileTypeData.ConvertMultiSzToObject = ConvertMultiSzToFile;
    fileTypeData.GetNativeObjectName = GetNativeFileName;
    fileTypeData.AcquirePhysicalObject = AcquirePhysicalFile;
    fileTypeData.ReleasePhysicalObject = ReleasePhysicalFile;
    fileTypeData.DoesPhysicalObjectExist = DoesPhysicalFileExist;
    fileTypeData.RemovePhysicalObject = RemovePhysicalFile;
    fileTypeData.CreatePhysicalObject = CreatePhysicalFile;
    fileTypeData.ReplacePhysicalObject = ReplacePhysicalFile;

    g_FileTypeId = IsmRegisterObjectType (
                        S_FILETYPE,
                        TRUE,
                        FALSE,
                        &fileTypeData
                        );
    MYASSERT (g_FileTypeId);
}

VOID
DoneFileType (
    VOID
    )
{
    GbFree (&g_FileConversionBuff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\ism.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ism.c

Abstract:

    Implements routines that are common to the entire ISM.

Author:

    Jim Schmidt (jimschm) 21-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"
#include "modules.h"

#define DBG_ISM     "Ism"

//
// Strings
//

#define S_LOCK_KEY          TEXT("Locks\\%X")
#define S_TRANSPORT_TYPES   TEXT("TransportTypes")
#define S_DATABASEFILE_LITE TEXT("|MainDatabaseFile\\LITE")   // pipe is to decorate for uniqueness
#define S_DATABASEFILE_FULL TEXT("|MainDatabaseFile\\Full")   // pipe is to decorate for uniqueness

#define S_VER_OSTYPE        TEXT("OsVersionType")
#define S_VER_OSMAJOR       TEXT("OsVersionMajor")
#define S_VER_OSMINOR       TEXT("OsVersionMinor")
#define S_VER_OSBUILD       TEXT("OsVersionBuild")

//
// Constants
//

#define ISM_TMP_SIGNATURE       0x544D5355

#define OBJECT_LOCKED           0x00000001
#define GROUP_ID                0x00000001
#define ITEM_ID                 0x00000002

//
// Macros
//

// None

//
// Types
//

typedef struct {
    MEMDB_ENUM MemDbEnum;
    DBENUM_ARGS ParsedPatterns;
} OBJECTENUM_HANDLE, *POBJECTENUM_HANDLE;

typedef enum {
    TESTATE_BEGINTRANSPORT,
    TESTATE_GETCAPS,
    TESTATE_RETURN,
    TESTATE_NEXTTRANSPORTTYPE,
    TESTATE_NEXTTRANSPORT,
    TESTATE_DONE
} TRANSPORTENUMSTATE;

typedef struct {
    HASHTABLE_ENUM TableEnum;
    MEMDB_ENUM MemDbEnum;
    TRANSPORTENUMSTATE State;
    MIG_TRANSPORTSTORAGEID DesiredStorageId;
} TRANSPORTENUMHANDLE, *PTRANSPORTENUMHANDLE;

typedef struct {
    UINT SliceSize;
    UINT CurrentPosition;
    UINT SliceSizeInSeconds;
} PROGSLICE, *PPROGSLICE;

//
// Globals
//

MIG_OBJECTCOUNT g_TotalObjects;
MIG_OBJECTCOUNT g_SourceObjects;
MIG_OBJECTCOUNT g_DestinationObjects;
HANDLE g_CancelEvent;
HANDLE g_ActivityEvent;
HASHTABLE g_TransportTable;
HASHTABLE g_ControlFileTable;
PMHANDLE g_IsmPool;
PMHANDLE g_IsmUntrackedPool;
HINF g_IsmInf = INVALID_HANDLE_VALUE;
PCTSTR g_CurrentGroup = NULL;
UINT g_IsmCurrentPlatform = PLATFORM_CURRENT;
UINT g_IsmModulePlatformContext = PLATFORM_CURRENT;
PRESTORE_STRUCT g_RestoreCallbacks = NULL;
PMESSAGECALLBACK g_MessageCallback;
PTRANSPORTDATA g_SelectedTransport;
MIG_TRANSPORTSTORAGEID g_SelectedTransportId;
GROWBUFFER g_SliceBuffer;
MIG_PROGRESSPHASE g_CurrentPhase;
PPROGRESSBARFN g_ProgressBarFn;
ULONG_PTR g_ProgressBarArg;
MIG_TRANSPORTTYPE g_TransportType = 0;
PTEMPORARYPROFILE g_TempProfile;
PMIG_LOGCALLBACK g_LogCallback;
PCTSTR g_JournalDirectory = NULL;
BOOL g_PreserveJournal = FALSE;
HANDLE g_JournalHandle = NULL;
BOOL g_RollbackMode = FALSE;
BOOL g_JournalUsed = FALSE;
BOOL g_ExecutionInProgress = FALSE;
PCTSTR g_DelayedOperationsCommand = NULL;
BOOL g_EngineInitialized;
BOOL g_EngineTerminated;
BOOL g_MakeProfilePermanent = FALSE;

// temporary storage
TCHAR g_GlobalTempDir [MAX_PATH] = TEXT("");
UINT g_TempDirIndex = 0;
UINT g_TempFileIndex = 0;

// execute
HASHTABLE g_PreProcessTable = NULL;
HASHTABLE g_RefreshTable = NULL;
HASHTABLE g_PostProcessTable = NULL;
BOOL g_PreProcessDone = FALSE;

#ifdef PRERELEASE
// crash hooks
MIG_OBJECTTYPEID g_CrashCountTypeId = 0;
DWORD g_CrashCountType = 0;
DWORD g_CrashCountObjects = 0;
MIG_OBJECTTYPEID g_CrashNameTypeId = 0;
PCTSTR g_CrashNameObject = NULL;
#endif

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

VOID
pCallProgressBar (
    IN      MIG_PROGRESSSTATE State
    );

BOOL
pEnumFirstTransportType (
    OUT     PMEMDB_ENUM EnumPtr
    );

BOOL
pEnumNextTransportType (
    IN OUT  PMEMDB_ENUM EnumPtr
    );

VOID
pAbortTransportTypeEnum (
    IN OUT  PMEMDB_ENUM EnumPtr
    );

BOOL
pEnumFirstVirtualObject (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern
    );

BOOL
pEnumNextVirtualObject (
    IN OUT  PMIG_OBJECT_ENUM ObjectEnum
    );

VOID
pAbortVirtualObjectEnum (
    IN      PMIG_OBJECT_ENUM ObjectEnum
    );

BOOL
pEnablePrivilege (
    IN PCTSTR PrivilegeName,
    IN BOOL   Enable
    );

VOID
pFreeRestoreCallbacks (
    VOID
    );

VOID
pRecordUserData (
    IN      PCTSTR UserName,
    IN      PCTSTR UserDomain,
    IN      PCTSTR UserStringSid,
    IN      PCTSTR UserProfilePath,
    IN      BOOL ProfileCreated
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        g_hInst = hInstance;
    }
    return TRUE;
}


BOOL
CheckCancel (
    VOID
    )
{
    BOOL cancelled;

    if (g_EngineTerminated) {
        SetLastError (ERROR_REQUEST_ABORTED);
        DEBUGMSG ((DBG_ERROR, "CheckCancel called after engine was terminated"));
        return TRUE;
    }

    if (!g_EngineInitialized) {
        SetLastError (ERROR_REQUEST_ABORTED);
        DEBUGMSG ((DBG_WARNING, "Engine is not initialized"));
        return TRUE;
    }

    cancelled = (WaitForSingleObject (g_CancelEvent, 0) == WAIT_OBJECT_0);

    if (cancelled) {
        SetLastError (ERROR_CANCELLED);
        DEBUGMSG ((DBG_ISM, "Cancel signaled"));
    }

    return cancelled;
}

MIG_OBJECTTYPEID
FixObjectTypeId (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_CURRENT) {
        return (ObjectTypeId | g_IsmCurrentPlatform);
    }
    return ObjectTypeId;
}


MIG_OBJECTTYPEID
FixEnumerationObjectTypeId (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_CURRENT) {
        if (g_IsmModulePlatformContext == PLATFORM_CURRENT) {
            return (ObjectTypeId | g_IsmCurrentPlatform);
        } else {
            return (ObjectTypeId | g_IsmModulePlatformContext);
        }
    }
    return ObjectTypeId;
}


BOOL
pEnablePrivilege (
    IN PCTSTR PrivilegeName,
    IN BOOL   Enable
    )
{
    HANDLE token;
    BOOL b;
    TOKEN_PRIVILEGES newPrivileges;
    LUID luid;

    if (ISWIN9X ()) {
        return TRUE;
    }

    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &token)) {
        return FALSE;
    }

    if (!LookupPrivilegeValue (NULL, PrivilegeName, &luid)) {
        CloseHandle (token);
        return FALSE;
    }

    newPrivileges.PrivilegeCount = 1;
    newPrivileges.Privileges[0].Luid = luid;
    newPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    b = AdjustTokenPrivileges(
            token,
            FALSE,
            &newPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle (token);

    return b;
}

#ifdef PRERELEASE
VOID
LoadCrashHooks (
    VOID
    )
{
    HINF crashInf;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR typeName;
    PCTSTR objectName;

    crashInf = InfOpenInfFile (TEXT("c:\\crash.inf"));

    if (crashInf == INVALID_HANDLE_VALUE) {
        return;
    }

    if (InfFindFirstLine (crashInf, TEXT("TotalNumber"), NULL, &is)) {
        InfGetIntField (&is, 1, &g_CrashCountObjects);
    }
    if (InfFindFirstLine (crashInf, TEXT("TypeNumber"), NULL, &is)) {
        typeName = InfGetStringField (&is, 1);
        if (typeName) {
            g_CrashCountTypeId = IsmGetObjectTypeId (typeName);
            InfGetIntField (&is, 2, &g_CrashCountType);
        }
    }
    if (InfFindFirstLine (crashInf, TEXT("TypeObject"), NULL, &is)) {
        typeName = InfGetStringField (&is, 1);
        objectName = InfGetStringField (&is, 2);
        if (typeName && objectName) {
            g_CrashNameTypeId = IsmGetObjectTypeId (typeName);
            g_CrashNameObject = IsmGetMemory (SizeOfString (objectName));
            StringCopy ((PTSTR)g_CrashNameObject, objectName);
        }
    }
    InfCleanUpInfStruct (&is);

    InfCloseInfFile (crashInf);
}
#endif

BOOL
pWriteIsmSig (
    IN      PCTSTR DirName
    )
{
    TCHAR tempName [MAX_PATH];
    HANDLE tempHandle;
    DWORD tempSig = ISM_TMP_SIGNATURE;

    StringCopy (tempName, DirName);
    StringCopy (AppendWack (tempName), TEXT("USMT.TMP"));
    tempHandle = BfCreateFile (tempName);
    if (!tempHandle) {
        return FALSE;
    }
    if (!BfWriteFile (tempHandle, (PCBYTE)(&tempSig), sizeof (DWORD))) {
        CloseHandle (tempHandle);
        DeleteFile (tempName);
        return FALSE;
    }
    CloseHandle (tempHandle);
    return TRUE;
}

BOOL
pReadIsmSig (
    IN      PCTSTR DirName
    )
{
    TCHAR tempName [MAX_PATH];
    HANDLE tempHandle;
    DWORD tempSig;

    StringCopy (tempName, DirName);
    StringCopy (AppendWack (tempName), TEXT("USMT.TMP"));
    tempHandle = BfOpenReadFile (tempName);
    if (!tempHandle) {
        return FALSE;
    }
    if (!BfReadFile (tempHandle, (PBYTE)(&tempSig), sizeof (DWORD))) {
        CloseHandle (tempHandle);
        DeleteFile (tempName);
        return FALSE;
    }
    if (tempSig != ISM_TMP_SIGNATURE) {
        CloseHandle (tempHandle);
        DeleteFile (tempName);
        return FALSE;
    }
    CloseHandle (tempHandle);
    return TRUE;
}

BOOL
pCreateTempStorage (
    VOID
    )
{
    DRIVE_ENUM driveEnum;
    GROWBUFFER excludedDrv = INIT_GROWBUFFER;
    TCHAR driveName [4] = TEXT("");
    DWORD sectPerClust;
    DWORD bytesPerSect;
    DWORD freeClusters;
    DWORD totalClusters;
    ULONGLONG maxFreeDiskSpace = 0;
    ULONGLONG freeDiskSpace = 0;
    UINT index = 0;
    PTSTR endStr = NULL;
    BOOL found = FALSE;
    BOOL hideDir = FALSE;

    // we are going to walk the fixed drives picking up the one
    // with the most available space. In the root we are going
    // to create a directory and mark it as ours by creating a
    // special file called USMT.TMP that will have a signature in it.
    // The directory name is normally USMT.TMP. If the directory
    // already exists and does not have our special file in it
    // we are going to pick another name (USMT%04d.TMP), otherwise
    // we are going to overwrite it.

    while (!found) {

        *driveName = 0;
        maxFreeDiskSpace = 0;

        if (EnumFirstDrive (&driveEnum, DRIVEENUM_FIXED)) {
            do {
                if (IsStrInMultiSz (driveEnum.DriveName, (PCTSTR)excludedDrv.Buf)) {
                    continue;
                }
                freeDiskSpace = 0;
                if (GetDiskFreeSpace (driveEnum.DriveName, &sectPerClust, &bytesPerSect, &freeClusters, &totalClusters)) {
                    freeDiskSpace = Int32x32To64 ((sectPerClust * bytesPerSect), freeClusters);
                }
                if (freeDiskSpace > maxFreeDiskSpace) {
                    StringCopyTcharCount (driveName, driveEnum.DriveName, 4);
                    maxFreeDiskSpace = freeDiskSpace;
                }
            } while (EnumNextDrive (&driveEnum));
        }

        while (index < 0xFFFF) {
            if (*driveName) {
                StringCopy (g_GlobalTempDir, driveName);
                hideDir = TRUE;
            } else {
                GetTempPath (ARRAYSIZE(g_GlobalTempDir), g_GlobalTempDir);
                hideDir = FALSE;
            }
            if (index) {
                endStr = GetEndOfString (g_GlobalTempDir);
                wsprintf (endStr, TEXT("USMT%04X.TMP"), index);
            } else {
                StringCat (g_GlobalTempDir, TEXT("USMT.TMP"));
            }
            if (!DoesFileExist (g_GlobalTempDir)) {
                if (BfCreateDirectory (g_GlobalTempDir)) {
                    if (pWriteIsmSig (g_GlobalTempDir)) {
                        found = TRUE;
                        if (hideDir) {
                            SetFileAttributes (g_GlobalTempDir, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
                        }
                        break;
                    }
                }
                // If we are here, we failed to create the temp dir
                // on this drive. This should have succeeded so this
                // means that the drive is locked down somehow.
                if (*driveName) {
                    // Let's bail out and add the drive to the exclude list.
                    GbMultiSzAppend (&excludedDrv, driveName);
                }
                break;
            }
            if (pReadIsmSig (g_GlobalTempDir)) {
                if (FiRemoveAllFilesInTree (g_GlobalTempDir)) {
                    if (BfCreateDirectory (g_GlobalTempDir)) {
                        if (pWriteIsmSig (g_GlobalTempDir)) {
                            found = TRUE;
                            if (hideDir) {
                                SetFileAttributes (g_GlobalTempDir, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
                            }
                            break;
                        }
                    }
                    // If we are here, we failed to create the temp dir
                    // on this drive. This should have succeeded so this
                    // means that the drive is locked down somehow.
                    if (*driveName) {
                        // Let's bail out and add the drive to the exclude list.
                        GbMultiSzAppend (&excludedDrv, driveName);
                    }
                    break;
                }
            }
            index ++;
        }
        if (!(*driveName)) {
            break;
        }
    }

    GbFree (&excludedDrv);

    return found;
}

BOOL
IsmGetTempStorage (
    OUT     PTSTR Path,
    IN      UINT PathTchars
    )
{
    MYASSERT (*g_GlobalTempDir);
    if (*g_GlobalTempDir) {
        StringCopyTcharCount (Path, g_GlobalTempDir, PathTchars);
        return TRUE;
    }
    return FALSE;
}

BOOL
IsmGetTempDirectory (
    OUT     PTSTR Path,
    IN      UINT PathTchars
    )
{
    PTSTR endStr = NULL;

    if (!IsmGetTempStorage (Path, PathTchars)) {
        return FALSE;
    }

    endStr = GetEndOfString (Path);
    while (g_TempDirIndex < 0xFFFFFFFF) {
        wsprintf (endStr, TEXT("\\DIR%04X.TMP"), g_TempDirIndex);
        if (!DoesFileExist (Path)) {
            if (BfCreateDirectory (Path)) {
                g_TempDirIndex ++;
                return TRUE;
            }
        }
        g_TempDirIndex ++;
    }
    return FALSE;
}

BOOL
IsmGetTempFile (
    OUT     PTSTR Path,
    IN      UINT PathTchars
    )
{
    PTSTR endStr = NULL;

    if (!IsmGetTempStorage (Path, PathTchars)) {
        return FALSE;
    }

    endStr = GetEndOfString (Path);
    while (g_TempFileIndex < 0xFFFFFFFF) {
        wsprintf (endStr, TEXT("\\FILE%04X.TMP"), g_TempFileIndex);
        if (!DoesFileExist (Path)) {
            g_TempFileIndex ++;
            return TRUE;
        }
        g_TempFileIndex ++;
    }
    return FALSE;
}

BOOL
IsmInitialize (
    IN      PCTSTR InfPath,
    IN      PMESSAGECALLBACK MessageCallback,       OPTIONAL
    IN      PMIG_LOGCALLBACK LogCallback
    )
{
    BOOL result = FALSE;
    BOOL logInitError = FALSE;
    TCHAR memdbDir[MAX_TCHAR_PATH];

    g_ExecutionInProgress = TRUE;

    __try {

        SetErrorMode (SEM_FAILCRITICALERRORS);

        //
        // Initialize utilities. They produce their own debug messages.
        //

        UtInitialize (NULL);

        LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

        if (!FileEnumInitialize ()) {
            logInitError = TRUE;
            __leave;
        }

        // Initialize the temporary storage
        if (!pCreateTempStorage ()) {
            logInitError = TRUE;
            __leave;
        }

        if (!IsmGetTempDirectory (memdbDir, ARRAYSIZE (memdbDir))) {
            logInitError = TRUE;
            __leave;
        }

        if (!MemDbInitializeEx (memdbDir)) {
            logInitError = TRUE;
            __leave;
        }

        if (!RegInitialize ()) {
            logInitError = TRUE;
            __leave;
        }

        RegInitializeCache (8);

        InfGlobalInit (FALSE);

        //
        // Turn on privileges
        //

        if (!pEnablePrivilege (SE_BACKUP_NAME, TRUE)) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NO_BACKUP_PRIVLEDGE));
            __leave;
        }

        if (!pEnablePrivilege (SE_RESTORE_NAME, TRUE)) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NO_RESTORE_PRIVLEDGE));
            __leave;
        }

        //
        // Initialize ISM globals
        //

        g_CancelEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
        if (!g_CancelEvent) {
            DEBUGMSG ((DBG_ERROR, "Can't create cancel event"));
            __leave;
        }

        g_ActivityEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
        if (!g_ActivityEvent) {
            DEBUGMSG ((DBG_ERROR, "Can't create activity event"));
            CloseHandle (g_CancelEvent);
            __leave;
        }

        g_TransportTable = HtAllocWithData (sizeof (PTRANSPORTDATA));
        g_ControlFileTable = HtAlloc ();

        g_IsmInf = InfOpenInfFile (InfPath);

        if (g_IsmInf == INVALID_HANDLE_VALUE) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INVALID_ISM_INF, InfPath));
            SetLastError (ERROR_FILE_NOT_FOUND);
            __leave;
        }

        if (!g_IsmPool) {
            g_IsmPool = PmCreateNamedPool ("ISM Pool");
        }

        if (!g_IsmUntrackedPool) {
            g_IsmUntrackedPool = PmCreatePool ();
            PmDisableTracking (g_IsmUntrackedPool);
        }

        //
        // Initialize internal modules
        //

        if (!InitializeEnv ()) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INIT_FAILURE, 1));
            __leave;
        }

        if (!InitializeFlowControl ()) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INIT_FAILURE, 3));
            __leave;
        }

        PrepareEnumerationEnvironment (TRUE);

        if (!InitializeTypeMgr ()) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INIT_FAILURE, 2));
            __leave;
        }

        if (!InitializeOperations ()) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INIT_FAILURE, 4));
            __leave;
        }

        g_MessageCallback = MessageCallback;

        //
        // Set the journal location
        //
        IsmSetRollbackJournalType (TRUE);

        g_PreProcessTable = HtAllocWithData (sizeof (PCTSTR));
        g_RefreshTable = HtAllocWithData (sizeof (PCTSTR));
        g_PostProcessTable = HtAllocWithData (sizeof (PCTSTR));

        g_EngineInitialized = TRUE;
        result = TRUE;
    }
    __finally {
        g_ExecutionInProgress = FALSE;

        if (!result) {
            IsmTerminate();
        }
    }

    if (logInitError) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_ENGINE_INIT_FAILURE));
    }

    return result;
}

BOOL
IsmSetPlatform (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    OSVERSIONINFO versionInfo;
    MIG_OSVERSIONINFO migVerInfo;
    TCHAR tempStr [sizeof (UINT) * 2 + 3];
    MIG_OBJECTSTRINGHANDLE tempHandle = NULL;

    if (Platform == PLATFORM_SOURCE) {

        if (!RegisterInternalAttributes ()) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INIT_FAILURE, 5));
            return FALSE;
        }

    }

    //
    // write the source or the destination machine version information
    // in the environment
    //

    ZeroMemory (&versionInfo, sizeof (OSVERSIONINFO));
    versionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    ZeroMemory (&migVerInfo, sizeof (MIG_OSVERSIONINFO));

    if (GetVersionEx (&versionInfo)) {
        if (versionInfo.dwPlatformId == 1) {
            migVerInfo.OsType = OSTYPE_WINDOWS9X;
            migVerInfo.OsTypeName = OSTYPE_WINDOWS9X_STR;
            if (versionInfo.dwMajorVersion == 4) {
                if (versionInfo.dwMinorVersion == 0) {
                    migVerInfo.OsMajorVersion = OSMAJOR_WIN95;
                    migVerInfo.OsMajorVersionName = OSMAJOR_WIN95_STR;
                    migVerInfo.OsMinorVersion = OSMINOR_GOLD;
                    migVerInfo.OsMinorVersionName = OSMINOR_GOLD_STR;
                    if (LOWORD (versionInfo.dwBuildNumber) >= 1111) {
                        migVerInfo.OsMajorVersion = OSMAJOR_WIN95OSR2;
                        migVerInfo.OsMajorVersionName = OSMAJOR_WIN95OSR2_STR;
                    }
                } else if (versionInfo.dwMinorVersion == 10) {
                    migVerInfo.OsMajorVersion = OSMAJOR_WIN98;
                    migVerInfo.OsMajorVersionName = OSMAJOR_WIN98_STR;
                    migVerInfo.OsMinorVersion = OSMINOR_GOLD;
                    migVerInfo.OsMinorVersionName = OSMINOR_GOLD_STR;
                    if (LOWORD (versionInfo.dwBuildNumber) >= 2222) {
                        migVerInfo.OsMinorVersion = OSMINOR_WIN98SE;
                        migVerInfo.OsMinorVersionName = OSMINOR_WIN98SE_STR;
                    }
                } else if (versionInfo.dwMinorVersion == 90) {
                    migVerInfo.OsMajorVersion = OSMAJOR_WINME;
                    migVerInfo.OsMajorVersionName = OSMAJOR_WINME_STR;
                    migVerInfo.OsMinorVersion = OSMINOR_GOLD;
                    migVerInfo.OsMinorVersionName = OSMINOR_GOLD_STR;
                }
            }
        }
        if (versionInfo.dwPlatformId == 2) {
            migVerInfo.OsType = OSTYPE_WINDOWSNT;
            migVerInfo.OsTypeName = OSTYPE_WINDOWSNT_STR;
            if (versionInfo.dwMajorVersion == 4) {
                migVerInfo.OsMajorVersion = OSMAJOR_WINNT4;
                migVerInfo.OsMajorVersionName = OSMAJOR_WINNT4_STR;
                migVerInfo.OsMinorVersion = versionInfo.dwMinorVersion;
                if (migVerInfo.OsMinorVersion == OSMINOR_GOLD) {
                    migVerInfo.OsMinorVersionName = OSMINOR_GOLD_STR;
                }
            }
            if (versionInfo.dwMajorVersion == 5) {
                migVerInfo.OsMajorVersion = OSMAJOR_WINNT5;
                migVerInfo.OsMajorVersionName = OSMAJOR_WINNT5_STR;
                migVerInfo.OsMinorVersion = versionInfo.dwMinorVersion;
                if (migVerInfo.OsMinorVersion == OSMINOR_GOLD) {
                    migVerInfo.OsMinorVersionName = OSMINOR_GOLD_STR;
                } else if (migVerInfo.OsMinorVersion == OSMINOR_WINNT51) {
                    migVerInfo.OsMinorVersionName = OSMINOR_WINNT51_STR;
                }
            }
        }
        wsprintf (tempStr, TEXT("0x%08X"), migVerInfo.OsType);
        IsmSetEnvironmentString (Platform, NULL, S_VER_OSTYPE, tempStr);
        wsprintf (tempStr, TEXT("0x%08X"), migVerInfo.OsMajorVersion);
        IsmSetEnvironmentString (Platform, NULL, S_VER_OSMAJOR, tempStr);
        wsprintf (tempStr, TEXT("0x%08X"), migVerInfo.OsMinorVersion);
        IsmSetEnvironmentString (Platform, NULL, S_VER_OSMINOR, tempStr);
        wsprintf (tempStr, TEXT("0x%08X"), versionInfo.dwBuildNumber);
        IsmSetEnvironmentString (Platform, NULL, S_VER_OSBUILD, tempStr);
    }

    if (Platform == PLATFORM_SOURCE) {
        // let's exclude our temporary directory
        tempHandle = IsmCreateObjectHandle (g_GlobalTempDir, NULL);
        if (tempHandle) {
            IsmRegisterStaticExclusion (MIG_FILE_TYPE, tempHandle);
            IsmDestroyObjectHandle (tempHandle);
            tempHandle = NULL;
        }
    }

    g_IsmCurrentPlatform = Platform;
    return TRUE;
}

BOOL
pPrepareUserJournal (
    IN OUT  PTEMPORARYPROFILE UserProfile
    )
{
    BOOL result = FALSE;
    DWORD tempField;
    PCTSTR journalFile = NULL;

    if (UserProfile && UserProfile->UserProfileRoot) {
        __try {
            UserProfile->DelayedOpJrn = JoinPaths (UserProfile->UserProfileRoot, TEXT("usrusmt2.tmp"));
            FiRemoveAllFilesInTree (UserProfile->DelayedOpJrn);
            if (!BfCreateDirectory (UserProfile->DelayedOpJrn)) {
                __leave;
            }
            journalFile = JoinPaths (UserProfile->DelayedOpJrn, TEXT("JOURNAL.DAT"));
            UserProfile->DelayedOpJrnHandle = BfCreateFile (journalFile);
            if (UserProfile->DelayedOpJrnHandle == INVALID_HANDLE_VALUE) {
                __leave;
            }
            tempField = JRN_USR_SIGNATURE;
            BfWriteFile (UserProfile->DelayedOpJrnHandle, (PBYTE)(&tempField), sizeof (DWORD));
            tempField = JRN_USR_VERSION;
            BfWriteFile (UserProfile->DelayedOpJrnHandle, (PBYTE)(&tempField), sizeof (DWORD));
            tempField = JRN_USR_DIRTY;
            BfWriteFile (UserProfile->DelayedOpJrnHandle, (PBYTE)(&tempField), sizeof (DWORD));
            FlushFileBuffers (UserProfile->DelayedOpJrnHandle);
            FreePathString (journalFile);
            result = TRUE;
        }
        __finally {
            if (!result) {
                if (UserProfile->DelayedOpJrn) {
                    FreePathString (UserProfile->DelayedOpJrn);
                    UserProfile->DelayedOpJrn = NULL;
                }
                if (!UserProfile->DelayedOpJrnHandle || (UserProfile->DelayedOpJrnHandle == INVALID_HANDLE_VALUE)) {
                    CloseHandle (UserProfile->DelayedOpJrnHandle);
                    UserProfile->DelayedOpJrnHandle = NULL;
                }
            }
        }
    }
    return result;
}

BOOL
pValidateUserJournal (
    IN      PTEMPORARYPROFILE UserProfile,
    IN      BOOL RunKeyAdded
    )
{
    BOOL result = FALSE;
    DWORD tempField;

    __try {
        if (UserProfile->DelayedOpJrn) {
            if (RunKeyAdded) {
                if (UserProfile->DelayedOpJrnHandle && (UserProfile->DelayedOpJrnHandle != INVALID_HANDLE_VALUE)) {
                    if (!BfSetFilePointer (UserProfile->DelayedOpJrnHandle, 2 * sizeof (DWORD))) {
                        __leave;
                    }
                    tempField = JRN_USR_COMPLETE;
                    BfWriteFile (UserProfile->DelayedOpJrnHandle, (PBYTE)(&tempField), sizeof (DWORD));
                    FlushFileBuffers (UserProfile->DelayedOpJrnHandle);
                    result = TRUE;
                }
            } else {
                // Run key command was not added, no point to
                // keep this journal here
                FiRemoveAllFilesInTree (UserProfile->DelayedOpJrn);
                result = TRUE;
            }
        }
    }
    __finally {
        if (UserProfile->DelayedOpJrnHandle && (UserProfile->DelayedOpJrnHandle != INVALID_HANDLE_VALUE)) {
            CloseHandle (UserProfile->DelayedOpJrnHandle);
            UserProfile->DelayedOpJrnHandle = NULL;
        }
        if (UserProfile->DelayedOpJrn) {
            FreePathString (UserProfile->DelayedOpJrn);
            UserProfile->DelayedOpJrn = NULL;
        }
    }
    return result;
}

BOOL
pWriteDelayedOperationsCommand (
    IN      PTEMPORARYPROFILE UserProfile
    )
{
    HKEY runKeyHandle = NULL;
    PCTSTR runKeyStr = NULL;
    LONG rc;
    BOOL result = FALSE;

    __try {
        if (!UserProfile->MapKey) {
            LOG ((LOG_ERROR, (PCSTR) MSG_NO_MAPPED_USER));
            __leave;
        }
        runKeyStr = JoinPathsInPoolEx ((
                        NULL,
                        TEXT("HKEY_USERS"),
                        UserProfile->MapKey,
                        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"),
                        NULL
                        ));
        runKeyHandle = CreateRegKeyStr (runKeyStr);
        if (!runKeyHandle) {
            LOG ((LOG_ERROR, (PCSTR) MSG_RUN_KEY_CREATE_FAILURE));
            __leave;
        }
        rc = RegSetValueEx (
                runKeyHandle,
                TEXT("USMT2RUN"),
                0,
                REG_EXPAND_SZ,
                (PBYTE) g_DelayedOperationsCommand,
                SizeOfString (g_DelayedOperationsCommand)
                );
        if (rc != ERROR_SUCCESS) {
            LOG ((LOG_ERROR, (PCSTR) MSG_RUN_KEY_CREATE_FAILURE));
            __leave;
        }
        result = TRUE;
    }
    __finally {
        if (runKeyHandle) {
            CloseRegKey (runKeyHandle);
            runKeyHandle = NULL;
        }
        if (runKeyStr) {
            FreePathString (runKeyStr);
            runKeyStr = NULL;
        }
    }
    return result;
}

BOOL
pDeleteDelayedOperationsCommand (
    VOID
    )
{
    HKEY runKeyHandle = NULL;
    LONG rc;
    BOOL result = FALSE;

    __try {
        runKeyHandle = OpenRegKeyStr (TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"));
        if (!runKeyHandle) {
            LOG ((LOG_ERROR, (PCSTR) MSG_RUN_KEY_DELETE_FAILURE));
            __leave;
        }
        rc = RegDeleteValue (
                runKeyHandle,
                TEXT("USMT2RUN")
                );
        if (rc != ERROR_SUCCESS) {
            LOG ((LOG_ERROR, (PCSTR) MSG_RUN_KEY_DELETE_FAILURE));
            __leave;
        }
        result = TRUE;
    }
    __finally {
        if (runKeyHandle) {
            CloseRegKey (runKeyHandle);
            runKeyHandle = NULL;
        }
    }
    return result;
}

VOID
IsmTerminate (
    VOID
    )
{
    HASHTABLE_ENUM e;
    BOOL runKeyAdded = FALSE;

    if (g_EngineTerminated) {
        g_EngineInitialized = FALSE;
        return;
    }

    // We need to try and terminate properties. In some cases the property file
    // remains opened.
    TerminateProperties (g_IsmCurrentPlatform);

    if (g_PreProcessTable) {
        if (EnumFirstHashTableString (&e, g_PreProcessTable)) {
            do {
                IsmReleaseMemory (*((PCTSTR *)e.ExtraData));
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_PreProcessTable);
        g_PreProcessTable = NULL;
    }

    if (g_RefreshTable) {
        if (EnumFirstHashTableString (&e, g_RefreshTable)) {
            do {
                if (!CheckCancel () && g_PreProcessDone) {
                    IsmSendMessageToApp (ISMMESSAGE_EXECUTE_REFRESH, (ULONG_PTR) *((PCTSTR *)e.ExtraData));
                }
                IsmReleaseMemory (*((PCTSTR *)e.ExtraData));
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_RefreshTable);
        g_RefreshTable = NULL;
    }

    if (g_PostProcessTable) {
        if (EnumFirstHashTableString (&e, g_PostProcessTable)) {
            do {
                if (g_PreProcessDone) {
                    IsmSendMessageToApp (ISMMESSAGE_EXECUTE_POSTPROCESS, (ULONG_PTR) *((PCTSTR *)e.ExtraData));
                }
                IsmReleaseMemory (*((PCTSTR *)e.ExtraData));
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_PostProcessTable);
        g_PostProcessTable = NULL;
    }
    g_PreProcessDone = FALSE;

    g_EngineInitialized = FALSE;

    g_ExecutionInProgress = TRUE;

    //
    // Terminate plug-in modules
    //

    TerminateProcessWideModules();

    //
    // Clean up journal
    //

    if (g_JournalDirectory && !g_PreserveJournal) {
        if (DoesFileExist (g_JournalDirectory)) {
            if (!FiRemoveAllFilesInTree (g_JournalDirectory)) {
                DEBUGMSG ((DBG_ERROR, "Cannot remove journal directory: %s", g_JournalDirectory));
            }
        }
        FreePathString (g_JournalDirectory);
        g_JournalDirectory = NULL;
        g_JournalUsed = FALSE;
    }

    if (g_TempProfile) {
        // let's write the Run key command line and set runKeyAdded to TRUE
        runKeyAdded = pWriteDelayedOperationsCommand (g_TempProfile);
        pValidateUserJournal (g_TempProfile, runKeyAdded);
        if (!CloseTemporaryProfile (g_TempProfile, g_MakeProfilePermanent)) {
            LOG ((
                LOG_MODULE_ERROR,
                (PCSTR) MSG_CANT_SAVE_PROFILE,
                g_TempProfile->UserName,
                GetLastError()
                ));
            CloseTemporaryProfile (g_TempProfile, FALSE);
        }
        g_TempProfile = NULL;
    }

    if (g_DelayedOperationsCommand) {
        FreePathString (g_DelayedOperationsCommand);
        g_DelayedOperationsCommand = NULL;
    }

    //
    // Terminate all control files
    //
    if (g_ControlFileTable) {
        if (EnumFirstHashTableString (&e, g_ControlFileTable)) {
            do {
                DeleteFile (e.String);
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_ControlFileTable);
        g_ControlFileTable = NULL;
    }

    //
    // Terminate internal modules
    //

    ClearEnumerationEnvironment (TRUE);

    TerminateEnv ();
    TerminateTypeMgr ();
    TerminateFlowControl ();
    TerminateOperations ();

    //
    // Destroy globals
    //

    pFreeRestoreCallbacks ();

    if (g_CancelEvent) {
        CloseHandle (g_CancelEvent);
        g_CancelEvent = NULL;
    }

    if (g_ActivityEvent) {
        CloseHandle (g_ActivityEvent);
        g_ActivityEvent = NULL;
    }

    GbFree (&g_SliceBuffer);

    if (g_TransportTable) {
        HtFree (g_TransportTable);
        g_TransportTable = NULL;
    }

    if (g_IsmPool) {
        PmDestroyPool (g_IsmPool);
        g_IsmPool = NULL;
    }

    if (g_IsmUntrackedPool) {
        PmDestroyPool (g_IsmUntrackedPool);
        g_IsmUntrackedPool = NULL;
    }

    if (g_IsmInf != INVALID_HANDLE_VALUE) {
        InfCloseInfFile (g_IsmInf);
        g_IsmInf = INVALID_HANDLE_VALUE;
    }

    InfGlobalInit (TRUE);

    MemDbTerminateEx (TRUE);        // relies on fileenum

    // let's remove the temporary storage, it's here because uses fileenum
    if (*g_GlobalTempDir) {
        if (!FiRemoveAllFilesInTree (g_GlobalTempDir)) {
            DEBUGMSG ((DBG_ERROR, "Cannot remove temporary storage: %s", g_GlobalTempDir));
        }
        *g_GlobalTempDir = 0;
    }

    FileEnumTerminate ();

    RegTerminate ();

    UtTerminate ();

    g_EngineTerminated = TRUE;
    g_ExecutionInProgress = FALSE;
}

BOOL
IsmPreserveJournal (
    IN      BOOL Preserve
    )
{
    BOOL result = g_PreserveJournal;
    g_PreserveJournal = Preserve;
    return result;
}

BOOL
pEtmParse (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    PETMDATA etmData;

    PrepareEnumerationEnvironment (FALSE);

    //
    // Call the parse entry point
    //

    if (EnumFirstHashTableString (&e, g_EtmTable)) {
        do {

            etmData = *((PETMDATA *) e.ExtraData);

            if (etmData->ShouldBeCalled && etmData->EtmParse) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = etmData->Group;

                b = etmData->EtmParse (Reserved);

                g_CurrentGroup = NULL;
            }

        } while (b && EnumNextHashTableString (&e));
    }
    ClearEnumerationEnvironment (FALSE);

    return b;
}

BOOL
pCreateComputerParse (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    PVCMDATA vcmData;

    PrepareEnumerationEnvironment (FALSE);

    //
    // Call the parse entry point
    //

    if (EnumFirstHashTableString (&e, g_VcmTable)) {
        do {

            vcmData = *((PVCMDATA *) e.ExtraData);

            if (vcmData->ShouldBeCalled && vcmData->VcmParse) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = vcmData->Group;

                b = vcmData->VcmParse (Reserved);

                g_CurrentGroup = NULL;
            }

        } while (b && EnumNextHashTableString (&e));
    }
    ClearEnumerationEnvironment (FALSE);

    return b;
}

BOOL
pCreateComputerGather (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;
    PVCMDATA vcmData;
    UINT containers;
    MIG_PROGRESSSLICEID sliceId;

    PrepareEnumerationEnvironment (FALSE);

    //
    // Queue high priority enumerations
    //

    if (b && EnumFirstHashTableString (&e, g_VcmTable)) {
        do {

            vcmData = *((PVCMDATA *) e.ExtraData);

            if (vcmData->ShouldBeCalled && vcmData->VcmQueueHighPriorityEnumeration) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = vcmData->Group;

                b = vcmData->VcmQueueHighPriorityEnumeration (Reserved);

                g_CurrentGroup = NULL;
            }

        } while (b && EnumNextHashTableString (&e));
    }

    g_CurrentPhase = MIG_HIGHPRIORITYGATHER_PHASE;
    g_SliceBuffer.End = 0;
    containers = EstimateAllObjectEnumerations (0, FALSE);

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    //
    // Run high priority enumeration queue
    //

    if (b) {

        if (!DoAllObjectEnumerations (sliceId)) {
            DEBUGMSG ((DBG_ERROR, "Internal ISM Error during high priority object enumeration."));
            b = FALSE;
        }
    }

    pCallProgressBar (MIG_END_PHASE);
    ClearEnumerationEnvironment (FALSE);

    PrepareEnumerationEnvironment (FALSE);

    //
    // Queue normal priority enumerations
    //

    if (b && EnumFirstHashTableString (&e, g_VcmTable)) {
        do {

            vcmData = *((PVCMDATA *) e.ExtraData);

            if (vcmData->ShouldBeCalled) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = vcmData->Group;

                b = vcmData->VcmQueueEnumeration (Reserved);

                g_CurrentGroup = NULL;
            }

        } while (b && EnumNextHashTableString (&e));
    }

    g_CurrentPhase = MIG_GATHER_PHASE;
    g_SliceBuffer.End = 0;
    containers = EstimateAllObjectEnumerations (0, FALSE);

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    //
    // Run normal priority enumeration queue
    //

    if (b) {

        if (!DoAllObjectEnumerations (sliceId)) {
            DEBUGMSG ((DBG_ERROR, "Internal ISM Error during object enumeration."));
            b = FALSE;
        }
    }

    ClearEnumerationEnvironment (FALSE);
    pCallProgressBar (MIG_END_PHASE);

    g_CurrentPhase = 0;
    g_SliceBuffer.End = 0;

    return b;
}

BOOL
pSourceParse (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    PSGMDATA sgmData;

    PrepareEnumerationEnvironment (FALSE);

    //
    // Call the parse entry point
    //

    if (b && EnumFirstHashTableString (&e, g_SgmTable)) {
        do {

            sgmData = *((PSGMDATA *) e.ExtraData);

            if (sgmData->ShouldBeCalled && sgmData->SgmParse) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = sgmData->Group;

                b = sgmData->SgmParse (Reserved);

                g_CurrentGroup = NULL;
            }

        } while (b && EnumNextHashTableString (&e));
    }
    ClearEnumerationEnvironment (FALSE);

    return b;
}

BOOL
pSourceGather (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;
    PSGMDATA sgmData;
    UINT containers;
    MIG_PROGRESSSLICEID sliceId;

    PrepareEnumerationEnvironment (FALSE);

    //
    // Estimate the queue high priority enumerations
    //

    containers = 0;
    if (b && EnumFirstHashTableString (&e, g_SgmTable)) {
        do {

            sgmData = *((PSGMDATA *) e.ExtraData);

            if (sgmData->ShouldBeCalled && sgmData->SgmQueueHighPriorityEnumeration) {

                containers ++;
            }

        } while (b && EnumNextHashTableString (&e));
    }

    //
    // Queue high priority enumerations
    //

    g_CurrentPhase = MIG_HIGHPRIORITYQUEUE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b && EnumFirstHashTableString (&e, g_SgmTable)) {
        do {

            sgmData = *((PSGMDATA *) e.ExtraData);

            if (sgmData->ShouldBeCalled && sgmData->SgmQueueHighPriorityEnumeration) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = sgmData->Group;

                b = sgmData->SgmQueueHighPriorityEnumeration (Reserved);

                g_CurrentGroup = NULL;

                // Call progress bar
                IsmTickProgressBar (sliceId, 1);
            }

        } while (b && EnumNextHashTableString (&e));
    }

    pCallProgressBar (MIG_END_PHASE);

    //
    // Estimate the high priority enumerations estimate
    //

    containers = EstimateAllObjectEnumerations (0, TRUE);

    //
    // Estimate the high priority enumerations
    //

    g_CurrentPhase = MIG_HIGHPRIORITYESTIMATE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    containers = EstimateAllObjectEnumerations (sliceId, FALSE);

    pCallProgressBar (MIG_END_PHASE);

    //
    // Run high priority enumeration queue
    //

    g_CurrentPhase = MIG_HIGHPRIORITYGATHER_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b) {

        if (!DoAllObjectEnumerations (sliceId)) {
            DEBUGMSG ((DBG_ERROR, "Internal ISM Error during high priority object enumeration."));
            b = FALSE;
        }
    }

    pCallProgressBar (MIG_END_PHASE);

    ClearEnumerationEnvironment (FALSE);

    PrepareEnumerationEnvironment (FALSE);

    //
    // Estimate the queue normal priority enumerations
    //

    containers = 0;
    if (b && EnumFirstHashTableString (&e, g_SgmTable)) {
        do {

            sgmData = *((PSGMDATA *) e.ExtraData);

            if (sgmData->ShouldBeCalled) {

                containers ++;
            }

        } while (b && EnumNextHashTableString (&e));
    }

    //
    // Queue normal priority enumerations
    //

    g_CurrentPhase = MIG_GATHERQUEUE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b && EnumFirstHashTableString (&e, g_SgmTable)) {
        do {

            sgmData = *((PSGMDATA *) e.ExtraData);

            if (sgmData->ShouldBeCalled) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = sgmData->Group;

                b = sgmData->SgmQueueEnumeration (Reserved);

                g_CurrentGroup = NULL;

                // Call progress bar
                IsmTickProgressBar (sliceId, 1);
            }

        } while (b && EnumNextHashTableString (&e));
    }

    pCallProgressBar (MIG_END_PHASE);

    //
    // Estimate the normal priority enumerations estimate
    //

    containers = EstimateAllObjectEnumerations (0, TRUE);

    //
    // Estimate the normal priority enumerations
    //

    g_CurrentPhase = MIG_GATHERESTIMATE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    containers = EstimateAllObjectEnumerations (sliceId, FALSE);

    pCallProgressBar (MIG_END_PHASE);

    //
    // Run normal priority enumeration queue
    //

    g_CurrentPhase = MIG_GATHER_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b) {

        if (!DoAllObjectEnumerations (sliceId)) {
            DEBUGMSG ((DBG_ERROR, "Internal ISM Error during object enumeration."));
            b = FALSE;
        }
    }

    ClearEnumerationEnvironment (FALSE);
    pCallProgressBar (MIG_END_PHASE);

    g_CurrentPhase = 0;
    g_SliceBuffer.End = 0;

    return b;
}


BOOL
pSourceAnalyze (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;
    PSAMDATA samData;
    UINT modulesNeedingProgress = 0;
    MIG_PROGRESSSLICEID sliceId = 0;

    //
    // Prepare a progress bar
    //

    g_CurrentPhase = MIG_ANALYSIS_PHASE;
    g_SliceBuffer.End = 0;

    if (b && EnumFirstHashTableString (&e, g_SamTable)) {
        do {

            samData = *((PSAMDATA *) e.ExtraData);

            if (samData->ShouldBeCalled) {
                if (samData->SamEstimateProgressBar) {
                    samData->SamEstimateProgressBar();
                } else {
                    modulesNeedingProgress++;
                }
            }

        } while (b && EnumNextHashTableString (&e));
    }

    if (modulesNeedingProgress) {
        sliceId = IsmRegisterProgressSlice (
                        modulesNeedingProgress,
                        modulesNeedingProgress * 10
                        );
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    //
    // Run all the registered SAMs
    //

    if (b && EnumFirstHashTableString (&e, g_SamTable)) {
        do {

            samData = *((PSAMDATA *) e.ExtraData);

            if (samData->ShouldBeCalled) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = samData->Group;

                b = samData->SamExecute();

                g_CurrentGroup = NULL;

                if (!samData->SamEstimateProgressBar) {
                    if (!IsmTickProgressBar (sliceId, 1)) {
                        b = FALSE;
                    }
                }
            }

        } while (b && EnumNextHashTableString (&e));
    }

    pCallProgressBar (MIG_END_PHASE);
    g_CurrentPhase = 0;
    g_SliceBuffer.End = 0;

    return b;
}


BOOL
pDestinationGather (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;
    PDGMDATA dgmData;
    UINT containers;
    MIG_PROGRESSSLICEID sliceId;

    PrepareEnumerationEnvironment (FALSE);

    //
    // Estimate the queue high priority enumerations
    //

    containers = 0;
    if (b && EnumFirstHashTableString (&e, g_DgmTable)) {
        do {

            dgmData = *((PDGMDATA *) e.ExtraData);

            if (dgmData->ShouldBeCalled && dgmData->DgmQueueHighPriorityEnumeration) {

                containers ++;
            }

        } while (b && EnumNextHashTableString (&e));
    }

    //
    // Queue high priority enumerations
    //

    g_CurrentPhase = MIG_HIGHPRIORITYQUEUE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b && EnumFirstHashTableString (&e, g_DgmTable)) {
        do {

            dgmData = *((PDGMDATA *) e.ExtraData);

            if (dgmData->ShouldBeCalled && dgmData->DgmQueueHighPriorityEnumeration) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = dgmData->Group;

                b = dgmData->DgmQueueHighPriorityEnumeration (Reserved);

                g_CurrentGroup = NULL;

                // Call progress bar
                IsmTickProgressBar (sliceId, 1);
            }

        } while (b && EnumNextHashTableString (&e));
    }

    pCallProgressBar (MIG_END_PHASE);

    //
    // Estimate the high priority enumerations estimate
    //

    containers = EstimateAllObjectEnumerations (0, TRUE);

    //
    // Estimate the high priority enumerations
    //

    g_CurrentPhase = MIG_HIGHPRIORITYESTIMATE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    containers = EstimateAllObjectEnumerations (sliceId, FALSE);

    pCallProgressBar (MIG_END_PHASE);

    //
    // Run high priority enumeration queue
    //

    g_CurrentPhase = MIG_HIGHPRIORITYGATHER_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b) {

        if (!DoAllObjectEnumerations (sliceId)) {
            DEBUGMSG ((DBG_ERROR, "Internal ISM Error during high priority object enumeration."));
            b = FALSE;
        }
    }

    pCallProgressBar (MIG_END_PHASE);

    ClearEnumerationEnvironment (FALSE);

    PrepareEnumerationEnvironment (FALSE);

    //
    // Estimate the queue normal priority enumerations
    //

    containers = 0;
    if (b && EnumFirstHashTableString (&e, g_DgmTable)) {
        do {

            dgmData = *((PDGMDATA *) e.ExtraData);

            if (dgmData->ShouldBeCalled) {

                containers ++;
            }

        } while (b && EnumNextHashTableString (&e));
    }

    //
    // Queue normal priority enumerations
    //

    g_CurrentPhase = MIG_GATHERQUEUE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b && EnumFirstHashTableString (&e, g_DgmTable)) {
        do {

            dgmData = *((PDGMDATA *) e.ExtraData);

            if (dgmData->ShouldBeCalled) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = dgmData->Group;

                b = dgmData->DgmQueueEnumeration (Reserved);

                g_CurrentGroup = NULL;

                // Call progress bar
                IsmTickProgressBar (sliceId, 1);
            }

        } while (b && EnumNextHashTableString (&e));
    }

    pCallProgressBar (MIG_END_PHASE);

    //
    // Estimate the normal priority enumerations estimate
    //

    containers = EstimateAllObjectEnumerations (0, TRUE);

    //
    // Estimate the normal priority enumerations
    //

    g_CurrentPhase = MIG_GATHERESTIMATE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    containers = EstimateAllObjectEnumerations (sliceId, FALSE);

    pCallProgressBar (MIG_END_PHASE);

    //
    // Run normal priority enumeration queue
    //

    g_CurrentPhase = MIG_GATHER_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b) {

        if (!DoAllObjectEnumerations (sliceId)) {
            DEBUGMSG ((DBG_ERROR, "Internal ISM Error during object enumeration."));
            b = FALSE;
        }
    }

    ClearEnumerationEnvironment (FALSE);
    pCallProgressBar (MIG_END_PHASE);

    g_CurrentPhase = 0;
    g_SliceBuffer.End = 0;

    return b;
}


BOOL
ShouldObjectBeRestored (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )

/*++

Routine Description:

  ShouldObjectBeRestored determines if a specific object should be restored
  at all.  It first checks if the object is marked for apply, and then checks
  all restore callbacks to allow them to deny the restore.

Arguments:

  ObjectTypeId - Specifies the object type
  ObjectId     - Specifies the numeric ID of the object
  ObjectName   - Specifies the encoded node and leaf of the object

Return Value:

  TRUE if the object should be restored, FALSE otherwise

--*/

{
    BOOL result = TRUE;
    MIG_RESTORECALLBACK_ENUM restoreEnum;

    //
    // Is object marked for apply?
    //

    if (!IsmIsApplyObjectId (ObjectId)) {
        return FALSE;
    }

    //
    // Call callbacks to allow them to deny restore
    //

    if (EnumFirstRestoreCallback (&restoreEnum)) {
        do {
            if (!restoreEnum.RestoreCallback (ObjectTypeId, ObjectId, ObjectName)) {
                result = FALSE;
                break;
            }
        } while (EnumNextRestoreCallback (&restoreEnum));
    }

    return result;
}


BOOL
pDestinationAnalyze (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;
    PDAMDATA damData;
    PCSMDATA csmData;
    UINT modulesNeedingProgress = 0;
    MIG_PROGRESSSLICEID sliceId = 0;

    //
    // Prepare a progress bar
    //

    g_CurrentPhase = MIG_ANALYSIS_PHASE;
    g_SliceBuffer.End = 0;

    if (EnumFirstHashTableString (&e, g_DamTable)) {
        do {

            damData = *((PDAMDATA *) e.ExtraData);

            if (damData->ShouldBeCalled) {
                if (damData->DamEstimateProgressBar) {
                    damData->DamEstimateProgressBar();
                } else {
                    modulesNeedingProgress++;
                }
            }

        } while (EnumNextHashTableString (&e));
    }
    if (EnumFirstHashTableString (&e, g_CsmTable)) {
        do {

            csmData = *((PCSMDATA *) e.ExtraData);

            if (csmData->ShouldBeCalled) {
                if (csmData->CsmEstimateProgressBar) {
                    csmData->CsmEstimateProgressBar();
                } else {
                    modulesNeedingProgress++;
                }
            }

        } while (EnumNextHashTableString (&e));
    }

    if (modulesNeedingProgress) {
        sliceId = IsmRegisterProgressSlice (
                        modulesNeedingProgress,
                        modulesNeedingProgress * 10
                        );
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    //
    // Run all the registered DAMs
    //

    if (EnumFirstHashTableString (&e, g_DamTable)) {
        do {

            damData = *((PDAMDATA *) e.ExtraData);

            if (damData->ShouldBeCalled) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = damData->Group;

                b = damData->DamExecute();

                g_CurrentGroup = NULL;

                if (!damData->DamEstimateProgressBar) {
                    if (!IsmTickProgressBar (sliceId, 1)) {
                        b = FALSE;
                    }
                }
            }

        } while (b && EnumNextHashTableString (&e));
    }

    //
    // Run all the registered CSMs
    //

    if (EnumFirstHashTableString (&e, g_CsmTable)) {
        do {

            csmData = *((PCSMDATA *) e.ExtraData);

            if (csmData->ShouldBeCalled) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = csmData->Group;

                b = csmData->CsmExecute();

                g_CurrentGroup = NULL;

                if (!csmData->CsmEstimateProgressBar) {
                    if (!IsmTickProgressBar (sliceId, 1)) {
                        b = FALSE;
                    }
                }
            }

        } while (b && EnumNextHashTableString (&e));
    }

    pCallProgressBar (MIG_END_PHASE);
    g_CurrentPhase = 0;
    g_SliceBuffer.End = 0;
    return b;
}

BOOL
pTestShortFileName (
    IN      PCTSTR FileName,
    IN      PCTSTR TempDir
    )
{
    PCTSTR testFileName;
    HANDLE fileHandle;
    WIN32_FIND_DATA fileInfo;
    BOOL result = FALSE;

    testFileName = JoinPaths (TempDir, FileName);
    fileHandle = BfCreateFile (testFileName);
    if (fileHandle) {
        CloseHandle (fileHandle);
        if (DoesFileExistEx (testFileName, &fileInfo)) {
            result = (fileInfo.cAlternateFileName [0] == 0) ||
                     StringIMatch (fileInfo.cFileName, fileInfo.cAlternateFileName);
        }
        DeleteFile (testFileName);
    }
    FreePathString (testFileName);
    return result;
}

BOOL
pIsShortFileName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR TempDir,
    IN      PCTSTR FullKeyName,
    IN OUT  KEYHANDLE *KeyHandle
    )
{
    PCTSTR node, leaf;
    PTSTR nodePtr;
    PTSTR fullKeyName;
    MEMDB_ENUM memDbEnum;
    BOOL result = FALSE;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (leaf) {
            result = pTestShortFileName (leaf, TempDir);
        } else {
            fullKeyName = DuplicatePathString (FullKeyName, 0);
            nodePtr = _tcsrchr (fullKeyName, TEXT('\\'));
            if (nodePtr) {
                *nodePtr = 0;
                nodePtr = _tcsrchr (fullKeyName, TEXT('\\'));
                if (nodePtr) {
                    result = pTestShortFileName (nodePtr, TempDir);
                    if (!result && MemDbEnumFirst (&memDbEnum, fullKeyName, ENUMFLAG_ALL, ENUMLEVEL_LASTLEVEL, ENUMLEVEL_ALLLEVELS)) {
                        *KeyHandle = memDbEnum.KeyHandle;
                        MemDbAbortEnum (&memDbEnum);
                    } else {
                        result = TRUE;
                    }
                }
            }
            FreePathString (fullKeyName);
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
pFixFileEnumerationOrder (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR TempDir
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    PCTSTR decoratedPath;
    MEMDB_ENUM memDbEnum;
    GROWBUFFER moveHandles = INIT_GROWBUFFER;
    KEYHANDLE keyHandle;
    PDWORD moveHandle = NULL;
    BOOL result = FALSE;

    objectTypeId = MIG_FILE_TYPE | Platform;
    decoratedPath = GetDecoratedObjectPathFromName (objectTypeId, TEXT("*"), TRUE);
    if (decoratedPath) {
        if (MemDbEnumFirst (&memDbEnum, decoratedPath, ENUMFLAG_NORMAL, 1, ENUMLEVEL_ALLLEVELS)) {
            do {
                if (IsmCheckCancel()) {
                    return FALSE;
                }
                keyHandle = memDbEnum.KeyHandle;
                if (!pIsShortFileName (objectTypeId, memDbEnum.KeyName, TempDir, memDbEnum.FullKeyName, &keyHandle)) {
                    GbAppendDword (&moveHandles, keyHandle);
                }
            } while (MemDbEnumNext (&memDbEnum));
        }
        GbAppendDword (&moveHandles, 0);
        moveHandle = (PDWORD)moveHandles.Buf;
        while (*moveHandle) {
            if (IsmCheckCancel()) {
                return FALSE;
            }
            MemDbMoveKeyHandleToEnd (*moveHandle);
            moveHandle ++;
        }
        FreePathString (decoratedPath);
    }

    GbFree (&moveHandles);

    return result;
}

BOOL
pDestinationApply (
    IN      PVOID Reserved
    )
{
    BOOL b = TRUE;
    BOOL cancelled = FALSE;
    MIG_OBJECTTYPEID objTypeId;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE objPattern = NULL;
    BOOL toProcess = FALSE;
    MIG_PROGRESSSLICEID sliceId = 0;
    UINT ticks;
    LONG failCode;
    BOOL runKeyAdded = FALSE;
    MIG_OBJECTTYPEID fileTypeId;
    TCHAR tempDir [MAX_PATH] = TEXT("");
    BOOL deleteFailed = FALSE;
    TCHAR delayedDeleteKey [] = TEXT("DelayedDelete");
    KEYHANDLE delayedDeleteHandle;
    MIG_OBJECTID delayedDeleteId;
    PUINT delayedDeleteList;
    UINT delayedDeleteListNo;
    UINT delayedDeleteIndex;
    MIG_OBJECTSTRINGHANDLE delayedObjectName = NULL;
    MIG_OBJECTTYPEID delayedObjectTypeId;
    HASHTABLE_ENUM e;
    ERRUSER_EXTRADATA extraData;

    g_CurrentPhase = MIG_APPLY_PHASE;
    g_SliceBuffer.End = 0;

    ticks = g_DestinationObjects.TotalObjects +
            g_SourceObjects.TotalObjects +
            g_DestinationObjects.TotalObjects;

    if (ticks) {
        sliceId = IsmRegisterProgressSlice (ticks, max (1, ticks / 10));
    } else {
        sliceId = IsmRegisterProgressSlice (1, 30);
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    // let's execute PreProcess functions
    if (g_PreProcessTable) {
        if (EnumFirstHashTableString (&e, g_PreProcessTable)) {
            do {
                IsmSendMessageToApp (ISMMESSAGE_EXECUTE_PREPROCESS, (ULONG_PTR) *((PCTSTR *)e.ExtraData));
            } while (EnumNextHashTableString (&e));
        }
    }
    g_PreProcessDone = TRUE;

    IsmGetTempDirectory (tempDir, ARRAYSIZE(tempDir));
    fileTypeId = MIG_FILE_TYPE;

    //
    // Special code for file type (short/long issue)
    //
    pFixFileEnumerationOrder (PLATFORM_SOURCE, tempDir);
    pFixFileEnumerationOrder (PLATFORM_DESTINATION, tempDir);

    //
    // Now we are going to execute an ISM driven restore
    //

    objPattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);

    //
    // Enumerate and process high priority operations for all objects on the
    // right side of the tree
    //

    failCode = ERROR_SUCCESS;
    objTypeId = IsmGetFirstObjectTypeId ();

    while (objTypeId) {

        objTypeId |= PLATFORM_DESTINATION;

        if (CanObjectTypeBeRestored (objTypeId)) {

            delayedDeleteHandle = MemDbAddKey (delayedDeleteKey);

            if (pEnumFirstVirtualObject (&objectEnum, objTypeId, objPattern)) {
                do {
                    toProcess = ShouldObjectBeRestored (
                                    objTypeId,
                                    objectEnum.ObjectId,
                                    objectEnum.ObjectName
                                    );

                    if (toProcess) {
                        if (!RestoreObject (
                                objTypeId,
                                objectEnum.ObjectName,
                                NULL,
                                OP_HIGH_PRIORITY,
                                &deleteFailed
                                )) {
                            failCode = GetLastError();
                            if (failCode != ERROR_SUCCESS) {
                                LOG ((
                                    IsmIsNonCriticalObjectId (objectEnum.ObjectId)?LOG_WARNING:LOG_ERROR,
                                    (PCSTR) MSG_CANT_RESTORE_SOURCE_OBJECT,
                                    IsmGetObjectTypeName (objTypeId),
                                    IsmGetNativeObjectName (objTypeId, objectEnum.ObjectName)
                                    ));
                                failCode = ERROR_SUCCESS;
                            }
                        }

                        if (deleteFailed && delayedDeleteHandle) {
                            delayedDeleteId = IsmGetObjectIdFromName (objTypeId, objectEnum.ObjectName, TRUE);
                            if (delayedDeleteId) {
                                MemDbAddSingleLinkageByKeyHandle (
                                    delayedDeleteHandle,
                                    delayedDeleteId,
                                    0
                                    );
                            }
                        }
                    }

                    if (ticks) {
                        if (!IsmTickProgressBar (sliceId, 1)) {
                            failCode = ERROR_CANCELLED;
                            break;
                        }
                        ticks--;
                    } else if (CheckCancel()) {
                        failCode = ERROR_CANCELLED;
                        break;
                    }
                } while (pEnumNextVirtualObject (&objectEnum));
            }
            if (delayedDeleteHandle) {
                // OK, now let's see if we have some delayed delete here
                delayedDeleteList = MemDbGetSingleLinkageArrayByKeyHandle (
                                        delayedDeleteHandle,
                                        0,
                                        &delayedDeleteListNo
                                        );
                delayedDeleteListNo /= SIZEOF(KEYHANDLE);

                if ((delayedDeleteList) &&
                    (delayedDeleteListNo > 0)) {
                    delayedDeleteIndex = delayedDeleteListNo;
                    do {
                        delayedDeleteIndex --;
                        delayedDeleteId = *(delayedDeleteList + delayedDeleteIndex);
                        delayedObjectName = MemDbGetKeyFromHandle ((KEYHANDLE) delayedDeleteId, 1);
                        if (delayedObjectName) {
                            if (MemDbGetValueByHandle ((KEYHANDLE) delayedDeleteId, &delayedObjectTypeId)) {
                                // now we have everything to retry the delete
                                if (!RestoreObject (
                                        delayedObjectTypeId,
                                        delayedObjectName,
                                        NULL,
                                        OP_HIGH_PRIORITY,
                                        NULL
                                        )) {
                                    failCode = GetLastError();
                                    if (failCode != ERROR_SUCCESS) {
                                        LOG ((
                                            IsmIsNonCriticalObject (delayedObjectTypeId, delayedObjectName)?LOG_WARNING:LOG_ERROR,
                                            (PCSTR) MSG_CANT_RESTORE_SOURCE_OBJECT,
                                            IsmGetObjectTypeName (objTypeId),
                                            IsmGetNativeObjectName (objTypeId, objectEnum.ObjectName)
                                            ));
                                        failCode = ERROR_SUCCESS;
                                    }
                                }
                            }
                            MemDbReleaseMemory (delayedObjectName);
                        }
                    } while (delayedDeleteIndex > 0);
                    MemDbReleaseMemory (delayedDeleteList);
                }
            }
            MemDbDeleteKey (delayedDeleteKey);
        }

        if (failCode != ERROR_SUCCESS) {
            IsmAbortObjectEnum (&objectEnum);
            SetLastError (failCode);
            if (tempDir [0]) {
                FiRemoveAllFilesInTree (tempDir);
            }
            return FALSE;
        }

        objTypeId &= (~PLATFORM_MASK);
        objTypeId = IsmGetNextObjectTypeId (objTypeId);
    }

    //
    // Enumerate and process high priority and low priority operations for all objects on the
    // left side of the tree
    //

    failCode = ERROR_SUCCESS;
    objTypeId = IsmGetFirstObjectTypeId ();

    while (objTypeId) {

        objTypeId |= PLATFORM_SOURCE;

        if (CanObjectTypeBeRestored (objTypeId)) {

            if (pEnumFirstVirtualObject (&objectEnum, objTypeId, objPattern)) {
                do {
                    toProcess = ShouldObjectBeRestored (
                                    objTypeId,
                                    objectEnum.ObjectId,
                                    objectEnum.ObjectName
                                    );

                    if (toProcess) {
                        if (!RestoreObject (
                                objTypeId,
                                objectEnum.ObjectName,
                                NULL,
                                OP_ALL_PRIORITY,
                                NULL
                                )) {
                            failCode = GetLastError();
                            if (failCode != ERROR_SUCCESS) {
                                LOG ((
                                    IsmIsNonCriticalObjectId (objectEnum.ObjectId)?LOG_WARNING:LOG_ERROR,
                                    (PCSTR) MSG_CANT_RESTORE_SOURCE_OBJECT,
                                    IsmGetObjectTypeName (objTypeId),
                                    IsmGetNativeObjectName (objTypeId, objectEnum.ObjectName)
                                    ));
                                failCode = ERROR_SUCCESS;
                                extraData.Error = ERRUSER_ERROR_CANTRESTOREOBJECT;
                                extraData.ErrorArea = ERRUSER_AREA_RESTORE;
                                extraData.ObjectTypeId = objTypeId;
                                extraData.ObjectName = objectEnum.ObjectName;
                                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                            }
                        }
                    }

                    if (ticks) {
                        if (!IsmTickProgressBar (sliceId, 1)) {
                            failCode = ERROR_CANCELLED;
                            break;
                        }
                        ticks--;
                    } else if (CheckCancel()) {
                        failCode = ERROR_CANCELLED;
                        break;
                    }
                } while (pEnumNextVirtualObject (&objectEnum));
            }
        }

        if (failCode != ERROR_SUCCESS) {
            IsmAbortObjectEnum (&objectEnum);
            SetLastError (failCode);
            if (tempDir [0]) {
                FiRemoveAllFilesInTree (tempDir);
            }
            return FALSE;
        }

        objTypeId &= (~PLATFORM_MASK);
        objTypeId = IsmGetNextObjectTypeId (objTypeId);
    }

    //
    // Enumerate and process low priority operation for all objects on the
    // right side of the tree
    //

    failCode = ERROR_SUCCESS;
    objTypeId = IsmGetFirstObjectTypeId ();

    while (objTypeId) {

        objTypeId |= PLATFORM_DESTINATION;

        if (CanObjectTypeBeRestored (objTypeId)) {

            delayedDeleteHandle = MemDbAddKey (delayedDeleteKey);

            if (pEnumFirstVirtualObject (&objectEnum, objTypeId, objPattern)) {
                do {
                    toProcess = ShouldObjectBeRestored (
                                    objTypeId,
                                    objectEnum.ObjectId,
                                    objectEnum.ObjectName
                                    );

                    if (toProcess) {
                        if (!RestoreObject (
                                objTypeId,
                                objectEnum.ObjectName,
                                NULL,
                                OP_LOW_PRIORITY,
                                &deleteFailed
                                )) {
                            failCode = GetLastError();
                            if (failCode != ERROR_SUCCESS) {
                                LOG ((
                                    IsmIsNonCriticalObjectId (objectEnum.ObjectId)?LOG_WARNING:LOG_ERROR,
                                    (PCSTR) MSG_CANT_RESTORE_SOURCE_OBJECT,
                                    IsmGetObjectTypeName (objTypeId),
                                    IsmGetNativeObjectName (objTypeId, objectEnum.ObjectName)
                                    ));
                                failCode = ERROR_SUCCESS;
                            }
                        }
                        if (deleteFailed && delayedDeleteHandle) {
                            delayedDeleteId = IsmGetObjectIdFromName (objTypeId, objectEnum.ObjectName, TRUE);
                            if (delayedDeleteId) {
                                MemDbAddSingleLinkageByKeyHandle (
                                    delayedDeleteHandle,
                                    delayedDeleteId,
                                    0
                                    );
                            }
                        }
                    }

                    if (ticks) {
                        if (!IsmTickProgressBar (sliceId, 1)) {
                            failCode = ERROR_CANCELLED;
                            break;
                        }
                        ticks--;
                    } else if (CheckCancel()) {
                        failCode = ERROR_CANCELLED;
                        break;
                    }
                } while (pEnumNextVirtualObject (&objectEnum));
            }
            if (delayedDeleteHandle) {
                // OK, now let's see if we have some delayed delete here
                delayedDeleteList = MemDbGetSingleLinkageArrayByKeyHandle (
                                        delayedDeleteHandle,
                                        0,
                                        &delayedDeleteListNo
                                        );
                delayedDeleteListNo /= SIZEOF(KEYHANDLE);

                if ((delayedDeleteList) &&
                    (delayedDeleteListNo > 0)) {
                    delayedDeleteIndex = delayedDeleteListNo;
                    do {
                        delayedDeleteIndex --;
                        delayedDeleteId = *(delayedDeleteList + delayedDeleteIndex);
                        delayedObjectName = MemDbGetKeyFromHandle ((KEYHANDLE) delayedDeleteId, 1);
                        if (delayedObjectName) {
                            if (MemDbGetValueByHandle ((KEYHANDLE) delayedDeleteId, &delayedObjectTypeId)) {
                                // now we have everything to retry the delete
                                if (!RestoreObject (
                                        delayedObjectTypeId,
                                        delayedObjectName,
                                        NULL,
                                        OP_LOW_PRIORITY,
                                        NULL
                                        )) {
                                    failCode = GetLastError();
                                    if (failCode != ERROR_SUCCESS) {
                                        LOG ((
                                            IsmIsNonCriticalObject (delayedObjectTypeId, delayedObjectName)?LOG_WARNING:LOG_ERROR,
                                            (PCSTR) MSG_CANT_RESTORE_SOURCE_OBJECT,
                                            IsmGetObjectTypeName (objTypeId),
                                            IsmGetNativeObjectName (objTypeId, objectEnum.ObjectName)
                                            ));
                                        failCode = ERROR_SUCCESS;
                                    }
                                }
                            }
                            MemDbReleaseMemory (delayedObjectName);
                        }
                    } while (delayedDeleteIndex > 0);
                    MemDbReleaseMemory (delayedDeleteList);
                }
            }
            MemDbDeleteKey (delayedDeleteKey);
        }

        if (failCode != ERROR_SUCCESS) {
            IsmAbortObjectEnum (&objectEnum);
            SetLastError (failCode);
            if (tempDir [0]) {
                FiRemoveAllFilesInTree (tempDir);
            }
            return FALSE;
        }

        objTypeId &= (~PLATFORM_MASK);
        objTypeId = IsmGetNextObjectTypeId (objTypeId);
    }

    g_MakeProfilePermanent = TRUE;

    IsmDestroyObjectHandle (objPattern);

    pCallProgressBar (MIG_END_PHASE);

    g_CurrentPhase = 0;
    g_SliceBuffer.End = 0;

    if (tempDir [0]) {
        FiRemoveAllFilesInTree (tempDir);
    }

    return b;
}


MIG_TRANSPORTSTORAGEID
IsmRegisterTransport (
    IN      PCTSTR TypeString
    )
{
    MIG_TRANSPORTSTORAGEID transportStorageId;
    PCTSTR memdbKey;

    memdbKey = JoinPaths (S_TRANSPORT_TYPES, TypeString);
    transportStorageId = (MIG_TRANSPORTSTORAGEID) MemDbSetKey (memdbKey);
    FreePathString (memdbKey);

    if (!transportStorageId) {
        DEBUGMSG ((DBG_ISM, "Unable to set memdb key in IsmRegisterTransport"));
        EngineError ();
    }

    return transportStorageId;
}


BOOL
pEnumFirstTransportType (
    OUT     PMEMDB_ENUM EnumPtr
    )
{
    PCTSTR memdbPattern;
    BOOL b;

    memdbPattern = JoinPaths (S_TRANSPORT_TYPES, TEXT("*"));
    b = MemDbEnumFirst (
            EnumPtr,
            memdbPattern,
            ENUMFLAG_NORMAL,
            ENUMLEVEL_ALLLEVELS,
            ENUMLEVEL_ALLLEVELS
            );
    FreePathString (memdbPattern);

    return b;
}


BOOL
pEnumNextTransportType (
    IN OUT  PMEMDB_ENUM EnumPtr
    )
{
    return MemDbEnumNext (EnumPtr);
}


VOID
pAbortTransportTypeEnum (
    IN      PMEMDB_ENUM EnumPtr
    )
{
    MemDbAbortEnum (EnumPtr);
}


BOOL
IsmEnumFirstTransport (
    OUT     PMIG_TRANSPORTENUM Enum,
    IN      MIG_TRANSPORTSTORAGEID DesiredStorageId     OPTIONAL
    )
{
    PTRANSPORTENUMHANDLE handle;
    BOOL b;

    ZeroMemory (Enum, sizeof (MIG_TRANSPORTENUM));

    Enum->Handle = MemAllocZeroed (sizeof (TRANSPORTENUMHANDLE));
    handle = (PTRANSPORTENUMHANDLE) Enum->Handle;

    handle->DesiredStorageId = DesiredStorageId;

    b = EnumFirstHashTableString (&handle->TableEnum, g_TransportTable);

    if (!b) {
        IsmAbortTransportEnum (Enum);
        return FALSE;
    }

    handle->State = TESTATE_BEGINTRANSPORT;

    return IsmEnumNextTransport (Enum);
}


BOOL
IsmEnumNextTransport (
    IN OUT  PMIG_TRANSPORTENUM Enum
    )
{
    PTRANSPORTENUMHANDLE handle;
    PTRANSPORTDATA transportData;

    handle = (PTRANSPORTENUMHANDLE) Enum->Handle;
    if (!handle) {
        return FALSE;
    }

    for (;;) {
        switch (handle->State) {

        case TESTATE_BEGINTRANSPORT:
            //
            // Begin enumeration of all registered types
            //

            if (!pEnumFirstTransportType (&handle->MemDbEnum)) {
                handle->State = TESTATE_NEXTTRANSPORT;
            } else {
                handle->State = TESTATE_GETCAPS;
            }

            break;

        case TESTATE_GETCAPS:
            transportData = *((PTRANSPORTDATA *) handle->TableEnum.ExtraData);

            if (!transportData) {
                handle->State = TESTATE_NEXTTRANSPORT;
            } else {
                MYASSERT (transportData->TransportQueryCapabilities);

                if (handle->DesiredStorageId &&
                    handle->DesiredStorageId != (MIG_TRANSPORTSTORAGEID) handle->MemDbEnum.KeyHandle
                    ) {
                    handle->State = TESTATE_NEXTTRANSPORTTYPE;
                } else {

                    if (!transportData->TransportQueryCapabilities (
                                            (MIG_TRANSPORTSTORAGEID) handle->MemDbEnum.KeyHandle,
                                            &Enum->TransportType,
                                            &Enum->Capabilities,
                                            &Enum->FriendlyDescription
                                            )) {

                        handle->State = TESTATE_NEXTTRANSPORTTYPE;
                    } else {
                        handle->State = TESTATE_RETURN;
                    }
                }
            }

            break;

        case TESTATE_RETURN:
            Enum->TransportId = (MIG_TRANSPORTID) handle->TableEnum.Index;
            Enum->SupportedStorageId = (MIG_TRANSPORTSTORAGEID) handle->MemDbEnum.KeyHandle;

            handle->State = TESTATE_NEXTTRANSPORTTYPE;
            return TRUE;


        case TESTATE_NEXTTRANSPORTTYPE:
            if (!pEnumNextTransportType (&handle->MemDbEnum)) {
                pAbortTransportTypeEnum (&handle->MemDbEnum);
                handle->State = TESTATE_NEXTTRANSPORT;
            } else {
                handle->State = TESTATE_GETCAPS;
            }
            break;

        case TESTATE_NEXTTRANSPORT:
            if (!EnumNextHashTableString (&handle->TableEnum)) {
                handle->State = TESTATE_DONE;
            } else {
                handle->State = TESTATE_BEGINTRANSPORT;
            }
            break;

        case TESTATE_DONE:
            IsmAbortTransportEnum (Enum);
            return FALSE;
        }
    }
}


VOID
IsmAbortTransportEnum (
    IN      PMIG_TRANSPORTENUM Enum
    )
{
    PTRANSPORTENUMHANDLE handle = (PTRANSPORTENUMHANDLE) Enum->Handle;

    if (handle) {
        pAbortTransportTypeEnum (&handle->MemDbEnum);

        FreeAlloc (handle);
        INVALID_POINTER (handle);
    }

    ZeroMemory (Enum, sizeof (MIG_TRANSPORTENUM));
}


MIG_TRANSPORTID
IsmSelectTransport (
    IN      MIG_TRANSPORTSTORAGEID DesiredStorageId,
    IN      MIG_TRANSPORTTYPE TransportType,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities
    )
{
    MIG_TRANSPORTENUM e;
    MIG_TRANSPORTID result = 0;

    if (!DesiredStorageId) {
        return 0;
    }

    if (IsmEnumFirstTransport (&e, DesiredStorageId)) {
        do {
            if (e.TransportType != TransportType) {
                continue;
            }
            if ((e.Capabilities & RequiredCapabilities) == RequiredCapabilities) {
                result = e.TransportId;
                IsmAbortTransportEnum (&e);
                g_TransportType = TransportType;
                return result;
            }

        } while (IsmEnumNextTransport (&e));
    }

    DEBUGMSG ((DBG_ISM, "IsmSelectTransport: Requested transport type does not exist"));

    return result;
}


BOOL
IsmSetTransportStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTID TransportId,
    IN      MIG_TRANSPORTSTORAGEID DesiredStorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL StoragePathIsValid,                       OPTIONAL
    OUT     PBOOL ImageExistsInStorage                      OPTIONAL
    )
{
    PTRANSPORTDATA *ptrToTransportData;
    PTRANSPORTDATA transportData;
    BOOL b;
    BOOL valid;
    BOOL exists;
    PCTSTR sanitizedPath = NULL;

    if (!TransportId) {
        return FALSE;
    }

    if (!HtGetExtraData (g_TransportTable, (HASHITEM) TransportId, (PVOID *) &ptrToTransportData)) {
        return FALSE;
    }

    transportData = *ptrToTransportData;

    if (!transportData || !transportData->ShouldBeCalled) {
        return FALSE;
    }

    MYASSERT (transportData->TransportSetStorage);

    if (Platform == PLATFORM_CURRENT) {
        Platform = g_IsmCurrentPlatform;
    }

    if (g_SelectedTransport) {
        if (g_SelectedTransport->TransportResetStorage) {
            g_SelectedTransport->TransportResetStorage (g_SelectedTransportId);
        }

        g_SelectedTransport = NULL;
        g_SelectedTransportId = 0;
    }

    if (StoragePath) {
        sanitizedPath = SanitizePath (StoragePath);
    }

    b = transportData->TransportSetStorage (
                            Platform,
                            DesiredStorageId,
                            RequiredCapabilities,
                            sanitizedPath,
                            &valid,
                            &exists
                            );
    if (sanitizedPath) {
        FreePathString (sanitizedPath);
    }

    if (b) {
        if (StoragePathIsValid) {
            *StoragePathIsValid = valid;
        }

        if (ImageExistsInStorage) {
            *ImageExistsInStorage = exists;
        }

        g_SelectedTransport = transportData;
        g_SelectedTransportId = DesiredStorageId;
    }

    return b;
}


BOOL
IsmExecute (
    MIG_EXECUTETYPEID ExecuteType
    )
{
    static BOOL srcInitCompleted = FALSE;
    static BOOL destInitCompleted = FALSE;
    static BOOL vcmInitCompleted = FALSE;
    static BOOL srcModuleInitCompleted = FALSE;
    static BOOL destModuleInitCompleted = FALSE;
    static BOOL rollbackInitCompleted = FALSE;
    static BOOL vcmMode = FALSE;
    static BOOL normalMode = FALSE;
    static BOOL parsingDone = FALSE;
    static BOOL srcExecuteDone = FALSE;
    static BOOL destExecuteDone = FALSE;
    static BOOL delayedOperationsDone = FALSE;
    BOOL needVcmInit = FALSE;
    BOOL needSrcModuleInit = FALSE;
    BOOL needDestModuleInit = FALSE;
    BOOL needRollbackInit = FALSE;
    BOOL needTerminate = FALSE;
    BOOL needTransportTermination = FALSE;
    BOOL needDelayedOperationsTerminate = FALSE;
    BOOL parseEtm = FALSE;
    BOOL parseVcm = FALSE;
    BOOL processVcm = FALSE;
    BOOL parseSource = FALSE;
    BOOL processSource = FALSE;
    BOOL processDestination = FALSE;
    BOOL processDelayedOperations = FALSE;
    MIG_PLATFORMTYPEID platform = PLATFORM_SOURCE;
    PCTSTR journalFile;
    DWORD tempField;
    PCURRENT_USER_DATA currentUserData;
    BOOL cleanupOnly = FALSE;
    BOOL b = TRUE;

    if (CheckCancel ()) {
        return FALSE;
    }

    g_ExecutionInProgress = TRUE;

    switch (ExecuteType) {

    case EXECUTETYPE_VIRTUALCOMPUTER_PARSING:
        if (parsingDone) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_VIRTUALCOMPUTER_PARSING denied, parsing already executed"));
            b = FALSE;
            break;
        }

        if (normalMode) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_VIRTUALCOMPUTER_PARSING denied, not in virtual computer mode"));
            b = FALSE;
            break;
        }

        needVcmInit = TRUE;
        parseEtm = TRUE;
        parseVcm = TRUE;

        parsingDone = TRUE;
        vcmMode = TRUE;
        break;

    case EXECUTETYPE_VIRTUALCOMPUTER:
        if (srcExecuteDone) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_VIRTUALCOMPUTER denied, virtual computer already built"));
            b = FALSE;
            break;
        }

        if (normalMode) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_VIRTUALCOMPUTER denied, not in virtual computer mode"));
            b = FALSE;
            break;
        }

        needVcmInit = TRUE;
        processVcm = TRUE;
        needTerminate = TRUE;

        parsingDone = TRUE;
        vcmMode = TRUE;
        srcExecuteDone = TRUE;
        break;

    case EXECUTETYPE_EXECUTESOURCE_PARSING:
        if (vcmMode) {
            DEBUGMSG ((DBG_ERROR, "PARSING denied, in virtual computer mode"));
            b = FALSE;
            break;
        }

        if (parsingDone) {
            DEBUGMSG ((DBG_ERROR, "PARSING denied, it was already done"));
            b = FALSE;
            break;
        }

        needSrcModuleInit = TRUE;
        parseEtm = TRUE;
        parseSource = TRUE;

        parsingDone = TRUE;
        normalMode = TRUE;
        break;

    case EXECUTETYPE_EXECUTESOURCE:
        if (vcmMode) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_EXECUTESOURCE denied, in virtual computer mode"));
            b = FALSE;
            break;
        }

        if (srcExecuteDone) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_EXECUTESOURCE denied, source computer already processed"));
            b = FALSE;
            break;
        }

        if (destExecuteDone) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_EXECUTESOURCE denied, destination computer already processed"));
            b = FALSE;
            break;
        }

        needSrcModuleInit = TRUE;
        processSource = TRUE;
        needTerminate = TRUE;

        parsingDone = TRUE;
        normalMode = TRUE;
        srcExecuteDone = TRUE;
        break;

    case EXECUTETYPE_EXECUTEDESTINATION:
        if (!g_SelectedTransport || !g_SelectedTransport->ShouldBeCalled) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NO_TRANSPORT_SELECTED));
            b = FALSE;
            break;
        }

        if (vcmMode) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_EXECUTEDESTINATION denied, in virtual computer mode"));
            b = FALSE;
            break;
        }

        if (destExecuteDone) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_EXECUTEDESTINATION denied, destination computer already processed"));
            b = FALSE;
            break;
        }

        platform = PLATFORM_DESTINATION;
        needDestModuleInit = TRUE;
        needRollbackInit = TRUE;
        processDestination = TRUE;
        needTransportTermination = TRUE;
        needTerminate = TRUE;

        parsingDone = TRUE;
        normalMode = TRUE;
        destExecuteDone = TRUE;

        break;

    case EXECUTETYPE_DELAYEDOPERATIONS:
    case EXECUTETYPE_DELAYEDOPERATIONSCLEANUP:
        if (vcmMode) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_DELAYEDOPERATIONS denied, in virtual computer mode"));
            b = FALSE;
            break;
        }

        if (delayedOperationsDone) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_DELAYEDOPERATIONS denied, delayed operations already processed"));
            b = FALSE;
            break;
        }

        platform = PLATFORM_DESTINATION;
        destInitCompleted = TRUE;
        needRollbackInit = TRUE;
        needDelayedOperationsTerminate = TRUE;
        processDelayedOperations = TRUE;

        delayedOperationsDone = TRUE;
        cleanupOnly = (ExecuteType == EXECUTETYPE_DELAYEDOPERATIONSCLEANUP);
    }

    if (b) {
        g_IsmModulePlatformContext = platform;

        if (platform == PLATFORM_SOURCE) {
            if (!srcInitCompleted) {
                //
                // Complete initialization of all ISM components
                //

                b = InitializeProperties (platform, vcmMode);
                srcInitCompleted = TRUE;

                DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: src property init failed"));
            }
        } else {
            if (!destInitCompleted) {
                //
                // Complete initialization of all ISM components
                //

                b = InitializeProperties (platform, vcmMode);
                destInitCompleted = TRUE;

                DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: dest property init failed"));
            }
        }

        if (needVcmInit && !vcmInitCompleted) {
            //
            // Initialize the modules
            //

            b = InitializeVcmModules (NULL);
            vcmInitCompleted = TRUE;

            DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: VCM init failed"));
        }

        if (needSrcModuleInit && !srcModuleInitCompleted) {
            //
            // Initialize the modules
            //

            b = InitializeModules (platform, NULL);
            srcModuleInitCompleted = TRUE;

            DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: src module init failed"));
        }

        if (needRollbackInit && !rollbackInitCompleted) {

            //
            // remove all journal entries, prepare for a new apply
            //
            if (g_JournalDirectory) {
                FiRemoveAllFilesInTree (g_JournalDirectory);
                BfCreateDirectory (g_JournalDirectory);
                journalFile = JoinPaths (g_JournalDirectory, TEXT("JOURNAL.DAT"));
                g_JournalHandle = BfCreateFile (journalFile);
                if (g_JournalHandle) {
                    tempField = JRN_SIGNATURE;
                    BfWriteFile (g_JournalHandle, (PBYTE)(&tempField), sizeof (DWORD));
                    tempField = JRN_VERSION;
                    BfWriteFile (g_JournalHandle, (PBYTE)(&tempField), sizeof (DWORD));
                    FreePathString (journalFile);
                    currentUserData = GetCurrentUserData ();
                    if (currentUserData) {
                        pRecordUserData (
                            currentUserData->UserName,
                            currentUserData->UserDomain,
                            currentUserData->UserStringSid,
                            currentUserData->UserProfilePath,
                            FALSE
                            );
                        FreeCurrentUserData (currentUserData);
                    } else {
                        pRecordUserData (
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            FALSE
                            );
                    }
                }
            }
            ELSE_DEBUGMSG ((DBG_WHOOPS, "Journal directory does not exist."));

            rollbackInitCompleted = TRUE;
        }

        if (needDestModuleInit && !destModuleInitCompleted) {
            //
            // Initialize the modules
            //

            b = InitializeModules (platform, NULL);
            destModuleInitCompleted = TRUE;

            DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: dest module init failed"));
        }
    }

    if (b && parseEtm) {
        //
        // Execute the appropriate ETM parse functions
        //

        b = pEtmParse (NULL);
        DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: ETM parse failed"));

        b = b && !CheckCancel();
    }

    if (b && parseVcm) {
        //
        // Execute the appropriate virtual computer parse functions
        //

        b = pCreateComputerParse (NULL);
        DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: VCM parse failed"));

        b = b && !CheckCancel();
    }

    if (b && processVcm) {
        //
        // Execute the appropriate virtual computer gather functions
        //

        b = pCreateComputerGather (NULL);
        DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: VCM queue enumeration or gather callback failed"));

        b = b && !CheckCancel();
    }

    if (b && parseSource) {
        //
        // Execute the appropriate virtual computer parse functions
        //

        b = pSourceParse (NULL);
        DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: SGM parse failed"));

        b = b && !CheckCancel();
    }


    if (b && processSource) {
        //
        // Execute the appropriate source gather functions
        //

        b = pSourceGather (NULL);
        DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: SGM queue enumeration or gather callback failed"));

        b = b && !CheckCancel();

        if (b) {
            b = pSourceAnalyze (NULL);
            DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: SAM failed"));

            b = b && !CheckCancel();
        }
    }


    if (b && processDestination) {
        //
        // Execute the appropriate destination functions
        //

        b = pDestinationGather (NULL);
        DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: DGM queue enumeration or gather callback failed"));

        b = b && !CheckCancel();

        if (b) {
            b = pDestinationAnalyze (NULL);
            DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: DAM failed"));

            b = b && !CheckCancel();
        }

        if (b) {
            b = pDestinationApply (NULL);
            DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: dest apply failed"));

            b = b && !CheckCancel();
        }
    }

    if (b && processDelayedOperations) {
        //
        // Execute the appropriate delayed operations
        //

        b = ExecuteDelayedOperations (cleanupOnly);
        DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: delayed operations failed"));

    }

    if (needTransportTermination) {

        MYASSERT (g_SelectedTransport);
        MYASSERT (g_SelectedTransport->TransportEndApply);

        g_SelectedTransport->TransportEndApply ();
    }

    if (needTerminate) {
        //
        // Done -- terminate the modules
        //

        TerminateModules ();
        TerminateProperties (platform);
    }

    if (needDelayedOperationsTerminate) {
        pDeleteDelayedOperationsCommand ();
    }

    g_IsmModulePlatformContext = PLATFORM_CURRENT;

    if (g_JournalHandle) {
        CloseHandle (g_JournalHandle);
        g_JournalHandle = NULL;
    }

    g_ExecutionInProgress = FALSE;

    return b;
}


BOOL
IsmRegisterProgressBarCallback (
    IN      PPROGRESSBARFN ProgressBarFn,
    IN      ULONG_PTR Arg
    )
{
    if (CheckCancel ()) {
        return FALSE;
    }

    if (!ProgressBarFn) {
        g_ProgressBarFn = NULL;
        return TRUE;
    }

    if (g_ProgressBarFn) {
        DEBUGMSG ((DBG_ERROR, "Progress bar callback is already set"));
        return FALSE;
    }

    g_ProgressBarFn = ProgressBarFn;
    g_ProgressBarArg = Arg;

    return TRUE;
}


BOOL
pSaveStatistics (
    VOID
    )
{
    MIG_OBJECTCOUNT objectCount [3];

    MYASSERT (
        g_TotalObjects.TotalObjects ==
            g_SourceObjects.TotalObjects +
            g_DestinationObjects.TotalObjects
        );
    MYASSERT (
        g_TotalObjects.PersistentObjects ==
            g_SourceObjects.PersistentObjects +
            g_DestinationObjects.PersistentObjects
        );
    MYASSERT (
        g_TotalObjects.ApplyObjects ==
            g_SourceObjects.ApplyObjects +
            g_DestinationObjects.ApplyObjects
        );

    CopyMemory (&(objectCount [0]), &g_TotalObjects, sizeof (MIG_OBJECTCOUNT));
    CopyMemory (&(objectCount [1]), &g_SourceObjects, sizeof (MIG_OBJECTCOUNT));
    CopyMemory (&(objectCount [2]), &g_DestinationObjects, sizeof (MIG_OBJECTCOUNT));
    if (!MemDbSetUnorderedBlob (S_OBJECTCOUNT, 0, (PCBYTE)objectCount, 3 * sizeof (MIG_OBJECTCOUNT))) {
        return FALSE;
    }
    return SavePerObjectStatistics ();
}

BOOL
pLoadStatistics (
    VOID
    )
{
    PMIG_OBJECTCOUNT objectCount;
    DWORD size;

    objectCount = (PMIG_OBJECTCOUNT) MemDbGetUnorderedBlob (S_OBJECTCOUNT, 0, &size);
    if ((!objectCount) || (size != 3 * sizeof (MIG_OBJECTCOUNT))) {
        if (objectCount) {
            MemDbReleaseMemory (objectCount);
        }
        MYASSERT (FALSE);
        return FALSE;
    }
    CopyMemory (&g_TotalObjects, objectCount, sizeof (MIG_OBJECTCOUNT));
    CopyMemory (&g_SourceObjects, objectCount + 1, sizeof (MIG_OBJECTCOUNT));
    CopyMemory (&g_DestinationObjects, objectCount + 2, sizeof (MIG_OBJECTCOUNT));
    MemDbReleaseMemory (objectCount);

    MYASSERT (
        g_TotalObjects.TotalObjects ==
            g_SourceObjects.TotalObjects +
            g_DestinationObjects.TotalObjects
        );
    MYASSERT (
        g_TotalObjects.PersistentObjects ==
            g_SourceObjects.PersistentObjects +
            g_DestinationObjects.PersistentObjects
        );
    MYASSERT (
        g_TotalObjects.ApplyObjects ==
            g_SourceObjects.ApplyObjects +
            g_DestinationObjects.ApplyObjects
        );

    return LoadPerObjectStatistics ();
}

BOOL
pLoadLightDatabase (
    IN      PCTSTR FileName
    )
{
    HINF infHandle;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    INFSTRUCT is2 = INITINFSTRUCT_PMHANDLE;
    MIG_OBJECTTYPEID objectTypeId;
    GROWBUFFER buff = INIT_GROWBUFFER;
    PCTSTR field;
    MIG_OBJECTSTRINGHANDLE objectName;
    UINT index;
    PCTSTR scope;
    PCTSTR name;
    PCTSTR key;
    PCTSTR keyData;
    UINT envType;
    DWORD dummy;
    PCTSTR savedGroup;
    ENVENTRY_STRUCT envStruct;
    PTSTR decodedString = NULL;

    infHandle = InfOpenInfFile (FileName);

    if (infHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    // let's load transport variables
    if (InfFindFirstLine (infHandle, TEXT("Data Sections"), NULL, &is)) {
        do {
            name = InfGetStringField (&is, 1);

            if (name && InfFindFirstLine (infHandle, name, NULL, &is2)) {
                do {

                    key = InfGetStringField (&is2, 0);
                    keyData = InfGetStringField (&is2, 1);

                    if (key && keyData) {
                        IsmSetTransportVariable (PLATFORM_SOURCE, name, key, keyData);
                    }

                } while (InfFindNextLine (&is2));
            }

        } while (InfFindNextLine (&is));
    }

    // let's load source environment variables
    if (InfFindFirstLine (infHandle, TEXT("Environment"), NULL, &is)) {
        do {
            name = InfGetStringField (&is, 1);
            scope = InfGetStringField (&is, 2);
            field = InfGetStringField (&is, 3);
            if (scope && name && field) {

                _stscanf (field, TEXT("%lx"), &envType);
                buff.End = 0;

                switch (envType) {
                case ENVENTRY_STRING:
                    field = InfGetStringField (&is, 4);
                    if (field) {
                        GbCopyString (&buff, field);
                    }
                    break;
                case ENVENTRY_MULTISZ:
                    index = 4;
                    for (;;) {
                        field = InfGetStringField (&is, index);
                        if (!field) {
                            break;
                        }
                        GbCopyString (&buff, field);
                        index ++;
                    }
                    if (buff.End) {
                        GbCopyString (&buff, TEXT(""));
                    }
                    break;
                case ENVENTRY_BINARY:
                    index = 4;
                    for (;;) {
                        field = InfGetStringField (&is, index);
                        if (!field) {
                            break;
                        }
                        _stscanf (field, TEXT("%lx"), &dummy);
                        *((PBYTE)GbGrow (&buff, sizeof (BYTE))) = (BYTE)dummy;
                        index ++;
                    }
                    break;
                default:
                    // don't know what to write, it's just a flag
                    break;
                }

                // now let's add the environment variable
                envStruct.Type = envType;
                if (buff.End) {
                    envStruct.EnvBinaryData = buff.Buf;
                    envStruct.EnvBinaryDataSize = buff.End;
                } else {
                    envStruct.EnvBinaryData = NULL;
                    envStruct.EnvBinaryDataSize = 0;
                }
                savedGroup = g_CurrentGroup;
                g_CurrentGroup = scope;
                IsmSetEnvironmentValue (
                    PLATFORM_SOURCE,
                    (scope && *scope)?scope:NULL,
                    name,
                    &envStruct
                    );
                g_CurrentGroup = savedGroup;
            }
        } while (InfFindNextLine (&is));
    }

    // let's load object types
    if (InfFindFirstLine (infHandle, TEXT("Object Types"), NULL, &is)) {
        do {
            field = InfGetStringField (&is, 1);
            if (field) {
                MYASSERT (IsmGetObjectTypeId (field) != 0);
                if (IsmGetObjectTypeId (field) == 0) {
                    // we need to preregister this type
                    IsmRegisterObjectType (
                        field,
                        TRUE,
                        FALSE,
                        NULL
                        );
                }
            }
        } while (InfFindNextLine (&is));
    }
    InfCleanUpInfStruct (&is);

    TypeMgrRescanTypes ();

    objectTypeId = IsmGetFirstObjectTypeId ();
    while (objectTypeId) {

        if (InfFindFirstLine (infHandle, IsmGetObjectTypeName (objectTypeId), NULL, &is)) {
            do {
                index = 1;
                buff.End = 0;
                for (;;) {
                    field = InfGetStringField (&is, index);
                    if (!field) {
                        break;
                    }
                    if (*field) {
                        decodedString = DuplicatePathString (field, 0);
                        if (DecodeRuleChars (decodedString, field) != NULL) {
                            GbCopyString (&buff, decodedString);
                        } else {
                            GbCopyString (&buff, field);
                        }
                        FreePathString (decodedString);
                    } else {
                        GbCopyString (&buff, TEXT("<empty>"));
                    }
                    index ++;
                }
                if (buff.End) {
                    GbCopyString (&buff, TEXT(""));
                    if (IsmConvertMultiSzToObject (
                            objectTypeId,
                            (PCTSTR)buff.Buf,
                            &objectName,
                            NULL
                            )) {
                        // now save the object data into our database
                        // for future reference

                        IsmMakePersistentObject (objectTypeId | PLATFORM_SOURCE, objectName);

                        IsmDestroyObjectHandle (objectName);
                    }
                }

            } while (InfFindNextLine (&is));
        }

        objectTypeId = IsmGetNextObjectTypeId (objectTypeId);
    }

    InfCleanUpInfStruct (&is);
    InfCleanUpInfStruct (&is2);
    InfCloseInfFile (infHandle);
    GbFree (&buff);

    pSaveStatistics ();

    return TRUE;
}

BOOL
pFinishLoad (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE memDbObjectName;
    MIG_CONTENT memDbContent;
    BOOL result = FALSE;
    GROWLIST growList = INIT_GROWLIST;

    __try {

        switch (g_TransportType) {
        case TRANSPORTTYPE_LIGHT:

            if (!RegisterInternalAttributes ()) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INIT_FAILURE, 6));
                __leave;
            }

            memDbObjectName = IsmCreateObjectHandle (S_DATABASEFILE_LITE, NULL);
            if (!IsmAcquireObjectEx (MIG_DATA_TYPE | PLATFORM_SOURCE, memDbObjectName, &memDbContent, CONTENTTYPE_FILE, 0)) {
                IsmDestroyObjectHandle (memDbObjectName);
                DEBUGMSG ((DBG_ISM, "pFinishLoad: Failed to acquire VCM database"));
                __leave;
            }

            if (!pLoadLightDatabase (memDbContent.FileContent.ContentPath)) {
                IsmDestroyObjectHandle (memDbObjectName);
                IsmReleaseObject (&memDbContent);
                DEBUGMSG ((DBG_ISM, "pFinishLoad: Failed to load VCM database"));
                __leave;
            }
            IsmDestroyObjectHandle (memDbObjectName);
            IsmReleaseObject (&memDbContent);
            break;

        case TRANSPORTTYPE_FULL:

            //
            // Save environment into a grow list, because memdb is going to be reloaded
            //

            EnvSaveEnvironment (&growList);

            memDbObjectName = IsmCreateObjectHandle (S_DATABASEFILE_FULL, NULL);
            if (!IsmAcquireObjectEx (MIG_DATA_TYPE | PLATFORM_SOURCE, memDbObjectName, &memDbContent, CONTENTTYPE_FILE, 0)) {
                IsmDestroyObjectHandle (memDbObjectName);
                DEBUGMSG ((DBG_ISM, "pFinishLoad: Failed to acquire database"));
                __leave;
            }

            if (!MemDbLoad (memDbContent.FileContent.ContentPath)) {
                IsmDestroyObjectHandle (memDbObjectName);
                IsmReleaseObject (&memDbContent);
                DEBUGMSG ((DBG_ISM, "pFinishLoad: Failed to load database"));
                __leave;
            }
            IsmDestroyObjectHandle (memDbObjectName);
            IsmReleaseObject (&memDbContent);

            //
            // Rebuild all the things we lost because of the memdb refresh
            //

            TypeMgrRescanTypes ();

            if (!RegisterInternalAttributes ()) {
                DEBUGMSG ((DBG_ISM, "pFinishLoad: Failed to register persistent attrib"));
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INIT_FAILURE, 7));
                __leave;
            }

            EnvRestoreEnvironment (&growList);

            break;
        default:
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_UNKNOWN_TRANSPORT_TYPE, g_TransportType));
            __leave;
        }

        pLoadStatistics ();

        GlFree (&growList);

        EnvInvalidateCallbacks ();

        result = TRUE;
    }
    __finally {
    }

    return result;
}

BOOL
IsmLoad (
    VOID
    )
{
    BOOL result = FALSE;
    GROWLIST growList = INIT_GROWLIST;

    if (CheckCancel ()) {
        return FALSE;
    }

    if (!g_SelectedTransport || !g_SelectedTransport->ShouldBeCalled) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NO_TRANSPORT_SELECTED));
        return FALSE;
    }

    g_ExecutionInProgress = TRUE;

    //
    // We need to invalidate operation combinations created so far
    // because we might load a new memdb where all operations could
    // be registered already
    //
    TerminateOperations ();

    g_CurrentPhase = MIG_TRANSPORT_PHASE;
    g_SliceBuffer.End = 0;

    __try {

        if (g_SelectedTransport->TransportEstimateProgressBar) {
            g_SelectedTransport->TransportEstimateProgressBar (g_IsmCurrentPlatform);
        }
        pCallProgressBar (MIG_BEGIN_PHASE);

        MYASSERT (g_SelectedTransport->TransportBeginApply);

        if (!g_SelectedTransport->TransportBeginApply ()) {
            DEBUGMSG ((DBG_ISM, "IsmLoad: Begin apply failed"));
            __leave;
        }

        result = pFinishLoad ();
    }
    __finally {
        PushError ();
        pCallProgressBar (MIG_END_PHASE);
        g_CurrentPhase = 0;
        g_SliceBuffer.End = 0;
        PopError ();
    }

    if (!result) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_LOAD_FAILURE));
    }

    InitializeOperations ();

    g_ExecutionInProgress = FALSE;

    return result;
}

BOOL
IsmResumeLoad (
    VOID
    )
{
    BOOL result = FALSE;
    GROWLIST growList = INIT_GROWLIST;

    if (CheckCancel ()) {
        return FALSE;
    }

    if (!g_SelectedTransport || !g_SelectedTransport->ShouldBeCalled) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NO_TRANSPORT_SELECTED));
        return FALSE;
    }

    g_ExecutionInProgress = TRUE;

    //
    // We need to invalidate operation combinations created so far
    // because we might load a new memdb where all operations could
    // be registered already
    //
    TerminateOperations ();

    g_CurrentPhase = MIG_TRANSPORT_PHASE;
    g_SliceBuffer.End = 0;

    __try {

        if (g_SelectedTransport->TransportEstimateProgressBar) {
            g_SelectedTransport->TransportEstimateProgressBar (g_IsmCurrentPlatform);
        }
        pCallProgressBar (MIG_BEGIN_PHASE);

        if (!g_SelectedTransport->TransportResumeApply) {
            __leave;
        }

        if (!g_SelectedTransport->TransportResumeApply ()) {
            __leave;
        }

        result = pFinishLoad ();
    }
    __finally {
        pCallProgressBar (MIG_END_PHASE);
        g_CurrentPhase = 0;
        g_SliceBuffer.End = 0;
    }

    InitializeOperations ();

    g_ExecutionInProgress = FALSE;

    return result;
}

BOOL
pSaveLightDatabase (
    IN      PCTSTR FileName
    )
{
    HANDLE fileHandle = NULL;
    MIG_OBJECTTYPEID objectTypeId;
    ENV_ENTRY_ENUM envEntryEnum;
    MULTISZ_ENUM multiSzEnum;
    UINT size;
    TCHAR buffer[sizeof (DWORD) * 2 + 3];
    PCTSTR start;
    PCTSTR end;
    TCHAR section[256];
    TCHAR sectionLookahead[256];
    UINT pass;

    fileHandle = BfCreateFile (FileName);
    if (!fileHandle) {
        return FALSE;
    }

    WriteFileString (fileHandle, TEXT("[Version]\r\n"));
    WriteFileString (fileHandle, TEXT("signature=\"$CHICAGO$\"\r\n"));
    WriteFileString (fileHandle, TEXT("Class=Upgrade\r\n\r\n\r\n"));

    //
    // Write sections for lite transport
    //

    for (pass = 0 ; pass < 2 ; pass++) {
        if (EnvEnumerateFirstEntry (
                &envEntryEnum,
                PLATFORM_SOURCE,
                TEXT("*\\") S_TRANSPORT_PREFIX TEXT("\\*")
                )) {

            if (pass == 0) {
                WriteFileString (fileHandle, TEXT("[Data Sections]\r\n"));
            }

            *section = 0;

            do {
                if (envEntryEnum.EnvEntryType != ENVENTRY_STRING) {
                    continue;
                }

                if (!envEntryEnum.EnvEntryDataSize || !envEntryEnum.EnvEntryData) {
                    continue;
                }

                if (envEntryEnum.EnvEntryName) {
                    //
                    // Find start and end of section name
                    //

                    start = envEntryEnum.EnvEntryName;
                    end = _tcschr (start, TEXT('\\'));
                    if (!end) {
                        continue;
                    }

                    start = end + 1;
                    end = _tcschr (start, TEXT('\\'));

                    if (end && (end - start) < (ARRAYSIZE (sectionLookahead) - 2)) {
                        //
                        // Copy section name into lookahead buffer
                        //

                        StringCopyAB (sectionLookahead, start, end);

                        //
                        // Ignore if no keys exist
                        //

                        start = _tcsinc (end);
                        if (*start == 0) {
                            continue;
                        }

                        //
                        // If lookahead buffer != last section, write section name
                        //

                        if (StringICompare (section, sectionLookahead)) {
                            if (pass == 1 && *section) {
                                WriteFileString (fileHandle, TEXT("\r\n"));
                            }

                            StringCopy (section, sectionLookahead);

                            if (pass == 1) {
                                WriteFileString (fileHandle, TEXT("["));
                            }

                            WriteFileString (fileHandle, section);

                            if (pass == 1) {
                                WriteFileString (fileHandle, TEXT("]\r\n"));
                            } else {
                                WriteFileString (fileHandle, TEXT("\r\n"));
                            }
                        }

                        //
                        // If pass 1, write the key=value text
                        //

                        if (pass == 1) {
                            WriteFileString (fileHandle, start);
                            WriteFileString (fileHandle, TEXT(" = "));
                            WriteFileString (fileHandle, (PCTSTR)envEntryEnum.EnvEntryData);
                            WriteFileString (fileHandle, TEXT("\r\n"));
                        }
                    }
                }

            } while (EnvEnumerateNextEntry (&envEntryEnum));
            AbortEnvEnumerateEntry (&envEntryEnum);

            if (*section == 0) {
                WriteFileString (fileHandle, TEXT("; empty\r\n\r\n"));
            } else {
                WriteFileString (fileHandle, TEXT("\r\n"));
            }
        }
    }

    WriteFileString (fileHandle, TEXT("[Environment]\r\n"));
    if (EnvEnumerateFirstEntry (&envEntryEnum, PLATFORM_SOURCE, TEXT("*"))) {
        do {
            // skip v1 hack variables
            if (envEntryEnum.EnvEntryName) {

                if (StringIMatchCharCount (
                        S_TRANSPORT_PREFIX TEXT("\\"),
                        envEntryEnum.EnvEntryName,
                        ARRAYSIZE (S_TRANSPORT_PREFIX)
                        )) {
                    continue;
                }
            }

            // write the group and the name
            WriteFileString (fileHandle, TEXT("\""));
            if (envEntryEnum.EnvEntryName) {
                WriteFileString (fileHandle, envEntryEnum.EnvEntryName);
            }
            WriteFileString (fileHandle, TEXT("\",\""));
            if (envEntryEnum.EnvEntryGroup) {
                WriteFileString (fileHandle, envEntryEnum.EnvEntryGroup);
            }
            WriteFileString (fileHandle, TEXT("\","));
            // now write the entry type
            wsprintf (buffer, TEXT("0x%08X"), envEntryEnum.EnvEntryType);
            WriteFileString (fileHandle, buffer);

            switch (envEntryEnum.EnvEntryType) {
            case ENVENTRY_STRING:
                if (envEntryEnum.EnvEntryDataSize && envEntryEnum.EnvEntryData) {
                    WriteFileString (fileHandle, TEXT(",\""));
                    WriteFileString (fileHandle, (PCTSTR)envEntryEnum.EnvEntryData);
                    WriteFileString (fileHandle, TEXT("\""));
                }
                break;
            case ENVENTRY_MULTISZ:
                if (envEntryEnum.EnvEntryDataSize && envEntryEnum.EnvEntryData) {
                    if (EnumFirstMultiSz (&multiSzEnum, (PCTSTR)envEntryEnum.EnvEntryData)) {
                        do {
                            WriteFileString (fileHandle, TEXT(",\""));
                            WriteFileString (fileHandle, multiSzEnum.CurrentString);
                            WriteFileString (fileHandle, TEXT("\""));
                        } while (EnumNextMultiSz (&multiSzEnum));
                    }
                }
                break;
            case ENVENTRY_BINARY:
                if (envEntryEnum.EnvEntryDataSize && envEntryEnum.EnvEntryData) {
                    // write it in binary format
                    size = 0;
                    while (size < envEntryEnum.EnvEntryDataSize) {
                        wsprintf (
                            buffer,
                            TEXT("%02X"),
                            envEntryEnum.EnvEntryData [size]
                            );
                        WriteFileString (fileHandle, TEXT(","));
                        WriteFileString (fileHandle, buffer);
                        size ++;
                    }
                }
                break;
            default:
                // don't know what to write, it's just a flag
                break;
            }
            WriteFileString (fileHandle, TEXT("\r\n"));
        } while (EnvEnumerateNextEntry (&envEntryEnum));
        AbortEnvEnumerateEntry (&envEntryEnum);
    }
    WriteFileString (fileHandle, TEXT("\r\n\r\n"));

    WriteFileString (fileHandle, TEXT("[Object Types]\r\n"));
    objectTypeId = IsmGetFirstObjectTypeId ();
    while (objectTypeId) {
        WriteFileString (fileHandle, IsmGetObjectTypeName (objectTypeId));
        WriteFileString (fileHandle, TEXT("\r\n"));
        objectTypeId = IsmGetNextObjectTypeId (objectTypeId);
    }
    WriteFileString (fileHandle, TEXT("\r\n\r\n"));

    CloseHandle (fileHandle);

    return TRUE;
}

BOOL
IsmSave (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE memDbObjectName;
    TCHAR tempPath [MAX_PATH];
    BOOL result = FALSE;

    if (CheckCancel ()) {
        return FALSE;
    }

    if (!g_SelectedTransport || !g_SelectedTransport->ShouldBeCalled) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NO_TRANSPORT_SELECTED));
        return FALSE;
    }

    __try {
        g_ExecutionInProgress = TRUE;

        if (!IsmGetTempFile (tempPath, ARRAYSIZE(tempPath))) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_SAVE_MEMDB));
            __leave;
        }

        switch (g_TransportType) {

        case TRANSPORTTYPE_LIGHT:
            memDbObjectName = IsmCreateObjectHandle (S_DATABASEFILE_LITE, NULL);
            DataTypeAddObject (memDbObjectName, tempPath, TRUE);
            IsmDestroyObjectHandle (memDbObjectName);
            if (!pSaveLightDatabase (tempPath)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_SAVE_MEMDB));
                __leave;
            }
            break;

        case TRANSPORTTYPE_FULL:
            memDbObjectName = IsmCreateObjectHandle (S_DATABASEFILE_FULL, NULL);
            DataTypeAddObject (memDbObjectName, tempPath, TRUE);
            IsmDestroyObjectHandle (memDbObjectName);
            pSaveStatistics ();
            if (!MemDbSave (tempPath)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_SAVE_MEMDB));
                __leave;
            }
            break;

        default:
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_UNKNOWN_TRANSPORT_TYPE, g_TransportType));
            __leave;
        }

        EnvInvalidateCallbacks ();

        g_CurrentPhase = MIG_TRANSPORT_PHASE;
        g_SliceBuffer.End = 0;

        if (g_SelectedTransport->TransportEstimateProgressBar) {
            g_SelectedTransport->TransportEstimateProgressBar (g_IsmCurrentPlatform);
        }
        pCallProgressBar (MIG_BEGIN_PHASE);

        result = g_SelectedTransport->TransportSaveState ();

        if (result) {
            DeleteFile (tempPath);
        } else {
            DEBUGMSG ((DBG_ISM, "TransportSaveState failed"));
            // NTRAID#NTBUG9-168115-2000/08/23-jimschm Temp file is not cleaned up here or in resume below
        }

        pCallProgressBar (MIG_END_PHASE);
        g_CurrentPhase = 0;
        g_SliceBuffer.End = 0;

    }
    __finally {
        g_ExecutionInProgress = FALSE;
    }

    if (!result) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_SAVE_FAILURE));
    }

    return result;
}

BOOL
IsmResumeSave (
    VOID
    )
{
    BOOL result;

    if (CheckCancel ()) {
        return FALSE;
    }

    if (!g_SelectedTransport || !g_SelectedTransport->ShouldBeCalled) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NO_TRANSPORT_SELECTED));
        return FALSE;
    }

    if (!g_SelectedTransport->TransportResumeSaveState) {
        return FALSE;
    }

    g_ExecutionInProgress = TRUE;

    EnvInvalidateCallbacks ();

    g_CurrentPhase = MIG_TRANSPORT_PHASE;
    g_SliceBuffer.End = 0;

    if (g_SelectedTransport->TransportEstimateProgressBar) {
        g_SelectedTransport->TransportEstimateProgressBar (g_IsmCurrentPlatform);
    }
    pCallProgressBar (MIG_BEGIN_PHASE);

    result = g_SelectedTransport->TransportResumeSaveState ();

    DEBUGMSG_IF ((!result, DBG_ISM, "TransportResumeSaveState failed"));

    pCallProgressBar (MIG_END_PHASE);
    g_CurrentPhase = 0;
    g_SliceBuffer.End = 0;

    g_ExecutionInProgress = FALSE;

    return result;
}

PVOID
TrackedIsmGetMemory (
    IN      UINT Size
            TRACKING_DEF
    )
{
    PVOID result;

    TRACK_ENTER();

    if (!g_IsmPool) {
        g_IsmPool = PmCreateNamedPool ("ISM Pool");
    }

    result = PmGetMemory (g_IsmPool, Size);

    TRACK_LEAVE();
    return result;
}


PCTSTR
TrackedIsmDuplicateString (
    IN      PCTSTR String
            TRACKING_DEF
    )
{
    PCTSTR result;

    TRACK_ENTER();

    if (!g_IsmPool) {
        g_IsmPool = PmCreateNamedPool ("ISM Pool");
    }

    result = PmDuplicateString (g_IsmPool, String);

    TRACK_LEAVE();
    return result;
}


BOOL
IsmReleaseMemory (
    IN      PCVOID Memory
    )
{
    if (g_IsmPool && Memory) {
        PmReleaseMemory (g_IsmPool, Memory);
        return TRUE;
    } else {
        return FALSE;
    }
}


MIG_OBJECTSTRINGHANDLE
TrackedIsmCreateObjectHandle (
    IN      PCTSTR Node,
    IN      PCTSTR Leaf
            TRACKING_DEF
    )
{
    MIG_OBJECTSTRINGHANDLE result;

    TRACK_ENTER();

    result = ObsBuildEncodedObjectStringEx (Node, Leaf, TRUE);

    TRACK_LEAVE();

    return result;
}


BOOL
WINAPI
TrackedIsmCreateObjectStringsFromHandleEx (
    IN      MIG_OBJECTSTRINGHANDLE Handle,
    OUT     PCTSTR *Node,               OPTIONAL
    OUT     PCTSTR *Leaf,               OPTIONAL
    IN      BOOL DoNotDecode
            TRACKING_DEF
    )
{
    BOOL result;

    TRACK_ENTER();
    result = ObsSplitObjectStringEx (
                Handle,
                Node,
                Leaf,
                NULL,
                !DoNotDecode
                );

    if (!result) {
        if (Node) {
            *Node = NULL;
        }

        if (Leaf) {
            *Leaf = NULL;
        }
    }

    TRACK_LEAVE();

    return result;
}

VOID
IsmDestroyObjectString (
    IN      PCTSTR String
    )
{
    ObsFree (String);
}

VOID
IsmDestroyObjectHandle (
    IN      MIG_OBJECTSTRINGHANDLE Handle
    )
{
    ObsFree (Handle);
}


BOOL
IsmIsObjectHandleNodeOnly (
    IN      MIG_OBJECTSTRINGHANDLE Handle
    )
{
    return ObsGetLeafPortionOfEncodedString (Handle) == NULL;
}


BOOL
IsmIsObjectHandleLeafOnly (
    IN      MIG_OBJECTSTRINGHANDLE Handle
    )
{
    return !ObsHasNode (Handle);
}


PCTSTR
pCreatePatternStr (
    IN      PMIG_SEGMENTS Segments,                 OPTIONAL
    IN      UINT Count
    )
{
    PTSTR result;
    UINT size;
    UINT u;
    PTSTR p;

    if (Segments == ALL_PATTERN) {

        result = DuplicatePathString (TEXT("*"), 0);

    } else if (Segments && Count) {
        //
        // Compute the buffer size needed: logchars * DBCS * escaping + nul
        //

        size = 1;

        for (u = 0; u < Count ; u++) {

            if (!Segments[u].IsPattern) {
                size += TcharCount (Segments[u].Segment) * 2;
            } else {
                size += TcharCount (Segments[u].Segment);
            }
        }

#ifndef UNICODE
        size *= 2;      // account for dbcs expansion
#endif

        result = AllocPathString (size);
        p = result;

        //
        // Build the pattern
        //

        *p = 0;
        for (u = 0; u < Count ; u ++) {

            if (!Segments[u].IsPattern) {
                ObsEncodeString (p, Segments[u].Segment);
                p = GetEndOfString (p);
            } else {
                p = StringCat (p, Segments[u].Segment);
            }
        }

    } else {
        result = DuplicatePathString (TEXT(""), 0);
    }

    return result;
}


MIG_OBJECTSTRINGHANDLE
TrackedIsmCreateObjectPattern (
    IN      PMIG_SEGMENTS NodeSegments,             OPTIONAL
    IN      UINT NodeSegmentsNr,
    IN      PMIG_SEGMENTS LeafSegments,             OPTIONAL
    IN      UINT LeafSegmentsNr
            TRACKING_DEF
    )
{
    PCTSTR node;
    PCTSTR leaf;
    ENCODEDSTRHANDLE result;

    TRACK_ENTER();

    if (NodeSegments == ALL_PATTERN) {
        NodeSegmentsNr = 1;
    }

    if (LeafSegments == ALL_PATTERN) {
        LeafSegmentsNr = 1;
    }

    node = pCreatePatternStr (NodeSegments, NodeSegmentsNr);
    leaf = pCreatePatternStr (LeafSegments, LeafSegmentsNr);

    result = ObsBuildEncodedObjectStringEx (NodeSegmentsNr ? node : NULL, LeafSegmentsNr ? leaf : NULL, FALSE);

    FreePathString (node);
    FreePathString (leaf);

    TRACK_LEAVE();

    return result;
}


MIG_OBJECTSTRINGHANDLE
TrackedIsmCreateSimpleObjectPattern (
    IN      PCTSTR BaseNode,                    OPTIONAL
    IN      BOOL EnumTree,
    IN      PCTSTR Leaf,                        OPTIONAL
    IN      BOOL LeafIsPattern
            TRACKING_DEF
    )
{
    MIG_SEGMENTS nodePat[2];
    MIG_SEGMENTS leafPat[1];
    UINT nrSegNode = 0;
    UINT nrSegLeaf = 0;
    PCTSTR p;
    MIG_OBJECTSTRINGHANDLE result;

    TRACK_ENTER();

    if (BaseNode) {
        nodePat [0].Segment = BaseNode;
        nodePat [0].IsPattern = FALSE;
        nrSegNode ++;
    }

    if (EnumTree) {
        if (nrSegNode) {
            p = _tcsdec2 (BaseNode, GetEndOfString (BaseNode));
            if (p && _tcsnextc (p) == TEXT('\\')) {
                nodePat [nrSegNode].Segment = TEXT("*");
            } else {
                nodePat [nrSegNode].Segment = TEXT("\\*");
            }
        } else {
            nodePat [nrSegNode].Segment = TEXT("*");
        }

        nodePat [nrSegNode].IsPattern = TRUE;
        nrSegNode ++;
    }

    if (Leaf) {
        leafPat [0].Segment = Leaf;
        leafPat [0].IsPattern = LeafIsPattern;
        nrSegLeaf ++;
    } else {
        if (LeafIsPattern) {
            leafPat [0].Segment = TEXT("*");
            leafPat [0].IsPattern = TRUE;
            nrSegLeaf ++;
        }
    }

    result = IsmCreateObjectPattern (nrSegNode?nodePat:NULL, nrSegNode, nrSegLeaf?leafPat:NULL, nrSegLeaf);

    TRACK_LEAVE();

    return result;
}

PTSTR
GetFirstSeg (
    IN      PCTSTR SrcFileName
    )
{
    if (_tcsnextc (SrcFileName) == TEXT('\\')) {
        SrcFileName = _tcsinc (SrcFileName);
        if (_tcsnextc (SrcFileName) == TEXT('\\')) {
            SrcFileName = _tcsinc (SrcFileName);
        }
        return (_tcschr (SrcFileName, TEXT('\\')));
    } else {
        return (_tcschr (SrcFileName, TEXT('\\')));
    }
}


BOOL
pAddShortLongInfo (
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    PTSTR nativeName = NULL;
    PTSTR nativeNamePtr;
    PTSTR beginSegPtr;
    PTSTR endSegPtr;
    TCHAR savedChar;
    WIN32_FIND_DATA findData;
    UINT savedEnd;
    UINT beginBuffIdx;
    BOOL result = FALSE;
    KEYHANDLE kh1, kh2;
    BOOL b;

    if (IsmCreateObjectStringsFromHandle (EncodedObjectName, &node, &leaf)) {
        MYASSERT (node);
        if (leaf) {
            nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node) + SizeOfString (leaf));
        } else {
            nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node));
        }
        nativeNamePtr = AppendWack (nativeName);
        StringCopy (nativeNamePtr, node);
        if (leaf) {
            StringCopy (AppendWack (nativeNamePtr), leaf);
        }

        GbAppendString (&growBuf, S_SHORTLONG_TREE);
        GbAppendString (&growBuf, TEXT("\\"));
        beginBuffIdx = growBuf.End - 1;

        beginSegPtr = GetFirstSeg (nativeNamePtr);

        if (beginSegPtr) {

            beginSegPtr = _tcsinc (beginSegPtr);

            GbAppendStringAB (&growBuf, nativeNamePtr, beginSegPtr);

            while (beginSegPtr) {
                endSegPtr = _tcschr (beginSegPtr, TEXT('\\'));
                if (!endSegPtr) {
                    endSegPtr = GetEndOfString (beginSegPtr);
                    MYASSERT (endSegPtr);
                }

                savedChar = *endSegPtr;
                *endSegPtr = 0;

                if (DoesFileExistEx (nativeNamePtr, &findData)) {
                    if (*findData.cAlternateFileName) {
                        savedEnd = growBuf.End - 1;
                        GbAppendString (&growBuf, findData.cAlternateFileName);
                        kh1 = MemDbAddKey (nativeName);
                        if (kh1) {
                            kh2 = MemDbAddKey ((PCTSTR) growBuf.Buf);
                            if (kh2) {
                                b = MemDbSetValueByHandle (kh1, FILENAME_LONG);
                                b = b && MemDbSetValueByHandle (kh2, FILENAME_SHORT);
                                b = b && MemDbAddDoubleLinkageByKeyHandle (kh1, kh2, 0);
                            } else {
                                b = FALSE;
                            }

                            if (!b) {
                                MemDbDeleteKey (nativeName);
                            }
                        }

                        growBuf.End = savedEnd;
                    }
                    GbAppendString (&growBuf, findData.cFileName);
                } else {
                    GbAppendStringAB (&growBuf, beginSegPtr, endSegPtr);
                }
                *endSegPtr = savedChar;
                if (savedChar) {
                    beginSegPtr = _tcsinc (endSegPtr);
                    GbAppendStringAB (&growBuf, endSegPtr, beginSegPtr);
                } else {
                    beginSegPtr = NULL;
                }
            }
        }
        FreePathString (nativeName);
        if (node) {
            IsmDestroyObjectString (node);
        }
        if (leaf) {
            IsmDestroyObjectString (leaf);
        }
    }
    GbFree (&growBuf);
    return result;
}


BOOL
pGetShortName (
    IN      PCTSTR Segment,
    OUT     WIN32_FIND_DATA *FindData
    )
{
    static TCHAR tempDir [MAX_PATH] = TEXT("");
    PCTSTR testFileName;
    HANDLE fileHandle;
    BOOL result = FALSE;

    if (tempDir [0] == 0) {
        IsmGetTempDirectory (tempDir, ARRAYSIZE(tempDir));
    }

    testFileName = JoinPaths (tempDir, Segment);
    fileHandle = BfCreateFile (testFileName);
    if (fileHandle) {
        CloseHandle (fileHandle);
        if (DoesFileExistEx (testFileName, FindData)) {
            result = TRUE;
        }
        DeleteFile (testFileName);
    }
    FreePathString (testFileName);
    return result;
}

BOOL
pAddShortLongInfoOnDest (
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    PTSTR nativeName = NULL;
    PTSTR nativeNamePtr;
    PTSTR beginSegPtr;
    PTSTR endSegPtr;
    PCTSTR shortSeg = NULL;
    TCHAR savedChar;
    WIN32_FIND_DATA findData;
    UINT savedEnd;
    UINT beginBuffIdx;
    BOOL result = FALSE;
    KEYHANDLE kh1, kh2;
    BOOL b;

    if (IsmCreateObjectStringsFromHandle (EncodedObjectName, &node, &leaf)) {
        MYASSERT (node);
        if (leaf) {
            nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node) + SizeOfString (leaf));
        } else {
            nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node));
        }
        nativeNamePtr = AppendWack (nativeName);
        StringCopy (nativeNamePtr, node);
        if (leaf) {
            StringCopy (AppendWack (nativeNamePtr), leaf);
        }

        GbAppendString (&growBuf, S_SHORTLONG_TREE);
        GbAppendString (&growBuf, TEXT("\\"));
        beginBuffIdx = growBuf.End - 1;

        beginSegPtr = GetFirstSeg (nativeNamePtr);

        if (beginSegPtr) {

            beginSegPtr = _tcsinc (beginSegPtr);

            GbAppendStringAB (&growBuf, nativeNamePtr, beginSegPtr);

            while (beginSegPtr) {
                endSegPtr = _tcschr (beginSegPtr, TEXT('\\'));
                if (!endSegPtr) {
                    endSegPtr = GetEndOfString (beginSegPtr);
                    MYASSERT (endSegPtr);
                }

                savedChar = *endSegPtr;
                *endSegPtr = 0;

                if (pGetShortName (beginSegPtr, &findData)) {
                    if (*findData.cAlternateFileName) {
                        savedEnd = growBuf.End - 1;
                        GbAppendString (&growBuf, findData.cAlternateFileName);
                        kh1 = MemDbAddKey (nativeName);
                        if (kh1) {
                            kh2 = MemDbAddKey ((PCTSTR) growBuf.Buf);
                            if (kh2) {
                                b = MemDbSetValueByHandle (kh1, FILENAME_LONG);
                                b = b && MemDbSetValueByHandle (kh2, FILENAME_SHORT);
                                b = b && MemDbAddDoubleLinkageByKeyHandle (kh1, kh2, 0);
                            } else {
                                b = FALSE;
                            }

                            if (!b) {
                                MemDbDeleteKey (nativeName);
                            }
                        }

                        growBuf.End = savedEnd;
                    }
                    GbAppendString (&growBuf, findData.cFileName);
                } else {
                    GbAppendStringAB (&growBuf, beginSegPtr, endSegPtr);
                }
                *endSegPtr = savedChar;
                if (savedChar) {
                    beginSegPtr = _tcsinc (endSegPtr);
                    GbAppendStringAB (&growBuf, endSegPtr, beginSegPtr);
                } else {
                    beginSegPtr = NULL;
                }
            }
        }
        FreePathString (nativeName);
        if (node) {
            IsmDestroyObjectString (node);
        }
        if (leaf) {
            IsmDestroyObjectString (leaf);
        }
    }
    GbFree (&growBuf);
    return result;
}


MIG_OBJECTID
IsmGetObjectIdFromName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      BOOL MustExist
    )
{
    MIG_OBJECTID result = 0;
    KEYHANDLE objectId;
    PCTSTR decoratedPath;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    __try {
        decoratedPath = GetDecoratedObjectPathFromName (ObjectTypeId, EncodedObjectName, FALSE);

        if (!decoratedPath) {
            __leave;
        }

        if (MustExist) {

            objectId = MemDbGetHandleFromKey (decoratedPath);

        } else {

            objectId = MemDbSetKey (decoratedPath);

            // if GetLastError = ERROR_ALREADY_EXISTS we don't have to do
            // anything, the object is already in our database
            if (GetLastError () == ERROR_SUCCESS) {

                if (MemDbSetValueByHandle (objectId, ObjectTypeId)) {

                    g_TotalObjects.TotalObjects ++;

                    if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
                        g_SourceObjects.TotalObjects ++;
                    } else {
                        g_DestinationObjects.TotalObjects ++;
                    }

                    IncrementTotalObjectCount (ObjectTypeId);

                    if (ObjectTypeId == (MIG_FILE_TYPE|PLATFORM_SOURCE)) {
                        //
                        // fire up the short-long algorithm
                        //
                        if (g_IsmCurrentPlatform == PLATFORM_SOURCE) {
                            pAddShortLongInfo (EncodedObjectName);
                        } else {
                            pAddShortLongInfoOnDest (EncodedObjectName);
                        }
                    }

                } else {
                    objectId = 0;
                }
            }

            if (!objectId) {
                EngineError ();
                __leave;
            }
        }

        result = (MIG_OBJECTID) objectId;
    }
    __finally {
        FreePathString (decoratedPath);
        INVALID_POINTER (decoratedPath);
    }

    return result;

}


MIG_OBJECTID
GetObjectIdForModification (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    )
{
    if (!CanObjectTypeBeModified (ObjectTypeId)) {
        return 0;
    }
    return IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, FALSE);
}


BOOL
pEnumFirstVirtualObject (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern
    )
{
    PCTSTR decoratedPath = NULL;
    BOOL result = FALSE;
    POBJECTENUM_HANDLE handle;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    ZeroMemory (ObjectEnum, sizeof (MIG_OBJECT_ENUM));
    ObjectEnum->ObjectTypeId = ObjectTypeId;
    ObjectEnum->Handle = MemAllocZeroed (sizeof (OBJECTENUM_HANDLE));

    handle = ObjectEnum->Handle;

    __try {

        if (!ObsHasNode (ObjectPattern)) {
            DEBUGMSG ((DBG_ERROR, "Pattern %s has nul node", ObjectPattern));
            __leave;
        }

        decoratedPath = GetDecoratedObjectPathFromName (ObjectTypeId, ObjectPattern, TRUE);

        if (!decoratedPath) {
            __leave;
        }

        if (DbEnumFirst (
                ObjectTypeId,
                &handle->MemDbEnum,
                decoratedPath,
                &handle->ParsedPatterns
                )) {

            ObjectEnum->ObjectName = handle->MemDbEnum.KeyName;
            ObjectEnum->ObjectId = (MIG_OBJECTID) handle->MemDbEnum.KeyHandle;
            result = TRUE;
        }
    }
    __finally {
        FreePathString (decoratedPath);
        INVALID_POINTER (decoratedPath);

        if (!result) {
            pAbortVirtualObjectEnum (ObjectEnum);
        }
    }

    return result;
}


BOOL
pEnumNextVirtualObject (
    IN OUT  PMIG_OBJECT_ENUM ObjectEnum
    )
{
    BOOL result = FALSE;
    POBJECTENUM_HANDLE handle;

    handle = ObjectEnum->Handle;

    if (MemDbEnumNext (&handle->MemDbEnum)) {
        ObjectEnum->ObjectName = handle->MemDbEnum.KeyName;
        ObjectEnum->ObjectId = (MIG_OBJECTID) handle->MemDbEnum.KeyHandle;
        result = TRUE;
    } else {
        pAbortVirtualObjectEnum (ObjectEnum);
    }

    return result;
}


VOID
pAbortVirtualObjectEnum (
    IN      PMIG_OBJECT_ENUM ObjectEnum
    )
{
    POBJECTENUM_HANDLE handle;

    handle = ObjectEnum->Handle;

    if (handle) {

        DbEnumFreeStruct (&handle->ParsedPatterns);
        MemDbAbortEnum (&handle->MemDbEnum);

        FreeAlloc (handle);
        INVALID_POINTER (ObjectEnum->Handle);
    }

    ZeroMemory (ObjectEnum, sizeof (MIG_OBJECT_ENUM));
}


BOOL
IsmEnumFirstSourceObjectEx (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      BOOL EnumerateVirtualObjects
    )
{
    //
    // First fix ObjectTypeId
    //
    ObjectTypeId &= (~PLATFORM_MASK);
    ObjectTypeId |= PLATFORM_SOURCE;

    //
    // If this is the destination or we are forced, then we enumerate virtual objects
    //

    if (EnumerateVirtualObjects ||
        (g_IsmModulePlatformContext == PLATFORM_CURRENT && g_IsmCurrentPlatform == PLATFORM_DESTINATION) ||
        g_IsmModulePlatformContext == PLATFORM_DESTINATION
        ) {
        return pEnumFirstVirtualObject (ObjectEnum, ObjectTypeId, ObjectPattern);
    }
    return EnumFirstPhysicalObject (ObjectEnum, ObjectTypeId, ObjectPattern);
}


BOOL
IsmEnumNextObject (
    IN OUT  PMIG_OBJECT_ENUM ObjectEnum
    )
{
    //
    // Verify enumeration has not completed
    //

    if (!ObjectEnum->Handle) {
        return FALSE;
    }

    //
    // If ObjectId is specified, we are enumerating the ISM
    //

    if (ObjectEnum->ObjectId) {
        return pEnumNextVirtualObject (ObjectEnum);
    }

    //
    // Otherwise we are enumerating physical objects
    //

    return EnumNextPhysicalObject (ObjectEnum);
}


VOID
IsmAbortObjectEnum (
    IN      PMIG_OBJECT_ENUM ObjectEnum
    )
{
    //
    // Verify enumeration has not completed
    //

    if (!ObjectEnum->Handle) {
        return;
    }

    //
    // If ObjectId is specified, we are enumerating the ISM, otherwise we are
    // enumerating physical objects
    //

    if (ObjectEnum->ObjectId) {
        pAbortVirtualObjectEnum (ObjectEnum);
    } else {
        AbortPhysicalObjectEnum (ObjectEnum);
    }

    return;
}


BOOL
IsmEnumFirstDestinationObjectEx (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      BOOL EnumerateVirtualObjects
    )
{
    //
    // First fix ObjectTypeId
    //
    ObjectTypeId &= (~PLATFORM_MASK);
    ObjectTypeId |= PLATFORM_SOURCE;

    //
    // If this is the source, it's illegal
    //
    if (g_IsmCurrentPlatform == PLATFORM_SOURCE) {
        return FALSE;
    }

    if (EnumerateVirtualObjects) {
        return pEnumFirstVirtualObject (ObjectEnum, ObjectTypeId, ObjectPattern);
    }

    return EnumFirstPhysicalObject (ObjectEnum, ObjectTypeId, ObjectPattern);
}


BOOL
IsObjectLocked (
    IN      MIG_OBJECTID ObjectId
    )
{
    UINT flags;

    if (!MemDbGetFlagsByHandle ((KEYHANDLE) ObjectId, &flags)) {
        return FALSE;
    }

    return flags & OBJECT_LOCKED;
}


BOOL
IsHandleLocked (
    IN      MIG_OBJECTID ObjectId,
    IN      KEYHANDLE Handle
    )
{
    TCHAR lockKey[256];

    wsprintf (lockKey, S_LOCK_KEY, ObjectId);

    return MemDbTestSingleLinkageValue (lockKey, 0, Handle);
}


BOOL
TestLock (
    IN      MIG_OBJECTID ObjectId,
    IN      KEYHANDLE Handle
    )
{
    return IsObjectLocked (ObjectId) || IsHandleLocked (ObjectId, Handle);
}


VOID
pLockHandle (
    IN      MIG_OBJECTID ObjectId,
    IN      KEYHANDLE Handle
    )
{
    TCHAR lockKey[256];

    wsprintf (lockKey, S_LOCK_KEY, ObjectId);

    if (!MemDbAddSingleLinkageValue (lockKey, 0, Handle, FALSE)) {
        EngineError ();
    }
}


BOOL
pLockGroup (
    IN      KEYHANDLE ItemId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    pLockHandle ((MIG_OBJECTID) Arg, (KEYHANDLE) ItemId);

    return TRUE;
}


VOID
LockHandle (
    IN      MIG_OBJECTID ObjectId,
    IN      KEYHANDLE Handle
    )
{
    RECURSERETURN rc;

    rc = RecurseForGroupItems (
                Handle,
                pLockGroup,
                (ULONG_PTR) ObjectId,
                TRUE,
                FALSE
                );

    if (rc == RECURSE_FAIL || rc == RECURSE_SUCCESS) {
        return;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    pLockHandle (ObjectId, Handle);
}


VOID
IsmLockObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    if (!MemDbSetFlagsByHandle (ObjectId, OBJECT_LOCKED, 0)) {
        EngineError ();
    }
}


VOID
IsmLockObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = GetObjectIdForModification (ObjectTypeId, EncodedObjectName);

    if (objectId) {
        IsmLockObjectId (objectId);
    }
}


PCTSTR
GetObjectNameForDebugMsg (
    IN      MIG_OBJECTID ObjectId
    )
{
    static TCHAR buffer[256];
    PCTSTR name;

    name = MemDbGetKeyFromHandle ((KEYHANDLE) ObjectId, 1);

    if (name) {
        StackStringCopy (buffer, name);
        MemDbReleaseMemory (name);
    } else {
        StringCopy (buffer, TEXT("<invalid object>"));
    }

    return name;
}


PCTSTR
pIsValidCName (
    IN      PCTSTR Name
    )
{
    UINT u;

    if (!Name) {
        return NULL;
    }

    if (!__iscsymf (_tcsnextc (Name))) {
        return NULL;
    }

    Name = _tcsinc (Name);
    u = 1;

    while (*Name) {
        if (!__iscsym (_tcsnextc (Name))) {
            return Name;
        }

        Name = _tcsinc (Name);
        u++;
    }

    if (u > 64) {
        return NULL;
    }

    return Name;
}


BOOL
IsValidCName (
    IN      PCTSTR Name
    )
{
    PCTSTR p;
    BOOL result = FALSE;

    p = pIsValidCName (Name);
    if (p && (!*p)) {
        result = TRUE;
    } else {
        SetLastError (ERROR_INVALID_NAME);
    }

    return TRUE;
}


BOOL
IsValidCNameWithDots (
    IN      PCTSTR Name
    )
{
    PCTSTR p;

    p = pIsValidCName (Name);

    while (p && _tcsnextc (p) == TEXT('.')) {
        p = _tcsinc (p);
        p = pIsValidCName (p);
    }

    return p && (*p == 0);
}


BOOL
MarkGroupIds (
    IN      PCTSTR MemDbKey
    )
{
    UINT flags;
    PTSTR keyCopy;
    PTSTR p;
    PTSTR start;
    BOOL b = FALSE;

    keyCopy = DuplicateText (MemDbKey);

    __try {

        p = (PTSTR) FindLastWack (keyCopy);
        if (!p) {
            __leave;
        }

        start = _tcschr (p + 1, TEXT('.'));

        //
        // Make sure all groups in the string are legal
        //

        p = start;

        while (p) {
            *p = 0;

            if (MemDbGetFlags (keyCopy, &flags)) {
                if (flags & ITEM_ID) {
                    DEBUGMSG ((DBG_ERROR, "Group already used as item. Key=%s", keyCopy));
                    __leave;
                }
            }

            *p = TEXT('.');
            p = _tcschr (p + 1, TEXT('.'));
        }

        if (MemDbGetFlags (keyCopy, &flags)) {
            if (flags & GROUP_ID) {
                DEBUGMSG ((DBG_ERROR, "Item already used as group. Key=%s", keyCopy));
                __leave;
            }
        }

        //
        // Mark all groups
        //

        p = start;

        while (p) {
            *p = 0;

            if (!MemDbSetFlags (keyCopy, GROUP_ID, 0)) {
                EngineError ();
                __leave;
            }

            *p = TEXT('.');
            p = _tcschr (p + 1, TEXT('.'));
        }

        //
        // Mark the item
        //

        b = MemDbSetFlags (keyCopy, ITEM_ID, 0);

        if (!b) {
            EngineError ();
        }
    }
    __finally {
        FreeText (keyCopy);
    }

    return b;
}


BOOL
IsGroupId (
    IN      KEYHANDLE Id
    )
{
    UINT flags;

    if (!MemDbGetFlagsByHandle (Id, &flags)) {
        return FALSE;
    }

    return flags & GROUP_ID;
}


BOOL
IsItemId (
    IN      KEYHANDLE Id
    )
{
    UINT flags;

    if (!MemDbGetFlagsByHandle (Id, &flags)) {
        return FALSE;
    }

    return flags & ITEM_ID;
}


KEYHANDLE
GetGroupOfId (
    IN      KEYHANDLE GroupOrItemId
    )
{
    PTSTR key;
    PTSTR p;
    PTSTR lastDot;
    KEYHANDLE result = 0;

    key = (PTSTR) MemDbGetKeyFromHandle (GroupOrItemId, 0);
    if (!key) {
        return 0;
    }

    __try {
        p = (PTSTR) FindLastWack (key);
        if (!p) {
            __leave;
        }

        lastDot = NULL;

        do {
            p = _tcschr (p + 1, TEXT('.'));
            if (p) {
                lastDot = p;
            }
        } while (p);

        if (!lastDot) {
            __leave;
        }

        *lastDot = 0;

        result = MemDbGetHandleFromKey (key);

        MYASSERT (!result || IsGroupId (result));
    }
    __finally {
        MemDbReleaseMemory (key);
    }

    return result;
}


BOOL
pGroupRegistrationWorker (
    IN OUT  PGROUPREGISTRATION_ENUM EnumPtr
    )
{
    EnumPtr->GroupOrItemId = EnumPtr->EnumStruct.KeyHandle;
    MYASSERT (EnumPtr->EnumStruct.Flags & (GROUP_ID|ITEM_ID));
    EnumPtr->ItemId = (EnumPtr->EnumStruct.Flags & ITEM_ID) != 0;

    return TRUE;
}


BOOL
EnumFirstGroupRegistration (
    OUT     PGROUPREGISTRATION_ENUM EnumPtr,
    IN      KEYHANDLE GroupId
    )
{
    BOOL b;
    PCTSTR key;
    PCTSTR pattern;

    if (!IsGroupId (GroupId)) {
        DEBUGMSG ((DBG_ERROR, "EnumFirstGroupRegistration: GroupId is invalid"));
        return FALSE;
    }

    key = MemDbGetKeyFromHandle (GroupId, 0);
    if (!key) {
        return 0;
    }

    pattern = JoinText (key, TEXT(".*"));

    MemDbReleaseMemory (key);
    INVALID_POINTER (key);

    b = MemDbEnumFirst (
            &EnumPtr->EnumStruct,
            pattern,
            ENUMFLAG_NORMAL,
            ENUMLEVEL_ALLLEVELS,
            ENUMLEVEL_ALLLEVELS
            );

    FreeText (pattern);
    INVALID_POINTER (pattern);

    if (!b) {
        return FALSE;
    }

    return pGroupRegistrationWorker (EnumPtr);
}


BOOL
EnumNextGroupRegistration (
    IN OUT  PGROUPREGISTRATION_ENUM EnumPtr
    )
{
    if (!MemDbEnumNext (&EnumPtr->EnumStruct)) {
        return FALSE;
    }

    return pGroupRegistrationWorker (EnumPtr);
}


VOID
AbortGroupRegistrationEnum (
    IN      PGROUPREGISTRATION_ENUM EnumPtr
    )
{
    MemDbAbortEnum (&EnumPtr->EnumStruct);
    ZeroMemory (EnumPtr, sizeof (GROUPREGISTRATION_ENUM));
}


RECURSERETURN
RecurseForGroupItems (
    IN      KEYHANDLE GroupId,
    IN      GROUPITEM_CALLBACK Callback,
    IN      ULONG_PTR Arg,
    IN      BOOL ExecuteOnly,
    IN      BOOL LogicalOrOnResults
    )
{
    PCTSTR groupKey = NULL;
    PCTSTR enumKey = NULL;
    MEMDB_ENUM e;
    UINT pass;
    RECURSERETURN result = RECURSE_FAIL;
    BOOL b;
    BOOL oneSuccess = FALSE;

    if (!IsGroupId (GroupId)) {
        return RECURSE_NOT_NEEDED;
    }

    groupKey = MemDbGetKeyFromHandle (GroupId, 0);
    enumKey = JoinText (groupKey, TEXT(".*"));
    MemDbReleaseMemory (groupKey);

    __try {

        for (pass = ExecuteOnly ? 1 : 0 ; pass < 2 ; pass++) {

            //
            // Enumerate all attributes (skip attribute subgroups)
            //

            if (MemDbEnumFirst (
                    &e,
                    enumKey,
                    ENUMFLAG_NORMAL,
                    ENUMLEVEL_ALLLEVELS,
                    ENUMLEVEL_ALLLEVELS
                    )) {

                do {

                    if (IsItemId (e.KeyHandle)) {
                        //
                        // Pass 0 is for query, pass 1 is for execute
                        //

                        b = Callback (e.KeyHandle, pass == 0, Arg);

                        if (LogicalOrOnResults) {
                            oneSuccess |= b;
                        } else if (!b) {
                            MemDbAbortEnum (&e);
                            __leave;
                        }
                    }

                } while (MemDbEnumNext (&e));
                MemDbAbortEnum (&e);
            }
        }

        if (LogicalOrOnResults) {
            if (!oneSuccess) {
                __leave;
            }
        }

        result = RECURSE_SUCCESS;
    }
    __finally {

        FreeText (enumKey);
        INVALID_POINTER (enumKey);

    }

    return result;
}


BOOL
DbEnumFillStruct (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR Pattern,
    OUT     PDBENUM_ARGS Args
    )
{
    PWSTR p, q;
    PWSTR plainPatternEnd = NULL;
    PWSTR patternCopy;
    PCWSTR node;
    PCWSTR leaf;
    BOOL freeNode = TRUE;

    Args->ObjectTypeId = ObjectTypeId;

    //
    // Split the pattern into a node and leaf pattern
    //

    patternCopy = (PWSTR) CreateUnicode (Pattern);
    ObsSplitObjectStringW (patternCopy, &node, &leaf);

    if (!node) {
        node = L"*";
        freeNode = FALSE;
    }

    DestroyUnicode (patternCopy);
    INVALID_POINTER (patternCopy);

    //
    // Find the first level in node that has a pattern.  Then
    // truncate the node and parse it as a "plain" pattern.
    // This makes sure a node pattern such as c:\foo\* will
    // match c:\foo itself.
    //

    patternCopy = DuplicateTextW (node);
    p = patternCopy;
    plainPatternEnd = patternCopy;

    while (p && *p) {

        MYASSERT (*plainPatternEnd);

        q = (PWSTR) ObsFindNonEncodedCharInEncodedStringW (p, L'\\');

        if (!q) {
            p = GetEndOfStringW (p);
        } else {
            p = q;
            *p = 0;
        }

        if (ObsFindNonEncodedCharInEncodedStringW (plainPatternEnd, L'*') ||
            ObsFindNonEncodedCharInEncodedStringW (plainPatternEnd, L'?')
            ) {
            *plainPatternEnd = 0;
            break;
        }

        plainPatternEnd = p;

        if (q) {
            *p = L'\\';
            p++;
        }
    }

    if (plainPatternEnd && *plainPatternEnd == 0 && *patternCopy) {

        Args->PlainNodeParsedPattern = CreateParsedPatternW (patternCopy);

    } else {

        Args->PlainNodeParsedPattern = NULL;

    }

    //
    // Fill the rest of the struct, clean up and exit
    //

    Args->NodeParsedPattern = CreateParsedPatternW (node);
    if (leaf) {
        Args->LeafParsedPattern = CreateParsedPatternW (leaf);
    } else {
        Args->LeafParsedPattern = NULL;
    }

    if (freeNode) {
        ObsFreeW (node);
        INVALID_POINTER (node);
    }

    ObsFreeW (leaf);
    INVALID_POINTER (leaf);

    FreeTextW (patternCopy);
    INVALID_POINTER (patternCopy);

    return TRUE;
}


VOID
DbEnumFreeStruct (
    IN      PDBENUM_ARGS Args
    )
{
    if (Args->PlainNodeParsedPattern) {
        DestroyParsedPatternW (Args->PlainNodeParsedPattern);
        INVALID_POINTER (Args->PlainNodeParsedPattern);
    }

    if (Args->NodeParsedPattern) {
        DestroyParsedPatternW (Args->NodeParsedPattern);
        INVALID_POINTER (Args->NodeParsedPattern);
    }

    if (Args->LeafParsedPattern) {
        DestroyParsedPatternW (Args->LeafParsedPattern);
        INVALID_POINTER (Args->LeafParsedPattern);
    }

    ZeroMemory (Args, sizeof (DBENUM_ARGS));
}


BOOL
DbEnumFind (
    IN      PCWSTR KeySegment
    )
{
    //
    // Does KeySegment have a pattern?
    //

    if (ObsFindNonEncodedCharInEncodedStringW (KeySegment, L'*') ||
        ObsFindNonEncodedCharInEncodedStringW (KeySegment, L'?')
        ) {
        return TRUE;
    }

    return FALSE;
}


BOOL
DbEnumMatch (
    IN      PCVOID InboundArgs,
    IN      PCWSTR CurrentKey
    )
{
    PDBENUM_ARGS args;
    PCWSTR node;
    PCWSTR leaf;
    PCWSTR newLeaf;
    BOOL result = FALSE;
    WCHAR dummy[] = L"";

    args = (PDBENUM_ARGS) InboundArgs;

    CurrentKey = wcschr (CurrentKey, L'\\');
    MYASSERT (CurrentKey);

    if (!CurrentKey) {
        return FALSE;
    }

    CurrentKey++;

    //
    // Split current key into node and leaf
    //

    ObsSplitObjectStringW (CurrentKey, &node, &leaf);

    MYASSERT (args->NodeParsedPattern);

    if (node) {

        //
        // Test node against parsed pattern
        //

        if (args->NodeParsedPattern) {
            result = TestParsedPatternW (args->NodeParsedPattern, node);
            if (!result && args->PlainNodeParsedPattern) {
                result = TestParsedPatternW (args->PlainNodeParsedPattern, node);
            }

            if (result) {
                if (leaf) {
                    result = FALSE;
                    if (args->LeafParsedPattern) {
                        result = TestParsedPatternW (args->LeafParsedPattern, leaf);
                        if (!result &&
                            ((args->ObjectTypeId & (~PLATFORM_MASK)) == MIG_FILE_TYPE) &&
                            (wcschr (leaf, L'.') == NULL)
                            ) {
                            newLeaf = JoinTextW (leaf, L".");
                            result = TestParsedPatternW (args->LeafParsedPattern, newLeaf);
                            FreeTextW (newLeaf);
                        }
                    }
                } else {
                    if (args->LeafParsedPattern &&
                        args->PlainNodeParsedPattern &&
                        TestParsedPatternW (args->PlainNodeParsedPattern, node)
                        ) {
                        result = FALSE;
                    }
                }
            }
        }
    } else {

        //
        // Test empty node against parsed pattern
        //

        if (args->NodeParsedPattern) {
            result = TestParsedPatternW (args->NodeParsedPattern, dummy);
            if (!result && args->PlainNodeParsedPattern) {
                result = TestParsedPatternW (args->PlainNodeParsedPattern, dummy);
            }

            if (result) {
                if (leaf) {
                    result = FALSE;
                    if (args->LeafParsedPattern) {
                        result = TestParsedPatternW (args->LeafParsedPattern, leaf);
                    }
                }
            }
        }
    }

    ObsFreeW (node);
    INVALID_POINTER (node);

    ObsFreeW (leaf);
    INVALID_POINTER (leaf);

    return result;
}


BOOL
DbEnumFirst (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    OUT     PMEMDB_ENUM EnumPtr,
    IN      PCTSTR PatternString,
    OUT     PDBENUM_ARGS ArgsStruct
    )
{
    MEMDB_PATTERNSTRUCTW callbacks;
    PCTSTR objectPattern;

    objectPattern = _tcschr (PatternString, TEXT('\\'));
    if (!objectPattern) {
        MYASSERT (FALSE);
        return FALSE;
    }

    objectPattern++;

#ifdef DEBUG
    {
        PCTSTR p;

        //
        // Verify pattern string base is not a pattern.  This is
        // required, because we assume the first level will not
        // use enumeration, but will use direct lookup.
        //

        p = _tcschr (PatternString, TEXT('*'));
        MYASSERT (!p || p >= objectPattern);

        p = _tcschr (PatternString, TEXT('?'));
        MYASSERT (!p || p >= objectPattern);
    }

#endif

    DbEnumFillStruct (ObjectTypeId, objectPattern, ArgsStruct);

    callbacks.PatternFind = DbEnumFind;
    callbacks.PatternMatch = DbEnumMatch;
    callbacks.Data = ArgsStruct;

    return MemDbEnumFirstEx (
                EnumPtr,
                PatternString,
                ENUMFLAG_NORMAL,
                1,
                ENUMLEVEL_ALLLEVELS,
                &callbacks
                );

}

BOOL
IsmRegisterRestoreCallback (
    IN      PMIG_RESTORECALLBACK RestoreCallback
    )
{
    PRESTORE_STRUCT restoreStruct;

    restoreStruct = (PRESTORE_STRUCT) PmGetMemory (g_IsmPool, sizeof (RESTORE_STRUCT));
    restoreStruct->RestoreCallback = RestoreCallback;
    restoreStruct->Next = g_RestoreCallbacks;
    g_RestoreCallbacks = restoreStruct;
    return TRUE;
}

BOOL
EnumFirstRestoreCallback (
    OUT     PMIG_RESTORECALLBACK_ENUM RestoreCallbackEnum
    )
{
    RestoreCallbackEnum->RestoreStruct = g_RestoreCallbacks;
    if (RestoreCallbackEnum->RestoreStruct) {
        RestoreCallbackEnum->RestoreCallback = RestoreCallbackEnum->RestoreStruct->RestoreCallback;
        return TRUE;
    }
    return FALSE;
}

BOOL
EnumNextRestoreCallback (
    IN OUT  PMIG_RESTORECALLBACK_ENUM RestoreCallbackEnum
    )
{
    if (!RestoreCallbackEnum->RestoreStruct) {
        return FALSE;
    }
    RestoreCallbackEnum->RestoreStruct = RestoreCallbackEnum->RestoreStruct->Next;
    if (RestoreCallbackEnum->RestoreStruct) {
        RestoreCallbackEnum->RestoreCallback = RestoreCallbackEnum->RestoreStruct->RestoreCallback;
        return TRUE;
    }
    return FALSE;
}

VOID
pFreeRestoreCallbacks (
    VOID
    )
{
    PRESTORE_STRUCT restoreStruct, oldStruct;

    restoreStruct = g_RestoreCallbacks;
    while (restoreStruct) {
        oldStruct = restoreStruct;
        restoreStruct = restoreStruct->Next;
        PmReleaseMemory (g_IsmPool, oldStruct);
    }
    g_RestoreCallbacks = NULL;
}


ULONG_PTR
IsmSendMessageToApp (
    UINT Message,
    ULONG_PTR Arg
    )
{
    if (g_MessageCallback) {
        return g_MessageCallback (Message, Arg);
    }

    return 0;
}


MIG_PROGRESSSLICEID
IsmRegisterProgressSlice (
    IN      UINT Ticks,
    IN      UINT TimeEstimateInSeconds
    )
{
    PPROGSLICE slice;
    MIG_PROGRESSSLICEID sliceId;

    if (!TimeEstimateInSeconds || !Ticks) {
        DEBUGMSG ((DBG_WARNING, "Ticks/TimeEstimateInSeconds must not be zero"));
        return 0;
    }

    sliceId = (MIG_PROGRESSSLICEID) (g_SliceBuffer.End / sizeof (PROGSLICE) + 1);
    slice = (PPROGSLICE) GbGrow (&g_SliceBuffer, sizeof (PROGSLICE));

    slice->SliceSize = Ticks;
    slice->CurrentPosition = 0;
    slice->SliceSizeInSeconds = TimeEstimateInSeconds;

    return sliceId;
}


VOID
pCallProgressBar (
    IN      MIG_PROGRESSSTATE State
    )
{
    ULONGLONG temp;
    UINT u;
    PPROGSLICE slice;
    UINT totalTicks = 0;
    UINT currentPos = 0;
    MIG_APPINFO appInfo;

    if (g_ProgressBarFn) {

        for (u = 0 ; u < g_SliceBuffer.End ; u += sizeof (PROGSLICE)) {

            slice = (PPROGSLICE) (g_SliceBuffer.Buf + u);

            temp = (ULONGLONG) slice->CurrentPosition * (ULONGLONG) slice->SliceSizeInSeconds;
            temp *= 10;
            temp /= (ULONGLONG) slice->SliceSize;
            currentPos += (UINT) temp;

            temp = (ULONGLONG) slice->SliceSizeInSeconds * 10;
            totalTicks += (UINT) temp;

        }

        if (State == MIG_END_PHASE) {
            currentPos = totalTicks;
        } else if (State == MIG_BEGIN_PHASE) {
            currentPos = 0;
        }

        g_ProgressBarFn (
            g_CurrentPhase,
            State,
            currentPos,
            totalTicks,
            g_ProgressBarArg
            );
    }
    if (State == MIG_BEGIN_PHASE) {
        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = g_CurrentPhase;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO_NOW, (ULONG_PTR)(&appInfo));
    }
    if (State == MIG_END_PHASE) {
        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));
    }
}


BOOL
IsmTickProgressBar (
    IN      MIG_PROGRESSSLICEID SliceId,
    IN      UINT TickDelta                  OPTIONAL
    )
{
    PPROGSLICE slice;

    if (!g_CurrentPhase || !g_ProgressBarFn) {
        SliceId = 0;
    }

    if (!TickDelta) {
        TickDelta = 1;
    }

    if (SliceId) {
        //
        // Update the slice ID
        //

        SliceId--;

        if (SliceId >= (MIG_PROGRESSSLICEID) (g_SliceBuffer.End / sizeof (PROGSLICE))) {
            DEBUGMSG ((DBG_ERROR, "Invalid slice ID passed to IsmTickProgressBar"));
            return FALSE;
        }

        slice = (PPROGSLICE) g_SliceBuffer.Buf + SliceId;

        if (slice->CurrentPosition < slice->SliceSize) {
            slice->CurrentPosition += TickDelta;
            if (slice->CurrentPosition > slice->SliceSize) {
                slice->CurrentPosition = slice->SliceSize;
            }

            //
            // Call the application's progress callback
            //

            pCallProgressBar (MIG_IN_PHASE);

        } else {
            DEBUGMSG ((DBG_WARNING, "IsmTickProgressBar: Slice already completed"));
        }
    }

    return !CheckCancel();
}


VOID
IsmSetCancel (
    VOID
    )
{
    if (g_CancelEvent) {
        SetEvent (g_CancelEvent);
    }
}

MIG_PLATFORMTYPEID
IsmGetRealPlatform (
    VOID
    )
{
    return g_IsmCurrentPlatform;
}

BOOL
IsmCurrentlyExecuting (
    VOID
    )
{
    return g_ExecutionInProgress;
}


BOOL
IsmCreateUser (
    IN      PCTSTR UserName,
    IN      PCTSTR Domain
    )
{
    if (g_TempProfile) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot call IsmCreateUser more than once"));
        return FALSE;
    }

    // record that we attempted to create the user
    pRecordUserData (
        UserName,
        Domain,
        NULL,
        NULL,
        TRUE
        );

    g_TempProfile = OpenTemporaryProfile (UserName, Domain);

    if (g_TempProfile) {
        // record that we created the user
        pRecordUserData (
            UserName,
            Domain,
            g_TempProfile->UserStringSid,
            g_TempProfile->UserProfileRoot,
            TRUE
            );
        // prepare the user journal
        pPrepareUserJournal (g_TempProfile);
        // let ETM module know this
        BroadcastUserCreation (g_TempProfile);
    }

    return g_TempProfile != NULL;
}

MIG_PARSEDPATTERN
IsmCreateParsedPattern (
    IN      MIG_OBJECTSTRINGHANDLE EncodedObject
    )
{
    return (MIG_PARSEDPATTERN)ObsCreateParsedPattern (EncodedObject);
}

VOID
IsmDestroyParsedPattern (
    IN      MIG_PARSEDPATTERN ParsedPattern
    )
{
    ObsDestroyParsedPattern ((POBSPARSEDPATTERN)ParsedPattern);
}

BOOL
IsmParsedPatternMatchEx (
    IN      MIG_PARSEDPATTERN ParsedPattern,
    IN      MIG_OBJECTTYPEID ObjectTypeId,      OPTIONAL
    IN      PCTSTR Node,                        OPTIONAL
    IN      PCTSTR Leaf                         OPTIONAL
    )
{
    BOOL result = TRUE;
    PTSTR newLeaf;
    PTSTR tempString;
    POBSPARSEDPATTERN obsParsedPattern = (POBSPARSEDPATTERN) ParsedPattern;

    MYASSERT (Node && obsParsedPattern->NodePattern);
    if (!(Node && obsParsedPattern->NodePattern)) {
       return FALSE;
    }

    if (((obsParsedPattern->Flags & OBSPF_NOLEAF) && Leaf) ||
        ((obsParsedPattern->Flags & OBSPF_EXACTLEAF) && !Leaf)
        ) {
        return FALSE;
    }

    if (!TestParsedPattern (obsParsedPattern->NodePattern, Node)) {
        //
        // let's try one more time with a wack at the end
        //
        tempString = JoinText (Node, TEXT("\\"));
        result = TestParsedPattern (obsParsedPattern->NodePattern, tempString);
        FreeText (tempString);
        if (!result) {
            return FALSE;
        }
    }

    if (Leaf) {
        if (!obsParsedPattern->LeafPattern) {
            return FALSE;
        }
        result = TestParsedPattern (obsParsedPattern->LeafPattern, Leaf);
        if (!result &&
            ((ObjectTypeId & (~PLATFORM_MASK)) == MIG_FILE_TYPE) &&
            (_tcschr (Leaf, TEXT('.')) == NULL)
            ) {
            newLeaf = JoinText (Leaf, TEXT("."));
            if (newLeaf) {
                result = TestParsedPattern (obsParsedPattern->LeafPattern, newLeaf);
                FreeText (newLeaf);
            } else {
                result = FALSE;
            }
        }
    } else {
        if (!obsParsedPattern->ExactRoot) {
            result = FALSE;
        }
    }
    return result;
}

BOOL
IsmParsedPatternMatch (
    IN      MIG_PARSEDPATTERN ParsedPattern,
    IN      MIG_OBJECTTYPEID ObjectTypeId,      OPTIONAL
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PTSTR decodedNode;
    PTSTR decodedLeaf;
    BOOL b;

    if (!IsmCreateObjectStringsFromHandle (ObjectName, &decodedNode, &decodedLeaf)) {
        return FALSE;
    }

    b = IsmParsedPatternMatchEx (ParsedPattern, ObjectTypeId, decodedNode, decodedLeaf);

    IsmDestroyObjectString (decodedNode);
    IsmDestroyObjectString (decodedLeaf);

    return b;
}

BOOL
IsmGetMappedUserData (
    OUT     PMIG_USERDATA UserData
    )
{
    if (UserData && g_TempProfile) {
        ZeroMemory (UserData, sizeof (MIG_USERDATA));
        UserData->UserName = g_TempProfile->UserName;
        UserData->DomainName = g_TempProfile->DomainName;
        UserData->AccountName = g_TempProfile->AccountName;
        UserData->UserProfileRoot = g_TempProfile->UserProfileRoot;
        UserData->UserSid = g_TempProfile->UserSid;
    }
    return (g_TempProfile != NULL);
}

BOOL
IsmAddControlFile (
    IN      PCTSTR ObjectName,
    IN      PCTSTR NativePath
    )
{
    MIG_OBJECTSTRINGHANDLE memDbObjectName;
    TCHAR tempFile[MAX_TCHAR_PATH];

    if (g_IsmCurrentPlatform == PLATFORM_CURRENT) {
        DEBUGMSG ((DBG_WHOOPS, "IsmSetPlatform must be called before IsmAddControlFile"));
        return FALSE;
    }

    // Do not start with a | special character
    if (*ObjectName == TEXT('|')) {
        return FALSE;
    }

    // INF file paths are limited to MAX_PATH in size
    if (SizeOfString (NativePath) > ARRAYSIZE(tempFile)) {
        return FALSE;
    }

    IsmGetTempFile (tempFile, ARRAYSIZE (tempFile));

    if (!CopyFile (NativePath, tempFile, FALSE)) {
        return FALSE;
    }

    // Add filename to hashtable for cleanup
    HtAddString (g_ControlFileTable, tempFile);

    memDbObjectName = IsmCreateObjectHandle (TEXT("External"), ObjectName);
    DataTypeAddObject (memDbObjectName, tempFile, TRUE);
    IsmDestroyObjectHandle (memDbObjectName);

    return TRUE;
}

BOOL
IsmGetControlFile (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR ObjectName,
    IN      PTSTR Buffer      // Required to be MAX_PATH_PLUS_NUL in size
    )
{
    MIG_CONTENT content;
    TCHAR tempFile[MAX_TCHAR_PATH];
    BOOL result = FALSE;

    if (IsmAcquireObject (ObjectTypeId, ObjectName, &content)) {
        MYASSERT (content.ContentInFile);

        if ((content.ContentInFile) &&
            (SizeOfString (content.FileContent.ContentPath) < ARRAYSIZE(tempFile))) {
            IsmGetTempFile (tempFile, ARRAYSIZE (tempFile));

            if (CopyFile (content.FileContent.ContentPath, tempFile, FALSE)) {
                // Return a copy of the filename
                StringCopy (Buffer, tempFile);

                // Add filename to hashtable for cleanup
                HtAddString (g_ControlFileTable, tempFile);

                result = TRUE;
            }
        }
    }
    return result;
}

BOOL
IsmSetRollbackJournalType (
    IN      BOOL Common
    )
{
    TCHAR winDir [MAX_PATH];
    PCURRENT_USER_DATA currentUserData;
    BOOL result = FALSE;

    if (g_JournalUsed) {
        return FALSE;
    }
    if (g_JournalDirectory) {
        FreePathString (g_JournalDirectory);
    }
    if (Common) {
        if (GetWindowsDirectory (winDir, ARRAYSIZE (winDir))) {
            g_JournalDirectory = JoinPaths (winDir, TEXT("usmt2.tmp"));
            result = TRUE;
        }
    } else {
        currentUserData = GetCurrentUserData ();
        if (currentUserData) {
            g_JournalDirectory = JoinPaths (currentUserData->UserProfilePath, TEXT("usmt2.tmp"));
            FreeCurrentUserData (currentUserData);
        }
    }
    return TRUE;
}

BOOL
IsmCanWriteRollbackJournal (
    VOID
    )
{
    BOOL result = TRUE;
    DWORD err;

    if (DoesFileExist (g_JournalDirectory)) {
        FiRemoveAllFilesInTree (g_JournalDirectory);
    }

    if (!BfCreateDirectory (g_JournalDirectory)) {
        err = GetLastError ();
        if ((err == ERROR_ALREADY_EXISTS) ||
            (err == ERROR_ACCESS_DENIED)
            ) {
            result = FALSE;
        }
    }

    if (result) {
        FiRemoveAllFilesInTree (g_JournalDirectory);
    }

    return result;
}

VOID
pRecordUserData (
    IN      PCTSTR UserName,
    IN      PCTSTR UserDomain,
    IN      PCTSTR UserStringSid,
    IN      PCTSTR UserProfilePath,
    IN      BOOL ProfileCreated
    )
{
    LONGLONG lastPos;
    TCHAR userName [MAX_TCHAR_PATH];
    TCHAR userDomain [MAX_TCHAR_PATH];
    TCHAR userStringSid [MAX_TCHAR_PATH];
    TCHAR userProfilePath [MAX_TCHAR_PATH];
    DWORD dontCare;

    if (g_RollbackMode) {
        return;
    }

    if (!g_JournalDirectory) {
        DEBUGMSG ((DBG_WHOOPS, "Journal directory does not exist."));
        return;
    }

    if (!g_JournalHandle) {
        DEBUGMSG ((DBG_WHOOPS, "Journal file is not opened."));
        return;
    }

    // If the file position is just after the journal header we'll just write
    // the info, otherwise we are going to save the current position,
    // write our data and restore the file position.

    if (!BfGetFilePointer (g_JournalHandle, &lastPos)) {
        DEBUGMSG ((DBG_WHOOPS, "Something wrong with the Journal file."));
        return;
    }

    if (lastPos != JOURNAL_HEADER_SIZE) {
        if (!BfSetFilePointer (g_JournalHandle, JOURNAL_HEADER_SIZE)) {
            DEBUGMSG ((DBG_WHOOPS, "Something wrong with the Journal file."));
            return;
        }
    }

    // now write the info
    ZeroMemory (userName, MAX_TCHAR_PATH);
    ZeroMemory (userDomain, MAX_TCHAR_PATH);
    ZeroMemory (userStringSid, MAX_TCHAR_PATH);
    ZeroMemory (userProfilePath, MAX_TCHAR_PATH);
    if (UserName) {
        StringCopyTcharCount (userName, UserName, MAX_TCHAR_PATH);
    }
    if (UserDomain) {
        StringCopyTcharCount (userDomain, UserDomain, MAX_TCHAR_PATH);
    }
    if (UserStringSid) {
        StringCopyTcharCount (userStringSid, UserStringSid, MAX_TCHAR_PATH);
    }
    if (UserProfilePath) {
        StringCopyTcharCount (userProfilePath, UserProfilePath, MAX_TCHAR_PATH);
    }
    WriteFile (
        g_JournalHandle,
        userName,
        MAX_TCHAR_PATH,
        &dontCare,
        NULL
        );
    WriteFile (
        g_JournalHandle,
        userDomain,
        MAX_TCHAR_PATH,
        &dontCare,
        NULL
        );
    WriteFile (
        g_JournalHandle,
        userStringSid,
        MAX_TCHAR_PATH,
        &dontCare,
        NULL
        );
    WriteFile (
        g_JournalHandle,
        userProfilePath,
        MAX_TCHAR_PATH,
        &dontCare,
        NULL
        );
    WriteFile (
        g_JournalHandle,
        &ProfileCreated,
        sizeof (BOOL),
        &dontCare,
        NULL
        );
    if (lastPos != JOURNAL_HEADER_SIZE) {
        BfSetFilePointer (g_JournalHandle, lastPos);
    }
}

VOID
IsmRecordOperation (
    IN      DWORD OperationType,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
#ifdef PRERELEASE
    // crash hooks
#define MAX_OBJECTTYPES 20
    static DWORD totalObjects = 0;
    static DWORD typeObjects[MAX_OBJECTTYPES] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    MIG_OBJECTTYPEID objTypeId;
    PCTSTR nativeName = NULL;
    BOOL doCrash = FALSE;
#endif
    static GROWBUFFER buffer = INIT_GROWBUFFER;
    static DWORD backupIdx = 0;

    TCHAR destFile [13];
    PCTSTR destFullPath;
    DWORD entrySize = 0;
    WIN32_FIND_DATA findData;
    MIG_CONTENT objectContent;
    DWORD dontCare;

    if (g_RollbackMode) {
        return;
    }

    if (!g_JournalDirectory) {
        DEBUGMSG ((DBG_WHOOPS, "Journal directory does not exist."));
        return;
    }

    if (!g_JournalHandle) {
        DEBUGMSG ((DBG_WHOOPS, "Journal file is not opened."));
        return;
    }

    ObjectTypeId &= (~PLATFORM_MASK);

    buffer.End = 0;

    switch (OperationType) {
    case JRNOP_CREATE:

#ifdef PRERELEASE
        // crash hooks
        totalObjects ++;
        if (g_CrashCountObjects == totalObjects) {
            doCrash = TRUE;
        }
        objTypeId = ObjectTypeId & (~PLATFORM_MASK);
        if (objTypeId && (objTypeId <= MAX_OBJECTTYPES)) {
            typeObjects [objTypeId - 1]++;
            if ((g_CrashCountTypeId == objTypeId) &&
                (g_CrashCountType == typeObjects [objTypeId - 1])
                ) {
                doCrash = TRUE;
            }
        }
        if (g_CrashNameTypeId == objTypeId) {
            nativeName = IsmGetNativeObjectName (objTypeId, ObjectName);
            if (StringIMatch (nativeName, g_CrashNameObject)) {
                doCrash = TRUE;
            }
            IsmReleaseMemory (nativeName);
        }
#endif

        GbAppendDword (&buffer, OperationType);
        CopyMemory (GbGrow (&buffer, sizeof (MIG_OBJECTTYPEID)), &ObjectTypeId, sizeof (MIG_OBJECTTYPEID));
        GbAppendDword (&buffer, SizeOfString (ObjectName));
        GbCopyString (&buffer, ObjectName);
        entrySize = buffer.End;
        break;
    case JRNOP_DELETE:
        if (!IsmAcquireObject (
                ObjectTypeId | PLATFORM_DESTINATION,
                ObjectName,
                &objectContent
                )) {
            return;
        }
        GbAppendDword (&buffer, OperationType);
        CopyMemory (GbGrow (&buffer, sizeof (MIG_OBJECTTYPEID)), &ObjectTypeId, sizeof (MIG_OBJECTTYPEID));
        GbAppendDword (&buffer, SizeOfString (ObjectName));
        GbCopyString (&buffer, ObjectName);
        GbAppendDword (&buffer, sizeof (MIG_CONTENT));
        CopyMemory (GbGrow (&buffer, sizeof (MIG_CONTENT)), &objectContent, sizeof (MIG_CONTENT));
        if (objectContent.Details.DetailsSize && objectContent.Details.DetailsData) {
            GbAppendDword (&buffer, objectContent.Details.DetailsSize);
            CopyMemory (
                GbGrow (&buffer, objectContent.Details.DetailsSize),
                objectContent.Details.DetailsData,
                objectContent.Details.DetailsSize
                );
        } else {
            GbAppendDword (&buffer, 0);
        }
        if (objectContent.ContentInFile) {
            if (DoesFileExistEx (objectContent.FileContent.ContentPath, &findData) &&
                ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                ) {
                // extra data is the relative path to the backup copy of this file
                backupIdx ++;
                wsprintf (destFile, TEXT("%08d.BAK"), backupIdx);
                destFullPath = JoinPaths (g_JournalDirectory, destFile);
                BfCopyAndFlushFile (objectContent.FileContent.ContentPath, destFullPath, FALSE);
                FreePathString (destFullPath);
                GbAppendDword (&buffer, SizeOfString (destFile));
                GbCopyString (&buffer, destFile);
            } else {
                GbAppendDword (&buffer, 0);
            }
        } else {
            // extra data is the actual content
            GbAppendDword (&buffer, objectContent.MemoryContent.ContentSize);
            if (objectContent.MemoryContent.ContentSize) {
                CopyMemory (
                    GbGrow (&buffer, objectContent.MemoryContent.ContentSize),
                    objectContent.MemoryContent.ContentBytes,
                    objectContent.MemoryContent.ContentSize
                    );
            }
        }
        entrySize = buffer.End;
        IsmReleaseObject (&objectContent);
        break;
    default:
        DEBUGMSG ((DBG_WHOOPS, "Wrong operation type in pRecordOperation: %d", OperationType));
        return;
    }
    WriteFile (
        g_JournalHandle,
        &entrySize,
        sizeof (DWORD),
        &dontCare,
        NULL
        );
    WriteFile (
        g_JournalHandle,
        buffer.Buf,
        buffer.End,
        &dontCare,
        NULL
        );
    WriteFile (
        g_JournalHandle,
        &entrySize,
        sizeof (DWORD),
        &dontCare,
        NULL
        );
    FlushFileBuffers (g_JournalHandle);

#ifdef PRERELEASE
    if (doCrash) {
        DebugBreak ();
    }
#endif

    g_JournalUsed = TRUE;
}

BOOL
IsmSetDelayedOperationsCommand (
    IN      PCTSTR DelayedOperationsCommand
    )
{
    if (g_DelayedOperationsCommand) {
        FreePathString (g_DelayedOperationsCommand);
    }
    g_DelayedOperationsCommand = DuplicatePathString (DelayedOperationsCommand, 0);

    return TRUE;
}

VOID
IsmRecordDelayedOperation (
    IN      DWORD OperationType,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    static GROWBUFFER buffer = INIT_GROWBUFFER;
    static DWORD backupIdx = 0;

    TCHAR destFile [13];
    PCTSTR destFullPath;
    DWORD entrySize = 0;
    WIN32_FIND_DATA findData;
    DWORD dontCare;

    if (!g_TempProfile ||
        !g_TempProfile->DelayedOpJrn ||
        !g_TempProfile->DelayedOpJrnHandle ||
        (g_TempProfile->DelayedOpJrnHandle == INVALID_HANDLE_VALUE)
        ) {
        DEBUGMSG ((DBG_WHOOPS, "Delayed operations Journal does not exist."));
        return;
    }

    ObjectTypeId &= (~PLATFORM_MASK);

    buffer.End = 0;

    switch (OperationType) {
    case JRNOP_DELETE:

        GbAppendDword (&buffer, OperationType);
        CopyMemory (GbGrow (&buffer, sizeof (MIG_OBJECTTYPEID)), &ObjectTypeId, sizeof (MIG_OBJECTTYPEID));
        GbAppendDword (&buffer, SizeOfString (ObjectName));
        GbCopyString (&buffer, ObjectName);
        entrySize = buffer.End;
        break;
    case JRNOP_CREATE:
    case JRNOP_REPLACE:
        GbAppendDword (&buffer, OperationType);
        CopyMemory (GbGrow (&buffer, sizeof (MIG_OBJECTTYPEID)), &ObjectTypeId, sizeof (MIG_OBJECTTYPEID));
        GbAppendDword (&buffer, SizeOfString (ObjectName));
        GbCopyString (&buffer, ObjectName);
        GbAppendDword (&buffer, sizeof (MIG_CONTENT));
        CopyMemory (GbGrow (&buffer, sizeof (MIG_CONTENT)), ObjectContent, sizeof (MIG_CONTENT));
        if (ObjectContent->Details.DetailsSize && ObjectContent->Details.DetailsData) {
            GbAppendDword (&buffer, ObjectContent->Details.DetailsSize);
            CopyMemory (
                GbGrow (&buffer, ObjectContent->Details.DetailsSize),
                ObjectContent->Details.DetailsData,
                ObjectContent->Details.DetailsSize
                );
        } else {
            GbAppendDword (&buffer, 0);
        }
        if (ObjectContent->ContentInFile) {
            if (DoesFileExistEx (ObjectContent->FileContent.ContentPath, &findData) &&
                ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                ) {
                // extra data is the relative path to the backup copy of this file
                backupIdx ++;
                wsprintf (destFile, TEXT("%08d.BAK"), backupIdx);
                destFullPath = JoinPaths (g_TempProfile->DelayedOpJrn, destFile);
                BfCopyAndFlushFile (ObjectContent->FileContent.ContentPath, destFullPath, FALSE);
                FreePathString (destFullPath);
                GbAppendDword (&buffer, SizeOfString (destFile));
                GbCopyString (&buffer, destFile);
            } else {
                GbAppendDword (&buffer, 0);
            }
        } else {
            // extra data is the actual content
            GbAppendDword (&buffer, ObjectContent->MemoryContent.ContentSize);
            if (ObjectContent->MemoryContent.ContentSize) {
                CopyMemory (
                    GbGrow (&buffer, ObjectContent->MemoryContent.ContentSize),
                    ObjectContent->MemoryContent.ContentBytes,
                    ObjectContent->MemoryContent.ContentSize
                    );
            }
        }
        entrySize = buffer.End;
        break;
    default:
        DEBUGMSG ((DBG_WHOOPS, "Wrong operation type in IsmRecordDelayedOperation: %d", OperationType));
        return;
    }
    WriteFile (
        g_TempProfile->DelayedOpJrnHandle,
        &entrySize,
        sizeof (DWORD),
        &dontCare,
        NULL
        );
    WriteFile (
        g_TempProfile->DelayedOpJrnHandle,
        buffer.Buf,
        buffer.End,
        &dontCare,
        NULL
        );
    WriteFile (
        g_TempProfile->DelayedOpJrnHandle,
        &entrySize,
        sizeof (DWORD),
        &dontCare,
        NULL
        );
    FlushFileBuffers (g_TempProfile->DelayedOpJrnHandle);
}

PMIG_OBJECTCOUNT
IsmGetObjectsStatistics (
    IN      MIG_OBJECTTYPEID ObjectTypeId   OPTIONAL
    )
{
    if ((ObjectTypeId & (~PLATFORM_MASK)) == 0) {
        if (ObjectTypeId & PLATFORM_SOURCE) {
            return &g_SourceObjects;
        } else if (ObjectTypeId & PLATFORM_DESTINATION) {
            return &g_DestinationObjects;
        } else {
            return &g_TotalObjects;
        }
    } else {
        return GetTypeObjectsStatistics (ObjectTypeId);
    }
}


VOID
EngineError (
    VOID
    )
{
    LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_ENGINE_FAILURE));
    IsmSetCancel();
}

BOOL
IsmGetOsVersionInfo (
    IN      MIG_PLATFORMTYPEID Platform,
    OUT     PMIG_OSVERSIONINFO VersionInfo
    )
{
    TCHAR tempStr [sizeof (UINT) * 2 + 3];

    if (!VersionInfo) {
        return FALSE;
    }

    ZeroMemory (VersionInfo, sizeof (MIG_OSVERSIONINFO));

    if (Platform == PLATFORM_CURRENT) {
        Platform = g_IsmCurrentPlatform;
    }

    if (!IsmGetEnvironmentString (
            Platform,
            NULL,
            S_VER_OSTYPE,
            tempStr,
            sizeof(tempStr),
            NULL
            )) {
        return FALSE;
    }
    _stscanf (tempStr, TEXT("%lx"), &(VersionInfo->OsType));

    if (!IsmGetEnvironmentString (
            Platform,
            NULL,
            S_VER_OSMAJOR,
            tempStr,
            sizeof(tempStr),
            NULL
            )) {
        return FALSE;
    }
    _stscanf (tempStr, TEXT("%lx"), &(VersionInfo->OsMajorVersion));

    if (!IsmGetEnvironmentString (
            Platform,
            NULL,
            S_VER_OSMINOR,
            tempStr,
            sizeof(tempStr),
            NULL
            )) {
        return FALSE;
    }
    _stscanf (tempStr, TEXT("%lx"), &(VersionInfo->OsMinorVersion));

    if (!IsmGetEnvironmentString (
            Platform,
            NULL,
            S_VER_OSBUILD,
            tempStr,
            sizeof(tempStr),
            NULL
            )) {
        return FALSE;
    }
    _stscanf (tempStr, TEXT("%lx"), &(VersionInfo->OsBuildNumber));

    if (VersionInfo->OsType == OSTYPE_WINDOWS9X) {
        VersionInfo->OsTypeName = OSTYPE_WINDOWS9X_STR;
        if (VersionInfo->OsMajorVersion == OSMAJOR_WIN95) {
            VersionInfo->OsMajorVersionName = OSMAJOR_WIN95_STR;
            if (VersionInfo->OsMinorVersion == OSMINOR_GOLD) {
                VersionInfo->OsMinorVersion = OSMINOR_GOLD;
            }
        }
        if (VersionInfo->OsMajorVersion == OSMAJOR_WIN95OSR2) {
            VersionInfo->OsMajorVersionName = OSMAJOR_WIN95OSR2_STR;
            if (VersionInfo->OsMinorVersion == OSMINOR_GOLD) {
                VersionInfo->OsMinorVersion = OSMINOR_GOLD;
            }
        }
        if (VersionInfo->OsMajorVersion == OSMAJOR_WIN98) {
            VersionInfo->OsMajorVersionName = OSMAJOR_WIN98_STR;
            if (VersionInfo->OsMinorVersion == OSMINOR_GOLD) {
                VersionInfo->OsMinorVersion = OSMINOR_GOLD;
            }
            if (VersionInfo->OsMinorVersion == OSMINOR_WIN98SE) {
                VersionInfo->OsMinorVersionName = OSMINOR_WIN98SE_STR;
            }
        }
        if (VersionInfo->OsMajorVersion == OSMAJOR_WINME) {
            VersionInfo->OsMajorVersionName = OSMAJOR_WINME_STR;
            if (VersionInfo->OsMinorVersion == OSMINOR_GOLD) {
                VersionInfo->OsMinorVersion = OSMINOR_GOLD;
            }
        }
    }
    if (VersionInfo->OsType == OSTYPE_WINDOWSNT) {
        VersionInfo->OsTypeName = OSTYPE_WINDOWSNT_STR;
        if (VersionInfo->OsMajorVersion == OSMAJOR_WINNT4) {
            VersionInfo->OsMajorVersionName = OSMAJOR_WINNT4_STR;
            if (VersionInfo->OsMinorVersion == OSMINOR_GOLD) {
                VersionInfo->OsMinorVersionName = OSMINOR_GOLD_STR;
            }
        }
        if (VersionInfo->OsMajorVersion == OSMAJOR_WINNT5) {
            VersionInfo->OsMajorVersionName = OSMAJOR_WINNT5_STR;
            if (VersionInfo->OsMinorVersion == OSMINOR_GOLD) {
                VersionInfo->OsMinorVersionName = OSMINOR_GOLD_STR;
            }
            if (VersionInfo->OsMinorVersion == OSMINOR_WINNT51) {
                VersionInfo->OsMinorVersionName = OSMINOR_WINNT51_STR;
            }
        }
    }

    return TRUE;
}

BOOL
pGetFunctionData (
    IN      PCTSTR FunctionMultiSz,
    OUT     PCTSTR *FunctionId,
    OUT     PCTSTR *MultiSzCopy
    )
{
    GROWBUFFER buf = INIT_GROWBUFFER;
    MULTISZ_ENUM e;
    BOOL result = TRUE;

    if (!FunctionMultiSz) {
        return FALSE;
    }
    if (!FunctionId) {
        return FALSE;
    }
    if (!MultiSzCopy) {
        return FALSE;
    }
    *FunctionId = NULL;
    *MultiSzCopy = NULL;
    buf.End = 0;
    if (result && EnumFirstMultiSz (&e, FunctionMultiSz)) {
        do {
            GbMultiSzAppend (&buf, e.CurrentString);
        } while (EnumNextMultiSz (&e));
    }
    if (buf.End) {
        *MultiSzCopy = IsmGetMemory (buf.End);
        CopyMemory ((PTSTR)(*MultiSzCopy), buf.Buf, buf.End);
    } else {
        result = FALSE;
    }
    buf.End = 0;
    if (result && EnumFirstMultiSz (&e, FunctionMultiSz)) {
        do {
            GbAppendString (&buf, e.CurrentString);
            GbAppendString (&buf, TEXT(";"));
        } while (EnumNextMultiSz (&e));
    }
    if (buf.End) {
        *FunctionId = IsmGetMemory (buf.End);
        CopyMemory ((PTSTR)(*FunctionId), buf.Buf, buf.End);
    } else {
        result = FALSE;
    }
    if (!result) {
        if (*MultiSzCopy) {
            IsmReleaseMemory (*MultiSzCopy);
            *MultiSzCopy = NULL;
        }
        if (*FunctionId) {
            IsmReleaseMemory (*FunctionId);
            *FunctionId = NULL;
        }
    }
    return result;
}

BOOL
IsmExecuteFunction (
    IN      UINT ExecutionPhase,
    IN      PCTSTR FunctionMultiSz
    )
{
    PCTSTR functionId;
    PCTSTR functionMultiSz;
    BOOL result = FALSE;

    switch (ExecutionPhase) {
    case MIG_EXECUTE_PREPROCESS:
        if (g_PreProcessTable) {
            if (pGetFunctionData (FunctionMultiSz, &functionId, &functionMultiSz)) {
                HtAddStringEx (g_PreProcessTable, functionId, &functionMultiSz, FALSE);
                IsmReleaseMemory (functionId);
            }
        }
        result = TRUE;
        break;
    case MIG_EXECUTE_REFRESH:
        if (g_RefreshTable) {
            if (pGetFunctionData (FunctionMultiSz, &functionId, &functionMultiSz)) {
                HtAddStringEx (g_RefreshTable, functionId, &functionMultiSz, FALSE);
                IsmReleaseMemory (functionId);
            }
        }
        result = TRUE;
        break;
    case MIG_EXECUTE_POSTPROCESS:
        if (g_PostProcessTable) {
            if (pGetFunctionData (FunctionMultiSz, &functionId, &functionMultiSz)) {
                HtAddStringEx (g_PostProcessTable, functionId, &functionMultiSz, FALSE);
                IsmReleaseMemory (functionId);
            }
        }
        result = TRUE;
        break;
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\ismp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ismp.h

Abstract:

    Declares types, constants, macros, etc., internal to the ISM source modules.

Author:

    Jim Schmidt (jimschm) 02-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "logmsg.h"


//
// Strings
//

#define S_COMMON                        TEXT("Common")
#define S_PROHIBITED_COMBINATIONS       TEXT("Prohibited Operation Combinations")
#define S_IGNORED_COLLISIONS            TEXT("Ignored Operation Collisions")
#define S_SHORTLONG_TREE                TEXT("ShortLong")
#define S_OBJECTCOUNT                   TEXT("ObjectCount")

#define S_TOTAL_OBJECTS                 TEXT("TotalObjects")
#define S_LEFT_SIDE_OBJECTS             TEXT("LeftSideObjects")
#define S_PERSISTENT_OBJECTS            TEXT("PersistentObjects")
#define S_APPLY_OBJECTS                 TEXT("ApplyObjects")

#define S_TRANSPORT_PREFIX              TEXT("TransportVariable")

//
// Constants
//

#ifdef DEBUG

#define TRACK_ENTER()       TrackPushEx (NULL, File, Line, TRUE)
#define TRACK_LEAVE()       TrackPop ()

#else

#define TRACK_ENTER()
#define TRACK_LEAVE()

#endif

#define MAX_OBJECT_LEVEL 0xFFFFFFFF
#define ATTRIBUTE_INDEX 0
#define PROPERTY_INDEX  1
#define OPERATION_INDEX 2

//
// Used by short file names preservation
//
#define FILENAME_UNDECIDED     0x00000000
#define FILENAME_LONG          0x00000001
#define FILENAME_SHORT         0x00000002

//
// Used by rollback
//
#define JRN_SIGNATURE               0x4A4D5355   //USMJ
#define JRN_VERSION                 0x00000001
#define JOURNAL_HEADER_SIZE         (2 * sizeof (DWORD))
#define JOURNAL_USER_DATA_SIZE      (4 * MAX_TCHAR_PATH + sizeof (BOOL))
#define JOURNAL_FULL_HEADER_SIZE    (JOURNAL_HEADER_SIZE + JOURNAL_USER_DATA_SIZE)

// Used by per-user delayed operations journal
#define JRN_USR_SIGNATURE           0x4A4D534A   //USMU
#define JRN_USR_VERSION             0x00000001
#define JRN_USR_DIRTY               0x00000001
#define JRN_USR_COMPLETE            0x00000002
#define JRN_USR_HEADER_SIZE         (3 * sizeof (DWORD))

// High Priority/Low Priority operations
#define OP_HIGH_PRIORITY            0x00000001
#define OP_LOW_PRIORITY             0x00000002
#define OP_ALL_PRIORITY             OP_HIGH_PRIORITY|OP_LOW_PRIORITY

//
// Macros
//

#define ISRIGHTSIDEOBJECT(ObjectTypeId)     ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_DESTINATION)
#define ISLEFTSIDEOBJECT(ObjectTypeId)      ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE)

//
// Types
//

typedef struct {
    BOOL Initialized;
    PCTSTR EtmPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PETMINITIALIZE EtmInitialize;
    PETMPARSE EtmParse;
    PETMTERMINATE EtmTerminate;
    PETMNEWUSERCREATED EtmNewUserCreated;
    BOOL ShouldBeCalled;
} ETMDATA, *PETMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR VcmPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PVCMINITIALIZE VcmInitialize;
    PVCMPARSE VcmParse;
    PVCMQUEUEENUMERATION VcmQueueEnumeration;
    PVCMQUEUEHIGHPRIORITYENUMERATION VcmQueueHighPriorityEnumeration;
    PVCMTERMINATE VcmTerminate;
    BOOL ShouldBeCalled;
} VCMDATA, *PVCMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR SgmPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PSGMINITIALIZE SgmInitialize;
    PSGMPARSE SgmParse;
    PSGMQUEUEENUMERATION SgmQueueEnumeration;
    PSGMQUEUEHIGHPRIORITYENUMERATION SgmQueueHighPriorityEnumeration;
    PSGMTERMINATE SgmTerminate;
    BOOL ShouldBeCalled;
} SGMDATA, *PSGMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR SamPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PSAMINITIALIZE SamInitialize;
    PSAMEXECUTE SamExecute;
    PSAMESTIMATEPROGRESSBAR SamEstimateProgressBar;
    PSAMTERMINATE SamTerminate;
    BOOL ShouldBeCalled;
} SAMDATA, *PSAMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR DgmPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PDGMINITIALIZE DgmInitialize;
    PDGMQUEUEENUMERATION DgmQueueEnumeration;
    PDGMQUEUEHIGHPRIORITYENUMERATION DgmQueueHighPriorityEnumeration;
    PDGMTERMINATE DgmTerminate;
    BOOL ShouldBeCalled;
} DGMDATA, *PDGMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR DamPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PDAMINITIALIZE DamInitialize;
    PDAMEXECUTE DamExecute;
    PDAMESTIMATEPROGRESSBAR DamEstimateProgressBar;
    PDAMTERMINATE DamTerminate;
    BOOL ShouldBeCalled;
} DAMDATA, *PDAMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR CsmPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PCSMINITIALIZE CsmInitialize;
    PCSMEXECUTE CsmExecute;
    PCSMESTIMATEPROGRESSBAR CsmEstimateProgressBar;
    PCSMTERMINATE CsmTerminate;
    BOOL ShouldBeCalled;
} CSMDATA, *PCSMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR OpmPath;
    PCTSTR Group;
    HANDLE LibHandle;
    POPMINITIALIZE OpmInitialize;
    POPMTERMINATE OpmTerminate;
    BOOL ShouldBeCalled;
} OPMDATA, *POPMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR TransportPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PTRANSPORTINITIALIZE TransportInitialize;
    PTRANSPORTTERMINATE TransportTerminate;
    PTRANSPORTQUERYCAPABILITIES TransportQueryCapabilities;
    PTRANSPORTSETSTORAGE TransportSetStorage;
    PTRANSPORTRESETSTORAGE TransportResetStorage;
    PTRANSPORTSAVESTATE TransportSaveState;
    PTRANSPORTRESUMESAVESTATE TransportResumeSaveState;
    PTRANSPORTBEGINAPPLY TransportBeginApply;
    PTRANSPORTRESUMEAPPLY TransportResumeApply;
    PTRANSPORTACQUIREOBJECT TransportAcquireObject;
    PTRANSPORTRELEASEOBJECT TransportReleaseObject;
    PTRANSPORTENDAPPLY TransportEndApply;
    PTRANSPORTESTIMATEPROGRESSBAR TransportEstimateProgressBar;
    BOOL ShouldBeCalled;
} TRANSPORTDATA, *PTRANSPORTDATA;

typedef struct {
    MIG_PLATFORMTYPEID Platform;
    ENVENTRY_TYPE EnvEntryType;
    PCTSTR EnvEntryGroup;
    PCTSTR EnvEntryName;
    UINT EnvEntryDataSize;
    PBYTE EnvEntryData;
    MEMDB_ENUM Handle;
} ENV_ENTRY_ENUM, *PENV_ENTRY_ENUM;

typedef struct {
    HANDLE FileHandle;
    HANDLE MapHandle;
    TCHAR TempFile [MAX_PATH];
    BOOL Moved;
    BOOL OkToMove;
    ULONG_PTR TransportArg;
} ACQUIREHANDLE, *PACQUIREHANDLE;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    PPARSEDPATTERNW PlainNodeParsedPattern;
    PPARSEDPATTERNW NodeParsedPattern;
    PPARSEDPATTERNW LeafParsedPattern;
} DBENUM_ARGS, *PDBENUM_ARGS;

typedef struct {
    PCTSTR UserName;
    PCTSTR DomainName;
    PCTSTR AccountName;
    PCTSTR UserProfileRoot;
    PCTSTR MapKey;
    PCTSTR UserHive;
    PCTSTR UserStringSid;
    PSID UserSid;
    PCTSTR DelayedOpJrn;
    HANDLE DelayedOpJrnHandle;

    // internal members
    PMHANDLE AllocPool;
} TEMPORARYPROFILE, *PTEMPORARYPROFILE;

typedef struct {
    PCTSTR UserName;
    PCTSTR UserDomain;
    PCTSTR UserStringSid;
    PCTSTR UserProfilePath;

    // internal members
    PMHANDLE AllocPool;
} CURRENT_USER_DATA, *PCURRENT_USER_DATA;

//
// group registration enumeration
//

typedef struct {
    KEYHANDLE GroupOrItemId;
    BOOL ItemId;

    // private members
    MEMDB_ENUM EnumStruct;
} GROUPREGISTRATION_ENUM, *PGROUPREGISTRATION_ENUM;

typedef BOOL (GROUPITEM_CALLBACK_PROTOTYPE)(KEYHANDLE ItemId, BOOL FirstPass, ULONG_PTR Arg);
typedef GROUPITEM_CALLBACK_PROTOTYPE * GROUPITEM_CALLBACK;

typedef enum {
    RECURSE_NOT_NEEDED,
    RECURSE_SUCCESS,
    RECURSE_FAIL
} RECURSERETURN;

//
// Restore callbacks
//

typedef struct _TAG_RESTORE_STRUCT {
    PMIG_RESTORECALLBACK RestoreCallback;
    //
    // Linkage.
    //
    struct _TAG_RESTORE_STRUCT * Next;
} RESTORE_STRUCT, *PRESTORE_STRUCT;

typedef struct {
    PRESTORE_STRUCT RestoreStruct;
    PMIG_RESTORECALLBACK RestoreCallback;
} MIG_RESTORECALLBACK_ENUM, *PMIG_RESTORECALLBACK_ENUM;

//
// Globals
//

extern MIG_OBJECTCOUNT g_TotalObjects;
extern MIG_OBJECTCOUNT g_SourceObjects;
extern MIG_OBJECTCOUNT g_DestinationObjects;
extern PCTSTR g_CurrentGroup;
extern HINF g_IsmInf;
extern PMHANDLE g_IsmPool;
extern PMHANDLE g_IsmUntrackedPool;
extern UINT g_IsmCurrentPlatform;
extern UINT g_IsmModulePlatformContext;
extern MIG_ATTRIBUTEID g_PersistentAttributeId;
extern PTRANSPORTDATA g_SelectedTransport;
extern HANDLE g_ActivityEvent;
extern PCTSTR g_JournalDirectory;
extern HANDLE g_JournalHandle;
extern BOOL g_RollbackMode;
extern BOOL g_JournalUsed;
extern HASHTABLE g_ModuleTable;
extern HASHTABLE g_EtmTable;
extern HASHTABLE g_VcmTable;
extern HASHTABLE g_SgmTable;
extern HASHTABLE g_SamTable;
extern HASHTABLE g_DgmTable;
extern HASHTABLE g_DamTable;
extern HASHTABLE g_CsmTable;
extern HASHTABLE g_OpmTable;
extern PMIG_LOGCALLBACK g_LogCallback;
extern HASHTABLE g_TransportTable;
extern BOOL g_ExecutionInProgress;
extern GROWLIST g_AcquireHookList;
extern GROWLIST g_EnumHookList;
extern PPROGRESSBARFN g_ProgressBarFn;
extern MIG_PROGRESSPHASE g_CurrentPhase;

#ifdef PRERELEASE
// crash hooks
extern DWORD g_CrashCountObjects;
extern MIG_OBJECTTYPEID g_CrashNameTypeId;
extern PCTSTR g_CrashNameObject;
#endif

//
// Macro expansion list
//

// None

//
// Macro expansion definition
//

// None

//
// Private function prototypes
//

BOOL
CheckCancel (
    VOID
    );

MIG_OBJECTTYPEID
FixObjectTypeId (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

MIG_OBJECTTYPEID
FixEnumerationObjectTypeId (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
InitializeTypeMgr (
    VOID
    );

VOID
TerminateTypeMgr (
    VOID
    );

BOOL
InitializeEnv (
    VOID
    );

VOID
TerminateEnv (
    VOID
    );

BOOL
EnumFirstObjectOfType (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      MIG_OBJECTTYPEID TypeId,
    IN      PCTSTR Pattern,
    IN      UINT MaxLevel
    );

BOOL
EnumNextObjectOfType (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    );

VOID
AbortObjectOfTypeEnum (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    );

VOID
AbortCurrentNodeEnum (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    );

MIG_OBJECTTYPEID
GetObjectTypeId (
    IN      PCTSTR TypeName
    );

PCTSTR
GetObjectTypeName (
    IN      MIG_OBJECTTYPEID TypeId
    );

PCTSTR
GetDecoratedObjectPathFromName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR ObjectName,
    IN      BOOL CanContainPattern
    );

BOOL
InitializeFlowControl (
    VOID
    );

VOID
TerminateFlowControl (
    VOID
    );

BOOL
DoAllObjectEnumerations (
    MIG_PROGRESSSLICEID SliceId
    );

UINT
EstimateAllObjectEnumerations (
    MIG_PROGRESSSLICEID SliceId,
    BOOL PreEstimate
    );

VOID
AddTypeToGlobalEnumerationEnvironment (
    IN      MIG_OBJECTTYPEID TypeId
    );

BOOL
PrepareEnumerationEnvironment (
    IN      BOOL GlobalEnvironment
    );

BOOL
ClearEnumerationEnvironment (
    IN      BOOL GlobalEnvironment
    );

LONGLONG
AppendProperty (
    PCMIG_BLOB Property
    );

BOOL
GetProperty (
    IN      LONGLONG Offset,
    IN OUT  PGROWBUFFER Buffer,                 OPTIONAL
    OUT     PBYTE PreAllocatedBuffer,           OPTIONAL
    OUT     PUINT Size,                         OPTIONAL
    OUT     PMIG_BLOBTYPE PropertyDataType      OPTIONAL
    );

BOOL
CreatePropertyStruct (
    OUT     PGROWBUFFER Buffer,
    OUT     PMIG_BLOB PropertyStruct,
    IN      LONGLONG Offset
    );

BOOL
IsObjectLocked (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
IsHandleLocked (
    IN      MIG_OBJECTID ObjectId,
    IN      KEYHANDLE Handle
    );

BOOL
TestLock (
    IN      MIG_OBJECTID ObjectId,
    IN      KEYHANDLE Handle
    );

VOID
LockHandle (
    IN      MIG_OBJECTID ObjectId,
    IN      KEYHANDLE Handle
    );

PCTSTR
GetObjectNameForDebugMsg (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
InitializeOperations (
    VOID
    );

VOID
TerminateOperations (
    VOID
    );

BOOL
IsValidCName (
    IN      PCTSTR Name
    );

BOOL
IsValidCNameWithDots (
    IN      PCTSTR Name
    );

BOOL
MarkGroupIds (
    IN      PCTSTR MemDbKey
    );

BOOL
IsGroupId (
    IN      KEYHANDLE Id
    );

BOOL
IsItemId (
    IN      KEYHANDLE Id
    );

VOID
EngineError (
    VOID
    );

BOOL
ApplyOperationsOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      BOOL TreeFiltersOnly,
    IN      BOOL NoRestoreObject,
    IN      DWORD OperationPriority,
    IN      PMIG_CONTENT ApplyInput,            OPTIONAL
    OUT     PMIG_FILTEROUTPUT FilterOutput,
    OUT     PMIG_CONTENT ApplyOutput            OPTIONAL
    );

VOID
FreeApplyOutput (
    IN      PCMIG_CONTENT OriginalContent,
    IN      PMIG_CONTENT FinalContent
    );

VOID
FreeFilterOutput (
    IN      MIG_OBJECTSTRINGHANDLE OriginalString,
    IN      PMIG_FILTEROUTPUT FilterOutput
    );

KEYHANDLE
GetGroupOfId (
    IN      KEYHANDLE Handle
    );

BOOL
EnumFirstGroupRegistration (
    OUT     PGROUPREGISTRATION_ENUM EnumPtr,
    IN      KEYHANDLE GroupId
    );

BOOL
EnumNextGroupRegistration (
    IN OUT  PGROUPREGISTRATION_ENUM EnumPtr
    );

VOID
AbortGroupRegistrationEnum (
    IN      PGROUPREGISTRATION_ENUM EnumPtr
    );

BOOL
ValidateModuleName (
    IN      PCTSTR ModuleName
    );

RECURSERETURN
RecurseForGroupItems (
    IN      KEYHANDLE GroupId,
    IN      GROUPITEM_CALLBACK Callback,
    IN      ULONG_PTR Arg,
    IN      BOOL ExecuteOnly,
    IN      BOOL LogicalOrOnResults
    );

BOOL
InitializeProperties (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      BOOL VcmMode
    );

VOID
TerminateProperties (
    IN      MIG_PLATFORMTYPEID Platform
    );

LONGLONG
OffsetFromPropertyDataId (
    IN      MIG_PROPERTYDATAID PropertyDataId
    );

BOOL
DbEnumFillStruct (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR Pattern,
    OUT     PDBENUM_ARGS Args
    );

VOID
DbEnumFreeStruct (
    IN      PDBENUM_ARGS Args
    );

BOOL
DbEnumFind (
    IN      PCWSTR KeySegment
    );

BOOL
DbEnumMatch (
    IN      PCVOID InboundArgs,
    IN      PCWSTR KeySegment
    );

BOOL
DbEnumFirst (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    OUT     PMEMDB_ENUM EnumPtr,
    IN      PCTSTR PatternString,
    OUT     PDBENUM_ARGS ArgsStruct
    );

VOID
EnvInvalidateCallbacks (
    VOID
    );

BOOL
EnvSaveEnvironment (
    IN OUT  PGROWLIST GrowList
    );

BOOL
EnvRestoreEnvironment (
    IN      PGROWLIST GrowList
    );

PTSTR
GetFirstSeg (
    IN      PCTSTR SrcFileName
    );

MIG_OBJECTID
GetObjectIdForModification (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    );

BOOL
RestoreObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName,
    OUT     MIG_COMPARERESULT *Compare,             OPTIONAL
    IN      DWORD OperationPriority,
    OUT     PBOOL DeleteFailed
    );

BOOL
RegisterInternalAttributes (
    VOID
    );

BOOL
EnumFirstRestoreCallback (
    OUT     PMIG_RESTORECALLBACK_ENUM RestoreCallbackEnum
    );

BOOL
EnumNextRestoreCallback (
    OUT     PMIG_RESTORECALLBACK_ENUM RestoreCallbackEnum
    );

BOOL
ShouldObjectBeRestored (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    );

VOID
InitRegistryType (
    VOID
    );

VOID
DoneRegistryType (
    VOID
    );

VOID
InitFileType (
    VOID
    );

VOID
DoneFileType (
    VOID
    );

VOID
InitDataType (
    VOID
    );

VOID
DoneDataType (
    VOID
    );

BOOL
DataTypeAddObject (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR ObjectLocation,
    IN      BOOL MakePersistent
    );

BOOL
CanObjectTypeBeRestored (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
CanObjectTypeBeModified (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

VOID
TypeMgrRescanTypes (
    VOID
    );

HASHTABLE
GetTypeExclusionTable (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
EnumFirstPhysicalObject (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern
    );

BOOL
EnumNextPhysicalObject (
    IN OUT  PMIG_OBJECT_ENUM ObjectEnum
    );

VOID
AbortPhysicalObjectEnum (
    IN      PMIG_OBJECT_ENUM ObjectEnum
    );

BOOL
IncrementTotalObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
IncrementPersistentObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
DecrementPersistentObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
IncrementApplyObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
DecrementApplyObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

PMIG_OBJECTCOUNT
GetTypeObjectsStatistics (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
SavePerObjectStatistics (
    VOID
    );

BOOL
LoadPerObjectStatistics (
    VOID
    );

BOOL
EnvEnumerateFirstEntry (
    OUT     PENV_ENTRY_ENUM EnvEntryEnum,
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Pattern
    );

BOOL
EnvEnumerateNextEntry (
    IN OUT  PENV_ENTRY_ENUM EnvEntryEnum
    );

VOID
AbortEnvEnumerateEntry (
    IN OUT  PENV_ENTRY_ENUM EnvEntryEnum
    );

PTEMPORARYPROFILE
OpenTemporaryProfile (
    IN      PCTSTR UserName,
    IN      PCTSTR Domain
    );

BOOL
SelectTemporaryProfile (
    IN      PTEMPORARYPROFILE Profile
    );

BOOL
CloseTemporaryProfile (
    IN      PTEMPORARYPROFILE Profile,
    IN      BOOL MakeProfilePermanent
    );

BOOL
MapUserProfile (
    IN      PCTSTR UserStringSid,
    IN      PCTSTR UserProfilePath
    );

BOOL
UnmapUserProfile (
    IN      PCTSTR UserStringSid
    );

BOOL
DeleteUserProfile (
    IN      PCTSTR UserStringSid,
    IN      PCTSTR UserProfilePath
    );

PCURRENT_USER_DATA
GetCurrentUserData (
    VOID
    );

VOID
FreeCurrentUserData (
    IN      PCURRENT_USER_DATA CurrentUserData
    );

BOOL
ExecuteDelayedOperations (
    IN      BOOL CleanupOnly
    );

//
// modules.c
//

BOOL
InitializeVcmModules (
    IN      PVOID Reserved
    );

BOOL
InitializeModules (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PVOID Reserved
    );

BOOL
BroadcastUserCreation (
    IN      PTEMPORARYPROFILE UserProfile
    );


VOID
TerminateModules (
    VOID
    );

VOID
TerminateProcessWideModules (
    VOID
    );


BOOL
ExecutePhysicalAcquireCallbacks (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT Content,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit,
    OUT     PMIG_CONTENT *NewContent
    );

BOOL
FreeViaAcquirePhysicalCallback (
    IN      PMIG_CONTENT Content
    );


BOOL
ExecutePhysicalEnumCheckCallbacks (
    IN      PMIG_TYPEOBJECTENUM ObjectEnum
    );

BOOL
ExecutePhysicalEnumAddCallbacks (
    IN OUT  PMIG_TYPEOBJECTENUM ObjectEnum,
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      MIG_PARSEDPATTERN ParsedPattern,
    IN OUT  PUINT CurrentCallback
    );

VOID
AbortPhysicalEnumCallback (
    IN      PMIG_TYPEOBJECTENUM ObjectEnum,         ZEROED
    IN      UINT CurrentCallback
    );

#ifdef PRERELEASE
VOID
LoadCrashHooks (
    VOID
    );
#endif

//
// ANSI/UNICODE Macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\flowctrl.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    flowctrl.c

Abstract:

    Implements the control functionality for the ISM. This includes the enumeration manager, transport marshalling
    and apply module ordering.

Author:

    Marc R. Whitten (marcw) 15-Nov-1999

Revision History:

    marcw 1-Dec-1999 Added function level callback prioritization and non-enumerated callbacks.

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_FLOW     "FlowCtrl"

//
// Strings
//

#define S_INI_SGMFUNCTIONHIGHPRIORITY   TEXT("Source.Gather Function High Priority")
#define S_INI_SGMFUNCTIONLOWPRIORITY    TEXT("Source.Gather Function Low Priority")

#define S_INI_DGMFUNCTIONHIGHPRIORITY   TEXT("Destination.Gather Function High Priority")
#define S_INI_DGMFUNCTIONLOWPRIORITY    TEXT("Destination.Gather Function Low Priority")

//
// Constants
//

#define MINIMUM_FUNCTION_PRIORITY   0xFFFFFFFF
#define MIDDLE_FUNCTION_PRIORITY    0x80000000
#define MAXIMUM_FUNCTION_PRIORITY   0x00000000

#define CALLBEFOREOBJECTENUMERATIONS    0
#define CALLAFTEROBJECTENUMERATIONS     1

//
// Macros
//

#define CALLBACK_ENUMFLAGS_TOP(b) ((PCALLBACK_ENUMFLAGS) ((b)->End > 0 ? ((b)->Buf + (b)->End - sizeof (CALLBACK_ENUMFLAGS)) : NULL))

//
// Types
//

typedef struct {
    UINT Level;
    BOOL Enabled;
    UINT EnableLevel;
    DWORD Flags;
} CALLBACK_ENUMFLAGS, *PCALLBACK_ENUMFLAGS;

typedef enum {
    CALLBACK_NORMAL     = 0x00000001,
    CALLBACK_HOOK,
    CALLBACK_EXCLUSION,
    CALLBACK_PHYSICAL_ENUM,
    CALLBACK_PHYSICAL_ACQUIRE
} CALLBACK_TYPE;

typedef struct _TAG_CALLBACKDATA {

    //
    // Callback Data
    //
    FARPROC Function;
    FARPROC Function2;
    UINT MaxLevel;
    UINT MinLevel;
    PPARSEDPATTERN NodeParsedPattern;
    PPARSEDPATTERN ExplodedNodeParsedPattern;
    PPARSEDPATTERN LeafParsedPattern;
    PPARSEDPATTERN ExplodedLeafParsedPattern;
    PCTSTR Pattern;
    ULONG_PTR CallbackArg;
    CALLBACK_TYPE CallbackType;

    //
    // Enumeration Control Members
    //
    GROWBUFFER EnumFlags;
    BOOL Done;
    BOOL Error;

    //
    // Prioritization and Identification Members
    //
    PCTSTR Group;
    PCTSTR Identifier;
    UINT Priority;

    //
    // Linkage.
    //
    struct _TAG_CALLBACKDATA * Next;
    struct _TAG_CALLBACKDATA * Prev;

} CALLBACKDATA, *PCALLBACKDATA;

typedef struct _TAG_ENUMDATA {

    PCTSTR Pattern;
    PPARSEDPATTERN NodeParsedPattern;
    PPARSEDPATTERN ExplodedNodeParsedPattern;
    PPARSEDPATTERN LeafParsedPattern;
    PPARSEDPATTERN ExplodedLeafParsedPattern;
    //
    // Linkage.
    //
    struct _TAG_ENUMDATA * Next;
    struct _TAG_ENUMDATA * Prev;

} ENUMDATA, *PENUMDATA;

typedef struct {

    MIG_OBJECTTYPEID ObjectTypeId;
    PCTSTR TypeName;
    PCALLBACKDATA PreEnumerationFunctionList;
    PCALLBACKDATA PostEnumerationFunctionList;
    PCALLBACKDATA FunctionList;
    PCALLBACKDATA ExclusionList;
    PCALLBACKDATA PhysicalEnumList;
    PCALLBACKDATA PhysicalAcquireList;
    PENUMDATA FirstEnum;
    PENUMDATA LastEnum;

} TYPEENUMINFO, *PTYPEENUMINFO;

typedef BOOL (NONENUMERATEDCALLBACK)(VOID);
typedef NONENUMERATEDCALLBACK *PNONENUMERATEDCALLBACK;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    PMIG_PHYSICALENUMADD AddCallback;
    ULONG_PTR AddCallbackArg;
    PCTSTR Node;
    PCTSTR Leaf;
} ENUMADDCALLBACK, *PENUMADDCALLBACK;



//
// Globals
//

PGROWLIST g_TypeData = NULL;
PGROWLIST g_GlobalTypeData = NULL;
PCALLBACKDATA g_PreEnumerationFunctionList = NULL;
PCALLBACKDATA g_PostEnumerationFunctionList = NULL;

PMHANDLE g_GlobalQueuePool;
PMHANDLE g_UntrackedFlowPool;
PMHANDLE g_CurrentQueuePool;
GROWBUFFER g_EnumerationList = INIT_GROWBUFFER;

GROWLIST g_AcquireList = INIT_GROWLIST;
GROWLIST g_EnumList = INIT_GROWLIST;
GROWLIST g_EnumAddList = INIT_GROWLIST;

#ifdef DEBUG

PCTSTR g_QueueFnName;

#define SETQUEUEFN(x)       g_QueueFnName = x

#else

#define SETQUEUEFN(x)

#endif

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

VOID
pAddStaticExclusion (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedFullName
    );

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
pInsertCallbackIntoSortedList (
    IN      PMHANDLE Pool,
    IN OUT  PCALLBACKDATA * Head,
    IN      PCALLBACKDATA Data
    )

/*++

Routine Description:

  pInsertCallback into sorted list.

Arguments:

  Pool - Specifies the pool to allocate from
  Head - Specifies this head of the callback data list.
  Data - Specifies the data to add to the list.

Return Value:

  TRUE if the callbackdata was successfully added to the list, FALSE
  otherwise.

--*/
{

    PCALLBACKDATA cur = *Head;
    PCALLBACKDATA last = NULL;
    PCALLBACKDATA dataCopy = NULL;

    dataCopy = (PCALLBACKDATA) PmGetMemory (Pool, sizeof (CALLBACKDATA));
    CopyMemory (dataCopy, Data, sizeof (CALLBACKDATA));


    if (!cur || dataCopy->Priority < cur->Priority) {
        //
        // Add to the head of the list if necessary.
        //
        dataCopy->Next = cur;
        if (cur) {
            cur->Prev = dataCopy;
        }

        *Head = dataCopy;
    }
    else {

        //
        // Add inside the list.
        // Always goes through the while loop once (see the if above)
        //
        while (dataCopy->Priority >= cur->Priority) {
            last = cur;
            if (!cur->Next) {
                break;
            }
            cur = cur->Next;
        }
        //
        // Add immediately after cur
        //
        dataCopy->Next = last->Next;
        last->Next = dataCopy;
        dataCopy->Prev = last;
    }

    return TRUE;
}


BOOL
pRegisterCallback (
    IN      PMHANDLE Pool,
    IN OUT  PCALLBACKDATA * FunctionList,
    IN      FARPROC Callback,
    IN      FARPROC Callback2,
    IN      ULONG_PTR CallbackArg,
    IN      MIG_OBJECTSTRINGHANDLE Pattern,             OPTIONAL
    IN      PCTSTR FunctionId,                          OPTIONAL
    IN      CALLBACK_TYPE CallbackType
    )

/*++

Routine Description:

  pRegisterCallback does the actual work of adding a callback to the
  necessary flow control data structures.

Arguments:

  Pool - Specifies the pool to allocate from

  FunctionList - Specifies the list of callback functions that will be
                 updated with the new function.

  Callback - Specifies the callback function to register

  Callback2 - Specifies the second callback function to register

  CallbackArg - Specifies a caller-defined value to be passed back on each
                enumeration

  Pattern - Optionally specifies the pattern that to be associated with
            the callback function

  FunctionId - Specifies the Function Identifer for the callback. This is used
               for function level prioritization.

Return Value:

  TRUE if the callback was successfully registered. FALSE otherwise.

--*/

{
    CALLBACKDATA data;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PTSTR nodePattern = NULL;
    PTSTR leafPattern = NULL;
    PCTSTR lowPriorityStr;
    PCTSTR highPriorityStr;
    BOOL result = TRUE;

    MYASSERT (g_CurrentGroup);

    //
    // Initialize callback data.
    //

    ZeroMemory (&data, sizeof (CALLBACKDATA));

    __try {

        data.Function = Callback;
        data.Function2 = Callback2;
        data.CallbackArg = CallbackArg;
        data.Group = PmDuplicateString (Pool, g_CurrentGroup);
        data.CallbackType = CallbackType;

        if (FunctionId) {
            data.Identifier = PmDuplicateString (Pool, FunctionId);
        }

        //
        // Store pattern information (pattern, max level, min level)
        //
        if (Pattern) {

            data.Pattern  = PmDuplicateString (Pool, Pattern);

            ObsSplitObjectStringEx (Pattern, &nodePattern, &leafPattern, NULL, FALSE);

            if (!nodePattern && !leafPattern) {
                DEBUGMSG ((DBG_ERROR, "Pattern specified has null node and leaf"));
                result = FALSE;
                __leave;
            }

            if (nodePattern) {

                GetNodePatternMinMaxLevels (nodePattern, NULL, &data.MinLevel, &data.MaxLevel);

                data.NodeParsedPattern = CreateParsedPatternEx (Pool, nodePattern);
                if (data.NodeParsedPattern) {
                    data.ExplodedNodeParsedPattern = ExplodeParsedPatternEx (Pool, data.NodeParsedPattern);
                }
                ObsFree (nodePattern);
                nodePattern = NULL;
            } else {
                if (data.CallbackType == CALLBACK_NORMAL) {
                    DEBUGMSG ((DBG_ERROR, "%s: Pattern must specify a node %s", g_QueueFnName, data.Pattern));
                    result = FALSE;
                    __leave;
                } else {
                    GetNodePatternMinMaxLevels (TEXT("*"), NULL, &data.MinLevel, &data.MaxLevel);
                    data.NodeParsedPattern = CreateParsedPatternEx (Pool, TEXT("*"));
                    data.ExplodedNodeParsedPattern = ExplodeParsedPatternEx (Pool, data.NodeParsedPattern);

                    DestroyParsedPattern (data.NodeParsedPattern);
                    data.NodeParsedPattern = NULL;
                }
            }
            if (leafPattern) {
                data.LeafParsedPattern = CreateParsedPatternEx (Pool, leafPattern);
                if (data.LeafParsedPattern) {
                    data.ExplodedLeafParsedPattern = ExplodeParsedPatternEx (Pool, data.LeafParsedPattern);
                }
                ObsFree (leafPattern);
                leafPattern = NULL;
            }
        }

        //
        // Get the priority for this function.
        //
        data.Priority = MIDDLE_FUNCTION_PRIORITY;

        if (FunctionId) {
            if (g_IsmModulePlatformContext == PLATFORM_SOURCE) {
                lowPriorityStr = S_INI_SGMFUNCTIONLOWPRIORITY;
                highPriorityStr = S_INI_SGMFUNCTIONHIGHPRIORITY;
            } else {
                lowPriorityStr = S_INI_DGMFUNCTIONLOWPRIORITY;
                highPriorityStr = S_INI_DGMFUNCTIONHIGHPRIORITY;
            }
            if (InfFindFirstLine (g_IsmInf, highPriorityStr, FunctionId, &is)) {

                data.Priority = MAXIMUM_FUNCTION_PRIORITY + is.Context.Line;
            }
            else if (InfFindFirstLine (g_IsmInf, lowPriorityStr, FunctionId, &is)) {

                data.Priority = MINIMUM_FUNCTION_PRIORITY - is.Context.Line;
            }
            InfCleanUpInfStruct (&is);
        }

        //
        // Add the function to the list.
        //
        pInsertCallbackIntoSortedList (Pool, FunctionList, &data);
    }
    __finally {

        InfCleanUpInfStruct (&is);

        if (nodePattern) {
            ObsFree (nodePattern);
            nodePattern = NULL;
        }
        if (leafPattern) {
            ObsFree (leafPattern);
            leafPattern = NULL;
        }
        if (!result) {
            if (data.NodeParsedPattern) {
                DestroyParsedPattern (data.NodeParsedPattern);
            }
            if (data.ExplodedNodeParsedPattern) {
                DestroyParsedPattern (data.ExplodedNodeParsedPattern);
            }
            if (data.LeafParsedPattern) {
                DestroyParsedPattern (data.LeafParsedPattern);
            }
            if (data.ExplodedLeafParsedPattern) {
                DestroyParsedPattern (data.ExplodedLeafParsedPattern);
            }
            ZeroMemory (&data, sizeof (CALLBACKDATA));
        }
    }

    return result;
}


BOOL
pTestContainer (
    IN      PPARSEDPATTERN NodeContainer,
    IN      PPARSEDPATTERN NodeContained,
    IN      PPARSEDPATTERN LeafContainer,
    IN      PPARSEDPATTERN LeafContained
    )
{
    MYASSERT (NodeContainer);
    MYASSERT (NodeContained);

    if ((!NodeContainer) ||
        (!NodeContained)
        ) {
        return FALSE;
    }
    if (!IsExplodedParsedPatternContainedEx (NodeContainer, NodeContained, FALSE)) {
        //they don't match
        return FALSE;
    }
    if (!LeafContained) {
        if (LeafContainer) {
            // If there is a leaf pattern for container the caller will get nodes
            // only if the node pattern has wild chars. So, since we know that the
            // contained node pattern is included in the container node pattern
            // we just need to see if the container node pattern includes wild chars.
            return WildCharsPattern (NodeContainer);
        } else {
            //both are NULL so...
            return TRUE;
        }
    } else {
        if (!LeafContainer) {
            // Even if the contained has a leaf pattern, it will get nodes only if
            // the node pattern has wild chars. So, since we know that the contained
            // node pattern is included in the container node pattern we just need
            // to see if the contained node pattern includes wild chars
            return WildCharsPattern (NodeContained);
        } else {
            //return the actual match of non-null parsed patterns
            return IsExplodedParsedPatternContainedEx (LeafContainer, LeafContained, TRUE);
        }
    }
}

BOOL
pTestContainerEx (
    IN      PPARSEDPATTERN NodeContainer,
    IN      PPARSEDPATTERN NodeContained,
    IN      PPARSEDPATTERN LeafContainer,
    IN      PPARSEDPATTERN LeafContained
    )
{
    MYASSERT (NodeContainer);
    MYASSERT (NodeContained);

    if ((!NodeContainer) ||
        (!NodeContained)
        ) {
        return FALSE;
    }

    if (!DoExplodedParsedPatternsIntersect (NodeContainer, NodeContained)) {
        if (!DoExplodedParsedPatternsIntersectEx (NodeContainer, NodeContained, TRUE)) {
            return FALSE;
        }
    }

    if (!LeafContained) {
        if (LeafContainer) {
            // If there is a leaf pattern for container the caller will get nodes
            // only if the node pattern has wild chars. So, since we know that the
            // contained node pattern is included in the container node pattern
            // we just need to see if the container node pattern includes wild chars.
            return WildCharsPattern (NodeContainer);
        } else {
            //both are NULL so...
            return TRUE;
        }
    } else {
        if (!LeafContainer) {
            // Even if the contained has a leaf pattern, it will get nodes only if
            // the node pattern has wild chars. So, since we know that the contained
            // node pattern is included in the container node pattern we just need
            // to see if the contained node pattern includes wild chars
            return WildCharsPattern (NodeContained);
        } else {
            //return the actual match of non-null parsed patterns
            return DoExplodedParsedPatternsIntersect (LeafContainer, LeafContained);
        }
    }
}

BOOL
pAddEnumeration (
    IN      PMHANDLE Pool,
    IN OUT  PTYPEENUMINFO TypeEnumInfo,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern
    )

/*++

Routine Description:

  pAddEnumeration Adds an enumeration string to the list of enumerations
  needed for a given type. Because the flow control module tries to use only
  a minimal set of enumerations, the actual enumeration may not be added.
  After a successful call to this function, any data needed by the specified
  enumeration will be enumerated.

Arguments:

  Pool          - Specifies the pool to allocate from
  TypeEnumInfo  - Specifies the type info structure that will receive the new
                  enumeration data.
  ObjectPattern - Specifies the enumeration pattern to add to the type.

Return Value:

  TRUE if the pattern was successfully added, FALSE otherwise.

--*/

{
    PENUMDATA enumData;
    PENUMDATA oldEnumData;
    PCTSTR nodePattern = NULL;
    PCTSTR leafPattern = NULL;
    PPARSEDPATTERN nodeParsedPattern = NULL;
    PPARSEDPATTERN explodedNodeParsedPattern = NULL;
    PPARSEDPATTERN leafParsedPattern = NULL;
    PPARSEDPATTERN explodedLeafParsedPattern = NULL;

    //
    // Add this to the enumeration list unless its already listed.
    //
    if (!ObsSplitObjectStringEx (ObjectPattern, &nodePattern, &leafPattern, NULL, FALSE)) {
        DEBUGMSG ((DBG_ERROR, "Bad pattern detected in pAddEnumeration: %s", ObjectPattern));
        return FALSE;
    }

    if (nodePattern) {
        nodeParsedPattern = CreateParsedPatternEx (Pool, nodePattern);
        if (nodeParsedPattern) {
            explodedNodeParsedPattern = ExplodeParsedPatternEx (Pool, nodeParsedPattern);
        }
        ObsFree (nodePattern);
        INVALID_POINTER (nodePattern);
    }

    if (leafPattern) {
        leafParsedPattern = CreateParsedPatternEx (Pool, leafPattern);
        if (leafParsedPattern) {
            explodedLeafParsedPattern = ExplodeParsedPatternEx (Pool, leafParsedPattern);
        }
        ObsFree (leafPattern);
        INVALID_POINTER (leafPattern);
    }

    enumData = TypeEnumInfo->FirstEnum;

    while (enumData) {
        if (pTestContainer (enumData->ExplodedNodeParsedPattern, explodedNodeParsedPattern, enumData->ExplodedLeafParsedPattern, explodedLeafParsedPattern)) {
            DEBUGMSG ((DBG_FLOW, "Enumeration %s not added. It will be handled during enumeration %s.", ObjectPattern, enumData->Pattern));
            break;
        }
        if (pTestContainer (explodedNodeParsedPattern, enumData->ExplodedNodeParsedPattern, explodedLeafParsedPattern, enumData->ExplodedLeafParsedPattern)) {
            DEBUGMSG ((DBG_FLOW, "Enumeration %s will replace enumeration %s.", ObjectPattern, enumData->Pattern));
            if (enumData->Prev) {
                enumData->Prev->Next = enumData->Next;
            }
            if (enumData->Next) {
                enumData->Next->Prev = enumData->Prev;
            }
            if (TypeEnumInfo->FirstEnum == enumData) {
                TypeEnumInfo->FirstEnum = enumData->Next;
            }
            if (TypeEnumInfo->LastEnum == enumData) {
                TypeEnumInfo->LastEnum = enumData->Prev;
            }
            PmReleaseMemory (Pool, enumData->Pattern);
            DestroyParsedPattern (enumData->ExplodedLeafParsedPattern);
            DestroyParsedPattern (enumData->LeafParsedPattern);
            DestroyParsedPattern (enumData->ExplodedNodeParsedPattern);
            DestroyParsedPattern (enumData->NodeParsedPattern);
            oldEnumData = enumData;
            enumData = enumData->Next;
            PmReleaseMemory (Pool, oldEnumData);
        } else {
            enumData = enumData->Next;
        }
    }

    if (enumData == NULL) {

        DEBUGMSG ((DBG_FLOW, "Adding Enumeration %s to the list of enumerations of type %s.", ObjectPattern, TypeEnumInfo->TypeName));

        enumData = (PENUMDATA) PmGetMemory (Pool, sizeof (ENUMDATA));
        ZeroMemory (enumData, sizeof (ENUMDATA));
        enumData->Pattern = PmDuplicateString (Pool, ObjectPattern);
        enumData->NodeParsedPattern = nodeParsedPattern;
        enumData->ExplodedNodeParsedPattern = explodedNodeParsedPattern;
        enumData->LeafParsedPattern = leafParsedPattern;
        enumData->ExplodedLeafParsedPattern = explodedLeafParsedPattern;
        if (TypeEnumInfo->LastEnum) {
            TypeEnumInfo->LastEnum->Next = enumData;
        }
        enumData->Prev = TypeEnumInfo->LastEnum;
        TypeEnumInfo->LastEnum = enumData;
        if (!TypeEnumInfo->FirstEnum) {
            TypeEnumInfo->FirstEnum = enumData;
        }
    } else {
        DestroyParsedPattern (explodedLeafParsedPattern);
        DestroyParsedPattern (leafParsedPattern);
        DestroyParsedPattern (explodedNodeParsedPattern);
        DestroyParsedPattern (nodeParsedPattern);
    }
    return TRUE;
}

PTYPEENUMINFO
pGetTypeEnumInfo (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      BOOL GlobalData
    )

/*++

Routine Description:

  pGetTypeEnumInfo returns the TypeEnumInfo for a specified type.

Arguments:

  ObjectTypeId - Specifies the object type.

  GlobalData - Specifies TRUE if the type enum data is global to the whole process,
               or FALSE if it is specific to the current enumeration queue.

Return Value:

  A TypeEnumInfo structure if one was found, NULL otherwise.

--*/

{
    UINT i;
    UINT count;
    PTYPEENUMINFO rTypeEnumInfo;
    PGROWLIST *typeData;

    if (GlobalData) {
        typeData = &g_GlobalTypeData;
    } else {
        typeData = &g_TypeData;
    }

    if (!(*typeData)) {
        return NULL;
    }

    count = GlGetSize (*typeData);

    //
    // Find the matching type info for this item.
    //
    for (i = 0; i < count; i++) {

        rTypeEnumInfo = (PTYPEENUMINFO) GlGetItem (*typeData, i);
        if (rTypeEnumInfo->ObjectTypeId == ObjectTypeId) {
            return rTypeEnumInfo;
        }
    }

    return NULL;
}

BOOL
pProcessQueueEnumeration (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      FARPROC Callback,
    IN      FARPROC Callback2,                      OPTIONAL
    IN      ULONG_PTR CallbackArg,                  OPTIONAL
    IN      PCTSTR FunctionId,                      OPTIONAL
    IN      CALLBACK_TYPE CallbackType
    )

/*++

Routine Description:

  pProcessQueueEnumeration is used by Source Gather Modules and Destination Gather Modules
  in order to register a callback function to be called for a particular object enumeration.

Arguments:

  ObjectTypeId      - Specifies the object type for the enumeration.
  ObjectPattern     - Specifies the enumeration pattern to use.
  Callback          - Specifies the function to callback during the enumeration
  Callback2         - Specifies the second function to callback during the enumeration (used
                      for the free function of physical hooks)
  CallbackArg       - Specifies a caller-defined value to be passed back on
                      each enumeration
  FunctionId        - Specifies the function identifier string, which is used
                      to prioritize function calls. The function string must
                      match the priorization string in the control INF file.
  GrowEnumPattern   - Specifies if the global enumeration pattern should be
                      grown to include this one. If FALSE, this function just
                      wants to be called back for all objects matching the
                      pattern but does not want to force the enumeration of
                      the pattern.
  ExclusionCallback - Specifies TRUE if Callback is an exclusion callback, or
                      FALSE if Callback is an object enum callback

Return Value:

  TRUE if the enumeration was successfully queued, FALSE otherwise.

--*/
{
    PTYPEENUMINFO typeEnumInfo;
    PCALLBACKDATA * list;
    BOOL globalData;
    BOOL result = FALSE;
    MIG_OBJECTSTRINGHANDLE handle = NULL;
    PMHANDLE pool;

    __try {

        MYASSERT (ObjectTypeId);
        if (!ObjectPattern) {
            handle = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
            ObjectPattern = handle;
            if (!handle) {
                MYASSERT (FALSE);
                __leave;
            }
        }

        if (CallbackType == CALLBACK_PHYSICAL_ACQUIRE ||
            CallbackType == CALLBACK_PHYSICAL_ENUM ||
            CallbackType == CALLBACK_EXCLUSION
            ) {
            globalData = TRUE;
            pool = g_GlobalQueuePool;
        } else {
            globalData = FALSE;
            pool = g_CurrentQueuePool;
        }

        if (!g_CurrentGroup) {
            DEBUGMSG ((DBG_ERROR, "%s called outside of ISM-managed callback", g_QueueFnName));
            __leave;
        }

        typeEnumInfo = pGetTypeEnumInfo (ObjectTypeId, globalData);

        if (!typeEnumInfo) {

            DEBUGMSG ((DBG_ERROR, "%s: %d does not match a known object type.", g_QueueFnName, ObjectTypeId));
            __leave;

        }

        //
        // Save away the callback function and associated data.
        //

        switch (CallbackType) {

        case CALLBACK_EXCLUSION:
            list = &typeEnumInfo->ExclusionList;
            break;

        case CALLBACK_PHYSICAL_ENUM:
            list = &typeEnumInfo->PhysicalEnumList;
            break;

        case CALLBACK_PHYSICAL_ACQUIRE:
            list = &typeEnumInfo->PhysicalAcquireList;
            break;

        default:
            list = &typeEnumInfo->FunctionList;
            break;

        }

        if (!pRegisterCallback (
                pool,
                list,
                Callback,
                Callback2,
                CallbackArg,
                ObjectPattern,
                FunctionId,
                CallbackType
                )) {
            __leave;
        }

        if (CallbackType == CALLBACK_NORMAL) {
            //
            // Save the pattern into the object tree and link the callback function with it.
            //
            if (!pAddEnumeration (pool, typeEnumInfo, ObjectPattern)) {
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {
        if (handle) {
            IsmDestroyObjectHandle (handle);
        }
    }

    return result;
}


BOOL
IsmProhibitPhysicalEnum (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      PMIG_PHYSICALENUMCHECK EnumCheckCallback,       OPTIONAL
    IN      ULONG_PTR CallbackArg,                          OPTIONAL
    IN      PCTSTR FunctionId                               OPTIONAL
    )
{
    SETQUEUEFN(TEXT("IsmProhibitPhysicalEnum"));

    if (!ObjectPattern) {
        DEBUGMSG ((DBG_ERROR, "IsmProhibitPhysicalEnum: ObjectPattern is required"));
        return FALSE;
    }

    return pProcessQueueEnumeration (
                ObjectTypeId,
                ObjectPattern,
                (FARPROC) EnumCheckCallback,
                NULL,
                CallbackArg,
                FunctionId,
                CALLBACK_PHYSICAL_ENUM
                );
}


BOOL
IsmAddToPhysicalEnum (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectBase,
    IN      PMIG_PHYSICALENUMADD EnumAddCallback,
    IN      ULONG_PTR CallbackArg                           OPTIONAL
    )
{
    PCTSTR newNode = NULL;
    PCTSTR newLeaf = NULL;
    UINT u;
    UINT count;
    ENUMADDCALLBACK callbackStruct;
    PENUMADDCALLBACK storedStruct;
    BOOL result = FALSE;
    UINT newTchars;
    UINT existTchars;
    UINT tchars;
    CHARTYPE ch;

    if (!ObjectTypeId || !ObjectBase || !EnumAddCallback) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // First test to see if the object base is already listed
    //

    ObsSplitObjectStringEx (ObjectBase, &newNode, &newLeaf, NULL, TRUE);

    if (!newNode) {
        DEBUGMSG ((DBG_ERROR, "IsmAddToPhysicalEnum requires a node"));
    } else {

        count = GlGetSize (&g_EnumAddList);

        for (u = 0 ; u < count ; u++) {

            storedStruct = (PENUMADDCALLBACK) GlGetItem (&g_EnumAddList, u);
            MYASSERT (storedStruct);

            if (storedStruct->AddCallback != EnumAddCallback) {

                if (StringIMatch (newNode, storedStruct->Node)) {
                    //
                    // Node is the same; leaf must be unique
                    //

                    if (!newLeaf || !storedStruct->Leaf) {
                        DEBUGMSG ((DBG_ERROR, "IsmAddToPhysicalEnum requires a unique object for %s", newNode));
                        break;
                    }

                    if (StringIMatch (newLeaf, storedStruct->Leaf)) {
                        DEBUGMSG ((
                            DBG_ERROR,
                            "IsmAddToPhysicalEnum does not have a unique leaf for %s leaf %s",
                            newNode,
                            newLeaf
                            ));
                        break;
                    }
                } else if (!newLeaf) {

                    //
                    // New node cannot be a prefix of an existing node, and vice-versa
                    //

                    newTchars = TcharCount (newNode);
                    existTchars = TcharCount (storedStruct->Node);

                    tchars = min (newTchars, existTchars);

                    //
                    // Compare only when new node might consume stored node
                    //

                    if (existTchars == tchars) {
                        // stored node is shortest; ignore if it has a leaf
                        if (storedStruct->Leaf) {
                            continue;
                        }
                    }

                    if (StringIMatchTcharCount (newNode, storedStruct->Node, tchars)) {

                        //
                        // Verify the end of the common prefix lands on either a nul or a
                        // backslash.  Otherwise, the prefix isn't common.
                        //

                        if (tchars == newTchars) {
                            ch = (CHARTYPE) _tcsnextc (newNode + tchars);
                        } else {
                            ch = (CHARTYPE) _tcsnextc (storedStruct->Node + tchars);
                        }

                        if (!ch || ch == TEXT('\\')) {

                            if (tchars == newTchars) {
                                DEBUGMSG ((
                                    DBG_ERROR,
                                    "IsmAddToPhysicalEnum: %s is already handled by %s",
                                    newNode,
                                    storedStruct->Node
                                    ));
                            } else {
                                DEBUGMSG ((
                                    DBG_ERROR,
                                    "IsmAddToPhysicalEnum: %s is already handled by %s",
                                    storedStruct->Node,
                                    newNode
                                    ));
                            }
                            break;
                        }
                    }
                }
            }
        }

        if (u >= count) {

            ZeroMemory (&callbackStruct, sizeof (callbackStruct));

            callbackStruct.ObjectTypeId = ObjectTypeId & ~(PLATFORM_MASK);
            callbackStruct.Node = PmDuplicateString (g_UntrackedFlowPool, newNode);
            callbackStruct.Leaf = newLeaf ? PmDuplicateString (g_UntrackedFlowPool, newLeaf) : NULL;
            callbackStruct.AddCallback = EnumAddCallback;
            callbackStruct.AddCallbackArg = CallbackArg;

            GlAppend (&g_EnumAddList, (PBYTE) &callbackStruct, sizeof (ENUMADDCALLBACK));

            result = TRUE;
        }
    }

    ObsFree (newNode);
    ObsFree (newLeaf);

    return result;
}


BOOL
IsmRegisterPhysicalAcquireHook (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,           OPTIONAL
    IN      PMIG_PHYSICALACQUIREHOOK HookCallback,
    IN      PMIG_PHYSICALACQUIREFREE FreeCallback,          OPTIONAL
    IN      ULONG_PTR CallbackArg,                          OPTIONAL
    IN      PCTSTR FunctionId                               OPTIONAL
    )
{
    ObjectTypeId &= ~PLATFORM_MASK;

    SETQUEUEFN(TEXT("IsmRegisterPhysicalAcquireHook"));

    return pProcessQueueEnumeration (
                ObjectTypeId,
                ObjectPattern,
                (FARPROC) HookCallback,
                (FARPROC) FreeCallback,
                CallbackArg,
                FunctionId,
                CALLBACK_PHYSICAL_ACQUIRE
                );
}


BOOL
IsmRegisterStaticExclusion (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    )
{
    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    pAddStaticExclusion (ObjectTypeId, EncodedObjectName);

    return TRUE;
}


UINT
WINAPI
pMakeApplyCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    if (CallerArg & QUEUE_MAKE_APPLY) {
        IsmMakeApplyObject (Data->ObjectTypeId, Data->ObjectName);
    } else if (CallerArg & QUEUE_MAKE_PERSISTENT) {
        IsmMakePersistentObject (Data->ObjectTypeId, Data->ObjectName);
    }

    if (CallerArg & QUEUE_OVERWRITE_DEST) {
        IsmAbandonObjectOnCollision ((Data->ObjectTypeId & ~PLATFORM_MASK)|PLATFORM_DESTINATION, Data->ObjectName);
    } else if (CallerArg & QUEUE_DONT_OVERWRITE_DEST) {
        IsmAbandonObjectOnCollision ((Data->ObjectTypeId & ~PLATFORM_MASK)|PLATFORM_SOURCE, Data->ObjectName);
    }

    if (CallerArg & QUEUE_MAKE_NONCRITICAL) {
        IsmMakeNonCriticalObject (Data->ObjectTypeId, Data->ObjectName);
    }

    return CALLBACK_ENUM_CONTINUE;
}


BOOL
IsmQueueEnumeration (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,   OPTIONAL
    IN      PMIG_OBJECTENUMCALLBACK Callback,       OPTIONAL
    IN      ULONG_PTR CallbackArg,                  OPTIONAL
    IN      PCTSTR FunctionId                       OPTIONAL
    )

/*++

Routine Description:

  IsmQueueEnumeration is used by Source Gather Modules and Destination Gather
  Modules in order to register a callback function to be called for a
  particular object enumeration.

Arguments:

  ObjectTypeId  - Specifies the object type for the enumeration.

  ObjectPattern - Specifies the enumeration pattern to use.  If not specified,
                  all objects for ObjectTypeId are queued.

  Callback      - Specifies the function to callback during the enumeration.
                  If not defined, the built-in ISM callback is used (which
                  marks the objects as persistent).

  CallbackArg   - Specifies a caller-defined value to be passed back on
                  each enumeration.  If Callback is NULL, then this argument
                  specifies zero or more of the following flags:

                    QUEUE_MAKE_PERSISTENT or QUEUE_MAKE_APPLY (mutually exclusive)
                    QUEUE_OVERWRITE_DEST or QUEUE_DONT_OVERWRITE_DEST (mutually exclusive)


  FunctionId    - Specifies the function identifier string, which is used to
                  prioritize function calls. The function string must match
                  the priorization string in the control INF file.  If
                  Callback is NULL, then this parameter is forced to the value
                  "SetDestPriority", "MakePersistent" or "MakeApply" depending
                  on CallbackArg.

Return Value:

  TRUE if the enumeration was successfully queued, FALSE otherwise.

--*/
{
    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    SETQUEUEFN(TEXT("IsmQueueEnumeration"));

    if (!Callback) {
        Callback = pMakeApplyCallback;

        if (!CallbackArg) {
            CallbackArg = QUEUE_MAKE_APPLY;
        }

        if (CallbackArg & QUEUE_MAKE_APPLY) {
            FunctionId = TEXT("MakeApply");
        } else if (CallbackArg & QUEUE_MAKE_PERSISTENT) {
            FunctionId = TEXT("MakePersistent");
        } else {
            FunctionId = TEXT("SetDestPriority");
        }
    }

    return pProcessQueueEnumeration (
                ObjectTypeId,
                ObjectPattern,
                (FARPROC) Callback,
                NULL,
                CallbackArg,
                FunctionId,
                CALLBACK_NORMAL
                );
}


BOOL
IsmHookEnumeration (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      PMIG_OBJECTENUMCALLBACK Callback,
    IN      ULONG_PTR CallbackArg,                  OPTIONAL
    IN      PCTSTR FunctionId                       OPTIONAL
    )

/*++

Routine Description:

  IsmHookEnumeration is used by Source Gather Modules and Destination Gather Modules
  in order to register a callback function to be called for a particular object enumeration. The
  difference to IsmQueueEnumeration is that this function does not expand the
  global enumeration pattern.

Arguments:

  ObjectTypeId  - Specifies the object type for the enumeration.

  ObjectPattern - Specifies the enumeration pattern to use.  If not specified,
                  all objects of type ObjectTypeId are hooked.

  Callback      - Specifies the function to callback during the enumeration

  CallbackArg   - Specifies a caller-defined value to be passed back on
                  each enumeration

  FunctionId    - Specifies the function identifier string, which is used to
                  prioritize function calls. The function string must match
                  the priorization string in the control INF file.

Return Value:

  TRUE if the enumeration was successfully queued, FALSE otherwise.

--*/
{
    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    SETQUEUEFN(TEXT("IsmHookEnumeration"));

    return pProcessQueueEnumeration (
                ObjectTypeId,
                ObjectPattern,
                (FARPROC) Callback,
                NULL,
                CallbackArg,
                FunctionId,
                CALLBACK_HOOK
                );
}


BOOL
IsmRegisterDynamicExclusion (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,   OPTIONAL
    IN      PMIG_DYNAMICEXCLUSIONCALLBACK Callback,
    IN      ULONG_PTR CallbackArg,                  OPTIONAL
    IN      PCTSTR FunctionId                       OPTIONAL
    )
{
    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    SETQUEUEFN(TEXT("IsmRegisterDynamicExclusion"));

    return pProcessQueueEnumeration (
                ObjectTypeId,
                ObjectPattern,
                (FARPROC) Callback,
                NULL,
                CallbackArg,
                FunctionId,
                CALLBACK_EXCLUSION
                );
}


BOOL
pRegisterNonEnumeratedCallback (
    IN      FARPROC Callback,
    IN      UINT WhenCalled,
    IN      PCTSTR FunctionId,  OPTIONAL
    IN      BOOL PerTypeId,
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )

/*++

Routine Description:

  IsmRegisterNonEnumeratedCallback is used to register a function to be
  called either before or after the enumeration of data.

Arguments:

  Callback      - Specifies the function to call.
  WhenCalled    - Specifies the timing of the non-enumerated callback. Either
                  CALLBEFOREOBJECTENUMERATIONS or CALLAFTEROBJECTENUMERATIONS
  FunctionId    - Optionally specifies the function identifier string. This
                  parameter can be used to add function level prioritization to
                  the module.
  PerTypeId     - Specifies if the pre or post enumeration callback is per type
  ObjectTypeId  - Specifies the object type id if PerTypeId is TRUE

Return Value:

  TRUE if the function was successfully registered. FALSE otherwise.

--*/
{
    PTYPEENUMINFO typeEnumInfo;
    PCALLBACKDATA * list;

    MYASSERT (Callback);
    MYASSERT (WhenCalled == CALLBEFOREOBJECTENUMERATIONS || WhenCalled == CALLAFTEROBJECTENUMERATIONS);

    if (!g_CurrentGroup) {
        DEBUGMSG ((DBG_ERROR, "IsmRegisterNonEnumeratedCallback called outside of ISM-managed callback."));
        return FALSE;
    }

    if (PerTypeId) {
        typeEnumInfo = pGetTypeEnumInfo (ObjectTypeId, FALSE);

        if (!typeEnumInfo) {
            DEBUGMSG ((DBG_ERROR, "IsmRegisterNonEnumeratedCallback: %d does not match a known object type.", ObjectTypeId));
            return FALSE;
        }
        if (WhenCalled == CALLBEFOREOBJECTENUMERATIONS) {
            list = &(typeEnumInfo->PreEnumerationFunctionList);
        }
        else {
            list = &(typeEnumInfo->PostEnumerationFunctionList);
        }
    } else {
        if (WhenCalled == CALLBEFOREOBJECTENUMERATIONS) {
            list = &g_PreEnumerationFunctionList;
        }
        else {
            list = &g_PostEnumerationFunctionList;
        }
    }

    return pRegisterCallback (
                g_CurrentQueuePool,
                list,
                (FARPROC) Callback,
                NULL,
                (ULONG_PTR) 0,
                NULL,
                FunctionId,
                CALLBACK_NORMAL
                );
}

BOOL
IsmRegisterPreEnumerationCallback (
    IN      PMIG_PREENUMCALLBACK Callback,
    IN      PCTSTR FunctionId               OPTIONAL
    )
{
    return pRegisterNonEnumeratedCallback (
                (FARPROC) Callback,
                CALLBEFOREOBJECTENUMERATIONS,
                FunctionId,
                FALSE,
                0
                );
}

BOOL
IsmRegisterTypePreEnumerationCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PMIG_PREENUMCALLBACK Callback,
    IN      PCTSTR FunctionId               OPTIONAL
    )
{
    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    return pRegisterNonEnumeratedCallback (
                (FARPROC) Callback,
                CALLBEFOREOBJECTENUMERATIONS,
                FunctionId,
                TRUE,
                ObjectTypeId
                );
}

BOOL
IsmRegisterPostEnumerationCallback (
    IN      PMIG_POSTENUMCALLBACK Callback,
    IN      PCTSTR FunctionId               OPTIONAL
    )
{
    return pRegisterNonEnumeratedCallback (
                (FARPROC) Callback,
                CALLAFTEROBJECTENUMERATIONS,
                FunctionId,
                FALSE,
                0
                );
}

BOOL
IsmRegisterTypePostEnumerationCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PMIG_POSTENUMCALLBACK Callback,
    IN      PCTSTR FunctionId               OPTIONAL
    )
{
    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    return pRegisterNonEnumeratedCallback (
                (FARPROC) Callback,
                CALLAFTEROBJECTENUMERATIONS,
                FunctionId,
                TRUE,
                ObjectTypeId
                );
}

VOID
pCreateFunctionListForPattern (
    IN OUT  PGROWLIST List,
    IN      PTYPEENUMINFO TypeEnumInfo,
    IN      PCTSTR Pattern,
    IN      PPARSEDPATTERN ExplodedNodeParsedPattern,
    IN      PPARSEDPATTERN ExplodedLeafParsedPattern,
    IN      CALLBACK_TYPE CallbackType
    )

/*++

Routine Description:

  pCreateFunctionListForPattern enumerates all callback functions for a given
  type and determines if they could be interested in an enumeration keyed off
  of the given pattern. Since we use a minimal list of patterns, at each
  pattern we must come up with the list of callback functions associated with
  patterns contained by our minimal pattern.

Arguments:

  List     - Specifies the growlist where the callback functions are to be
             stored. After the function's return, this list contains all
             callback functions that are needed for the given enumeration
             pattern.

  TypeEnumInfo - Specifies the type to draw potential callback functions from.

  Pattern  - Specifies the minimal pattern to that will be used for
             enumeration.

  ExplodedNodeParsedPattern - Specifies the node portion of Pattern, in pre-parsed
                              exploded format.

  ExplodedLeafParsedPattern - Specifies the leaf portion of Pattern, in pre-parsed
                              exploded format.

  CallbackType - Specifies which type of callback list to use (a CALLBACK_* constant)

Return Value:

  None.

--*/

{

    PCALLBACKDATA data;
    BOOL processHooks = FALSE;

    if (!TypeEnumInfo) {
        return;
    }

    //
    // Loop through all functions for this type, and add functions that fall under the
    // current enumeration pattern.
    //

    switch (CallbackType) {

    case CALLBACK_EXCLUSION:
        data = TypeEnumInfo->ExclusionList;
        break;

    default:
        data = TypeEnumInfo->FunctionList;
        processHooks = TRUE;
        break;

    }

    if (!data) {
        return;
    }

    while (data) {
        if (pTestContainer (
                ExplodedNodeParsedPattern,
                data->ExplodedNodeParsedPattern,
                ExplodedLeafParsedPattern,
                data->ExplodedLeafParsedPattern
                )) {

            GlAppend (List, (PBYTE) data, sizeof (CALLBACKDATA));

        } else if (processHooks) {
            if (data->CallbackType == CALLBACK_HOOK) {

                if (pTestContainerEx (
                        data->ExplodedNodeParsedPattern,
                        ExplodedNodeParsedPattern,
                        data->ExplodedLeafParsedPattern,
                        ExplodedLeafParsedPattern
                        )) {

                    GlAppend (List, (PBYTE) data, sizeof (CALLBACKDATA));

                }
            }
        }

        data = data->Next;
    }
}

VOID
pDestroyFunctionListForPattern (
    IN OUT PGROWLIST List
    )

/*++

Routine Description:

  This function simply cleans up the resources associated with a function
  list.

Arguments:

  List - Specifies the growlist of callbackdata to clean up.

Return Value:

  None.

--*/

{
    UINT i;
    PCALLBACKDATA data;
    UINT count;

    //
    // Clean up enum modification stacks.
    //

    count = GlGetSize (List);

    for (i = 0; i < count; i++) {

        data = (PCALLBACKDATA) GlGetItem (List, i);
        GbFree (&data->EnumFlags);
    }

    //
    // Clean up list itself.
    //
    GlFree (List);
}


VOID
pAddStaticExclusion (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedFullName
    )
{
    HASHTABLE exclusionTable;

    if (!EncodedFullName) {
        //
        // Ignore request for bad name
        //
        return;
    }
    ObjectTypeId = ObjectTypeId & (~PLATFORM_MASK);

    exclusionTable = GetTypeExclusionTable (ObjectTypeId);
    if (!exclusionTable) {
        return;
    }
    HtAddString (exclusionTable, EncodedFullName);
}


BOOL
pIsObjectExcluded (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedFullName
    )
{
    HASHTABLE exclusionTable;

    if (!EncodedFullName) {
        return FALSE;
    }

    //
    // Check the hash table for an entry
    //

    ObjectTypeId = ObjectTypeId & (~PLATFORM_MASK);

    exclusionTable = GetTypeExclusionTable (ObjectTypeId);
    if (!exclusionTable) {
        return FALSE;
    }

    if (HtFindString (exclusionTable, EncodedFullName)) {
        return TRUE;
    }

    return FALSE;
}


BOOL
pIsObjectNodeExcluded (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR NodePattern,
    OUT     PBOOL PossiblePatternMatch      OPTIONAL
    )
{
    HASHTABLE exclusionTable;
    HASHTABLE_ENUM e;
    PCTSTR node;
    PTSTR wackedExclusion;
    PCTSTR firstWildcard = NULL;
    PCTSTR wildcard1;
    PCTSTR wildcard2;
    UINT patternStrTchars;
    UINT hashStrTchars;
    BOOL match = FALSE;

    ObjectTypeId = ObjectTypeId & (~PLATFORM_MASK);

    exclusionTable = GetTypeExclusionTable (ObjectTypeId);
    if (!exclusionTable) {
        return FALSE;
    }

    //
    // If NodePattern is a pattern, then PossiblePatternMatch is specified.
    // Otherwise, NodePattern is a specific node.
    //

    if (PossiblePatternMatch) {
        //
        // Computer the length of the non-pattern portion
        //

        *PossiblePatternMatch = FALSE;

        firstWildcard = NULL;

        wildcard1 = ObsFindNonEncodedCharInEncodedString (NodePattern, TEXT('*'));
        wildcard2 = ObsFindNonEncodedCharInEncodedString (NodePattern, TEXT('?'));

        if (wildcard1) {
            firstWildcard = wildcard1;
        }
        if (wildcard2) {
            if ((!firstWildcard) || (firstWildcard > wildcard2)) {
                firstWildcard = wildcard2;
            }
        }

        if (!firstWildcard) {
            firstWildcard = GetEndOfString (NodePattern);
        }
    } else {
        firstWildcard = GetEndOfString (NodePattern);
    }

    //
    // Enumerate all exclusions and check NodePattern against them
    //

    patternStrTchars = (HALF_PTR) (firstWildcard - NodePattern);

    if (EnumFirstHashTableString (&e, exclusionTable)) {
        do {
            if (IsmIsObjectHandleNodeOnly (e.String)) {
                IsmCreateObjectStringsFromHandle (e.String, &node, NULL);
                MYASSERT (node);

                hashStrTchars = TcharCount (node);
                if (hashStrTchars < patternStrTchars) {

                    //
                    // Require exclusion to be a prefix, ending in a backslash
                    //

                    wackedExclusion = DuplicatePathString (node, sizeof (TCHAR));
                    AppendWack (wackedExclusion);

                    if (StringIPrefix (NodePattern, wackedExclusion)) {
                        match = TRUE;
                    }

                    FreePathString (wackedExclusion);

                } else {

                    //
                    // Require exclusion to match identically
                    //

                    if (hashStrTchars == patternStrTchars &&
                        StringIMatch (NodePattern, e.String)
                        ) {

                        match = TRUE;

                    } else if (PossiblePatternMatch && !match) {

                        //
                        // We *might* have an exclusion match (we can't tell).
                        // If the pattern contains no wacks, then we assume
                        // the enumerated node will determine exclusion
                        // properly.
                        //
                        // This could be optimized further by checking if the
                        // character set of NodePattern is a subset of the
                        // exclusion string.
                        //

                        if (!_tcschr (NodePattern, TEXT('\\'))) {
                            *PossiblePatternMatch = TRUE;
                        }
                    }
                }

                IsmDestroyObjectString (node);
            }

        } while (!match && EnumNextHashTableString (&e));
    }

    return match;
}


BOOL
pShouldCallGatherCallback (
    IN      PMIG_TYPEOBJECTENUM Object,
    IN      PCALLBACKDATA Callback
    )

/*++

Routine Description:

  This function encapsulates the logic needed to determine wether or not to
  callback the specified callback. This is necessary because patterns
  requested by various Data Gather Modules are collapsed into a minimal set
  of enumeration patterns. Therefore, we only know that a particular callback
  may be interested in the current object. This function is used to make
  sure.

Arguments:

  Object   - Specifies the current object being enumerated.
  Callback - Specifies the callback data to be checked. This may be modified,
             if a previous enumeration change request by the callback has now
             expired.

Return Value:

  TRUE if the callback should be called, FALSE otherwise.

--*/

{
    PCALLBACK_ENUMFLAGS flags;
    BOOL result = FALSE;
    PTSTR tempString;

    if (Object->Level >= Callback->MinLevel && Object->Level <= Callback->MaxLevel ) {

        //
        // Don't call callbacks that have signaled they are finished or that have errored.
        //
        if (Callback->Done || Callback->Error) {
            return FALSE;
        }

        //
        // See if there is a enumeration modification in effect for this callback.
        //
        flags = CALLBACK_ENUMFLAGS_TOP(&Callback->EnumFlags);

        //
        // Remove stale entries in the modification list.
        //
        while (flags) {
            if (Object->IsNode) {
                if (flags->Level > Object->Level) {
                    Callback->EnumFlags.End -= sizeof (CALLBACK_ENUMFLAGS);
                    flags = CALLBACK_ENUMFLAGS_TOP (&Callback->EnumFlags);
                    continue;
                }
                if ((flags->Level == Object->Level) && (flags->Flags == CALLBACK_SKIP_LEAVES)) {
                    Callback->EnumFlags.End -= sizeof (CALLBACK_ENUMFLAGS);
                    flags = CALLBACK_ENUMFLAGS_TOP (&Callback->EnumFlags);
                    continue;
                }
            }
            if (Object->IsLeaf) {
                if (flags->Level > (Object->Level + 1)) {
                    Callback->EnumFlags.End -= sizeof (CALLBACK_ENUMFLAGS);
                    flags = CALLBACK_ENUMFLAGS_TOP (&Callback->EnumFlags);
                    continue;
                }
            }
            break;
        }

        if (flags && (!flags->Enabled) && Object->IsNode && (flags->EnableLevel == Object->Level)) {
            flags->Enabled = TRUE;
        }

        //
        // Check flags to see if we should call this function.
        //
        if (flags) {

            if (flags->Enabled && flags->Flags == CALLBACK_THIS_TREE_ONLY) {
                if (flags->Level == Object->Level) {
                    Callback->Done = TRUE;
                    return FALSE;
                }
            }

            if (flags->Enabled && flags->Flags == CALLBACK_SKIP_LEAVES) {
                if ((Object->IsLeaf) && (flags->Level == Object->Level + 1)) {
                    return FALSE;
                }
            }

            if (flags->Enabled && flags->Flags == CALLBACK_SKIP_NODES) {
                if (flags->Level <= Object->Level){
                    return FALSE;
                }
            }
            if (flags->Enabled && flags->Flags == CALLBACK_SKIP_TREE) {
                if (flags->Level <= (Object->IsLeaf?Object->Level+1:Object->Level)){
                    return FALSE;
                }
            }
        }

        //
        // If we haven't failed out yet, do a pattern match against the function's requested
        // enumeration.
        //

        result = TRUE;

        if (Object->ObjectNode) {

            if (Callback->NodeParsedPattern) {
                result = TestParsedPattern (Callback->NodeParsedPattern, Object->ObjectNode);

                if (!result) {
                    //
                    // let's try one more time with a wack at the end
                    //

                    tempString = JoinText (Object->ObjectNode, TEXT("\\"));
                    result = TestParsedPattern (Callback->NodeParsedPattern, tempString);
                    FreeText (tempString);

                }
            } else {
                result = Object->ObjectLeaf != NULL;
            }
        }

        if (result && Object->ObjectLeaf) {

            if (Callback->LeafParsedPattern) {
                result = TestParsedPattern (Callback->LeafParsedPattern, Object->ObjectLeaf);
                if (!result &&
                    ((Object->ObjectTypeId & (~PLATFORM_MASK)) == MIG_FILE_TYPE) &&
                    (_tcschr (Object->ObjectLeaf, TEXT('.')) == NULL)
                    ) {
                    // let's try one more thing
                    tempString = JoinText (Object->ObjectLeaf, TEXT("."));
                    result = TestParsedPattern (Callback->LeafParsedPattern, tempString);
                    FreeText (tempString);
                }
            }
        }
    }

    return result;
}


BOOL
pProcessCallbackReturnCode (
    IN DWORD ReturnCode,
    IN PMIG_TYPEOBJECTENUM Object,
    IN OUT PCALLBACKDATA Callback
    )

/*++

Routine Description:

  This function encapsulates the logic for handling the return code of a
  callback function. Callback functions have the capability to alter the
  behavior of the enumeration with respect to themselves. This function takes
  care of logging those change requests.

Arguments:

  ReturnCode - Specifies a callback return code.
  Object     - Specifies the current object being enumerated.
  Callback   - Specifies the callback data structure responsible for the
               return code. May be modified if a change is required by the
               callback.

Return Value:

  TRUE if the return code was successfully processed, FALSE otherwise.

--*/

{
    PCALLBACK_ENUMFLAGS flags;

    if (ReturnCode & CALLBACK_ERROR) {

        //
        // the callback function encountered some error, will never be called again
        //
        Callback->Error = TRUE;

        DEBUGMSG ((DBG_ERROR, "A callback function returned an error while enumerating %s.", Object->ObjectName));

        //
        // NTRAID#NTBUG9-153257-2000/08/01-jimschm Add appropriate error handling here.
        //

    } else if (ReturnCode & CALLBACK_DONE_ENUMERATING) {

        //
        // the callback function is done enumerating, will never be called again
        //
        Callback->Done = TRUE;

    } else if (ReturnCode != CALLBACK_ENUM_CONTINUE) {

        //
        // Save callback enumeration flags into the callback's private stack.
        //

        if (ReturnCode & CALLBACK_THIS_TREE_ONLY) {
            flags = (PCALLBACK_ENUMFLAGS) GbGrow (&Callback->EnumFlags, sizeof(CALLBACK_ENUMFLAGS));
            flags->Level = Object->Level;
            flags->EnableLevel = Object->Level;
            flags->Enabled = FALSE;
            flags->Flags = CALLBACK_THIS_TREE_ONLY;
        }
        if (ReturnCode & CALLBACK_SKIP_NODES) {
            flags = (PCALLBACK_ENUMFLAGS) GbGrow (&Callback->EnumFlags, sizeof(CALLBACK_ENUMFLAGS));
            flags->Level = Object->IsLeaf?Object->Level+1:Object->Level;
            flags->EnableLevel = Object->IsLeaf?Object->Level+1:Object->Level;
            flags->Enabled = FALSE;
            flags->Flags = CALLBACK_SKIP_NODES;
        }
        if (ReturnCode & CALLBACK_SKIP_TREE) {
            flags = (PCALLBACK_ENUMFLAGS) GbGrow (&Callback->EnumFlags, sizeof(CALLBACK_ENUMFLAGS));
            flags->Level = Object->Level + 1;
            flags->EnableLevel = 0;
            flags->Enabled = TRUE;
            flags->Flags = CALLBACK_SKIP_TREE;
        }
        if (ReturnCode & CALLBACK_SKIP_LEAVES) {
            flags = (PCALLBACK_ENUMFLAGS) GbGrow (&Callback->EnumFlags, sizeof(CALLBACK_ENUMFLAGS));
            flags->Level = Object->Level + 1;
            flags->EnableLevel = 0;
            flags->Enabled = TRUE;
            flags->Flags = CALLBACK_SKIP_LEAVES;
        }
    }

    return TRUE;
}


BOOL
pDoSingleEnumeration (
    IN      PTYPEENUMINFO GlobalTypeEnumInfo,
    IN      PTYPEENUMINFO TypeEnumInfo,
    IN      PCTSTR ObjectPattern,
    IN      BOOL CallNormalCallbacks,
    IN      MIG_PROGRESSSLICEID SliceId     OPTIONAL
    )

/*++

Routine Description:

  Given a type structure and a pattern, this function runs an enumeration
  based on that pattern, calling all callbacks as needed in that enumeration.

Arguments:

  GlobalTypeEnumInfo - Specifies the type data for the exclude list. This parameter
                       supplies the excluded pattern list.

  TypeEnumInfo  - Specifies the type data for the enumeration to be run. This
                  parameter supplies the queued pattern lists.

  ObjectPattern - Specifies the pattern for the enumeration.

  CallNormalCallbacks - Specifies TRUE for normal callbacks to be processed,
                        or FALSE for hook callbacks to be processed

  SliceId - Specifies the progress bar slice ID, or 0 for no slice.  If
            specified, the slice ID will cause ticks to be generated for
            each container at level 3.


Return Value:

  TRUE if the enumeration was run successfully, FALSE otherwise.

--*/

{
    MIG_TYPEOBJECTENUM eObjects;
    GROWLIST funList = INIT_GROWLIST;
    GROWLIST exclFunList = INIT_GROWLIST;
    UINT i;
    PCALLBACKDATA callbackData;
    DWORD rc;
    MIG_OBJECTENUMDATA publicData;
    PTSTR leafPattern = NULL;
    PTSTR nodePattern = NULL;
    PPARSEDPATTERN nodeParsedPattern = NULL;
    PPARSEDPATTERN explodedNodeParsedPattern = NULL;
    PPARSEDPATTERN leafParsedPattern = NULL;
    PPARSEDPATTERN explodedLeafParsedPattern = NULL;
    PMIG_OBJECTENUMCALLBACK obEnumCallback;
    PMIG_DYNAMICEXCLUSIONCALLBACK exclusionCallback;
    UINT size;
    BOOL stop;
    BOOL b;
    BOOL fSkip;
    UINT fIndex;
    BOOL result = TRUE;
    static DWORD ticks;
    static UINT objects;
    BOOL extraExcludeCheck = FALSE;
    MIG_APPINFO appInfo;

    //
    // Is entire pattern excluded?
    //

    ObsSplitObjectStringEx (ObjectPattern, &nodePattern, &leafPattern, NULL, FALSE);

    if (nodePattern) {
        if (pIsObjectNodeExcluded (
                TypeEnumInfo->ObjectTypeId,
                nodePattern,
                &extraExcludeCheck
                )) {
            DEBUGMSG ((DBG_FLOW, "Pattern %s is completely excluded", ObjectPattern));

            ObsFree (nodePattern);
            return TRUE;
        }
    }

    //
    // Prepare parsed patterns for speed
    //

    if (nodePattern) {
        nodeParsedPattern = CreateParsedPatternEx (g_CurrentQueuePool, nodePattern);
        if (nodeParsedPattern) {
            explodedNodeParsedPattern = ExplodeParsedPatternEx (g_CurrentQueuePool, nodeParsedPattern);
        }
        ObsFree (nodePattern);
        INVALID_POINTER (nodePattern);
    }

    if (leafPattern) {
        leafParsedPattern = CreateParsedPatternEx (g_CurrentQueuePool, leafPattern);
        if (leafParsedPattern) {
            explodedLeafParsedPattern = ExplodeParsedPatternEx (g_CurrentQueuePool, leafParsedPattern);
        }
        ObsFree (leafPattern);
        INVALID_POINTER (leafPattern);
    }

    //
    // Perform enumeration
    //

    if (EnumFirstObjectOfType (&eObjects, TypeEnumInfo->ObjectTypeId, ObjectPattern, NODE_LEVEL_MAX)) {

        DEBUGMSG ((DBG_FLOW, "Enumerating objects of type %s with pattern %s.", TypeEnumInfo->TypeName, ObjectPattern));

        //
        // Get list of functions that want things from this particular enumeration.
        //

        pCreateFunctionListForPattern (
            &funList,
            TypeEnumInfo,
            ObjectPattern,
            explodedNodeParsedPattern,
            explodedLeafParsedPattern,
            CALLBACK_NORMAL
            );

        pCreateFunctionListForPattern (
            &exclFunList,
            GlobalTypeEnumInfo,
            ObjectPattern,
            explodedNodeParsedPattern,
            explodedLeafParsedPattern,
            CALLBACK_EXCLUSION
            );

        MYASSERT ((!CallNormalCallbacks) || GlGetSize (&funList));

        do {
            //
            // Should enumeration of this object be skipped?
            //

            objects++;
            LOG ((LOG_STATUS, (PCSTR) MSG_OBJECT_STATUS, objects, eObjects.NativeObjectName));

            if (!eObjects.ObjectLeaf) {
                // send our status to the app, but only for nodes to keep it fast
                ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
                appInfo.Phase = g_CurrentPhase;
                appInfo.SubPhase = 0;
                appInfo.ObjectTypeId = (eObjects.ObjectTypeId & (~PLATFORM_MASK));
                appInfo.ObjectName = eObjects.ObjectName;
                IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR) (&appInfo));
            }

            //
            // Is this object at level 3?  If so, tick the progress bar.
            //

            if (g_ProgressBarFn) {
                if (SliceId && !eObjects.ObjectLeaf && eObjects.SubLevel <= 3) {
                    IsmTickProgressBar (SliceId, 1);
                }
            }

            if (extraExcludeCheck && eObjects.ObjectNode) {
                if (pIsObjectNodeExcluded (
                        TypeEnumInfo->ObjectTypeId,
                        eObjects.ObjectNode,
                        NULL
                        )) {
                    DEBUGMSG ((DBG_FLOW, "Node %s is completely excluded", ObjectPattern));
                    AbortCurrentNodeEnum (&eObjects);
                    continue;
                }
            }

            if (pIsObjectExcluded (eObjects.ObjectTypeId, eObjects.ObjectName)) {
                DEBUGMSG ((DBG_FLOW, "Object %s is excluded", eObjects.ObjectName));

                //
                // If leaf is empty, abort enum of this node
                //

                if (!eObjects.ObjectLeaf) {
                    AbortCurrentNodeEnum (&eObjects);
                }

                continue;
            }

            if (eObjects.ObjectLeaf) {

                b = pIsObjectExcluded (
                        eObjects.ObjectTypeId,
                        ObsGetNodeLeafDivider (eObjects.ObjectName)
                        );

                if (b) {
                    DEBUGMSG ((DBG_FLOW, "Leaf %s is excluded", eObjects.ObjectLeaf));
                    continue;
                }
            }

            //
            // Call all dynamic exclusion functions
            //

            stop = FALSE;

            size = GlGetSize (&exclFunList);
            for (i = 0; i < size ; i++) {

                callbackData = (PCALLBACKDATA) GlGetItem (&exclFunList, i);

                if (pShouldCallGatherCallback (&eObjects, callbackData)) {

                    //
                    // Call the callback function
                    //

                    MYASSERT (!g_CurrentGroup);
                    g_CurrentGroup = callbackData->Group;

                    exclusionCallback = (PMIG_DYNAMICEXCLUSIONCALLBACK) callbackData->Function;
                    stop = exclusionCallback (
                                eObjects.ObjectTypeId,
                                eObjects.ObjectName,
                                callbackData->CallbackArg
                                );

                    g_CurrentGroup = NULL;

                    if (stop) {
                        break;
                    }
                }
            }

            if (stop) {
                DEBUGMSG ((
                    DBG_FLOW,
                    "Object %s is dynamically excluded",
                    eObjects.ObjectName
                    ));
                continue;
            }

            //
            // Check if the user wants to cancel.  If yes, fail with an error.
            //

            if (IsmCheckCancel()) {
                AbortObjectOfTypeEnum (&eObjects);
                SetLastError (ERROR_CANCELLED);
                result = FALSE;
                break;
            }

            //
            // Cycle through each of the list of functions looking for any that care about the current data.
            //

            size = GlGetSize (&funList);
            g_EnumerationList.End = 0;
            for (i = 0; i < size ; i++) {

                callbackData = (PCALLBACKDATA) GlGetItem (&funList, i);

                if (CallNormalCallbacks || (callbackData->CallbackType == CALLBACK_HOOK)) {

                    if (pShouldCallGatherCallback (&eObjects, callbackData)) {

                        fSkip = FALSE;

                        if (g_EnumerationList.End) {
                            fIndex = 0;
                            while (fIndex < g_EnumerationList.End) {
                                if (*((ULONG_PTR *)(g_EnumerationList.Buf + fIndex)) == (ULONG_PTR)callbackData->Function) {
                                    fSkip = TRUE;
                                }
                                fIndex += sizeof (callbackData->Function);
                                if (*((ULONG_PTR *)(g_EnumerationList.Buf + fIndex)) != (ULONG_PTR)callbackData->CallbackArg) {
                                    fSkip = FALSE;
                                }
                                fIndex += sizeof (callbackData->CallbackArg);
                                if (fSkip) {
                                    break;
                                }
                            }
                        }

                        if (!fSkip) {

                            CopyMemory (
                                GbGrow (&g_EnumerationList, sizeof (callbackData->Function)),
                                &(callbackData->Function),
                                sizeof (callbackData->Function)
                                );
                            CopyMemory (
                                GbGrow (&g_EnumerationList, sizeof (callbackData->CallbackArg)),
                                &(callbackData->CallbackArg),
                                sizeof (callbackData->CallbackArg)
                                );

                            //
                            // Copy the enumeration info to the public structure
                            //

                            publicData.ObjectTypeId = TypeEnumInfo->ObjectTypeId;
                            publicData.ObjectName = eObjects.ObjectName;
                            publicData.NativeObjectName = eObjects.NativeObjectName;
                            publicData.ObjectNode = eObjects.ObjectNode;
                            publicData.ObjectLeaf = eObjects.ObjectLeaf;

                            publicData.Level = eObjects.Level;
                            publicData.SubLevel = eObjects.SubLevel;
                            publicData.IsLeaf = eObjects.IsLeaf;
                            publicData.IsNode = eObjects.IsNode;

                            publicData.Details.DetailsSize = eObjects.Details.DetailsSize;
                            publicData.Details.DetailsData = eObjects.Details.DetailsData;

                            //
                            // Call the callback function
                            //

                            MYASSERT (!g_CurrentGroup);
                            g_CurrentGroup = callbackData->Group;

                            obEnumCallback = (PMIG_OBJECTENUMCALLBACK) callbackData->Function;

                            rc = obEnumCallback (&publicData, callbackData->CallbackArg);

                            g_CurrentGroup = NULL;

                            if (rc != CALLBACK_ENUM_CONTINUE) {
                                //
                                // Callback wants to make some sort of modification to its enumeration.
                                //
                                pProcessCallbackReturnCode (rc, &eObjects, callbackData);
                            }
                        }
                    }
                }
            }

        } while (EnumNextObjectOfType (&eObjects));

        //
        // Clean up function list.
        //
        pDestroyFunctionListForPattern (&funList);
        pDestroyFunctionListForPattern (&exclFunList);

    }
    ELSE_DEBUGMSG ((DBG_FLOW, "No objects found matching enumeration pattern %s.", ObjectPattern));

    DestroyParsedPattern (explodedLeafParsedPattern);
    DestroyParsedPattern (leafParsedPattern);
    DestroyParsedPattern (explodedNodeParsedPattern);
    DestroyParsedPattern (nodeParsedPattern);

    return result;
}


VOID
pCreatePhysicalTypeCallbackList (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      CALLBACK_TYPE CallbackType,
    IN OUT  PGROWLIST List
    )
{
    PTYPEENUMINFO typeEnumInfo;
    PCTSTR node;
    PCTSTR leaf;
    PCALLBACKDATA callbackData;
    BOOL callFn;

    //
    // Test object against all patterns of the type
    //

    typeEnumInfo = pGetTypeEnumInfo (ObjectTypeId & (~PLATFORM_MASK), TRUE);
    if (!typeEnumInfo) {
        return;
    }

    ObsSplitObjectStringEx (ObjectName, &node, &leaf, NULL, TRUE);
    if (!node && !leaf) {
        return;
    }

    switch (CallbackType) {

    case CALLBACK_PHYSICAL_ENUM:
        callbackData = typeEnumInfo->PhysicalEnumList;
        break;

    case CALLBACK_PHYSICAL_ACQUIRE:
        callbackData = typeEnumInfo->PhysicalAcquireList;
        break;

    default:
        MYASSERT (FALSE);
        return;
    }

    while (callbackData) {

        MYASSERT (callbackData->NodeParsedPattern);

        if (!node || TestParsedPattern (callbackData->NodeParsedPattern, node)) {

            if (callbackData->LeafParsedPattern && leaf) {
                callFn = TestParsedPattern (callbackData->LeafParsedPattern, leaf);
            } else if (leaf && !callbackData->LeafParsedPattern) {
                callFn = FALSE;
            } else {
                callFn = TRUE;
            }

            if (callFn) {
                GlAppend (List, (PBYTE) callbackData, sizeof (CALLBACKDATA));
            }
        }

        callbackData = callbackData->Next;
    }

    ObsFree (node);
    ObsFree (leaf);
}


BOOL
ExecutePhysicalAcquireCallbacks (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT Content,                       OPTIONAL
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit,
    OUT     PMIG_CONTENT *NewContent
    )
{
    UINT count;
    UINT u;
    PCALLBACKDATA callbackData;
    PMIG_PHYSICALACQUIREFREE acquireFree = NULL;
    PMIG_PHYSICALACQUIREHOOK acquireHook;
    PMIG_CONTENT updatedContent;
    BOOL result = TRUE;
    PMIG_CONTENT currentContent;

    pCreatePhysicalTypeCallbackList (
        ObjectTypeId,
        ObjectName,
        CALLBACK_PHYSICAL_ACQUIRE,
        &g_AcquireList
        );

    count = GlGetSize (&g_AcquireList);
    currentContent = Content;

    for (u = 0 ; u < count ; u++) {
        //
        // Call this function
        //

        callbackData = (PCALLBACKDATA) GlGetItem (&g_AcquireList, u);

        acquireHook = (PMIG_PHYSICALACQUIREHOOK) callbackData->Function;

        if (acquireHook) {

            updatedContent = NULL;

            if (!acquireHook (
                    ObjectName,
                    currentContent,
                    ContentType,
                    MemoryContentLimit,
                    &updatedContent,
                    FALSE,
                    callbackData->CallbackArg
                    )) {
                //
                // Hook says "don't acquire"
                //

                result = FALSE;
            }

            if (!result || updatedContent) {
                if (currentContent != Content) {
                    //
                    // Free previous hook content change
                    //

                    if (acquireFree) {
                        acquireFree (currentContent);
                        acquireFree = NULL;
                    }

                    currentContent = NULL;
                }

                if (updatedContent) {
                    //
                    // Hook provided replacement content
                    //

                    currentContent = updatedContent;
                    acquireFree = (PMIG_PHYSICALACQUIREFREE) callbackData->Function2;

                } else {
                    break;      // don't acquire -- we can stop now
                }
            }
        }
    }

    if (currentContent && acquireFree) {
        currentContent->IsmHandle = acquireFree;
    }

    *NewContent = currentContent != Content ? currentContent : NULL;

    GlReset (&g_AcquireList);

    return result;
}


BOOL
FreeViaAcquirePhysicalCallback (
    IN      PMIG_CONTENT Content
    )
{
    PMIG_PHYSICALACQUIREFREE acquireFree;

    if (!Content->IsmHandle) {
        return FALSE;
    }

    acquireFree = (PMIG_PHYSICALACQUIREFREE) Content->IsmHandle;
    if (acquireFree) {
        acquireFree (Content);
    }

    return TRUE;
}


BOOL
ExecutePhysicalEnumCheckCallbacks (
    IN      PMIG_TYPEOBJECTENUM ObjectEnum
    )
{
    UINT count;
    UINT u;
    PCALLBACKDATA callbackData;
    PMIG_PHYSICALENUMCHECK enumCheck;
    BOOL result = TRUE;

    pCreatePhysicalTypeCallbackList (
        ObjectEnum->ObjectTypeId,
        ObjectEnum->ObjectName,
        CALLBACK_PHYSICAL_ENUM,
        &g_EnumList
        );

    count = GlGetSize (&g_EnumList);

    for (u = 0 ; u < count ; u++) {
        //
        // Call this function
        //

        callbackData = (PCALLBACKDATA) GlGetItem (&g_EnumList, u);

        enumCheck = (PMIG_PHYSICALENUMCHECK) callbackData->Function;

        if (enumCheck) {

            if (!enumCheck (ObjectEnum, callbackData->CallbackArg)) {
                //
                // Hook says "skip"
                //

                result = FALSE;
                break;
            }
        } else {
            //
            // No callback means "skip"
            //

            result = FALSE;
            break;
        }
    }

    GlReset (&g_EnumList);

    return result;
}


BOOL
ExecutePhysicalEnumAddCallbacks (
    IN OUT  PMIG_TYPEOBJECTENUM ObjectEnum,
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      MIG_PARSEDPATTERN ParsedPattern,
    IN OUT  PUINT CurrentCallback
    )
{
    BOOL result = FALSE;
    BOOL done;
    PENUMADDCALLBACK callback;
    MIG_OBJECTTYPEID objectTypeId;

    objectTypeId = ObjectEnum->ObjectTypeId & ~(PLATFORM_MASK);

    do {
        done = TRUE;

        if (GlGetSize (&g_EnumAddList) > *CurrentCallback) {

            callback = (PENUMADDCALLBACK) GlGetItem (&g_EnumAddList, *CurrentCallback);

            MYASSERT (callback);
            MYASSERT (callback->AddCallback);

            if (callback->ObjectTypeId != objectTypeId) {
                result = FALSE;
            } else {
                result = callback->AddCallback (ObjectEnum, Pattern, ParsedPattern, callback->AddCallbackArg, FALSE);
            }

            if (!result) {
                *CurrentCallback += 1;
                done = FALSE;
            }
        }
    } while (!done);

    return result;
}


VOID
AbortPhysicalEnumCallback (
    IN      PMIG_TYPEOBJECTENUM ObjectEnum,             ZEROED
    IN      UINT CurrentCallback
    )
{
    PENUMADDCALLBACK callback;

    if (GlGetSize (&g_EnumAddList) > CurrentCallback) {

        callback = (PENUMADDCALLBACK) GlGetItem (&g_EnumAddList, CurrentCallback);

        MYASSERT (callback);
        MYASSERT (callback->AddCallback);

        callback->AddCallback (ObjectEnum, NULL, NULL, callback->AddCallbackArg, TRUE);
    }

    ZeroMemory (ObjectEnum, sizeof (MIG_TYPEOBJECTENUM));
}


UINT
pEstimateSingleEnumerationTicks (
    IN      PTYPEENUMINFO TypeEnumInfo,
    IN      PCTSTR ObjectPattern
    )

/*++

Routine Description:

  Given a type structure and a pattern, this function runs an enumeration
  based on that pattern, counting all the containers 3 levels deep.  This
  is a quick approximation of how much work there is to do.

Arguments:

  TypeEnumInfo  - Specifies the type data for the enumeration to be run.
  ObjectPattern - Specifies the pattern for the enumeration.

Return Value:

  The number of containers exactly 3 levels deep in the object pattern.

--*/

{
    MIG_TYPEOBJECTENUM eObjects;
    PTSTR nodePattern = NULL;
    UINT ticks = 0;
    MIG_OBJECTSTRINGHANDLE nodeOnlyPattern;

    ObsSplitObjectStringEx (ObjectPattern, &nodePattern, NULL, NULL, FALSE);
    if (nodePattern) {
        nodeOnlyPattern = ObsBuildEncodedObjectStringEx (nodePattern, NULL, FALSE);

        ObsFree (nodePattern);
        INVALID_POINTER (nodePattern);
    } else {
        return 0;
    }

    if (EnumFirstObjectOfType (&eObjects, TypeEnumInfo->ObjectTypeId, nodeOnlyPattern, 3)) {

        DEBUGMSG ((DBG_FLOW, "Estimating number of objects of type %s with pattern %s.", TypeEnumInfo->TypeName, nodeOnlyPattern));

        do {

            if (eObjects.SubLevel <= 3) {
                ticks++;
            }

        } while (EnumNextObjectOfType (&eObjects));
    }
    ELSE_DEBUGMSG ((DBG_FLOW, "No objects found matching enumeration pattern %s.", nodeOnlyPattern));

    ObsFree (nodeOnlyPattern);

    return ticks;
}


BOOL
pCallNonEnumeratedCallbacks (
    IN PCALLBACKDATA FunctionList
    )

/*++

Routine Description:

  This function simply takes the provided list of CALLBACKDATA and for each
  function, calls it as a non-enumerated callback.

Arguments:

  FunctionList - Specifies the list of functions to call.

Return Value:

  TRUE if all functions were called successfully. FALSE otherwise.

--*/

{
    PCALLBACKDATA cur;
    BOOL rc;

    cur = FunctionList;

    while (cur) {

        MYASSERT (!g_CurrentGroup);
        g_CurrentGroup = cur->Group;

        rc = ((PNONENUMERATEDCALLBACK) cur->Function) ();

        if (!rc) {
            DEBUGMSG ((
                DBG_FLOW,
                "Group %s returned an error while calling its NonEnumerated Callback with id %s.",
                g_CurrentGroup,
                cur->Identifier ? cur->Identifier : TEXT("<Unidentified Function>")
                ));
        }

        g_CurrentGroup = NULL;
        cur = cur->Next;
    }

    return TRUE;
}


UINT
EstimateAllObjectEnumerations (
    MIG_PROGRESSSLICEID SliceId,
    BOOL PreEstimate
    )

/*++

Routine Description:

  EstimateAllObjectEnumerations computes a tick estimate for all enumerations
  that have been requested by Data Gather Modules (by calling
  IsmQueueEnumeration).

  The function loops through all known types and for each needed enumeration
  of that type, then calls down to a worker function to call to perform the
  actual enumeration.

Arguments:

  None.

Return Value:

  TRUE if enumerations were completed successfully. FALSE otherwise.

--*/

{
    PTYPEENUMINFO typeEnumInfo;
    MIG_OBJECTTYPEID typeId;
    PENUMDATA enumData;
    UINT ticks = 0;

    if (g_CurrentGroup) {
        DEBUGMSG ((DBG_ERROR, "EstimateAllObjectEnumerations cannot be called during another callback"));
        return 0;
    }

    if (!g_ProgressBarFn) {
        //
        // No need to estimate; no progress bar callback
        //

        return 0;
    }

    //
    // Initialize type data with all known types. Note that we require
    // the type manager to have been initialized before we are.
    //
    typeId = IsmGetFirstObjectTypeId ();

    if (!typeId) {
        DEBUGMSG ((DBG_ERROR, "EstimateAllObjectEnumerations: No known types to enumerate"));
        return 0;
    }

    do {
        if (g_IsmModulePlatformContext == PLATFORM_CURRENT) {
            typeId |= g_IsmCurrentPlatform;
        } else {
            typeId |= g_IsmModulePlatformContext;
        }

        typeEnumInfo = pGetTypeEnumInfo (typeId, FALSE);

        //
        // For each enumeration of this type, call the enumeration worker function
        //
        enumData = typeEnumInfo->FirstEnum;

        while (enumData) {
            if (PreEstimate) {
                ticks ++;
            } else {
                ticks += pEstimateSingleEnumerationTicks (typeEnumInfo, enumData->Pattern);
            }
            if (SliceId) {
                IsmTickProgressBar (SliceId, 1);
            }
            enumData = enumData->Next;
        }

        typeId &= ~(PLATFORM_MASK);

        typeId = IsmGetNextObjectTypeId (typeId);

    } while (typeId != 0);

    return ticks;
}


BOOL
DoAllObjectEnumerations (
    IN      MIG_PROGRESSSLICEID SliceId
    )

/*++

Routine Description:

  DoAllObjectEnumerations is responsible for processing all enumerations that
  have been requested by Data Gather Modules (by calling
  IsmQueueEnumeration).

  The function:
  (1) Calls Pre EnumerationFunctions
  (2) Loops through all known types and for each needed enumeration of that type,
      calls down to a worker function to call to perform the actual enumeration.
  (3) Calls Post Enumeration Functions

Arguments:

  None.

Return Value:

  TRUE if enumerations were completed successfully. FALSE otherwise.

--*/

{
    PTYPEENUMINFO globalTypeEnumInfo;
    PTYPEENUMINFO typeEnumInfo;
    MIG_OBJECTTYPEID typeId;
    PENUMDATA enumData;
    BOOL result = TRUE;


    if (g_CurrentGroup) {
        DEBUGMSG ((DBG_ERROR, "DoAllObjectEnumerations cannot be called during another callback"));
        return FALSE;
    }

    //
    // Call any Pre-ObjectEnumeration functions.
    //
    pCallNonEnumeratedCallbacks (g_PreEnumerationFunctionList);

    //
    // Initialize type data with all known types. Note that we require
    // type type manager to have been initialized before we are.
    //
    typeId = IsmGetFirstObjectTypeId ();

    if (!typeId) {
        DEBUGMSG ((DBG_ERROR, "DoAllObjectEnumerations: No known types to enumerate"));
        return FALSE;
    }

    do {
        if (g_IsmModulePlatformContext == PLATFORM_CURRENT) {
            typeId |= g_IsmCurrentPlatform;
        } else {
            typeId |= g_IsmModulePlatformContext;
        }

        globalTypeEnumInfo = pGetTypeEnumInfo (typeId, TRUE);
        typeEnumInfo = pGetTypeEnumInfo (typeId, FALSE);

        pCallNonEnumeratedCallbacks (typeEnumInfo->PreEnumerationFunctionList);

        //
        // For each enumeration of this type, call the enumeration worker function
        //
        enumData = typeEnumInfo->FirstEnum;

        while (enumData && result) {
            result = pDoSingleEnumeration (
                        globalTypeEnumInfo,
                        typeEnumInfo,
                        enumData->Pattern,
                        TRUE,
                        SliceId
                        );

            enumData = enumData->Next;
        }

        if (result) {
            result = pCallNonEnumeratedCallbacks (typeEnumInfo->PostEnumerationFunctionList);
        }

        typeId &= ~(PLATFORM_MASK);

        typeId = IsmGetNextObjectTypeId (typeId);

    } while ((typeId != 0) && result);

    //
    // Call any Post-ObjectEnumeration functions.
    //
    if (result) {
        result = pCallNonEnumeratedCallbacks (g_PostEnumerationFunctionList);
    }

    return result;
}


VOID
IsmExecuteHooks (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PTYPEENUMINFO globalTypeEnumInfo;
    PTYPEENUMINFO typeEnumInfo;
    PENUMDATA enumData;
    PCTSTR oldCurrentGroup;
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    PCTSTR tempString;
    BOOL result;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    globalTypeEnumInfo = pGetTypeEnumInfo (ObjectTypeId, TRUE);
    typeEnumInfo = pGetTypeEnumInfo (ObjectTypeId, FALSE);

    if (!globalTypeEnumInfo || !typeEnumInfo) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return;
    }

    enumData = typeEnumInfo->FirstEnum;

    if (!ObsSplitObjectStringEx (ObjectName, &node, &leaf, NULL, TRUE)) {
        DEBUGMSG ((DBG_ERROR, "Bad encoded object detected in IsmExecuteHooks: %s", ObjectName));
        return;
    }

    while (enumData) {
        result = TestParsedPattern (enumData->NodeParsedPattern, node);

        if (!result) {
            //
            // let's try one more time with a wack at the end
            //
            tempString = JoinText (node, TEXT("\\"));
            result = TestParsedPattern (enumData->NodeParsedPattern, tempString);
            FreeText (tempString);
        }

        if (result && leaf) {
            if (!enumData->LeafParsedPattern) {
                result = FALSE;
            } else {
                result = TestParsedPattern (enumData->LeafParsedPattern, leaf);
                if (!result &&
                    ((ObjectTypeId & (~PLATFORM_MASK)) == MIG_FILE_TYPE) &&
                    (_tcschr (leaf, TEXT('.')) == NULL)
                    ) {
                    // let's try one more thing
                    tempString = JoinText (leaf, TEXT("."));
                    result = TestParsedPattern (enumData->LeafParsedPattern, tempString);
                    FreeText (tempString);
                }
            }
        }

        if (result) {
            DEBUGMSG ((DBG_FLOW, "IsmExecuteHooks request for an object that was or will be enumerated: %s", ObjectName));
            break;
        }
        enumData = enumData->Next;
    }
    ObsFree (node);
    ObsFree (leaf);

    oldCurrentGroup = g_CurrentGroup;
    g_CurrentGroup = NULL;

    pDoSingleEnumeration (globalTypeEnumInfo, typeEnumInfo, ObjectName, FALSE, 0);

    g_CurrentGroup = oldCurrentGroup;

    SetLastError (ERROR_SUCCESS);
}

BOOL
InitializeFlowControl (
    VOID
    )

/*++

Routine Description:

  InitializeFlowControl is called to ready the flow control unit for work.
  This function takes care of initialization of basic resources needed by the
  flow control unit.

  Flow control is dependent upon the type manager module and can only be
  initialized after type manager intialization is completed.

Arguments:

  None.

Return Value:

  TRUE if flow control was able to successfully initialize, FALSE otherwise.

--*/
{
    g_GlobalQueuePool = PmCreateNamedPool ("Global Queue Pool");
    g_UntrackedFlowPool = PmCreatePool();
    PmDisableTracking (g_UntrackedFlowPool);
    g_CurrentQueuePool = PmCreateNamedPoolEx ("Current Queue Pool", 32768);

    return TRUE;
}


VOID
pAddTypeToEnumerationEnvironment (
    IN      PMHANDLE Pool,
    IN      PGROWLIST *TypeData,
    IN      MIG_OBJECTTYPEID TypeId
    )
{
    TYPEENUMINFO data;

    ZeroMemory (&data, sizeof (TYPEENUMINFO));
    data.ObjectTypeId = TypeId | g_IsmModulePlatformContext;
    data.TypeName = PmDuplicateString (Pool, GetObjectTypeName (TypeId));

    GlAppend (*TypeData, (PBYTE) &data, sizeof (TYPEENUMINFO));
}


VOID
AddTypeToGlobalEnumerationEnvironment (
    IN      MIG_OBJECTTYPEID TypeId
    )
{
    pAddTypeToEnumerationEnvironment (g_GlobalQueuePool, &g_GlobalTypeData, TypeId);
}


BOOL
PrepareEnumerationEnvironment (
    BOOL GlobalEnv
    )
{
    MIG_OBJECTTYPEID typeId;
    PGROWLIST *typeData;
    PMHANDLE pool;

    if (GlobalEnv) {
        typeData = &g_GlobalTypeData;
        pool = g_GlobalQueuePool;
    } else {
        typeData = &g_TypeData;
        pool = g_CurrentQueuePool;
    }

    *typeData = (PGROWLIST) PmGetMemory (pool, sizeof (GROWLIST));
    ZeroMemory (*typeData, sizeof (GROWLIST));

    //
    // Initialize type data with all known types. For global types, we expect
    // this list to be empty.
    //
    typeId = IsmGetFirstObjectTypeId ();

    while (typeId) {

        pAddTypeToEnumerationEnvironment (pool, typeData, typeId);
        typeId = IsmGetNextObjectTypeId (typeId);

    }

    return TRUE;
}

BOOL
ClearEnumerationEnvironment (
    IN      BOOL GlobalData
    )
{
    PGROWLIST *typeData;

    if (GlobalData) {
        typeData = &g_GlobalTypeData;
    } else {
        typeData = &g_TypeData;
    }

    if (*typeData) {
        //
        // Clean up the grow lists, but forget about the rest because
        // it all was allocated from the queue pool
        //

        GlFree (*typeData);
        *typeData = NULL;
    }

    g_PreEnumerationFunctionList = NULL;
    g_PostEnumerationFunctionList = NULL;

    if (GlobalData) {
        PmEmptyPool (g_GlobalQueuePool);
    } else {
        PmEmptyPool (g_CurrentQueuePool);
    }

    return TRUE;
}

VOID
TerminateFlowControl (
    VOID
    )

/*++

Routine Description:

  TerminateFlowControl should be called when flow control services are no
  longer needed. This function ensures that flow control resources are freed.

Arguments:

  None.

Return Value:

  None.

--*/

{
    GbFree (&g_EnumerationList);

    PmEmptyPool (g_CurrentQueuePool);
    PmDestroyPool (g_CurrentQueuePool);
    g_CurrentQueuePool = NULL;

    PmEmptyPool (g_GlobalQueuePool);
    PmDestroyPool (g_GlobalQueuePool);
    g_GlobalQueuePool = NULL;

    PmEmptyPool (g_UntrackedFlowPool);
    PmDestroyPool (g_UntrackedFlowPool);
    g_UntrackedFlowPool = NULL;

    GlFree (&g_AcquireList);
    GlFree (&g_EnumList);
    GlFree (&g_EnumAddList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\regtype.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    regtype.c

Abstract:

    Implements all callbacks for registry type

Author:

    Calin Negreanu (calinn) 09-Apr-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_REGTYPE        "RegType"

//
// Strings
//

// none

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR TempFile [MAX_PATH];
} REGACQUIREHANDLE, *PREGACQUIREHANDLE;

//
// Globals
//

MIG_OBJECTTYPEID g_RegistryTypeId = 0;
GROWBUFFER g_RegConversionBuff = INIT_GROWBUFFER;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstPhysicalRegistry;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextPhysicalRegistry;
TYPE_ABORTENUMCURRENTPHYSICALNODE AbortEnumCurrentKey;
TYPE_ABORTENUMPHYSICALOBJECT AbortEnumPhysicalRegistry;
TYPE_CONVERTOBJECTTOMULTISZ ConvertRegistryToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToRegistry;
TYPE_GETNATIVEOBJECTNAME GetNativeRegistryName;
TYPE_ACQUIREPHYSICALOBJECT AcquirePhysicalRegistry;
TYPE_RELEASEPHYSICALOBJECT ReleasePhysicalRegistry;
TYPE_DOESPHYSICALOBJECTEXIST DoesPhysicalRegistryExist;
TYPE_REMOVEPHYSICALOBJECT RemovePhysicalRegistry;
TYPE_CREATEPHYSICALOBJECT CreatePhysicalRegistry;
TYPE_REPLACEPHYSICALOBJECT ReplacePhysicalRegistry;
TYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertRegContentToUnicode;
TYPE_CONVERTOBJECTCONTENTTOANSI ConvertRegContentToAnsi;
TYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedRegContent;

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pRegTypeEnumWorker (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PREGTREE_ENUM handle;

    handle = (PREGTREE_ENUM) EnumPtr->EtmHandle;

    EnumPtr->ObjectName = handle->EncodedFullName;
    EnumPtr->NativeObjectName = handle->NativeFullName;
    EnumPtr->Level = handle->CurrentLevel;
    EnumPtr->SubLevel = handle->CurrentLevel - handle->RegEnumInfo.RootLevel;
    EnumPtr->IsNode = ((handle->Attributes & REG_ATTRIBUTE_KEY) != 0);
    EnumPtr->IsLeaf = !EnumPtr->IsNode;
    if (EnumPtr->IsNode) {
        EnumPtr->ObjectNode = EnumPtr->NativeObjectName;
        EnumPtr->ObjectLeaf = NULL;
    } else {
        EnumPtr->ObjectNode = handle->Location;
        EnumPtr->ObjectLeaf = handle->Name;
    }
    MYASSERT ((EnumPtr->ObjectTypeId & ~PLATFORM_MASK) == g_RegistryTypeId);
    EnumPtr->Details.DetailsData = &handle->CurrentValueType;

    return TRUE;
}

BOOL
EnumFirstPhysicalRegistry (
    PMIG_TYPEOBJECTENUM EnumPtr,            CALLER_INITIALIZED
    MIG_OBJECTSTRINGHANDLE Pattern,
    UINT MaxLevel
    )
{
    PREGTREE_ENUM handle;
    BOOL result;

    if (!Pattern) {
        return FALSE;
    }

    handle = (PREGTREE_ENUM) IsmGetMemory (sizeof (REGTREE_ENUM));
    EnumPtr->EtmHandle = (LONG_PTR) handle;

    EnumPtr->Details.DetailsSize = sizeof (DWORD);

    result = EnumFirstRegObjectInTreeEx (
                handle,
                Pattern,
                TRUE,
                TRUE,
                TRUE,
                TRUE,
                MaxLevel == NODE_LEVEL_MAX ? REGENUM_ALL_SUBLEVELS : MaxLevel,
                FALSE,
                FALSE,
                RegEnumDefaultCallback
                );

    if (result) {
        result = pRegTypeEnumWorker (EnumPtr);
    } else {
        AbortEnumPhysicalRegistry (EnumPtr);
    }

    return result;
}

BOOL
EnumNextPhysicalRegistry (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PREGTREE_ENUM handle;
    BOOL result;

    handle = (PREGTREE_ENUM) EnumPtr->EtmHandle;

    result = EnumNextRegObjectInTree (handle);

    if (result) {
        result = pRegTypeEnumWorker (EnumPtr);
    } else {
        AbortEnumPhysicalRegistry (EnumPtr);
    }

    return result;
}

VOID
AbortEnumCurrentKey (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PREGTREE_ENUM handle;

    handle = (PREGTREE_ENUM) EnumPtr->EtmHandle;

    if (handle) {
        handle->ControlFlags |= RECF_SKIPSUBKEYS|RECF_SKIPVALUES;
    }
}

VOID
AbortEnumPhysicalRegistry (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PREGTREE_ENUM handle;

    handle = (PREGTREE_ENUM) EnumPtr->EtmHandle;

    if (handle) {
        AbortRegObjectInTreeEnum (handle);
        IsmReleaseMemory (handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}

PVOID
pIsmAlloc (
    IN      DWORD Size
    )
{
    return IsmGetMemory (Size);
}

VOID
pIsmDealloc (
    IN      PCVOID Mem
    )
{
    IsmReleaseMemory (Mem);
}

BOOL
AcquirePhysicalRegistry (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PREGACQUIREHANDLE handle;
    REGSAM prevMode;
    PDWORD dataType;
    DWORD contentSize;
    HANDLE fileHandle;
    PCBYTE content;
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    HKEY keyHandle = NULL;
    BOOL result = FALSE;

    handle = IsmGetMemory (sizeof (REGACQUIREHANDLE));
    ZeroMemory (handle, sizeof (REGACQUIREHANDLE));
    ObjectContent->EtmHandle = handle;

    dataType = IsmGetMemory (sizeof (DWORD));
    ZeroMemory (dataType, sizeof (DWORD));
    ObjectContent->Details.DetailsSize = sizeof (DWORD);
    ObjectContent->Details.DetailsData = dataType;

    ObsSplitObjectString (ObjectName, &node, &leaf);

    if (leaf) {

        prevMode = SetRegOpenAccessMode (KEY_READ);

        keyHandle = OpenRegKeyStr (node);

        SetRegOpenAccessMode (prevMode);

        if (keyHandle) {

            if (GetRegValueTypeAndSize (
                    keyHandle,
                    leaf,
                    dataType,
                    &contentSize
                    )) {

                switch (ContentType) {
                    case CONTENTTYPE_DETAILS_ONLY:
                        MYASSERT (ObjectContent->ContentInFile == FALSE);
                        result = TRUE;
                        break;

                    case CONTENTTYPE_MEMORY:
                    case CONTENTTYPE_ANY:
                        if (contentSize) {
                            if (!MemoryContentLimit || MemoryContentLimit >= contentSize) {
                                MYASSERT (ObjectContent->ContentInFile == FALSE);
                                ObjectContent->MemoryContent.ContentBytes = (PCBYTE) GetRegValueDataOfType2 (
                                                                                keyHandle,
                                                                                leaf,
                                                                                *dataType,
                                                                                pIsmAlloc,
                                                                                pIsmDealloc
                                                                                );
                                if (ObjectContent->MemoryContent.ContentBytes) {
                                    ObjectContent->MemoryContent.ContentSize = contentSize;
                                    result = TRUE;
                                }
                            }
                        } else {
                            result = TRUE;
                        }
                        break;
                    case CONTENTTYPE_FILE:
                        if (contentSize) {
                            BfGetTempFileName (handle->TempFile, ARRAYSIZE(handle->TempFile));
                            fileHandle = BfCreateFile (handle->TempFile);

                            if (fileHandle) {
                                content = (PCBYTE) GetRegValueDataOfType2 (
                                                        keyHandle,
                                                        leaf,
                                                        *dataType,
                                                        pIsmAlloc,
                                                        pIsmDealloc
                                                        );
                                if (content) {
                                    if (BfWriteFile (fileHandle, content, contentSize)) {
                                        ObjectContent->ContentInFile = TRUE;
                                        ObjectContent->FileContent.ContentPath = PmDuplicateString (g_IsmPool, handle->TempFile);
                                        ObjectContent->FileContent.ContentSize = contentSize;
                                        result = TRUE;
                                    }
                                    IsmReleaseMemory (content);
                                }
                                CloseHandle (fileHandle);
                            }
                        } else {
                            result = TRUE;
                        }
                        break;
                    default:
                        DEBUGMSG ((DBG_WHOOPS, "Illegal ContentType in IsmAcquireObject: %d", ContentType));
                }
            }

            CloseRegKey (keyHandle);
        }
    } else {

        prevMode = SetRegOpenAccessMode (KEY_READ);

        keyHandle = OpenRegKeyStr (node);

        SetRegOpenAccessMode (prevMode);

        if (keyHandle) {
            switch (ContentType) {
                case CONTENTTYPE_MEMORY:
                case CONTENTTYPE_ANY:
                case CONTENTTYPE_DETAILS_ONLY:
                    ObjectContent->ContentInFile = FALSE;
                    result = TRUE;
                    break;
                case CONTENTTYPE_FILE:
                    ObjectContent->ContentInFile = TRUE;
                    result = TRUE;
                    break;
                default:
                    DEBUGMSG ((DBG_WHOOPS, "Illegal ContentType in IsmAcquireObject: %d", ContentType));
            }
            CloseRegKey (keyHandle);
        }
    }

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    if (!result) {
        IsmReleaseMemory (dataType);
        dataType = NULL;
        IsmReleaseMemory (handle);
        handle = NULL;
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }
    return result;
}

PCTSTR
ConvertRegistryToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node, leaf;
    DWORD size;
    PTSTR result = NULL;
    BOOL bresult = TRUE;
    TCHAR buff[3];
    PCTSTR quotedString;
    MULTISZ_ENUM multiSzEnum;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        g_RegConversionBuff.End = 0;

        GbCopyQuotedString (&g_RegConversionBuff, node);
        if (leaf) {
            GbCopyQuotedString (&g_RegConversionBuff, leaf);
        }

        if (leaf) {
            // this is actually a value name
            MYASSERT (ObjectContent->Details.DetailsSize == sizeof (DWORD));

            if ((ObjectContent->Details.DetailsSize == sizeof (DWORD)) &&
                (ObjectContent->Details.DetailsData)
                ) {

                // let's save the details
                wsprintf (
                    (PTSTR) GbGrow (&g_RegConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                    TEXT("0x%08X"),
                    *((PDWORD)ObjectContent->Details.DetailsData)
                    );

                if ((!ObjectContent->ContentInFile) &&
                    (ObjectContent->MemoryContent.ContentSize) &&
                    (ObjectContent->MemoryContent.ContentBytes)
                    ) {

                    // let's save the content
                    switch (*((PDWORD)ObjectContent->Details.DetailsData)) {
                    case REG_SZ:
                    case REG_EXPAND_SZ:
                        quotedString = StringSearchAndReplace (
                                            (PCTSTR)ObjectContent->MemoryContent.ContentBytes,
                                            TEXT("\""),
                                            TEXT("\"\""));
                        if (quotedString) {
                            GbCopyQuotedString (&g_RegConversionBuff, quotedString);
                            FreePathString (quotedString);
                        } else {
                            GbCopyQuotedString (&g_RegConversionBuff, (PCTSTR)ObjectContent->MemoryContent.ContentBytes);
                        }
                        break;
                    case REG_MULTI_SZ:
                        if (EnumFirstMultiSz (&multiSzEnum, (PCTSTR)ObjectContent->MemoryContent.ContentBytes)) {
                            do {
                                quotedString = StringSearchAndReplace (
                                                    multiSzEnum.CurrentString,
                                                    TEXT("\""),
                                                    TEXT("\"\""));
                                if (quotedString) {
                                    GbCopyQuotedString (&g_RegConversionBuff, quotedString);
                                    FreePathString (quotedString);
                                } else {
                                    GbCopyQuotedString (&g_RegConversionBuff, multiSzEnum.CurrentString);
                                }
                            } while (EnumNextMultiSz (&multiSzEnum));
                        }
                        break;
                    case REG_DWORD:
                    case REG_DWORD_BIG_ENDIAN:
                        wsprintf (
                            (PTSTR) GbGrow (&g_RegConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                            TEXT("0x%08X"),
                            *((PDWORD)ObjectContent->MemoryContent.ContentBytes)
                            );
                        break;
                    default:
                        // write it in binary format
                        size = 0;
                        while (size < ObjectContent->MemoryContent.ContentSize) {
                            wsprintf (
                                buff,
                                TEXT("%02X"),
                                ObjectContent->MemoryContent.ContentBytes [size]
                                );
                            GbCopyString (&g_RegConversionBuff, buff);
                            size ++;
                        }
                        break;
                    }
                }
            } else {
                bresult = FALSE;
            }
        }

        if (bresult) {
            GbCopyString (&g_RegConversionBuff, TEXT(""));
            result = IsmGetMemory (g_RegConversionBuff.End);
            CopyMemory (result, g_RegConversionBuff.Buf, g_RegConversionBuff.End);
        }

        g_RegConversionBuff.End = 0;

        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    return result;
}

BOOL
ConvertMultiSzToRegistry (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    )
{
#define indexNode   0
#define indexLeaf   1
#define indexType   2
#define indexData   3
    MULTISZ_ENUM multiSzEnum;
    PCTSTR node = NULL, leaf = NULL;
    DWORD type = REG_NONE;
    DWORD dummy;
    UINT index;

    g_RegConversionBuff.End = 0;

    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }

    if (EnumFirstMultiSz (&multiSzEnum, ObjectMultiSz)) {
        index = 0;
        do {
            if (index == indexNode) {
                node = multiSzEnum.CurrentString;
            }
            if (index == indexLeaf) {
                leaf = multiSzEnum.CurrentString;
                if (StringIMatch (leaf, TEXT("<empty>"))) {
                    leaf = TEXT("");
                }
            }
            if (index == indexType) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &type);
            }
            if (index >= indexData) {
                switch (type) {
                case REG_SZ:
                case REG_EXPAND_SZ:
                    if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                        GbCopyString (&g_RegConversionBuff, multiSzEnum.CurrentString);
                    } else {
                        GbCopyString (&g_RegConversionBuff, TEXT(""));
                    }
                    break;
                case REG_MULTI_SZ:
                    if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                        GbCopyString (&g_RegConversionBuff, multiSzEnum.CurrentString);
                    } else {
                        GbCopyString (&g_RegConversionBuff, TEXT(""));
                    }
                    break;
                case REG_DWORD:
                case REG_DWORD_BIG_ENDIAN:
                    _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                    *((PDWORD)GbGrow (&g_RegConversionBuff, sizeof (DWORD))) = dummy;
                    break;
                default:
                    _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                    *((PBYTE)GbGrow (&g_RegConversionBuff, sizeof (BYTE))) = (BYTE)dummy;
                    break;
                }
            }
            index ++;
        } while (EnumNextMultiSz (&multiSzEnum));
    }

    if (type == REG_MULTI_SZ) {
        GbCopyString (&g_RegConversionBuff, TEXT(""));
    }

    if (!node) {
        return FALSE;
    }

    if (ObjectContent) {

        ObjectContent->ObjectTypeId = MIG_REGISTRY_TYPE;

        ObjectContent->ContentInFile = FALSE;
        ObjectContent->MemoryContent.ContentSize = g_RegConversionBuff.End;
        if (ObjectContent->MemoryContent.ContentSize) {
            ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            CopyMemory (
                (PBYTE)ObjectContent->MemoryContent.ContentBytes,
                g_RegConversionBuff.Buf,
                ObjectContent->MemoryContent.ContentSize
                );
            g_RegConversionBuff.End = 0;
        }
        if (leaf) {
            ObjectContent->Details.DetailsSize = sizeof (DWORD);
            ObjectContent->Details.DetailsData = IsmGetMemory (ObjectContent->Details.DetailsSize);
            CopyMemory ((PBYTE)ObjectContent->Details.DetailsData, &type, ObjectContent->Details.DetailsSize);
        }
    }
    *ObjectName = IsmCreateObjectHandle (node, leaf);

    return TRUE;
}

PCTSTR
GetNativeRegistryName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node, leaf, tmp;
    UINT size;
    PTSTR endPtr, result = NULL;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (leaf) {
            tmp = JoinTextEx (NULL, node, leaf, TEXT("\\["), 1, &endPtr);
            if (tmp) {
                StringCopy (endPtr, TEXT("]"));
                size = SizeOfString (tmp);
                if (size) {
                    result = IsmGetMemory (size);
                    if (result) {
                        CopyMemory (result, tmp, size);
                    }
                }
                FreeText (tmp);
            }
        } else {
            size = SizeOfString (node);
            result = IsmGetMemory (size);
            CopyMemory (result, node, size);
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
ReleasePhysicalRegistry (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PREGACQUIREHANDLE handle;
    BOOL result = TRUE;

    handle = (PREGACQUIREHANDLE) ObjectContent->EtmHandle;

    if (handle) {
        if (ObjectContent->ContentInFile) {
            if (ObjectContent->FileContent.ContentPath) {
                IsmReleaseMemory (ObjectContent->FileContent.ContentPath);
                DeleteFile (handle->TempFile);
            }
        } else {
            if (ObjectContent->MemoryContent.ContentBytes) {
                IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
            }
        }
        IsmReleaseMemory (handle);
    }
    if (ObjectContent->Details.DetailsData) {
        IsmReleaseMemory (ObjectContent->Details.DetailsData);
    }
    ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    return result;
}

BOOL
DoesPhysicalRegistryExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    REGSAM prevMode;
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    HKEY keyHandle = NULL;
    DWORD type;
    BOOL result = FALSE;

    ObsSplitObjectString (ObjectName, &node, &leaf);

    if (node) {

        prevMode = SetRegOpenAccessMode (KEY_READ);

        keyHandle = OpenRegKeyStr (node);

        SetRegOpenAccessMode (prevMode);

        if (keyHandle) {
            result = TRUE;
        }
    }

    if (result && leaf) {
        result = GetRegValueTypeAndSize (keyHandle, leaf, &type, NULL);
    }

    if (keyHandle) {
        CloseRegKey (keyHandle);
        keyHandle = NULL;
    }

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    return result;
}

BOOL
RemovePhysicalRegistry (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    REGSAM prevMode;
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    HKEY keyHandle;
    DWORD rc;
    BOOL result = FALSE;

    ObsSplitObjectString (ObjectName, &node, &leaf);

    if (leaf) {

        prevMode = SetRegOpenAccessMode (KEY_WRITE);

        keyHandle = OpenRegKeyStr (node);

        SetRegOpenAccessMode (prevMode);

        if (keyHandle) {

            // record value name deletion
            IsmRecordOperation (
                JRNOP_DELETE,
                g_RegistryTypeId,
                ObjectName
                );

            rc = RegDeleteValue (keyHandle, leaf);
            if (rc == ERROR_SUCCESS) {
                result = TRUE;
            } else {
                SetLastError (rc);
            }
            CloseRegKey (keyHandle);
        }
    } else {
        // we do attempt to remove empty keys.
        // there is no problem in recording an operation that
        // will potentially fail (if the key is not empty).
        IsmRecordOperation (
            JRNOP_DELETE,
            g_RegistryTypeId,
            ObjectName
            );

        prevMode = SetRegOpenAccessMode (KEY_WRITE | KEY_QUERY_VALUE);

        if (node) {
            result = DeleteEmptyRegKeyStr (node);
        }

        SetRegOpenAccessMode (prevMode);
    }

    PushError ();

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    PopError ();

    return result;
}

HKEY
pTrackedCreateRegKeyStr (
    IN      PCTSTR KeyName
    )
{
    REGSAM prevMode;
    MIG_OBJECTSTRINGHANDLE objectName;
    PTSTR keyCopy;
    PTSTR p;
    HKEY keyHandle;
    BOOL result = TRUE;

    keyCopy = DuplicatePathString (KeyName, 0);

    //
    // Advance past key root
    //
    p = _tcschr (keyCopy, TEXT('\\'));
    if (p) {
        p = _tcschr (p + 1, TEXT('\\'));
    }

    //
    // Make all keys along the path
    //

    while (p) {

        *p = 0;

        prevMode = SetRegOpenAccessMode (KEY_WRITE);

        keyHandle = OpenRegKeyStr (keyCopy);

        SetRegOpenAccessMode (prevMode);

        if (!keyHandle) {

            // record key creation
            objectName = IsmCreateObjectHandle (keyCopy, NULL);
            IsmRecordOperation (
                JRNOP_CREATE,
                g_RegistryTypeId,
                objectName
                );
            IsmDestroyObjectHandle (objectName);

            keyHandle = CreateRegKeyStr (keyCopy);
            if (keyHandle) {
                CloseRegKey (keyHandle);
            } else {
                result = FALSE;
            }
            if (!result) {
                break;
            }
        } else {
            CloseRegKey (keyHandle);
        }

        *p = TEXT('\\');
        p = _tcschr (p + 1, TEXT('\\'));
    }

    //
    // At last, make the FullPath directory
    //

    if (result) {

        prevMode = SetRegOpenAccessMode (KEY_WRITE);

        keyHandle = OpenRegKeyStr (keyCopy);

        SetRegOpenAccessMode (prevMode);

        if (!keyHandle) {

            // record key creation
            objectName = IsmCreateObjectHandle (keyCopy, NULL);
            IsmRecordOperation (
                JRNOP_CREATE,
                g_RegistryTypeId,
                objectName
                );
            IsmDestroyObjectHandle (objectName);

            keyHandle = CreateRegKeyStr (keyCopy);
            if (!keyHandle) {
                result = FALSE;
            }
        } else {
            result = FALSE;
            SetLastError (ERROR_ALREADY_EXISTS);
        }
    }

    FreePathString (keyCopy);

    if (result) {
        return keyHandle;
    }

    if (GetLastError() == ERROR_CHILD_MUST_BE_VOLATILE) {
        // NOTE: There is no way to check for volatile keys before attempting
        //       to create them.  Ideally we do not want to migrate volatile
        //       keys, so we will just ignore this error.  It will not be
        //       created, and we'll continue happily.
        SetLastError (ERROR_SUCCESS);
    }

    return NULL;
}

BOOL
CreatePhysicalRegistry (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    REGSAM prevMode;
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    DWORD type;
    PDWORD dataType;
    HKEY keyHandle;
    DWORD rc;
    PCBYTE data = NULL;
    UINT size;
    HANDLE fileHandle = NULL;
    HANDLE mapHandle = NULL;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    dataType = (PDWORD) (ObjectContent->Details.DetailsData);

    ObsSplitObjectString (ObjectName, &node, &leaf);

    if (leaf) {

        prevMode = SetRegOpenAccessMode (KEY_WRITE);

        keyHandle = OpenRegKeyStr (node);

        SetRegOpenAccessMode (prevMode);

        if (!keyHandle) {
            keyHandle = pTrackedCreateRegKeyStr (node);
        }

        if (keyHandle) {

            if (ObjectContent->ContentInFile) {
                data = MapFileIntoMemory (
                            ObjectContent->FileContent.ContentPath,
                            fileHandle,
                            mapHandle
                            );
                size = (UINT) ObjectContent->FileContent.ContentSize;
            } else {
                data = ObjectContent->MemoryContent.ContentBytes;
                size = ObjectContent->MemoryContent.ContentSize;
            }

            if (!GetRegValueTypeAndSize (keyHandle, leaf, &type, NULL)) {

                // record value name creation
                IsmRecordOperation (
                    JRNOP_CREATE,
                    g_RegistryTypeId,
                    ObjectName
                    );

                rc = RegSetValueEx (
                            keyHandle,
                            leaf,
                            0,
                            *dataType,
                            data,
                            size
                            );
                result = (rc == ERROR_SUCCESS);
            } else {
                rc = ERROR_ALREADY_EXISTS;
            }

            if (fileHandle && mapHandle) {
                UnmapFile (
                    data,
                    mapHandle,
                    fileHandle
                    );
            }

            CloseRegKey (keyHandle);

            if (!result) {
                SetLastError (rc);
            }
        }

    } else {

        prevMode = SetRegOpenAccessMode (KEY_WRITE);

        keyHandle = OpenRegKeyStr (node);

        SetRegOpenAccessMode (prevMode);

        if (keyHandle) {

            CloseRegKey (keyHandle);
            SetLastError (ERROR_ALREADY_EXISTS);

        } else {

            keyHandle = pTrackedCreateRegKeyStr (node);

            if (keyHandle) {
                result = TRUE;
                CloseRegKey (keyHandle);
            }
        }
    }

    PushError ();

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    PopError ();

    return result;
}

BOOL
ReplacePhysicalRegistry (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    PDWORD dataType;
    PCBYTE data = NULL;
    HANDLE fileHandle = NULL;
    HANDLE mapHandle = NULL;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    dataType = (PDWORD) (ObjectContent->Details.DetailsData);

    ObsSplitObjectString (ObjectName, &node, &leaf);

    if (leaf) {
        result = TRUE;
        if (DoesPhysicalRegistryExist (ObjectName)) {
            result = RemovePhysicalRegistry (ObjectName);
        }
        if (result) {
            result = CreatePhysicalRegistry (ObjectName, ObjectContent);
        }
    } else {
        if (DoesPhysicalRegistryExist (ObjectName)) {
            result = TRUE;
        } else {
            result = CreatePhysicalRegistry (ObjectName, ObjectContent);
        }
    }

    PushError ();

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    PopError ();

    return result;
}

PMIG_CONTENT
ConvertRegContentToUnicode (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;
    DWORD regType = 0;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    if ((ObjectContent->MemoryContent.ContentSize == 0) ||
        (ObjectContent->MemoryContent.ContentBytes == NULL)
        ) {
        return result;
    }

    if ((ObjectContent->Details.DetailsSize == 0) ||
        (ObjectContent->Details.DetailsSize != sizeof (DWORD)) ||
        (ObjectContent->Details.DetailsData == NULL)
        ) {
        return result;
    }

    regType = *((PDWORD) ObjectContent->Details.DetailsData);

    if ((regType == REG_SZ) ||
        (regType == REG_MULTI_SZ) ||
        (regType == REG_EXPAND_SZ)
        ) {
        result = IsmGetMemory (sizeof (MIG_CONTENT));
        if (result) {
            CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));
            result->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize * 2);
            if (!result->MemoryContent.ContentBytes) {
                IsmReleaseMemory (result);
                result = NULL;
                return result;
            }
            ZeroMemory ((PBYTE)result->MemoryContent.ContentBytes, ObjectContent->MemoryContent.ContentSize * 2);
            DirectDbcsToUnicodeN (
                (PWSTR)result->MemoryContent.ContentBytes,
                (PSTR)ObjectContent->MemoryContent.ContentBytes,
                ObjectContent->MemoryContent.ContentSize
                );
            if ((regType == REG_SZ) ||
                (regType == REG_EXPAND_SZ)
                ) {
                result->MemoryContent.ContentSize = SizeOfStringW ((PWSTR)result->MemoryContent.ContentBytes);
            } else {
                result->MemoryContent.ContentSize = SizeOfMultiSzW ((PWSTR)result->MemoryContent.ContentBytes);
            }
        }
    }

    return result;
}

PMIG_CONTENT
ConvertRegContentToAnsi (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;
    DWORD regType = 0;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    if ((ObjectContent->MemoryContent.ContentSize == 0) ||
        (ObjectContent->MemoryContent.ContentBytes == NULL)
        ) {
        return result;
    }

    if ((ObjectContent->Details.DetailsSize == 0) ||
        (ObjectContent->Details.DetailsSize != sizeof (DWORD)) ||
        (ObjectContent->Details.DetailsData == NULL)
        ) {
        return result;
    }

    regType = *((PDWORD) ObjectContent->Details.DetailsData);

    if ((regType == REG_SZ) ||
        (regType == REG_MULTI_SZ) ||
        (regType == REG_EXPAND_SZ)
        ) {
        result = IsmGetMemory (sizeof (MIG_CONTENT));
        if (result) {
            CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));
            result->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            if (!result->MemoryContent.ContentBytes) {
                IsmReleaseMemory (result);
                result = NULL;
                return result;
            }
            ZeroMemory ((PBYTE)result->MemoryContent.ContentBytes, ObjectContent->MemoryContent.ContentSize);
            DirectUnicodeToDbcsN (
                (PSTR)result->MemoryContent.ContentBytes,
                (PWSTR)ObjectContent->MemoryContent.ContentBytes,
                ObjectContent->MemoryContent.ContentSize
                );
            if ((regType == REG_SZ) ||
                (regType == REG_EXPAND_SZ)
                ) {
                result->MemoryContent.ContentSize = SizeOfStringA ((PSTR)result->MemoryContent.ContentBytes);
            } else {
                result->MemoryContent.ContentSize = SizeOfMultiSzA ((PSTR)result->MemoryContent.ContentBytes);
            }
        }
    }

    return result;
}

BOOL
FreeConvertedRegContent (
    IN      PMIG_CONTENT ObjectContent
    )
{
    if (!ObjectContent) {
        return TRUE;
    }

    if (ObjectContent->MemoryContent.ContentBytes) {
        IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
    }

    IsmReleaseMemory (ObjectContent);

    return TRUE;
}

VOID
InitRegistryType (
    VOID
    )
{
    TYPE_REGISTER regTypeData;

    ZeroMemory (&regTypeData, sizeof (TYPE_REGISTER));

    regTypeData.EnumFirstPhysicalObject = EnumFirstPhysicalRegistry;
    regTypeData.EnumNextPhysicalObject = EnumNextPhysicalRegistry;
    regTypeData.AbortEnumCurrentPhysicalNode = AbortEnumCurrentKey;
    regTypeData.AbortEnumPhysicalObject = AbortEnumPhysicalRegistry;
    regTypeData.ConvertObjectToMultiSz = ConvertRegistryToMultiSz;
    regTypeData.ConvertMultiSzToObject = ConvertMultiSzToRegistry;
    regTypeData.GetNativeObjectName = GetNativeRegistryName;
    regTypeData.AcquirePhysicalObject = AcquirePhysicalRegistry;
    regTypeData.ReleasePhysicalObject = ReleasePhysicalRegistry;
    regTypeData.DoesPhysicalObjectExist = DoesPhysicalRegistryExist;
    regTypeData.RemovePhysicalObject = RemovePhysicalRegistry;
    regTypeData.CreatePhysicalObject = CreatePhysicalRegistry;
    regTypeData.ReplacePhysicalObject = ReplacePhysicalRegistry;
    regTypeData.ConvertObjectContentToUnicode = ConvertRegContentToUnicode;
    regTypeData.ConvertObjectContentToAnsi = ConvertRegContentToAnsi;
    regTypeData.FreeConvertedObjectContent = FreeConvertedRegContent;

    g_RegistryTypeId = IsmRegisterObjectType (
                            S_REGISTRYTYPE,
                            TRUE,
                            FALSE,
                            &regTypeData
                            );
    MYASSERT (g_RegistryTypeId);
}

VOID
DoneRegistryType (
    VOID
    )
{
    GbFree (&g_RegConversionBuff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\property.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    property.c

Abstract:

    Implements the property interface of the ISM. Properties are used to
    associate data with objects.  They are identified by name, and a single
    object can have multiple instances of the same property.

Author:

    Jim Schmidt (jimschm) 01-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_PROPERTY    "Property"

//
// Strings
//

#define S_PROPINST          TEXT("PropInst")
#define S_PROPINST_FORMAT   S_PROPINST TEXT("\\%u")
#define S_PROPERTYFILE      TEXT("|PropertyFile")     // pipe is to decorate for uniqueness

//
// Constants
//

#define PROPERTY_FILE_SIGNATURE         0xF062298F
#define PROPERTY_FILE_VERSION           0x00010000

//
// Macros
//

// None

//
// Types
//

typedef enum {
    PROPENUM_GET_NEXT_LINKAGE,
    PROPENUM_GET_NEXT_INSTANCE,
    PROPENUM_RETURN_VALUE,
    PROPENUM_DONE
} PROPENUM_STATE;

typedef struct {
    MIG_PROPERTYID PropertyId;
    LONGLONG DatFileOffset;
} PROPERTY_DATA_REFERENCE, *PPROPERTY_DATA_REFERENCE;

#pragma pack(push,1)

typedef struct {
    DWORD Size;
    WORD PropertyDataType;
    // data follows in the file
} PROPERTY_ITEM_HEADER, *PPROPERTY_ITEM_HEADER;

typedef struct {
    DWORD Signature;
    DWORD Version;
} PROPERTY_FILE_HEADER, *PPROPERTY_FILE_HEADER;

#pragma pack(pop)

typedef struct {

    MIG_PROPERTYID FilterPropertyId;

    MIG_OBJECTID ObjectId;

    PUINT LinkageList;
    UINT LinkageCount;
    UINT LinkageEnumPosition;

    PPROPERTY_DATA_REFERENCE InstanceArray;
    UINT InstanceCount;
    UINT InstancePosition;

    PROPENUM_STATE State;

} OBJECTPROPERTY_HANDLE, *POBJECTPROPERTY_HANDLE;

typedef struct {

    MIG_PROPERTYID PropertyId;

    PUINT LinkageList;
    UINT LinkageCount;
    UINT LinkagePos;

    ENCODEDSTRHANDLE ObjectPath;

} OBJECTWITHPROPERTY_HANDLE, *POBJECTWITHPROPERTY_HANDLE;

typedef struct {
    MIG_OBJECTID ObjectId;
    PCMIG_BLOB Property;
    LONGLONG PreExistingProperty;
} ADDPROPERTYARG, *PADDPROPERTYARG;

//
// Globals
//

PCTSTR g_PropertyDatName;
HANDLE g_PropertyDatHandle;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
InitializeProperties (
    MIG_PLATFORMTYPEID Platform,
    BOOL VcmMode
    )
{
    PROPERTY_FILE_HEADER header;
    TCHAR tempFile [MAX_PATH];
    MIG_OBJECTSTRINGHANDLE propertyObjectName;
    MIG_CONTENT propertyContent;

    //
    // In gather mode, create property.dat in a temp dir.
    // In restore mode, get property.dat from the transport, then
    //      open it.
    //

    if (Platform == PLATFORM_SOURCE) {

        IsmGetTempFile (tempFile, ARRAYSIZE (tempFile));
        g_PropertyDatName = DuplicatePathString (tempFile, 0);

        g_PropertyDatHandle = BfCreateFile (g_PropertyDatName);
        if (g_PropertyDatHandle) {
            header.Signature = PROPERTY_FILE_SIGNATURE;
            header.Version   = PROPERTY_FILE_VERSION;

            if (!BfWriteFile (g_PropertyDatHandle, (PBYTE) &header, sizeof (header))) {
                return FALSE;
            }
            propertyObjectName = IsmCreateObjectHandle (S_PROPERTYFILE, NULL);
            DataTypeAddObject (propertyObjectName, g_PropertyDatName, !VcmMode);
            IsmDestroyObjectHandle (propertyObjectName);
        }
    } else {
        propertyObjectName = IsmCreateObjectHandle (S_PROPERTYFILE, NULL);
        if (IsmAcquireObjectEx (MIG_DATA_TYPE | PLATFORM_SOURCE, propertyObjectName, &propertyContent, CONTENTTYPE_FILE, 0)) {

            BfGetTempFileName (tempFile, ARRAYSIZE (tempFile));
            g_PropertyDatName = DuplicatePathString (tempFile, 0);

            if (CopyFile (propertyContent.FileContent.ContentPath, g_PropertyDatName, FALSE)) {
                g_PropertyDatHandle = BfOpenFile (g_PropertyDatName);
            }
            IsmReleaseObject (&propertyContent);
        } else if (IsmAcquireObjectEx (MIG_DATA_TYPE | PLATFORM_DESTINATION, propertyObjectName, &propertyContent, CONTENTTYPE_FILE, 0)) {
            g_PropertyDatName = DuplicatePathString (propertyContent.FileContent.ContentPath, 0);
            g_PropertyDatHandle = BfOpenFile (g_PropertyDatName);
            IsmReleaseObject (&propertyContent);
        }
        IsmDestroyObjectHandle (propertyObjectName);
    }

    return g_PropertyDatHandle != NULL;
}


VOID
TerminateProperties (
    MIG_PLATFORMTYPEID Platform
    )
{
    if (g_PropertyDatHandle) {
        CloseHandle (g_PropertyDatHandle);
        g_PropertyDatHandle = NULL;
    }
    if (g_PropertyDatName) {
        if (Platform == PLATFORM_DESTINATION) {
            DeleteFile (g_PropertyDatName);
        }
        FreePathString (g_PropertyDatName);
        g_PropertyDatName = NULL;
    }
}


PCTSTR
pGetPropertyNameForDebugMsg (
    IN      MIG_PROPERTYID PropertyId
    )
{
    static TCHAR name[256];

    if (!IsmGetPropertyName (PropertyId, name, ARRAYSIZE(name), NULL, NULL, NULL)) {
        StringCopy (name, TEXT("<invalid property>"));
    }

    return name;
}


PCTSTR
pPropertyPathFromId (
    IN      MIG_PROPERTYID PropertyId
    )
{
    return MemDbGetKeyFromHandle ((UINT) PropertyId, 0);
}


VOID
pPropertyPathFromName (
    IN      PCTSTR PropertyName,
    OUT     PTSTR Path
    )
{
    wsprintf (Path, TEXT("Property\\%s"), PropertyName);
}


LONGLONG
OffsetFromPropertyDataId (
    IN      MIG_PROPERTYDATAID PropertyDataId
    )
{
    PCTSTR p;
    LONGLONG offset;

    p = MemDbGetKeyFromHandle (
            (KEYHANDLE) PropertyDataId,
            MEMDB_LAST_LEVEL
            );

    if (!p) {
        DEBUGMSG ((DBG_ERROR, "Can't get offset from invalid property instance"));
        return 0;
    }

    offset = (LONGLONG) TToU64 (p);

    MemDbReleaseMemory (p);

    return offset;
}


MIG_PROPERTYDATAID
pPropertyDataIdFromOffset (
    IN      LONGLONG DataOffset
    )
{
    TCHAR instanceKey[256];
    KEYHANDLE handle;

    wsprintf (instanceKey, S_PROPINST_FORMAT, DataOffset);

    handle = MemDbGetHandleFromKey (instanceKey);

    if (!handle) {
        return 0;
    }

    return (MIG_PROPERTYDATAID) handle;
}


#if 0

//
// This function is not valid because the assumption it was initially
// implemented with has changed.  It used to be that a property instance
// was associated with a specific property id.  Now the instance is
// just the data, which can be associated with any property!
//

MIG_PROPERTYID
pPropertyIdFromInstance (
    IN      MIG_PROPERTYDATAID PropertyDataId
    )
{
    MIG_PROPERTYID result = 0;
    KEYHANDLE *linkage;
    UINT count;
    PPROPERTY_DATA_REFERENCE dataRef = NULL;
    UINT dataRefSize;
    UINT u;
    LONGLONG offset;

    linkage = (KEYHANDLE *) MemDbGetSingleLinkageArrayByKeyHandle (
                                PropertyDataId,
                                PROPERTY_INDEX,
                                &count
                                );

    count /= sizeof (KEYHANDLE);

    __try {

        if (!linkage || !count) {
            __leave;
        }

        offset = OffsetFromPropertyDataId (PropertyData);
        if (!offset) {
            __leave;
        }

        dataRef = (PPROPERTY_DATA_REFERENCE) MemDbGetUnorderedBlobByKeyHandle (
                                                    (MIG_OBJECTID) linkage[0],
                                                    PROPERTY_INDEX,
                                                    &dataRefSize
                                                    );

        dataRefSize /= sizeof (PROPERTY_DATA_REFERENCE);

        if (!dataRef || !dataRefSize) {
            __leave;
        }

        for (u = 0 ; u < dataRefSize ; u++) {
            if (dataRef[u].DatFileOffset == offset) {
                result = dataRef[u].PropertyId;
                break;
            }
        }
    }
    __finally {
        MemDbReleaseMemory (linkage);
        INVALID_POINTER (linkage);

        MemDbReleaseMemory (dataRef);
        INVALID_POINTER (dataRef);
    }

    return result;
}

#endif

MIG_PROPERTYID
IsmRegisterProperty (
    IN      PCTSTR Name,
    IN      BOOL Private
    )

/*++

Routine Description:

  IsmRegisterProperty creates a public or private property and returns the
  ID to the caller. If the property already exists, then the existing ID is
  returned to the caller.

Arguments:

  Name    - Specifies the property name to register.
  Private - Specifies TRUE if the property is owned by the calling module
            only, or FALSE if it is shared by all modules. If TRUE is
            specified, the caller must be in an ISM callback function.

Return Value:

  The ID of the property, or 0 if the registration failed.

--*/

{
    TCHAR propertyPath[MEMDB_MAX];
    TCHAR decoratedName[MEMDB_MAX];
    UINT offset;

    if (!g_CurrentGroup && Private) {
        DEBUGMSG ((DBG_ERROR, "IsmRegisterProperty called for private property outside of ISM-managed context"));
        return 0;
    }

    if (!IsValidCNameWithDots (Name)) {
        DEBUGMSG ((DBG_ERROR, "property name \"%s\" is illegal", Name));
        return FALSE;
    }

#ifdef DEBUG
    if (Private && !IsValidCName (g_CurrentGroup)) {
        DEBUGMSG ((DBG_ERROR, "group name \"%s\" is illegal", g_CurrentGroup));
        return FALSE;
    }
#endif

    if (Private) {
        wsprintf (decoratedName, TEXT("%s:%s"), g_CurrentGroup, Name);
    } else {
        wsprintf (decoratedName, S_COMMON TEXT(":%s"), Name);
    }

    pPropertyPathFromName (decoratedName, propertyPath);

    if (!MarkGroupIds (propertyPath)) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s conflicts with previously registered property",
            propertyPath
            ));
        return FALSE;
    }

    offset = MemDbSetKey (propertyPath);

    if (!offset) {
        EngineError ();
        return 0;
    }

    MYASSERT (offset);

    return (MIG_PROPERTYID) offset;
}


BOOL
IsmGetPropertyName (
    IN      MIG_PROPERTYID PropertyId,
    OUT     PTSTR PropertyName,             OPTIONAL
    IN      UINT PropertyNameBufChars,
    OUT     PBOOL Private,                  OPTIONAL
    OUT     PBOOL BelongsToMe,              OPTIONAL
    OUT     PUINT ObjectReferences          OPTIONAL
    )

/*++

Routine Description:

  IsmGetPropertyName obtains the property text name from a numeric ID. It
  also identifies private and owned properties.

Arguments:

  PropertyId            - Specifies the property ID to look up.
  PropertyName          - Receives the property name. The name is filled for
                          all valid PropertyId values, even when the return
                          value is FALSE.
  PropertyNameBufChars  - Specifies the number of TCHARs that PropertyName
                          can hold, including the nul terminator.
  Private               - Receives TRUE if the property is private, or FALSE
                          if it is public.
  BelongsToMe           - Receives TRUE if the property is private and
                          belongs to the caller, FALSE otherwise.
  ObjectReferences      - Receives the number of objects that reference the
                          property

Return Value:

  TRUE if the property is public, or if the property is private and belongs to
  the caller.

  FALSE if the property is private and belongs to someone else. PropertyName,
  Private and BelongsToMe are valid in this case.

  FALSE if PropertyId is not valid. Propertyname, Private and BelongsToMe are
  not modified in this case.  Do not use this function to test if PropertyId
  is valid or not.

--*/


{
    PCTSTR propertyPath = NULL;
    PCTSTR start;
    PTSTR p, q;
    BOOL privateProperty = FALSE;
    BOOL groupMatch = FALSE;
    BOOL result = FALSE;
    UINT references;
    PUINT linkageList;

    __try {
        //
        // Get the property path from memdb, then parse it for group and name
        //

        propertyPath = pPropertyPathFromId (PropertyId);
        if (!propertyPath) {
            __leave;
        }

        p = _tcschr (propertyPath, TEXT('\\'));
        if (!p) {
            __leave;
        }

        start = _tcsinc (p);
        p = _tcschr (start, TEXT(':'));

        if (!p) {
            __leave;
        }

        q = _tcsinc (p);
        *p = 0;

        if (StringIMatch (start, S_COMMON)) {

            //
            // This property is a global property.
            //

            groupMatch = TRUE;

        } else if (g_CurrentGroup) {

            //
            // This property is private. Check if it is ours.
            //

            privateProperty = TRUE;
            groupMatch = StringIMatch (start, g_CurrentGroup);

        } else {

            //
            // This is a private property, but the caller is not
            // a module that can own properties.
            //

            DEBUGMSG ((DBG_WARNING, "IsmGetPropertyName: Caller cannot own private properties"));
        }

        //
        // Copy the name to the buffer, update outbound BOOLs, set result
        //

        if (PropertyName && PropertyNameBufChars >= sizeof (TCHAR)) {
            StringCopyByteCount (PropertyName, q, PropertyNameBufChars * sizeof (TCHAR));
        }

        if (Private) {
            *Private = privateProperty;
        }

        if (ObjectReferences) {
            linkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                PropertyId,
                                PROPERTY_INDEX,
                                &references
                                );

            references /= SIZEOF(KEYHANDLE);

            if (linkageList) {
                MemDbReleaseMemory (linkageList);
                INVALID_POINTER (linkageList);
            } else {
                references = 0;
            }

            *ObjectReferences = references;
        }

        if (BelongsToMe) {
            *BelongsToMe = privateProperty && groupMatch;
        }

        result = groupMatch;
    }
    __finally {
        if (propertyPath) {       //lint !e774
            MemDbReleaseMemory (propertyPath);
            INVALID_POINTER (propertyPath);
        }
    }

    return result;
}


MIG_PROPERTYID
IsmGetPropertyGroup (
    IN      MIG_PROPERTYID PropertyId
    )
{
    return (MIG_PROPERTYID) GetGroupOfId ((KEYHANDLE) PropertyId);
}


LONGLONG
AppendProperty (
    PCMIG_BLOB Property
    )
{
    LONGLONG offset;
    PROPERTY_ITEM_HEADER item;
#ifndef UNICODE
    PCWSTR convStr = NULL;
#endif
    PCBYTE data = NULL;

    if (!g_PropertyDatHandle) {
        MYASSERT (FALSE);
        return 0;
    }

    if (!BfGoToEndOfFile (g_PropertyDatHandle, &offset)) {
        DEBUGMSG ((DBG_ERROR, "Can't seek to end of property.dat"));
        return 0;
    }

    __try {
        switch (Property->Type) {

        case BLOBTYPE_STRING:
#ifndef UNICODE
            convStr = ConvertAtoW (Property->String);
            if (convStr) {
                item.Size = (DWORD) SizeOfStringW (convStr);
                data = (PCBYTE) convStr;
            } else {
                DEBUGMSG ((DBG_ERROR, "Error writing to property.dat"));
                offset = 0;
                __leave;
            }
#else
            item.Size = (DWORD) SizeOfString (Property->String);
            data = (PCBYTE) Property->String;
#endif
            break;

        case BLOBTYPE_BINARY:
            item.Size = (DWORD) Property->BinarySize;
            data = Property->BinaryData;
            break;

        default:
            MYASSERT(FALSE);
            offset = 0;
            __leave;
        }

        item.PropertyDataType = (WORD) Property->Type;

        if (!BfWriteFile (g_PropertyDatHandle, (PCBYTE) &item, sizeof (item)) ||
            !BfWriteFile (g_PropertyDatHandle, data, item.Size)
            ) {

            DEBUGMSG ((DBG_ERROR, "Can't write to property.dat"));
            offset = 0;
            __leave;
        }
    }
    __finally {
    }

#ifndef UNICODE
    if (convStr) {
        FreeConvertedStr (convStr);
        convStr = NULL;
    }
#endif

    return offset;
}


MIG_PROPERTYDATAID
IsmRegisterPropertyData (
    IN      PCMIG_BLOB Property
    )
{
    LONGLONG offset;
    TCHAR offsetString[256];
    KEYHANDLE offsetHandle;

    offset = AppendProperty (Property);
    if (!offset) {
        return 0;
    }

    wsprintf (offsetString, S_PROPINST_FORMAT, offset);
    offsetHandle = MemDbSetKey (offsetString);

    if (!offsetHandle) {
        EngineError ();
    }

    return (MIG_PROPERTYDATAID) offsetHandle;
}


BOOL
GetProperty (
    IN      LONGLONG Offset,
    IN OUT  PGROWBUFFER Buffer,                 OPTIONAL
    OUT     PBYTE PreAllocatedBuffer,           OPTIONAL
    OUT     PUINT Size,                         OPTIONAL
    OUT     PMIG_BLOBTYPE PropertyDataType      OPTIONAL
    )
{
    PBYTE data;
    PROPERTY_ITEM_HEADER item;
#ifndef UNICODE
    PCSTR ansiStr = NULL;
    DWORD ansiSize = 0;
    PBYTE ansiData = NULL;
#endif

    if (!g_PropertyDatHandle) {
        MYASSERT (FALSE);
        return FALSE;
    }

    if (!BfSetFilePointer (g_PropertyDatHandle, Offset)) {
        DEBUGMSG ((DBG_ERROR, "Can't seek to %I64Xh in property.dat", Offset));
        return FALSE;
    }

    if (!BfReadFile (g_PropertyDatHandle, (PBYTE) &item, sizeof (item))) {
        DEBUGMSG ((DBG_ERROR, "Can't read property item header"));
        return FALSE;
    }

#ifndef UNICODE
    if (item.PropertyDataType == BLOBTYPE_STRING) {
        // we have some work to do
        if (PropertyDataType) {
            *PropertyDataType = (MIG_BLOBTYPE) item.PropertyDataType;
        }
        data = IsmGetMemory (item.Size);
        if (!data) {
            return FALSE;
        }
        ZeroMemory (data, item.Size);
        if (!BfReadFile (g_PropertyDatHandle, data, item.Size)) {
            DEBUGMSG ((DBG_ERROR, "Can't read property item"));
            IsmReleaseMemory (data);
            return FALSE;
        }
        ansiStr = ConvertWtoA ((PCWSTR) data);
        if (!ansiStr) {
            DEBUGMSG ((DBG_ERROR, "Can't read property item"));
            IsmReleaseMemory (data);
            return FALSE;
        }
        ansiSize = SizeOfStringA (ansiStr);
        if (Size) {
            *Size = ansiSize;
        }
        if (Buffer || PreAllocatedBuffer) {

            if (PreAllocatedBuffer) {
                CopyMemory (PreAllocatedBuffer, ansiStr, ansiSize);
            } else {
                ansiData = GbGrow (Buffer, ansiSize);
                if (!ansiData) {
                    DEBUGMSG ((DBG_ERROR, "Can't allocate %u bytes", ansiSize));
                    FreeConvertedStr (ansiStr);
                    IsmReleaseMemory (data);
                    return FALSE;
                }
                CopyMemory (ansiData, ansiStr, ansiSize);
            }
        }
        FreeConvertedStr (ansiStr);
        IsmReleaseMemory (data);
    } else {
#endif
        if (Size) {
            *Size = item.Size;
        }

        if (PropertyDataType) {
            *PropertyDataType = (MIG_BLOBTYPE) item.PropertyDataType;
        }

        if (Buffer || PreAllocatedBuffer) {

            if (PreAllocatedBuffer) {
                data = PreAllocatedBuffer;
            } else {
                data = GbGrow (Buffer, item.Size);

                if (!data) {
                    DEBUGMSG ((DBG_ERROR, "Can't allocate %u bytes", item.Size));
                    return FALSE;
                }
            }

            if (!BfReadFile (g_PropertyDatHandle, data, item.Size)) {
                DEBUGMSG ((DBG_ERROR, "Can't read property item"));
                return FALSE;
            }
        }
#ifndef UNICODE
    }
#endif

    return TRUE;
}


BOOL
CreatePropertyStruct (
    IN OUT  PGROWBUFFER Buffer,
    OUT     PMIG_BLOB PropertyStruct,
    IN      LONGLONG Offset
    )
{
    UINT size;
    MIG_BLOBTYPE type;

    //
    // Obtain property size, data and type
    //

    Buffer->End = 0;

    if (!GetProperty (Offset, Buffer, NULL, &size, &type)) {
        DEBUGMSG ((DBG_ERROR, "Error getting op property instance header from dat file"));
        return FALSE;
    }

    //
    // Fill in the property struct
    //

    PropertyStruct->Type = type;

    switch (type) {

    case BLOBTYPE_STRING:
        PropertyStruct->String = (PCTSTR) Buffer->Buf;
        break;

    case BLOBTYPE_BINARY:
        PropertyStruct->BinaryData = Buffer->Buf;
        PropertyStruct->BinarySize = size;
        break;

    default:
        ZeroMemory (PropertyStruct, sizeof (MIG_BLOB));
        break;

    }

    return TRUE;
}


MIG_PROPERTYDATAID
pAddPropertyToObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId,
    IN      PCMIG_BLOB Property,
    IN      BOOL QueryOnly,
    IN      PLONGLONG PreExistingProperty       OPTIONAL
    )
{
    PROPERTY_DATA_REFERENCE propertyRef;
    MIG_PROPERTYDATAID result = 0;
    GROWBUFFER buffer = INIT_GROWBUFFER;
    TCHAR offsetString[256];
    KEYHANDLE offsetHandle;
    UINT u;
    PPROPERTY_DATA_REFERENCE dataRef;
    UINT dataRefSize;

    __try {
        //
        // Is the property id locked?
        //

        if (TestLock (ObjectId, (KEYHANDLE) PropertyId)) {
            SetLastError (ERROR_LOCKED);
            DEBUGMSG ((
                DBG_WARNING,
                "Can't set property %s on %s because of lock",
                pGetPropertyNameForDebugMsg (PropertyId),
                GetObjectNameForDebugMsg (ObjectId)
                ));
            __leave;
        }

        if (QueryOnly) {
            result = TRUE;
            __leave;
        }

        //
        // Store the property in the dat file
        //

        propertyRef.PropertyId = PropertyId;

        if (PreExistingProperty) {
            propertyRef.DatFileOffset = *PreExistingProperty;
        } else {
            propertyRef.DatFileOffset = AppendProperty (Property);

            if (!propertyRef.DatFileOffset) {
                __leave;
            }

            if (PreExistingProperty) {
                *PreExistingProperty = propertyRef.DatFileOffset;
            }
        }

        //
        // Link the object to the property, and the object to the property
        // instance and data
        //

        if (!MemDbAddDoubleLinkageByKeyHandle (PropertyId, ObjectId, PROPERTY_INDEX)) {
            DEBUGMSG ((DBG_ERROR, "Can't link object to property"));
            EngineError ();
            __leave;
        }


        dataRef = (PPROPERTY_DATA_REFERENCE) MemDbGetUnorderedBlobByKeyHandle (
                                                    ObjectId,
                                                    PROPERTY_INDEX,
                                                    &dataRefSize
                                                    );

        dataRefSize /= sizeof (PROPERTY_DATA_REFERENCE);

        if (dataRef && dataRefSize) {
            //
            // Scan the unorderd blob for a zero property id (means "deleted")
            //

            for (u = 0 ; u < dataRefSize ; u++) {
                if (!dataRef[u].PropertyId) {
                    break;
                }
            }

            //
            // If a zero property id was found, use it and update the array
            //

            if (u < dataRefSize) {
                CopyMemory (&dataRef[u], &propertyRef, sizeof (PROPERTY_DATA_REFERENCE));
            } else {
                MemDbReleaseMemory (dataRef);
                dataRef = NULL;
            }
        }

        if (!dataRef) {
            //
            // If the array was initially empty, or if no deleted space was found,
            // then grow the blob by putting the new property reference at the end
            //

            if (!MemDbGrowUnorderedBlobByKeyHandle (
                    ObjectId,
                    PROPERTY_INDEX,
                    (PBYTE) &propertyRef,
                    sizeof (propertyRef)
                    )) {
                DEBUGMSG ((DBG_ERROR, "Can't link property data to property"));
                __leave;
            }
        } else {
            //
            // If the array was not freed, then it has been updated, and it needs
            // to be saved back to memdb.  Do that, then release the memory.
            //

            if (!MemDbSetUnorderedBlobByKeyHandle (
                    ObjectId,
                    PROPERTY_INDEX,
                    (PBYTE) dataRef,
                    dataRefSize * sizeof (PROPERTY_DATA_REFERENCE)
                    )) {
                DEBUGMSG ((DBG_ERROR, "Can't link property data to property (2)"));
                __leave;
            }

            MemDbReleaseMemory (dataRef);
            INVALID_POINTER (dataRef);
        }


        //
        // Link the offset to the object
        //

        wsprintf (offsetString, S_PROPINST_FORMAT, propertyRef.DatFileOffset);
        offsetHandle = MemDbSetKey (offsetString);

        if (!offsetHandle) {
            EngineError ();
            __leave;
        }

        if (!MemDbAddSingleLinkageByKeyHandle (offsetHandle, ObjectId, PROPERTY_INDEX)) {
            DEBUGMSG ((DBG_ERROR, "Can't link dat file offset to object"));
            EngineError ();
            __leave;
        }

        result = (MIG_PROPERTYDATAID) offsetHandle;

    }
    __finally {
        GbFree (&buffer);
    }

    return result;
}


BOOL
pAddPropertyGroup (
    IN      KEYHANDLE PropertyId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    PADDPROPERTYARG myArg = (PADDPROPERTYARG) Arg;

    MYASSERT (IsItemId (PropertyId));

    return pAddPropertyToObjectId (
                myArg->ObjectId,
                (MIG_PROPERTYID) PropertyId,
                myArg->Property,
                FirstPass,
                &myArg->PreExistingProperty
                );
}


MIG_PROPERTYDATAID
IsmAddPropertyToObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId,
    IN      PCMIG_BLOB Property
    )
{
    RECURSERETURN rc;
    ADDPROPERTYARG myArg;

    //
    // If PropertyId is a group, set all properties in the group
    //

    myArg.ObjectId = ObjectId;
    myArg.Property = Property;
    myArg.PreExistingProperty = 0;

    rc = RecurseForGroupItems (
                PropertyId,
                pAddPropertyGroup,
                (ULONG_PTR) &myArg,
                FALSE,
                FALSE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pAddPropertyToObjectId (ObjectId, PropertyId, Property, FALSE, NULL);
}


MIG_PROPERTYDATAID
IsmAddPropertyToObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID PropertyId,
    IN      PCMIG_BLOB Property
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = GetObjectIdForModification (ObjectTypeId, EncodedObjectName);

    if (objectId) {
        result = IsmAddPropertyToObjectId (objectId, PropertyId, Property);
    }

    return result;
}


BOOL
IsmAddPropertyDataToObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId,
    IN      MIG_PROPERTYDATAID PropertyDataId
    )
{
    LONGLONG offset;
    MIG_PROPERTYDATAID instance;

    offset = OffsetFromPropertyDataId (PropertyDataId);
    if (!offset) {
        DEBUGMSG ((DBG_ERROR, "Invalid property instance passed to IsmAddPropertyDataToObjectId (2)"));
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    instance = pAddPropertyToObjectId (
                    ObjectId,
                    PropertyId,
                    NULL,
                    FALSE,
                    &offset
                    );

    return instance != 0;
}


BOOL
IsmAddPropertyDataToObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID PropertyId,
    IN      MIG_PROPERTYDATAID PropertyDataId
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = GetObjectIdForModification (ObjectTypeId, EncodedObjectName);

    if (objectId) {
        result = IsmAddPropertyDataToObjectId (objectId, PropertyId, PropertyDataId);
    }

    return result;
}


VOID
IsmLockProperty (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId
    )
{
    LockHandle (ObjectId, (KEYHANDLE) PropertyId);
}


BOOL
IsmGetPropertyData (
    IN      MIG_PROPERTYDATAID PropertyDataId,
    OUT     PBYTE Buffer,                               OPTIONAL
    IN      UINT BufferSize,
    OUT     PUINT PropertyDataSize,                     OPTIONAL
    OUT     PMIG_BLOBTYPE PropertyDataType              OPTIONAL
    )
{
    LONGLONG offset;
    UINT size;

    //
    // Convert the property instance to the property.dat offset
    //

    offset = OffsetFromPropertyDataId (PropertyDataId);
    if (!offset) {
        DEBUGMSG ((DBG_ERROR, "Invalid property instance passed to IsmGetPropertyData"));
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Obtain the property data size
    //

    if (!GetProperty (offset, NULL, NULL, &size, PropertyDataType)) {
        DEBUGMSG ((DBG_ERROR, "Error getting property instance header from dat file"));
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (PropertyDataSize) {
        *PropertyDataSize = size;
    }

    //
    // If a buffer was specified, check its size and fill it if possible
    //

    if (Buffer) {
        if (BufferSize >= size) {
            if (!GetProperty (offset, NULL, Buffer, NULL, NULL)) {
                DEBUGMSG ((DBG_ERROR, "Error reading property data from dat file"));
                // error code is one of the file api error codes
                return FALSE;
            }
        } else {
            SetLastError (ERROR_MORE_DATA);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
IsmRemovePropertyData (
    IN      MIG_PROPERTYDATAID PropertyDataId
    )
{
    BOOL result = FALSE;
    KEYHANDLE *linkageArray;
    UINT linkageCount;
    UINT u;
    UINT v;
    UINT propertySearch;
    PPROPERTY_DATA_REFERENCE dataRef;
    UINT dataRefSize;
    LONGLONG offset;
    TCHAR instanceKey[256];
    KEYHANDLE lockId = 0;
    BOOL noMoreLeft;
    BOOL b;

    __try {
        //
        // Determine the offset for the property instance
        //

        offset = OffsetFromPropertyDataId (PropertyDataId);
        if (!offset) {
            __leave;
        }

        //
        // Get single linkage list from property instance.  The links point
        // to objects.
        //

        linkageArray = (KEYHANDLE *) MemDbGetSingleLinkageArrayByKeyHandle (
                                            PropertyDataId,                     // handle
                                            PROPERTY_INDEX,
                                            &linkageCount
                                            );

        if (!linkageArray) {
            //
            // Doesn't exist!
            //

            DEBUGMSG ((DBG_ERROR, "Tried to remove invalid property instance"));
            __leave;
        }

        linkageCount /= sizeof (KEYHANDLE);

        if (!linkageCount) {
            DEBUGMSG ((DBG_WHOOPS, "Empty linkage list for property instances"));
            __leave;
        }

        //
        // For all entries in the linkage list, remove the blob entry
        //

        for (u = 0 ; u < linkageCount ; u++) {
            //
            // Check if the object is locked
            //

            if (IsObjectLocked (linkageArray[u])) {
                DEBUGMSG ((
                    DBG_WARNING,
                    "Can't remove property from %s because of object lock",
                    GetObjectNameForDebugMsg (linkageArray[u])
                    ));
                continue;
            }

            if (lockId) {
                //
                // For the first pass, the lockId is unknown. On additional
                // passes, the per-object property lock is checked here.
                //

                if (IsHandleLocked ((MIG_OBJECTID) linkageArray[u], lockId)) {
                    DEBUGMSG ((
                        DBG_WARNING,
                        "Can't remove property from %s because of object lock",
                        GetObjectNameForDebugMsg (linkageArray[u])
                        ));
                    continue;
                }
            }

            //
            // Get the unordered blob for the object
            //

            dataRef = (PPROPERTY_DATA_REFERENCE) MemDbGetUnorderedBlobByKeyHandle (
                                                        linkageArray[u],
                                                        PROPERTY_INDEX,
                                                        &dataRefSize
                                                        );

            dataRefSize /= sizeof (PROPERTY_DATA_REFERENCE);

            if (!dataRef || !dataRefSize) {
                DEBUGMSG ((DBG_WHOOPS, "Empty propid/offset blob for property instance"));
                continue;
            }

#ifdef DEBUG
            //
            // Assert that the blob has a reference to the offset we are removing
            //

            for (v = 0 ; v < dataRefSize ; v++) {
                if (dataRef[v].DatFileOffset == offset) {
                    break;
                }
            }

            MYASSERT (v < dataRefSize);
#endif

            //
            // Scan the blob for all references to this property instance, then
            // reset the PropertyId member. If removing the property instance
            // causes the property not to be referenced by the object, then
            // also remove the property name linkage.
            //

            noMoreLeft = FALSE;

            for (v = 0 ; v < dataRefSize && !noMoreLeft ; v++) {
                if (dataRef[v].DatFileOffset == offset) {

                    MYASSERT (!lockId || dataRef[v].PropertyId == lockId);

                    //
                    // Check if the per-object property is locked (on the first pass only)
                    //

                    if (!lockId) {
                        lockId = (KEYHANDLE) dataRef[v].PropertyId;

                        if (IsHandleLocked ((MIG_OBJECTID) linkageArray[u], lockId)) {
                            DEBUGMSG ((
                                DBG_WARNING,
                                "Can't remove property from %s because of object lock (2)",
                                GetObjectNameForDebugMsg (linkageArray[u])
                                ));

                            //
                            // noMoreLeft is used to detect this case outside the loop
                            //

                            MYASSERT (!noMoreLeft);
                            break;
                        }
                    }

                    //
                    // Are there more references in this blob to the current property ID?
                    //

                    for (propertySearch = 0 ; propertySearch < dataRefSize ; propertySearch++) {

                        if (propertySearch == v) {
                            continue;
                        }

                        if (dataRef[propertySearch].PropertyId == dataRef[v].PropertyId) {
                            break;
                        }

                    }

                    //
                    // If no other references to property, remove the property name linkage
                    //

                    if (propertySearch >= dataRefSize) {
                        MemDbDeleteDoubleLinkageByKeyHandle (
                            linkageArray[u],
                            dataRef[v].PropertyId,
                            PROPERTY_INDEX
                            );

                        noMoreLeft = TRUE;

                    }

                    //
                    // Reset the current property id (to "deleted" status)
                    //

                    dataRef[v].PropertyId = 0;
                }
            }

            if (v >= dataRefSize || noMoreLeft) {
                //
                // The loop did not terminated early because of a lock,
                // so reapply the change
                //

                b = MemDbSetUnorderedBlobByKeyHandle (
                        linkageArray[u],
                        PROPERTY_INDEX,
                        (PBYTE) dataRef,
                        dataRefSize * sizeof (PROPERTY_DATA_REFERENCE)
                        );
            } else {
                b = TRUE;
            }

            MemDbReleaseMemory (dataRef);

            if (!b) {
                DEBUGMSG ((DBG_ERROR, "Can't re-apply property linkage blob during instance remove"));
                EngineError ();
                __leave;
            }
        }

        //
        // Remove the property instance
        //

        wsprintf (instanceKey, S_PROPINST_FORMAT, offset);
        MemDbDeleteKey (instanceKey);

        result = TRUE;
    }
    __finally {
    }

    return result;
}


BOOL
pRemovePropertyFromObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId,
    IN      BOOL QueryOnly
    )
{
    BOOL result = FALSE;
    UINT u;
    PPROPERTY_DATA_REFERENCE dataRef = NULL;
    UINT dataRefSize;
    TCHAR instanceKey[256];
    KEYHANDLE propertyData;
    BOOL b;

    __try {
        //
        // Test for locks
        //

        if (TestLock (ObjectId, (KEYHANDLE) PropertyId)) {
            SetLastError (ERROR_LOCKED);
            DEBUGMSG ((
                DBG_WARNING,
                "Can't remove property %s on %s because of lock",
                pGetPropertyNameForDebugMsg (PropertyId),
                GetObjectNameForDebugMsg (ObjectId)
                ));
            __leave;
        }

        if (QueryOnly) {
            result =  TRUE;
            __leave;
        }

        //
        // Get the unordered blob
        //

        dataRef = (PPROPERTY_DATA_REFERENCE) MemDbGetUnorderedBlobByKeyHandle (
                                                    ObjectId,
                                                    PROPERTY_INDEX,
                                                    &dataRefSize
                                                    );

        dataRefSize /= sizeof (PROPERTY_DATA_REFERENCE);

        if (!dataRef || !dataRefSize) {
            DEBUGMSG ((DBG_WHOOPS, "Empty propid/offset blob for property removal"));
            __leave;
        }

        //
        // Scan the blob for references to this property
        //

        b = FALSE;

        for (u = 0 ; u < dataRefSize ; u++) {

            if (dataRef[u].PropertyId == PropertyId) {

                //
                // Remove the single linkage from offset to object
                //

                wsprintf (instanceKey, S_PROPINST_FORMAT, dataRef[u].DatFileOffset);
                propertyData = MemDbGetHandleFromKey (instanceKey);

                if (!propertyData) {
                    DEBUGMSG ((DBG_WHOOPS, "Property references non-existent offset"));
                    continue;
                }

                MemDbDeleteSingleLinkageByKeyHandle (propertyData, ObjectId, PROPERTY_INDEX);

                //
                // IMPORTANT: The operation above might have made the property instance
                // key point to nothing (because the last remaining linkage was removed).
                // However, it is critical not to remove the abandoned propertyData key,
                // becase the caller might still have handle to the property instance, and
                // this handle can be applied to a new object later.
                //

                //
                // Now reset the property id ("deleted" state)
                //

                dataRef[u].PropertyId = 0;
                b = TRUE;
            }
        }

        //
        // Reapply the changed blob
        //

        if (b) {
            if (!MemDbSetUnorderedBlobByKeyHandle (
                    ObjectId,
                    PROPERTY_INDEX,
                    (PBYTE) dataRef,
                    dataRefSize * sizeof (PROPERTY_DATA_REFERENCE)
                    )) {
                __leave;
            }
        }

        //
        // Remove the object-to-property name linkage. If this fails and b is FALSE,
        // then the object doesn't have a reference to the property.
        //

        if (!MemDbDeleteDoubleLinkageByKeyHandle (ObjectId, PropertyId, PROPERTY_INDEX)) {
            DEBUGMSG_IF ((b, DBG_WHOOPS, "Can't delete object<->property linkage"));
            __leave;
        }

        result = TRUE;
    }
    __finally {
        if (dataRef) {
            MemDbReleaseMemory (dataRef);
            INVALID_POINTER (dataRef);
        }
    }

    return result;
}


BOOL
pRemovePropertyGroup (
    IN      KEYHANDLE PropertyId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    return pRemovePropertyFromObjectId (
                (MIG_OBJECTID) Arg,
                (MIG_PROPERTYID) PropertyId,
                FirstPass
                );
}


BOOL
IsmRemovePropertyFromObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId
    )
{
    RECURSERETURN rc;

    //
    // If PropertyId is a group, set all attribs in the group
    //

    rc = RecurseForGroupItems (
                PropertyId,
                pRemovePropertyGroup,
                (ULONG_PTR) ObjectId,
                FALSE,
                FALSE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pRemovePropertyFromObjectId (ObjectId, PropertyId, FALSE);
}


BOOL
IsmRemovePropertyFromObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID PropertyId
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmRemovePropertyFromObjectId (objectId, PropertyId);
    }

    return result;
}


BOOL
pIsPropertySetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId
    )
{
    return MemDbTestDoubleLinkageByKeyHandle (
                ObjectId,
                PropertyId,
                PROPERTY_INDEX
                );
}


BOOL
pQueryPropertyGroup (
    IN      KEYHANDLE PropertyId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    return pIsPropertySetOnObjectId (
                (MIG_OBJECTID) Arg,
                (MIG_PROPERTYID) PropertyId
                );
}


BOOL
IsmIsPropertySetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId
    )
{
    RECURSERETURN rc;

    //
    // If PropertyId is a group, query all properties in the group
    //

    rc = RecurseForGroupItems (
                PropertyId,
                pQueryPropertyGroup,
                (ULONG_PTR) ObjectId,
                TRUE,
                TRUE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pIsPropertySetOnObjectId (ObjectId, PropertyId);
}


BOOL
IsmIsPropertySetOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID PropertyId
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmIsPropertySetOnObjectId (objectId, PropertyId);
    }

    return result;
}


BOOL
IsmEnumFirstObjectPropertyById (
    OUT     PMIG_OBJECTPROPERTY_ENUM EnumPtr,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID FilterProperty           OPTIONAL
    )
{
    POBJECTPROPERTY_HANDLE handle;
    BOOL b = TRUE;
    UINT size;

    //
    // Initialize the enum structure and alloc an internal data struct
    //

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTPROPERTY_ENUM));

    EnumPtr->Handle = MemAllocZeroed (sizeof (OBJECTPROPERTY_HANDLE));
    handle = (POBJECTPROPERTY_HANDLE) EnumPtr->Handle;

    handle->ObjectId = ObjectId;
    handle->FilterPropertyId = FilterProperty;

    if (!handle->ObjectId) {
        IsmAbortObjectPropertyEnum (EnumPtr);
        return FALSE;
    }

    //
    // Property enumeration occurs in the following states
    //
    // 1. Get linkage list of all properties
    // 2. Take first linkage from the list
    // 3. Find the property name
    // 4. Find the first instance of the property in the unordered blob
    // 5. Return the property name and property data to the caller
    // 6. Find the next instance of the property in the undorderd blob
    //      - go back to state 5 if another instance is found
    //      - go to state 7 if no more instances are found
    // 7. Take the next linkage from the list
    //      - go back to state 3 if another linkage exists
    //      - terminate otherwise
    //

    //
    // Get linkage list of all properties
    //

    handle->LinkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                handle->ObjectId,
                                PROPERTY_INDEX,
                                &handle->LinkageCount
                                );

    handle->LinkageCount /= sizeof (KEYHANDLE);

    if (!handle->LinkageList || !handle->LinkageCount) {
        IsmAbortObjectPropertyEnum (EnumPtr);
        return FALSE;
    }

    handle->LinkageEnumPosition = 0;

    //
    // Get unordered blob that points us into property.dat
    //

    handle->InstanceArray = (PPROPERTY_DATA_REFERENCE) MemDbGetUnorderedBlobByKeyHandle (
                                                            handle->ObjectId,
                                                            PROPERTY_INDEX,
                                                            &size
                                                            );

    if (!handle->InstanceArray || !size) {
        DEBUGMSG ((DBG_WHOOPS, "Object<->Property Instance linkage is broken in enum"));
        IsmAbortObjectPropertyEnum (EnumPtr);
    }

    handle->InstanceCount = size / sizeof (PROPERTY_DATA_REFERENCE);

    //
    // Call next enum routine to continue with state machine
    //

    handle->State = PROPENUM_GET_NEXT_LINKAGE;

    return IsmEnumNextObjectProperty (EnumPtr);
}


BOOL
IsmEnumFirstObjectProperty (
    OUT     PMIG_OBJECTPROPERTY_ENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID FilterProperty               OPTIONAL
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmEnumFirstObjectPropertyById (EnumPtr, objectId, FilterProperty);
    }

    return result;
}

BOOL
IsmEnumNextObjectProperty (
    IN OUT  PMIG_OBJECTPROPERTY_ENUM EnumPtr
    )
{
    POBJECTPROPERTY_HANDLE handle;
    PPROPERTY_DATA_REFERENCE propData;

    handle = (POBJECTPROPERTY_HANDLE) EnumPtr->Handle;
    if (!handle) {
        return FALSE;
    }

    while (handle->State != PROPENUM_RETURN_VALUE &&
           handle->State != PROPENUM_DONE
           ) {

        switch (handle->State) {

        case PROPENUM_GET_NEXT_LINKAGE:

            if (handle->LinkageEnumPosition >= handle->LinkageCount) {
                handle->State = PROPENUM_DONE;
                break;
            }

            EnumPtr->PropertyId = (MIG_PROPERTYID) handle->LinkageList[handle->LinkageEnumPosition];
            handle->LinkageEnumPosition++;

            //
            // If there is a property id filter, make sure we ignore all properties
            // except for the one specified
            //

            if (handle->FilterPropertyId) {
                if (handle->FilterPropertyId != EnumPtr->PropertyId) {
                    //
                    // This property is not interesting -- skip it
                    //

                    handle->State = PROPENUM_GET_NEXT_LINKAGE;
                    break;
                }
            }

            //
            // Now make sure the property is not owned by someone else
            //

            if (!IsmGetPropertyName (
                    EnumPtr->PropertyId,
                    NULL,
                    0,
                    &EnumPtr->Private,
                    NULL,
                    NULL
                    )) {
                //
                // This property is not owned by the caller -- skip it
                //

                handle->State = PROPENUM_GET_NEXT_LINKAGE;
                break;
            }

            //
            // The current property is either common or is owned by the caller;
            // now enumerate the property instances.
            //

            handle->InstancePosition = 0;

#ifdef DEBUG
            //
            // Assert that there is at least one instance of the property
            // in the current unordered blob
            //

            {
                UINT u;

                for (u = 0 ; u < handle->InstanceCount ; u++) {
                    propData = &handle->InstanceArray[u];
                    if (propData->PropertyId == EnumPtr->PropertyId) {
                        break;
                    }
                }

                MYASSERT (u < handle->InstanceCount);
            }
#endif

            handle->State = PROPENUM_GET_NEXT_INSTANCE;
            break;

        case PROPENUM_GET_NEXT_INSTANCE:

            //
            // Sequentially search the unordered blob for the current property,
            // continuing from the last match (if any)
            //

            handle->State = PROPENUM_GET_NEXT_LINKAGE;

            while (handle->InstancePosition < handle->InstanceCount) {

                propData = &handle->InstanceArray[handle->InstancePosition];
                handle->InstancePosition++;

                if (propData->PropertyId == EnumPtr->PropertyId) {
                    EnumPtr->PropertyDataId = pPropertyDataIdFromOffset (propData->DatFileOffset);
                    handle->State = PROPENUM_RETURN_VALUE;
                    break;
                }
            }

            break;

        }
    }

    if (handle->State == PROPENUM_DONE) {
        IsmAbortObjectPropertyEnum (EnumPtr);
        return FALSE;
    }

    MYASSERT (handle->State == PROPENUM_RETURN_VALUE);

    handle->State = PROPENUM_GET_NEXT_INSTANCE;

    return TRUE;
}


VOID
IsmAbortObjectPropertyEnum (
    IN OUT  PMIG_OBJECTPROPERTY_ENUM EnumPtr
    )
{
    POBJECTPROPERTY_HANDLE handle;

    if (EnumPtr->Handle) {

        handle = (POBJECTPROPERTY_HANDLE) EnumPtr->Handle;

        if (handle->LinkageList) {
            MemDbReleaseMemory (handle->LinkageList);
            INVALID_POINTER (handle->LinkageList);
        }

        FreeAlloc (EnumPtr->Handle);
        INVALID_POINTER (EnumPtr->Handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTPROPERTY_ENUM));
}


MIG_PROPERTYDATAID
IsmGetPropertyFromObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_PROPERTYID ObjectProperty
    )
{
    MIG_OBJECTPROPERTY_ENUM propEnum;
    MIG_PROPERTYDATAID result = 0;

    if (IsmEnumFirstObjectProperty (&propEnum, ObjectTypeId, ObjectName, ObjectProperty)) {
        result = propEnum.PropertyDataId;
        IsmAbortObjectPropertyEnum (&propEnum);
    }
    return result;
}


MIG_PROPERTYDATAID
IsmGetPropertyFromObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID ObjectProperty
    )
{
    MIG_OBJECTPROPERTY_ENUM propEnum;
    MIG_PROPERTYDATAID result = 0;

    if (IsmEnumFirstObjectPropertyById (&propEnum, ObjectId, ObjectProperty)) {
        result = propEnum.PropertyDataId;
        IsmAbortObjectPropertyEnum (&propEnum);
    }
    return result;
}


BOOL
IsmEnumFirstObjectWithProperty (
    OUT     PMIG_OBJECTWITHPROPERTY_ENUM EnumPtr,
    IN      MIG_PROPERTYID PropertyId
    )
{
    POBJECTWITHPROPERTY_HANDLE handle;
    BOOL result = FALSE;

    __try {
        if (!IsItemId ((KEYHANDLE) PropertyId)) {
            DEBUGMSG ((DBG_ERROR, "IsmEnumFirstObjectWithProperty: invalid property id"));
            __leave;
        }

        //
        // Initialize the enum struct and alloc a data struct
        //

        ZeroMemory (EnumPtr, sizeof (MIG_OBJECTWITHPROPERTY_ENUM));

        EnumPtr->Handle = MemAllocZeroed (sizeof (OBJECTWITHPROPERTY_HANDLE));
        handle = (POBJECTWITHPROPERTY_HANDLE) EnumPtr->Handle;

        //
        // Obtain the object<->property linkage list from the property ID
        //

        handle->LinkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                    PropertyId,
                                    PROPERTY_INDEX,
                                    &handle->LinkageCount
                                    );

        handle->LinkageCount /= SIZEOF(KEYHANDLE);

        if (!handle->LinkageList || !handle->LinkageCount) {
            IsmAbortObjectWithPropertyEnum (EnumPtr);
            __leave;
        }

        handle->LinkagePos = 0;
        handle->PropertyId = PropertyId;

        //
        // Call the enum next routine to continue
        //

        result = IsmEnumNextObjectWithProperty (EnumPtr);

    }
    __finally {
    }

    return result;
}


BOOL
IsmEnumNextObjectWithProperty (
    IN OUT  PMIG_OBJECTWITHPROPERTY_ENUM EnumPtr
    )
{
    POBJECTWITHPROPERTY_HANDLE handle;
    BOOL result = FALSE;
    PTSTR p;

    __try {
        handle = (POBJECTWITHPROPERTY_HANDLE) EnumPtr->Handle;
        if (!handle) {
            __leave;
        }

        if (handle->LinkagePos >= handle->LinkageCount) {
            IsmAbortObjectWithPropertyEnum (EnumPtr);
            __leave;
        }

        EnumPtr->ObjectId = handle->LinkageList[handle->LinkagePos];
        handle->LinkagePos++;

        if (handle->ObjectPath) {
            MemDbReleaseMemory (handle->ObjectPath);
            INVALID_POINTER (handle->ObjectPath);
        }

        handle->ObjectPath = MemDbGetKeyFromHandle ((UINT) EnumPtr->ObjectId, 0);
        if (!handle->ObjectPath) {
            __leave;
        }

        p = _tcschr (handle->ObjectPath, TEXT('\\'));
        if (!p) {
            __leave;
        }

        EnumPtr->ObjectName = _tcsinc (p);
        *p = 0;
        EnumPtr->ObjectTypeId = GetObjectTypeId (handle->ObjectPath);

        result = TRUE;
    }
    __finally {
    }

    return result;
}


VOID
IsmAbortObjectWithPropertyEnum (
    IN OUT  PMIG_OBJECTWITHPROPERTY_ENUM EnumPtr
    )
{
    POBJECTWITHPROPERTY_HANDLE handle;

    if (EnumPtr->Handle) {
        handle = (POBJECTWITHPROPERTY_HANDLE) EnumPtr->Handle;

        if (handle->ObjectPath) {
            MemDbReleaseMemory (handle->ObjectPath);
            INVALID_POINTER (handle->ObjectPath);
        }

        if (handle->LinkageList) {
            MemDbReleaseMemory (handle->LinkageList);
            INVALID_POINTER (handle->LinkageList);
        }

        FreeAlloc (EnumPtr->Handle);
        INVALID_POINTER (EnumPtr->Handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTWITHPROPERTY_ENUM));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\modules.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    modules.c

Abstract:

    Implements routines that are common to the entire ISM.

Author:

    Jim Schmidt (jimschm) 21-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_ISM     "Ism"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    UINT RefCount;
    HMODULE Handle;
} MODULEDATA, *PMODULEDATA;

//
// Globals
//

HASHTABLE g_ModuleTable;
HASHTABLE g_EtmTable;
HASHTABLE g_VcmTable;
HASHTABLE g_SgmTable;
HASHTABLE g_SamTable;
HASHTABLE g_DgmTable;
HASHTABLE g_DamTable;
HASHTABLE g_CsmTable;
HASHTABLE g_OpmTable;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

VOID
pFreeEtmTable (
    VOID
    );

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
pFindModule (
    IN      PCTSTR ModulePath,
    OUT     PTSTR FullModulePath
    )
{
    HANDLE result = NULL;
    TCHAR relativePath[MAX_PATH] = TEXT("");
    PCTSTR fileName;
    PTSTR p;

    fileName = GetFileNameFromPath (ModulePath);

    if (fileName) {
        if (GetModuleFileName (g_hInst, relativePath, ARRAYSIZE(relativePath))) {
            p = _tcsrchr (relativePath, TEXT('\\'));
            if (p) {
                p++;
                StringCopyByteCount (
                    p,
                    fileName,
                    sizeof (relativePath) - (HALF_PTR) ((PBYTE) p - (PBYTE) relativePath)
                    );
            }

            if (DoesFileExist (relativePath)) {
                StringCopy (FullModulePath, relativePath);
                return;
            }
        }
    }

    GetFullPathName (ModulePath, ARRAYSIZE(relativePath), relativePath, (PTSTR *) &fileName);

    if (DoesFileExist (relativePath)) {
        StringCopy (FullModulePath, relativePath);
        return;
    }

    if (SearchPath (NULL, fileName, NULL, MAX_PATH, FullModulePath, &p)) {
        return;
    }

    StringCopy (FullModulePath, ModulePath);
}

PMODULEDATA
pGetModuleData (
    IN      PCTSTR ModulePath
    )
{
    HASHITEM rc;
    PMODULEDATA moduleData;

    rc = HtFindStringEx (
            g_ModuleTable,
            ModulePath,
            &moduleData,
            FALSE
            );

    if (!rc) {
        return NULL;
    }

    return moduleData;
}

BOOL
pRegisterModule (
    IN      PCTSTR ModulePath,
    IN      HMODULE ModuleHandle
    )
{
    PMODULEDATA moduleData;
    PMODULEINITIALIZE moduleInitialize = NULL;
    BOOL result = TRUE;

    moduleData = pGetModuleData (ModulePath);
    if (moduleData) {
        if (moduleData->RefCount == 0) {
            moduleData->Handle = ModuleHandle;
            // time to call the initialization routine
            moduleInitialize = (PMODULEINITIALIZE) GetProcAddress (moduleData->Handle, "ModuleInitialize");
            if (moduleInitialize) {
                result = moduleInitialize ();
            }
        }
        MYASSERT (moduleData->Handle == ModuleHandle);
        moduleData->RefCount ++;
    } else {
        moduleData = (PMODULEDATA) PmGetMemory (g_IsmUntrackedPool, sizeof (MODULEDATA));
        ZeroMemory (moduleData, sizeof (MODULEDATA));
        moduleData->RefCount = 1;
        moduleData->Handle = ModuleHandle;
        // time to call the initialization routine
        moduleInitialize = (PMODULEINITIALIZE) GetProcAddress (moduleData->Handle, "ModuleInitialize");
        if (moduleInitialize) {
            result = moduleInitialize ();
        }
        HtAddStringEx (g_ModuleTable, ModulePath, &moduleData, FALSE);
    }
    return TRUE;
}

BOOL
pUnregisterModule (
    IN      PCTSTR ModulePath
    )
{
    PMODULEDATA moduleData;
    PMODULETERMINATE moduleTerminate = NULL;

    moduleData = pGetModuleData (ModulePath);
    if (moduleData) {
        if (moduleData->RefCount) {
            moduleData->RefCount --;
            if (moduleData->RefCount == 0) {
                // time to call the termination routine
                moduleTerminate = (PMODULETERMINATE) GetProcAddress (moduleData->Handle, "ModuleTerminate");
                if (moduleTerminate) {
                    moduleTerminate ();
                }
                FreeLibrary (moduleData->Handle);
                moduleData->Handle = NULL;
            }
        } else {
            DEBUGMSG ((DBG_WHOOPS, "Too many UnregisterModule called for %s", ModulePath));
        }
    }
    return TRUE;
}

VOID
pFreeRegisteredModules (
    VOID
    )
{
    PMODULEDATA moduleData;
    PMODULETERMINATE moduleTerminate = NULL;
    HASHTABLE_ENUM e;

    if (g_ModuleTable) {
        if (EnumFirstHashTableString (&e, g_ModuleTable)) {
            do {
                moduleData = *((PMODULEDATA *) e.ExtraData);
                if (moduleData) {
                    if (moduleData->RefCount) {
                        DEBUGMSG ((DBG_WHOOPS, "Registered module was not unregistered."));
                        moduleData->RefCount = 0;
                        moduleTerminate = (PMODULETERMINATE) GetProcAddress (moduleData->Handle, "ModuleTerminate");
                        if (moduleTerminate) {
                            moduleTerminate ();
                        }
                        FreeLibrary (moduleData->Handle);
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_ModuleTable);
        g_ModuleTable = NULL;
    }
}

BOOL
pRegisterEtm (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR ModuleId,
    IN      PCTSTR ModulePath,
    IN      PVOID Reserved
    )
{
    PETMDATA etmData;
    HASHITEM rc;
    PTYPEMODULE queryTypeModule;
    TYPE_ENTRYPOINTS entryPoints;
    TCHAR fullModulePath[MAX_TCHAR_PATH];

    rc = HtFindString (g_EtmTable, ModuleId);

    if (rc) {
        return FALSE;
    }

    etmData = (PETMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (ETMDATA));
    ZeroMemory (etmData, sizeof (ETMDATA));

    pFindModule (ModulePath, fullModulePath);
    etmData->EtmPath = PmDuplicateString (g_IsmUntrackedPool, fullModulePath);
    etmData->LibHandle = LoadLibrary (fullModulePath);

    if (etmData->LibHandle) {

        queryTypeModule = (PTYPEMODULE) GetProcAddress (etmData->LibHandle, "TypeModule");

        if (queryTypeModule) {

            ZeroMemory (&entryPoints, sizeof (entryPoints));
            entryPoints.Version = ISM_VERSION;

            if (queryTypeModule (ModuleId, &entryPoints)) {

                etmData->EtmInitialize = entryPoints.EtmInitialize;
                etmData->EtmParse = entryPoints.EtmParse;
                etmData->EtmTerminate = entryPoints.EtmTerminate;
                etmData->EtmNewUserCreated = entryPoints.EtmNewUserCreated;

                if (etmData->EtmInitialize) {
                    etmData->ShouldBeCalled = TRUE;
                }
            } else {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_DLL_DOES_NOT_SUPPORT_TAG, fullModulePath, ModuleId));
            }
        } else {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_ETM_ENTRYPOINT_MISSING, fullModulePath));
        }

    } else {
        LOG ((LOG_WARNING, (PCSTR) MSG_LOADLIBRARY_FAILURE, ModuleId));
    }

    if (etmData->ShouldBeCalled) {

        etmData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_EtmTable, ModuleId, &etmData, FALSE);

        if (pRegisterModule (fullModulePath, etmData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!etmData->EtmInitialize (Platform, g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                etmData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            etmData->Initialized = TRUE;

        } else {

            etmData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    return etmData->ShouldBeCalled;
}


BOOL
pRegisterVcm (
    IN      PCTSTR ModuleId,
    IN      PCTSTR ModulePath,
    IN      PVOID Reserved
    )
{
    PVCMDATA vcmData;
    HASHITEM rc;
    PVIRTUALCOMPUTERMODULE queryEntryPoints;
    VIRTUAL_COMPUTER_ENTRYPOINTS entryPoints;
    TCHAR fullModulePath[MAX_TCHAR_PATH];

    pFindModule (ModulePath, fullModulePath);

    rc = HtFindString (g_VcmTable, ModuleId);

    if (rc) {
        return FALSE;
    }

    vcmData = (PVCMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (VCMDATA));
    ZeroMemory (vcmData, sizeof (VCMDATA));

    vcmData->VcmPath = PmDuplicateString (g_IsmUntrackedPool, fullModulePath);
    vcmData->LibHandle = LoadLibrary (fullModulePath);

    if (vcmData->LibHandle) {

        queryEntryPoints = (PVIRTUALCOMPUTERMODULE) GetProcAddress (
                                                        vcmData->LibHandle,
                                                        "VirtualComputerModule"
                                                        );

        if (queryEntryPoints) {
            ZeroMemory (&entryPoints, sizeof (entryPoints));
            entryPoints.Version = ISM_VERSION;

            if (queryEntryPoints (ModuleId, &entryPoints)) {

                vcmData->VcmInitialize = entryPoints.VcmInitialize;
                vcmData->VcmParse = entryPoints.VcmParse;
                vcmData->VcmQueueEnumeration = entryPoints.VcmQueueEnumeration;
                vcmData->VcmQueueHighPriorityEnumeration = entryPoints.VcmQueueHighPriorityEnumeration;
                vcmData->VcmTerminate = entryPoints.VcmTerminate;

                if (vcmData->VcmInitialize && vcmData->VcmQueueEnumeration) {
                    vcmData->ShouldBeCalled = TRUE;
                }
            } else {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_DLL_DOES_NOT_SUPPORT_TAG, fullModulePath, ModuleId));
            }
        } else {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_VCM_ENTRYPOINT_MISSING, fullModulePath));
        }

    } else {
        LOG ((LOG_WARNING, (PCSTR) MSG_LOADLIBRARY_FAILURE, ModuleId));
    }

    if (vcmData->ShouldBeCalled) {

        vcmData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_VcmTable, ModuleId, &vcmData, FALSE);

        if (pRegisterModule (fullModulePath, vcmData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!vcmData->VcmInitialize (g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                vcmData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            vcmData->Initialized = TRUE;

        } else {

            vcmData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    return vcmData->ShouldBeCalled;
}


BOOL
pRegisterSm (
    IN      PCTSTR ModuleId,
    IN      PCTSTR ModulePath,
    IN      PVOID Reserved
    )
{
    PSGMDATA sgmData;
    PSAMDATA samData;
    HASHITEM rc;
    PSOURCEMODULE queryEntryPoints;
    SOURCE_ENTRYPOINTS entryPoints;
    TCHAR fullModulePath[MAX_TCHAR_PATH];

    pFindModule (ModulePath, fullModulePath);

    rc = HtFindString (g_SgmTable, ModuleId);

    if (!rc) {
        rc = HtFindString (g_SamTable, ModuleId);
    }

    if (rc) {
        return FALSE;
    }

    sgmData = (PSGMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (SGMDATA));
    ZeroMemory (sgmData, sizeof (SGMDATA));

    samData = (PSAMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (SAMDATA));
    ZeroMemory (samData, sizeof (SAMDATA));

    sgmData->SgmPath = PmDuplicateString (g_IsmUntrackedPool, fullModulePath);
    sgmData->LibHandle = LoadLibrary (fullModulePath);

    samData->SamPath = sgmData->SgmPath;
    samData->LibHandle = sgmData->LibHandle;

    if (sgmData->LibHandle) {

        queryEntryPoints = (PSOURCEMODULE) GetProcAddress (sgmData->LibHandle, "SourceModule");

        if (queryEntryPoints) {

            ZeroMemory (&entryPoints, sizeof (entryPoints));
            entryPoints.Version = ISM_VERSION;

            if (queryEntryPoints (ModuleId, &entryPoints)) {

                sgmData->SgmInitialize = entryPoints.SgmInitialize;
                sgmData->SgmParse = entryPoints.SgmParse;
                sgmData->SgmQueueEnumeration = entryPoints.SgmQueueEnumeration;
                sgmData->SgmQueueHighPriorityEnumeration = entryPoints.SgmQueueHighPriorityEnumeration;
                sgmData->SgmTerminate = entryPoints.SgmTerminate;

                if (sgmData->SgmInitialize && sgmData->SgmQueueEnumeration) {
                    sgmData->ShouldBeCalled = TRUE;
                }

                samData->SamInitialize = entryPoints.SamInitialize;
                samData->SamExecute = entryPoints.SamExecute;
                samData->SamEstimateProgressBar = entryPoints.SamEstimateProgressBar;
                samData->SamTerminate = entryPoints.SamTerminate;

                if (samData->SamInitialize && samData->SamExecute) {
                    samData->ShouldBeCalled = TRUE;
                }
            } else {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_DLL_DOES_NOT_SUPPORT_TAG, fullModulePath, ModuleId));
            }
        } else {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_SOURCE_ENTRYPOINT_MISSING, fullModulePath));
        }

    } else {
        LOG ((LOG_WARNING, (PCSTR) MSG_LOADLIBRARY_FAILURE, ModuleId));
    }

    if (sgmData->ShouldBeCalled) {

        sgmData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_SgmTable, ModuleId, &sgmData, FALSE);

        if (pRegisterModule (fullModulePath, sgmData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!sgmData->SgmInitialize (g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                sgmData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            sgmData->Initialized = TRUE;

        } else {

            sgmData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    if (samData->ShouldBeCalled) {

        samData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_SamTable, ModuleId, &samData, FALSE);

        if (pRegisterModule (fullModulePath, samData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!samData->SamInitialize (g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                samData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            samData->Initialized = TRUE;

        } else {

            samData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    return sgmData->ShouldBeCalled || samData->ShouldBeCalled;
}


BOOL
pRegisterDm (
    IN      PCTSTR ModuleId,
    IN      PCTSTR ModulePath,
    IN      PVOID Reserved
    )
{
    PDAMDATA damData;
    PDGMDATA dgmData;
    PCSMDATA csmData;
    POPMDATA opmData;
    HASHITEM rc;
    PDESTINATIONMODULE queryEntryPoints;
    DESTINATION_ENTRYPOINTS entryPoints;
    TCHAR fullModulePath[MAX_TCHAR_PATH];

    pFindModule (ModulePath, fullModulePath);

    rc = HtFindString (g_DgmTable, ModuleId);

    if (!rc) {
        rc = HtFindString (g_DamTable, ModuleId);
    }

    if (!rc) {
        rc = HtFindString (g_CsmTable, ModuleId);
    }

    if (!rc) {
        rc = HtFindString (g_OpmTable, ModuleId);
    }

    if (rc) {
        return FALSE;
    }

    dgmData = (PDGMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (DGMDATA));
    ZeroMemory (dgmData, sizeof (DGMDATA));

    dgmData->DgmPath = PmDuplicateString (g_IsmUntrackedPool, fullModulePath);
    dgmData->LibHandle = LoadLibrary (fullModulePath);

    damData = (PDAMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (DAMDATA));
    ZeroMemory (damData, sizeof (DAMDATA));

    damData->DamPath = dgmData->DgmPath;
    damData->LibHandle = dgmData->LibHandle;

    csmData = (PCSMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (CSMDATA));
    ZeroMemory (csmData, sizeof (CSMDATA));

    csmData->CsmPath = dgmData->DgmPath;
    csmData->LibHandle = dgmData->LibHandle;

    opmData = (POPMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (OPMDATA));
    ZeroMemory (opmData, sizeof (OPMDATA));

    opmData->OpmPath = dgmData->DgmPath;
    opmData->LibHandle = dgmData->LibHandle;

    if (dgmData->LibHandle) {

        queryEntryPoints = (PDESTINATIONMODULE) GetProcAddress (dgmData->LibHandle, "DestinationModule");

        if (queryEntryPoints) {

            ZeroMemory (&entryPoints, sizeof (entryPoints));
            entryPoints.Version = ISM_VERSION;

            if (queryEntryPoints (ModuleId, &entryPoints)) {

                dgmData->DgmInitialize = entryPoints.DgmInitialize;
                dgmData->DgmQueueEnumeration = entryPoints.DgmQueueEnumeration;
                dgmData->DgmQueueHighPriorityEnumeration = entryPoints.DgmQueueHighPriorityEnumeration;
                dgmData->DgmTerminate = entryPoints.DgmTerminate;

                if (dgmData->DgmInitialize && dgmData->DgmQueueEnumeration) {
                    dgmData->ShouldBeCalled = TRUE;
                }

                damData->DamInitialize = entryPoints.DamInitialize;
                damData->DamExecute = entryPoints.DamExecute;
                damData->DamEstimateProgressBar = entryPoints.DamEstimateProgressBar;
                damData->DamTerminate = entryPoints.DamTerminate;

                if (damData->DamInitialize && damData->DamExecute) {
                    damData->ShouldBeCalled = TRUE;
                }

                csmData->CsmInitialize = entryPoints.CsmInitialize;
                csmData->CsmExecute = entryPoints.CsmExecute;
                csmData->CsmEstimateProgressBar = entryPoints.CsmEstimateProgressBar;
                csmData->CsmTerminate = entryPoints.CsmTerminate;

                if (csmData->CsmInitialize && csmData->CsmExecute) {
                    csmData->ShouldBeCalled = TRUE;
                }

                opmData->OpmInitialize = entryPoints.OpmInitialize;
                opmData->OpmTerminate = entryPoints.OpmTerminate;

                if (opmData->OpmInitialize) {
                    opmData->ShouldBeCalled = TRUE;
                }
            }
        } else {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_DEST_ENTRYPOINT_MISSING, fullModulePath));
        }

    } else {
        LOG ((LOG_WARNING, (PCSTR) MSG_LOADLIBRARY_FAILURE, ModuleId));
    }

    if (dgmData->ShouldBeCalled) {

        dgmData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_DgmTable, ModuleId, &dgmData, FALSE);

        if (pRegisterModule (fullModulePath, dgmData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!dgmData->DgmInitialize (g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                dgmData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            dgmData->Initialized = TRUE;

        } else {

            dgmData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    if (damData->ShouldBeCalled) {

        damData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_DamTable, ModuleId, &damData, FALSE);

        if (pRegisterModule (fullModulePath, damData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!damData->DamInitialize (g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                damData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            damData->Initialized = TRUE;

        } else {

            damData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    if (csmData->ShouldBeCalled) {

        csmData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_CsmTable, ModuleId, &csmData, FALSE);

        if (pRegisterModule (fullModulePath, csmData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!csmData->CsmInitialize (g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                csmData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            csmData->Initialized = TRUE;

        } else {

            csmData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    if (opmData->ShouldBeCalled) {

        opmData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_OpmTable, ModuleId, &opmData, FALSE);

        if (pRegisterModule (fullModulePath, opmData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!opmData->OpmInitialize (g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                opmData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            opmData->Initialized = TRUE;

        } else {

            opmData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    return dgmData->ShouldBeCalled ||
           damData->ShouldBeCalled ||
           csmData->ShouldBeCalled ||
           opmData->ShouldBeCalled;
}


BOOL
pRegisterTransport (
    IN      PCTSTR ModuleId,
    IN      PCTSTR ModulePath,
    IN      PVOID Reserved
    )
{
    PTRANSPORTDATA transportData;
    HASHITEM rc;
    PTRANSPORTMODULE queryEntryPoints;
    TRANSPORT_ENTRYPOINTS entryPoints;
    TCHAR fullModulePath[MAX_TCHAR_PATH];

    pFindModule (ModulePath, fullModulePath);

    rc = HtFindString (g_TransportTable, ModuleId);

    if (rc) {
        return FALSE;
    }

    transportData = (PTRANSPORTDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (TRANSPORTDATA));
    ZeroMemory (transportData, sizeof (TRANSPORTDATA));

    transportData->TransportPath = PmDuplicateString (g_IsmUntrackedPool, fullModulePath);
    transportData->LibHandle = LoadLibrary (fullModulePath);

    if (transportData->LibHandle) {

        queryEntryPoints = (PTRANSPORTMODULE) GetProcAddress (transportData->LibHandle, "TransportModule");

        if (queryEntryPoints) {

            ZeroMemory (&entryPoints, sizeof (entryPoints));
            entryPoints.Version = ISM_VERSION;

            if (queryEntryPoints (ModuleId, &entryPoints)) {

                transportData->TransportInitialize = entryPoints.TransportInitialize;
                transportData->TransportTerminate = entryPoints.TransportTerminate;
                transportData->TransportQueryCapabilities = entryPoints.TransportQueryCapabilities;
                transportData->TransportSetStorage = entryPoints.TransportSetStorage;
                transportData->TransportResetStorage = entryPoints.TransportResetStorage;
                transportData->TransportSaveState = entryPoints.TransportSaveState;
                transportData->TransportResumeSaveState = entryPoints.TransportResumeSaveState;
                transportData->TransportBeginApply = entryPoints.TransportBeginApply;
                transportData->TransportResumeApply = entryPoints.TransportResumeApply;
                transportData->TransportAcquireObject = entryPoints.TransportAcquireObject;
                transportData->TransportReleaseObject = entryPoints.TransportReleaseObject;
                transportData->TransportEndApply = entryPoints.TransportEndApply;
                transportData->TransportEstimateProgressBar = entryPoints.TransportEstimateProgressBar;

                if (transportData->TransportInitialize &&
                    transportData->TransportTerminate &&
                    transportData->TransportQueryCapabilities &&
                    transportData->TransportSetStorage &&
                    transportData->TransportSaveState &&
                    transportData->TransportBeginApply &&
                    transportData->TransportAcquireObject &&
                    transportData->TransportReleaseObject &&
                    transportData->TransportEndApply
                    ) {
                    transportData->ShouldBeCalled = TRUE;
                }
            }

        } else {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_TRANS_ENTRYPOINT_MISSING, fullModulePath));
        }

    } else {
        LOG ((LOG_WARNING, (PCSTR) MSG_LOADLIBRARY_FAILURE, ModuleId));
    }

    if (transportData->ShouldBeCalled) {

        transportData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_TransportTable, ModuleId, &transportData, FALSE);

        if (pRegisterModule (fullModulePath, transportData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!transportData->TransportInitialize (g_LogCallback)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                transportData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            transportData->Initialized = TRUE;

        } else {

            transportData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    return transportData->ShouldBeCalled;
}

VOID
pAllocModuleTables (
    VOID
    )
{
    if (!g_VcmTable) {
        g_VcmTable = HtAllocWithData (sizeof (PVCMDATA));
    }

    if (!g_SgmTable) {
        g_SgmTable = HtAllocWithData (sizeof (PSGMDATA));
    }

    if (!g_SamTable) {
        g_SamTable = HtAllocWithData (sizeof (PSAMDATA));
    }

    if (!g_DgmTable) {
        g_DgmTable = HtAllocWithData (sizeof (PDGMDATA));
    }

    if (!g_DamTable) {
        g_DamTable = HtAllocWithData (sizeof (PDAMDATA));
    }

    if (!g_CsmTable) {
        g_CsmTable = HtAllocWithData (sizeof (PCSMDATA));
    }

    if (!g_OpmTable) {
        g_OpmTable = HtAllocWithData (sizeof (POPMDATA));
    }
}

VOID
pFreeModuleTables (
    VOID
    )
{
    HASHTABLE_ENUM e;
    POPMDATA opmData;
    PCSMDATA csmData;
    PDAMDATA damData;
    PDGMDATA dgmData;
    PSAMDATA samData;
    PSGMDATA sgmData;
    PVCMDATA vcmData;

    if (g_OpmTable) {
        if (EnumFirstHashTableString (&e, g_OpmTable)) {
            do {
                opmData = *((POPMDATA *) e.ExtraData);
                if (opmData) {
                    if (opmData->Initialized && opmData->OpmTerminate) {
                        opmData->OpmTerminate ();
                    }
                    if (opmData->OpmPath) {
                        pUnregisterModule (opmData->OpmPath);
                        // opmData->OpmPath is owned by DGM
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_OpmTable);
        g_OpmTable = NULL;
    }
    if (g_CsmTable) {
        if (EnumFirstHashTableString (&e, g_CsmTable)) {
            do {
                csmData = *((PCSMDATA *) e.ExtraData);
                if (csmData) {
                    if (csmData->Initialized && csmData->CsmTerminate) {
                        csmData->CsmTerminate ();
                    }
                    if (csmData->CsmPath) {
                        pUnregisterModule (csmData->CsmPath);
                        // csmData->CsmPath is owned by DGM
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_CsmTable);
        g_CsmTable = NULL;
    }
    if (g_DamTable) {
        if (EnumFirstHashTableString (&e, g_DamTable)) {
            do {
                damData = *((PDAMDATA *) e.ExtraData);
                if (damData) {
                    if (damData->Initialized && damData->DamTerminate) {
                        damData->DamTerminate ();
                    }
                    if (damData->DamPath) {
                        pUnregisterModule (damData->DamPath);
                        // damData->DamPath is owned by DGM
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_DamTable);
        g_DamTable = NULL;
    }
    if (g_DgmTable) {
        if (EnumFirstHashTableString (&e, g_DgmTable)) {
            do {
                dgmData = *((PDGMDATA *) e.ExtraData);
                if (dgmData) {
                    if (dgmData->Initialized && dgmData->DgmTerminate) {
                        dgmData->DgmTerminate ();
                    }
                    if (dgmData->DgmPath) {
                        pUnregisterModule (dgmData->DgmPath);
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_DgmTable);
        g_DgmTable = NULL;
    }
    if (g_SamTable) {
        if (EnumFirstHashTableString (&e, g_SamTable)) {
            do {
                samData = *((PSAMDATA *) e.ExtraData);
                if (samData) {
                    if (samData->Initialized && samData->SamTerminate) {
                        samData->SamTerminate ();
                    }
                    if (samData->SamPath) {
                        pUnregisterModule (samData->SamPath);
                        // samData->SamPath is owned by SGM
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_SamTable);
        g_SamTable = NULL;
    }
    if (g_SgmTable) {
        if (EnumFirstHashTableString (&e, g_SgmTable)) {
            do {
                sgmData = *((PSGMDATA *) e.ExtraData);
                if (sgmData) {
                    if (sgmData->Initialized && sgmData->SgmTerminate) {
                        sgmData->SgmTerminate ();
                    }
                    if (sgmData->SgmPath) {
                        pUnregisterModule (sgmData->SgmPath);
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_SgmTable);
        g_SgmTable = NULL;
    }
    if (g_VcmTable) {
        if (EnumFirstHashTableString (&e, g_VcmTable)) {
            do {
                vcmData = *((PVCMDATA *) e.ExtraData);
                if (vcmData) {
                    if (vcmData->Initialized && vcmData->VcmTerminate) {
                        vcmData->VcmTerminate ();
                    }
                    if (vcmData->VcmPath) {
                        pUnregisterModule (vcmData->VcmPath);
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_VcmTable);
        g_VcmTable = NULL;
    }
}

VOID
pFreeTransportTable (
    VOID
    )
{
    PTRANSPORTDATA transportData;
    HASHTABLE_ENUM e;

    if (g_TransportTable) {
        if (EnumFirstHashTableString (&e, g_TransportTable)) {
            do {
                transportData = *((PTRANSPORTDATA *) e.ExtraData);
                if (transportData) {
                    if (transportData->Initialized && transportData->TransportTerminate) {
                        transportData->TransportTerminate ();
                    }
                    if (transportData->TransportPath) {
                        pUnregisterModule (transportData->TransportPath);
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_TransportTable);
        g_TransportTable = NULL;
    }
}


BOOL
ValidateModuleName (
    IN      PCTSTR ModuleName
    )
{
    if (StringIMatch (ModuleName, S_COMMON)) {
        return FALSE;
    }

    if (!IsValidCName (ModuleName)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
InitializeVcmModules (
    IN      PVOID Reserved
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR modulePath;
    PCTSTR moduleId;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;
    PCTSTR sectionName;

    //
    // Initialize external modules
    //

    pAllocModuleTables();

    sectionName = TEXT("Virtual Computer Modules");

    if (InfFindFirstLine (g_IsmInf, sectionName, NULL, &is)) {

        do {

            //
            // A source gather module has an ID and module path
            //

            moduleId = InfGetStringField (&is, 0);
            modulePath = InfGetStringField (&is, 1);

            if (!ValidateModuleName (moduleId)) {
                LOG ((LOG_WARNING, (PCSTR) MSG_INVALID_ID, moduleId));
                continue;
            }

            if (moduleId && modulePath) {

                //
                // Register the VCM in an internal database
                //

                b = pRegisterVcm (moduleId, modulePath, Reserved);

                cancelled = CheckCancel();

                if (!b) {
                    if (cancelled) {
                        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, moduleId));
                        break;
                    } else {
                        LOG ((LOG_INFORMATION, (PCSTR) MSG_IGNORE_MODULE, moduleId));
                    }
                }
            }

        } while (InfFindNextLine (&is));
    }

    if (cancelled) {
        return FALSE;
    }

    InfCleanUpInfStruct (&is);

    if (!b) {
        pFreeModuleTables();
    }

    return b;
}


BOOL
InitializeModules (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PVOID Reserved
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR modulePath;
    PCTSTR moduleId;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;

    __try {
        //
        // Initialize external modules
        //

        pAllocModuleTables();

        if (Platform == PLATFORM_SOURCE) {

            if (InfFindFirstLine (g_IsmInf, TEXT("Source Modules"), NULL, &is)) {

                do {

                    //
                    // A source gather module has an ID and module path
                    //

                    moduleId = InfGetStringField (&is, 0);
                    modulePath = InfGetStringField (&is, 1);

                    if (!ValidateModuleName (moduleId)) {
                        LOG ((LOG_WARNING, (PCSTR) MSG_INVALID_ID, moduleId));
                        continue;
                    }

                    if (moduleId && modulePath) {

                        //
                        // Register the source module in an internal database
                        //

                        b = pRegisterSm (moduleId, modulePath, Reserved);

                        cancelled = CheckCancel();

                        if (!b) {
                            if (cancelled) {
                                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, moduleId));
                                break;
                            } else {
                                LOG ((LOG_INFORMATION, (PCSTR) MSG_IGNORE_MODULE, moduleId));
                            }
                        }
                    }

                } while (InfFindNextLine (&is));
            }

            if (cancelled) {
                __leave;
            }

        } else if (g_IsmCurrentPlatform == PLATFORM_DESTINATION) {

            if (InfFindFirstLine (g_IsmInf, TEXT("Destination Modules"), NULL, &is)) {

                do {

                    //
                    // A destination module has an ID and module path
                    //

                    moduleId = InfGetStringField (&is, 0);
                    modulePath = InfGetStringField (&is, 1);

                    if (!ValidateModuleName (moduleId)) {
                        LOG ((LOG_WARNING, (PCSTR) MSG_INVALID_ID, moduleId));
                        continue;
                    }

                    if (moduleId && modulePath) {

                        //
                        // Register the destination module in an internal database
                        //

                        b = pRegisterDm (moduleId, modulePath, Reserved);

                        cancelled = CheckCancel();

                        if (!b) {
                            if (cancelled) {
                                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, moduleId));
                                break;
                            } else {
                                LOG ((LOG_INFORMATION, (PCSTR) MSG_IGNORE_MODULE, moduleId));
                            }
                        }
                    }

                } while (InfFindNextLine (&is));
            }

            if (cancelled) {
                __leave;
            }

        } else {
            DEBUGMSG ((DBG_ERROR, "InitializeModules: Unknown ISM current platform %d", g_IsmCurrentPlatform));
            cancelled = TRUE;
        }
    }
    __finally {
        if (cancelled) {
            pFreeModuleTables();
        }

        InfCleanUpInfStruct (&is);
    }

    return !cancelled;
}


VOID
TerminateModules (
    VOID
    )
{
    pFreeModuleTables();
}


BOOL
pStartEtmModules (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR modulePath;
    PCTSTR moduleId;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;

    MYASSERT (g_IsmInf != INVALID_HANDLE_VALUE);

    if (InfFindFirstLine (g_IsmInf, TEXT("Type Modules"), NULL, &is)) {

        do {
            //
            // An ETM has an ID and module path
            //

            moduleId = InfGetStringField (&is, 0);
            modulePath = InfGetStringField (&is, 1);

            if (!ValidateModuleName (moduleId)) {
                LOG ((LOG_WARNING, (PCSTR) MSG_INVALID_ID, moduleId));
                continue;
            }

            if (moduleId && modulePath) {

                //
                // Register the ETM in an internal database
                //

                b = pRegisterEtm (Platform, moduleId, modulePath, NULL);

                cancelled = CheckCancel();

                if (!b) {
                    if (cancelled) {
                        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, moduleId));
                        break;
                    } else {
                        LOG ((LOG_INFORMATION, (PCSTR) MSG_IGNORE_MODULE, moduleId));
                    }
                }
            }
        } while (InfFindNextLine (&is));
    }

    if (cancelled) {
        return FALSE;
    }

#ifdef PRERELEASE
    //
    // If pre-release, read in the exclusions from exclude.inf
    //
    {
        TCHAR path[MAX_PATH];
        PTSTR p;
        HINF inf;
        MIG_OBJECTSTRINGHANDLE handle;
        MIG_OBJECTTYPEID typeId;
        PCTSTR data;
        PCTSTR leaf;

        GetWindowsDirectory (path, MAX_PATH);

        p = _tcschr (path, TEXT('\\'));
        StringCopy (_tcsinc (p), TEXT("exclude.inf"));

        inf = InfOpenInfFile (path);
        if (inf && inf != INVALID_HANDLE_VALUE) {

            if (InfFindFirstLine (inf, TEXT("Objects"), NULL, &is)) {
                do {
                    data = InfGetStringField (&is, 1);
                    if (!data) {
                        continue;
                    }

                    typeId = IsmGetObjectTypeId (data);
                    if (!typeId) {
                        LOG ((LOG_ERROR, "EXCLUDE.INF: Invalid object exclusion type: %s", data));
                        continue;
                    }

                    data = InfGetStringField (&is, 2);
                    if (!data) {
                        LOG ((LOG_ERROR, "EXCLUDE.INF: Missing node object in field 2"));
                        continue;
                    }

                    leaf = InfGetStringField (&is, 3);
                    if (!leaf) {
                        LOG ((LOG_ERROR, "EXCLUDE.INF: Missing leaf object in field 3"));
                        continue;
                    }

                    handle = IsmCreateObjectHandle (data, leaf);
                    if (handle) {
                        IsmRegisterStaticExclusion (typeId, handle);
                        IsmDestroyObjectHandle (handle);
                    }

                } while (InfFindNextLine (&is));
            }

            if (InfFindFirstLine (inf, TEXT("Nodes"), NULL, &is)) {
                do {
                    data = InfGetStringField (&is, 1);
                    if (!data) {
                        continue;
                    }

                    typeId = IsmGetObjectTypeId (data);
                    if (!typeId) {
                        LOG ((LOG_ERROR, "EXCLUDE.INF: Invalid node exclusion type: %s", data));
                        continue;
                    }

                    data = InfGetStringField (&is, 2);
                    if (!data) {
                        LOG ((LOG_ERROR, "EXCLUDE.INF: Missing node object in field 2"));
                        continue;
                    }

                    handle = IsmCreateObjectHandle (data, NULL);
                    if (handle) {
                        IsmRegisterStaticExclusion (typeId, handle);
                        IsmDestroyObjectHandle (handle);
                    }

                } while (InfFindNextLine (&is));
            }

            if (InfFindFirstLine (inf, TEXT("Leaves"), NULL, &is)) {
                do {
                    data = InfGetStringField (&is, 1);
                    if (!data) {
                        continue;
                    }

                    typeId = IsmGetObjectTypeId (data);
                    if (!typeId) {
                        LOG ((LOG_ERROR, "EXCLUDE.INF: Invalid leaf exclusion type: %s", data));
                        continue;
                    }

                    data = InfGetStringField (&is, 2);
                    if (!data) {
                        LOG ((LOG_ERROR, "EXCLUDE.INF: Missing leaf object in field 2"));
                        continue;
                    }

                    handle = IsmCreateObjectHandle (NULL, data);
                    if (handle) {
                        IsmRegisterStaticExclusion (typeId, handle);
                        IsmDestroyObjectHandle (handle);
                    }

                } while (InfFindNextLine (&is));
            }

            InfCleanUpInfStruct (&is);
            InfCloseInfFile (inf);
        }

    }

#endif

    InfCleanUpInfStruct (&is);

    if (!b) {
        pFreeEtmTable ();
    }

    return b;
}


VOID
pFreeEtmTable (
    VOID
    )
{
    PETMDATA etmData;
    HASHTABLE_ENUM e;

    if (g_EtmTable) {
        if (EnumFirstHashTableString (&e, g_EtmTable)) {
            do {
                etmData = *((PETMDATA *) e.ExtraData);
                if (etmData) {
                    if (etmData->Initialized && etmData->EtmTerminate) {
                        etmData->EtmTerminate ();
                    }
                    if (etmData->EtmPath) {
                        pUnregisterModule (etmData->EtmPath);
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_EtmTable);
        g_EtmTable = NULL;
    }
}


BOOL
IsmStartEtmModules (
    VOID
    )
{
    BOOL result;

    if (CheckCancel ()) {
        return FALSE;
    }

    g_ExecutionInProgress = TRUE;

    if (!g_ModuleTable) {
        g_ModuleTable = HtAllocWithData (sizeof (PMODULEDATA));
    }

    if (!g_EtmTable) {
        g_EtmTable = HtAllocWithData (sizeof (PETMDATA));
    }

    result = pStartEtmModules (g_IsmCurrentPlatform);

#ifdef PRERELEASE
    LoadCrashHooks ();
#endif

    g_ExecutionInProgress = FALSE;

    return result;
}


BOOL
BroadcastUserCreation (
    IN      PTEMPORARYPROFILE UserProfile
    )
{
    PETMDATA etmData;
    HASHTABLE_ENUM e;

    if (g_EtmTable) {
        if (EnumFirstHashTableString (&e, g_EtmTable)) {
            do {
                etmData = *((PETMDATA *) e.ExtraData);
                if (etmData) {
                    if (etmData->Initialized && etmData->EtmNewUserCreated) {
                        etmData->EtmNewUserCreated (
                            UserProfile->UserName,
                            UserProfile->DomainName,
                            UserProfile->UserProfileRoot,
                            UserProfile->UserSid
                            );
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
    }
    return TRUE;
}


VOID
TerminateProcessWideModules (
    VOID
    )
{
    //
    // Terminate the phase-specific modules
    //

    TerminateModules();

    //
    // Terminate the process-wide modules: ETMs, transports

    //
    // Terminate Etm modules table
    //
    pFreeEtmTable ();

    //
    // Terminate all transport modules
    //
    pFreeTransportTable ();

    //
    // Enumerate all registered modules and verify that RefCount is 0
    //
    pFreeRegisteredModules ();
}


BOOL
IsmStartTransport (
    VOID
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR modulePath;
    PCTSTR moduleId;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;

    if (CheckCancel ()) {
        return FALSE;
    }

    g_ExecutionInProgress = TRUE;

    MYASSERT (g_IsmInf != INVALID_HANDLE_VALUE);

    if (InfFindFirstLine (g_IsmInf, TEXT("Transport Modules"), NULL, &is)) {

        do {

            //
            // A transport module has an ID and module path
            //

            moduleId = InfGetStringField (&is, 0);
            modulePath = InfGetStringField (&is, 1);

            if (!ValidateModuleName (moduleId)) {
                LOG ((LOG_WARNING, (PCSTR) MSG_INVALID_ID, moduleId));
                continue;
            }

            if (moduleId && modulePath) {

                //
                // Register the transport in an internal database
                //

                b = pRegisterTransport (moduleId, modulePath, NULL);

                cancelled = CheckCancel();

                if (!b) {
                    if (cancelled) {
                        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, moduleId));
                        break;
                    } else {
                        LOG ((LOG_INFORMATION, (PCSTR) MSG_IGNORE_MODULE, moduleId));
                    }
                }
            }

        } while (InfFindNextLine (&is));
    }

    if (!cancelled) {

        InfCleanUpInfStruct (&is);

        if (!b) {
            pFreeTransportTable ();
        }

    } else {
        b = FALSE;
    }

    g_ExecutionInProgress = FALSE;

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\ops.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ops.c

Abstract:

    Implements the operation interface for the ISM.  Operations are used to
    track changes to state.  An object can have any number of operations
    applied to it, as long as the combinations are legal. Each operation
    has an optional source and destination property per object.

Author:

    Jim Schmidt (jimschm) 01-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_OPS         "Ops"

//
// Strings
//

// None

//
// Constants
//

#define OP_HASH_BUCKETS         503

//
// Macros
//

// None

//
// Types
//

typedef struct {
    MIG_OPERATIONID OperationId;
    LONGLONG SrcData;
    LONGLONG DestData;
} OPERATION_PROPERTY_LINKAGE, *POPERATION_PROPERTY_LINKAGE;

typedef struct {
    PUINT LinkageList;
    UINT Count;
    UINT Index;
    POPERATION_PROPERTY_LINKAGE OpPropLinkList;
    UINT OpPropCount;
    GROWBUFFER SrcPropBuf;
    GROWBUFFER DestPropBuf;
    MIG_BLOB SrcData;
    MIG_BLOB DestData;
    BOOL ReturnAllPrivateOps;
} OBJECTOPERATION_HANDLE, *POBJECTOPERATION_HANDLE;

typedef struct {
    PUINT LinkageList;
    UINT Count;
    UINT Index;
    PCTSTR ObjectFromMemdb;
} OBJECTWITHOPERATION_HANDLE, *POBJECTWITHOPERATION_HANDLE;

typedef struct {
    POPMFILTERCALLBACK FilterCallbackHp;
    POPMFILTERCALLBACK FilterCallback;
    BOOL TreeFilterHp;
    BOOL TreeFilter;
    BOOL NoRestoreFilterHp;
    BOOL NoRestoreFilter;
    POPMAPPLYCALLBACK ApplyCallbackHp;
    POPMAPPLYCALLBACK ApplyCallback;
    UINT CombinationsCount;
    BOOL IgnoreCollision;
    MIG_OPERATIONID *Combinations;
} OPERATION_DATA, *POPERATION_DATA;

typedef struct TAG_OPERATION_DATA_ITEM {
    struct TAG_OPERATION_DATA_ITEM *NextBucketItem;
    MIG_OPERATIONID OperationId;
    POPERATION_DATA Data;
} OPERATION_DATA_ITEM, *POPERATION_DATA_ITEM;

typedef struct {
    MIG_OBJECTID ObjectId;
    PCMIG_BLOB SourceData;
    PCMIG_BLOB DestinationData;
    LONGLONG SourceDataOffset;
    LONGLONG DestinationDataOffset;
} SETOPERATIONARG, *PSETOPERATIONARG;

typedef struct {
    MIG_OBJECTID ObjectId;
    LONGLONG SourceDataOffset;
    LONGLONG DestinationDataOffset;
} SETOPERATIONARG2, *PSETOPERATIONARG2;

typedef struct TAG_GLOBALFILTER {

    struct TAG_GLOBALFILTER *Next, *Prev;
    UINT Priority;

    MIG_PLATFORMTYPEID Platform;
    MIG_OPERATIONID OperationId;
    POPMFILTERCALLBACK Callback;
    BOOL TreeFilter;
    BOOL NoRestoreFilter;

} GLOBALFILTER, *PGLOBALFILTER;

typedef struct TAG_GLOBALEDIT {

    struct TAG_GLOBALEDIT *Next, *Prev;
    UINT Priority;

    MIG_PLATFORMTYPEID Platform;
    MIG_OPERATIONID OperationId;
    POPMAPPLYCALLBACK Callback;

} GLOBALEDIT, *PGLOBALEDIT;

typedef struct TAG_GLOBALFILTERINDEX {
    struct TAG_GLOBALFILTERINDEX *Next;
    MIG_OBJECTTYPEID ObjectTypeId;

    // normal priority
    PGLOBALFILTER FilterFirstHead;
    PGLOBALFILTER FilterLastHead;
    PGLOBALEDIT EditFirstHead;
    PGLOBALEDIT EditLastHead;

    // high priority
    PGLOBALFILTER FilterFirstHeadHp;
    PGLOBALFILTER FilterLastHeadHp;
    PGLOBALEDIT EditFirstHeadHp;
    PGLOBALEDIT EditLastHeadHp;
} GLOBALFILTERINDEX, *PGLOBALFILTERINDEX;

//
// Globals
//

PMHANDLE g_OpPool;
OPERATION_DATA_ITEM g_OpHashTable[OP_HASH_BUCKETS];
PGLOBALFILTERINDEX g_FirstGlobalOperation;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

MIG_OPERATIONID
pRegisterOperation (
    IN      PCTSTR OperationName,
    IN      BOOL Private,
    IN      PCTSTR CurrentGroup
    );

//
// Macro expansion definition
//

// None

//
// Code
//

PCTSTR
pGetOpNameForDebug (
    IN      MIG_OPERATIONID OperationId
    )
{
    static TCHAR Name[256];

    if (!IsmGetOperationName (OperationId, Name, ARRAYSIZE(Name), NULL, NULL, NULL)) {
        StringCopy (Name, TEXT("<invalid operation>"));
    }

    return Name;
}


PCTSTR
pGetOpNameForDebug2 (
    IN      MIG_OPERATIONID OperationId
    )
{
    static TCHAR Name[256];

    if (!IsmGetOperationName (OperationId, Name, ARRAYSIZE(Name), NULL, NULL, NULL)) {
        StringCopy (Name, TEXT("<invalid operation>"));
    }

    return Name;
}


UINT
pComputeOperationHash (
    IN      MIG_OPERATIONID OperationId
    )
{
    return (UINT) OperationId % OP_HASH_BUCKETS;
}


POPERATION_DATA_ITEM
pFindOperationBucketItem (
    IN      MIG_OPERATIONID OperationId
    )
{
    UINT hash;
    POPERATION_DATA_ITEM item;

    hash = pComputeOperationHash (OperationId);

    item = &g_OpHashTable[hash];

    do {
        if (item->OperationId == OperationId) {
            return item;
        }

        item = item->NextBucketItem;

    } while (item);

    return NULL;
}


POPERATION_DATA_ITEM
pGetOperationBucketItem (
    IN      MIG_OPERATIONID OperationId
    )
{
    POPERATION_DATA_ITEM item;
    POPERATION_DATA_ITEM newItem;
    UINT hash;

    hash = pComputeOperationHash (OperationId);

    item = &g_OpHashTable[hash];

    if (item->OperationId) {
        //
        // Find the last bucket item, then allocate a new bucket item
        //

        while (item->NextBucketItem) {
            item = item->NextBucketItem;
        }

        newItem = (POPERATION_DATA_ITEM) PmGetMemory (g_OpPool, sizeof (OPERATION_DATA_ITEM));
        ZeroMemory (newItem, sizeof (OPERATION_DATA_ITEM));

        item->NextBucketItem = newItem;
        item = newItem;
    }

    item->OperationId = OperationId;
    item->Data = NULL;

    return item;
}


VOID
pUpdateOperationData (
    IN      MIG_OPERATIONID OperationId,
    IN      POPERATION_DATA Data
    )
{
    POPERATION_DATA_ITEM item;

    item = pFindOperationBucketItem (OperationId);
    MYASSERT (item);
    MYASSERT (item->Data);

    CopyMemory (item->Data, Data, sizeof (OPERATION_DATA));
}


BOOL
pGetOperationData (
    IN      MIG_OPERATIONID OperationId,
    OUT     POPERATION_DATA Data
    )
{
    POPERATION_DATA_ITEM item;

    item = pFindOperationBucketItem (OperationId);

    if (!item) {
        ZeroMemory (Data, sizeof (OPERATION_DATA));

        item = pGetOperationBucketItem (OperationId);
        MYASSERT (item);
        MYASSERT (!item->Data);

        item->Data = (POPERATION_DATA) PmDuplicateMemory (
                                            g_OpPool,
                                            (PBYTE) Data,
                                            sizeof (OPERATION_DATA)
                                            );
        return TRUE;
    }

    CopyMemory (Data, item->Data, sizeof (OPERATION_DATA));

    return TRUE;
}


VOID
pAddCombinationPair (
    IN      MIG_OPERATIONID OperationIdToChange,
    IN      MIG_OPERATIONID OperationIdForTheComboList
    )
{
    OPERATION_DATA data;

    //
    // If a data struct does not exist, create one
    //

    if (!pGetOperationData (OperationIdToChange, &data)) {
        return;
    }

    if (!data.Combinations) {

        data.Combinations = (MIG_OPERATIONID *) PmGetMemory (
                                                    g_OpPool,
                                                    sizeof (MIG_OPERATIONID)
                                                    );
        data.CombinationsCount = 0;

    } else {

        data.Combinations = (MIG_OPERATIONID *) PmGetMemory (
                                                    g_OpPool,
                                                    (data.CombinationsCount + 1) * sizeof (MIG_OPERATIONID)
                                                    );
    }

    MYASSERT (data.Combinations);

    data.Combinations[data.CombinationsCount] = OperationIdForTheComboList;
    data.CombinationsCount++;

    pUpdateOperationData (OperationIdToChange, &data);
}


BOOL
pTestOperationCombination (
    IN      MIG_OPERATIONID OperationId1,
    IN      MIG_OPERATIONID OperationId2,
    OUT     PBOOL IgnoreCollision
    )

/*++

Routine Description:

  pTestOperationCombination tests if two operations can be combined. The
  return result indicates if the combination is prohibited.

Arguments:

  OperationId1 - Specifies the first operation to test.  The ID must be
                 valid.

  OperationId2 - Specifies the second operation to test. This ID must also be
                 valid.

  IgnoreCollision - Receives that the collision is ignored

Return Value:

  TRUE if the combination is prohibited, or FALSE if it is allowed.

--*/

{
    POPERATION_DATA_ITEM item;
    POPERATION_DATA data;
    UINT u;

    item = pFindOperationBucketItem (OperationId1);
    if (!item) {
        return FALSE;
    }

    data = item->Data;
    if (!data) {
        return FALSE;
    }

    for (u = 0 ; u < data->CombinationsCount ; u++) {
        if (data->Combinations[u] == OperationId2) {
            if (IgnoreCollision) {
                *IgnoreCollision = data->IgnoreCollision;
            }
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
pIsOperationProhibitedOnObject (
    IN      MIG_OPERATIONID OperationIdToTest,
    IN      MIG_OBJECTID ObjectId,
    IN      BOOL NoDebugOutput
    )
{
    UINT count;
    UINT u;
    KEYHANDLE *list = NULL;
    BOOL result = TRUE;
    BOOL ignoreCollision;
    POPERATION_DATA_ITEM item;

    __try {

        //
        // First check if this operation is prohibited to be combined with another operation
        //

        item = pFindOperationBucketItem (OperationIdToTest);
        if (!item || !item->Data || !item->Data->CombinationsCount) {
            //
            // No prohibited pairs exist; return now
            //

            result = FALSE;
            __leave;
        }

        //
        // Now check each operation set on ObjectId against the prohibited ID list
        //

        list = MemDbGetDoubleLinkageArrayByKeyHandle (ObjectId, OPERATION_INDEX, &count);

        if (list) {
            count /= sizeof (KEYHANDLE);

            for (u = 0 ; u < count ; u++) {

                if ((MIG_OPERATIONID) list[u] == OperationIdToTest) {
                    DEBUGMSG ((
                        DBG_VERBOSE,
                        "Operation %s already set on object %s; ignoring subsequent set",
                        pGetOpNameForDebug (OperationIdToTest),
                        GetObjectNameForDebugMsg (ObjectId)
                        ));
                    __leave;
                }

                if (pTestOperationCombination (OperationIdToTest, (MIG_OPERATIONID) list[u], &ignoreCollision)) {
                    if (!ignoreCollision &&
                        !NoDebugOutput) {
                        DEBUGMSG ((
                            DBG_ERROR,
                            "Can't set operation %s because it conflicts with %s",
                            pGetOpNameForDebug (OperationIdToTest),
                            pGetOpNameForDebug2 ((MIG_OPERATIONID) list[u])
                            ));
                    }
                    __leave;
                }
            }
        }

        //
        // All operations set on ObjectId are allowed to be combined with OperationIdToTest
        //

        result = FALSE;
    }
    __finally {
        if (list) {
            MemDbReleaseMemory (list);
            INVALID_POINTER (list);
        }
    }

    return result;
}


PCTSTR
pOperationPathFromId (
    IN      MIG_OPERATIONID OperationId
    )
{
    return MemDbGetKeyFromHandle ((UINT) OperationId, 0);
}


VOID
pOperationPathFromName (
    IN      PCTSTR OperationName,
    OUT     PTSTR Path
    )
{
    wsprintf (Path, TEXT("Op\\%s"), OperationName);
}


LONGLONG
pGetOffsetFromDataHandle (
    IN      MIG_DATAHANDLE DataHandle
    )
{
    if (!DataHandle) {
        return 0;
    }

    return OffsetFromPropertyDataId ((MIG_PROPERTYDATAID) DataHandle);
}


BOOL
pAddProhibitedCombinations (
    IN      PCTSTR InfSection
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    BOOL b = FALSE;
    PCTSTR mainOp;
    PCTSTR mainOpModule;
    PCTSTR combinationOp;
    PCTSTR combinationOpModule;
    UINT u;
    MIG_OPERATIONID mainOpId;
    MIG_OPERATIONID combinationOpId;
    PTSTR p;

    //
    // The INF tells us about prohibited operation combinations.  Given a
    // specific operation ID, we need to be able to tell if it can be
    // combined with another id.
    //

    __try {
        if (InfFindFirstLine (g_IsmInf, InfSection, NULL, &is)) {
            do {

                mainOp = InfGetStringField (&is, 1);

                if (!mainOp) {
                    continue;
                }

                p = _tcschr (mainOp, TEXT(':'));

                if (p) {
                    mainOpModule = mainOp;
                    *p = 0;
                    mainOp = p + 1;

                    if (!ValidateModuleName (mainOpModule)) {
                        LOG ((
                            LOG_WARNING,
                            (PCSTR) MSG_INVALID_ID_OPS,
                            mainOpModule,
                            InfSection,
                            is.Context.Line + 1
                            ));
                        continue;
                    }

                } else {
                    mainOpModule = NULL;
                }

                mainOpId = pRegisterOperation (mainOp, mainOpModule != NULL, mainOpModule);

                if (!mainOpId) {
                    LOG ((
                        LOG_WARNING,
                        (PCSTR) MSG_ISM_INF_SYNTAX_ERROR,
                        InfSection,
                        is.Context.Line + 1
                        ));
                    continue;
                }

                u = 2;
                for (;; u++) {
                    combinationOp = InfGetStringField (&is, u);
                    if (!combinationOp) {
                        break;
                    }

                    p = _tcschr (combinationOp, TEXT(':'));

                    if (p) {
                        combinationOpModule = combinationOp;
                        *p = 0;
                        combinationOp = p + 1;

                        if (!ValidateModuleName (combinationOpModule)) {
                            LOG ((
                                LOG_WARNING,
                                (PCSTR) MSG_INVALID_ID_OPS,
                                combinationOpModule,
                                InfSection,
                                is.Context.Line + 1
                                ));
                            continue;
                        }

                    } else {
                        combinationOpModule = NULL;
                    }

                    combinationOpId = pRegisterOperation (
                                            combinationOp,
                                            combinationOpModule != NULL,
                                            combinationOpModule
                                            );

                    if (!combinationOpId) {
                        LOG ((
                            LOG_WARNING,
                            (PCSTR) MSG_ISM_INF_SYNTAX_ERROR,
                            InfSection,
                            is.Context.Line + 1
                            ));
                        continue;
                    }

                    pAddCombinationPair (mainOpId, combinationOpId);
                    pAddCombinationPair (combinationOpId, mainOpId);
                }

            } while (InfFindNextLine (&is));
        }

        b = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (&is);
    }

    return b;
}


VOID
pAddIgnoredCollision (
    IN      MIG_OPERATIONID OperationIdToChange
    )
{
    OPERATION_DATA data;

    //
    // If a data struct does not exist, create one
    //

    if (!pGetOperationData (OperationIdToChange, &data)) {
        return;
    }

    data.IgnoreCollision = TRUE;

    pUpdateOperationData (OperationIdToChange, &data);
}


BOOL
pAddIgnoredCollisions (
    IN      PCTSTR InfSection
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    BOOL b = FALSE;
    PCTSTR mainOp;
    PCTSTR mainOpModule;
    MIG_OPERATIONID mainOpId;
    PTSTR p;

    //
    // The INF tells us about ignored operation collisions.
    //

    __try {
        if (InfFindFirstLine (g_IsmInf, InfSection, NULL, &is)) {
            do {

                mainOp = InfGetStringField (&is, 1);

                if (!mainOp) {
                    continue;
                }

                p = _tcschr (mainOp, TEXT(':'));

                if (p) {
                    mainOpModule = mainOp;
                    *p = 0;
                    mainOp = p + 1;

                    if (!ValidateModuleName (mainOpModule)) {
                        LOG ((
                            LOG_WARNING,
                            (PCSTR) MSG_INVALID_ID_OPS,
                            mainOpModule,
                            InfSection,
                            is.Context.Line + 1
                            ));
                        continue;
                    }

                } else {
                    mainOpModule = NULL;
                }

                mainOpId = pRegisterOperation (mainOp, mainOpModule != NULL, mainOpModule);

                if (!mainOpId) {
                    LOG ((
                        LOG_WARNING,
                        (PCSTR) MSG_ISM_INF_SYNTAX_ERROR,
                        InfSection,
                        is.Context.Line + 1
                        ));
                    continue;
                }

                pAddIgnoredCollision (mainOpId);

            } while (InfFindNextLine (&is));
        }

        b = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (&is);
    }

    return b;
}


BOOL
InitializeOperations (
    VOID
    )
{
    //
    // The INF tells us about prohibited operation combinations.  Given a
    // specific operation ID, we need to be able to tell if it can be
    // combined with another id.
    //

    g_OpPool = PmCreateNamedPool ("Operation Data");

    if (!pAddIgnoredCollisions (S_IGNORED_COLLISIONS)) {
        return FALSE;
    }

    return pAddProhibitedCombinations (S_PROHIBITED_COMBINATIONS);
}


VOID
TerminateOperations (
    VOID
    )
{
    PmEmptyPool (g_OpPool);
    PmDestroyPool (g_OpPool);
    ZeroMemory (&g_OpHashTable, sizeof (g_OpHashTable));
}


MIG_OPERATIONID
pRegisterOperation (
    IN      PCTSTR OperationName,
    IN      BOOL Private,
    IN      PCTSTR CurrentGroup
    )

{
    TCHAR operationPath[MEMDB_MAX];
    TCHAR decoratedName[MEMDB_MAX];
    UINT offset;

    if (!IsValidCNameWithDots (OperationName)) {
        DEBUGMSG ((DBG_ERROR, "operation name \"%s\" is illegal", OperationName));
        return FALSE;
    }

#ifdef DEBUG
    if (Private && !IsValidCName (CurrentGroup)) {
        DEBUGMSG ((DBG_ERROR, "group name \"%s\" is illegal", CurrentGroup));
        return FALSE;
    }
#endif

    if (Private) {
        wsprintf (decoratedName, TEXT("%s:%s"), CurrentGroup, OperationName);
    } else {
        wsprintf (decoratedName, S_COMMON TEXT(":%s"), OperationName);
    }

    pOperationPathFromName (decoratedName, operationPath);

    if (!MarkGroupIds (operationPath)) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s conflicts with previously registered operation",
            operationPath
            ));
        return FALSE;
    }

    offset = MemDbSetKey (operationPath);

    if (!offset) {
        EngineError ();
        return 0;
    }

    return (MIG_OPERATIONID) offset;
}


MIG_OPERATIONID
IsmRegisterOperation (
    IN      PCTSTR OperationName,
    IN      BOOL Private
    )

/*++

Routine Description:

  IsmRegisterOperation creates a public or private Operation and returns the
  ID to the caller. If the Operation already exists, then the existing ID is
  returned to the caller.

Arguments:

  OperationName - Specifies the operation name to register.
  Private       - Specifies TRUE if the operation is owned by the calling module
                  only, or FALSE if it is shared by all modules. If TRUE is
                  specified, the caller must be in an ISM callback function.

Return Value:

  The ID of the operation, or 0 if the registration failed.

--*/

{
    if (!g_CurrentGroup && Private) {
        DEBUGMSG ((DBG_ERROR, "IsmRegisterOperation called for private operation outside of ISM-managed context"));
        return 0;
    }

    return pRegisterOperation (OperationName, Private, g_CurrentGroup);
}


MIG_OPERATIONID
IsmGetOperationGroup (
    IN      MIG_OPERATIONID OperationId
    )
{
    return (MIG_OPERATIONID) GetGroupOfId ((KEYHANDLE) OperationId);
}


PGLOBALFILTERINDEX
pGetGlobalIndex (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      BOOL Create
    )
{
    PGLOBALFILTERINDEX index;

    ObjectTypeId &= (~PLATFORM_MASK);

    index = g_FirstGlobalOperation;
    while (index) {
        if (index->ObjectTypeId == ObjectTypeId) {
            break;
        }

        index = index->Next;
    }

    if (!index && Create) {
        index = (PGLOBALFILTERINDEX) PmGetMemory (g_IsmUntrackedPool, sizeof (GLOBALFILTERINDEX));

        ZeroMemory (index, sizeof (GLOBALFILTERINDEX));

        index->Next = g_FirstGlobalOperation;
        index->ObjectTypeId = ObjectTypeId;

        g_FirstGlobalOperation = index;
    }

    return index;
}


BOOL
IsmRegisterGlobalFilterCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR FunctionId,
    IN      POPMFILTERCALLBACK Callback,
    IN      BOOL TreeFilter,
    IN      BOOL CanHandleNoRestore
    )

/*++

Routine Description:

  IsmRegisterGlobalFilterCallback adds a filter to the "global" filter list.
  Functions are prioritized by the ism.inf section [Global Filters]. If a
  function is not listed, or if no name is given, it has the lowest priority.
  In addition, global filters can be prohibited from being processed with
  another non-global filter through the [Prohibit Operation Combination]
  section of ism.inf.

Arguments:

  ObjectTypeId - Specifies the type of the object

  FunctionId - Specifies the text name of the callback function, for purposes
               of prioritizing and combination management

  Callback - Specifies the function address to call

  TreeFilter - Specifies TRUE if the callback potentially modifies a portion
               of an object's node, or FALSE if it modifies the node completely
               or doesn't modify the node at all

Return Value:

  TRUE on success, FALSE on failure

--*/

{
    PGLOBALFILTERINDEX index;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PGLOBALFILTER filter;
    PGLOBALFILTER *head;
    PGLOBALFILTER insertAt;

    if (!FunctionId) {
        DEBUGMSG ((DBG_ERROR, "All global filters must have a text function ID"));
        return FALSE;
    }

    //
    // Locate the index for our type
    //

    index = pGetGlobalIndex (ObjectTypeId, TRUE);

    //
    // Allocate a new filter node
    //

    filter = (PGLOBALFILTER) PmGetMemory (g_IsmUntrackedPool, sizeof (GLOBALFILTER));
    filter->Platform = ObjectTypeId & PLATFORM_MASK;
    filter->OperationId = IsmRegisterOperation (FunctionId, FALSE);
    filter->TreeFilter = TreeFilter;
    filter->Callback = Callback;
    filter->NoRestoreFilter = CanHandleNoRestore;

    //
    // Insert the node into the list by priority
    //

    if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Filter First"), FunctionId, &is)) {

        filter->Priority = is.Context.Line;
        head = &index->FilterFirstHead;

    } else if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Filter Last"), FunctionId, &is)) {

        filter->Priority = is.Context.Line;
        head = &index->FilterLastHead;

    } else if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Filter First.High Priority"), FunctionId, &is)) {

        filter->Priority = is.Context.Line;
        head = &index->FilterFirstHeadHp;

    } else if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Filter Last.High Priority"), FunctionId, &is)) {

        filter->Priority = is.Context.Line;
        head = &index->FilterLastHead;

    } else {

        filter->Priority = 0xFFFFFFFF;
        head = &index->FilterLastHead;
    }

    insertAt = *head;

    while (insertAt) {
        if (insertAt->Priority >= filter->Priority) {
            insertAt = insertAt->Prev;
            break;
        }

        insertAt = insertAt->Next;
    }

    if (insertAt) {
        filter->Next = insertAt->Next;
        insertAt->Next = filter;

        if (filter->Next) {
            filter->Next->Prev = filter;
        }
    } else {
        *head = filter;
        filter->Next = NULL;
    }

    filter->Prev = insertAt;

    InfCleanUpInfStruct (&is);

    return TRUE;
}


BOOL
IsmRegisterOperationFilterCallback (
    IN      MIG_OPERATIONID OperationId,
    IN      POPMFILTERCALLBACK Callback,
    IN      BOOL TreeFilter,
    IN      BOOL HighPriority,
    IN      BOOL CanHandleNoRestore
    )
{
    OPERATION_DATA data;

    //
    // If a data struct does not exist, create one
    //

    if (!pGetOperationData (OperationId, &data)) {
        return FALSE;
    }

    if (HighPriority) {

        if (data.FilterCallbackHp) {
            DEBUGMSG ((DBG_ERROR, "High Priority Filter Callback for operation 0x%08X already registered", OperationId));
            return FALSE;
        }

        data.FilterCallbackHp = Callback;
        data.TreeFilterHp = TreeFilter;
        data.NoRestoreFilterHp = CanHandleNoRestore;

    } else {

        if (data.FilterCallback) {
            DEBUGMSG ((DBG_ERROR, "Filter Callback for operation 0x%08X already registered", OperationId));
            return FALSE;
        }

        data.FilterCallback = Callback;
        data.TreeFilter = TreeFilter;
        data.NoRestoreFilter = CanHandleNoRestore;

    }

    pUpdateOperationData (OperationId, &data);

    return TRUE;
}


BOOL
WINAPI
IsmRegisterGlobalApplyCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR FunctionId,
    IN      POPMAPPLYCALLBACK Callback
    )
{
    PGLOBALFILTERINDEX index;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PGLOBALEDIT editFn;
    PGLOBALEDIT *head;
    PGLOBALEDIT insertAt;

    if (!FunctionId) {
        DEBUGMSG ((DBG_ERROR, "All global content editor callbacks must have a text function ID"));
        return FALSE;
    }

    //
    // Locate the index for our type
    //

    index = pGetGlobalIndex (ObjectTypeId, TRUE);

    //
    // Allocate a new content edit node
    //

    editFn = (PGLOBALEDIT) PmGetMemory (g_IsmUntrackedPool, sizeof (GLOBALEDIT));
    editFn->Platform = ObjectTypeId & PLATFORM_MASK;
    editFn->OperationId = IsmRegisterOperation (FunctionId, FALSE);
    editFn->Callback = Callback;

    //
    // Insert the node into the list by priority
    //

    if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Apply First"), FunctionId, &is)) {

        editFn->Priority = is.Context.Line;
        head = &index->EditFirstHead;

    } else if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Apply Last"), FunctionId, &is)) {

        editFn->Priority = is.Context.Line;
        head = &index->EditLastHead;

    } else if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Apply First.High Priority"), FunctionId, &is)) {

        editFn->Priority = is.Context.Line;
        head = &index->EditFirstHeadHp;

    } else if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Apply Last.High Priority"), FunctionId, &is)) {

        editFn->Priority = is.Context.Line;
        head = &index->EditLastHead;

    } else {

        editFn->Priority = 0xFFFFFFFF;
        head = &index->EditLastHead;
    }

    insertAt = *head;

    while (insertAt) {
        if (insertAt->Priority >= editFn->Priority) {
            insertAt = insertAt->Prev;
            break;
        }

        insertAt = insertAt->Next;
    }

    if (insertAt) {
        editFn->Next = insertAt->Next;
        insertAt->Next = editFn;

        if (editFn->Next) {
            editFn->Next->Prev = editFn;
        }
    } else {
        *head = editFn;
        editFn->Next = NULL;
    }

    editFn->Prev = insertAt;

    InfCleanUpInfStruct (&is);

    return TRUE;
}


BOOL
IsmRegisterOperationApplyCallback (
    IN      MIG_OPERATIONID OperationId,
    IN      POPMAPPLYCALLBACK Callback,
    IN      BOOL HighPriority
    )
{
    OPERATION_DATA data;

    //
    // If a data struct does not exist, create one
    //

    if (!pGetOperationData (OperationId, &data)) {
        return FALSE;
    }

    if (HighPriority) {
        if (data.ApplyCallbackHp) {
            DEBUGMSG ((
                DBG_ERROR,
                "High Priority Apply Callback for operation %s already registered",
                pGetOpNameForDebug (OperationId)
                ));
            return FALSE;
        }

        data.ApplyCallbackHp = Callback;

    } else {
        if (data.ApplyCallback) {
            DEBUGMSG ((
                DBG_ERROR,
                "Apply Callback for operation %s already registered",
                pGetOpNameForDebug (OperationId)
                ));
            return FALSE;
        }

        data.ApplyCallback = Callback;
    }

    pUpdateOperationData (OperationId, &data);

    return TRUE;
}

BOOL
pGetOperationName (
    IN      MIG_OPERATIONID OperationId,
    OUT     PTSTR OperationName,            OPTIONAL
    IN      UINT OperationNameBufChars,
    OUT     PBOOL Private,                  OPTIONAL
    OUT     PBOOL BelongsToMe,              OPTIONAL
    OUT     PUINT ObjectReferences,         OPTIONAL
    IN      BOOL ReturnAllPrivateOps
    )

/*++

Routine Description:

  pGetOperationName obtains the operation text name from a numeric ID. It
  also identifies private and owned operations.

Arguments:

  OperationId           - Specifies the operation ID to look up.
  OperationName         - Receives the operation name. The name is filled for
                          all valid OperationId values, even when the return
                          value is FALSE.
  OperationNameBufChars - Specifies the number of TCHARs that OperationName
                          can hold, including the nul terminator.
  Private               - Receives TRUE if the operation is private, or FALSE
                          if it is public.
  BelongsToMe           - Receives TRUE if the operation is private and
                          belongs to the caller, FALSE otherwise.
  ObjectReferences      - Receives the number of objects that reference the
                          operation

Return Value:

  TRUE if the operation is public, or if the operation is private and belongs to
  the caller.

  FALSE if the operation is private and belongs to someone else. OperationName,
  Private and BelongsToMe are valid in this case.

  FALSE if OperationId is not valid. Operationname, Private and BelongsToMe are
  not modified in this case.  Do not use this function to test if OperationId
  is valid or not.

--*/


  {
    PCTSTR operationPath = NULL;
    PCTSTR start;
    PTSTR p, q;
    BOOL privateOperation = FALSE;
    BOOL groupMatch = FALSE;
    BOOL result = FALSE;
    UINT references;
    PUINT linkageList;

    __try {
        //
        // Did caller specify an item id?
        //

        if (!IsItemId ((KEYHANDLE) OperationId)) {
            DEBUGMSG ((
                DBG_ERROR,
                "IsmGetOperationName: must specify item id, not group id"
                ));
            __leave;
        }

        //
        // Get the operation path from memdb, then parse it for group and name
        //

        operationPath = pOperationPathFromId (OperationId);
        if (!operationPath) {
            __leave;
        }

        p = _tcschr (operationPath, TEXT('\\'));
        if (!p) {
            __leave;
        }

        start = _tcsinc (p);
        p = _tcschr (start, TEXT(':'));

        if (!p) {
            __leave;
        }

        q = _tcsinc (p);
        *p = 0;

        if (StringIMatch (start, S_COMMON)) {

            //
            // This operation is a global operation.
            //

            privateOperation = FALSE;
            groupMatch = TRUE;

        } else if (g_CurrentGroup || ReturnAllPrivateOps) {

            //
            // This operation is private. Check if it is ours.
            //

            privateOperation = TRUE;

            if (g_CurrentGroup && StringIMatch (start, g_CurrentGroup)) {
                groupMatch = TRUE;
            } else {
                groupMatch = ReturnAllPrivateOps;
            }
        } else {

            //
            // This is a private operation, but the caller is not
            // a module that can own operations.
            //

            DEBUGMSG ((DBG_WARNING, "IsmGetOperationName: Caller cannot own private operations"));
        }

        //
        // Copy the name to the buffer, update outbound BOOLs, set result
        //

        if (OperationName && OperationNameBufChars >= sizeof (TCHAR)) {
            StringCopyByteCount (OperationName, q, OperationNameBufChars * sizeof (TCHAR));
        }

        if (Private) {
            *Private = privateOperation;
        }

        if (BelongsToMe) {
            *BelongsToMe = privateOperation && groupMatch;
        }

        if (ObjectReferences) {
            linkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                OperationId,
                                OPERATION_INDEX,
                                &references
                                );

            references /= SIZEOF(KEYHANDLE);

            if (linkageList) {
                MemDbReleaseMemory (linkageList);
                INVALID_POINTER (linkageList);
            } else {
                references = 0;
            }

            *ObjectReferences = references;
        }

        if (groupMatch) {
            result = TRUE;
        }
    }
    __finally {
        if (operationPath) {       //lint !e774
            MemDbReleaseMemory (operationPath);
            operationPath = NULL;
        }
    }
    return result;
}


BOOL
IsmGetOperationName (
    IN      MIG_OPERATIONID OperationId,
    OUT     PTSTR OperationName,            OPTIONAL
    IN      UINT OperationNameBufChars,
    OUT     PBOOL Private,                  OPTIONAL
    OUT     PBOOL BelongsToMe,              OPTIONAL
    OUT     PUINT ObjectReferences          OPTIONAL
    )
{
    return pGetOperationName (
                OperationId,
                OperationName,
                OperationNameBufChars,
                Private,
                BelongsToMe,
                ObjectReferences,
                FALSE
                );
}

POPERATION_PROPERTY_LINKAGE
pFindOperationPropertyLinkage (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationIdToFind,
    OUT     PBYTE *BlockToFree,
    OUT     PUINT BlockSize
    )
{
    POPERATION_PROPERTY_LINKAGE linkage;
    UINT linkageCount;
    POPERATION_PROPERTY_LINKAGE result = NULL;
    UINT u;

    __try {
        linkage = (POPERATION_PROPERTY_LINKAGE) MemDbGetUnorderedBlobByKeyHandle (
                                                    ObjectId,
                                                    OPERATION_INDEX,
                                                    BlockSize
                                                    );

        linkageCount = *BlockSize / sizeof (OPERATION_PROPERTY_LINKAGE);

        if (!linkage || !linkageCount) {
            __leave;
        }

        for (u = 0 ; u < linkageCount ; u++) {

            if (linkage[u].OperationId == OperationIdToFind) {
                result = linkage + u;
                break;
            }

        }
    }
    __finally {
        if (!result && linkage) {
            MemDbReleaseMemory (linkage);
            INVALID_POINTER (linkage);
        } else {
            *BlockToFree = (PBYTE) linkage;
        }
    }

    return result;
}


BOOL
pSetOperationOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    IN      PCMIG_BLOB SourceData,          OPTIONAL
    IN      PCMIG_BLOB DestinationData,     OPTIONAL
    IN      BOOL QueryOnly,
    IN OUT  PLONGLONG SourceDataOffset,         OPTIONAL
    IN OUT  PLONGLONG DestinationDataOffset     OPTIONAL
    )
{
    BOOL result = FALSE;
    OPERATION_PROPERTY_LINKAGE linkage;
    POPERATION_PROPERTY_LINKAGE reuseLinkage;
    PBYTE freeMe;
    UINT linkageSize;
    KEYHANDLE *list = NULL;

    __try {
        //
        // Is the operation or object locked?
        //

        if (TestLock (ObjectId, (KEYHANDLE) OperationId)) {
            SetLastError (ERROR_LOCKED);
            DEBUGMSG ((
                DBG_WARNING,
                "Can't set operation %s on %s because of lock",
                pGetOpNameForDebug (OperationId),
                GetObjectNameForDebugMsg (ObjectId)
                ));
            __leave;
        }

        //
        // Does this operation conflict with itself or another operation?
        //

        if (pIsOperationProhibitedOnObject (OperationId, ObjectId, FALSE)) {
            __leave;
        }

        //
        // If query only, return success
        //

        if (QueryOnly) {
            result = TRUE;
            __leave;
        }

        //
        // Add the operaiton.  First, store the properties in property.dat
        //

        ZeroMemory (&linkage, sizeof (linkage));

        if (SourceData || SourceDataOffset) {

            if (SourceDataOffset && *SourceDataOffset) {
                linkage.SrcData = *SourceDataOffset;
            } else {
                linkage.SrcData = AppendProperty (SourceData);

                if (!linkage.SrcData) {
                    DEBUGMSG ((DBG_ERROR, "Can't append src property"));
                    __leave;
                }

                if (SourceDataOffset) {
                    *SourceDataOffset = linkage.SrcData;
                }
            }
        }

        if (DestinationData || DestinationDataOffset) {

            if (DestinationDataOffset && *DestinationDataOffset) {
                linkage.DestData = *DestinationDataOffset;
            } else {
                linkage.DestData = AppendProperty (DestinationData);

                if (!linkage.DestData) {
                    DEBUGMSG ((DBG_ERROR, "Can't append dest property"));
                    __leave;
                }

                if (DestinationDataOffset) {
                    *DestinationDataOffset = linkage.DestData;
                }
            }
        }

        //
        // Establish linkage between the object, operation and properties
        //

        if (SourceData || SourceDataOffset ||
            DestinationData || DestinationDataOffset
            ) {

            linkage.OperationId = OperationId;

            reuseLinkage = pFindOperationPropertyLinkage (
                                ObjectId,
                                0,
                                &freeMe,
                                &linkageSize
                                );

            if (reuseLinkage) {
                //
                // Recovery case -- reuse an empty spot in the blob
                //

                CopyMemory (reuseLinkage, &linkage, sizeof (linkage));

                if (!MemDbSetUnorderedBlobByKeyHandle (
                        ObjectId,
                        OPERATION_INDEX,
                        freeMe,
                        linkageSize
                        )) {
                    DEBUGMSG ((DBG_ERROR, "Can't update unordered operation blob"));
                    __leave;
                }

                MemDbReleaseMemory (freeMe);
                INVALID_POINTER (freeMe);

            } else {
                //
                // New case -- add the struct to the end of the blob
                //

                if (!MemDbGrowUnorderedBlobByKeyHandle (
                            ObjectId,
                            OPERATION_INDEX,
                            (PBYTE) &linkage,
                            sizeof (linkage)
                            )) {

                    DEBUGMSG ((DBG_ERROR, "Can't grow operation property linkage"));
                    __leave;

                }
            }
        }

        if (!MemDbAddDoubleLinkageByKeyHandle (ObjectId, OperationId, OPERATION_INDEX)) {
            DEBUGMSG ((DBG_ERROR, "Can't link object to operation"));
            EngineError ();
            __leave;
        }

        result = TRUE;
    }
    __finally {
        if (list) {
            MemDbReleaseMemory (list);
            INVALID_POINTER (list);
        }
    }

    return result;
}


BOOL
pSetOperationGroup (
    IN      KEYHANDLE OperationId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    PSETOPERATIONARG myArg = (PSETOPERATIONARG) Arg;

    return pSetOperationOnObjectId (
                myArg->ObjectId,
                (MIG_OPERATIONID) OperationId,
                myArg->SourceData,
                myArg->DestinationData,
                FirstPass,
                &myArg->SourceDataOffset,
                &myArg->DestinationDataOffset
                );
}


BOOL
pSetOperationGroup2 (
    IN      KEYHANDLE OperationId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    PSETOPERATIONARG2 myArg = (PSETOPERATIONARG2) Arg;

    return pSetOperationOnObjectId (
                myArg->ObjectId,
                (MIG_OPERATIONID) OperationId,
                NULL,
                NULL,
                FirstPass,
                myArg->SourceDataOffset ? &myArg->SourceDataOffset : NULL,
                myArg->DestinationDataOffset ? &myArg->DestinationDataOffset : NULL
                );
}


BOOL
IsmSetOperationOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    IN      PCMIG_BLOB SourceData,          OPTIONAL
    IN      PCMIG_BLOB DestinationData      OPTIONAL
    )
{
    RECURSERETURN rc;
    SETOPERATIONARG myArg;

    myArg.ObjectId = ObjectId;
    myArg.SourceData = SourceData;
    myArg.DestinationData = DestinationData;
    myArg.SourceDataOffset = 0;
    myArg.DestinationDataOffset = 0;

    rc = RecurseForGroupItems (
                OperationId,
                pSetOperationGroup,
                (ULONG_PTR) &myArg,
                FALSE,
                FALSE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pSetOperationOnObjectId (
                ObjectId,
                OperationId,
                SourceData,
                DestinationData,
                FALSE,
                NULL,
                NULL
                );
}


BOOL
IsmSetOperationOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_OPERATIONID OperationId,
    IN      PCMIG_BLOB SourceData,          OPTIONAL
    IN      PCMIG_BLOB DestinationData      OPTIONAL
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = GetObjectIdForModification (ObjectTypeId, EncodedObjectName);

    if (objectId) {
        result = IsmSetOperationOnObjectId (
                        objectId,
                        OperationId,
                        SourceData,
                        DestinationData
                        );
    }

    return result;
}


MIG_DATAHANDLE
IsmRegisterOperationData (
    IN      PCMIG_BLOB Data
    )
{
    return (MIG_DATAHANDLE) IsmRegisterPropertyData (Data);
}


BOOL
IsmSetOperationOnObjectId2 (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    IN      MIG_DATAHANDLE SourceData,      OPTIONAL
    IN      MIG_DATAHANDLE DestinationData  OPTIONAL
    )
{
    RECURSERETURN rc;
    SETOPERATIONARG2 myArg;

    myArg.ObjectId = ObjectId;
    if (SourceData) {
        myArg.SourceDataOffset = pGetOffsetFromDataHandle (SourceData);
        if (!myArg.SourceDataOffset) {
            return FALSE;
        }
    } else {
        myArg.SourceDataOffset = 0;
    }

    if (DestinationData) {
        myArg.DestinationDataOffset = pGetOffsetFromDataHandle (DestinationData);
        if (!myArg.DestinationDataOffset) {
            return FALSE;
        }
    } else {
        myArg.DestinationDataOffset = 0;
    }

    rc = RecurseForGroupItems (
                OperationId,
                pSetOperationGroup2,
                (ULONG_PTR) &myArg,
                FALSE,
                FALSE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pSetOperationOnObjectId (
                ObjectId,
                OperationId,
                NULL,
                NULL,
                FALSE,
                SourceData ? &myArg.SourceDataOffset : NULL,
                DestinationData ? &myArg.DestinationDataOffset : NULL
                );
}


BOOL
IsmSetOperationOnObject2 (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_OPERATIONID OperationId,
    IN      MIG_DATAHANDLE SourceData,      OPTIONAL
    IN      MIG_DATAHANDLE DestinationData  OPTIONAL
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = GetObjectIdForModification (ObjectTypeId, EncodedObjectName);

    if (objectId) {
        result = IsmSetOperationOnObjectId2 (
                        objectId,
                        OperationId,
                        SourceData,
                        DestinationData
                        );
    }

    return result;
}


VOID
IsmLockOperation (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId
    )
{
    LockHandle (ObjectId, (KEYHANDLE) OperationId);
}


BOOL
pClearOperationOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    IN      BOOL QueryOnly
    )
{
    BOOL result = FALSE;
    POPERATION_PROPERTY_LINKAGE linkage;
    PBYTE freeMe;
    UINT linkageSize;

    __try {
        //
        // Is the operation or object locked?
        //

        if (TestLock (ObjectId, (KEYHANDLE) OperationId)) {
            SetLastError (ERROR_LOCKED);
            DEBUGMSG ((
                DBG_WARNING,
                "Can't remove operation %s on %s because of lock",
                pGetOpNameForDebug (OperationId),
                GetObjectNameForDebugMsg (ObjectId)
                ));
            __leave;
        }

        //
        // If query only, return success
        //

        if (QueryOnly) {
            result = TRUE;
            __leave;
        }

        //
        // Find the reference to this operation within the object's unordered blob
        //

        linkage = pFindOperationPropertyLinkage (
                        ObjectId,
                        OperationId,
                        &freeMe,
                        &linkageSize
                        );

        if (linkage) {
            ZeroMemory (linkage, sizeof (OPERATION_PROPERTY_LINKAGE));

            if (!MemDbSetUnorderedBlobByKeyHandle (
                    ObjectId,
                    OPERATION_INDEX,
                    freeMe,
                    linkageSize
                    )) {
                DEBUGMSG ((DBG_ERROR, "Can't reset unordered operation blob"));
                __leave;
            }

            MemDbReleaseMemory (freeMe);
            INVALID_POINTER (freeMe);
        }

        //
        // Remove object-to-operation linkage
        //

        result = MemDbDeleteDoubleLinkageByKeyHandle (
                    ObjectId,
                    OperationId,
                    OPERATION_INDEX
                    );
    }
    __finally {
    }

    return result;
}


BOOL
pClearOperationGroup (
    IN      KEYHANDLE OperationId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    return pClearOperationOnObjectId (
                (MIG_OBJECTID) Arg,
                (MIG_OPERATIONID) OperationId,
                FirstPass
                );
}


BOOL
IsmClearOperationOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId
    )
{
    RECURSERETURN rc;

    //
    // If OperationId is a group, remove all operations in the group
    //

    rc = RecurseForGroupItems (
                OperationId,
                pClearOperationGroup,
                (ULONG_PTR) ObjectId,
                FALSE,
                FALSE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pClearOperationOnObjectId (ObjectId, OperationId, FALSE);
}


BOOL
IsmClearOperationOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_OPERATIONID OperationId
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmClearOperationOnObjectId (objectId, OperationId);
    }

    return result;
}


BOOL
pIsOperationSetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId
    )
{
    PCTSTR groupKey;
    PCTSTR enumKey = NULL;
    BOOL result = FALSE;
    BOOL done = FALSE;
    MEMDB_ENUM e;

    __try {
        //
        // Did caller specify an item id?
        //

        if (!IsItemId ((KEYHANDLE) OperationId)) {
            if (IsGroupId ((KEYHANDLE) OperationId)) {

                groupKey = MemDbGetKeyFromHandle (OperationId, 0);
                enumKey = JoinText (groupKey, TEXT(".*"));
                MemDbReleaseMemory (groupKey);

                //
                // Enumerate all operations (skip operation subgroups)
                //

                if (MemDbEnumFirst (
                        &e,
                        enumKey,
                        ENUMFLAG_NORMAL,
                        ENUMLEVEL_ALLLEVELS,
                        ENUMLEVEL_ALLLEVELS
                        )) {

                    do {
                        if (IsItemId (e.KeyHandle)) {
                            //
                            // Check if at least one operation is set
                            //

                            if (IsmIsOperationSetOnObjectId (
                                    ObjectId,
                                    (MIG_OPERATIONID) e.KeyHandle
                                    )) {
                                MemDbAbortEnum (&e);
                                result = TRUE;
                                done = TRUE;
                                __leave;
                            }
                        }

                    } while (MemDbEnumNext (&e));
                    MemDbAbortEnum (&e);
                }

                done = TRUE;
                __leave;

            } else {
                DEBUGMSG ((
                    DBG_ERROR,
                    "IsmIsOperationSetOnObjectId: operation id is invalid"
                    ));
                __leave;
            }
        }
    }
    __finally {
        if (enumKey) {
            FreeText (enumKey);
            INVALID_POINTER (enumKey);
        }
    }

    if (done) {
        return result;
    }

    return MemDbTestDoubleLinkageByKeyHandle (
                ObjectId,
                OperationId,
                OPERATION_INDEX
                );
}


BOOL
pQueryOperationGroup (
    IN      KEYHANDLE OperationId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    return pIsOperationSetOnObjectId (
                (MIG_OBJECTID) Arg,
                (MIG_OPERATIONID) OperationId
                );
}


BOOL
IsmIsOperationSetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId
    )
{
    RECURSERETURN rc;

    //
    // If OperationId is a group, query all operations in the group
    //

    rc = RecurseForGroupItems (
                OperationId,
                pQueryOperationGroup,
                (ULONG_PTR) ObjectId,
                TRUE,
                TRUE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pIsOperationSetOnObjectId (ObjectId, OperationId);
}


BOOL
IsmIsOperationSetOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_OPERATIONID OperationId
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmIsOperationSetOnObjectId (objectId, OperationId);
    }

    return FALSE;
}


BOOL
IsmGetObjectOperationDataById (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    OUT     PBYTE Buffer,                   OPTIONAL
    IN      UINT BufferSize,
    OUT     PUINT BufferSizeNeeded,         OPTIONAL
    OUT     PMIG_BLOBTYPE Type,             OPTIONAL
    IN      BOOL DestinationData
    )
{
    POPERATION_PROPERTY_LINKAGE linkage = NULL;
    UINT dataCount;
    BOOL result = FALSE;
    GROWBUFFER tempBuffer = INIT_GROWBUFFER;
    LONGLONG offset;
    UINT size;
    DWORD error = ERROR_SUCCESS;
    PBYTE freeMe = NULL;

    __try {
        //
        // Obtain the linkage between the operation and its data
        //

        linkage = pFindOperationPropertyLinkage (
                        ObjectId,
                        OperationId,
                        &freeMe,
                        &dataCount
                        );

        if (!linkage) {
            //
            // No data
            //

            __leave;
        }

        offset = DestinationData ? linkage->DestData : linkage->SrcData;

        if (!offset) {
            //
            // No data
            //

            __leave;
        }

        if (!GetProperty (offset, NULL, NULL, &size, Type)) {
            DEBUGMSG ((DBG_ERROR, "Error getting property instance header from dat file"));
            error = ERROR_INVALID_PARAMETER;
            __leave;
        }

        if (BufferSizeNeeded) {
            *BufferSizeNeeded = size;
        }

        //
        // If a buffer was specified, check its size and fill it if possible
        //

        if (Buffer) {
            if (BufferSize >= size) {
                if (!GetProperty (offset, NULL, Buffer, NULL, NULL)) {
                    DEBUGMSG ((DBG_ERROR, "Error reading property data from dat file"));

                    //
                    // error code is one of the file api error codes
                    //

                    error = GetLastError();
                    __leave;
                }
            } else {
                error = ERROR_MORE_DATA;
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {
        MemDbReleaseMemory (freeMe);
        INVALID_POINTER (freeMe);

        GbFree (&tempBuffer);
    }

    SetLastError (error);
    return result;
}


BOOL
IsmGetObjectOperationData (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_OPERATIONID OperationId,
    OUT     PBYTE Buffer,                   OPTIONAL
    IN      UINT BufferSize,
    OUT     PUINT BufferSizeNeeded,         OPTIONAL
    OUT     PMIG_BLOBTYPE Type,             OPTIONAL
    IN      BOOL DestinationData
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmGetObjectOperationDataById (
                    objectId,
                    OperationId,
                    Buffer,
                    BufferSize,
                    BufferSizeNeeded,
                    Type,
                    DestinationData
                    );
    }

    return FALSE;
}


BOOL
pEnumFirstObjectOperationById (
    OUT     PMIG_OBJECTOPERATION_ENUM EnumPtr,
    IN      MIG_OBJECTID ObjectId,
    IN      BOOL ReturnAllPrivateOps
    )
{
    POBJECTOPERATION_HANDLE handle;
    BOOL b = TRUE;

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTOPERATION_ENUM));

    EnumPtr->Handle = MemAllocZeroed (sizeof (OBJECTOPERATION_HANDLE));
    handle = (POBJECTOPERATION_HANDLE) EnumPtr->Handle;
    handle->ReturnAllPrivateOps = ReturnAllPrivateOps;

    //
    // Obtain the linkage up front
    //

    handle->LinkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                ObjectId,
                                OPERATION_INDEX,
                                &handle->Count
                                );

    handle->Count /= sizeof(KEYHANDLE);

    if (!handle->LinkageList || !handle->Count) {
        IsmAbortObjectOperationEnum (EnumPtr);
        return FALSE;
    }

    handle->OpPropLinkList = (POPERATION_PROPERTY_LINKAGE) MemDbGetUnorderedBlobByKeyHandle (
                                                                ObjectId,
                                                                OPERATION_INDEX,
                                                                &handle->OpPropCount
                                                                );

    handle->OpPropCount /= sizeof (OPERATION_PROPERTY_LINKAGE);

    if (!handle->OpPropLinkList) {
        handle->OpPropCount = 0;
    }

    //
    // Continue enumeration in "next" function
    //

    return IsmEnumNextObjectOperation (EnumPtr);
}


BOOL
IsmEnumFirstObjectOperationById (
    OUT     PMIG_OBJECTOPERATION_ENUM EnumPtr,
    IN      MIG_OBJECTID ObjectId
    )
{
    return pEnumFirstObjectOperationById (EnumPtr, ObjectId, FALSE);
}


BOOL
pEnumFirstObjectOperation (
    OUT     PMIG_OBJECTOPERATION_ENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      BOOL ReturnAllPrivateOps
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return pEnumFirstObjectOperationById (EnumPtr, objectId, ReturnAllPrivateOps);
    }

    return FALSE;
}


BOOL
IsmEnumFirstObjectOperation (
    OUT     PMIG_OBJECTOPERATION_ENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    )
{
    return pEnumFirstObjectOperation (EnumPtr, ObjectTypeId, EncodedObjectName, FALSE);
}


BOOL
IsmEnumNextObjectOperation (
    IN OUT  PMIG_OBJECTOPERATION_ENUM EnumPtr
    )
{
    POBJECTOPERATION_HANDLE handle;
    BOOL b = FALSE;
    BOOL mine;
    UINT u;
    POPERATION_PROPERTY_LINKAGE linkage;

    handle = (POBJECTOPERATION_HANDLE) EnumPtr->Handle;
    if (!handle) {
        return FALSE;
    }

    do {

        MYASSERT (!b);

        //
        // Check if we hit the end
        //

        if (handle->Index >= handle->Count) {
            break;
        }

        //
        // Return the next operation
        //

        EnumPtr->OperationId = (MIG_OPERATIONID) handle->LinkageList[handle->Index];
        handle->Index++;

        b = pGetOperationName (
                EnumPtr->OperationId,
                NULL,
                0,
                &EnumPtr->Private,
                &mine,
                NULL,
                handle->ReturnAllPrivateOps
                );

        //
        // Continue when the operation is not owned by the caller
        //

        if (b && EnumPtr->Private && !mine) {
            b = FALSE;
        }

    } while (!b);

    if (!b) {
        IsmAbortObjectOperationEnum (EnumPtr);
    } else {
        //
        // Before returning match, fill enum structure with property info
        //

        linkage = handle->OpPropLinkList;

        for (u = 0 ; u < handle->OpPropCount ; u++) {
            if (linkage->OperationId == EnumPtr->OperationId) {
                break;
            }

            linkage++;
        }

        if (u < handle->OpPropCount) {
            //
            // This operation has src property, dest property, or both.
            // Get the data from property.dat and put it in the enum
            // struct.
            //

            if (linkage->SrcData) {

                EnumPtr->SourceData = &handle->SrcData;
                CreatePropertyStruct (
                    &handle->SrcPropBuf,
                    &handle->SrcData,
                    linkage->SrcData
                    );

            } else {
                EnumPtr->SourceData = NULL;
            }

            if (linkage->DestData) {

                EnumPtr->DestinationData = &handle->DestData;
                CreatePropertyStruct (
                    &handle->DestPropBuf,
                    &handle->DestData,
                    linkage->DestData
                    );

            } else {
                EnumPtr->DestinationData = NULL;
            }

        } else {
            //
            // No src or dest properties
            //

            EnumPtr->SourceData = NULL;
            EnumPtr->DestinationData = NULL;
        }
    }

    return b;
}


VOID
IsmAbortObjectOperationEnum (
    IN OUT  PMIG_OBJECTOPERATION_ENUM EnumPtr
    )
{
    POBJECTOPERATION_HANDLE handle;

    if (EnumPtr->Handle) {

        handle = (POBJECTOPERATION_HANDLE) EnumPtr->Handle;

        GbFree (&handle->SrcPropBuf);
        GbFree (&handle->DestPropBuf);

        if (handle->LinkageList) {
            MemDbReleaseMemory (handle->LinkageList);
            INVALID_POINTER (handle->LinkageList);
        }

        if (handle->OpPropLinkList) {
            MemDbReleaseMemory (handle->OpPropLinkList);
            INVALID_POINTER (handle->OpPropLinkList);
        }

        FreeAlloc (EnumPtr->Handle);
        INVALID_POINTER (EnumPtr->Handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTOPERATION_ENUM));
}


BOOL
IsmEnumFirstObjectWithOperation (
    OUT     PMIG_OBJECTWITHOPERATION_ENUM EnumPtr,
    IN      MIG_OPERATIONID OperationId
    )
{
    POBJECTWITHOPERATION_HANDLE handle;
    BOOL b = FALSE;

    __try {
        //
        // Did caller specify an item id?
        //

        if (!IsItemId ((KEYHANDLE) OperationId)) {
            DEBUGMSG ((
                DBG_ERROR,
                "IsmEnumFirstObjectWithOperation: operation id is invalid"
                ));
            __leave;
        }

        ZeroMemory (EnumPtr, sizeof (MIG_OBJECTWITHOPERATION_ENUM));

        EnumPtr->Handle = MemAllocZeroed (sizeof (OBJECTWITHOPERATION_HANDLE));
        handle = (POBJECTWITHOPERATION_HANDLE) EnumPtr->Handle;

        handle->LinkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                    OperationId,
                                    OPERATION_INDEX,
                                    &handle->Count
                                    );

        handle->Count = handle->Count / SIZEOF(KEYHANDLE);

        if (!handle->LinkageList || !handle->Count) {
            IsmAbortObjectWithOperationEnum (EnumPtr);
            __leave;
        } else {
            b = IsmEnumNextObjectWithOperation (EnumPtr);
        }
    }
    __finally {
    }

    return b;
}


BOOL
IsmEnumNextObjectWithOperation (
    IN OUT  PMIG_OBJECTWITHOPERATION_ENUM EnumPtr
    )
{
    POBJECTWITHOPERATION_HANDLE handle;
    PCTSTR objectPath = NULL;
    BOOL b = FALSE;
    PTSTR p;

    __try {
        handle = (POBJECTWITHOPERATION_HANDLE) EnumPtr->Handle;
        if (!handle) {
            __leave;
        }

        while (!b) {

            //
            // Check if enum is done
            //

            if (handle->Index >= handle->Count) {
                break;
            }

            //
            // Get the next object id from the linkage list
            //

            EnumPtr->ObjectId = handle->LinkageList[handle->Index];
            handle->Index++;

            if (handle->ObjectFromMemdb) {
                MemDbReleaseMemory (handle->ObjectFromMemdb);
                INVALID_POINTER (handle->ObjectFromMemdb);
            }

            handle->ObjectFromMemdb = MemDbGetKeyFromHandle ((KEYHANDLE) EnumPtr->ObjectId, 0);

            if (!handle->ObjectFromMemdb) {
                MYASSERT (FALSE);   // this error shouldn't happen -- but don't give up
                continue;
            }

            //
            // Turn the object id into a name
            //

            p = _tcschr (handle->ObjectFromMemdb, TEXT('\\'));

            if (p) {
                b = TRUE;
                EnumPtr->ObjectName = _tcsinc (p);
                *p = 0;
                EnumPtr->ObjectTypeId = GetObjectTypeId (handle->ObjectFromMemdb);
            }
        }
    }
    __finally {
    }

    if (!b) {
        IsmAbortObjectWithOperationEnum (EnumPtr);
    }

    return b;
}


VOID
IsmAbortObjectWithOperationEnum (
    IN      PMIG_OBJECTWITHOPERATION_ENUM EnumPtr
    )
{
    POBJECTWITHOPERATION_HANDLE handle;

    if (EnumPtr->Handle) {
        handle = (POBJECTWITHOPERATION_HANDLE) EnumPtr->Handle;

        if (handle->ObjectFromMemdb) {
            MemDbReleaseMemory (handle->ObjectFromMemdb);
            INVALID_POINTER (handle->ObjectFromMemdb);
        }

        if (handle->LinkageList) {
            MemDbReleaseMemory (handle->LinkageList);
            INVALID_POINTER (handle->LinkageList);
        }

        FreeAlloc (EnumPtr->Handle);
        INVALID_POINTER (EnumPtr->Handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTWITHOPERATION_ENUM));
}

MIG_OBJECTSTRINGHANDLE
TrackedIsmGetLongName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
            TRACKING_DEF
    )
{
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    UINT resultType = FILENAME_UNDECIDED;
    BOOL hadLeaf = FALSE;
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    PTSTR nativeName = NULL;
    PTSTR nativeNamePtr;
    PTSTR beginSegPtr;
    PTSTR endSegPtr;
    PCTSTR lastSeg;
    UINT savedEnd;
    UINT beginBuffIdx;
    TCHAR savedChar;
    KEYHANDLE kh1, kh2;
    DWORD value;
    MIG_OBJECTSTRINGHANDLE result = NULL;

    TRACK_ENTER();

    if ((ObjectTypeId & (~PLATFORM_MASK)) == MIG_FILE_TYPE) {

        //
        // fire up the short-long algorithm
        //
        if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

            MYASSERT (node);
            if (leaf) {
                nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node) + SizeOfString (leaf));
                hadLeaf = TRUE;
            } else {
                nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node));
                hadLeaf = FALSE;
            }
            nativeNamePtr = AppendWack (nativeName);
            StringCopy (nativeNamePtr, node);
            if (leaf) {
                StringCopy (AppendWack (nativeNamePtr), leaf);
            }
            GbAppendString (&growBuf, S_SHORTLONG_TREE);
            GbAppendString (&growBuf, TEXT("\\"));
            beginBuffIdx = growBuf.End - (1 * sizeof (TCHAR));
            beginSegPtr = GetFirstSeg (nativeNamePtr);

            if (beginSegPtr) {

                beginSegPtr = _tcsinc (beginSegPtr);

                GbAppendStringAB (&growBuf, nativeNamePtr, beginSegPtr);

                while (beginSegPtr) {
                    endSegPtr = _tcschr (beginSegPtr, TEXT('\\'));
                    if (!endSegPtr) {
                        endSegPtr = GetEndOfString (beginSegPtr);
                        MYASSERT (endSegPtr);
                    }

                    savedChar = *endSegPtr;
                    *endSegPtr = 0;

                    savedEnd = growBuf.End - (1 * sizeof (TCHAR));
                    GbAppendStringAB (&growBuf, beginSegPtr, endSegPtr);

                    kh1 = MemDbGetHandleFromKey ((PCTSTR) growBuf.Buf);
                    if (kh1) {
                        MemDbGetValueByHandle (kh1, &value);
                        if (value == FILENAME_LONG) {
                            resultType = FILENAME_LONG;
                        } else {
                            if (resultType != FILENAME_LONG) {
                                resultType = FILENAME_SHORT;
                            }
                            kh2 = MemDbGetDoubleLinkageByKeyHandle (kh1, 0, 0);
                            MYASSERT (kh2);
                            if (kh2) {
                                growBuf.End = savedEnd;
                                lastSeg = MemDbGetKeyFromHandle (kh2, MEMDB_LAST_LEVEL);
                                GbAppendString (&growBuf, lastSeg);
                                MemDbReleaseMemory (lastSeg);
                            }
                        }
                    }

                    *endSegPtr = savedChar;
                    if (savedChar) {
                        beginSegPtr = _tcsinc (endSegPtr);
                        GbAppendStringAB (&growBuf, endSegPtr, beginSegPtr);
                    } else {
                        beginSegPtr = NULL;
                    }
                }
            } else {
                GbAppendString (&growBuf, nativeNamePtr);
            }
            FreePathString (nativeName);
            if (node) {
                IsmDestroyObjectString (node);
            }
            if (leaf) {
                IsmDestroyObjectString (leaf);
            }
            if (hadLeaf) {
                beginSegPtr = _tcsrchr ((PTSTR) growBuf.Buf, TEXT('\\'));
                endSegPtr = _tcsinc (beginSegPtr);
                *beginSegPtr = 0;
            } else {
                endSegPtr = NULL;
            }
            result = IsmCreateObjectHandle ((PTSTR) (growBuf.Buf + beginBuffIdx), endSegPtr);
        }
        GbFree (&growBuf);
    }

    TRACK_LEAVE();

    return result;
}

MIG_OBJECTSTRINGHANDLE
IsmFilterObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     MIG_OBJECTTYPEID *NewObjectTypeId,          OPTIONAL
    OUT     PBOOL ObjectDeleted,                        OPTIONAL
    OUT     PBOOL ObjectReplaced                        OPTIONAL
    )
{
    MIG_OBJECTSTRINGHANDLE objectName = ObjectName;
    ENCODEDSTRHANDLE result = NULL;
    MIG_FILTEROUTPUT filterOutput;
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    UINT resultType = FILENAME_UNDECIDED;
    BOOL hadLeaf = FALSE;
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    PTSTR nativeName = NULL;
    PTSTR nativeNamePtr;
    PTSTR beginSegPtr;
    PTSTR endSegPtr;
    PCTSTR lastSeg;
    UINT savedEnd;
    UINT beginBuffIdx;
    TCHAR savedChar;
    KEYHANDLE kh1, kh2;
    DWORD value;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    __try {

        if ((ObjectTypeId & (~PLATFORM_MASK)) == MIG_FILE_TYPE) {
            //
            // fire up the short-long algorithm
            //
            if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

                if (node) {
                    if (leaf) {
                        nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node) + SizeOfString (leaf));
                        hadLeaf = TRUE;
                    } else {
                        nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node));
                        hadLeaf = FALSE;
                    }
                    nativeNamePtr = AppendWack (nativeName);
                    StringCopy (nativeNamePtr, node);
                    if (leaf) {
                        StringCopy (AppendWack (nativeNamePtr), leaf);
                    }
                    GbAppendString (&growBuf, S_SHORTLONG_TREE);
                    GbAppendString (&growBuf, TEXT("\\"));
                    beginBuffIdx = growBuf.End - (1 * sizeof (TCHAR));
                    beginSegPtr = GetFirstSeg (nativeNamePtr);

                    if (beginSegPtr) {

                        beginSegPtr = _tcsinc (beginSegPtr);

                        GbAppendStringAB (&growBuf, nativeNamePtr, beginSegPtr);

                        while (beginSegPtr) {
                            endSegPtr = _tcschr (beginSegPtr, TEXT('\\'));
                            if (!endSegPtr) {
                                endSegPtr = GetEndOfString (beginSegPtr);
                                MYASSERT (endSegPtr);
                            }

                            savedChar = *endSegPtr;
                            *endSegPtr = 0;

                            savedEnd = growBuf.End - (1 * sizeof (TCHAR));
                            GbAppendStringAB (&growBuf, beginSegPtr, endSegPtr);

                            kh1 = MemDbGetHandleFromKey ((PCTSTR) growBuf.Buf);
                            if (kh1) {
                                MemDbGetValueByHandle (kh1, &value);
                                if (value == FILENAME_LONG) {
                                    resultType = FILENAME_LONG;
                                } else {
                                    if (resultType != FILENAME_LONG) {
                                        resultType = FILENAME_SHORT;
                                    }
                                    kh2 = MemDbGetDoubleLinkageByKeyHandle (kh1, 0, 0);
                                    MYASSERT (kh2);
                                    if (kh2) {
                                        growBuf.End = savedEnd;
                                        lastSeg = MemDbGetKeyFromHandle (kh2, MEMDB_LAST_LEVEL);
                                        GbAppendString (&growBuf, lastSeg);
                                        MemDbReleaseMemory (lastSeg);
                                    }
                                }
                            }

                            *endSegPtr = savedChar;
                            if (savedChar) {
                                beginSegPtr = _tcsinc (endSegPtr);
                                GbAppendStringAB (&growBuf, endSegPtr, beginSegPtr);
                            } else {
                                beginSegPtr = NULL;
                            }
                        }
                    } else {
                        GbAppendString (&growBuf, nativeNamePtr);
                    }
                    FreePathString (nativeName);
                    if (node) {
                        IsmDestroyObjectString (node);
                    }
                    if (leaf) {
                        IsmDestroyObjectString (leaf);
                    }
                    if (hadLeaf) {
                        beginSegPtr = _tcsrchr ((PTSTR) growBuf.Buf, TEXT('\\'));
                        endSegPtr = _tcsinc (beginSegPtr);
                        *beginSegPtr = 0;
                    } else {
                        endSegPtr = NULL;
                    }
                    objectName = IsmCreateObjectHandle ((PTSTR) (growBuf.Buf + beginBuffIdx), endSegPtr);
                }
            }
        }

        if (!ApplyOperationsOnObject (
                    ObjectTypeId,
                    objectName,
                    FALSE,
                    !ShouldObjectBeRestored (
                        ObjectTypeId,
                        IsmGetObjectIdFromName (ObjectTypeId, objectName, TRUE),
                        objectName
                        ),
                    OP_ALL_PRIORITY,
                    NULL,
                    &filterOutput,
                    NULL
                    )) {
            __leave;
        }

        if (ObjectDeleted) {
            *ObjectDeleted = filterOutput.Deleted;
        }

        if (ObjectReplaced) {
            *ObjectReplaced = filterOutput.Replaced;
        }

        if (NewObjectTypeId) {
            *NewObjectTypeId = filterOutput.NewObject.ObjectTypeId;
        }

        if (filterOutput.NewObject.ObjectName == objectName) {
            __leave;
        }

        if (resultType == FILENAME_SHORT) {
            // NTRAID#NTBUG9-153258-2000/08/01-jimschm Create dummy file (if does not exist) to reserve and get the short file name
        }

        result = filterOutput.NewObject.ObjectName;
    }
    __finally {
        if (objectName != ObjectName) {
            //
            // free the object name allocated by the short-long algorithm
            //
            IsmDestroyObjectHandle (objectName);
        }
    }
    GbFree (&growBuf);

    return result;
}


VOID
pFreeMigObjectStruct (
    IN      PMIG_OBJECT Object,
    IN      PMIG_OBJECT OriginalObject,         OPTIONAL
    IN      PMIG_OBJECT NewObject               OPTIONAL
    )
{
    BOOL free = TRUE;

    if (OriginalObject) {
        if (Object->ObjectName == OriginalObject->ObjectName) {
            free = FALSE;
        }
    }

    if (NewObject) {
        if (Object->ObjectName == NewObject->ObjectName) {
            free = FALSE;
        }
    }

    if (free) {
        IsmDestroyObjectHandle (Object->ObjectName);
    }

    ZeroMemory (Object, sizeof (MIG_OBJECT));
}


VOID
pFreeMigContentStruct (
    IN      PMIG_CONTENT Content,
    IN      PCMIG_CONTENT OriginalContent,      OPTIONAL
    IN      PCMIG_CONTENT NewContent            OPTIONAL
    )
{
    BOOL free;

    if (Content->ContentInFile) {

        free = TRUE;

        if (OriginalContent &&
            Content->FileContent.ContentPath == OriginalContent->FileContent.ContentPath
            ) {

            free = FALSE;

        } else if (NewContent &&
                   Content->FileContent.ContentPath == NewContent->FileContent.ContentPath
                   ) {

            free = FALSE;

        }

        if (free) {
            if (Content->FileContent.ContentPath) {
                IsmReleaseMemory (Content->FileContent.ContentPath);
                Content->FileContent.ContentPath = NULL;
            }
        }

    } else {

        free = TRUE;

        if (OriginalContent &&
            Content->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes
            ) {

            free = FALSE;

        } else if (NewContent &&
                   Content->MemoryContent.ContentBytes == NewContent->MemoryContent.ContentBytes
                   ) {

            free = FALSE;
        }

        if (free) {
            if (Content->MemoryContent.ContentBytes) {
                IsmReleaseMemory (Content->MemoryContent.ContentBytes);
                Content->MemoryContent.ContentBytes = NULL;
            }
        }
    }

    free = TRUE;

    if (OriginalContent &&
        OriginalContent->Details.DetailsData == Content->Details.DetailsData
        ) {

        free = FALSE;
    }

    if (NewContent &&
        NewContent->Details.DetailsData == Content->Details.DetailsData
        ) {

        free = FALSE;
    }

    if (free && Content->Details.DetailsData) {
        IsmReleaseMemory (Content->Details.DetailsData);
        Content->Details.DetailsData = NULL;;
    }

    ZeroMemory (Content, sizeof (MIG_CONTENT));
}


BOOL
ApplyOperationsOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      BOOL TreeFiltersOnly,
    IN      BOOL NoRestoreObject,
    IN      DWORD OperationPriority,
    IN      PMIG_CONTENT ApplyInput,            OPTIONAL
    OUT     PMIG_FILTEROUTPUT FilterOutput,
    OUT     PMIG_CONTENT ApplyOutput            OPTIONAL
    )
{
    MIG_FILTERINPUT filterInput;
    MIG_OBJECTOPERATION_ENUM Enum;
    BOOL result = FALSE;
    MIG_CONTENT currentContent;
    OPERATION_DATA operationData;
    POPMFILTERCALLBACK filterCallback;
    POPMAPPLYCALLBACK applyCallback;
    PGLOBALFILTERINDEX globalFilterIndex;
    PGLOBALFILTER globalFilter;
    PGLOBALEDIT globalEdit;
    BOOL needObjectId;
    MIG_OBJECTID objectId = 0;

    if (NoRestoreObject) {
        MYASSERT (!ApplyInput);
        MYASSERT (!ApplyOutput);
        if (ApplyInput || ApplyOutput) {
            return FALSE;
        }
    }

    __try {

        //
        // Save original values
        //

        ZeroMemory (&filterInput, sizeof (filterInput));

        filterInput.OriginalObject.ObjectTypeId = ObjectTypeId;
        filterInput.OriginalObject.ObjectName = ObjectName;
        filterInput.CurrentObject = filterInput.OriginalObject;
        if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
            filterInput.Deleted = NoRestoreObject;
        }

        filterInput.FilterTreeChangesOnly = TreeFiltersOnly;

        ZeroMemory (&currentContent, sizeof (MIG_CONTENT));

        if (ApplyInput) {
            CopyMemory (&currentContent, ApplyInput, sizeof (MIG_CONTENT));
        }

        //
        // Set defaults for output
        //

        FilterOutput->NewObject = filterInput.CurrentObject;
        FilterOutput->Deleted = filterInput.Deleted;
        FilterOutput->Replaced = filterInput.Replaced;

        if (ApplyInput) {
            MYASSERT (ApplyOutput);
            CopyMemory (ApplyOutput, ApplyInput, sizeof (MIG_CONTENT));
        }

        //
        // Find type in filter index and process first pass global filters and editors
        //

        globalFilterIndex = pGetGlobalIndex (ObjectTypeId, FALSE);

        if (globalFilterIndex) {

            //
            // Get object ID
            //

            needObjectId = FALSE;

            if (OperationPriority & OP_HIGH_PRIORITY) {
                if (globalFilterIndex->FilterFirstHeadHp ||
                    globalFilterIndex->FilterLastHeadHp ||
                    globalFilterIndex->EditFirstHeadHp ||
                    globalFilterIndex->EditLastHeadHp
                    ) {
                    needObjectId = TRUE;
                }
            }

            if (OperationPriority & OP_LOW_PRIORITY) {
                if (globalFilterIndex->FilterFirstHead ||
                    globalFilterIndex->FilterLastHead ||
                    globalFilterIndex->EditFirstHead ||
                    globalFilterIndex->EditLastHead
                    ) {
                    needObjectId = TRUE;
                }
            }

            if (needObjectId) {
                objectId = IsmGetObjectIdFromName (ObjectTypeId, ObjectName, TRUE);
            }

            //
            // Perform first pass global filter
            //

            if (OperationPriority & OP_HIGH_PRIORITY) {

                globalFilter = globalFilterIndex->FilterFirstHeadHp;

                while (globalFilter) {

                    if ((!globalFilter->Platform || (globalFilter->Platform & ObjectTypeId)) &&
                        (!TreeFiltersOnly || globalFilter->TreeFilter) &&
                        (!NoRestoreObject || globalFilter->NoRestoreFilter)
                        ) {

                        if (!objectId ||
                            !pIsOperationProhibitedOnObject (globalFilter->OperationId, objectId, TRUE)
                            ) {

                            if (!globalFilter->Callback (
                                    &filterInput,
                                    FilterOutput,
                                    NoRestoreObject,
                                    NULL,
                                    NULL
                                    )) {
                                DEBUGMSG ((
                                    DBG_ERROR,
                                    "ApplyOperationsOnObject: first pass global filter failed for %s",
                                    pGetOpNameForDebug (globalFilter->OperationId)
                                    ));
                                __leave;
                            }

                            //
                            // Free input allocations if they are different from
                            // both the original and new pointer values
                            //

                            pFreeMigObjectStruct (
                                &filterInput.CurrentObject,
                                &filterInput.OriginalObject,
                                &FilterOutput->NewObject
                                );

                            //
                            // Filter outputs now become the inputs
                            //

                            filterInput.CurrentObject = FilterOutput->NewObject;
                            filterInput.Deleted = FilterOutput->Deleted;
                            filterInput.Replaced = FilterOutput->Replaced;
                        }
                    }

                    globalFilter = globalFilter->Next;
                }
            }

            if (OperationPriority & OP_LOW_PRIORITY) {

                globalFilter = globalFilterIndex->FilterFirstHead;

                while (globalFilter) {

                    if ((!globalFilter->Platform || (globalFilter->Platform & ObjectTypeId)) &&
                        (!TreeFiltersOnly || globalFilter->TreeFilter) &&
                        (!NoRestoreObject || globalFilter->NoRestoreFilter)
                        ) {

                        if (!objectId ||
                            !pIsOperationProhibitedOnObject (globalFilter->OperationId, objectId, TRUE)
                            ) {

                            if (!globalFilter->Callback (
                                    &filterInput,
                                    FilterOutput,
                                    NoRestoreObject,
                                    NULL,
                                    NULL
                                    )) {
                                DEBUGMSG ((
                                    DBG_ERROR,
                                    "ApplyOperationsOnObject: first pass global filter failed for %s",
                                    pGetOpNameForDebug (globalFilter->OperationId)
                                    ));
                                __leave;
                            }

                            //
                            // Free input allocations if they are different from
                            // both the original and new pointer values
                            //

                            pFreeMigObjectStruct (
                                &filterInput.CurrentObject,
                                &filterInput.OriginalObject,
                                &FilterOutput->NewObject
                                );

                            //
                            // Filter outputs now become the inputs
                            //

                            filterInput.CurrentObject = FilterOutput->NewObject;
                            filterInput.Deleted = FilterOutput->Deleted;
                            filterInput.Replaced = FilterOutput->Replaced;
                        }
                    }

                    globalFilter = globalFilter->Next;
                }
            }

            //
            // Perform first pass apply
            //

            if (ApplyInput) {

                if (OperationPriority & OP_HIGH_PRIORITY) {

                    globalEdit = globalFilterIndex->EditFirstHeadHp;

                    while (globalEdit) {

                        if (!globalEdit->Platform || (globalEdit->Platform & ObjectTypeId)) {

                            if (!objectId ||
                                !pIsOperationProhibitedOnObject (globalEdit->OperationId, objectId, TRUE)
                                ) {

                                //
                                // Call the apply function associated with this operation
                                //

                                if (!globalEdit->Callback (
                                        ObjectTypeId,
                                        ObjectName,
                                        ApplyInput,
                                        &currentContent,
                                        ApplyOutput,
                                        NULL,
                                        NULL
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: first pass global callback failed for %s",
                                        pGetOpNameForDebug (globalEdit->OperationId)
                                        ));
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from both
                                // the original and new pointer values
                                //

                                pFreeMigContentStruct (&currentContent, ApplyInput, ApplyOutput);

                                //
                                // Apply outputs now become the current content
                                //

                                CopyMemory (&currentContent, ApplyOutput, sizeof (MIG_CONTENT));
                            }
                        }
                        globalEdit = globalEdit->Next;
                    }
                }

                if (OperationPriority & OP_LOW_PRIORITY) {

                    globalEdit = globalFilterIndex->EditFirstHead;

                    while (globalEdit) {

                        if (!globalEdit->Platform || (globalEdit->Platform & ObjectTypeId)) {

                            if (!objectId ||
                                !pIsOperationProhibitedOnObject (globalEdit->OperationId, objectId, TRUE)
                                ) {

                                //
                                // Call the apply function associated with this operation
                                //

                                if (!globalEdit->Callback (
                                        ObjectTypeId,
                                        ObjectName,
                                        ApplyInput,
                                        &currentContent,
                                        ApplyOutput,
                                        NULL,
                                        NULL
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: first pass global callback failed for %s",
                                        pGetOpNameForDebug (globalEdit->OperationId)
                                        ));
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from both
                                // the original and new pointer values
                                //

                                pFreeMigContentStruct (&currentContent, ApplyInput, ApplyOutput);

                                //
                                // Apply outputs now become the current content
                                //

                                CopyMemory (&currentContent, ApplyOutput, sizeof (MIG_CONTENT));
                            }
                        }
                        globalEdit = globalEdit->Next;
                    }
                }
            }
        }

        //
        // Enumerate all operations on the object, then call filter and apply
        // callbacks.
        //

        if (pEnumFirstObjectOperation (&Enum, ObjectTypeId, ObjectName, TRUE)) {

            do {

                if (pGetOperationData (Enum.OperationId, &operationData)) {

                    if (OperationPriority & OP_HIGH_PRIORITY) {

                        //
                        // Screen the non-tree filters if necessary
                        //

                        if ((!TreeFiltersOnly || operationData.TreeFilterHp) &&
                            (!NoRestoreObject || operationData.NoRestoreFilterHp)
                            ) {

                            //
                            // NOTE: This loop calls the filter for an operation, then the
                            //       apply for the operation, then the filter for the next
                            //       operation, the apply for the next operation, and so on.
                            //
                            //       A content-edit of something that points to itself
                            //       might not be processed correctly.  That is, its
                            //       own path is not completely filtered, and
                            //       therefore it might not be correct.  To fix this,
                            //       all filters should run first, and then all apply
                            //       callbacks should run.  But because this would
                            //       cause double-enumeration of operations (costing
                            //       operation data retrieval), the loop is left
                            //       as-is.  Also, the theoretical case is rare enough
                            //       that we aren't concerned, and there is a
                            //       workaround via the operation priorities.
                            //

                            //
                            // Call the filter associated with this operation
                            //

                            filterCallback = operationData.FilterCallbackHp;
                            if (filterCallback) {

                                if (!filterCallback (
                                        &filterInput,
                                        FilterOutput,
                                        NoRestoreObject,
                                        Enum.SourceData,
                                        Enum.DestinationData
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: filter failed for %s",
                                        pGetOpNameForDebug (Enum.OperationId)
                                        ));
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from
                                // both the original and new pointer values
                                //

                                pFreeMigObjectStruct (
                                    &filterInput.CurrentObject,
                                    &filterInput.OriginalObject,
                                    &FilterOutput->NewObject
                                    );

                                //
                                // Filter outputs now become the inputs
                                //

                                filterInput.CurrentObject = FilterOutput->NewObject;
                                filterInput.Deleted = FilterOutput->Deleted;
                                filterInput.Replaced = FilterOutput->Replaced;

                            }

                            //
                            // Call the apply function associated with this operation
                            //

                            if (ApplyInput) {
                                applyCallback = operationData.ApplyCallbackHp;
                            } else {
                                applyCallback = NULL;
                            }

                            if (applyCallback) {

                                if (!applyCallback (
                                        ObjectTypeId,
                                        ObjectName,
                                        ApplyInput,
                                        &currentContent,
                                        ApplyOutput,
                                        Enum.SourceData,
                                        Enum.DestinationData
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: Operation apply callback failed for %s",
                                        pGetOpNameForDebug (Enum.OperationId)
                                        ));
                                    IsmAbortObjectOperationEnum (&Enum);
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from both
                                // the original and new pointer values
                                //

                                pFreeMigContentStruct (&currentContent, ApplyInput, ApplyOutput);

                                //
                                // Apply outputs now become the current content
                                //

                                CopyMemory (&currentContent, ApplyOutput, sizeof (MIG_CONTENT));
                            }
                        }
                    }

                    if (OperationPriority & OP_LOW_PRIORITY) {

                        //
                        // Screen the non-tree filters if necessary
                        //

                        if ((!TreeFiltersOnly || operationData.TreeFilter) &&
                            (!NoRestoreObject || operationData.NoRestoreFilter)
                            ) {

                            //
                            // NOTE: This loop calls the filter for an operation, then the
                            //       apply for the operation, then the filter for the next
                            //       operation, the apply for the next operation, and so on.
                            //
                            //       A content-edit of something that points to itself
                            //       might not be processed correctly.  That is, its
                            //       own path is not completely filtered, and
                            //       therefore it might not be correct.  To fix this,
                            //       all filters should run first, and then all apply
                            //       callbacks should run.  But because this would
                            //       cause double-enumeration of operations (costing
                            //       operation data retrieval), the loop is left
                            //       as-is.  Also, the theoretical case is rare enough
                            //       that we aren't concerned, and there is a
                            //       workaround via the operation priorities.
                            //

                            //
                            // Call the filter associated with this operation
                            //

                            filterCallback = operationData.FilterCallback;
                            if (filterCallback) {

                                if (!filterCallback (
                                        &filterInput,
                                        FilterOutput,
                                        NoRestoreObject,
                                        Enum.SourceData,
                                        Enum.DestinationData
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: filter failed for %s",
                                        pGetOpNameForDebug (Enum.OperationId)
                                        ));
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from
                                // both the original and new pointer values
                                //

                                pFreeMigObjectStruct (
                                    &filterInput.CurrentObject,
                                    &filterInput.OriginalObject,
                                    &FilterOutput->NewObject
                                    );

                                //
                                // Filter outputs now become the inputs
                                //

                                filterInput.CurrentObject = FilterOutput->NewObject;
                                filterInput.Deleted = FilterOutput->Deleted;
                                filterInput.Replaced = FilterOutput->Replaced;

                            }

                            //
                            // Call the apply function associated with this operation
                            //

                            if (ApplyInput) {
                                applyCallback = operationData.ApplyCallback;
                            } else {
                                applyCallback = NULL;
                            }

                            if (applyCallback) {

                                if (!applyCallback (
                                        ObjectTypeId,
                                        ObjectName,
                                        ApplyInput,
                                        &currentContent,
                                        ApplyOutput,
                                        Enum.SourceData,
                                        Enum.DestinationData
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: Operation apply callback failed for %s",
                                        pGetOpNameForDebug (Enum.OperationId)
                                        ));
                                    IsmAbortObjectOperationEnum (&Enum);
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from both
                                // the original and new pointer values
                                //

                                pFreeMigContentStruct (&currentContent, ApplyInput, ApplyOutput);

                                //
                                // Apply outputs now become the current content
                                //

                                CopyMemory (&currentContent, ApplyOutput, sizeof (MIG_CONTENT));
                            }
                        }
                    }
                }

            } while (IsmEnumNextObjectOperation (&Enum));
        }

        //
        // Execute last pass global filters and content editors
        //

        if (globalFilterIndex) {

            //
            // Preform last pass global filter
            //

            if (OperationPriority & OP_HIGH_PRIORITY) {

                globalFilter = globalFilterIndex->FilterLastHeadHp;

                while (globalFilter) {

                    if ((!globalFilter->Platform || (globalFilter->Platform & ObjectTypeId)) &&
                        (!TreeFiltersOnly || globalFilter->TreeFilter) &&
                        (!NoRestoreObject || globalFilter->NoRestoreFilter)
                        ) {

                        if (!objectId ||
                            !pIsOperationProhibitedOnObject (globalFilter->OperationId, objectId, TRUE)
                            ) {

                            if (!globalFilter->Callback (
                                    &filterInput,
                                    FilterOutput,
                                    NoRestoreObject,
                                    NULL,
                                    NULL
                                    )) {
                                DEBUGMSG ((
                                    DBG_ERROR,
                                    "ApplyOperationsOnObject: last pass global filter failed for %s",
                                    pGetOpNameForDebug (globalFilter->OperationId)
                                    ));
                                __leave;
                            }

                            //
                            // Free input allocations if they are different from
                            // both the original and new pointer values
                            //

                            pFreeMigObjectStruct (
                                &filterInput.CurrentObject,
                                &filterInput.OriginalObject,
                                &FilterOutput->NewObject
                                );

                            //
                            // Filter outputs now become the inputs
                            //

                            filterInput.CurrentObject = FilterOutput->NewObject;
                            filterInput.Deleted = FilterOutput->Deleted;
                            filterInput.Replaced = FilterOutput->Replaced;
                        }
                    }

                    globalFilter = globalFilter->Next;
                }
            }

            if (OperationPriority & OP_LOW_PRIORITY) {

                globalFilter = globalFilterIndex->FilterLastHead;

                while (globalFilter) {

                    if ((!globalFilter->Platform || (globalFilter->Platform & ObjectTypeId)) &&
                        (!TreeFiltersOnly || globalFilter->TreeFilter) &&
                        (!NoRestoreObject || globalFilter->NoRestoreFilter)
                        ) {

                        if (!objectId ||
                            !pIsOperationProhibitedOnObject (globalFilter->OperationId, objectId, TRUE)
                            ) {

                            if (!globalFilter->Callback (
                                    &filterInput,
                                    FilterOutput,
                                    NoRestoreObject,
                                    NULL,
                                    NULL
                                    )) {
                                DEBUGMSG ((
                                    DBG_ERROR,
                                    "ApplyOperationsOnObject: last pass global filter failed for %s",
                                    pGetOpNameForDebug (globalFilter->OperationId)
                                    ));
                                __leave;
                            }

                            //
                            // Free input allocations if they are different from
                            // both the original and new pointer values
                            //

                            pFreeMigObjectStruct (
                                &filterInput.CurrentObject,
                                &filterInput.OriginalObject,
                                &FilterOutput->NewObject
                                );

                            //
                            // Filter outputs now become the inputs
                            //

                            filterInput.CurrentObject = FilterOutput->NewObject;
                            filterInput.Deleted = FilterOutput->Deleted;
                            filterInput.Replaced = FilterOutput->Replaced;
                        }
                    }

                    globalFilter = globalFilter->Next;
                }
            }

            if (ApplyInput) {

                if (OperationPriority & OP_HIGH_PRIORITY) {

                    globalEdit = globalFilterIndex->EditLastHeadHp;

                    while (globalEdit) {

                        if (!globalEdit->Platform || (globalEdit->Platform & ObjectTypeId)) {

                            if (!objectId ||
                                !pIsOperationProhibitedOnObject (globalEdit->OperationId, objectId, TRUE)
                                ) {

                                //
                                // Call the apply function associated with this operation
                                //

                                if (!globalEdit->Callback (
                                        ObjectTypeId,
                                        ObjectName,
                                        ApplyInput,
                                        &currentContent,
                                        ApplyOutput,
                                        Enum.SourceData,
                                        Enum.DestinationData
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: last pass global callback failed for %s",
                                        pGetOpNameForDebug (globalEdit->OperationId)
                                        ));
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from both
                                // the original and new pointer values
                                //

                                pFreeMigContentStruct (&currentContent, ApplyInput, ApplyOutput);

                                //
                                // Apply outputs now become the current content
                                //

                                CopyMemory (&currentContent, ApplyOutput, sizeof (MIG_CONTENT));
                            }
                        }
                        globalEdit = globalEdit->Next;
                    }
                }

                if (OperationPriority & OP_LOW_PRIORITY) {

                    globalEdit = globalFilterIndex->EditLastHead;

                    while (globalEdit) {

                        if (!globalEdit->Platform || (globalEdit->Platform & ObjectTypeId)) {

                            if (!objectId ||
                                !pIsOperationProhibitedOnObject (globalEdit->OperationId, objectId, TRUE)
                                ) {

                                //
                                // Call the apply function associated with this operation
                                //

                                if (!globalEdit->Callback (
                                        ObjectTypeId,
                                        ObjectName,
                                        ApplyInput,
                                        &currentContent,
                                        ApplyOutput,
                                        Enum.SourceData,
                                        Enum.DestinationData
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: last pass global callback failed for %s",
                                        pGetOpNameForDebug (globalEdit->OperationId)
                                        ));
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from both
                                // the original and new pointer values
                                //

                                pFreeMigContentStruct (&currentContent, ApplyInput, ApplyOutput);

                                //
                                // Apply outputs now become the current content
                                //

                                CopyMemory (&currentContent, ApplyOutput, sizeof (MIG_CONTENT));
                            }
                        }
                        globalEdit = globalEdit->Next;
                    }
                }
            }
        }

        result = TRUE;
    }
    __finally {
        if (!result) {
            //
            // Free all allocations except for the original (made by
            // the caller)
            //

            pFreeMigObjectStruct (
                &filterInput.CurrentObject,
                &filterInput.OriginalObject,
                &FilterOutput->NewObject
                );
            pFreeMigObjectStruct (
                &FilterOutput->NewObject,
                &filterInput.OriginalObject,
                NULL
                );

            if (ApplyInput) {
                pFreeMigContentStruct (&currentContent, ApplyInput, ApplyOutput);
                pFreeMigContentStruct (ApplyOutput, ApplyInput, NULL);
            }
        }
    }

    return result;
}


VOID
FreeFilterOutput (
    IN      MIG_OBJECTSTRINGHANDLE OriginalString,
    IN      PMIG_FILTEROUTPUT FilterOutput
    )
{
    MIG_OBJECT object;

    object.ObjectName = OriginalString;
    pFreeMigObjectStruct (&FilterOutput->NewObject, &object, NULL);
}


VOID
FreeApplyOutput (
    IN      PCMIG_CONTENT OriginalContent,
    IN      PMIG_CONTENT FinalContent
    )
{
    pFreeMigContentStruct (FinalContent, OriginalContent, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\typemgr.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    typemgr.c

Abstract:

    Provides type abstraction layer to the flow control module. Enumerations of Objects are eventually resolved
    to specific types through the interfaces in this module.

Author:

    Jim Schmidt 11-November-1999

Revision History:

    marcw 16-Nov-1999 Implemented necessary changes needed by flowctrl.c

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_TYPEMGR     "TypeMgr"

//
// Strings
//

#define S_OBJECTTYPES       TEXT("ObjectTypes")
#define S_OBJECTIDS         TEXT("ObjectIds")

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR ObjectTypeName [MAX_PATH];
    TCHAR SObjectTypeName [MAX_PATH];
    TCHAR DObjectTypeName [MAX_PATH];
    BOOL CanBeRestored;
    BOOL ReadOnly;
    MIG_OBJECTCOUNT TotalObjects;
    MIG_OBJECTCOUNT SourceObjects;
    MIG_OBJECTCOUNT DestinationObjects;
    PTYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstPhysicalObject;
    PTYPE_ENUMNEXTPHYSICALOBJECT EnumNextPhysicalObject;
    PTYPE_ABORTENUMCURRENTPHYSICALNODE AbortEnumCurrentPhysicalNode;
    PTYPE_ABORTENUMPHYSICALOBJECT AbortEnumPhysicalObject;
    PTYPE_CONVERTOBJECTTOMULTISZ ConvertObjectToMultiSz;
    PTYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToObject;
    PTYPE_GETNATIVEOBJECTNAME GetNativeObjectName;
    PTYPE_ACQUIREPHYSICALOBJECT AcquirePhysicalObject;
    PTYPE_RELEASEPHYSICALOBJECT ReleasePhysicalObject;
    PTYPE_DOESPHYSICALOBJECTEXIST DoesPhysicalObjectExist;
    PTYPE_REMOVEPHYSICALOBJECT RemovePhysicalObject;
    PTYPE_CREATEPHYSICALOBJECT CreatePhysicalObject;
    PTYPE_REPLACEPHYSICALOBJECT ReplacePhysicalObject;
    PTYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertObjectContentToUnicode;
    PTYPE_CONVERTOBJECTCONTENTTOANSI ConvertObjectContentToAnsi;
    PTYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedObjectContent;
    HASHTABLE ExclusionTable;
} TYPEINFO, *PTYPEINFO;

typedef struct {
    MIG_TYPEOBJECTENUM Enum;
    BOOL Completed;
} TOPLEVELENUM_HANDLE, *PTOPLEVELENUM_HANDLE;

typedef struct {
    MIG_OBJECTSTRINGHANDLE Pattern;
    MIG_PARSEDPATTERN ParsedPattern;
    BOOL AddedEnums;
    UINT CurrentEnumId;
} ADDEDOBJECTSENUM, *PADDEDOBJECTSENUM;

//
// Globals
//

GROWBUFFER g_TypeList = INIT_GROWBUFFER;
HASHTABLE g_TypeTable;
MIG_OBJECTTYPEID g_MaxType = 0;

//
// Macro expansion list
//

// none

//
// Private function prototypes
//

BOOL
pEnumNextPhysicalObjectOfType (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
InitializeTypeMgr (
    VOID
    )
{
    g_TypeTable = HtAllocWithData (sizeof (UINT));

    InitDataType ();
    InitRegistryType ();
    InitFileType ();

    return TRUE;
}

PTYPEINFO
GetTypeInfo (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO *typeInfo;
    MIG_OBJECTTYPEID objectTypeId;

    objectTypeId = ObjectTypeId & (~PLATFORM_MASK);
    typeInfo = (PTYPEINFO *) (g_TypeList.Buf);
    if (!objectTypeId) {
        return NULL;
    }
    if ((g_TypeList.End / sizeof (PTYPEINFO)) < objectTypeId) {
        return NULL;
    }
    return *(typeInfo + (objectTypeId - 1));
}

HASHTABLE
GetTypeExclusionTable (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (!typeInfo) {
        return NULL;
    }

    return typeInfo->ExclusionTable;
}

BOOL
pInsertTypeIdAt (
    IN      PGROWBUFFER List,
    IN      PTYPEINFO Data,
    IN      UINT Index
    )
{
    UINT existingElems;

    existingElems = (List->End / sizeof (PTYPEINFO));
    if (existingElems < Index) {
        GbGrow (List, (Index - existingElems) * sizeof (PTYPEINFO));
    }
    CopyMemory (List->Buf + ((Index - 1) * sizeof (PTYPEINFO)), &Data, sizeof (PTYPEINFO));
    return TRUE;
}

VOID
TypeMgrRescanTypes (
    VOID
    )
{
    MEMDB_ENUM e;
    PTYPEINFO typeInfo;
    MIG_OBJECTTYPEID objId;

    // now let's rescan all registered objects and add them to the list (with NULL callbacks)
    if (MemDbEnumFirst (&e, S_OBJECTTYPES TEXT("\\*"), ENUMFLAG_NORMAL, ENUMLEVEL_LASTLEVEL, ENUMLEVEL_ALLLEVELS)) {
        do {
            objId = e.Value;
            typeInfo = GetTypeInfo (objId);
            if (typeInfo) {
                // this type was added already, let's validate it
                MYASSERT (StringIMatch (typeInfo->ObjectTypeName, e.KeyName));
                MYASSERT (g_MaxType >= objId);
            } else {
                // this type was not added yes, let's add an empty one
                typeInfo = IsmGetMemory (sizeof (TYPEINFO));
                ZeroMemory (typeInfo, sizeof (TYPEINFO));
                StringCopy (typeInfo->SObjectTypeName, TEXT("S"));
                StringCat (typeInfo->SObjectTypeName, e.KeyName);
                objId = objId | PLATFORM_SOURCE;
                HtAddStringEx (g_TypeTable, typeInfo->SObjectTypeName, &objId, FALSE);
                objId = objId & (~PLATFORM_MASK);

                StringCopy (typeInfo->DObjectTypeName, TEXT("D"));
                StringCat (typeInfo->DObjectTypeName, e.KeyName);
                objId = objId | PLATFORM_DESTINATION;
                HtAddStringEx (g_TypeTable, typeInfo->DObjectTypeName, &objId, FALSE);
                objId = objId & (~PLATFORM_MASK);

                StringCopy (typeInfo->ObjectTypeName, e.KeyName);
                HtAddStringEx (g_TypeTable, typeInfo->ObjectTypeName, &objId, FALSE);
                pInsertTypeIdAt (&g_TypeList, typeInfo, objId);
                if (g_MaxType < objId) {
                    g_MaxType = objId;
                }
            }
        } while (MemDbEnumNext (&e));
    }
}

VOID
TerminateTypeMgr (
    VOID
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    PTYPEINFO objectTypeInfo;

    objectTypeId = IsmGetFirstObjectTypeId ();
    while (objectTypeId) {
        objectTypeInfo = GetTypeInfo (objectTypeId);
        if (objectTypeInfo) {
            if (objectTypeInfo->ExclusionTable) {
                HtFree (objectTypeInfo->ExclusionTable);
            }
            IsmReleaseMemory (objectTypeInfo);
        }
        objectTypeId = IsmGetNextObjectTypeId (objectTypeId);
    }

    DoneDataType ();
    DoneFileType ();
    DoneRegistryType ();
    GbFree (&g_TypeList);

    if (g_TypeTable) {
        HtFree (g_TypeTable);
        g_TypeTable = NULL;
    }
}

MIG_OBJECTTYPEID
GetObjectTypeId (
    IN      PCTSTR Type
    )
{
    HASHITEM rc;
    MIG_OBJECTTYPEID id;

    if (!g_TypeTable) {
        DEBUGMSG ((DBG_ERROR, "No ETMs registered; can't get object type id"));
        return 0;
    }

    //
    // Given a type string (i.e., File, Registry, etc.), return an id
    //

    rc = HtFindStringEx (g_TypeTable, Type, &id, FALSE);

    if (!rc) {
        return 0;
    }

    return id;
}

PCTSTR
pGetDecoratedObjectTypeName (
    IN      PCTSTR ObjectTypeName
    )
{
    return JoinPaths (S_OBJECTTYPES, ObjectTypeName);
}

BOOL
CanObjectTypeBeRestored (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        return (typeInfo->CanBeRestored);
    }
    return FALSE;
}

BOOL
CanObjectTypeBeModified (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        return (!typeInfo->ReadOnly);
    }
    return FALSE;
}

BOOL
IncrementTotalObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        typeInfo->TotalObjects.TotalObjects ++;
        if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
            typeInfo->SourceObjects.TotalObjects ++;
        } else {
            typeInfo->DestinationObjects.TotalObjects ++;
        }
    }
    ELSE_DEBUGMSG ((DBG_WHOOPS, "Unknown object type ID: %d", ObjectTypeId));
    return FALSE;
}

BOOL
IncrementPersistentObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        typeInfo->TotalObjects.PersistentObjects ++;
        if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
            typeInfo->SourceObjects.PersistentObjects ++;
        } else {
            typeInfo->DestinationObjects.PersistentObjects ++;
        }
    }
    ELSE_DEBUGMSG ((DBG_WHOOPS, "Unknown object type ID: %d", ObjectTypeId));
    return FALSE;
}

BOOL
DecrementPersistentObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        typeInfo->TotalObjects.PersistentObjects --;
        if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
            typeInfo->SourceObjects.PersistentObjects --;
        } else {
            typeInfo->DestinationObjects.PersistentObjects --;
        }
    }
    ELSE_DEBUGMSG ((DBG_WHOOPS, "Unknown object type ID: %d", ObjectTypeId));
    return FALSE;
}

BOOL
IncrementApplyObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        typeInfo->TotalObjects.ApplyObjects ++;
        if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
            typeInfo->SourceObjects.ApplyObjects ++;
        } else {
            typeInfo->DestinationObjects.ApplyObjects ++;
        }
    }
    ELSE_DEBUGMSG ((DBG_WHOOPS, "Unknown object type ID: %d", ObjectTypeId));
    return FALSE;
}

BOOL
DecrementApplyObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        typeInfo->TotalObjects.ApplyObjects --;
        if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
            typeInfo->SourceObjects.ApplyObjects --;
        } else {
            typeInfo->DestinationObjects.ApplyObjects --;
        }
    }
    ELSE_DEBUGMSG ((DBG_WHOOPS, "Unknown object type ID: %d", ObjectTypeId));
    return FALSE;
}

PMIG_OBJECTCOUNT
GetTypeObjectsStatistics (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        if (ObjectTypeId & PLATFORM_SOURCE) {
            return &typeInfo->SourceObjects;
        } else if (ObjectTypeId & PLATFORM_DESTINATION) {
            return &typeInfo->DestinationObjects;
        } else {
            return &typeInfo->TotalObjects;
        }
    }
    ELSE_DEBUGMSG ((DBG_WHOOPS, "Unknown object type ID: %d", ObjectTypeId));
    return NULL;
}

BOOL
SavePerObjectStatistics (
    VOID
    )
{
    MIG_OBJECTCOUNT objectCount [3];
    PCTSTR typeKey;
    MIG_OBJECTTYPEID objectTypeId;
    PTYPEINFO objectTypeInfo;
    BOOL result = TRUE;

    objectTypeId = IsmGetFirstObjectTypeId ();
    while (objectTypeId) {
        objectTypeInfo = GetTypeInfo (objectTypeId);
        if (objectTypeInfo) {
            typeKey = JoinPaths (S_OBJECTCOUNT, objectTypeInfo->ObjectTypeName);

            MYASSERT (
                objectTypeInfo->TotalObjects.TotalObjects ==
                    objectTypeInfo->SourceObjects.TotalObjects +
                    objectTypeInfo->DestinationObjects.TotalObjects
                );
            MYASSERT (
                objectTypeInfo->TotalObjects.PersistentObjects ==
                    objectTypeInfo->SourceObjects.PersistentObjects +
                    objectTypeInfo->DestinationObjects.PersistentObjects
                );
            MYASSERT (
                objectTypeInfo->TotalObjects.ApplyObjects ==
                    objectTypeInfo->SourceObjects.ApplyObjects +
                    objectTypeInfo->DestinationObjects.ApplyObjects
                );

            CopyMemory (&(objectCount [0]), &objectTypeInfo->TotalObjects, sizeof (MIG_OBJECTCOUNT));
            CopyMemory (&(objectCount [1]), &objectTypeInfo->SourceObjects, sizeof (MIG_OBJECTCOUNT));
            CopyMemory (&(objectCount [2]), &objectTypeInfo->DestinationObjects, sizeof (MIG_OBJECTCOUNT));
            if (!MemDbSetUnorderedBlob (typeKey, 0, (PCBYTE)objectCount, 3 * sizeof (MIG_OBJECTCOUNT))) {
                MYASSERT (FALSE);
                EngineError ();
                result = FALSE;
            }
            FreePathString (typeKey);
        }
        objectTypeId = IsmGetNextObjectTypeId (objectTypeId);
    }
    return result;
}

BOOL
LoadPerObjectStatistics (
    VOID
    )
{
    PMIG_OBJECTCOUNT objectCount;
    DWORD size;
    PCTSTR typeKey;
    MIG_OBJECTTYPEID objectTypeId;
    PTYPEINFO objectTypeInfo;
    BOOL result = TRUE;

    objectTypeId = IsmGetFirstObjectTypeId ();
    while (objectTypeId) {
        objectTypeInfo = GetTypeInfo (objectTypeId);
        if (objectTypeInfo) {
            typeKey = JoinPaths (S_OBJECTCOUNT, objectTypeInfo->ObjectTypeName);
            objectCount = (PMIG_OBJECTCOUNT) MemDbGetUnorderedBlob (typeKey, 0, &size);
            if ((!objectCount) || (size != 3 * sizeof (MIG_OBJECTCOUNT))) {
                if (objectCount) {
                    MemDbReleaseMemory (objectCount);
                }
                MYASSERT (FALSE);
                result = FALSE;
            } else {
                CopyMemory (&objectTypeInfo->TotalObjects, objectCount, sizeof (MIG_OBJECTCOUNT));
                CopyMemory (&objectTypeInfo->SourceObjects, objectCount + 1, sizeof (MIG_OBJECTCOUNT));
                CopyMemory (&objectTypeInfo->DestinationObjects, objectCount + 2, sizeof (MIG_OBJECTCOUNT));
                MemDbReleaseMemory (objectCount);

                MYASSERT (
                    objectTypeInfo->TotalObjects.TotalObjects ==
                        objectTypeInfo->SourceObjects.TotalObjects +
                        objectTypeInfo->DestinationObjects.TotalObjects
                    );
                MYASSERT (
                    objectTypeInfo->TotalObjects.PersistentObjects ==
                        objectTypeInfo->SourceObjects.PersistentObjects +
                        objectTypeInfo->DestinationObjects.PersistentObjects
                    );
                MYASSERT (
                    objectTypeInfo->TotalObjects.ApplyObjects ==
                        objectTypeInfo->SourceObjects.ApplyObjects +
                        objectTypeInfo->DestinationObjects.ApplyObjects
                    );
            }
            FreePathString (typeKey);
        }
        objectTypeId = IsmGetNextObjectTypeId (objectTypeId);
    }
    return result;
}

MIG_OBJECTTYPEID
IsmRegisterObjectType (
    IN      PCTSTR ObjectTypeName,
    IN      BOOL CanBeRestored,
    IN      BOOL ReadOnly,
    IN      PTYPE_REGISTER TypeRegisterData
    )
{
    PCTSTR decoratedName;
    MIG_OBJECTTYPEID objectTypeId;
    KEYHANDLE keyHandle1;
    PTYPEINFO typeInfo;

    decoratedName = pGetDecoratedObjectTypeName (ObjectTypeName);
    keyHandle1 = MemDbGetHandleFromKey (decoratedName);
    if (keyHandle1) {
        // this type was registered before, update information
        // let's get the ObjectTypeId from this type
        objectTypeId = GetObjectTypeId (ObjectTypeName);
        typeInfo = GetTypeInfo (objectTypeId);
        if (typeInfo) {
            typeInfo->CanBeRestored = CanBeRestored;
            typeInfo->ReadOnly = ReadOnly;
            if (TypeRegisterData && TypeRegisterData->EnumFirstPhysicalObject) {
                typeInfo->EnumFirstPhysicalObject = TypeRegisterData->EnumFirstPhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->EnumNextPhysicalObject) {
                typeInfo->EnumNextPhysicalObject = TypeRegisterData->EnumNextPhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->AbortEnumCurrentPhysicalNode) {
                typeInfo->AbortEnumCurrentPhysicalNode = TypeRegisterData->AbortEnumCurrentPhysicalNode;
            }
            if (TypeRegisterData && TypeRegisterData->AbortEnumPhysicalObject) {
                typeInfo->AbortEnumPhysicalObject = TypeRegisterData->AbortEnumPhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->ConvertObjectToMultiSz) {
                typeInfo->ConvertObjectToMultiSz = TypeRegisterData->ConvertObjectToMultiSz;
            }
            if (TypeRegisterData && TypeRegisterData->ConvertMultiSzToObject) {
                typeInfo->ConvertMultiSzToObject = TypeRegisterData->ConvertMultiSzToObject;
            }
            if (TypeRegisterData && TypeRegisterData->GetNativeObjectName) {
                typeInfo->GetNativeObjectName = TypeRegisterData->GetNativeObjectName;
            }
            if (TypeRegisterData && TypeRegisterData->AcquirePhysicalObject) {
                typeInfo->AcquirePhysicalObject = TypeRegisterData->AcquirePhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->ReleasePhysicalObject) {
                typeInfo->ReleasePhysicalObject = TypeRegisterData->ReleasePhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->DoesPhysicalObjectExist) {
                typeInfo->DoesPhysicalObjectExist = TypeRegisterData->DoesPhysicalObjectExist;
            }
            if (TypeRegisterData && TypeRegisterData->RemovePhysicalObject) {
                typeInfo->RemovePhysicalObject = TypeRegisterData->RemovePhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->CreatePhysicalObject) {
                typeInfo->CreatePhysicalObject = TypeRegisterData->CreatePhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->ReplacePhysicalObject) {
                typeInfo->ReplacePhysicalObject = TypeRegisterData->ReplacePhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->ConvertObjectContentToUnicode) {
                typeInfo->ConvertObjectContentToUnicode = TypeRegisterData->ConvertObjectContentToUnicode;
            }
            if (TypeRegisterData && TypeRegisterData->ConvertObjectContentToAnsi) {
                typeInfo->ConvertObjectContentToAnsi = TypeRegisterData->ConvertObjectContentToAnsi;
            }
            if (TypeRegisterData && TypeRegisterData->FreeConvertedObjectContent) {
                typeInfo->FreeConvertedObjectContent = TypeRegisterData->FreeConvertedObjectContent;
            }
        } else {
            DEBUGMSG ((DBG_WHOOPS, "Cannot get type info for a registered type: %s", ObjectTypeName));
        }
    } else {
        //
        // Allocate a new type
        //

        typeInfo = IsmGetMemory (sizeof (TYPEINFO));
        ZeroMemory (typeInfo, sizeof (TYPEINFO));
        g_MaxType ++;
        objectTypeId = g_MaxType;
        keyHandle1 = MemDbSetValue (decoratedName, objectTypeId);

        if (!keyHandle1) {
            EngineError ();
            FreePathString (decoratedName);
            return 0;
        }

        //
        // Separate source and destination types
        //

        StringCopy (typeInfo->SObjectTypeName, TEXT("S"));
        StringCat (typeInfo->SObjectTypeName, ObjectTypeName);
        objectTypeId = objectTypeId | PLATFORM_SOURCE;
        HtAddStringEx (g_TypeTable, typeInfo->SObjectTypeName, &objectTypeId, FALSE);
        objectTypeId = objectTypeId & (~PLATFORM_MASK);

        StringCopy (typeInfo->DObjectTypeName, TEXT("D"));
        StringCat (typeInfo->DObjectTypeName, ObjectTypeName);
        objectTypeId = objectTypeId | PLATFORM_DESTINATION;
        HtAddStringEx (g_TypeTable, typeInfo->DObjectTypeName, &objectTypeId, FALSE);
        objectTypeId = objectTypeId & (~PLATFORM_MASK);

        StringCopy (typeInfo->ObjectTypeName, ObjectTypeName);
        HtAddStringEx (g_TypeTable, typeInfo->ObjectTypeName, &objectTypeId, FALSE);

        //
        // Initialize type info struct's callback members and exclusion list
        //

        typeInfo->CanBeRestored = CanBeRestored;
        typeInfo->ReadOnly = ReadOnly;

        if (TypeRegisterData) {
            typeInfo->EnumFirstPhysicalObject = TypeRegisterData->EnumFirstPhysicalObject;
            typeInfo->EnumNextPhysicalObject = TypeRegisterData->EnumNextPhysicalObject;
            typeInfo->AbortEnumCurrentPhysicalNode = TypeRegisterData->AbortEnumCurrentPhysicalNode;
            typeInfo->AbortEnumPhysicalObject = TypeRegisterData->AbortEnumPhysicalObject;
            typeInfo->ConvertObjectToMultiSz = TypeRegisterData->ConvertObjectToMultiSz;
            typeInfo->ConvertMultiSzToObject = TypeRegisterData->ConvertMultiSzToObject;
            typeInfo->GetNativeObjectName = TypeRegisterData->GetNativeObjectName;
            typeInfo->AcquirePhysicalObject = TypeRegisterData->AcquirePhysicalObject;
            typeInfo->ReleasePhysicalObject = TypeRegisterData->ReleasePhysicalObject;
            typeInfo->DoesPhysicalObjectExist = TypeRegisterData->DoesPhysicalObjectExist;
            typeInfo->RemovePhysicalObject = TypeRegisterData->RemovePhysicalObject;
            typeInfo->CreatePhysicalObject = TypeRegisterData->CreatePhysicalObject;
            typeInfo->ReplacePhysicalObject = TypeRegisterData->ReplacePhysicalObject;
            typeInfo->ConvertObjectContentToUnicode = TypeRegisterData->ConvertObjectContentToUnicode;
            typeInfo->ConvertObjectContentToAnsi = TypeRegisterData->ConvertObjectContentToAnsi;
            typeInfo->FreeConvertedObjectContent = TypeRegisterData->FreeConvertedObjectContent;
        }

        typeInfo->ExclusionTable = HtAlloc();

        //
        // Put the typeInfo struct in our list. Then update the flow control
        // structs so that other ETMs can hook the acquire callback of this
        // type.
        //

        pInsertTypeIdAt (&g_TypeList, typeInfo, objectTypeId);
        AddTypeToGlobalEnumerationEnvironment (objectTypeId);

    }
    FreePathString (decoratedName);
    return objectTypeId;
}

MIG_OBJECTTYPEID
IsmGetObjectTypeId (
    IN      PCTSTR ObjectTypeName
    )
{
    return GetObjectTypeId (ObjectTypeName);
}

PCTSTR
GetObjectTypeName (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        switch (ObjectTypeId & PLATFORM_MASK) {
        case PLATFORM_SOURCE:
            return typeInfo->SObjectTypeName;
        case PLATFORM_DESTINATION:
            return typeInfo->DObjectTypeName;
        default:
            return typeInfo->ObjectTypeName;
        }
    } else {
        return FALSE;
    }
}

PCTSTR
IsmGetObjectTypeName (
    IN      MIG_OBJECTTYPEID TypeId
    )
{
    return GetObjectTypeName (TypeId & (~PLATFORM_MASK));
}

MIG_OBJECTTYPEID
IsmGetFirstObjectTypeId (
    VOID
    )
{
    if (!(g_TypeList.End / sizeof (PTYPEINFO))) {
        return 0;
    }

    return 1;
}

MIG_OBJECTTYPEID
IsmGetNextObjectTypeId (
    IN      MIG_OBJECTTYPEID CurrentTypeId
    )
{
    UINT i = (g_TypeList.End / sizeof (PTYPEINFO));

    MYASSERT (i);

    if (CurrentTypeId >= i) {
        return 0;
    }

    return (CurrentTypeId + 1);
}

PCTSTR
GetDecoratedObjectPathFromName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR ObjectName,
    IN      BOOL CanContainPattern
    )
{
    PCTSTR typeStr;

    typeStr = GetObjectTypeName (ObjectTypeId);
    if (!typeStr) {
        return NULL;
    }

    return JoinPaths (typeStr, ObjectName);
}

//
// General
//

VOID
pAbortPhysicalObjectOfTypeEnum (
    IN      PMIG_TYPEOBJECTENUM EnumPtr             ZEROED
    )
{
    PTYPEINFO typeInfo;
    PADDEDOBJECTSENUM handle;

    handle = (PADDEDOBJECTSENUM) EnumPtr->IsmHandle;
    if (!handle) {
        return;
    }

    if (handle->AddedEnums) {
        AbortPhysicalEnumCallback (EnumPtr, handle->CurrentEnumId);
    } else {

        typeInfo = GetTypeInfo (EnumPtr->ObjectTypeId);
        if (typeInfo && typeInfo->AbortEnumPhysicalObject) {
            typeInfo->AbortEnumPhysicalObject (EnumPtr);
        }
    }

    PmReleaseMemory (g_IsmPool, handle->Pattern);
    IsmDestroyParsedPattern (handle->ParsedPattern);
    PmReleaseMemory (g_IsmPool, handle);

    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}

VOID
pAbortVirtualObjectOfTypeEnum (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PMIG_OBJECT_ENUM objEnum;

    if (EnumPtr->NativeObjectName) {
        IsmReleaseMemory (EnumPtr->NativeObjectName);
    }
    if (EnumPtr->ObjectNode) {
        ObsFree (EnumPtr->ObjectNode);
    }
    if (EnumPtr->ObjectLeaf) {
        ObsFree (EnumPtr->ObjectLeaf);
    }
    if (EnumPtr->Details.DetailsData) {
        IsmReleaseMemory (EnumPtr->Details.DetailsData);
    }
    objEnum = (PMIG_OBJECT_ENUM)EnumPtr->IsmHandle;
    if (objEnum) {
        IsmAbortObjectEnum (objEnum);
        IsmReleaseMemory (objEnum);
    }
    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}

VOID
AbortObjectOfTypeEnum (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    if (g_IsmCurrentPlatform == g_IsmModulePlatformContext) {
        pAbortPhysicalObjectOfTypeEnum (EnumPtr);
    } else {
        pAbortVirtualObjectOfTypeEnum (EnumPtr);
    }
}

BOOL
pEnumFirstPhysicalObjectOfType (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    PTYPEINFO typeInfo;
    BOOL result = FALSE;
    PADDEDOBJECTSENUM handle;

    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));

    if (CheckCancel ()) {
        return FALSE;
    }

    handle = (PADDEDOBJECTSENUM) PmGetAlignedMemory (g_IsmPool, sizeof (ADDEDOBJECTSENUM));
    ZeroMemory (handle, sizeof (ADDEDOBJECTSENUM));
    EnumPtr->IsmHandle = handle;
    handle->Pattern = PmDuplicateString (g_IsmPool, Pattern);
    handle->ParsedPattern = IsmCreateParsedPattern (Pattern);

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo && typeInfo->EnumFirstPhysicalObject) {
        EnumPtr->ObjectTypeId = ObjectTypeId;
        result = typeInfo->EnumFirstPhysicalObject (EnumPtr, Pattern, MaxLevel);

        MYASSERT (!result || EnumPtr->ObjectTypeId == ObjectTypeId);

        if (result) {
            result = ExecutePhysicalEnumCheckCallbacks (EnumPtr);

            if (!result) {
                result = pEnumNextPhysicalObjectOfType (EnumPtr);
            }
        } else {
            handle->AddedEnums = TRUE;
            handle->CurrentEnumId = 0;

            ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
            EnumPtr->IsmHandle = handle;
            EnumPtr->ObjectTypeId = ObjectTypeId;

            result = ExecutePhysicalEnumAddCallbacks (
                        EnumPtr,
                        handle->Pattern,
                        handle->ParsedPattern,
                        &handle->CurrentEnumId
                        );
        }
    }

    if (!result) {
        pAbortPhysicalObjectOfTypeEnum (EnumPtr);
    }

    return result;
}

BOOL
pEnumFirstVirtualObjectOfType (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR Pattern,
    IN      UINT MaxLevel
    )
{
    PMIG_OBJECT_ENUM objEnum;
    MIG_CONTENT objectContent;
    BOOL result = FALSE;

    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));

    if (CheckCancel ()) {
        return FALSE;
    }

    objEnum = (PMIG_OBJECT_ENUM)IsmGetMemory (sizeof (MIG_OBJECT_ENUM));
    ZeroMemory (objEnum, sizeof (MIG_OBJECT_ENUM));
    EnumPtr->IsmHandle = objEnum;
    if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
        result = IsmEnumFirstSourceObjectEx (objEnum, ObjectTypeId, Pattern, TRUE);
    } else {
        result = IsmEnumFirstDestinationObjectEx (objEnum, ObjectTypeId, Pattern, TRUE);
    }
    if (result) {
        EnumPtr->ObjectTypeId = objEnum->ObjectTypeId;
        EnumPtr->ObjectName = objEnum->ObjectName;
        EnumPtr->NativeObjectName = IsmGetNativeObjectName (objEnum->ObjectTypeId, objEnum->ObjectName);
        IsmCreateObjectStringsFromHandle (EnumPtr->ObjectName, &EnumPtr->ObjectNode, &EnumPtr->ObjectLeaf);
        if (EnumPtr->ObjectNode) {
            GetNodePatternMinMaxLevels (EnumPtr->ObjectNode, NULL, &EnumPtr->Level, NULL);
        } else {
            EnumPtr->Level = 1;
        }
        EnumPtr->SubLevel = 0;
        EnumPtr->IsLeaf = (EnumPtr->ObjectLeaf != NULL);
        EnumPtr->IsNode = !EnumPtr->IsLeaf;
        EnumPtr->Details.DetailsSize = 0;
        EnumPtr->Details.DetailsData = NULL;
        if (IsmAcquireObject (objEnum->ObjectTypeId, objEnum->ObjectName, &objectContent)) {
            if (objectContent.Details.DetailsSize && objectContent.Details.DetailsData) {
                EnumPtr->Details.DetailsSize = objectContent.Details.DetailsSize;
                EnumPtr->Details.DetailsData = IsmGetMemory (EnumPtr->Details.DetailsSize);
                CopyMemory ((PBYTE)EnumPtr->Details.DetailsData, objectContent.Details.DetailsData, EnumPtr->Details.DetailsSize);
            }
            IsmReleaseObject (&objectContent);
        }
    } else {
        pAbortVirtualObjectOfTypeEnum (EnumPtr);
    }
    return result;
}

BOOL
EnumFirstObjectOfType (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    if (g_IsmCurrentPlatform == g_IsmModulePlatformContext) {
        return pEnumFirstPhysicalObjectOfType (EnumPtr, ObjectTypeId, Pattern, MaxLevel);
    } else {
        return pEnumFirstVirtualObjectOfType (EnumPtr, ObjectTypeId, Pattern, MaxLevel);
    }
}

BOOL
pEnumNextPhysicalObjectOfType (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PTYPEINFO typeInfo;
    PADDEDOBJECTSENUM handle;
    MIG_OBJECTTYPEID objectTypeId = EnumPtr->ObjectTypeId;

    handle = (PADDEDOBJECTSENUM) EnumPtr->IsmHandle;
    MYASSERT (handle);      // if NULL, perhaps the ETM blew it away

    if (CheckCancel ()) {
        pAbortPhysicalObjectOfTypeEnum (EnumPtr);
        return FALSE;
    }

    typeInfo = GetTypeInfo (objectTypeId);
    if (!typeInfo || !typeInfo->EnumNextPhysicalObject) {
        pAbortPhysicalObjectOfTypeEnum (EnumPtr);
        return FALSE;
    }

    if (!handle->AddedEnums) {

        for (;;) {
            if (typeInfo->EnumNextPhysicalObject (EnumPtr)) {

                MYASSERT (EnumPtr->ObjectTypeId == objectTypeId);

                if (ExecutePhysicalEnumCheckCallbacks (EnumPtr)) {
                    return TRUE;
                }

                continue;

            } else {

                break;

            }
        }

        handle->AddedEnums = TRUE;
        handle->CurrentEnumId = 0;

        ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
        EnumPtr->IsmHandle = handle;
        EnumPtr->ObjectTypeId = objectTypeId;
    }

    if (ExecutePhysicalEnumAddCallbacks (
            EnumPtr,
            handle->Pattern,
            handle->ParsedPattern,
            &handle->CurrentEnumId
            )) {
        return TRUE;
    }

    pAbortPhysicalObjectOfTypeEnum (EnumPtr);
    return FALSE;
}


BOOL
pEnumNextVirtualObjectOfType (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PMIG_OBJECT_ENUM objEnum;
    MIG_CONTENT objectContent;
    BOOL result = FALSE;

    if (CheckCancel ()) {
        return FALSE;
    }

    if (EnumPtr->NativeObjectName) {
        IsmReleaseMemory (EnumPtr->NativeObjectName);
        EnumPtr->NativeObjectName = NULL;
    }
    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    if (EnumPtr->Details.DetailsData) {
        EnumPtr->Details.DetailsSize = 0;
        IsmReleaseMemory (EnumPtr->Details.DetailsData);
        EnumPtr->Details.DetailsData = NULL;
    }
    objEnum = (PMIG_OBJECT_ENUM)EnumPtr->IsmHandle;
    result = IsmEnumNextObject (objEnum);
    if (result) {
        EnumPtr->ObjectTypeId = objEnum->ObjectTypeId;
        EnumPtr->ObjectName = objEnum->ObjectName;
        EnumPtr->NativeObjectName = IsmGetNativeObjectName (objEnum->ObjectTypeId, objEnum->ObjectName);
        IsmCreateObjectStringsFromHandle (EnumPtr->ObjectName, &EnumPtr->ObjectNode, &EnumPtr->ObjectLeaf);
        if (EnumPtr->ObjectNode) {
            GetNodePatternMinMaxLevels (EnumPtr->ObjectNode, NULL, &EnumPtr->Level, NULL);
        } else {
            EnumPtr->Level = 1;
        }
        EnumPtr->SubLevel = 0;
        EnumPtr->IsLeaf = (EnumPtr->ObjectLeaf != NULL);
        EnumPtr->IsNode = !EnumPtr->IsLeaf;
        EnumPtr->Details.DetailsSize = 0;
        EnumPtr->Details.DetailsData = NULL;

        if (IsmAcquireObject (objEnum->ObjectTypeId, objEnum->ObjectName, &objectContent)) {
            if (objectContent.Details.DetailsSize && objectContent.Details.DetailsData) {
                EnumPtr->Details.DetailsSize = objectContent.Details.DetailsSize;
                EnumPtr->Details.DetailsData = IsmGetMemory (EnumPtr->Details.DetailsSize);
                CopyMemory ((PBYTE)EnumPtr->Details.DetailsData, objectContent.Details.DetailsData, EnumPtr->Details.DetailsSize);
            }
            IsmReleaseObject (&objectContent);
        }
    } else {
        pAbortVirtualObjectOfTypeEnum (EnumPtr);
    }
    return result;
}

BOOL
EnumNextObjectOfType (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    if (g_IsmCurrentPlatform == g_IsmModulePlatformContext) {
        return pEnumNextPhysicalObjectOfType (EnumPtr);
    } else {
        return pEnumNextVirtualObjectOfType (EnumPtr);
    }
}

VOID
pAbortCurrentPhysicalNodeEnum (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PTYPEINFO typeInfo;
    PADDEDOBJECTSENUM handle;

    handle = (PADDEDOBJECTSENUM) EnumPtr->IsmHandle;

    if (handle->AddedEnums) {
        return;
    }

    typeInfo = GetTypeInfo (EnumPtr->ObjectTypeId);
    if (typeInfo && typeInfo->AbortEnumCurrentPhysicalNode) {
        typeInfo->AbortEnumCurrentPhysicalNode (EnumPtr);
    }
}

VOID
pAbortCurrentVirtualNodeEnum (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    // NTRAID#NTBUG9-153259-2000/08/01-jimschm implement pAbortCurrentVirtualNodeEnum
}

VOID
AbortCurrentNodeEnum (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    if (g_IsmCurrentPlatform == g_IsmModulePlatformContext) {
        pAbortCurrentPhysicalNodeEnum (EnumPtr);
    } else {
        pAbortCurrentVirtualNodeEnum (EnumPtr);
    }
}

BOOL
pIsSameSideType (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    return ((ObjectTypeId & PLATFORM_MASK) == g_IsmCurrentPlatform);
}

BOOL
IsmDoesObjectExist (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    MIG_CONTENT content;

    if (IsmAcquireObjectEx (ObjectTypeId,
                            ObjectName,
                            &content,
                            CONTENTTYPE_DETAILS_ONLY,
                            0) ) {
       IsmReleaseObject (&content);
       return TRUE;
    }

    return FALSE;
}


BOOL
IsmAcquireObjectEx (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PTYPEINFO typeInfo;
    PMIG_CONTENT updatedContent;
    BOOL result = FALSE;
    BOOL callbackResult;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    if (!ObjectContent) {
        return FALSE;
    }

    if (g_IsmCurrentPlatform == PLATFORM_SOURCE && ISRIGHTSIDEOBJECT (ObjectTypeId)) {
        DEBUGMSG ((DBG_WHOOPS, "Can't obtain destination side objects on source side"));
        return FALSE;
    }

    ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    ObjectContent->ObjectTypeId = ObjectTypeId;

    if (pIsSameSideType (ObjectTypeId)) {
        typeInfo = GetTypeInfo (ObjectTypeId);
        if (typeInfo && typeInfo->AcquirePhysicalObject) {

            result = typeInfo->AcquirePhysicalObject (
                        ObjectName,
                        ObjectContent,
                        ContentType,
                        MemoryContentLimit
                        );

            //
            // Process all acquire hooks
            //

            callbackResult = ExecutePhysicalAcquireCallbacks (
                                    ObjectTypeId,
                                    ObjectName,
                                    result ? ObjectContent : NULL,
                                    ContentType,
                                    MemoryContentLimit,
                                    &updatedContent
                                    );

            if (result) {
                if (!callbackResult || updatedContent) {
                    //
                    // Free the original content because it has been replaced or deleted
                    //

                    if (typeInfo->ReleasePhysicalObject) {
                        typeInfo->ReleasePhysicalObject (ObjectContent);
                    }
                }
            }

            if (callbackResult) {
                if (updatedContent) {
                    //
                    // Copy the updated content into the caller's struct
                    //

                    CopyMemory (ObjectContent, updatedContent, sizeof (MIG_CONTENT));
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    result = TRUE;
                }
            } else {
                result = FALSE;
            }
        }
    } else {
        result = g_SelectedTransport->TransportAcquireObject (
                                        ObjectTypeId,
                                        ObjectName,
                                        ObjectContent,
                                        ContentType,
                                        MemoryContentLimit
                                        );
    }
    if (!result) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }
    return result;
}

BOOL
IsmReleaseObject (
    IN      PMIG_CONTENT ObjectContent          ZEROED
    )
{
    PTYPEINFO typeInfo;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    if (pIsSameSideType (ObjectContent->ObjectTypeId)) {
        typeInfo = GetTypeInfo (ObjectContent->ObjectTypeId);
        if (typeInfo) {

            if (!FreeViaAcquirePhysicalCallback (ObjectContent)) {

                if (typeInfo->ReleasePhysicalObject) {
                    result = typeInfo->ReleasePhysicalObject (ObjectContent);
                }
            } else {
                result = TRUE;
            }
        }
    } else {
        result = g_SelectedTransport->TransportReleaseObject (ObjectContent);
    }
    ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));

    return result;
}

PMIG_CONTENT
IsmConvertObjectContentToUnicode (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PTYPEINFO typeInfo;
    PMIG_CONTENT result = NULL;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    if (!ObjectName) {
        return NULL;
    }

    if (!ObjectContent) {
        return NULL;
    }

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo && typeInfo->ConvertObjectContentToUnicode) {

        result = typeInfo->ConvertObjectContentToUnicode (
                    ObjectName,
                    ObjectContent
                    );
    }

    return result;
}

PMIG_CONTENT
IsmConvertObjectContentToAnsi (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PTYPEINFO typeInfo;
    PMIG_CONTENT result = NULL;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    if (!ObjectName) {
        return NULL;
    }

    if (!ObjectContent) {
        return NULL;
    }

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo && typeInfo->ConvertObjectContentToAnsi) {

        result = typeInfo->ConvertObjectContentToAnsi (
                    ObjectName,
                    ObjectContent
                    );
    }

    return result;
}

BOOL
IsmFreeConvertedObjectContent (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PTYPEINFO typeInfo;
    BOOL result = TRUE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    if (!ObjectContent) {
        return TRUE;
    }

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo && typeInfo->FreeConvertedObjectContent) {

        result = typeInfo->FreeConvertedObjectContent (
                    ObjectContent
                    );
    }

    return result;
}

BOOL
pEmptyContent (
    IN      PMIG_CONTENT content
    )
{
    if (content->ContentInFile) {
        return (content->FileContent.ContentPath == NULL);
    } else {
        return (content->MemoryContent.ContentBytes == NULL);
    }
}

BOOL
RestoreObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName,
    OUT     MIG_COMPARERESULT *Compare,             OPTIONAL
    IN      DWORD OperationPriority,
    OUT     PBOOL DeleteFailed
    )
{
    MIG_CONTENT inboundContent;
    MIG_CONTENT outboundContent;
    MIG_FILTEROUTPUT finalObject;
    PTYPEINFO inTypeInfo;
    PTYPEINFO outTypeInfo;
    BOOL result = FALSE;
    MIG_COMPARERESULT compare;
    BOOL overwriteExisting = FALSE;
    BOOL existentSrc = FALSE;

    if (Compare) {
        *Compare = CR_FAILED;
    }
    compare = CR_FAILED;

    if (DeleteFailed) {
        *DeleteFailed = FALSE;
    }

    if (g_IsmCurrentPlatform != PLATFORM_DESTINATION) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot restore objects on left side"));
        return FALSE;
    }

    inTypeInfo = GetTypeInfo (ObjectTypeId);
    if (!inTypeInfo) {
        DEBUGMSG ((DBG_WHOOPS, "Unknown ObjectTypeId"));
        return FALSE;
    }

    if (ISRIGHTSIDEOBJECT (ObjectTypeId)) {
        if (IsmAcquireObject (
                ObjectTypeId,
                ObjectName,
                &inboundContent
                )) {
            existentSrc = TRUE;
        } else {
            existentSrc = FALSE;
            ZeroMemory (&inboundContent, sizeof (MIG_CONTENT));
            inboundContent.ObjectTypeId = ObjectTypeId;
        }
        if (ApplyOperationsOnObject (
                ObjectTypeId,
                ObjectName,
                FALSE,
                FALSE,
                OperationPriority,
                &inboundContent,
                &finalObject,
                &outboundContent
                )) {
            if (finalObject.Deleted) {
                // we need to delete the object
                if (inTypeInfo->RemovePhysicalObject) {
                    result = inTypeInfo->RemovePhysicalObject (ObjectName);
                    if (!result) {
                        if (DeleteFailed) {
                            *DeleteFailed = TRUE;
                        }
                        result = TRUE;
                    }
                } else {
                    DEBUGMSG ((
                        DBG_WHOOPS,
                        "Type %d does not have RemovePhysicalObject callback",
                        (ObjectTypeId & (~PLATFORM_MASK))
                        ));
                }
            } else {
                if (StringIMatch (ObjectName, finalObject.NewObject.ObjectName) &&
                    ((ObjectTypeId & (~PLATFORM_MASK)) == (finalObject.NewObject.ObjectTypeId & (~PLATFORM_MASK))) &&
                    (existentSrc || pEmptyContent (&outboundContent))
                    ) {
                    // same object, nothing to do
                    compare = 0;
                    result = TRUE;
                } else {
                    if ((ObjectTypeId & (~PLATFORM_MASK)) == (finalObject.NewObject.ObjectTypeId & (~PLATFORM_MASK))) {
                        outTypeInfo = inTypeInfo;
                    } else {
                        outTypeInfo = GetTypeInfo (finalObject.NewObject.ObjectTypeId);
                        if (!outTypeInfo) {
                            outTypeInfo = inTypeInfo;
                        }
                    }
                    if (outTypeInfo->CreatePhysicalObject &&
                        outTypeInfo->DoesPhysicalObjectExist &&
                        outTypeInfo->RemovePhysicalObject
                        ) {
                        overwriteExisting = FALSE;
                        if (!overwriteExisting) {
                            overwriteExisting = IsmIsObjectAbandonedOnCollision (
                                                    finalObject.NewObject.ObjectTypeId,
                                                    finalObject.NewObject.ObjectName
                                                    );
                        }
                        if (!overwriteExisting) {
                            overwriteExisting = !IsmIsObjectAbandonedOnCollision (
                                                    ObjectTypeId,
                                                    ObjectName
                                                    );
                        }
                        if (overwriteExisting) {
                            if ((inTypeInfo == outTypeInfo) &&
                                (outTypeInfo->ReplacePhysicalObject)
                                ) {
                                //
                                // we have the same type and the type owner implements ReplacePhysicalObject
                                //
                                if (outTypeInfo->DoesPhysicalObjectExist (finalObject.NewObject.ObjectName)) {
                                    compare = CR_DESTINATION_EXISTS;
                                }
                                result = outTypeInfo->ReplacePhysicalObject (finalObject.NewObject.ObjectName, &outboundContent);
                            } else {
                                //
                                // we are having different types or we need to emulate ReplacePhysicalObject
                                //
                                if (outTypeInfo->DoesPhysicalObjectExist (finalObject.NewObject.ObjectName)) {
                                    result = outTypeInfo->RemovePhysicalObject (finalObject.NewObject.ObjectName);
                                } else {
                                    result = TRUE;
                                }
                                if (result) {
                                    result = outTypeInfo->CreatePhysicalObject (finalObject.NewObject.ObjectName, &outboundContent);
                                } else {
                                    compare = CR_DESTINATION_EXISTS;
                                }
                            }
                        } else {
                            if (!outTypeInfo->DoesPhysicalObjectExist (finalObject.NewObject.ObjectName)) {
                                result = outTypeInfo->CreatePhysicalObject (finalObject.NewObject.ObjectName, &outboundContent);
                            } else {
                                result = TRUE;
                                compare = CR_DESTINATION_EXISTS;
                            }
                        }
                    } else {
                        DEBUGMSG ((
                            DBG_WHOOPS,
                            "Type %d does not have RemovePhysicalObject or CreatePhysicalObject callback",
                            (ObjectTypeId & (~PLATFORM_MASK))
                            ));
                    }
                }
            }
            FreeFilterOutput (ObjectName, &finalObject);
            FreeApplyOutput (&inboundContent, &outboundContent);
        } else {
            DEBUGMSG ((DBG_ERROR, "Failed to apply operations on object %s", ObjectName));
        }

        if (existentSrc) {
            IsmReleaseObject (&inboundContent);
        } else {
            compare = CR_SOURCE_DOES_NOT_EXIST;
        }
    } else {
        if (IsmAcquireObject (
                ObjectTypeId,
                ObjectName,
                &inboundContent
                )) {
            if (ApplyOperationsOnObject (
                    ObjectTypeId,
                    ObjectName,
                    FALSE,
                    FALSE,
                    OperationPriority,
                    &inboundContent,
                    &finalObject,
                    &outboundContent
                    )) {
                if (finalObject.Deleted) {
                    // nothing to do, the virtual object won't get restored
                    result = TRUE;
                } else {
                    if ((ObjectTypeId & (~PLATFORM_MASK)) == (finalObject.NewObject.ObjectTypeId & (~PLATFORM_MASK))) {
                        outTypeInfo = inTypeInfo;
                    } else {
                        outTypeInfo = GetTypeInfo (finalObject.NewObject.ObjectTypeId);
                        if (!outTypeInfo) {
                            outTypeInfo = inTypeInfo;
                        }
                    }
                    if (outTypeInfo->CreatePhysicalObject &&
                        outTypeInfo->DoesPhysicalObjectExist &&
                        outTypeInfo->RemovePhysicalObject
                        ) {
                        overwriteExisting = FALSE;
                        if (!overwriteExisting) {
                            overwriteExisting = IsmIsObjectAbandonedOnCollision (
                                                    (finalObject.NewObject.ObjectTypeId & (~PLATFORM_MASK)) | PLATFORM_DESTINATION,
                                                    finalObject.NewObject.ObjectName
                                                    );
                        }
                        if (!overwriteExisting) {
                            overwriteExisting = !IsmIsObjectAbandonedOnCollision (
                                                    ObjectTypeId,
                                                    ObjectName
                                                    );
                        }
                        if (overwriteExisting) {
                            if ((inTypeInfo == outTypeInfo) &&
                                (outTypeInfo->ReplacePhysicalObject)
                                ) {
                                //
                                // we have the same type and the type owner implements ReplacePhysicalObject
                                //
                                if (outTypeInfo->DoesPhysicalObjectExist (finalObject.NewObject.ObjectName)) {
                                    compare = CR_DESTINATION_EXISTS;
                                }
                                result = outTypeInfo->ReplacePhysicalObject (finalObject.NewObject.ObjectName, &outboundContent);
                            } else {
                                //
                                // we are having different types or we need to emulate ReplacePhysicalObject
                                //
                                if (outTypeInfo->DoesPhysicalObjectExist (finalObject.NewObject.ObjectName)) {
                                    result = outTypeInfo->RemovePhysicalObject (finalObject.NewObject.ObjectName);
                                } else {
                                    result = TRUE;
                                }
                                if (result) {
                                    result = outTypeInfo->CreatePhysicalObject (finalObject.NewObject.ObjectName, &outboundContent);
                                } else {
                                    compare = CR_DESTINATION_EXISTS;
                                }
                            }
                        } else {
                            if (!outTypeInfo->DoesPhysicalObjectExist (finalObject.NewObject.ObjectName)) {
                                result = outTypeInfo->CreatePhysicalObject (finalObject.NewObject.ObjectName, &outboundContent);
                            } else {
                                result = TRUE;
                                compare = CR_DESTINATION_EXISTS;
                            }
                        }
                    } else {
                        DEBUGMSG ((
                            DBG_WHOOPS,
                            "Type %d does not have RemovePhysicalObject or CreatePhysicalObject callback",
                            (ObjectTypeId & (~PLATFORM_MASK))
                            ));
                    }
                }
                FreeFilterOutput (ObjectName, &finalObject);
                FreeApplyOutput (&inboundContent, &outboundContent);
            } else {
                DEBUGMSG ((DBG_ERROR, "Failed to apply operations on object %s", ObjectName));
            }
            IsmReleaseObject (&inboundContent);
        } else {
            compare = CR_SOURCE_DOES_NOT_EXIST;
        }
    }

    if (Compare) {
        *Compare = compare;
    }

    return result;
}

BOOL
pPhysicalObjectEnumWorker (
    IN      BOOL Result,
    IN OUT  PMIG_OBJECT_ENUM ObjectEnum,
    IN      PTOPLEVELENUM_HANDLE Handle
    )
{
    if (!Result) {
        AbortPhysicalObjectEnum (ObjectEnum);
    } else {
        ObjectEnum->ObjectTypeId = Handle->Enum.ObjectTypeId;
        ObjectEnum->ObjectName = Handle->Enum.ObjectName;
    }

    return Result;
}


BOOL
EnumFirstPhysicalObject (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern
    )
{
    PTOPLEVELENUM_HANDLE handle;
    BOOL b;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    ZeroMemory (ObjectEnum, sizeof (MIG_OBJECT_ENUM));

    ObjectEnum->Handle = MemAllocZeroed (sizeof (TOPLEVELENUM_HANDLE));
    handle = (PTOPLEVELENUM_HANDLE) ObjectEnum->Handle;

    b = EnumFirstObjectOfType (&handle->Enum, ObjectTypeId, ObjectPattern, NODE_LEVEL_MAX);

    return pPhysicalObjectEnumWorker (b, ObjectEnum, handle);
}


BOOL
EnumNextPhysicalObject (
    IN OUT  PMIG_OBJECT_ENUM ObjectEnum
    )
{
    PTOPLEVELENUM_HANDLE handle;
    BOOL b;

    handle = (PTOPLEVELENUM_HANDLE) ObjectEnum->Handle;

    b = EnumNextObjectOfType (&handle->Enum);

    if (!b) {
        handle->Completed = TRUE;
    }

    return pPhysicalObjectEnumWorker (b, ObjectEnum, handle);
}


VOID
AbortPhysicalObjectEnum (
    IN      PMIG_OBJECT_ENUM ObjectEnum
    )
{
    PTOPLEVELENUM_HANDLE handle;

    handle = (PTOPLEVELENUM_HANDLE) ObjectEnum->Handle;

    if (handle) {
        if (!handle->Completed) {
            AbortObjectOfTypeEnum (&handle->Enum);
        }

        FreeAlloc (handle);
    }

    ZeroMemory (ObjectEnum, sizeof (MIG_OBJECT_ENUM));
}

PCTSTR
IsmConvertObjectToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PTYPEINFO typeInfo;
    PCTSTR result = NULL;

    typeInfo = GetTypeInfo (ObjectContent->ObjectTypeId);
    if (typeInfo && typeInfo->ConvertObjectToMultiSz) {
        result = typeInfo->ConvertObjectToMultiSz (ObjectName, ObjectContent);
    }
    return result;
}

BOOL
IsmConvertMultiSzToObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    )
{
    PTYPEINFO typeInfo;
    BOOL result = FALSE;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo && typeInfo->ConvertMultiSzToObject) {

        if (ObjectContent) {
            ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
            ObjectContent->ObjectTypeId = ObjectTypeId;
        }

        result = typeInfo->ConvertMultiSzToObject (ObjectMultiSz, ObjectName, ObjectContent);
    }
    return result;
}

PCTSTR
TrackedIsmGetNativeObjectName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
            TRACKING_DEF
    )
{
    PTYPEINFO typeInfo;
    PCTSTR result = NULL;

    TRACK_ENTER();

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo && typeInfo->GetNativeObjectName) {
        result = typeInfo->GetNativeObjectName (ObjectName);
    }

    TRACK_LEAVE();
    return result;
}

BOOL
pUserKeyPrefix (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR nativeObjectName;
    BOOL result = FALSE;

    nativeObjectName = IsmGetNativeObjectName (ObjectTypeId, ObjectName);
    result = StringIMatchTcharCount (TEXT("HKCU\\"), nativeObjectName, 5);
    IsmReleaseMemory (nativeObjectName);
    return result;
}

BOOL
IsmDoesRollbackDataExist (
    OUT     PCTSTR *UserName,
    OUT     PCTSTR *UserDomain,
    OUT     PCTSTR *UserStringSid,
    OUT     PCTSTR *UserProfilePath,
    OUT     BOOL *UserProfileCreated
    )
{
    TCHAR userName [MAX_TCHAR_PATH];
    TCHAR userDomain [MAX_TCHAR_PATH];
    TCHAR userStringSid [MAX_TCHAR_PATH];
    TCHAR userProfilePath [MAX_TCHAR_PATH];
    BOOL userProfileCreated;
    PCTSTR journalFile = NULL;
    DWORD tempField;
    BOOL result = FALSE;

    if (g_JournalHandle) {
        return FALSE;
    }
    if (!g_JournalDirectory) {
        return FALSE;
    }

    __try {

        // Open the journal file
        journalFile = JoinPaths (g_JournalDirectory, TEXT("JOURNAL.DAT"));
        g_JournalHandle = BfOpenReadFile (journalFile);
        if (!g_JournalHandle) {
            __leave;
        }
        FreePathString (journalFile);
        journalFile = NULL;

        if (!BfReadFile (g_JournalHandle, (PBYTE)(&tempField), sizeof (DWORD))) {
            __leave;
        }

        if (tempField != JRN_SIGNATURE) {
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(&tempField), sizeof (DWORD))) {
            __leave;
        }

        if (tempField != JRN_VERSION) {
            __leave;
        }

        // now read user's name, domain, SID and profile path
        if (!BfReadFile (g_JournalHandle, (PBYTE)(userName), MAX_TCHAR_PATH)) {
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(userDomain), MAX_TCHAR_PATH)) {
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(userStringSid), MAX_TCHAR_PATH)) {
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(userProfilePath), MAX_TCHAR_PATH)) {
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(&userProfileCreated), sizeof (BOOL))) {
            __leave;
        }

        result = TRUE;
    }
    __finally {
        if (g_JournalHandle) {
            CloseHandle (g_JournalHandle);
            g_JournalHandle = NULL;
        }

        if (journalFile) {
            FreePathString (journalFile);
            journalFile = NULL;
        }
    }

    if (result) {
        if (UserName) {
            *UserName = PmDuplicateString (g_IsmPool, userName);
        }
        if (UserDomain) {
            *UserDomain = PmDuplicateString (g_IsmPool, userDomain);
        }
        if (UserStringSid) {
            *UserStringSid = PmDuplicateString (g_IsmPool, userStringSid);
        }
        if (UserProfilePath) {
            *UserProfilePath = PmDuplicateString (g_IsmPool, userProfilePath);
        }
        if (UserProfileCreated) {
            *UserProfileCreated = userProfileCreated;
        }
    }

    return result;
}

BOOL
IsmRollback (
    VOID
    )
{
#ifdef PRERELEASE
    // crash hooks
    static DWORD totalObjects = 0;
    MIG_OBJECTTYPEID objTypeId;
    PCTSTR nativeName = NULL;
#endif
    GROWBUFFER buffer = INIT_GROWBUFFER;
    TCHAR userName [MAX_TCHAR_PATH];
    TCHAR userDomain [MAX_TCHAR_PATH];
    TCHAR userStringSid [MAX_TCHAR_PATH];
    TCHAR userProfilePath [MAX_TCHAR_PATH];
    BOOL userProfileCreated;
    PCTSTR journalFile = NULL;
    DWORD entrySizeHead;
    DWORD entrySizeTail;
    LONGLONG fileMaxPos = 0;
    PBYTE currPtr;
    DWORD tempSize;
    PDWORD operationType;
    MIG_OBJECTTYPEID *objectTypeId;
    ENCODEDSTRHANDLE objectName;
    MIG_CONTENT objectContent;
    PTYPEINFO typeInfo;
    DWORD tempField;
    BOOL ignoreUserKeys = TRUE;
    BOOL mappedUserProfile = FALSE;
    PCURRENT_USER_DATA currentUserData = NULL;
#ifdef DEBUG
    PCTSTR nativeObjectName;
#endif

    if (g_JournalHandle) {
        return FALSE;
    }
    if (!g_JournalDirectory) {
        return FALSE;
    }

    g_RollbackMode = TRUE;

    __try {

        // Open the journal file
        journalFile = JoinPaths (g_JournalDirectory, TEXT("JOURNAL.DAT"));
        g_JournalHandle = BfOpenReadFile (journalFile);
        if (!g_JournalHandle) {
            LOG ((LOG_WARNING, (PCSTR) MSG_ROLLBACK_CANT_FIND_JOURNAL, journalFile));
            __leave;
        }
        FreePathString (journalFile);
        journalFile = NULL;

        if (!BfReadFile (g_JournalHandle, (PBYTE)(&tempField), sizeof (DWORD))) {
            LOG ((LOG_ERROR, (PCSTR) MSG_ROLLBACK_INVALID_JOURNAL, journalFile));
            __leave;
        }

        if (tempField != JRN_SIGNATURE) {
            LOG ((LOG_ERROR, (PCSTR) MSG_ROLLBACK_INVALID_JOURNAL, journalFile));
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(&tempField), sizeof (DWORD))) {
            LOG ((LOG_ERROR, (PCSTR) MSG_ROLLBACK_INVALID_JOURNAL, journalFile));
            __leave;
        }

        if (tempField != JRN_VERSION) {
            LOG ((LOG_ERROR, (PCSTR) MSG_ROLLBACK_INVALID_JOURNAL_VER, journalFile));
            __leave;
        }

        // now read user's name, domain, SID and profile path
        if (!BfReadFile (g_JournalHandle, (PBYTE)(userName), MAX_TCHAR_PATH)) {
            LOG ((LOG_WARNING, (PCSTR) MSG_ROLLBACK_NOTHING_TO_DO));
            FiRemoveAllFilesInTree (g_JournalDirectory);
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(userDomain), MAX_TCHAR_PATH)) {
            LOG ((LOG_WARNING, (PCSTR) MSG_ROLLBACK_NOTHING_TO_DO));
            FiRemoveAllFilesInTree (g_JournalDirectory);
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(userStringSid), MAX_TCHAR_PATH)) {
            LOG ((LOG_WARNING, (PCSTR) MSG_ROLLBACK_NOTHING_TO_DO));
            FiRemoveAllFilesInTree (g_JournalDirectory);
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(userProfilePath), MAX_TCHAR_PATH)) {
            LOG ((LOG_WARNING, (PCSTR) MSG_ROLLBACK_NOTHING_TO_DO));
            FiRemoveAllFilesInTree (g_JournalDirectory);
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(&userProfileCreated), sizeof (BOOL))) {
            LOG ((LOG_WARNING, (PCSTR) MSG_ROLLBACK_NOTHING_TO_DO));
            FiRemoveAllFilesInTree (g_JournalDirectory);
            __leave;
        }

        // get current user data
        currentUserData = GetCurrentUserData ();
        if (currentUserData) {
            if (StringIMatch (userProfilePath, currentUserData->UserProfilePath)) {
                // if we are in the same profile we'll just continue if we are talking about the same user
                // This is possible in two cases:
                // 1. There was a merge with current user
                // 2. A profile was created but we are logged on as that profile
                ignoreUserKeys = !(StringIMatch (userStringSid, currentUserData->UserStringSid));
            } else {
                // we are logged on with a different profile
                if (userProfileCreated) {
                    // 1. If the old user was created we will attempt to remove it's profile
                    //    and we will ignore all user keys
                    ignoreUserKeys = TRUE;
                    if (*userProfilePath && *userStringSid) {
                        // we successfully created a user before, let's remove it's profile
                        DeleteUserProfile (userStringSid, userProfilePath);
                    }
                } else {
                    // 2. We did not create the user. It means that we are logged on as
                    //    a different user and we need to map it's profile in. We will not
                    //    ignore user keys
                    mappedUserProfile = MapUserProfile (userStringSid, userProfilePath);
                    if (mappedUserProfile) {
                        ignoreUserKeys = FALSE;
                    } else {
                        // some error occured, we cannot restore user keys
                        ignoreUserKeys = TRUE;
                    }
                }
            }
        } else {
            // we cannot assume nothing about the user's hive.
            // We'll just have to ignore all user's keys
            ignoreUserKeys = TRUE;
        }

        // Validate the file
        // We start from the beginning and read a DWORD, skip the DWORD value and expect to
        // read the same DWORD after that
        // We stop the first time when this is not true, assuming that a crash has made the
        // rest of the file useless.
        while (TRUE) {
            if (!BfReadFile (g_JournalHandle, (PBYTE)&entrySizeHead, sizeof (DWORD))) {
                break;
            }
            if (!BfSetFilePointer (g_JournalHandle, JOURNAL_FULL_HEADER_SIZE + fileMaxPos + sizeof (DWORD) + (LONGLONG)entrySizeHead)) {
                break;
            }
            if (!BfReadFile (g_JournalHandle, (PBYTE)&entrySizeTail, sizeof (DWORD))) {
                break;
            }
            if (entrySizeHead != entrySizeTail) {
                break;
            }
            fileMaxPos += entrySizeHead + 2 * sizeof (DWORD);
        }
        if (fileMaxPos == 0) {
            LOG ((LOG_WARNING, (PCSTR) MSG_ROLLBACK_EMPTY_OR_INVALID_JOURNAL, journalFile));
        } else {
            while (fileMaxPos) {
                fileMaxPos -= sizeof (DWORD);
                if (!BfSetFilePointer (g_JournalHandle, JOURNAL_FULL_HEADER_SIZE + fileMaxPos)) {
                    break;
                }
                if (!BfReadFile (g_JournalHandle, (PBYTE)&entrySizeTail, sizeof (DWORD))) {
                    break;
                }
                fileMaxPos -= entrySizeTail;
                if (!BfSetFilePointer (g_JournalHandle, JOURNAL_FULL_HEADER_SIZE + fileMaxPos)) {
                    break;
                }
                buffer.End = 0;
                if (!BfReadFile (g_JournalHandle, GbGrow (&buffer, entrySizeTail), entrySizeTail)) {
                    break;
                }

                // Now process the entry
                currPtr = buffer.Buf;
                operationType = (PDWORD) currPtr;
                currPtr += sizeof (DWORD);
                switch (*operationType) {
                case JRNOP_CREATE:

                    // get the object type id
                    objectTypeId = (MIG_OBJECTTYPEID *) currPtr;
                    currPtr += sizeof (MIG_OBJECTTYPEID);
                    // get the object name
                    currPtr += sizeof (DWORD);
                    objectName = (ENCODEDSTRHANDLE) currPtr;
#ifdef PRERELEASE
                    // crash hooks
                    totalObjects ++;
                    if (g_CrashCountObjects == totalObjects) {
                        DebugBreak ();
                    }
                    objTypeId = (*objectTypeId) & (~PLATFORM_MASK);
                    if (g_CrashNameTypeId == objTypeId) {
                        nativeName = IsmGetNativeObjectName (objTypeId, objectName);
                        if (StringIMatch (nativeName, g_CrashNameObject)) {
                            DebugBreak ();
                        }
                        IsmReleaseMemory (nativeName);
                    }
#endif

                    if (ignoreUserKeys && (*objectTypeId == MIG_REGISTRY_TYPE) && pUserKeyPrefix (*objectTypeId, objectName)) {
                        // we are just ignoring this
#ifdef DEBUG
                        nativeObjectName = IsmGetNativeObjectName (*objectTypeId, objectName);
                        DEBUGMSG ((DBG_VERBOSE, "Ignoring user key %s", nativeObjectName));
                        IsmReleaseMemory (nativeObjectName);
#endif
                    } else {
                        typeInfo = GetTypeInfo (*objectTypeId);
                        if (!typeInfo) {
                            DEBUGMSG ((DBG_WHOOPS, "Rollback: Unknown ObjectTypeId: %d", *objectTypeId));
                        } else {
                            if (typeInfo->RemovePhysicalObject) {
                                typeInfo->RemovePhysicalObject (objectName);
                            }
                            ELSE_DEBUGMSG ((DBG_WHOOPS, "Rollback: ObjectTypeId %d does not implement RemovePhysicalObject", *objectTypeId));
                        }
                    }
                    break;
                case JRNOP_DELETE:
                    // get the object type id
                    objectTypeId = (MIG_OBJECTTYPEID *) currPtr;
                    currPtr += sizeof (MIG_OBJECTTYPEID);
                    // get the object name
                    tempSize = *((PDWORD)currPtr);
                    currPtr += sizeof (DWORD);
                    objectName = (ENCODEDSTRHANDLE) currPtr;
                    MYASSERT (tempSize == SizeOfString (objectName));
                    currPtr += tempSize;
                    // get the object content
                    tempSize = *((PDWORD)currPtr);
                    MYASSERT (tempSize == sizeof (MIG_CONTENT));
                    currPtr += sizeof (DWORD);
                    CopyMemory (&objectContent, currPtr, sizeof (MIG_CONTENT));
                    objectContent.EtmHandle = NULL;
                    objectContent.IsmHandle = NULL;
                    currPtr += tempSize;
                    // get the object details, put them in the object content
                    tempSize = *((PDWORD)currPtr);
                    currPtr += sizeof (DWORD);
                    objectContent.Details.DetailsSize = tempSize;
                    if (tempSize) {
                        objectContent.Details.DetailsData = IsmGetMemory (tempSize);
                        CopyMemory ((PBYTE)(objectContent.Details.DetailsData), currPtr, tempSize);
                    } else {
                        objectContent.Details.DetailsData = NULL;
                    }
                    currPtr += tempSize;
                    // get the actual memory or file content
                    if (objectContent.ContentInFile) {
                        tempSize = *((PDWORD)currPtr);
                        currPtr += sizeof (DWORD);
                        if (tempSize) {
                            objectContent.FileContent.ContentPath = JoinPaths (g_JournalDirectory, (PCTSTR)currPtr);
                        } else {
                            objectContent.FileContent.ContentSize = 0;
                            objectContent.FileContent.ContentPath = NULL;
                        }
                        currPtr += tempSize;
                    } else {
                        tempSize = *((PDWORD)currPtr);
                        currPtr += sizeof (DWORD);
                        if (tempSize) {
                            MYASSERT (objectContent.MemoryContent.ContentSize == tempSize);
                            objectContent.MemoryContent.ContentSize = tempSize;
                            objectContent.MemoryContent.ContentBytes = IsmGetMemory (tempSize);
                            CopyMemory ((PBYTE)(objectContent.MemoryContent.ContentBytes), currPtr, tempSize);
                        } else {
                            objectContent.MemoryContent.ContentSize = 0;
                            objectContent.MemoryContent.ContentBytes = NULL;
                        }
                        currPtr += tempSize;
                    }
                    if (ignoreUserKeys && (*objectTypeId == MIG_REGISTRY_TYPE) && pUserKeyPrefix (*objectTypeId, objectName)) {
                        // we are just ignoring this
#ifdef DEBUG
                        nativeObjectName = IsmGetNativeObjectName (*objectTypeId, objectName);
                        DEBUGMSG ((DBG_VERBOSE, "Ignoring user key %s", nativeObjectName));
                        IsmReleaseMemory (nativeObjectName);
#endif
                    } else {
                        typeInfo = GetTypeInfo (*objectTypeId);
                        if (!typeInfo) {
                            DEBUGMSG ((DBG_WHOOPS, "Rollback: Unknown ObjectTypeId: %d", *objectTypeId));
                        } else {
                            if (typeInfo->CreatePhysicalObject) {
                                typeInfo->CreatePhysicalObject (objectName, &objectContent);
                            }
                            ELSE_DEBUGMSG ((DBG_WHOOPS, "Rollback: ObjectTypeId %d does not implement CreatePhysicalObject", *objectTypeId));
                        }
                    }
                    break;
                default:
                    DEBUGMSG ((DBG_WHOOPS, "Rollback: Wrong operation type in pRecordOperation: %d", operationType));
                }

                fileMaxPos -= sizeof (DWORD);
            }
        }
        //
        // We successfully completed the rollback, let's remove the journal directory
        //
        CloseHandle (g_JournalHandle);
        g_JournalHandle = NULL;

        FiRemoveAllFilesInTree (g_JournalDirectory);
    }
    __finally {
        if (mappedUserProfile) {
            UnmapUserProfile (userStringSid);
            mappedUserProfile = FALSE;
        }

        if (currentUserData) {
            FreeCurrentUserData (currentUserData);
            currentUserData = NULL;
        }

        GbFree (&buffer);

        if (g_JournalHandle) {
            CloseHandle (g_JournalHandle);
            g_JournalHandle = NULL;
        }

        if (journalFile) {
            FreePathString (journalFile);
            journalFile = NULL;
        }

        g_RollbackMode = FALSE;

    }

    return TRUE;
}

BOOL
ExecuteDelayedOperations (
    IN      BOOL CleanupOnly
    )
{
    GROWBUFFER buffer = INIT_GROWBUFFER;
    PCURRENT_USER_DATA currentUserData = NULL;
    PCTSTR journalDir = NULL;
    PCTSTR journalFile = NULL;
    HANDLE journalFileHandle = NULL;
    DWORD tempField;
    DWORD entrySizeHead;
    DWORD entrySizeTail;
    LONGLONG fileMaxPos = 0;
    DWORD tempSize;
    PBYTE currPtr;
    PDWORD operationType;
    MIG_OBJECTTYPEID *objectTypeId;
    ENCODEDSTRHANDLE objectName;
    MIG_CONTENT objectContent;
    PTYPEINFO typeInfo;
    BOOL result = FALSE;

    __try {
        currentUserData = GetCurrentUserData ();
        if (!currentUserData) {
            __leave;
        }

        journalDir = JoinPaths (currentUserData->UserProfilePath, TEXT("usrusmt2.tmp"));

        if (!CleanupOnly) {

            journalFile = JoinPaths (journalDir, TEXT("JOURNAL.DAT"));

            journalFileHandle = BfOpenReadFile (journalFile);
            if (!journalFileHandle) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DELAY_CANT_FIND_JOURNAL, journalFile));
                __leave;
            }

            if (!BfReadFile (journalFileHandle, (PBYTE)(&tempField), sizeof (DWORD))) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DELAY_INVALID_JOURNAL, journalFile));
                __leave;
            }
            if (tempField != JRN_USR_SIGNATURE) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DELAY_INVALID_JOURNAL, journalFile));
                __leave;
            }

            if (!BfReadFile (journalFileHandle, (PBYTE)(&tempField), sizeof (DWORD))) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DELAY_INVALID_JOURNAL, journalFile));
                __leave;
            }
            if (tempField != JRN_USR_VERSION) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DELAY_INVALID_JOURNAL_VER, journalFile));
                __leave;
            }

            if (!BfReadFile (journalFileHandle, (PBYTE)(&tempField), sizeof (DWORD))) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DELAY_INVALID_JOURNAL, journalFile));
                __leave;
            }
            if (tempField != JRN_USR_COMPLETE) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DELAY_INVALID_JOURNAL_STATE, journalFile));
                __leave;
            }

            // Validate the file
            // We start from the beginning and read a DWORD, skip the DWORD value and expect to
            // read the same DWORD after that
            // We stop the first time when this is not true, assuming that a crash has made the
            // rest of the file useless.
            while (TRUE) {
                if (!BfReadFile (journalFileHandle, (PBYTE)&entrySizeHead, sizeof (DWORD))) {
                    break;
                }
                if (!BfSetFilePointer (journalFileHandle, JRN_USR_HEADER_SIZE + fileMaxPos + sizeof (DWORD) + (LONGLONG)entrySizeHead)) {
                    break;
                }
                if (!BfReadFile (journalFileHandle, (PBYTE)&entrySizeTail, sizeof (DWORD))) {
                    break;
                }
                if (entrySizeHead != entrySizeTail) {
                    break;
                }
                fileMaxPos += entrySizeHead + 2 * sizeof (DWORD);
            }

            if (fileMaxPos == 0) {
                LOG ((LOG_WARNING, (PCSTR) MSG_DELAY_EMPTY_OR_INVALID_JOURNAL, journalFile));
            } else {
                while (fileMaxPos) {
                    fileMaxPos -= sizeof (DWORD);
                    if (!BfSetFilePointer (journalFileHandle, JRN_USR_HEADER_SIZE + fileMaxPos)) {
                        break;
                    }
                    if (!BfReadFile (journalFileHandle, (PBYTE)&entrySizeTail, sizeof (DWORD))) {
                        break;
                    }
                    fileMaxPos -= entrySizeTail;
                    if (!BfSetFilePointer (journalFileHandle, JRN_USR_HEADER_SIZE + fileMaxPos)) {
                        break;
                    }
                    buffer.End = 0;
                    if (!BfReadFile (journalFileHandle, GbGrow (&buffer, entrySizeTail), entrySizeTail)) {
                        break;
                    }

                    // Now process the entry
                    // BUGBUG - implement this

                    // Now process the entry
                    currPtr = buffer.Buf;
                    operationType = (PDWORD) currPtr;
                    currPtr += sizeof (DWORD);
                    switch (*operationType) {
                    case JRNOP_DELETE:
                        // get the object type id
                        objectTypeId = (MIG_OBJECTTYPEID *) currPtr;
                        currPtr += sizeof (MIG_OBJECTTYPEID);
                        // get the object name
                        currPtr += sizeof (DWORD);
                        objectName = (ENCODEDSTRHANDLE) currPtr;
                        typeInfo = GetTypeInfo (*objectTypeId);
                        if (!typeInfo) {
                            DEBUGMSG ((DBG_WHOOPS, "Delayed operations: Unknown ObjectTypeId: %d", *objectTypeId));
                        } else {
                            if (typeInfo->RemovePhysicalObject) {
                                typeInfo->RemovePhysicalObject (objectName);
                            }
                            ELSE_DEBUGMSG ((DBG_WHOOPS, "Delayed operations: ObjectTypeId %d does not implement RemovePhysicalObject", *objectTypeId));
                        }
                        break;
                    case JRNOP_CREATE:
                    case JRNOP_REPLACE:
                        // get the object type id
                        objectTypeId = (MIG_OBJECTTYPEID *) currPtr;
                        currPtr += sizeof (MIG_OBJECTTYPEID);
                        // get the object name
                        tempSize = *((PDWORD)currPtr);
                        currPtr += sizeof (DWORD);
                        objectName = (ENCODEDSTRHANDLE) currPtr;
                        MYASSERT (tempSize == SizeOfString (objectName));
                        currPtr += tempSize;
                        // get the object content
                        tempSize = *((PDWORD)currPtr);
                        MYASSERT (tempSize == sizeof (MIG_CONTENT));
                        currPtr += sizeof (DWORD);
                        CopyMemory (&objectContent, currPtr, sizeof (MIG_CONTENT));
                        objectContent.EtmHandle = NULL;
                        objectContent.IsmHandle = NULL;
                        currPtr += tempSize;
                        // get the object details, put them in the object content
                        tempSize = *((PDWORD)currPtr);
                        currPtr += sizeof (DWORD);
                        objectContent.Details.DetailsSize = tempSize;
                        if (tempSize) {
                            objectContent.Details.DetailsData = IsmGetMemory (tempSize);
                            CopyMemory ((PBYTE)(objectContent.Details.DetailsData), currPtr, tempSize);
                        } else {
                            objectContent.Details.DetailsData = NULL;
                        }
                        currPtr += tempSize;
                        // get the actual memory or file content
                        if (objectContent.ContentInFile) {
                            tempSize = *((PDWORD)currPtr);
                            currPtr += sizeof (DWORD);
                            if (tempSize) {
                                objectContent.FileContent.ContentPath = JoinPaths (g_JournalDirectory, (PCTSTR)currPtr);
                            } else {
                                objectContent.FileContent.ContentSize = 0;
                                objectContent.FileContent.ContentPath = NULL;
                            }
                            currPtr += tempSize;
                        } else {
                            tempSize = *((PDWORD)currPtr);
                            currPtr += sizeof (DWORD);
                            if (tempSize) {
                                MYASSERT (objectContent.MemoryContent.ContentSize == tempSize);
                                objectContent.MemoryContent.ContentSize = tempSize;
                                objectContent.MemoryContent.ContentBytes = IsmGetMemory (tempSize);
                                CopyMemory ((PBYTE)(objectContent.MemoryContent.ContentBytes), currPtr, tempSize);
                            } else {
                                objectContent.MemoryContent.ContentSize = 0;
                                objectContent.MemoryContent.ContentBytes = NULL;
                            }
                            currPtr += tempSize;
                        }
                        typeInfo = GetTypeInfo (*objectTypeId);
                        if (!typeInfo) {
                            DEBUGMSG ((DBG_WHOOPS, "Delayed operations: Unknown ObjectTypeId: %d", *objectTypeId));
                        } else {
                            if (*operationType == JRNOP_CREATE) {
                                if (typeInfo->CreatePhysicalObject) {
                                    typeInfo->CreatePhysicalObject (objectName, &objectContent);
                                }
                                ELSE_DEBUGMSG ((
                                        DBG_WHOOPS,
                                        "Delayed operations: ObjectTypeId %d does not implement CreatePhysicalObject",
                                        *objectTypeId
                                        ));
                            } else {
                                if (typeInfo->ReplacePhysicalObject) {
                                    typeInfo->ReplacePhysicalObject (objectName, &objectContent);
                                }
                                ELSE_DEBUGMSG ((
                                        DBG_WHOOPS,
                                        "Delayed operations: ObjectTypeId %d does not implement ReplacePhysicalObject",
                                        *objectTypeId
                                        ));
                            }
                        }
                        break;
                    default:
                        DEBUGMSG ((
                            DBG_WHOOPS,
                            "Delayed operations: Wrong operation type in ExecuteDelayedOperations: %d",
                            operationType
                            ));
                    }
                    fileMaxPos -= sizeof (DWORD);
                }
            }
        }
        result = TRUE;
    }
    __finally {
        GbFree (&buffer);
        if (result) {
            FiRemoveAllFilesInTree (journalDir);
        }
        if (currentUserData) {
            FreeCurrentUserData (currentUserData);
            currentUserData = NULL;
        }
        if (journalDir) {
            FreePathString (journalDir);
            journalDir = NULL;
        }
        if (journalFile) {
            FreePathString (journalFile);
            journalFile = NULL;
        }
        if (journalFileHandle && (journalFileHandle != INVALID_HANDLE_VALUE)) {
            CloseHandle (journalFileHandle);
            journalFileHandle = NULL;
        }
    }
    return result;
}

BOOL
IsmReplacePhysicalObject (
    IN    MIG_OBJECTTYPEID ObjectTypeId,
    IN    MIG_OBJECTSTRINGHANDLE ObjectName,
    IN    PMIG_CONTENT ObjectContent
    )
{
    PTYPEINFO typeInfo;
    BOOL result = FALSE;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        if (typeInfo->ReplacePhysicalObject) {
            // Type supports Replace
            result = typeInfo->ReplacePhysicalObject (ObjectName, ObjectContent);
        } else {
            // Type does not support Replace, so we need to emulate it
            if (typeInfo->DoesPhysicalObjectExist (ObjectName)) {
                result = typeInfo->RemovePhysicalObject (ObjectName);
            } else {
                result = TRUE;
            }
            if (result) {
                result = typeInfo->CreatePhysicalObject (ObjectName, ObjectContent);
            }
        }
    }
    return result;
}

BOOL
IsmRemovePhysicalObject (
    IN    MIG_OBJECTTYPEID ObjectTypeId,
    IN    MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PTYPEINFO typeInfo;
    BOOL result = FALSE;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo && typeInfo->RemovePhysicalObject) {
        if (typeInfo->DoesPhysicalObjectExist (ObjectName)) {
            result = typeInfo->RemovePhysicalObject (ObjectName);
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ism.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\users.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    users.c

Abstract:

    Creates user profiles and enumerates users

Author:

    Jim Schmidt (jimschm) 15-May-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_ISMUSERS            "IsmUsers"

//
// Strings
//

#define S_TEMP_HKCU             TEXT("$HKCU$")

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef BOOL (WINAPI GETDEFAULTUSERPROFILEDIRECTORY)(PTSTR ProfileDir, PDWORD Size);
typedef GETDEFAULTUSERPROFILEDIRECTORY * PGETDEFAULTUSERPROFILEDIRECTORY;

typedef BOOL (WINAPI GETPROFILESDIRECTORY)(PTSTR ProfileDir, PDWORD Size);
typedef GETPROFILESDIRECTORY * PGETPROFILESDIRECTORY;

typedef LONG (WINAPI REGOVERRIDEPREDEFKEY)(HKEY hKey, HKEY hNewHKey);
typedef REGOVERRIDEPREDEFKEY * PREGOVERRIDEPREDEFKEY;

typedef BOOL (WINAPI CONVERTSIDTOSTRINGSID)(PSID Sid, PTSTR *SidString);
typedef CONVERTSIDTOSTRINGSID * PCONVERTSIDTOSTRINGSID;

typedef BOOL (WINAPI CREATEUSERPROFILE)(
                        PSID Sid,
                        PCTSTR UserName,
                        PCTSTR UserHive,
                        PTSTR ProfileDir,
                        DWORD DirSize,
                        BOOL IsWin9xUpgrade
                        );
typedef CREATEUSERPROFILE * PCREATEUSERPROFILE;

typedef BOOL (WINAPI OLDCREATEUSERPROFILE)(
                        PSID Sid,
                        PCTSTR UserName,
                        PCTSTR UserHive,
                        PTSTR ProfileDir,
                        DWORD DirSize
                        );
typedef OLDCREATEUSERPROFILE * POLDCREATEUSERPROFILE;

typedef BOOL (WINAPI GETUSERPROFILEDIRECTORY)(HANDLE hToken, PTSTR lpProfileDir, PDWORD lpcchSize);
typedef GETUSERPROFILEDIRECTORY * PGETUSERPROFILEDIRECTORY;

typedef BOOL (WINAPI DELETEPROFILE)(PCTSTR lpSidString, PCTSTR lpProfilePath, PCTSTR lpComputerName);
typedef DELETEPROFILE * PDELETEPROFILE;

//
// Globals
//

PTEMPORARYPROFILE g_CurrentOverrideUser;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


HANDLE
pGetUserEnvLib (
    VOID
    )
{
    static HANDLE lib;

    if (lib) {
        return lib;
    }

    lib = LoadLibrary (TEXT("userenv.dll"));
    if (!lib) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_LOAD_USERENV));
    }

    return lib;
}


HANDLE
pGetAdvApi32Lib (
    VOID
    )
{
    static HANDLE lib;

    if (lib) {
        return lib;
    }

    lib = LoadLibrary (TEXT("advapi32.dll"));
    if (!lib) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_LOAD_ADVAPI32));
    }

    return lib;
}


BOOL
pOurGetDefaultUserProfileDirectory (
    OUT     PTSTR ProfileDir,
    IN OUT  PDWORD Size
    )
{
    HANDLE lib;
    PGETDEFAULTUSERPROFILEDIRECTORY getDefaultUserProfileDirectory;

    lib = pGetUserEnvLib();
    if (!lib) {
        return FALSE;
    }

#ifdef UNICODE
    getDefaultUserProfileDirectory = (PGETDEFAULTUSERPROFILEDIRECTORY) GetProcAddress (lib, "GetDefaultUserProfileDirectoryW");
#else
    getDefaultUserProfileDirectory = (PGETDEFAULTUSERPROFILEDIRECTORY) GetProcAddress (lib, "GetDefaultUserProfileDirectoryA");
#endif

    if (!getDefaultUserProfileDirectory) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_FIND_GETDEFAULTUSERPROFILEDIRECTORY));
        return FALSE;
    }

    return getDefaultUserProfileDirectory (ProfileDir, Size);
}


BOOL
pOurGetProfilesDirectory (
    OUT     PTSTR ProfileDir,
    IN OUT  PDWORD Size
    )
{
    HANDLE lib;
    PGETPROFILESDIRECTORY getProfilesDirectory;

    lib = pGetUserEnvLib();
    if (!lib) {
        return FALSE;
    }

#ifdef UNICODE
    getProfilesDirectory = (PGETPROFILESDIRECTORY) GetProcAddress (lib, "GetProfilesDirectoryW");
#else
    getProfilesDirectory = (PGETPROFILESDIRECTORY) GetProcAddress (lib, "GetProfilesDirectoryA");
#endif

    if (!getProfilesDirectory) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_FIND_GETPROFILESDIRECTORY));
        return FALSE;
    }

    return getProfilesDirectory (ProfileDir, Size);
}


LONG
pOurConvertSidToStringSid (
    IN      PSID Sid,
    IN      PTSTR *SidString
    )
{
    HANDLE lib;
    PCONVERTSIDTOSTRINGSID convertSidToStringSid;
    BOOL result = FALSE;
    DWORD error;

    lib = pGetAdvApi32Lib();
    if (!lib) {
        error = GetLastError();
        if (error == ERROR_SUCCESS) {
            SetLastError (ERROR_PROC_NOT_FOUND);
        }
    } else {
#ifdef UNICODE
        convertSidToStringSid = (PCONVERTSIDTOSTRINGSID) GetProcAddress(lib, "ConvertSidToStringSidW");
#else
        convertSidToStringSid = (PCONVERTSIDTOSTRINGSID) GetProcAddress(lib, "ConvertSidToStringSidA");
#endif
        if (convertSidToStringSid) {
            result = convertSidToStringSid (Sid, SidString);
        }
    }

    return result;
}


BOOL
pOurGetUserProfileDirectory (
    IN      HANDLE Token,
    IN      PTSTR ProfileDir,
    IN      PDWORD ProfileDirSize
    )
{
    HANDLE lib;
    PGETUSERPROFILEDIRECTORY getUserProfileDirectory;
    BOOL result = FALSE;
    DWORD error;

    lib = pGetUserEnvLib();
    if (!lib) {
        error = GetLastError();
        if (error == ERROR_SUCCESS) {
            SetLastError (ERROR_PROC_NOT_FOUND);
        }
    } else {
#ifdef UNICODE
        getUserProfileDirectory = (PGETUSERPROFILEDIRECTORY) GetProcAddress (lib, "GetUserProfileDirectoryW");
#else
        getUserProfileDirectory = (PGETUSERPROFILEDIRECTORY) GetProcAddress (lib, "GetUserProfileDirectoryA");
#endif
        if (getUserProfileDirectory) {
            result = getUserProfileDirectory (Token, ProfileDir, ProfileDirSize);
        }
    }

    return result;
}


BOOL
pOurDeleteProfile (
    IN      PCTSTR UserStringSid,
    IN      PCTSTR UserProfilePath,
    IN      PCTSTR ComputerName
    )
{
    HANDLE lib;
    PDELETEPROFILE deleteProfile;
    BOOL result = FALSE;
    DWORD error;

    lib = pGetUserEnvLib();
    if (!lib) {
        error = GetLastError();
        if (error == ERROR_SUCCESS) {
            SetLastError (ERROR_PROC_NOT_FOUND);
        }
    } else {
#ifdef UNICODE
        deleteProfile = (PDELETEPROFILE) GetProcAddress (lib, "DeleteProfileW");
#else
        deleteProfile = (PDELETEPROFILE) GetProcAddress (lib, "DeleteProfileA");
#endif
        if (deleteProfile) {
            result = deleteProfile (UserStringSid, UserProfilePath, ComputerName);
        }
    }

    return result;
}


LONG
pOurRegOverridePredefKey (
    IN      HKEY hKey,
    IN      HKEY hNewHKey
    )
{
    HANDLE lib;
    PREGOVERRIDEPREDEFKEY regOverridePredefKey;
    LONG result;

    lib = pGetAdvApi32Lib();
    if (!lib) {
        result = GetLastError();
        if (result == ERROR_SUCCESS) {
            result = ERROR_PROC_NOT_FOUND;
        }
    } else {
        regOverridePredefKey = (PREGOVERRIDEPREDEFKEY) GetProcAddress (lib, "RegOverridePredefKey");
        if (!regOverridePredefKey) {
            result = GetLastError();
        } else {
            result = regOverridePredefKey (hKey, hNewHKey);
        }
    }

    return result;
}


BOOL
pOurCreateUserProfile (
    IN      PSID Sid,
    IN      PCTSTR UserName,
    IN      PCTSTR UserHive,
    OUT     PTSTR ProfileDir,
    IN      DWORD DirSize
    )
{
    HANDLE lib;
    PCREATEUSERPROFILE createUserProfile;
    POLDCREATEUSERPROFILE oldCreateUserProfile;
    MIG_OSVERSIONINFO versionInfo;
    BOOL useNew = FALSE;

    lib = pGetUserEnvLib();
    if (!lib) {
        return FALSE;
    }

    if (IsmGetOsVersionInfo (g_IsmCurrentPlatform, &versionInfo)) {
        if ((versionInfo.OsMajorVersion > OSMAJOR_WINNT5) ||
            (versionInfo.OsMajorVersion == OSMAJOR_WINNT5 &&
             ((versionInfo.OsMinorVersion > OSMINOR_WINNT51) ||
              ((versionInfo.OsMinorVersion == OSMINOR_WINNT51) &&
               (versionInfo.OsBuildNumber >= 2464))))) {
            useNew = TRUE;
        }
    }

    if (useNew) {
#ifdef UNICODE
        createUserProfile = (PCREATEUSERPROFILE) GetProcAddress (lib, (PCSTR) 154);
#else
        createUserProfile = (PCREATEUSERPROFILE) GetProcAddress (lib, (PCSTR) 153);
#endif

        if (!createUserProfile) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_FIND_CREATEUSERPROFILE));
            return FALSE;
        }

        return createUserProfile (
                    Sid,
                    UserName,
                    UserHive,
                    ProfileDir,
                    DirSize,
                    FALSE
                    );
    } else {
#ifdef UNICODE
        oldCreateUserProfile = (POLDCREATEUSERPROFILE) GetProcAddress (lib, (PCSTR) 110);
#else
        oldCreateUserProfile = (POLDCREATEUSERPROFILE) GetProcAddress (lib, (PCSTR) 109);
#endif

        if (!oldCreateUserProfile) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_FIND_CREATEUSERPROFILE));
            return FALSE;
        }

        return oldCreateUserProfile (
                    Sid,
                    UserName,
                    UserHive,
                    ProfileDir,
                    DirSize
                    );
    }
}


BOOL
pCloneDefaultUserProfile (
    IN      PSID Sid,
    IN      PCTSTR UserName,
    OUT     PTSTR OutUserProfileRoot
    )
{
    TCHAR userProfile[MAX_TCHAR_PATH];
    BOOL result = FALSE;

    __try {

        if (!pOurCreateUserProfile (
                Sid,
                UserName,
                NULL,
                userProfile,
                ARRAYSIZE(userProfile)
                )) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_CREATE_PROFILE, UserName));
            __leave;
        }

        MYASSERT (OutUserProfileRoot);
        StringCopy (OutUserProfileRoot, userProfile);

        result = TRUE;
    }
    __finally {
        if (result) {
            LOG ((LOG_INFORMATION, (PCSTR) MSG_PROFILE_INFO, UserName, OutUserProfileRoot));
        }
    }

    return result;
}


PTEMPORARYPROFILE
OpenTemporaryProfile (
    IN      PCTSTR UserName,
    IN      PCTSTR Domain
    )
{
    DWORD sidSize;
    DWORD domainSize;
    SID_NAME_USE use;
    PTSTR domainBuffer = NULL;
    PSID sidBuffer = NULL;
    PTSTR sidString = NULL;
    PTEMPORARYPROFILE result = NULL;
    PCTSTR accountName = NULL;
    TCHAR userProfileRoot[MAX_TCHAR_PATH];
    PCTSTR hiveFile = NULL;
    LONG rc;
    HKEY key = NULL;
    PMHANDLE allocPool;
    BOOL b;

    __try {
        //
        // Generate the account name
        //

        if (!UserName || !Domain) {
            DEBUGMSG ((DBG_WHOOPS, "EstablishTemporaryProfile requires user and domain"));
            __leave;
        }

        accountName = JoinPaths (Domain, UserName);

        //
        // Obtain the buffer sizes needed to obtain the user's SID
        //

        sidSize = 0;
        domainSize = 0;

        b = LookupAccountName (
                NULL,
                accountName,
                NULL,
                &sidSize,
                NULL,
                &domainSize,
                &use
                );

        if (!b && GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_FIND_ACCOUNT, accountName));
            __leave;
        }

        //
        // Allocate the buffers
        //

        domainBuffer = AllocText (domainSize);
        sidBuffer = MemAllocUninit (sidSize);

        if (!domainBuffer || !sidBuffer) {
            __leave;
        }

        //
        // Get the SID
        //

        b = LookupAccountName (
                NULL,
                accountName,
                sidBuffer,
                &sidSize,
                domainBuffer,
                &domainSize,
                &use
                );

        if (!b) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_FIND_ACCOUNT_SID, accountName));
            __leave;
        }

        if (use != SidTypeUser) {
            SetLastError (ERROR_INVALID_ACCOUNT_NAME);
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NOT_USER_ACCOUNT, accountName));
            __leave;
        }

        //
        // Copy the default profile
        //

        b = pCloneDefaultUserProfile (sidBuffer, UserName, userProfileRoot);

        if (!b) {
            __leave;
        }

        //
        // convert SID into a string SID
        //
        if (!pOurConvertSidToStringSid (sidBuffer, &sidString) || !sidString) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CONVERT_SID_FAILURE));
            __leave;
        }

        //
        // Load the user's hive
        //

        RegUnLoadKey (HKEY_USERS, sidString);

        hiveFile = JoinPaths (userProfileRoot, TEXT("ntuser.dat"));
        rc = RegLoadKey (HKEY_USERS, sidString, hiveFile);

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_LOAD_HIVE, hiveFile));
            __leave;
        }

        //
        // Make the hive the new HKCU
        //

        key = OpenRegKey (HKEY_USERS, sidString);
        if (!key) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_MAP_HIVE, hiveFile));
            __leave;
        }

        if (g_CurrentOverrideUser) {
            pOurRegOverridePredefKey (HKEY_CURRENT_USER, NULL);
            g_CurrentOverrideUser = NULL;
        }

        rc = pOurRegOverridePredefKey (HKEY_CURRENT_USER, key);

        if (rc != ERROR_SUCCESS) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_REDIRECT_HIVE, hiveFile));
            __leave;
        }

        //
        // Prepare outbound handle
        //

        allocPool = PmCreateNamedPool ("TempProfile");
        if (!allocPool) {
            __leave;
        }

        result = (PTEMPORARYPROFILE) PmGetMemory (allocPool, sizeof (TEMPORARYPROFILE));
        if (!result) {
            __leave;
        }

        g_CurrentOverrideUser = result;

        result->AllocPool = allocPool;
        result->UserName = PmDuplicateString (allocPool, UserName);
        result->DomainName = PmDuplicateString (allocPool, Domain);
        result->AccountName = PmDuplicateString (allocPool, accountName);
        result->UserProfileRoot = PmDuplicateString (allocPool, userProfileRoot);
        result->MapKey = PmDuplicateString (allocPool, sidString);
        result->UserStringSid = PmDuplicateString (allocPool, sidString);
        result->UserHive = PmDuplicateString (allocPool, hiveFile);
        result->UserSid = (PSID) PmDuplicateMemory (
                                        allocPool,
                                        sidBuffer,
                                        GetLengthSid (sidBuffer)
                                        );

    }
    __finally {

        FreePathString (hiveFile);
        FreePathString (accountName);
        FreeText (domainBuffer);

        if (sidBuffer) {
            FreeAlloc (sidBuffer);
            INVALID_POINTER (sidBuffer);
        }

        if (key) {
            CloseRegKey (key);
        }

        if (!result) {
            if (sidString) {
                RegTerminateCache ();
                RegUnLoadKey (HKEY_USERS, sidString);
            }

            pOurRegOverridePredefKey (HKEY_CURRENT_USER, NULL);
        }

        if (sidString) {
            LocalFree (sidString);
        }
    }

    return result;
}


BOOL
SelectTemporaryProfile (
    IN      PTEMPORARYPROFILE Profile
    )
{
    LONG rc;
    HKEY key;

    if (g_CurrentOverrideUser == Profile) {
        return TRUE;
    }

    key = OpenRegKey (HKEY_LOCAL_MACHINE, Profile->MapKey);
    if (!key) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_OPEN_USER_REGISTRY, Profile->UserName));
        return FALSE;
    }

    if (g_CurrentOverrideUser) {
        pOurRegOverridePredefKey (HKEY_CURRENT_USER, NULL);
        g_CurrentOverrideUser = NULL;
    }

    rc = pOurRegOverridePredefKey (HKEY_CURRENT_USER, key);

    CloseRegKey (key);

    if (rc == ERROR_SUCCESS) {
        g_CurrentOverrideUser = Profile;
        return TRUE;
    }

    return FALSE;
}


BOOL
CloseTemporaryProfile (
    IN      PTEMPORARYPROFILE Profile,
    IN      BOOL MakeProfilePermanent
    )
{
    BOOL result = TRUE;
    LONG rc;
    DWORD error;
    MIG_OSVERSIONINFO osVersionInfo;

    if (g_CurrentOverrideUser == Profile) {
        pOurRegOverridePredefKey (HKEY_CURRENT_USER, NULL);
        g_CurrentOverrideUser = NULL;
    }

    RegTerminateCache ();
    rc = RegUnLoadKey (HKEY_USERS, Profile->MapKey);

    DEBUGMSG_IF ((
        rc != ERROR_SUCCESS,
        DBG_WHOOPS,
        "Can't unload mapped hive: rc=%u; check for registry handle leaks",
        rc
        ));

    if (MakeProfilePermanent) {

        if (!pOurCreateUserProfile (
                Profile->UserSid,
                Profile->UserName,
                Profile->UserHive,
                NULL,
                0
                )) {
            // on Win2k it is known that this will fail with error ERROR_SHARING_VIOLATION
            // but the hive will actually be OK. So, if this is Win2k
            // and the error is ERROR_SHARING_VIOLATION we'll just consider a success.
            result = FALSE;
            error = GetLastError ();
            if (IsmGetOsVersionInfo (PLATFORM_DESTINATION, &osVersionInfo)) {
                if ((osVersionInfo.OsType == OSTYPE_WINDOWSNT) &&
                    (osVersionInfo.OsMajorVersion == OSMAJOR_WINNT5) &&
                    (osVersionInfo.OsMinorVersion == OSMINOR_GOLD) &&
                    (error == ERROR_SHARING_VIOLATION)
                    ) {
                    result = TRUE;
                }
            }
            if (!result) {
                SetLastError (error);
            }
        }
    }

    if (result) {
        PmDestroyPool (Profile->AllocPool);
        INVALID_POINTER (Profile);
    }

    return result;
}

BOOL
MapUserProfile (
    IN      PCTSTR UserStringSid,
    IN      PCTSTR UserProfilePath
    )
{
    PCTSTR hiveFile = NULL;
    LONG rc;
    HKEY key;

    //
    // Unload UserStringSid if loaded
    //
    RegUnLoadKey (HKEY_USERS, UserStringSid);

    hiveFile = JoinPaths (UserProfilePath, TEXT("ntuser.dat"));
    rc = RegLoadKey (HKEY_USERS, UserStringSid, hiveFile);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_LOAD_HIVE, hiveFile));
        FreePathString (hiveFile);
        return FALSE;
    }

    //
    // Make the hive the new HKCU
    //

    key = OpenRegKey (HKEY_USERS, UserStringSid);
    if (!key) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_MAP_HIVE, hiveFile));
        RegUnLoadKey (HKEY_USERS, UserStringSid);
        FreePathString (hiveFile);
        return FALSE;
    }

    rc = pOurRegOverridePredefKey (HKEY_CURRENT_USER, key);

    if (rc != ERROR_SUCCESS) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_REDIRECT_HIVE, hiveFile));
        CloseRegKey (key);
        RegTerminateCache ();
        RegUnLoadKey (HKEY_USERS, UserStringSid);
        FreePathString (hiveFile);
        return FALSE;
    }

    CloseRegKey (key);
    FreePathString (hiveFile);

    return TRUE;
}

BOOL
UnmapUserProfile (
    IN      PCTSTR UserStringSid
    )
{
    LONG rc;

    pOurRegOverridePredefKey (HKEY_CURRENT_USER, NULL);
    RegTerminateCache ();

    rc = RegUnLoadKey (HKEY_USERS, UserStringSid);
    DEBUGMSG_IF ((
        rc != ERROR_SUCCESS,
        DBG_WHOOPS,
        "Can't unmap user profile: rc=%u; check for registry handle leaks",
        rc
        ));

    return TRUE;
}

BOOL
DeleteUserProfile (
    IN      PCTSTR UserStringSid,
    IN      PCTSTR UserProfilePath
    )
{
    RegTerminateCache ();
    RegUnLoadKey (HKEY_USERS, UserStringSid);
    return pOurDeleteProfile (UserStringSid, UserProfilePath, NULL);
}

PCURRENT_USER_DATA
GetCurrentUserData (
    VOID
    )
{
    PCURRENT_USER_DATA result = NULL;
    HANDLE token;
    DWORD bytesRequired;
    PTOKEN_USER tokenUser;
    PMHANDLE allocPool;
    PTSTR sidString = NULL;
    TCHAR userName[256];
    DWORD nameSize;
    TCHAR userDomain[256];
    DWORD domainSize;
    SID_NAME_USE dontCare;

    //
    // Open the process token.
    //
    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &token)) {
        return FALSE;
    }

    bytesRequired = 0;
    if (GetTokenInformation (token, TokenUser, NULL, 0, &bytesRequired)) {
        return FALSE;
    }

    if (GetLastError () != ERROR_INSUFFICIENT_BUFFER) {
        return FALSE;
    }

    tokenUser = (PTOKEN_USER) MemAllocUninit (bytesRequired);

    if (!GetTokenInformation (token, TokenUser, tokenUser, bytesRequired, &bytesRequired)) {
        FreeAlloc (tokenUser);
        return FALSE;
    }

    nameSize = ARRAYSIZE (userName);
    domainSize = ARRAYSIZE (userDomain);

    ZeroMemory (userName, nameSize);
    ZeroMemory (userDomain, domainSize);

    LookupAccountSid (
        NULL,
        tokenUser->User.Sid,
        userName,
        &nameSize,
        userDomain,
        &domainSize,
        &dontCare
        );

    allocPool = PmCreateNamedPool ("CurrentUser");
    if (!allocPool) {
        FreeAlloc (tokenUser);
        return FALSE;
    }

    PmDisableTracking (allocPool);

    result = (PCURRENT_USER_DATA) PmGetMemory (allocPool, sizeof (CURRENT_USER_DATA));
    if (!result) {
        FreeAlloc (tokenUser);
        return FALSE;
    }

    result->AllocPool = allocPool;

    result->UserName = PmDuplicateString (result->AllocPool, userName);

    result->UserDomain = PmDuplicateString (result->AllocPool, userDomain);

    if (!pOurConvertSidToStringSid (tokenUser->User.Sid, &sidString) || !sidString) {
        PmDestroyPool (allocPool);
        FreeAlloc (tokenUser);
        return FALSE;
    }

    result->UserStringSid = PmDuplicateString (allocPool, sidString);

    LocalFree (sidString);

    FreeAlloc (tokenUser);

    // now just get the current user profile path

    bytesRequired = MAX_TCHAR_PATH;
    result->UserProfilePath = PmGetMemory (allocPool, bytesRequired);

    if (!pOurGetUserProfileDirectory (token, (PTSTR)result->UserProfilePath, &bytesRequired)) {
        result->UserProfilePath = PmGetMemory (allocPool, bytesRequired);
        if (!pOurGetUserProfileDirectory (token, (PTSTR)result->UserProfilePath, &bytesRequired)) {
            PmDestroyPool (allocPool);
            return FALSE;
        }
    }

    return result;
}

VOID
FreeCurrentUserData (
    IN      PCURRENT_USER_DATA CurrentUserData
    )
{
    PmDestroyPool (CurrentUserData->AllocPool);
}

PCTSTR
IsmGetCurrentSidString (
    VOID
    )
{
    if (!g_CurrentOverrideUser) {
        return NULL;
    } else {
        return PmDuplicateString (g_IsmPool, g_CurrentOverrideUser->UserStringSid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\engine\ism\sources.inc ===
!include ..\..\engine.mk

MINORCOMP=ism
SYNCHRONIZE_BLOCK=1

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\ism.c            \
    ..\typemgr.c        \
    ..\filetype.c       \
    ..\regtype.c        \
    ..\datatype.c       \
    ..\flowctrl.c       \
    ..\attrib.c         \
    ..\property.c       \
    ..\ism.rc           \
    ..\env.c            \
    ..\ops.c            \
    ..\users.c          \
    ..\components.c     \
    ..\modules.c        \
    ..\logmsg.mc        \


DLLENTRY=_DllMainCRTStartup
DLLBASE=0x01E000000
LINKER_FLAGS=$(LINKER_FLAGS) -SWAPRUN:CD -SWAPRUN:NET
SUBSYSTEM_VERSION=4.00

# extra libs
TARGETLIBS= $(TARGETLIBS)                           \
            $(COBRA_ROOT)\lib\$(O)\memdb.lib        \
            $(COBRA_ROOT)\lib\$(O)\inf.lib          \
            $(COBRA_ROOT)\lib\$(O)\utils.lib        \
            $(COBRA_ROOT)\lib\$(O)\file.lib         \
            $(COBRA_ROOT)\lib\$(O)\reg.lib          \

PRECOMPILED_INCLUDE=..\pch.h

DLLDEF=..\ism.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\inc\baseinc.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    baseinc.h

Abstract:

    Includes SDK headers needed for the project, and allutils.h.

Author:

    Marc R. Whitten (marcw) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// basetypes.h creates better types for managing DBCS and UNICODE
// with the C runtime, and defines other types that should be defined
// by the Win32 headers but aren't.
//

#include "basetypes.h"

//
// COBJMACROS turns on the C-style macros for COM.  We don't use C++!
//

#define COBJMACROS

//
// Windows
//

#pragma warning(push)

#include <windows.h>
#include <winnt.h>
#include <stdlib.h>
#include <imagehlp.h>
#include <stdio.h>
#include <time.h>
#include <setupapi.h>
#include <spapip.h>

//
// PORTBUG -- I had to uncomment shlobj.h just to get the #define DOUBLE working...
//
#include <shlobj.h>
//#include <objidl.h>
//#include <mmsystem.h>
//

#pragma warning(pop)

//
// Private utilities
//

#include "allutils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\inc\allutils.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    allutils.h

Abstract:

    Includes all header files necessary to use the libraries generated under the
    utils directory. Declares many macros and MAX constants.

Author:

    Jim Schmidt (jimschm) 23-Aug-1996

Revision History:

    marcw 2-Sep-1999 Ported over from win95upg project (migutil.h) Needs lots of cleanup.

--*/

#pragma once

//
// Includes
//

#include "utiltypes.h"
#include "main.h"
#include "dbgtrack.h"
#include "basemem.h"
#include "log.h"
#include "growbuf.h"
#include "strings.h"
#include "poolmem.h"
#include "growlist.h"
#include "version.h"
#include "modimage.h"
#include "icons.h"
#include "unicode.h"
#include "hash.h"
#include "basefile.h"
#include "memdb.h"
#include "inf.h"
#include "ini.h"
#include "blobs.h"
#include "objstr.h"
#include "exclist.h"
#include "reg.h"
#include "regenum.h"
#include "fileenum.h"
#include "cablib.h"
#include "wnd.h"
#include "strmap.h"
#include "linkpif.h"
#include "progbar.h"

//
// Strings
//

// None

//
// Constants
//

#define MAX_PATH_PLUS_NUL           (MAX_PATH+1)
#define MAX_MBCHAR_PATH             (MAX_PATH_PLUS_NUL*2)
#define MAX_WCHAR_PATH              MAX_PATH_PLUS_NUL
#define MAX_MBCHAR_PRINTABLE_PATH   (MAX_PATH*2)
#define MAX_WCHAR_PRINTABLE_PATH    MAX_PATH

#define MAX_SERVER_NAMEA            (64*2)
#define MAX_USER_NAMEA              (MAX_SERVER_NAMEA + (20 * 2))
#define MAX_REGISTRY_KEYA           (1024 * 2)
#define MAX_REGISTRY_VALUE_NAMEA    (260 * 2)
#define MAX_COMPONENT_NAMEA         (256 * 2)
#define MAX_COMPUTER_NAMEA          (64 * 2)
#define MAX_CMDLINEA                (1024 * 2)     // maximum number of chars in a Win95 command line
#define MAX_KEYBOARDLAYOUT          64
#define MAX_INF_SECTION_NAME        128
#define MAX_INF_KEY_NAME            128

#define MAX_SERVER_NAMEW            64
#define MAX_USER_NAMEW              (MAX_SERVER_NAMEW + 20)
#define MAX_REGISTRY_KEYW           1024
#define MAX_REGISTRY_VALUE_NAMEW    260
#define MAX_COMPONENT_NAMEW         256
#define MAX_COMPUTER_NAMEW          64

#define MAX_CMDLINEW                1024            // maximum number of chars in a Win95 command line

#ifdef UNICODE

#define MAX_SERVER_NAME             MAX_SERVER_NAMEW
#define MAX_USER_NAME               MAX_USER_NAMEW
#define MAX_REGISTRY_KEY            MAX_REGISTRY_KEYW
#define MAX_REGISTRY_VALUE_NAME     MAX_REGISTRY_VALUE_NAMEW
#define MAX_COMPONENT_NAME          MAX_COMPONENT_NAMEW
#define MAX_COMPUTER_NAME           MAX_COMPUTER_NAMEW
#define MAX_CMDLINE                 MAX_CMDLINEW

#define MAX_TCHAR_PATH              MAX_WCHAR_PATH
#define MAX_TCHAR_PRINTABLE_PATH    MAX_WCHAR_PRINTABLE_PATH

#else

#define MAX_SERVER_NAME             MAX_SERVER_NAMEA
#define MAX_USER_NAME               MAX_USER_NAMEA
#define MAX_REGISTRY_KEY            MAX_REGISTRY_KEYA
#define MAX_REGISTRY_VALUE_NAME     MAX_REGISTRY_VALUE_NAMEA
#define MAX_COMPONENT_NAME          MAX_COMPONENT_NAMEA
#define MAX_COMPUTER_NAME           MAX_COMPUTER_NAMEA
#define MAX_CMDLINE                 MAX_CMDLINEA

#define MAX_TCHAR_PATH              MAX_MBCHAR_PATH
#define MAX_TCHAR_PRINTABLE_PATH    MAX_MBCHAR_PRINTABLE_PATH

#endif


//
// Macros
//


//
// OSVERSION macros...
//
#define ISNT()              (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
#define ISWIN9X()           (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
#define ISWIN95_GOLDEN()    (ISWIN95() && WORD(g_OsInfo.dwBuildNumber) <= 1000)
#define ISWIN95_OSR2()      (ISWIN95() && WORD(g_OsInfo.dwBuildNumber) > 1000)
#define ISWIN95()           (ISWIN9X() && !ISMEMPHIS())
#define ISMEMPHIS()         (ISWIN9X() && g_OsInfo.dwMajorVersion==4 && g_OsInfo.dwMinorVersion==10)
#define BUILDNUMBER()       (g_OsInfo.dwBuildNumber)

//
// Error condition tags.
//
// These tags should be used for all error conditions.
//

#define ERROR_CRITICAL
#define ERROR_NONCRITICAL
#define ERROR_TRIVIAL
#define ERROR_ABNORMAL_CONDITION



//
// Types
//

typedef struct {
    HANDLE EventHandle;
} OUR_CRITICAL_SECTION, *POUR_CRITICAL_SECTION;

//
// Globals
//

extern HINSTANCE g_hInst;
extern HANDLE g_hHeap;
extern OSVERSIONINFOA g_OsInfo;


extern BOOL g_IsPc98;

//
// Boot drive letter
//

extern PCSTR g_BootDrivePathA;
extern PCWSTR g_BootDrivePathW;
extern PCSTR g_BootDriveA;
extern PCWSTR g_BootDriveW;
extern CHAR g_BootDriveLetterA;
extern WCHAR g_BootDriveLetterW;


//
// Macro expansion list
//

// None

//
// Public function prototypes
//

//
// Critical Section APIs, implemented because TryEnterCriticalSection is
// supported only on NT, and we need it on Win9x.
//


BOOL
InitializeOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

VOID
DeleteOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

BOOL
EnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

VOID
LeaveOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

BOOL
TryEnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

//
// Includes of util modules
//


VOID
CenterWindow (
    HWND Wnd,
    HWND Parent     OPTIONAL
    );

VOID
TurnOnWaitCursor (
    VOID
    );

VOID
TurnOffWaitCursor (
    VOID
    );

VOID
OutOfMemory_Terminate (
    VOID
    );


VOID
SetOutOfMemoryParent (
    HWND hwnd
    );


HANDLE
StartThread (
    IN      PTHREAD_START_ROUTINE Address,
    IN      PVOID Arg
    );

//
// Macro expansion definition
//

// None

//
// Unicode/Ansi mappings.
//
#ifdef UNICODE

#define g_BootDrivePath     g_BootDrivePathW
#define g_BootDrive         g_BootDriveW
#define g_BootDriveLetter   g_BootDriveLetterW

#else

#define g_BootDrivePath     g_BootDrivePathA
#define g_BootDrive         g_BootDriveA
#define g_BootDriveLetter   g_BootDriveLetterA

#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(n)    (sizeof(n)/sizeof(n[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\inc\basetypes.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    chartype.h

Abstract:

    Declares macros and types for the multi-byte and Unicode
    character environment that the Win9x upgrade code requires.
    The following macros are defined:

    - Make sure UNICODE is defined if _UNICODE is defined
    - Make the type MBCHAR that holds both bytes of a multi-byte char
    - Make CHARTYPE point to wint_t for UNICODE and MBCHAR for not
      UNICODE
    - Define non-standard types PCTCHAR and PTCHAR for spapip.h

Author:

    Jim Schmidt (jimschm) 10-Oct-1996

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#ifdef NEED_EXPORTS
#define EXPORT  __declspec(dllexport)
#else
#define EXPORT
#endif

#ifndef PCUINT
typedef const unsigned int  *PCUINT;
#endif

#ifndef PCUINT64
typedef const unsigned _int64  *PCUINT64;
#endif

#ifdef _WIN64

#define BINT    INT64
#define UBINT   UINT64
#define PBINT   PINT64
#define PUBINT  PUINT64
#define PCUBINT PCUINT64

#else

#define BINT    INT
#define UBINT   UINT
#define PBINT   PINT
#define PUBINT  PUINT
#define PCUBINT PCUINT

#endif

#if defined _UNICODE && !defined UNICODE
#define UNICODE
#endif

#ifdef UNICODE

//
// If UNICODE, define _UNICODE for tchar.h, and make
// a type to represent a single character.
//

#ifndef _UNICODE
#define _UNICODE
#endif

#define CHARTYPE wint_t

#pragma message ("UNICODE version being built")

#else       // ifdef UNICODE

//
// If not UNICODE, we must assume multibyte characters.
// Define _MBCS for tchar.h, and make a type that can
// hold a complete multibyte character.
//

#ifndef _MBCS
#define _MBCS
#endif
#define CHARTYPE unsigned int

#pragma message ("MBCS version being built")

#endif      // ifdef UNICODE, else

#define MBCHAR unsigned int

#include <tchar.h>

//
// Constant pointer to a void
//

#ifndef PCVOID
typedef const void * PCVOID;
#endif

//
// Pointer to a constant byte sequence
//

#ifndef PCBYTE
typedef const unsigned char * PCBYTE;
#endif

//
// use the result of sizeof operator as a DWORD
//
#define DWSIZEOF(x) ((DWORD)sizeof(x))



// PORTBUG!!  We want to eliminate setupapi.h
//
// Types for Setup API
//

#ifndef PCTCHAR
#define PCTCHAR const TCHAR *
#endif

#ifndef PTCHAR
#define PTCHAR TCHAR *
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\inc\ism.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ism.h

Abstract:

    Base definitions for the Intermediate State Manager.

Author:

    Jim Schmidt (jimschm) 15-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

//
// Strings
//

#define S_DATATYPE                      TEXT("Data")
#define S_FILETYPE                      TEXT("File")
#define S_REGISTRYTYPE                  TEXT("Registry")

//
// Constants
//

//
// If either DBG or DEBUG defined, use debug mode
//

#if defined(DBG) && !defined(DEBUG)
#define DEBUG
#endif

#if defined(DEBUG) && !defined(DBG)
#define DBG
#endif

#ifdef DEBUG

#define TRACKING_DEF , PCSTR File, UINT Line
#define TRACKING_CALL ,__FILE__,__LINE__
#define TRACKING_INLINE_CALL ,File,Line

#else

#define TRACKING_DEF
#define TRACKING_CALL
#define TRACKING_INLINE_CALL

#endif

//
// callback constants
//

#define CALLBACK_ENUM_CONTINUE          0x00000000

#define CALLBACK_SKIP_LEAVES            0x00000001
#define CALLBACK_SKIP_NODES             0x00000002
#define CALLBACK_SKIP_TREE              0x00000004
#define CALLBACK_SKIP_REMAINING_TREE    CALLBACK_SKIP_TREE
#define CALLBACK_THIS_TREE_ONLY         0x00000008
#define CALLBACK_DONE_ENUMERATING       0x00000010
#define CALLBACK_ERROR                  0x80000000

#define ALL_PATTERN                     ((PMIG_SEGMENTS) 1)

//
// used by rollback and delayed operations mechanism
//
#define JRNOP_CREATE                    0x00000001
#define JRNOP_DELETE                    0x00000002
#define JRNOP_REPLACE                   0x00000003

#define ZEROED
#define CALLER_INITIALIZED

//
// component constants
//

#define MASTERGROUP_NONE                0
#define MASTERGROUP_SCRIPT              1
#define MASTERGROUP_FILES_AND_FOLDERS   2
#define MASTERGROUP_USER                3
#define MASTERGROUP_APP                 4
#define MASTERGROUP_SYSTEM              5
#define MASTERGROUP_ALL                 255

//
// IsmQueueEnumeration constants
//

#define QUEUE_MAKE_APPLY                0x0001
#define QUEUE_MAKE_PERSISTENT           0x0002
#define QUEUE_OVERWRITE_DEST            0x0004
#define QUEUE_DONT_OVERWRITE_DEST       0x0008
#define QUEUE_MAKE_NONCRITICAL          0x0010

//
// execute constants
//
#define MIG_EXECUTE_PREPROCESS          0x0001
#define MIG_EXECUTE_REFRESH             0x0002
#define MIG_EXECUTE_POSTPROCESS         0x0003

#define ISMMESSAGE_EXECUTE_PREPROCESS   0x0001
#define ISMMESSAGE_EXECUTE_REFRESH      0x0002
#define ISMMESSAGE_EXECUTE_POSTPROCESS  0x0003
#define ISMMESSAGE_EXECUTE_ROLLBACK     0x0004
#define ISMMESSAGE_APP_INFO             0x0005
#define ISMMESSAGE_APP_INFO_NOW         0x0006

//
// Macros
//

// None

//
// Types
//

//
// misc types
//

typedef enum {
    CONTENTTYPE_ANY = 0,
    CONTENTTYPE_MEMORY,
    CONTENTTYPE_FILE,
    CONTENTTYPE_DETAILS_ONLY
} MIG_CONTENTTYPE;


#define PLATFORM_CURRENT        0x00000000
#define PLATFORM_SOURCE         0x10000000
#define PLATFORM_DESTINATION    0x20000000
#define PLATFORM_MASK           0xF0000000
#define TYPE_MASK               0x0FFFFFFF

#define COMPONENTENUM_ALIASES                   0x00000001
#define COMPONENTENUM_ENABLED                   0x00000002
#define COMPONENTENUM_DISABLED                  0x00000004
#define COMPONENTENUM_PREFERRED_ONLY            0x00000008
#define COMPONENTENUM_NON_PREFERRED_ONLY        0x00000010

#define COMPONENTENUM_ALL_COMPONENTS            (COMPONENTENUM_ENABLED|COMPONENTENUM_DISABLED)
#define COMPONENTENUM_ALL_ALIASES               (COMPONENTENUM_ALIASES|COMPONENTENUM_ENABLED|COMPONENTENUM_DISABLED)

#define EXECUTETYPE_VIRTUALCOMPUTER_PARSING     0x00000001
#define EXECUTETYPE_VIRTUALCOMPUTER             0x00000002
#define EXECUTETYPE_EXECUTESOURCE_PARSING       0x00000003
#define EXECUTETYPE_EXECUTESOURCE               0x00000004
#define EXECUTETYPE_EXECUTEDESTINATION          0x00000005
#define EXECUTETYPE_DELAYEDOPERATIONS           0x00000006
#define EXECUTETYPE_DELAYEDOPERATIONSCLEANUP    0x00000007

#define TRANSPORTTYPE_LIGHT             0x00000001
#define TRANSPORTTYPE_FULL              0x00000002

#define MIG_DATA_TYPE           IsmGetObjectTypeId(S_DATATYPE)
#define MIG_REGISTRY_TYPE       IsmGetObjectTypeId(S_REGISTRYTYPE)
#define MIG_FILE_TYPE           IsmGetObjectTypeId(S_FILETYPE)

typedef enum {
    MIG_TRANSPORT_PHASE = 1,
    MIG_HIGHPRIORITYQUEUE_PHASE,
    MIG_HIGHPRIORITYESTIMATE_PHASE,
    MIG_HIGHPRIORITYGATHER_PHASE,
    MIG_GATHERQUEUE_PHASE,
    MIG_GATHERESTIMATE_PHASE,
    MIG_GATHER_PHASE,
    MIG_ANALYSIS_PHASE,
    MIG_APPLY_PHASE
} MIG_PROGRESSPHASE;

typedef enum {
    MIG_BEGIN_PHASE = 1,
    MIG_IN_PHASE,
    MIG_END_PHASE
} MIG_PROGRESSSTATE;

typedef struct {
    DWORD TotalObjects;
    DWORD PersistentObjects;
    DWORD ApplyObjects;
} MIG_OBJECTCOUNT, *PMIG_OBJECTCOUNT;

#ifndef PCVOID
typedef const void * PCVOID;
#endif

#ifndef PCBYTE
typedef const unsigned char * PCBYTE;
#endif

typedef unsigned long       MIG_ATTRIBUTEID;
typedef unsigned int        MIG_PROPERTYID;
typedef unsigned long       MIG_OBJECTTYPEID;
typedef unsigned long       MIG_OPERATIONID;
typedef signed int          MIG_OBJECTID;
typedef unsigned int        MIG_PROPERTYDATAID;
typedef unsigned int        MIG_DATAHANDLE;
typedef PCTSTR              MIG_OBJECTSTRINGHANDLE;
typedef unsigned int        MIG_PLATFORMTYPEID;
typedef LONG_PTR            MIG_TRANSPORTID;
typedef signed long         MIG_TRANSPORTSTORAGEID;
typedef unsigned long       MIG_TRANSPORTTYPE;
typedef unsigned long       MIG_TRANSPORTCAPABILITIES;
typedef signed short        MIG_PROGRESSSLICEID;
typedef unsigned int        MIG_EXECUTETYPEID;
typedef PCVOID              MIG_PARSEDPATTERN;

typedef MIG_TRANSPORTTYPE *PMIG_TRANSPORTTYPE;
typedef MIG_TRANSPORTCAPABILITIES *PMIG_TRANSPORTCAPABILITIES;

typedef enum {
    PHYSICAL_OBJECT = 1,
    ISM_OBJECT
} MIG_LOCATION_TYPE;

typedef enum {
    CR_FAILED = 1,
    CR_SOURCE_DOES_NOT_EXIST,
    CR_DESTINATION_EXISTS
} MIG_COMPARERESULT;

//
// object values
//

typedef struct {
    UINT DetailsSize;
    PCVOID DetailsData;
} MIG_DETAILS, *PMIG_DETAILS;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;

    BOOL ContentInFile;

    union {

        struct _TAG_FILECONTENT {
            PCTSTR ContentPath;
            LONGLONG ContentSize;
        } FileContent;

        struct _TAG_MEMORYCONTENT {
            PCBYTE ContentBytes;
            UINT ContentSize;
        } MemoryContent;
    };

    MIG_DETAILS Details;

    // internal members
    union {
        PVOID EtmHandle;
        PVOID TransHandle;
    };

    PVOID IsmHandle;

} MIG_CONTENT, *PMIG_CONTENT;

typedef MIG_CONTENT const * PCMIG_CONTENT;

typedef struct {
    PCTSTR Segment;
    BOOL IsPattern;
} MIG_SEGMENTS, *PMIG_SEGMENTS;

//
// transport module structs and function types
//

typedef struct {
    MIG_TRANSPORTID TransportId;
    MIG_TRANSPORTSTORAGEID SupportedStorageId;
    MIG_TRANSPORTTYPE TransportType;
    MIG_TRANSPORTCAPABILITIES Capabilities;
    PCTSTR FriendlyDescription;

    PVOID Handle;
} MIG_TRANSPORTENUM, *PMIG_TRANSPORTENUM;


//
// object enum
//

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;

    PCTSTR NativeObjectName;
    PCTSTR ObjectNode;
    PCTSTR ObjectLeaf;

    UINT Level;
    UINT SubLevel;
    BOOL IsLeaf;
    BOOL IsNode;

    MIG_DETAILS Details;

    LONG_PTR EtmHandle;
    PVOID IsmHandle;
} MIG_TYPEOBJECTENUM, *PMIG_TYPEOBJECTENUM;

typedef struct {

    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;

    PCTSTR NativeObjectName;
    PCTSTR ObjectNode;
    PCTSTR ObjectLeaf;

    UINT Level;
    UINT SubLevel;
    BOOL IsLeaf;
    BOOL IsNode;

    MIG_DETAILS Details;
} MIG_OBJECTENUMDATA, *PMIG_OBJECTENUMDATA;

typedef const MIG_OBJECTENUMDATA * PCMIG_OBJECTENUMDATA;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;

    MIG_OBJECTID ObjectId;              // 0 == physical object

    PVOID Handle;       // used by enum routines
} MIG_OBJECT_ENUM, *PMIG_OBJECT_ENUM;

//
// properties
//

typedef enum {
    BLOBTYPE_STRING = 1,
    BLOBTYPE_BINARY = 2
} MIG_BLOBTYPE, *PMIG_BLOBTYPE;

typedef struct {
    MIG_BLOBTYPE Type;

    union {
        PCTSTR String;
        struct {
            PCBYTE BinaryData;
            UINT BinarySize;
        };
    };

} MIG_BLOB, *PMIG_BLOB;

typedef const MIG_BLOB * PCMIG_BLOB;

typedef struct {
    MIG_PROPERTYID PropertyId;
    MIG_PROPERTYDATAID PropertyDataId;
    BOOL Private;

    PVOID Handle;       // used by enum routines
} MIG_OBJECTPROPERTY_ENUM, *PMIG_OBJECTPROPERTY_ENUM;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;
    MIG_OBJECTID ObjectId;

    PVOID Handle;       // used by enum routines
} MIG_OBJECTWITHPROPERTY_ENUM, *PMIG_OBJECTWITHPROPERTY_ENUM;

//
// attributes
//

typedef struct {
    MIG_ATTRIBUTEID AttributeId;
    BOOL Private;

    PVOID Handle;       // used by enum routines
} MIG_OBJECTATTRIBUTE_ENUM, *PMIG_OBJECTATTRIBUTE_ENUM;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;
    MIG_OBJECTID ObjectId;

    PVOID Handle;       // used by enum routines
} MIG_OBJECTWITHATTRIBUTE_ENUM, *PMIG_OBJECTWITHATTRIBUTE_ENUM;

//
// operations
//

typedef struct {
    MIG_OPERATIONID OperationId;
    PCMIG_BLOB SourceData;              OPTIONAL
    PCMIG_BLOB DestinationData;         OPTIONAL
    BOOL Private;

    PVOID Handle;       // used by enum routines
} MIG_OBJECTOPERATION_ENUM, *PMIG_OBJECTOPERATION_ENUM;

typedef struct {
    MIG_OBJECTSTRINGHANDLE ObjectName;
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTID ObjectId;
    MIG_OPERATIONID OperationId;
    PCMIG_BLOB SourceData;              OPTIONAL
    PCMIG_BLOB DestinationData;         OPTIONAL

    PVOID Handle;       // used by enum routines
} MIG_OBJECTWITHOPERATION_ENUM, *PMIG_OBJECTWITHOPERATION_ENUM;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;
} MIG_OBJECT, *PMIG_OBJECT;

typedef const MIG_OBJECT * PCMIG_OBJECT;

typedef struct {
    MIG_OBJECT OriginalObject;
    MIG_OBJECT CurrentObject;
    BOOL FilterTreeChangesOnly;
    BOOL Deleted;
    BOOL Replaced;
} MIG_FILTERINPUT, *PMIG_FILTERINPUT;

typedef MIG_FILTERINPUT const * PCMIG_FILTERINPUT;

typedef struct {
    MIG_OBJECT NewObject;
    BOOL Deleted;
    BOOL Replaced;
} MIG_FILTEROUTPUT, *PMIG_FILTEROUTPUT;

//
// environment & message passing types
//

typedef enum {
    ENVENTRY_NONE = 0,
    ENVENTRY_STRING,
    ENVENTRY_MULTISZ,
    ENVENTRY_CALLBACK,
    ENVENTRY_BINARY
} ENVENTRY_TYPE, *PENVENTRY_TYPE;

typedef BOOL (WINAPI ENVENTRYCALLBACK)(PCTSTR,PTSTR,UINT,PUINT,PCTSTR);
typedef ENVENTRYCALLBACK *PENVENTRYCALLBACK;

typedef struct {
    ENVENTRY_TYPE Type;
    union {
        PCTSTR EnvString;
        PCTSTR MultiSz;
        struct {
            PCBYTE EnvBinaryData;
            UINT EnvBinaryDataSize;
        };
        PENVENTRYCALLBACK EnvCallback;
    };
} ENVENTRY_STRUCT, *PENVENTRY_STRUCT;

typedef struct {
    PCTSTR UserName;
    PCTSTR DomainName;
    PCTSTR AccountName;
    PCTSTR UserProfileRoot;
    PSID UserSid;
} MIG_USERDATA, *PMIG_USERDATA;

typedef struct {
    MIG_PROGRESSPHASE Phase;
    UINT SubPhase;
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;
    PCTSTR Text;
} MIG_APPINFO, *PMIG_APPINFO;

//
// components
//

typedef struct {
    PCTSTR ComponentString;
    PCTSTR LocalizedAlias;
    UINT Instance;
    UINT GroupId;
    BOOL Preferred;
    BOOL UserSupplied;
    BOOL Enabled;
    UINT MasterGroup;

    BOOL SkipToNextComponent;       // set this to TRUE to cause enumeration to continue to next component
                                    // (instead of next alias of same component)

    PVOID Handle;
} MIG_COMPONENT_ENUM, *PMIG_COMPONENT_ENUM;

//
// Version
//

#define OSTYPE_WINDOWS9X        1
#define OSTYPE_WINDOWS9X_STR    TEXT("9X")
#define OSTYPE_WINDOWSNT        2
#define OSTYPE_WINDOWSNT_STR    TEXT("NT")

#define OSMAJOR_WIN95           1
#define OSMAJOR_WIN95_STR       TEXT("Windows 95")
#define OSMAJOR_WIN95OSR2       2
#define OSMAJOR_WIN95OSR2_STR   TEXT("Windows 95 - OSR2")
#define OSMAJOR_WIN98           3
#define OSMAJOR_WIN98_STR       TEXT("Windows 98")
#define OSMAJOR_WINME           4
#define OSMAJOR_WINME_STR       TEXT("Windows Millennium")
#define OSMAJOR_WINNT4          1
#define OSMAJOR_WINNT4_STR      TEXT("Windows NT4")
#define OSMAJOR_WINNT5          2
#define OSMAJOR_WINNT5_STR      TEXT("Windows 2000")

#define OSMINOR_GOLD            0
#define OSMINOR_GOLD_STR        TEXT("Gold")
#define OSMINOR_WIN95OSR21      1
#define OSMINOR_WIN95OSR21_STR  TEXT("1")
#define OSMINOR_WIN95OSR25      2
#define OSMINOR_WIN95OSR25_STR  TEXT("5")
#define OSMINOR_WIN98SE         1
#define OSMINOR_WIN98SE_STR     TEXT("Second Edition")
#define OSMINOR_WINNT51         1
#define OSMINOR_WINNT51_STR     TEXT("XP")

typedef struct {
    UINT OsType;
    PCTSTR OsTypeName;
    UINT OsMajorVersion;
    PCTSTR OsMajorVersionName;
    UINT OsMinorVersion;
    PCTSTR OsMinorVersionName;
    UINT OsBuildNumber;
} MIG_OSVERSIONINFO, *PMIG_OSVERSIONINFO;

#include "ismproc.h"

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Macro expansion definition
//

// None

//
// Public function declarations
//

//
// app layer
//

BOOL
WINAPI
IsmInitialize (
    IN      PCTSTR InfPath,
    IN      PMESSAGECALLBACK MessageCallback,   OPTIONAL
    IN      PMIG_LOGCALLBACK LogCallback
    );

BOOL
WINAPI
IsmSetPlatform (
    IN      MIG_PLATFORMTYPEID Platform
    );

BOOL
WINAPI
IsmRegisterProgressBarCallback (
    IN      PPROGRESSBARFN ProgressBarFn,
    IN      ULONG_PTR Arg
    );

BOOL
WINAPI
IsmStartEtmModules (
    VOID
    );

BOOL
WINAPI
IsmStartTransport (
    VOID
    );

BOOL
WINAPI
IsmEnumFirstTransport (
    OUT     PMIG_TRANSPORTENUM Enum,
    IN      MIG_TRANSPORTSTORAGEID DesiredType  OPTIONAL
    );

BOOL
WINAPI
IsmEnumNextTransport (
    IN OUT  PMIG_TRANSPORTENUM Enum
    );

VOID
WINAPI
IsmAbortTransportEnum (
    IN      PMIG_TRANSPORTENUM Enum
    );

MIG_TRANSPORTID
WINAPI
IsmSelectTransport (
    IN      MIG_TRANSPORTSTORAGEID DesiredStorageId,
    IN      MIG_TRANSPORTTYPE TransportType,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities
    );

BOOL
WINAPI
IsmSetTransportStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTID TransportId,
    IN      MIG_TRANSPORTSTORAGEID StorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL StoragePathIsValid,                       OPTIONAL
    OUT     PBOOL ImageExistsInStorage                      OPTIONAL
    );

BOOL
WINAPI
IsmPerformParsing (
    VOID
    );

BOOL
WINAPI
IsmExecute (
    IN      MIG_EXECUTETYPEID ExecuteType
    );

BOOL
WINAPI
IsmLoad (
    VOID
    );

BOOL
WINAPI
IsmResumeLoad (
    VOID
    );

BOOL
WINAPI
IsmSave (
    VOID
    );

BOOL
WINAPI
IsmResumeSave (
    VOID
    );

VOID
WINAPI
IsmTerminate (
    VOID
    );

//
// component apis
//

BOOL
WINAPI
IsmAddComponentAlias (
    IN      PCTSTR ComponentString,             OPTIONAL
    IN      UINT MasterGroup,
    IN      PCTSTR LocalizedAlias,
    IN      UINT ComponentGroupId,
    IN      BOOL UserSupplied
    );

BOOL
WINAPI
IsmSelectPreferredAlias (
    IN      PCTSTR ComponentString,
    IN      PCTSTR LocalizedAlias,          OPTIONAL
    IN      UINT ComponentGroupId           OPTIONAL
    );

BOOL
WINAPI
IsmSelectComponent (
    IN      PCTSTR ComponentOrAlias,
    IN      UINT ComponentGroupId,              OPTIONAL
    IN      BOOL Enable
    );

BOOL
WINAPI
IsmSelectMasterGroup (
    IN      UINT MasterGroup,
    IN      BOOL Enable
    );

BOOL
WINAPI
IsmEnumFirstComponent (
    OUT     PMIG_COMPONENT_ENUM EnumPtr,
    IN      DWORD ComponentEnumFlags,
    IN      UINT GroupIdFilter                  OPTIONAL
    );

BOOL
WINAPI
IsmEnumNextComponent (
    IN OUT  PMIG_COMPONENT_ENUM EnumPtr
    );


VOID
WINAPI
IsmAbortComponentEnum (
    IN      PMIG_COMPONENT_ENUM EnumPtr         ZEROED
    );

VOID
WINAPI
IsmRemoveAllUserSuppliedComponents (
    VOID
    );

BOOL
WINAPI
IsmIsComponentSelected (
    IN      PCTSTR ComponentOrAlias,
    IN      UINT ComponentGroupId               OPTIONAL
    );

//
// module support routines
//

PVOID
WINAPI
TrackedIsmGetMemory (
    IN      UINT Size
            TRACKING_DEF
    );
#define IsmGetMemory(s) TrackedIsmGetMemory(s TRACKING_CALL)

PCTSTR
WINAPI
TrackedIsmDuplicateString (
    IN      PCTSTR String
            TRACKING_DEF
    );
#define IsmDuplicateString(s) TrackedIsmDuplicateString(s TRACKING_CALL)

BOOL
WINAPI
IsmReleaseMemory (
    IN      PCVOID Memory
    );

MIG_PLATFORMTYPEID
WINAPI
IsmGetRealPlatform (
    VOID
    );

BOOL
WINAPI
IsmCreateUser (
    IN      PCTSTR UserName,
    IN      PCTSTR Domain
    );

MIG_OBJECTSTRINGHANDLE
TrackedIsmGetLongName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
            TRACKING_DEF
    );
#define IsmGetLongName(t,n) TrackedIsmGetLongName(t,n TRACKING_CALL)

//
// type module interface
//

MIG_OBJECTTYPEID
WINAPI
IsmRegisterObjectType (
    IN      PCTSTR ObjectTypeName,
    IN      BOOL CanBeRestored,
    IN      BOOL ReadOnly,
    IN      PTYPE_REGISTER TypeRegisterData
    );

MIG_OBJECTTYPEID
WINAPI
IsmGetFirstObjectTypeId (
    VOID
    );

MIG_OBJECTTYPEID
WINAPI
IsmGetNextObjectTypeId (
    IN      MIG_OBJECTTYPEID CurrentTypeId
    );

PCTSTR
WINAPI
IsmConvertObjectToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    );

BOOL
WINAPI
IsmConvertMultiSzToObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    );

PCTSTR
WINAPI
TrackedIsmGetNativeObjectName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
            TRACKING_DEF
    );
#define IsmGetNativeObjectName(t,n) TrackedIsmGetNativeObjectName(t,n TRACKING_CALL)

BOOL
IsmRegisterPhysicalAcquireHook (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      PMIG_PHYSICALACQUIREHOOK HookCallback,
    IN      PMIG_PHYSICALACQUIREFREE FreeCallback,          OPTIONAL
    IN      ULONG_PTR CallbackArg,                          OPTIONAL
    IN      PCTSTR FunctionId                               OPTIONAL
    );

BOOL
IsmProhibitPhysicalEnum (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      PMIG_PHYSICALENUMCHECK EnumCheckCallback,       OPTIONAL
    IN      ULONG_PTR CallbackArg,                          OPTIONAL
    IN      PCTSTR FunctionId                               OPTIONAL
    );

BOOL
IsmAddToPhysicalEnum (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectBase,
    IN      PMIG_PHYSICALENUMADD EnumAddCallback,
    IN      ULONG_PTR CallbackArg                           OPTIONAL
    );

//
// environment & messaging
//

BOOL
WINAPI
IsmSetEnvironmentValue (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PENVENTRY_STRUCT VariableData   OPTIONAL
    );

BOOL
WINAPI
IsmSetEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    );

BOOL
WINAPI
IsmSetEnvironmentMultiSz (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    );

BOOL
WINAPI
IsmAppendEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    );

BOOL
WINAPI
IsmAppendEnvironmentMultiSz (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    );

BOOL
WINAPI
IsmSetEnvironmentCallback (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PENVENTRYCALLBACK VariableCallback
    );

BOOL
WINAPI
IsmSetEnvironmentData (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCBYTE VariableData,
    IN      UINT VariableDataSize
    );

BOOL
WINAPI
IsmSetEnvironmentFlag (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName
    );

BOOL
WINAPI
IsmGetEnvironmentValue (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PBYTE Data,                 OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded,       OPTIONAL
    OUT     PENVENTRY_TYPE DataType     OPTIONAL
    );

BOOL
WINAPI
IsmGetEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PTSTR VariableValue,        OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded        OPTIONAL
    );

#define IsmCopyEnvironmentString(p,g,n,v) IsmGetEnvironmentString(p,g,n,v,sizeof(v)/sizeof((v)[0]),NULL)

BOOL
WINAPI
IsmGetEnvironmentMultiSz (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PTSTR VariableValue,        OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded        OPTIONAL
    );

BOOL
WINAPI
IsmGetEnvironmentCallback (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                           OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PENVENTRYCALLBACK *VariableCallback     OPTIONAL
    );

BOOL
WINAPI
IsmGetEnvironmentData (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PBYTE VariableData,         OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded        OPTIONAL
    );

BOOL
WINAPI
IsmIsEnvironmentFlagSet (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName
    );

BOOL
WINAPI
IsmDeleteEnvironmentVariable (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName
    );

PCTSTR
WINAPI
TrackedIsmExpandEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR SrcString,
    IN      PCTSTR Context
            TRACKING_DEF
    );
#define IsmExpandEnvironmentString(p,g,s,c) TrackedIsmExpandEnvironmentString(p,g,s,c TRACKING_CALL)

BOOL
WINAPI
IsmGetTransportVariable (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    OUT     PTSTR KeyData,              OPTIONAL
    IN      UINT KeyDataBufferSizeInBytes
    );

BOOL
WINAPI
IsmSetTransportVariable (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    IN      PCTSTR KeyData
    );

ULONG_PTR
WINAPI
IsmSendMessageToApp (
    UINT Message,
    ULONG_PTR Arg
    );

MIG_PROGRESSSLICEID
WINAPI
IsmRegisterProgressSlice (
    IN      UINT Ticks,
    IN      UINT TimeEstimateInSeconds
    );

BOOL
WINAPI
IsmTickProgressBar (
    IN      MIG_PROGRESSSLICEID SliceId,
    IN      UINT TickDelta                  OPTIONAL
    );

#define IsmCheckCancel()    (IsmTickProgressBar(0,0)==FALSE)

BOOL
WINAPI
IsmCurrentlyExecuting (
    VOID
    );

VOID
WINAPI
IsmSetCancel (
    VOID
    );

//
// encoded strings support
//

MIG_OBJECTSTRINGHANDLE
WINAPI
TrackedIsmCreateObjectHandle (
    IN      PCTSTR Node,
    IN      PCTSTR Leaf
            TRACKING_DEF
    );
#define IsmCreateObjectHandle(n,l) TrackedIsmCreateObjectHandle(n,l TRACKING_CALL)

BOOL
WINAPI
TrackedIsmCreateObjectStringsFromHandleEx (
    IN      MIG_OBJECTSTRINGHANDLE Handle,
    OUT     PCTSTR *Node,               OPTIONAL
    OUT     PCTSTR *Leaf,               OPTIONAL
    IN      BOOL DoNotDecode
            TRACKING_DEF
    );

#define IsmCreateObjectStringsFromHandleEx(h,n,l,d) TrackedIsmCreateObjectStringsFromHandleEx(h,n,l,d TRACKING_CALL)
#define IsmCreateObjectStringsFromHandle(handle,node,leaf)  IsmCreateObjectStringsFromHandleEx(handle,node,leaf,FALSE)

BOOL
WINAPI
IsmIsObjectHandleNodeOnly (
    IN      MIG_OBJECTSTRINGHANDLE Handle
    );

BOOL
WINAPI
IsmIsObjectHandleLeafOnly (
    IN      MIG_OBJECTSTRINGHANDLE Handle
    );


VOID
WINAPI
IsmDestroyObjectString (
    IN      PCTSTR String
    );

VOID
WINAPI
IsmDestroyObjectHandle (
    IN      MIG_OBJECTSTRINGHANDLE Handle
    );

MIG_OBJECTSTRINGHANDLE
WINAPI
TrackedIsmCreateObjectPattern (
    IN      PMIG_SEGMENTS NodeSegments,     OPTIONAL
    IN      UINT NodeSegmentsNr,
    IN      PMIG_SEGMENTS LeafSegments,     OPTIONAL
    IN      UINT LeafSegmentsNr
            TRACKING_DEF
    );

#define IsmCreateObjectPattern(node,ncnt,leaf,lcnt) TrackedIsmCreateObjectPattern(node,ncnt,leaf,lcnt TRACKING_CALL)

MIG_OBJECTSTRINGHANDLE
WINAPI
TrackedIsmCreateSimpleObjectPattern (
    IN      PCTSTR BaseNode,                    OPTIONAL
    IN      BOOL EnumTree,
    IN      PCTSTR Leaf,                        OPTIONAL
    IN      BOOL LeafIsPattern
            TRACKING_DEF
    );

#define IsmCreateSimpleObjectPattern(base,tree,leaf,pat) TrackedIsmCreateSimpleObjectPattern(base,tree,leaf,pat TRACKING_CALL)

MIG_PARSEDPATTERN
IsmCreateParsedPattern (
    IN      MIG_OBJECTSTRINGHANDLE EncodedObject
    );

VOID
IsmDestroyParsedPattern (
    IN      MIG_PARSEDPATTERN ParsedPattern
    );

BOOL
WINAPI
IsmParsedPatternMatchEx (
    IN      MIG_PARSEDPATTERN ParsedPattern,
    IN      MIG_OBJECTTYPEID ObjectTypeId,      OPTIONAL
    IN      PCTSTR Node,                        OPTIONAL
    IN      PCTSTR Leaf                         OPTIONAL
    );

BOOL
WINAPI
IsmParsedPatternMatch (
    IN      MIG_PARSEDPATTERN ParsedPattern,
    IN      MIG_OBJECTTYPEID ObjectTypeId,      OPTIONAL
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    );

//
// objects
//

MIG_OBJECTID
WINAPI
IsmGetObjectIdFromName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      BOOL MustExist
    );

VOID
WINAPI
IsmLockObjectId (
    IN      MIG_OBJECTID ObjectId
    );

VOID
WINAPI
IsmLockObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

MIG_OBJECTSTRINGHANDLE
WINAPI
IsmFilterObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     MIG_OBJECTTYPEID *NewObjectTypeId,          OPTIONAL
    OUT     PBOOL ObjectDeleted,                        OPTIONAL
    OUT     PBOOL ObjectReplaced                        OPTIONAL
    );

BOOL
WINAPI
IsmEnumFirstSourceObjectEx (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      BOOL EnumerateVirtualObjects
    );
#define IsmEnumFirstSourceObject(e,t,p) IsmEnumFirstSourceObjectEx(e,t,p,FALSE)

BOOL
WINAPI
IsmEnumFirstDestinationObjectEx (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      BOOL EnumerateVirtualObjects
    );
#define IsmEnumFirstDestinationObject(e,t,p) IsmEnumFirstDestinationObjectEx(e,t,p,FALSE)

BOOL
WINAPI
IsmEnumNextObject (
    IN OUT  PMIG_OBJECT_ENUM ObjectEnum
    );

VOID
WINAPI
IsmAbortObjectEnum (
    IN      PMIG_OBJECT_ENUM ObjectEnum
    );

//
// persistence, apply, AbandonOnCollision, and NonCritical flags
//

BOOL
WINAPI
IsmMakePersistentObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmMakePersistentObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmClearPersistenceOnObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmClearPersistenceOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmIsPersistentObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmIsPersistentObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmEnumFirstPersistentObject (
    OUT     PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );

BOOL
WINAPI
IsmEnumNextPersistentObject (
    IN OUT  PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortPersistentObjectEnum (
    IN      PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );

BOOL
WINAPI
IsmMakeApplyObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmMakeApplyObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmClearApplyOnObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmClearApplyOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmIsApplyObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmIsApplyObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmEnumFirstApplyObject (
    OUT     PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );

BOOL
WINAPI
IsmEnumNextApplyObject (
    IN OUT  PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortApplyObjectEnum (
    IN      PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );

BOOL
WINAPI
IsmAbandonObjectIdOnCollision (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmAbandonObjectOnCollision (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmClearAbandonObjectIdOnCollision (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmClearAbandonObjectOnCollision (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmIsObjectIdAbandonedOnCollision (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmIsObjectAbandonedOnCollision (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmMakeNonCriticalObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmMakeNonCriticalObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmClearNonCriticalFlagOnObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmClearNonCriticalFlagOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmIsNonCriticalObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmIsNonCriticalObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );



//
// attributes
//

MIG_ATTRIBUTEID
WINAPI
IsmRegisterAttribute (
    IN      PCTSTR AttributeName,
    IN      BOOL Private
    );

BOOL
WINAPI
IsmGetAttributeName (
    IN      MIG_ATTRIBUTEID AttributeId,
    OUT     PTSTR AttributeName,            OPTIONAL
    IN      UINT AttributeNameBufChars,
    OUT     PBOOL Private,                  OPTIONAL
    OUT     PBOOL BelongsToMe,              OPTIONAL
    OUT     PUINT ObjectReferences          OPTIONAL
    );

MIG_ATTRIBUTEID
WINAPI
IsmGetAttributeGroup (
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmSetAttributeOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmSetAttributeOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_ATTRIBUTEID AttributeId
    );

VOID
WINAPI
IsmLockAttribute (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmClearAttributeOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmClearAttributeOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmIsAttributeSetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmIsAttributeSetOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmEnumFirstObjectAttributeById (
    OUT     PMIG_OBJECTATTRIBUTE_ENUM EnumPtr,
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmEnumFirstObjectAttribute (
    OUT     PMIG_OBJECTATTRIBUTE_ENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmEnumNextObjectAttribute (
    IN OUT  PMIG_OBJECTATTRIBUTE_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortObjectAttributeEnum (
    IN OUT  PMIG_OBJECTATTRIBUTE_ENUM EnumPtr
    );

BOOL
WINAPI
IsmEnumFirstObjectWithAttribute (
    OUT     PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr,
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmEnumNextObjectWithAttribute (
    IN OUT  PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortObjectWithAttributeEnum (
    IN OUT  PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );


//
// properties
//

MIG_PROPERTYID
WINAPI
IsmRegisterProperty (
    IN      PCTSTR PropertyName,
    IN      BOOL Private
    );

BOOL
WINAPI
IsmGetPropertyName (
    IN      MIG_PROPERTYID PropertyId,
    OUT     PTSTR PropertyName,             OPTIONAL
    IN      UINT PropertyNameBufChars,
    OUT     PBOOL Private,                  OPTIONAL
    OUT     PBOOL BelongsToMe,              OPTIONAL
    OUT     PUINT ObjectReferences          OPTIONAL
    );

MIG_PROPERTYID
WINAPI
IsmGetPropertyGroup (
    IN      MIG_PROPERTYID PropertyId
    );

MIG_PROPERTYDATAID
WINAPI
IsmAddPropertyToObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId,
    IN      PCMIG_BLOB Property
    );

MIG_PROPERTYDATAID
WINAPI
IsmAddPropertyToObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID PropertyId,
    IN      PCMIG_BLOB Property
    );

MIG_PROPERTYDATAID
WINAPI
IsmRegisterPropertyData (
    IN      PCMIG_BLOB Property
    );

BOOL
WINAPI
IsmAddPropertyDataToObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId,
    IN      MIG_PROPERTYDATAID PropertyDataId
    );

BOOL
WINAPI
IsmAddPropertyDataToObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID PropertyId,
    IN      MIG_PROPERTYDATAID PropertyDataId
    );

VOID
WINAPI
IsmLockProperty (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId
    );

BOOL
WINAPI
IsmGetPropertyData (
    IN      MIG_PROPERTYDATAID PropertyDataId,
    OUT     PBYTE Buffer,                               OPTIONAL
    IN      UINT BufferSize,
    OUT     PUINT PropertyDataSize,                     OPTIONAL
    OUT     PMIG_BLOBTYPE PropertyDataType              OPTIONAL
    );

BOOL
WINAPI
IsmRemovePropertyData (
    IN      MIG_PROPERTYDATAID PropertyDataId
    );

BOOL
WINAPI
IsmRemovePropertyFromObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_PROPERTYDATAID PropertyId
    );

BOOL
WINAPI
IsmRemovePropertyFromObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId
    );

BOOL
WINAPI
IsmIsPropertySetOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID PropertyId
    );

BOOL
WINAPI
IsmIsPropertySetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId
    );

BOOL
WINAPI
IsmEnumFirstObjectProperty (
    OUT     PMIG_OBJECTPROPERTY_ENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_PROPERTYID FilterProperty           OPTIONAL
    );

BOOL
WINAPI
IsmEnumFirstObjectPropertyById (
    OUT     PMIG_OBJECTPROPERTY_ENUM EnumPtr,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID FilterProperty           OPTIONAL
    );

BOOL
WINAPI
IsmEnumNextObjectProperty (
    IN OUT  PMIG_OBJECTPROPERTY_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortObjectPropertyEnum (
    IN OUT  PMIG_OBJECTPROPERTY_ENUM EnumPtr
    );

MIG_PROPERTYDATAID
WINAPI
IsmGetPropertyFromObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_PROPERTYID ObjectProperty
    );

MIG_PROPERTYDATAID
WINAPI
IsmGetPropertyFromObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID ObjectProperty
    );

BOOL
WINAPI
IsmEnumFirstObjectWithProperty (
    OUT     PMIG_OBJECTWITHPROPERTY_ENUM EnumPtr,
    IN      MIG_PROPERTYID PropertyId
    );

BOOL
WINAPI
IsmEnumNextObjectWithProperty (
    IN OUT  PMIG_OBJECTWITHPROPERTY_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortObjectWithPropertyEnum (
    IN OUT  PMIG_OBJECTWITHPROPERTY_ENUM EnumPtr
    );


//
// operations
//

MIG_OPERATIONID
WINAPI
IsmRegisterOperation (
    IN      PCTSTR Name,
    IN      BOOL Private
    );

BOOL
WINAPI
IsmGetOperationName (
    IN      MIG_OPERATIONID OperationId,
    OUT     PTSTR OperationName,            OPTIONAL
    IN      UINT OperationNameBufChars,
    OUT     PBOOL Private,                  OPTIONAL
    OUT     PBOOL BelongsToMe,              OPTIONAL
    OUT     PUINT ObjectReferences          OPTIONAL
    );

MIG_OPERATIONID
WINAPI
IsmGetOperationGroup (
    IN      MIG_OPERATIONID OperationId
    );

BOOL
WINAPI
IsmSetOperationOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    IN      PCMIG_BLOB SourceData,          OPTIONAL
    IN      PCMIG_BLOB DestinationData      OPTIONAL
    );

BOOL
WINAPI
IsmSetOperationOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_OPERATIONID OperationId,
    IN      PCMIG_BLOB SourceData,          OPTIONAL
    IN      PCMIG_BLOB DestinationData      OPTIONAL
    );

MIG_DATAHANDLE
WINAPI
IsmRegisterOperationData (
    IN      PCMIG_BLOB Data
    );

BOOL
WINAPI
IsmSetOperationOnObjectId2 (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    IN      MIG_DATAHANDLE SourceData,      OPTIONAL
    IN      MIG_DATAHANDLE DestinationData  OPTIONAL
    );

BOOL
WINAPI
IsmSetOperationOnObject2 (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_OPERATIONID OperationId,
    IN      MIG_DATAHANDLE SourceData,      OPTIONAL
    IN      MIG_DATAHANDLE DestinationData  OPTIONAL
    );

VOID
WINAPI
IsmLockOperation (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId
    );

BOOL
WINAPI
IsmClearOperationOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId
    );

BOOL
WINAPI
IsmClearOperationOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_OPERATIONID OperationId
    );

BOOL
WINAPI
IsmIsOperationSetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId
    );

BOOL
WINAPI
IsmIsOperationSetOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_OPERATIONID OperationId
    );

BOOL
WINAPI
IsmGetObjectOperationDataById (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    OUT     PBYTE Buffer,                   OPTIONAL
    IN      UINT BufferSize,
    OUT     PUINT BufferSizeNeeded,         OPTIONAL
    OUT     PMIG_BLOBTYPE Type,             OPTIONAL
    IN      BOOL DestinationData
    );

BOOL
WINAPI
IsmGetObjectOperationData (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_OPERATIONID OperationId,
    OUT     PBYTE Buffer,                   OPTIONAL
    IN      UINT BufferSize,
    OUT     PUINT BufferSizeNeeded,         OPTIONAL
    OUT     PMIG_BLOBTYPE Type,             OPTIONAL
    IN      BOOL DestinationData
    );


BOOL
WINAPI
IsmEnumFirstObjectOperationById (
    OUT     PMIG_OBJECTOPERATION_ENUM EnumPtr,
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmEnumFirstObjectOperation (
    OUT     PMIG_OBJECTOPERATION_ENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    );

BOOL
WINAPI
IsmEnumNextObjectOperation (
    IN OUT  PMIG_OBJECTOPERATION_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortObjectOperationEnum (
    IN OUT  PMIG_OBJECTOPERATION_ENUM EnumPtr
    );

BOOL
WINAPI
IsmEnumFirstObjectWithOperation (
    OUT     PMIG_OBJECTWITHOPERATION_ENUM EnumPtr,
    IN      MIG_OPERATIONID OperationId
    );

BOOL
WINAPI
IsmEnumNextObjectWithOperation (
    IN OUT  PMIG_OBJECTWITHOPERATION_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortObjectWithOperationEnum (
    IN OUT  PMIG_OBJECTWITHOPERATION_ENUM EnumPtr
    );

BOOL
WINAPI
IsmRegisterOperationFilterCallback (
    IN      MIG_OPERATIONID OperationId,
    IN      POPMFILTERCALLBACK Callback,
    IN      BOOL TreeFilter,
    IN      BOOL HighPriority,
    IN      BOOL CanHandleNoRestore
    );

BOOL
WINAPI
IsmRegisterGlobalFilterCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR FunctionId,
    IN      POPMFILTERCALLBACK Callback,
    IN      BOOL TreeFilter,
    IN      BOOL CanHandleNoRestore
    );

BOOL
WINAPI
IsmRegisterOperationApplyCallback (
    IN      MIG_OPERATIONID OperationId,
    IN      POPMAPPLYCALLBACK Callback,
    IN      BOOL HighPriority
    );

BOOL
WINAPI
IsmRegisterGlobalApplyCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR FunctionId,
    IN      POPMAPPLYCALLBACK Callback
    );

//
// enumeration and object types
//

BOOL
WINAPI
IsmQueueEnumeration (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      PMIG_OBJECTENUMCALLBACK Callback,       OPTIONAL
    IN      ULONG_PTR CallbackArg,                  OPTIONAL
    IN      PCTSTR FunctionId                       OPTIONAL
    );

BOOL
WINAPI
IsmHookEnumeration (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      PMIG_OBJECTENUMCALLBACK Callback,
    IN      ULONG_PTR CallbackArg,                  OPTIONAL
    IN      PCTSTR FunctionId                       OPTIONAL
    );

BOOL
WINAPI
IsmRegisterStaticExclusion (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmRegisterDynamicExclusion (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      PMIG_DYNAMICEXCLUSIONCALLBACK Callback,
    IN      ULONG_PTR CallbackArg,                  OPTIONAL
    IN      PCTSTR FunctionId                       OPTIONAL
    );

BOOL
WINAPI
IsmRegisterPreEnumerationCallback (
    IN      PMIG_PREENUMCALLBACK Callback,
    IN      PCTSTR FunctionId                       OPTIONAL
    );

BOOL
WINAPI
IsmRegisterTypePreEnumerationCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PMIG_PREENUMCALLBACK Callback,
    IN      PCTSTR FunctionId                       OPTIONAL
    );

BOOL
WINAPI
IsmRegisterPostEnumerationCallback (
    IN      PMIG_POSTENUMCALLBACK Callback,
    IN      PCTSTR FunctionId                       OPTIONAL
    );

BOOL
WINAPI
IsmRegisterTypePostEnumerationCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PMIG_POSTENUMCALLBACK Callback,
    IN      PCTSTR FunctionId                       OPTIONAL
    );

MIG_OBJECTTYPEID
WINAPI
IsmGetObjectTypeId (
    IN      PCTSTR ObjectTypeName
    );

PCTSTR
WINAPI
IsmGetObjectTypeName (
    IN      MIG_OBJECTTYPEID TypeId
    );

VOID
WINAPI
IsmExecuteHooks (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

//
// transport interface
//

BOOL
IsmDoesObjectExist (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    );

BOOL
WINAPI
IsmAcquireObjectEx (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    );

#define IsmAcquireObject(type,name,content)   IsmAcquireObjectEx(type,name,content,CONTENTTYPE_ANY,0)

BOOL
WINAPI
IsmReleaseObject (
    IN OUT  PMIG_CONTENT ObjectContent
    );

PMIG_CONTENT
IsmConvertObjectContentToUnicode (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    );

PMIG_CONTENT
IsmConvertObjectContentToAnsi (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    );

BOOL
IsmFreeConvertedObjectContent (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PMIG_CONTENT ObjectContent
    );

BOOL
WINAPI
IsmRegisterRestoreCallback (
    IN      PMIG_RESTORECALLBACK RestoreCallback
    );

MIG_TRANSPORTSTORAGEID
WINAPI
IsmRegisterTransport (
    IN      PCTSTR TypeString
    );

BOOL
WINAPI
IsmGetMappedUserData (
    OUT     PMIG_USERDATA UserData
    );

BOOL
WINAPI
IsmAddControlFile (
    IN      PCTSTR ObjectName,
    IN      PCTSTR NativePath
    );

BOOL
WINAPI
IsmGetControlFile (
    MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR ObjectName,
    IN      PTSTR Buffer
    );

BOOL
WINAPI
IsmSetRollbackJournalType (
    IN      BOOL Common
    );

BOOL
WINAPI
IsmCanWriteRollbackJournal (
    VOID
    );

BOOL
IsmDoesRollbackDataExist (
    OUT     PCTSTR *UserName,
    OUT     PCTSTR *UserDomain,
    OUT     PCTSTR *UserStringSid,
    OUT     PCTSTR *UserProfilePath,
    OUT     BOOL *UserProfileCreated
    );

VOID
WINAPI
IsmRecordOperation (
    IN      DWORD OperationType,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    );

BOOL
WINAPI
IsmRollback (
    VOID
    );

BOOL
IsmPreserveJournal (
    IN      BOOL Preserve
    );

BOOL
WINAPI
IsmSetDelayedOperationsCommand (
    IN      PCTSTR DelayedOperationsCommand
    );

VOID
IsmRecordDelayedOperation (
    IN      DWORD OperationType,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    );

PMIG_OBJECTCOUNT
IsmGetObjectsStatistics (
    IN      MIG_OBJECTTYPEID ObjectTypeId   OPTIONAL
    );

BOOL
IsmGetOsVersionInfo (
    IN      MIG_PLATFORMTYPEID Platform,
    OUT     PMIG_OSVERSIONINFO VersionInfo
    );

BOOL
IsmGetTempStorage (
    OUT     PTSTR Path,
    IN      UINT PathTchars
    );

BOOL
IsmGetTempDirectory (
    OUT     PTSTR Path,
    IN      UINT PathTchars
    );

BOOL
IsmGetTempFile (
    OUT     PTSTR Path,
    IN      UINT PathTchars
    );

BOOL
IsmExecuteFunction (
    IN      UINT ExecutionPhase,
    IN      PCTSTR FunctionMultiSz
    );

BOOL
IsmReplacePhysicalObject (
    IN    MIG_OBJECTTYPEID ObjectTypeId,
    IN    MIG_OBJECTSTRINGHANDLE ObjectName,
    IN    PMIG_CONTENT ObjectContent
    );

BOOL
IsmRemovePhysicalObject (
    IN    MIG_OBJECTTYPEID ObjectTypeId,
    IN    MIG_OBJECTSTRINGHANDLE ObjectName
    );

PCTSTR
IsmGetCurrentSidString (
    VOID
    );

//
// ANSI/UNICODE macros
//

// None


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\inc\v2app.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    v2app.h

Abstract:

    Constants used to communicate with the v2 app layer.

Author:

    Jim Schmidt (jimschm) 24-May-2000

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// Includes
//

#include "ism.h"
#include "trans.h"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Macro expansion definition
//

// None

//
// Public function declarations
//

// None

//
// ANSI/UNICODE macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\inc\ismproc.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ismproc.h

Abstract:

    Callback function prototype definitions for the Intermediate State Manager.

Author:

    Jim Schmidt (jimschm) 15-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// Types
//

//
// misc types
//

#define ISM_VERSION         0x10000

typedef VOID (WINAPI MIG_LOGCALLBACK)(PVOID Arg);
typedef MIG_LOGCALLBACK * PMIG_LOGCALLBACK;

typedef VOID(PROGRESSBARFN)(
                MIG_PROGRESSPHASE Phase,
                MIG_PROGRESSSTATE State,
                UINT WorkDone,
                UINT TotalWork,
                ULONG_PTR Arg
                );

typedef PROGRESSBARFN * PPROGRESSBARFN;

//
// transport
//

typedef BOOL(WINAPI TRANSPORTINITIALIZE)(PMIG_LOGCALLBACK LogCallback);
typedef TRANSPORTINITIALIZE *PTRANSPORTINITIALIZE;

typedef VOID(WINAPI TRANSPORTESTIMATEPROGRESSBAR)(MIG_PLATFORMTYPEID PlatformTypeId);
typedef TRANSPORTESTIMATEPROGRESSBAR *PTRANSPORTESTIMATEPROGRESSBAR;

typedef BOOL(WINAPI TRANSPORTQUERYCAPABILITIES)(
                        IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
                        OUT     PMIG_TRANSPORTTYPE TransportType,
                        OUT     PMIG_TRANSPORTCAPABILITIES Capabilities,
                        OUT     PCTSTR *FriendlyDescription
                        );
typedef TRANSPORTQUERYCAPABILITIES *PTRANSPORTQUERYCAPABILITIES;

typedef BOOL(WINAPI TRANSPORTSETSTORAGE)(
                        IN      MIG_PLATFORMTYPEID Platform,
                        IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
                        IN      MIG_TRANSPORTCAPABILITIES Capabilities,
                        IN      PCTSTR StoragePath,
                        OUT     PBOOL Valid,
                        OUT     PBOOL ImageExists
                        );
typedef TRANSPORTSETSTORAGE *PTRANSPORTSETSTORAGE;

typedef VOID(WINAPI TRANSPORTRESETSTORAGE)(MIG_TRANSPORTSTORAGEID TransportStorageId);
typedef TRANSPORTRESETSTORAGE *PTRANSPORTRESETSTORAGE;

typedef VOID(WINAPI TRANSPORTTERMINATE)(VOID);
typedef TRANSPORTTERMINATE *PTRANSPORTTERMINATE;

typedef BOOL(WINAPI TRANSPORTSAVESTATE)(VOID);
typedef TRANSPORTSAVESTATE *PTRANSPORTSAVESTATE;

typedef BOOL(WINAPI TRANSPORTRESUMESAVESTATE)(VOID);
typedef TRANSPORTRESUMESAVESTATE *PTRANSPORTRESUMESAVESTATE;

typedef BOOL(WINAPI TRANSPORTBEGINAPPLY)(VOID);
typedef TRANSPORTBEGINAPPLY *PTRANSPORTBEGINAPPLY;

typedef BOOL(WINAPI TRANSPORTRESUMEAPPLY)(VOID);
typedef TRANSPORTRESUMEAPPLY *PTRANSPORTRESUMEAPPLY;

typedef BOOL(WINAPI TRANSPORTACQUIREOBJECT)(
                            IN      MIG_OBJECTTYPEID ObjectTypeId,
                            IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                            IN OUT  PMIG_CONTENT ObjectContent,
                            IN      MIG_CONTENTTYPE ContentType,
                            IN      UINT MemoryContentLimit
                            );
typedef TRANSPORTACQUIREOBJECT *PTRANSPORTACQUIREOBJECT;

typedef BOOL(WINAPI TRANSPORTRELEASEOBJECT)(PMIG_CONTENT ObjectContent);
typedef TRANSPORTRELEASEOBJECT *PTRANSPORTRELEASEOBJECT;

typedef VOID(WINAPI TRANSPORTENDAPPLY)(VOID);
typedef TRANSPORTENDAPPLY *PTRANSPORTENDAPPLY;

typedef struct {
    UINT Version;
    PTRANSPORTINITIALIZE TransportInitialize;
    PTRANSPORTESTIMATEPROGRESSBAR TransportEstimateProgressBar;
    PTRANSPORTQUERYCAPABILITIES TransportQueryCapabilities;
    PTRANSPORTSETSTORAGE TransportSetStorage;
    PTRANSPORTRESETSTORAGE TransportResetStorage;
    PTRANSPORTTERMINATE TransportTerminate;
    PTRANSPORTSAVESTATE TransportSaveState;
    PTRANSPORTRESUMESAVESTATE TransportResumeSaveState;
    PTRANSPORTBEGINAPPLY TransportBeginApply;
    PTRANSPORTRESUMEAPPLY TransportResumeApply;
    PTRANSPORTACQUIREOBJECT TransportAcquireObject;
    PTRANSPORTRELEASEOBJECT TransportReleaseObject;
    PTRANSPORTENDAPPLY TransportEndApply;
} TRANSPORT_ENTRYPOINTS, *PTRANSPORT_ENTRYPOINTS;

//
// operations
//

typedef BOOL (WINAPI OPMFILTERCALLBACK)(
                        PCMIG_FILTERINPUT InputData,
                        PMIG_FILTEROUTPUT OutputData,
                        BOOL NoRestoreObject,
                        PCMIG_BLOB SourceOperationData,             OPTIONAL
                        PCMIG_BLOB DestinationOperationData         OPTIONAL
                        );
typedef OPMFILTERCALLBACK *POPMFILTERCALLBACK;

typedef BOOL (WINAPI OPMAPPLYCALLBACK)(
                        MIG_OBJECTTYPEID SrcObjectTypeId,
                        MIG_OBJECTSTRINGHANDLE SrcObjectName,
                        PCMIG_CONTENT OriginalContent,
                        PCMIG_CONTENT CurrentContent,
                        PMIG_CONTENT NewContent,
                        PCMIG_BLOB SourceOperationData,             OPTIONAL
                        PCMIG_BLOB DestinationOperationData         OPTIONAL
                        );
typedef OPMAPPLYCALLBACK *POPMAPPLYCALLBACK;

//
// message passing
//

typedef ULONG_PTR(CALLBACK MESSAGECALLBACK)(UINT Message, ULONG_PTR Arg);
typedef MESSAGECALLBACK *PMESSAGECALLBACK;

//
// ETM entry points
//

typedef BOOL(WINAPI TYPE_ENUMFIRSTPHYSICALOBJECT)(
                IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,
                IN      MIG_OBJECTSTRINGHANDLE Pattern,
                IN      UINT MaxLevel
                );
typedef TYPE_ENUMFIRSTPHYSICALOBJECT *PTYPE_ENUMFIRSTPHYSICALOBJECT;

typedef BOOL(WINAPI TYPE_ENUMNEXTPHYSICALOBJECT)(
                IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
                );
typedef TYPE_ENUMNEXTPHYSICALOBJECT *PTYPE_ENUMNEXTPHYSICALOBJECT;

typedef VOID(WINAPI TYPE_ABORTENUMCURRENTPHYSICALNODE)(
                IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
                );
typedef TYPE_ABORTENUMCURRENTPHYSICALNODE *PTYPE_ABORTENUMCURRENTPHYSICALNODE;

typedef VOID(WINAPI TYPE_ABORTENUMPHYSICALOBJECT)(
                IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
                );
typedef TYPE_ABORTENUMPHYSICALOBJECT *PTYPE_ABORTENUMPHYSICALOBJECT;

typedef PCTSTR(WINAPI TYPE_CONVERTOBJECTTOMULTISZ)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                IN      PMIG_CONTENT ObjectContent
                );
typedef TYPE_CONVERTOBJECTTOMULTISZ *PTYPE_CONVERTOBJECTTOMULTISZ;

typedef BOOL(WINAPI TYPE_CONVERTMULTISZTOOBJECT)(
                IN      PCTSTR ObjectMultiSz,
                OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
                OUT     PMIG_CONTENT ObjectContent          OPTIONAL
                );
typedef TYPE_CONVERTMULTISZTOOBJECT *PTYPE_CONVERTMULTISZTOOBJECT;

typedef PCTSTR(WINAPI TYPE_GETNATIVEOBJECTNAME)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName
                );
typedef TYPE_GETNATIVEOBJECTNAME *PTYPE_GETNATIVEOBJECTNAME;

typedef BOOL(WINAPI TYPE_ACQUIREPHYSICALOBJECT)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                OUT     PMIG_CONTENT ObjectContent,
                IN      MIG_CONTENTTYPE ContentType,
                IN      UINT MemoryContentLimit
                );
typedef TYPE_ACQUIREPHYSICALOBJECT *PTYPE_ACQUIREPHYSICALOBJECT;

typedef BOOL(WINAPI TYPE_RELEASEPHYSICALOBJECT)(
                IN OUT  PMIG_CONTENT ObjectContent
                );
typedef TYPE_RELEASEPHYSICALOBJECT *PTYPE_RELEASEPHYSICALOBJECT;

typedef BOOL(WINAPI TYPE_DOESPHYSICALOBJECTEXIST)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName
                );
typedef TYPE_DOESPHYSICALOBJECTEXIST *PTYPE_DOESPHYSICALOBJECTEXIST;

typedef BOOL(WINAPI TYPE_REMOVEPHYSICALOBJECT)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName
                );
typedef TYPE_REMOVEPHYSICALOBJECT *PTYPE_REMOVEPHYSICALOBJECT;

typedef BOOL(WINAPI TYPE_CREATEPHYSICALOBJECT)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                IN      PMIG_CONTENT ObjectContent
                );
typedef TYPE_CREATEPHYSICALOBJECT *PTYPE_CREATEPHYSICALOBJECT;

typedef BOOL(WINAPI TYPE_REPLACEPHYSICALOBJECT)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                IN      PMIG_CONTENT ObjectContent
                );
typedef TYPE_REPLACEPHYSICALOBJECT *PTYPE_REPLACEPHYSICALOBJECT;

typedef PMIG_CONTENT(WINAPI TYPE_CONVERTOBJECTCONTENTTOUNICODE)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                IN      PMIG_CONTENT ObjectContent
                );
typedef TYPE_CONVERTOBJECTCONTENTTOUNICODE *PTYPE_CONVERTOBJECTCONTENTTOUNICODE;

typedef PMIG_CONTENT(WINAPI TYPE_CONVERTOBJECTCONTENTTOANSI)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                IN      PMIG_CONTENT ObjectContent
                );
typedef TYPE_CONVERTOBJECTCONTENTTOANSI *PTYPE_CONVERTOBJECTCONTENTTOANSI;

typedef BOOL(WINAPI TYPE_FREECONVERTEDOBJECTCONTENT)(
                IN      PMIG_CONTENT ObjectContent
                );
typedef TYPE_FREECONVERTEDOBJECTCONTENT *PTYPE_FREECONVERTEDOBJECTCONTENT;

typedef struct {
    PTYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstPhysicalObject;
    PTYPE_ENUMNEXTPHYSICALOBJECT EnumNextPhysicalObject;
    PTYPE_ABORTENUMCURRENTPHYSICALNODE AbortEnumCurrentPhysicalNode;
    PTYPE_ABORTENUMPHYSICALOBJECT AbortEnumPhysicalObject;
    PTYPE_CONVERTOBJECTTOMULTISZ ConvertObjectToMultiSz;
    PTYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToObject;
    PTYPE_GETNATIVEOBJECTNAME GetNativeObjectName;
    PTYPE_ACQUIREPHYSICALOBJECT AcquirePhysicalObject;
    PTYPE_RELEASEPHYSICALOBJECT ReleasePhysicalObject;
    PTYPE_DOESPHYSICALOBJECTEXIST DoesPhysicalObjectExist;
    PTYPE_REMOVEPHYSICALOBJECT RemovePhysicalObject;
    PTYPE_CREATEPHYSICALOBJECT CreatePhysicalObject;
    PTYPE_REPLACEPHYSICALOBJECT ReplacePhysicalObject;
    PTYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertObjectContentToUnicode;
    PTYPE_CONVERTOBJECTCONTENTTOANSI ConvertObjectContentToAnsi;
    PTYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedObjectContent;
} TYPE_REGISTER, *PTYPE_REGISTER;

typedef BOOL (WINAPI MIG_PHYSICALENUMCHECK)(
                IN      PMIG_TYPEOBJECTENUM ObjectEnum,
                IN      ULONG_PTR Arg
                );

typedef MIG_PHYSICALENUMCHECK *PMIG_PHYSICALENUMCHECK;

typedef BOOL (WINAPI MIG_PHYSICALENUMADD)(
                IN OUT  PMIG_TYPEOBJECTENUM ObjectEnum,
                IN      MIG_OBJECTSTRINGHANDLE Pattern,     // NULL if Abort is TRUE
                IN      MIG_PARSEDPATTERN ParsedPattern,    // NULL if Abort is TRUE
                IN      ULONG_PTR Arg,
                IN      BOOL Abort
                );

typedef MIG_PHYSICALENUMADD *PMIG_PHYSICALENUMADD;

typedef BOOL (WINAPI MIG_PHYSICALACQUIREHOOK)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                IN      PMIG_CONTENT ObjectContent,
                IN      MIG_CONTENTTYPE ContentType,
                IN      UINT MemoryContentLimit,
                OUT     PMIG_CONTENT *NewObjectContent,         CALLER_INITIALIZED OPTIONAL
                IN      BOOL ReleaseContent,
                IN      ULONG_PTR Arg
                );

typedef MIG_PHYSICALACQUIREHOOK *PMIG_PHYSICALACQUIREHOOK;

typedef VOID (WINAPI MIG_PHYSICALACQUIREFREE)(PMIG_CONTENT ObjectContent);

typedef MIG_PHYSICALACQUIREFREE *PMIG_PHYSICALACQUIREFREE;


//
// module entry points
//

typedef BOOL(WINAPI MODULEINITIALIZE)(VOID);
typedef MODULEINITIALIZE * PMODULEINITIALIZE;

typedef VOID(WINAPI MODULETERMINATE)(VOID);
typedef MODULETERMINATE * PMODULETERMINATE;

typedef BOOL(WINAPI ETMINITIALIZE)(MIG_PLATFORMTYPEID Platform, PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef ETMINITIALIZE * PETMINITIALIZE;

typedef BOOL(WINAPI ETMPARSE)(PVOID Reserved);
typedef ETMPARSE *PETMPARSE;

typedef VOID(WINAPI ETMTERMINATE)(VOID);
typedef ETMTERMINATE * PETMTERMINATE;

typedef VOID(WINAPI ETMNEWUSERCREATED)(PCTSTR UserName, PCTSTR DomainName, PCTSTR UserProfileRoot, PSID UserSid);
typedef ETMNEWUSERCREATED * PETMNEWUSERCREATED;

typedef struct {
    UINT Version;
    PETMINITIALIZE EtmInitialize;
    PETMPARSE EtmParse;
    PETMTERMINATE EtmTerminate;
    PETMNEWUSERCREATED EtmNewUserCreated;
} TYPE_ENTRYPOINTS, *PTYPE_ENTRYPOINTS;

typedef BOOL(WINAPI VCMINITIALIZE)(PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef VCMINITIALIZE * PVCMINITIALIZE;

typedef BOOL(WINAPI VCMPARSE)(PVOID Reserved);
typedef VCMPARSE * PVCMPARSE;

typedef BOOL(WINAPI VCMQUEUEENUMERATION)(PVOID Reserved);
typedef VCMQUEUEENUMERATION * PVCMQUEUEENUMERATION;

typedef BOOL(WINAPI VCMQUEUEHIGHPRIORITYENUMERATION)(PVOID Reserved);
typedef VCMQUEUEHIGHPRIORITYENUMERATION * PVCMQUEUEHIGHPRIORITYENUMERATION;

typedef UINT(WINAPI VCMENUMERATIONCALLBACK)(
                IN      PCMIG_OBJECTENUMDATA Data,
                IN      ULONG_PTR CallerArg
                );
typedef VCMENUMERATIONCALLBACK * PVCMENUMERATIONCALLBACK;

typedef VOID(WINAPI VCMTERMINATE)(VOID);
typedef VCMTERMINATE * PVCMTERMINATE;

typedef struct {
    UINT Version;
    PVCMINITIALIZE VcmInitialize;
    PVCMPARSE VcmParse;
    PVCMQUEUEENUMERATION VcmQueueEnumeration;
    PVCMQUEUEHIGHPRIORITYENUMERATION VcmQueueHighPriorityEnumeration;
    PVCMTERMINATE VcmTerminate;
} VIRTUAL_COMPUTER_ENTRYPOINTS, *PVIRTUAL_COMPUTER_ENTRYPOINTS;

typedef BOOL(WINAPI SGMINITIALIZE)(PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef SGMINITIALIZE * PSGMINITIALIZE;

typedef BOOL(WINAPI SGMPARSE)(PVOID Reserved);
typedef SGMPARSE * PSGMPARSE;

typedef BOOL(WINAPI SGMQUEUEENUMERATION)(PVOID Reserved);
typedef SGMQUEUEENUMERATION * PSGMQUEUEENUMERATION;

typedef BOOL(WINAPI SGMQUEUEHIGHPRIORITYENUMERATION)(PVOID Reserved);
typedef SGMQUEUEHIGHPRIORITYENUMERATION * PSGMQUEUEHIGHPRIORITYENUMERATION;

typedef UINT(WINAPI SGMENUMERATIONCALLBACK)(
                IN      PCMIG_OBJECTENUMDATA Data,
                IN      ULONG_PTR CallerArg
                );
typedef SGMENUMERATIONCALLBACK * PSGMENUMERATIONCALLBACK;

typedef VOID(WINAPI SGMTERMINATE)(VOID);
typedef SGMTERMINATE * PSGMTERMINATE;

typedef BOOL(WINAPI SAMINITIALIZE)(PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef SAMINITIALIZE * PSAMINITIALIZE;

typedef BOOL(WINAPI SAMEXECUTE)(VOID);
typedef SAMEXECUTE * PSAMEXECUTE;

typedef VOID(WINAPI SAMESTIMATEPROGRESSBAR)(VOID);
typedef SAMESTIMATEPROGRESSBAR *PSAMESTIMATEPROGRESSBAR;

typedef VOID(WINAPI SAMTERMINATE)(VOID);
typedef SAMTERMINATE * PSAMTERMINATE;

typedef struct {
    UINT Version;
    PSGMINITIALIZE SgmInitialize;
    PSGMPARSE SgmParse;
    PSGMQUEUEENUMERATION SgmQueueEnumeration;
    PSGMQUEUEHIGHPRIORITYENUMERATION SgmQueueHighPriorityEnumeration;
    PSGMTERMINATE SgmTerminate;
    PSAMINITIALIZE SamInitialize;
    PSAMEXECUTE SamExecute;
    PSAMESTIMATEPROGRESSBAR SamEstimateProgressBar;
    PSAMTERMINATE SamTerminate;
} SOURCE_ENTRYPOINTS, *PSOURCE_ENTRYPOINTS;

typedef BOOL(WINAPI DGMINITIALIZE)(PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef DGMINITIALIZE * PDGMINITIALIZE;

typedef BOOL(WINAPI DGMQUEUEENUMERATION)(PVOID Reserved);
typedef DGMQUEUEENUMERATION * PDGMQUEUEENUMERATION;

typedef BOOL(WINAPI DGMQUEUEHIGHPRIORITYENUMERATION)(PVOID Reserved);
typedef DGMQUEUEHIGHPRIORITYENUMERATION * PDGMQUEUEHIGHPRIORITYENUMERATION;

typedef UINT(WINAPI DGMENUMERATIONCALLBACK)(
                IN      PCMIG_OBJECTENUMDATA Data,
                IN      ULONG_PTR CallerArg
                );
typedef DGMENUMERATIONCALLBACK * PDGMENUMERATIONCALLBACK;

typedef VOID(WINAPI DGMTERMINATE)(VOID);
typedef DGMTERMINATE * PDGMTERMINATE;

typedef BOOL(WINAPI DAMINITIALIZE)(PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef DAMINITIALIZE * PDAMINITIALIZE;

typedef BOOL(WINAPI DAMEXECUTE)(VOID);
typedef DAMEXECUTE * PDAMEXECUTE;

typedef VOID(WINAPI DAMESTIMATEPROGRESSBAR)(VOID);
typedef DAMESTIMATEPROGRESSBAR *PDAMESTIMATEPROGRESSBAR;

typedef VOID(WINAPI DAMTERMINATE)(VOID);
typedef DAMTERMINATE * PDAMTERMINATE;

typedef BOOL(WINAPI CSMINITIALIZE)(PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef CSMINITIALIZE * PCSMINITIALIZE;

typedef BOOL(WINAPI CSMEXECUTE)(VOID);
typedef CSMEXECUTE * PCSMEXECUTE;

typedef VOID(WINAPI CSMESTIMATEPROGRESSBAR)(VOID);
typedef CSMESTIMATEPROGRESSBAR *PCSMESTIMATEPROGRESSBAR;

typedef VOID(WINAPI CSMTERMINATE)(VOID);
typedef CSMTERMINATE * PCSMTERMINATE;

typedef BOOL(WINAPI OPMINITIALIZE)(PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef OPMINITIALIZE * POPMINITIALIZE;

typedef VOID(WINAPI OPMTERMINATE)(VOID);
typedef OPMTERMINATE * POPMTERMINATE;

typedef struct {
    UINT Version;
    PDGMINITIALIZE DgmInitialize;
    PDGMQUEUEENUMERATION DgmQueueEnumeration;
    PDGMQUEUEHIGHPRIORITYENUMERATION DgmQueueHighPriorityEnumeration;
    PDGMTERMINATE DgmTerminate;
    PDAMINITIALIZE DamInitialize;
    PDAMEXECUTE DamExecute;
    PDAMESTIMATEPROGRESSBAR DamEstimateProgressBar;
    PDAMTERMINATE DamTerminate;
    PCSMINITIALIZE CsmInitialize;
    PCSMEXECUTE CsmExecute;
    PCSMESTIMATEPROGRESSBAR CsmEstimateProgressBar;
    PCSMTERMINATE CsmTerminate;
    POPMINITIALIZE OpmInitialize;
    POPMTERMINATE OpmTerminate;
} DESTINATION_ENTRYPOINTS, *PDESTINATION_ENTRYPOINTS;

//
// callback prototypes
//

typedef UINT (WINAPI MIG_OBJECTENUMCALLBACK)(PCMIG_OBJECTENUMDATA Data, ULONG_PTR CallerArg);
typedef MIG_OBJECTENUMCALLBACK *PMIG_OBJECTENUMCALLBACK;

typedef BOOL (WINAPI MIG_PREENUMCALLBACK)(VOID);
typedef MIG_PREENUMCALLBACK *PMIG_PREENUMCALLBACK;

typedef BOOL (WINAPI MIG_POSTENUMCALLBACK)(VOID);
typedef MIG_POSTENUMCALLBACK *PMIG_POSTENUMCALLBACK;

typedef BOOL (WINAPI MIG_DYNAMICEXCLUSIONCALLBACK)(
                    MIG_OBJECTTYPEID ObjectTypeId,
                    MIG_OBJECTSTRINGHANDLE EncodedObjectName,
                    ULONG_PTR Arg
                    );

typedef MIG_DYNAMICEXCLUSIONCALLBACK *PMIG_DYNAMICEXCLUSIONCALLBACK;

typedef BOOL (WINAPI MIG_RESTORECALLBACK)(MIG_OBJECTTYPEID,MIG_OBJECTID,MIG_OBJECTSTRINGHANDLE);
typedef MIG_RESTORECALLBACK *PMIG_RESTORECALLBACK;

//
// entry points that return module funciton addresses
//

typedef BOOL(WINAPI VIRTUALCOMPUTERMODULE)(
                IN      PCTSTR ModuleId,
                IN OUT  PVIRTUAL_COMPUTER_ENTRYPOINTS VirtualComputerEntryPoints
                );
typedef VIRTUALCOMPUTERMODULE *PVIRTUALCOMPUTERMODULE;

typedef BOOL(WINAPI SOURCEMODULE)(
                IN      PCTSTR ModuleId,
                IN OUT  PSOURCE_ENTRYPOINTS SourceEntryPoints
                );
typedef SOURCEMODULE *PSOURCEMODULE;

typedef BOOL(WINAPI DESTINATIONMODULE)(
                IN      PCTSTR ModuleId,
                IN OUT  PDESTINATION_ENTRYPOINTS DestinationEntryPoints
                );
typedef DESTINATIONMODULE *PDESTINATIONMODULE;

typedef BOOL(WINAPI TYPEMODULE)(
                IN      PCTSTR ModuleId,
                IN OUT  PTYPE_ENTRYPOINTS TypeEntryPoints
                );
typedef TYPEMODULE *PTYPEMODULE;

typedef BOOL(WINAPI TRANSPORTMODULE)(
                IN      PCTSTR ModuleId,
                IN OUT  PTRANSPORT_ENTRYPOINTS TransportEntryPoints
                );
typedef TRANSPORTMODULE *PTRANSPORTMODULE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\guitrans\entry.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    entry.c

Abstract:

    Implements the DLL entry point that provides all Cobra module entry points
    to the engine.

Author:

    Jim Schmidt (jimschm) 11-Aug-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "guitrans.h"

typedef struct {
    PCTSTR Name;
    TRANSPORT_ENTRYPOINTS EntryPoints;
} TRANSPORT_TABLE, *PTRANSPORT_TABLE;

#define NOPROGBAR NULL
#define NORESET NULL
#define NORESUME NULL

//
// Add an entry for each transport module in the DLL
//

TRANSPORT_TABLE g_TransportEntryPoints[] = {
    {   TEXT("REMOVABLE_MEDIA"), ISM_VERSION,
        RmvMedTransportInitialize,
        RmvMedTransportEstimateProgressBar,
        RmvMedTransportQueryCapabilities,
        RmvMedTransportSetStorage,
        NORESET,
        RmvMedTransportTerminate,
        RmvMedTransportSaveState,
        NORESUME,
        RmvMedTransportBeginApply,
        NORESUME,
        RmvMedTransportAcquireObject,
        RmvMedTransportReleaseObject,
        RmvMedTransportEndApply
    },

    {   TEXT("DIRECT_CABLE"), ISM_VERSION,
        DirectCableTransportInitialize,
        DirectCableTransportEstimateProgressBar,
        DirectCableTransportQueryCapabilities,
        DirectCableTransportSetStorage,
        NORESET,
        DirectCableTransportTerminate,
        DirectCableTransportSaveState,
        NORESUME,
        DirectCableTransportBeginApply,
        NORESUME,
        DirectCableTransportAcquireObject,
        DirectCableTransportReleaseObject,
        DirectCableTransportEndApply
    },

    {   TEXT("HOME_NETWORKING"), ISM_VERSION,
        HomeNetTransportInitialize,
        HomeNetTransportEstimateProgressBar,
        HomeNetTransportQueryCapabilities,
        HomeNetTransportSetStorage,
        HomeNetTransportResetStorage,
        HomeNetTransportTerminate,
        HomeNetTransportSaveState,
        NORESUME,
        HomeNetTransportBeginApply,
        NORESUME,
        HomeNetTransportAcquireObject,
        HomeNetTransportReleaseObject,
        HomeNetTransportEndApply
    },

    {   TEXT("OPAQUE_UNC_TRANSPORT"), ISM_VERSION,
        OpaqueTransportInitialize,
        OpaqueTransportEstimateProgressBar,
        OpaqueTransportQueryCapabilities,
        OpaqueTransportSetStorage,
        NORESET,
        OpaqueTransportTerminate,
        OpaqueTransportSaveState,
        NORESUME,
        OpaqueTransportBeginApply,
        NORESUME,
        OpaqueTransportAcquireObject,
        OpaqueTransportReleaseObject,
        OpaqueTransportEndApply
    },

    {NULL}
};

EXPORT
BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        g_hInst = hInstance;
    }

    return TRUE;
}


EXPORT
BOOL
WINAPI
ModuleInitialize (
    VOID
    )
{
    TCHAR memDbDir[MAX_PATH];

    UtInitialize (NULL);
    FileEnumInitialize ();
    RegInitialize ();

    IsmGetTempDirectory (memDbDir, ARRAYSIZE (memDbDir));
    if (!MemDbInitializeEx (memDbDir)) {
        IsmSetCancel();
        return FALSE;
    }

    return TRUE;
}

EXPORT
VOID
WINAPI
ModuleTerminate (
    VOID
    )
{
    MemDbTerminateEx (TRUE);
    RegTerminate();
    FileEnumTerminate ();
    UtTerminate ();
}


BOOL
WINAPI
pFindModule (
    IN      PCTSTR ModuleId,
    OUT     PVOID IsmBuffer,
    IN      PCTSTR *TableEntry,
    IN      UINT StructureSize
    )
{

    while (*TableEntry) {
        if (StringIMatch (*TableEntry, ModuleId)) {
            CopyMemory (
                IsmBuffer,
                (PBYTE) (TableEntry + 1),
                StructureSize
                );
            return TRUE;
        }

        TableEntry = (PCTSTR *) ((PBYTE) (TableEntry + 1) + StructureSize);
    }

    return FALSE;
}



EXPORT
BOOL
WINAPI
TransportModule (
    IN      PCTSTR ModuleId,
    IN OUT  PTRANSPORT_ENTRYPOINTS TransportEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) TransportEntryPoints,
                (PCTSTR *) g_TransportEntryPoints,
                sizeof (TRANSPORT_ENTRYPOINTS)
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\guitrans\direct.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    direct.c

Abstract:

    Implements a transport module that works with serial and parallel ports

Author:

    Calin Negreanu (calinn) 14-Apr-2001

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include <compress.h>

#define DBG_DIRECT    "DIRECT"

//
// Strings
//

#define S_TRANSPORT_DAT_FILE    TEXT("TRANSDB.DAT")
#define S_TRANSPORT_DEST_FILE   TEXT("USMT2IMG.DAT")
#define S_TRANSPORT_IMG_FILE    TEXT("IMG%05X.DAT")
#define S_UNCOMPRESSED_FILE     TEXT("TEMPFILE.DAT")
#define S_DETAILS_PREFIX        TEXT("details-")

//
// Constants
//
#define TRFLAG_FILE         0x01
#define TRFLAG_MEMORY       0x02
#define COPY_BUFFER_SIZE    32768
#define DIRECTTR_SIG        0x55534D33  //USM2
#define DIRECT_BUFFER_SIZE  1024

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR TempFile [MAX_PATH];
    PCVOID AllocPtr;
    PCVOID DetailsPtr;
    HANDLE FileHandle;
    HANDLE MapHandle;
} ALLOCSTATE, *PALLOCSTATE;

typedef struct {
    DWORD Signature;
    DWORD NumberOfFiles;
    LONGLONG TotalImageSize;
} HEADER1, *PHEADER1;

typedef struct {
    DWORD FileNumber;
    LONGLONG FileSize;
} HEADER2, *PHEADER2;

//
// Globals
//

MIG_TRANSPORTSTORAGEID g_DirectCableId;
UINT g_DirectCablePlatform;
PCTSTR g_DirectCablePath = NULL;
PCTSTR g_DirectCableTempPath = NULL;
DWORD g_DirectCableBaudRate = 0;
MIG_PROGRESSSLICEID g_PersistentSlice;
MIG_PROGRESSSLICEID g_DatabaseSlice;
UINT g_CompressedTicks;
UINT g_CompressedTicked;
MIG_PROGRESSSLICEID g_CompressedSlice;
UINT g_DownloadTicks;
UINT g_DownloadTicked;
MIG_PROGRESSSLICEID g_DownloadSlice;
UINT g_UncompressTicks;
UINT g_UncompressTicked;
MIG_PROGRESSSLICEID g_UncompressSlice;
LONGLONG g_TotalFiles;
LONGLONG g_FilesRead;
DWORD g_BaudRate [] = {CBR_256000,
                       CBR_128000,
                       CBR_115200,
                       CBR_57600,
                       CBR_56000,
                       CBR_38400,
                       CBR_19200,
                       CBR_14400,
                       CBR_9600,
                       CBR_4800,
                       CBR_2400,
                       CBR_1200,
                       CBR_600,
                       CBR_300,
                       CBR_110,
                       0};

DWORD g_StartTicks = 0;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

VOID
pDCCleanupTempDir (
    VOID
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
WINAPI
DirectCableTransportInitialize (
    PMIG_LOGCALLBACK LogCallback
    )
{
    //
    // Initialize globals
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    g_DirectCableId = IsmRegisterTransport (S_DIRECT_CABLE_TRANSPORT);

    return TRUE;
}

VOID
WINAPI
DirectCableTransportTerminate (
    VOID
    )
{
    pDCCleanupTempDir ();

    if (g_DirectCableTempPath) {
        FreePathString (g_DirectCableTempPath);
        g_DirectCableTempPath = NULL;
    }
    if (g_DirectCablePath) {
        FreePathString (g_DirectCablePath);
        g_DirectCablePath = NULL;
    }
}

VOID
WINAPI
DirectCableTransportEstimateProgressBar (
    MIG_PLATFORMTYPEID PlatformTypeId
    )
{
    UINT ticks;
    PMIG_OBJECTCOUNT objectCount;

    if (PlatformTypeId == PLATFORM_SOURCE) {

        //
        // If saving, we know the number of ticks based on the count of the
        // persistent attribute.
        //

        objectCount = IsmGetObjectsStatistics (PLATFORM_SOURCE);

        if (objectCount) {
            ticks = objectCount->PersistentObjects;
        } else {
            ticks = 0;
        }

        g_PersistentSlice = IsmRegisterProgressSlice (ticks, max (1, ticks / 5));

        g_DatabaseSlice = IsmRegisterProgressSlice (3, 1);

        g_CompressedTicks = ticks;

        g_CompressedSlice = IsmRegisterProgressSlice (g_CompressedTicks, max (1, g_CompressedTicks / 5));
    } else {
        g_DownloadTicked = 0;
        g_DownloadTicks = 1000;
        g_DownloadSlice = IsmRegisterProgressSlice (g_DownloadTicks, 180);
        g_UncompressTicked = 0;
        g_UncompressTicks = 1000;
        g_UncompressSlice = IsmRegisterProgressSlice (g_UncompressTicks, 180);
    }
}

BOOL
WINAPI
DirectCableTransportQueryCapabilities (
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    OUT     PMIG_TRANSPORTTYPE TransportType,
    OUT     PMIG_TRANSPORTCAPABILITIES Capabilities,
    OUT     PCTSTR *FriendlyDescription
    )
{
    if (TransportStorageId != g_DirectCableId) {
        return FALSE;
    }

    *TransportType = TRANSPORTTYPE_FULL;
    *Capabilities = CAPABILITY_COMPRESSED;
    *FriendlyDescription = TEXT("Direct Cable");
    return TRUE;
}

VOID
pDCCleanupTempDir (
    VOID
    )
{
    if (g_DirectCableTempPath) {
        FiRemoveAllFilesInTree (g_DirectCableTempPath);
    }
}

PCTSTR
pDCCreateTemporaryDir (
    VOID
    )
{
    TCHAR tempFile[MAX_PATH];

    if (!IsmGetTempDirectory (tempFile, ARRAYSIZE(tempFile))) {
        return NULL;
    }
    return DuplicatePathString (tempFile, 0);
}

BOOL
WINAPI
DirectCableTransportSetStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL Valid,
    OUT     PBOOL ImageExists
    )
{
    BOOL result = FALSE;
    PTSTR baudRatePtr = NULL;

    if (Valid) {
        *Valid = FALSE;
    }
    if (ImageExists) {
        *ImageExists = FALSE;
    }

    if (TransportStorageId == g_DirectCableId) {

        if ((!RequiredCapabilities) || (RequiredCapabilities == CAPABILITY_COMPRESSED)) {

            if (g_DirectCablePath) {
                FreePathString (g_DirectCablePath);
                g_DirectCablePath = NULL;
            }
            g_DirectCablePath = DuplicatePathString (StoragePath, 0);
            baudRatePtr = _tcschr (g_DirectCablePath, TEXT(':'));
            if (baudRatePtr) {
                *baudRatePtr = 0;
                baudRatePtr ++;
                g_DirectCableBaudRate = _ttoi (baudRatePtr);
            }

            if (Valid) {
                *Valid = TRUE;
            }

            if (ImageExists) {
                if (Platform == PLATFORM_SOURCE) {
                    *ImageExists = FALSE;
                } else {
                    *ImageExists = TRUE;
                }
            }

            result = TRUE;
        }
    }
    return result;
}

PCTSTR
pDCBuildDecoratedObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName
    )
{
    TCHAR prefix[32];

    wsprintf (prefix, TEXT("%u"), ObjectTypeId);

    return JoinPaths (prefix, ObjectName);
}

VOID
pDCDestroyDecoratedObject (
    IN      PCTSTR String
    )
{
    FreePathString (String);
}

BOOL
pDCSaveDetails (
    IN      PCTSTR DecoratedObject,
    IN      PMIG_DETAILS Details
    )
{
    PCTSTR key;
    BOOL b;

    if ((!Details) || (!Details->DetailsSize)) {
        return TRUE;
    }

    key = JoinText (S_DETAILS_PREFIX, DecoratedObject);

    b = (MemDbSetUnorderedBlob (key, 0, Details->DetailsData, Details->DetailsSize) != 0);

    FreeText (key);

    return b;
}

PCTSTR
pDCAllocStorageFileName (
    VOID
    )
{
    static UINT fileIndex = 0;
    TCHAR buffer [32];

    fileIndex ++;
    wsprintf (buffer, TEXT("%08X.DAT"), fileIndex);

    return DuplicatePathString (buffer, 0);
}

BOOL
pDCSaveContentInMemory (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT ObjectValue
    )
{
    BOOL result = FALSE;

    MemDbSetValue (DecoratedObject, TRFLAG_MEMORY);

    if (ObjectValue->MemoryContent.ContentBytes && ObjectValue->MemoryContent.ContentSize) {

        MemDbSetUnorderedBlob (
            DecoratedObject,
            0,
            ObjectValue->MemoryContent.ContentBytes,
            ObjectValue->MemoryContent.ContentSize
            );
    }

    result = pDCSaveDetails (DecoratedObject, &ObjectValue->Details);

    return result;
}

BOOL
pDCAddFileToImage (
    IN      PCTSTR FileName,
    IN      PCTSTR StoredName,
    IN OUT  PCOMPRESS_HANDLE CompressedHandle
    )
{
    return CompressAddFileToHandle (FileName, StoredName, CompressedHandle);
}

BOOL
pDCSaveContentInFile (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedFileName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content,
    IN OUT  PCOMPRESS_HANDLE CompressedHandle
    )
{
    BOOL result = FALSE;
    PCTSTR destPath = NULL;
    DWORD attributes = INVALID_ATTRIBUTES;

    MYASSERT (Content->ContentInFile);
    if (!Content->ContentInFile) {
        return FALSE;
    }

    //
    // Use the CopyFile API to move the file from local to storage.
    //

    __try {
        if (Content && (Content->Details.DetailsSize == sizeof (WIN32_FIND_DATAW)) && Content->Details.DetailsData) {
            attributes = ((PWIN32_FIND_DATAW)Content->Details.DetailsData)->dwFileAttributes;
        }
        if ((attributes != INVALID_ATTRIBUTES) && (attributes & FILE_ATTRIBUTE_DIRECTORY)) {

            // this must be a directory, let's just write the key

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }
            result = TRUE;

        } else {

            //
            // Get a temp file, assemble the src path, copy the file
            //

            destPath = pDCAllocStorageFileName ();
            if (!destPath) {
                __leave;
            }

            if (!pDCAddFileToImage (Content->FileContent.ContentPath, destPath, CompressedHandle)) {
                __leave;
            }

            //
            // Keep track of where the file went
            //

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

            if (!MemDbAddSingleLinkage (DecoratedObject, destPath, 0)) {
                __leave;
            }

            FreePathString (destPath);
            destPath = NULL;
        }

        //
        // Save details
        //

        result = pDCSaveDetails (DecoratedObject, &(Content->Details));
    }
    __finally {
        if (destPath) {
            FreePathString (destPath);
            destPath = NULL;
        }
    }

    return result;
}

PCTSTR
pDCGetImageFile (
    IN      UINT ImageIdx
    )
{
    TCHAR imageFileName [13];
    PCTSTR imageFile = NULL;
    HANDLE imageFileHandle = NULL;

    wsprintf (imageFileName, S_TRANSPORT_IMG_FILE, ImageIdx);
    return JoinPaths (g_DirectCableTempPath, imageFileName);
}

HANDLE
pDCOpenAndSetPort (
    IN      PCTSTR ComPort
    )
{
    HANDLE result = INVALID_HANDLE_VALUE;
    COMMTIMEOUTS commTimeouts;
    DCB dcb;

    // let's open the port. If we can't we just exit with error;
    result = CreateFile (ComPort, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (result == INVALID_HANDLE_VALUE) {
        return result;
    }

    // we want 3 sec timeout for both read and writ