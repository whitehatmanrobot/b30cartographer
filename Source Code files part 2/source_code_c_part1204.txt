ata,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DEV,
                                    KEY_ALL_ACCESS))) {
        return GetLastError();
    }

    len = sizeof(DWORD);
    if (ERROR_SUCCESS != RegQueryValueEx(hKey,
                                         TEXT("RequestFlagsMask"),
                                         NULL,
                                         &type,
                                         (LPBYTE) &requestFlagsMask,
                                         &len)) {
        //
        // Assume key wasn't there - set to 0;
        //
        requestFlagsMask = 0;
    }
    
    len = sizeof(DWORD);
    if (data->TagQueuingCurState) {
        requestFlagsMask |= 0x2;
    } else {
        requestFlagsMask &= ~(DWORD)0x2;
    }
    
    if (ERROR_SUCCESS != RegSetValueEx(hKey,
                                         TEXT("RequestFlagsMask"),
                                         0,
                                         REG_DWORD,
                                         (LPBYTE) &requestFlagsMask,
                                         len)) {
        RegCloseKey(hKey);
        return GetLastError();
    }
    RegCloseKey(hKey);
    return ERROR_SUCCESS;
}

UINT
SetDefaultRequestFlags(PSCSI_PAGE_DATA data)
{
    HKEY hKey;
    DWORD DefaultRequestFlags;
    DWORD len, type;
   
    if (INVALID_HANDLE_VALUE == 
        (hKey = SetupDiOpenDevRegKey(data->DeviceInfoSet,
                                    data->DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DEV,
                                    KEY_ALL_ACCESS))) {
        return GetLastError();
    }

    len = sizeof(DWORD);
    if (ERROR_SUCCESS != RegQueryValueEx(hKey,
                                         TEXT("DefaultRequestFlags"),
                                         NULL,
                                         &type,
                                         (LPBYTE) &DefaultRequestFlags,
                                         &len)) {
        //
        // Assume key wasn't there - set to 0;
        //
        DefaultRequestFlags = 0;
    }
    
    len = sizeof(DWORD);

    if (data->SyncTransCurState) {
        DefaultRequestFlags |= 0x8;
    } else {
        DefaultRequestFlags &= ~(DWORD)0x8;
    }
    
    if (ERROR_SUCCESS != RegSetValueEx(hKey,
                                         TEXT("DefaultRequestFlags"),
                                         0,
                                         REG_DWORD,
                                         (LPBYTE) &DefaultRequestFlags,
                                         len)) {
        RegCloseKey(hKey);
        return GetLastError();
    }
    RegCloseKey(hKey);
    return ERROR_SUCCESS;
}

UINT
GetRequestFlagsMask(PSCSI_PAGE_DATA data)
{
    HKEY hKey;
    DWORD requestFlagsMask;
    DWORD len, type;
   
    if (INVALID_HANDLE_VALUE == 
        (hKey = SetupDiOpenDevRegKey(data->DeviceInfoSet,
                                    data->DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DEV,
                                    KEY_ALL_ACCESS))) {
        data->TagQueuingCurState = FALSE;
        data->TagQueuingOrigState = FALSE;
        return GetLastError();
    }

    len = sizeof(DWORD);
    if (ERROR_SUCCESS != RegQueryValueEx(hKey,
                                         TEXT("RequestFlagsMask"),
                                         NULL,
                                         &type,
                                         (LPBYTE) &requestFlagsMask,
                                         &len)) {
        data->TagQueuingCurState = FALSE;
        data->TagQueuingOrigState = FALSE;
        RegCloseKey(hKey);
        return GetLastError();
    }
    RegCloseKey(hKey);
    
    if (2 & requestFlagsMask) {
        data->TagQueuingCurState = TRUE;
        data->TagQueuingOrigState = TRUE;
    } else {
        data->TagQueuingCurState = FALSE;
        data->TagQueuingOrigState = FALSE;
    }
    return ERROR_SUCCESS;
}

UINT
GetDefaultRequestFlags(PSCSI_PAGE_DATA data)
{
    HKEY hKey;
    DWORD defaultRequestFlags;
    DWORD len, type;
   
    if (INVALID_HANDLE_VALUE == 
        (hKey = SetupDiOpenDevRegKey(data->DeviceInfoSet,
                                    data->DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DEV,
                                    KEY_ALL_ACCESS))) {
        data->SyncTransOrigState = FALSE;
        data->SyncTransCurState = FALSE;
        return GetLastError();
    }

    len = sizeof(DWORD);
    if (ERROR_SUCCESS != RegQueryValueEx(hKey,
                                         TEXT("DefaultRequestFlags"),
                                         NULL,
                                         &type,
                                         (LPBYTE) &defaultRequestFlags,
                                         &len)) {
        data->SyncTransOrigState = FALSE;
        data->SyncTransCurState = FALSE;
        RegCloseKey(hKey);
        return GetLastError();
    }
    RegCloseKey(hKey);
    
    if (8 & defaultRequestFlags) {
        data->SyncTransOrigState = TRUE;
        data->SyncTransCurState = TRUE;
    } else {
        data->SyncTransOrigState = FALSE;
        data->SyncTransCurState = FALSE;
    }

    return ERROR_SUCCESS;
}

BOOL
ScsiOnInitDialog(HWND    HWnd,
                 HWND    HWndFocus,
                 LPARAM  LParam)
{
    LPPROPSHEETPAGE page = (LPPROPSHEETPAGE) LParam;
    PSCSI_PAGE_DATA scsiData = (PSCSI_PAGE_DATA) page->lParam;

    //
    // Set the states of the checkboxes
    //
    if (ERROR_SUCCESS == GetDefaultRequestFlags(scsiData)) {
        CheckDlgButton(HWnd,
                       IDC_SCSI_SYNCHONOUS_TX,
                       scsiData->SyncTransOrigState);
    }
    if (ERROR_SUCCESS == GetRequestFlagsMask(scsiData)) {
        CheckDlgButton(HWnd,
                       IDC_SCSI_TAGGED_QUEUING,
                       scsiData->TagQueuingOrigState);
    }
    
    SetWindowLongPtr(HWnd, DWLP_USER, (LONG_PTR) scsiData);

    return TRUE;
}

LRESULT
ScsiOnNotify (HWND    HWnd,
              int     HWndFocus,
              LPNMHDR lpNMHdr)
{
    PSCSI_PAGE_DATA scsiData = (PSCSI_PAGE_DATA) GetWindowLongPtr(HWnd,
                                                                  DWLP_USER);
    switch(lpNMHdr->code) {

        case PSN_APPLY: {
            SetRequestFlagsMask(scsiData);
            SetDefaultRequestFlags(scsiData);
            break;
        }
    }
    return 0;
}            

VOID
ScsiOnCommand(HWND    HWnd,
              int     id,
              HWND    HWndCtl,
              UINT    codeNotify)
{
    PSCSI_PAGE_DATA scsiData = (PSCSI_PAGE_DATA) GetWindowLongPtr(HWnd,
                                                                  DWLP_USER);
    TCHAR buf[MAX_PATH];

    switch (id) {
    case IDC_SCSI_TAGGED_QUEUING:
        scsiData->TagQueuingCurState = !scsiData->TagQueuingCurState;

        if(scsiData->TagQueuingCurState != scsiData->TagQueuingOrigState) {
            PropSheet_Changed(GetParent(HWnd), HWnd);
        }
        break;

    case IDC_SCSI_SYNCHONOUS_TX:
        scsiData->SyncTransCurState = !scsiData->SyncTransCurState;

        if(scsiData->SyncTransCurState != scsiData->SyncTransOrigState) {
            PropSheet_Changed(GetParent(HWnd), HWnd);
        }
        break;

    }
}
        
INT_PTR
ScsiDialogProc(
    HWND Dialog,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch(Message) {

        HANDLE_MSG(Dialog, WM_INITDIALOG,     ScsiOnInitDialog);
        HANDLE_MSG(Dialog, WM_COMMAND,        ScsiOnCommand);
        HANDLE_MSG(Dialog, WM_NOTIFY,         ScsiOnNotify);

    case WM_CONTEXTMENU:
        return ScsiContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        ScsiHelp(Dialog, (LPHELPINFO) lParam);
        break;

    default: {
        return FALSE;
        break;
    }
    }
    return TRUE;
}


BOOL
ScsiDialogCallback(
    HWND Dialog,
    UINT Message,
    LPPROPSHEETPAGE Page
    )
{
    return TRUE;
}

BOOL
ScsiCheckDriveType (
    IN HDEVINFO            DeviceInfoSet,
    IN PSP_DEVINFO_DATA    DeviceInfoData)
{    
    
    HKEY  hDeviceKey;
    TCHAR * szHwIds = NULL;
    DWORD i;

    for (i=1;i<=4;i++) {

        szHwIds = LocalAlloc(LPTR, i*512);
        if (szHwIds == NULL) {
            return FALSE;
        }
        
        if (SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                             DeviceInfoData,
                                             SPDRP_HARDWAREID,
                                             NULL,
                                             (PBYTE) szHwIds,
                                             i*512,
                                             NULL)) {

            if ( _tcsncmp(TEXT("SCSI"), szHwIds, 4) == 0 ) {
                LocalFree(szHwIds);
                return TRUE;
            }
            LocalFree(szHwIds);
            return FALSE;

        }
        
        LocalFree(szHwIds);

        //
        // ISSUE-2000/5/24-henrygab - need to loop when buffer is too small only
        //
#if 0
        if (GetLastError() != ERROR_BUFFER_TOO_SMALL) {
            return FALSE;
        }
#endif // FALSE

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\proppage\volprop.c ===
/** FILE: volprop.cpp ********** Module Header ********************************
 *
 *  Property page for volume info on disk.
 *
 * History:
 *  30-Jan-1998     HLiu             Initial coding
 *
 *  Copyright (C) Microsoft Corporation, 1998 - 1999
 *
 *************************************************************************/
#include "propp.h"
#include "volprop.h"

// next 2 are shell headers
#include "shlobj.h"
#include "shlobjp.h"

// context identifier 
#define HIDC_DISK                       0x815c042f
#define HIDC_TYPE                       0x815c0430
#define HIDC_STATUS                     0x815c0432
#define HIDC_PARTSTYLE                  0x815c0434
#define HIDC_SPACE                      0x815c0431
#define HIDC_CAPACITY                   0x815c0122
#define HIDC_RESERVED                   0x815c0435
#define HIDC_VOLUME_LIST                0x815c0132
#define HIDC_VOLUME_PROPERTY            0x815c0442
#define HIDC_VOLUME_POPULATE            0x815c0444

// context help map
static const DWORD VolumeHelpIDs[]=
{
    IDC_DISK, HIDC_DISK,
    IDC_TYPE, HIDC_TYPE,
    IDC_STATUS, HIDC_STATUS,
    IDC_PARTSTYLE, HIDC_PARTSTYLE,
    IDC_SPACE, HIDC_SPACE,
    IDC_CAPACITY, HIDC_CAPACITY,
    IDC_RESERVED, HIDC_RESERVED,
    IDC_VOLUME_LIST, HIDC_VOLUME_LIST,
    IDC_VOLUME_PROPERTY, HIDC_VOLUME_PROPERTY,
    IDC_DISK_STATIC, HIDC_DISK,
    IDC_TYPE_STATIC, HIDC_TYPE,
    IDC_STATUS_STATIC, HIDC_STATUS,
    IDC_PARTSTYLE_STATIC, HIDC_PARTSTYLE,
    IDC_SPACE_STATIC, HIDC_SPACE,
    IDC_CAPACITY_STATIC, HIDC_CAPACITY,
    IDC_RESERVED_STATIC, HIDC_RESERVED,
    IDC_VOLUMELIST_STATIC, HIDC_VOLUME_LIST,
    IDC_VOLUME_POPULATE, HIDC_VOLUME_POPULATE,
    IDC_DIV1_STATIC, ((DWORD) -1),
    0, 0
};

// Volume property page functions
//

int CALLBACK SortVolumeList(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    LV_FINDINFO findInfo1 = {LVFI_PARAM,NULL,lParam1};
    LV_FINDINFO findInfo2 = {LVFI_PARAM,NULL,lParam2};
    HWND hwndVolumeList = (HWND)lParamSort;

    int index1 = ListView_FindItem(hwndVolumeList, -1, &findInfo1);
    int index2 = ListView_FindItem(hwndVolumeList, -1, &findInfo2);

    TCHAR ItemText1[ITEM_LENGTH];
    TCHAR ItemText2[ITEM_LENGTH];

    ListView_GetItemText(hwndVolumeList,index1,0,ItemText1,ITEM_LENGTH);
    ListView_GetItemText(hwndVolumeList,index2,0,ItemText2,ITEM_LENGTH);

    if (lstrcmp(ItemText1,ItemText2)>0)
        return 1;
    else
        return -1;
}

BOOL
VolumeOnPopulate(HWND HWnd,
                 PVOLUME_PAGE_DATA volumeData )
{
    HMODULE           LdmModule;
    PPROPERTY_PAGE_DATA pPropertyPageData = NULL;
    HWND              hwndVolumeList=GetDlgItem(HWnd, IDC_VOLUME_LIST);
    int               iCount, i;
    LVITEM            lvitem;
    BOOL              bLoadedDmdskmgr=FALSE;
    BOOL              bResult=FALSE;
    TCHAR             bufferError[800];  // big enough for localization
    TCHAR             bufferTitle[100];

    //
    // Check if LDM is loaded in the same process. If yes, check to see if 
    // volume information is already available from it.
    //
    LdmModule = GetModuleHandle(TEXT("dmdskmgr"));
    if ( LdmModule )
    {
        GET_PROPERTY_PAGE_DATA pfnGetPropertyPageData;
        pfnGetPropertyPageData = (GET_PROPERTY_PAGE_DATA) 
            GetProcAddress(LdmModule, "GetPropertyPageData");
        if (pfnGetPropertyPageData)
            pPropertyPageData = (*pfnGetPropertyPageData)(
                                        volumeData->MachineName,
                                        volumeData->DeviceInstanceId);
    }

    //
    // Try to load the data through dmadmin otherwise.
    //
    if (!pPropertyPageData)
    {
        LOAD_PROPERTY_PAGE_DATA pfnLoadPropertyPageData;
        
        if (!LdmModule)
        {
            LdmModule = LoadLibrary(TEXT("dmdskmgr"));
            if (!LdmModule)
                goto _out;

            bLoadedDmdskmgr = TRUE;
        }

        pfnLoadPropertyPageData = (LOAD_PROPERTY_PAGE_DATA) 
            GetProcAddress(LdmModule, "LoadPropertyPageData");
        if (pfnLoadPropertyPageData)
            pPropertyPageData = (*pfnLoadPropertyPageData)(
                                        volumeData->MachineName,
                                        volumeData->DeviceInfoSet,
                                        volumeData->DeviceInfoData );
    }
    
    if (!pPropertyPageData)
    {
        if ( LoadString( ModuleInstance, IDS_DISK_INFO_NOT_FOUND, bufferError,
                800 ) &&
             LoadString( ModuleInstance, IDS_DISK_INFO_NOT_FOUND_TITLE, bufferTitle,
                100 ) )
        {
            MessageBox( HWnd,
                        bufferError,
                        bufferTitle,
                        MB_OK | MB_ICONERROR );
        }
        goto _out;
    }

    volumeData->pPropertyPageData = pPropertyPageData;

    //
    // Initialize property page items.
    //
    SendDlgItemMessage( HWnd, IDC_DISK, WM_SETTEXT, (WPARAM)NULL,
                        (LPARAM)pPropertyPageData->DiskName );
    SendDlgItemMessage( HWnd, IDC_STATUS, WM_SETTEXT, (WPARAM)NULL,
                        (LPARAM)pPropertyPageData->DiskStatus );
    SendDlgItemMessage( HWnd, IDC_TYPE, WM_SETTEXT, (WPARAM)NULL,
                        (LPARAM)pPropertyPageData->DiskType );
    SendDlgItemMessage( HWnd, IDC_PARTSTYLE, WM_SETTEXT, (WPARAM)NULL,
                        (LPARAM)pPropertyPageData->DiskPartitionStyle );
    SendDlgItemMessage( HWnd, IDC_CAPACITY, WM_SETTEXT, (WPARAM)NULL,
                        (LPARAM)pPropertyPageData->DiskCapacity );
    SendDlgItemMessage( HWnd, IDC_SPACE, WM_SETTEXT, (WPARAM)NULL,
                        (LPARAM)pPropertyPageData->DiskFreeSpace );
    SendDlgItemMessage( HWnd, IDC_RESERVED, WM_SETTEXT, (WPARAM)NULL,
                        (LPARAM)pPropertyPageData->DiskReservedSpace );

    // Set image list
    ListView_SetImageList( hwndVolumeList,
                           pPropertyPageData->ImageList,
                           LVSIL_SMALL);

    //
    // Fill in volume list.
    //
    iCount = 0;
    lvitem.state = 0;
    lvitem.stateMask = 0;
    lvitem.iImage = 1;
    for (i=0; i<pPropertyPageData->VolumeCount; i++)
    {
        int iIndex;

        lvitem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        lvitem.pszText = pPropertyPageData->VolumeArray[i].Label;
        lvitem.iItem = i;
        lvitem.iSubItem = 0;
        lvitem.lParam = (LPARAM)(pPropertyPageData->VolumeArray[i].MountName);
        lvitem.iImage = 1;
        iIndex = ListView_InsertItem( hwndVolumeList, &lvitem );

        ListView_SetItemText( hwndVolumeList, iIndex, 1, 
                              pPropertyPageData->VolumeArray[i].Size );
    }

    ListView_SortItems( hwndVolumeList, SortVolumeList, hwndVolumeList );

    EnableWindow( GetDlgItem(HWnd,IDC_VOLUME_POPULATE), FALSE );

    bResult = TRUE;
_out:
    if ( bLoadedDmdskmgr )
        FreeLibrary( LdmModule );
    return bResult;
}


BOOL
VolumeOnInitDialog(HWND    HWnd,
                   HWND    HWndFocus,
                   LPARAM  LParam)
{
    SP_DEVINFO_LIST_DETAIL_DATA  DeviceInfoSetDetailData;
    HWND              hwndVolumeList;
    LPPROPSHEETPAGE   page = (LPPROPSHEETPAGE) LParam;
    PVOLUME_PAGE_DATA volumeData = (PVOLUME_PAGE_DATA)page->lParam;
    TCHAR             HeadingColumn[ITEM_LENGTH], *pstrTemp;
    LVCOLUMN          lvcolumn;
    RECT              rect;

    volumeData->pPropertyPageData = NULL;

    //
    // Display volume list headings.
    //
    hwndVolumeList = GetDlgItem( HWnd, IDC_VOLUME_LIST );

    HeadingColumn[0] = TEXT('\0');
    LoadString( ModuleInstance, IDS_VOLUME_VOLUME, HeadingColumn, 
                ITEM_LENGTH );
    lvcolumn.mask    = LVCF_TEXT | LVCF_FMT;
    lvcolumn.pszText = HeadingColumn;
    lvcolumn.fmt     = LVCFMT_LEFT;
    lvcolumn.iSubItem= 0;
    ListView_InsertColumn( hwndVolumeList, 0, &lvcolumn );

    HeadingColumn[0] = TEXT('\0');
    LoadString( ModuleInstance, IDS_VOLUME_CAPACITY, HeadingColumn,
                ITEM_LENGTH );
    lvcolumn.mask    = LVCF_TEXT | LVCF_FMT | LVCF_SUBITEM;
    lvcolumn.pszText = HeadingColumn;
    lvcolumn.fmt     = LVCFMT_LEFT;
    lvcolumn.iSubItem= 1;
    ListView_InsertColumn( hwndVolumeList, 1, &lvcolumn );

    //
    // Set column widths.
    //
    GetClientRect( hwndVolumeList, &rect );
    ListView_SetColumnWidth( hwndVolumeList, 0, (int)rect.right*2/3 );
    ListView_SetColumnWidth( hwndVolumeList, 1, (int)rect.right/3 );

    EnableWindow( GetDlgItem(HWnd, IDC_VOLUME_PROPERTY), FALSE );

    //
    // Get machine name.
    //
    DeviceInfoSetDetailData.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
    if ( !SetupDiGetDeviceInfoListDetail( volumeData->DeviceInfoSet,
                                          &DeviceInfoSetDetailData) )
        return FALSE;
    if (DeviceInfoSetDetailData.RemoteMachineHandle)
    {
        volumeData->bIsLocalMachine = FALSE;
        pstrTemp = DeviceInfoSetDetailData.RemoteMachineName;
        while (*pstrTemp==_T('\\')) pstrTemp++;
        lstrcpy( volumeData->MachineName, pstrTemp );
    }
    else
    {
        volumeData->bIsLocalMachine = TRUE;
        volumeData->MachineName[0] = _T('\0');
    }

    //
    // Get physical device instance Id.
    //
    if ( !SetupDiGetDeviceInstanceId( volumeData->DeviceInfoSet,
                                      volumeData->DeviceInfoData,
                                      volumeData->DeviceInstanceId,
                                      sizeof(volumeData->DeviceInstanceId), 
                                      NULL
                                    ) )
        return FALSE;

    SetWindowLongPtr( HWnd, DWLP_USER, (LONG_PTR)volumeData );

    //
    // Hide "Populate" button and populate volume page if this page is 
    // brought up from Disk Management snapin. 
    //
    if (volumeData->bInvokedByDiskmgr)
    {
        ShowWindow(GetDlgItem(HWnd,IDC_VOLUME_POPULATE), SW_HIDE);
        VolumeOnPopulate( HWnd, volumeData );
    }
    
    return TRUE;
}

VOID VolumeOnProperty(HWND HWnd)
{
    HWND hwndVolumeList = GetDlgItem(HWnd, IDC_VOLUME_LIST);
    LVITEM lvitem;
    int iSelItem;
    WCHAR *MountName;

    //
    // Find selected item.
    //
    iSelItem = ListView_GetNextItem(hwndVolumeList, -1, LVNI_SELECTED);
    if (iSelItem==LB_ERR)
        return;

    //
    // Get mount name.
    //
    lvitem.mask = LVIF_PARAM;
    lvitem.iItem = iSelItem;
    lvitem.iSubItem = 0;
    lvitem.lParam = 0;
    ListView_GetItem(hwndVolumeList, &lvitem);

    MountName = (WCHAR *)lvitem.lParam;

    SetFocus(hwndVolumeList);
    ListView_SetItemState( hwndVolumeList, 
                           iSelItem, 
                           LVIS_FOCUSED | LVIS_SELECTED, 
                           LVIS_FOCUSED | LVIS_SELECTED);
    // EnableWindow(GetDlgItem(HWnd,IDC_VOLUME_PROPERTY), TRUE);

    if ( MountName[1]==L':' )
        SHObjectProperties(NULL, SHOP_FILEPATH, MountName, NULL);
    else
        SHObjectProperties(NULL, SHOP_VOLUMEGUID, MountName, NULL);
}

VOID
VolumeOnCommand(HWND    HWnd,
                int     id,
                HWND    HWndCtl,
                UINT    codeNotify)
{
    HCURSOR hOldCursor;
    PVOLUME_PAGE_DATA volumeData = (PVOLUME_PAGE_DATA) GetWindowLongPtr(HWnd,
                                                                  DWLP_USER);
    switch (id) {
    case IDC_VOLUME_POPULATE:
        hOldCursor = SetCursor( LoadCursor(NULL, IDC_WAIT) );
        VolumeOnPopulate(HWnd, volumeData);
        SetCursor( hOldCursor );
        break;

    case IDC_VOLUME_PROPERTY:
        VolumeOnProperty(HWnd);
        break;

    }
}

LRESULT
VolumeOnNotify (HWND    HWnd,
                int     HWndFocus,
                LPNMHDR lpNMHdr)
{
    PVOLUME_PAGE_DATA volumeData = (PVOLUME_PAGE_DATA) GetWindowLongPtr(HWnd,
                                                                   DWLP_USER);
    int iSelItem;
    WCHAR *MountName;

    switch(lpNMHdr->code) {

        case NM_CLICK:
            //
            // Sanity check.
            //
            if (lpNMHdr->idFrom!=IDC_VOLUME_LIST)
                break;

            //
            // Don't do volume property on remote machine.
            //
            if (!volumeData->bIsLocalMachine)
                break;

            iSelItem = ListView_GetNextItem(lpNMHdr->hwndFrom, 
                                            -1, LVNI_SELECTED);
            if (iSelItem == LB_ERR)
                EnableWindow(GetDlgItem(HWnd, IDC_VOLUME_PROPERTY), FALSE);
            else {
                // enable only if item has a mount name
                LVITEM lvitem;
                lvitem.mask = LVIF_PARAM;
                lvitem.iItem = iSelItem;
                lvitem.iSubItem = 0;
                lvitem.lParam = 0;

                ListView_GetItem(GetDlgItem(HWnd, IDC_VOLUME_LIST), &lvitem);
                MountName = (WCHAR *)lvitem.lParam;

                if (MountName)
                    EnableWindow(GetDlgItem(HWnd, IDC_VOLUME_PROPERTY), TRUE);
                else
                    EnableWindow(GetDlgItem(HWnd, IDC_VOLUME_PROPERTY), FALSE);
            }
            break;
    }
    return 0;
}

BOOL
VolumeContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
    WinHelp(HwndControl,
            _T("diskmgmt.hlp"),
            HELP_CONTEXTMENU,
            (ULONG_PTR) VolumeHelpIDs);

    return FALSE;
}

void
VolumeHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    )
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) HelpInfo->hItemHandle,
                _T("diskmgmt.hlp"),
                HELP_WM_HELP,
                (ULONG_PTR) VolumeHelpIDs);
    }
}

void 
VolumeOnDestroy(HWND HWnd)
{
    PVOLUME_PAGE_DATA volumeData = (PVOLUME_PAGE_DATA) GetWindowLongPtr(HWnd,
                                                                   DWLP_USER);
    PPROPERTY_PAGE_DATA pPropertyPageData = NULL;
    int  i;

    //
    // release data memory
    //
    if (volumeData->pPropertyPageData)
    {
        pPropertyPageData = volumeData->pPropertyPageData;
        for (i=0; i<pPropertyPageData->VolumeCount; i++ )
        {
            if (pPropertyPageData->VolumeArray[i].MountName)
                HeapFree( GetProcessHeap(), 0, 
                    pPropertyPageData->VolumeArray[i].MountName);
        }

        HeapFree( GetProcessHeap(), 0, pPropertyPageData );
    }
}

INT_PTR
VolumeDialogProc(HWND hWnd,
                 UINT Message,
                 WPARAM wParam,
                 LPARAM lParam)
{
    switch(Message)
    {
        HANDLE_MSG(hWnd, WM_INITDIALOG,     VolumeOnInitDialog);
        HANDLE_MSG(hWnd, WM_COMMAND,        VolumeOnCommand);
        HANDLE_MSG(hWnd, WM_NOTIFY,         VolumeOnNotify);

    case WM_CONTEXTMENU:
        return VolumeContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        VolumeHelp(hWnd, (LPHELPINFO) lParam);
        break;

    case WM_DESTROY:
        VolumeOnDestroy(hWnd);
        break;
    }
    return FALSE;
}

BOOL
VolumeDialogCallback(
    HWND HWnd,
    UINT Message,
    LPPROPSHEETPAGE Page
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\proppage\resource.h ===
/*++

Copyright (c) Microsoft Corporation, 2000

Module Name :

    resource.h

Abstract :

    Include file to be used by proppage.rc

Revision History :

--*/

#define IDS_IDE_PIO_ONLY                1
#define IDS_IDE_DMA                     2
#define IDS_IDE_AUTO_DETECT             3
#define IDS_IDE_NONE                    4
#define IDS_ADVANCED                    6
#define IDS_IDE_SAVE_ERROR              7
#define IDS_IDE_SAVE_ERROR_TITLE        8
#define IDS_VOLUME_VOLUME               9
#define IDS_VOLUME_CAPACITY             10
#define IDS_DISK_INFO_NOT_FOUND         12
#define IDS_DISK_INFO_NOT_FOUND_TITLE   13
#define ID_IDE_PROPPAGE                 104
#define ID_DISK_PROPPAGE                106
#define ID_SCSI_PROPPAGE                107
#define ID_STORAGE_PROPPAGE             108
#define ID_DVD_PROPPAGE                 109
#define ID_VOLUME_PROPPAGE              110
#define IDB_DISK                        113
#define ID_CDROM_PROPPAGE               114
#define IDD_VOLUME                      115
#define IDC_CAPACITY                    290
#define IDC_VOLUME_LIST                 306
#define IDC_DRV_PIE                     1001
#define IDC_MASTER_XFER_MODE            1003
#define IDC_SLAVE_XFER_MODE             1004
#define IDC_MASTER_DEVICE_TYPE          1007
#define IDC_SLAVE_DEVICE_TYPE           1008
#define IDC_DVD_COUNTRY_LIST            1009
#define IDC_NEW_REGION                  1011
#define IDC_CURRENT_REGION              1013
#define IDC_CHANGE_TEXT                 1014
#define IDC_DVD_HELP                    1015
#define IDC_MASTER_CURRENT_XFER_MODE    1016
#define IDC_SLAVE_CURRENT_XFER_MODE     1017
#define IDC_SCSI_TAGGED_QUEUING         1022
#define IDC_SCSI_SYNCHONOUS_TX          1023
#define IDC_SCSI_LUN                    1026
#define IDC_SCSI_LUN2                   1027
#define IDC_SCSI_LUN3                   1028
#define IDC_CDROM_REDBOOK_ENABLE        1033
#define IDC_CDROM_REDBOOK_DISABLE       1034
#define IDC_CDROM_IS_DRIVE_GOOD         1035
#define IDC_VOLUME_DISKPERF_ENABLE      1036
#define IDC_DVD_CAUTION                 1037
#define IDC_DVD_CHANGE_HELP             1038
#define IDC_PIO_MODE_STRING             1050
#define IDC_DMA_MODE_STRING             1051
#define IDC_UDMA_MODE_STRING            1052
#define IDC_NO_MODE_STRING              1053
#define IDC_DISK                        1071
#define IDC_TYPE                        1072
#define IDC_SPACE                       1073
#define IDC_STATUS                      1074
#define IDC_RESERVED                    1075
#define IDC_PARTSTYLE                   1076
#define IDC_VOLUME_PROPERTY             1090
#define IDC_VOLUME_POPULATE             1091
#define IDC_DISK_STATIC                 1139
#define IDC_TYPE_STATIC                 1140
#define IDC_STATUS_STATIC               1141
#define IDC_SPACE_STATIC                1142
#define IDC_CAPACITY_STATIC             1143
#define IDC_RESERVED_STATIC             1144
#define IDC_PARTSTYLE_STATIC            1145
#define IDC_VOLUMELIST_STATIC           1147
#define IDC_DIV1_STATIC                 1186
#define DVD_REGION1_NAME                2000
#define DVD_REGION2_NAME                2001
#define DVD_REGION3_NAME                2002
#define DVD_REGION4_NAME                2003
#define DVD_REGION5_NAME                2004
#define DVD_REGION6_NAME                2005
#define DVD_REGION7_NAME                2006
#define DVD_REGION8_NAME                2007
#define DVD_NOREGION_NAME               2008
#define DVD_SET_RPC_CONFIRM_TITLE       2010
#define DVD_SET_RPC_CONFIRM             2011
#define DVD_SET_RPC_CONFIRM_LAST_CHANCE 2012
#define DVD_SET_RPC_ERROR_TITLE         2013
#define DVD_SET_RPC_ERROR               2014
#define DVD_HELP                        2015
#define DVD_CHANGE_TEXT                 2016
#define DVD_CAUTION                     2017
#define DVD_CHANGE_HELP                 2018

#define REDBOOK_UNKNOWN_DRIVE_CONFIRM   3000
#define REDBOOK_UNKNOWN_DRIVE_CONFIRM_TITLE 3001
#define IDC_MWDMA_MODE2_STRING          3002
#define IDC_MWDMA_MODE1_STRING          3003
#define IDC_SWDMA_MODE2_STRING          3004
#define IDC_UDMA_MODE0_STRING           3005
#define IDC_UDMA_MODE1_STRING           3006
#define IDC_UDMA_MODE2_STRING           3007
#define IDC_UDMA_MODE3_STRING           3008
#define IDC_UDMA_MODE4_STRING           3009
#define IDC_UDMA_MODE5_STRING           3010

//
// Recoding region numbers to the 5000 block.
// (2000 == win2k, 3000 = sp1. )

//
// numbers 2100 - 2600 and 4100 - 4600 are reserved due
// to previous use and MUI's inability to update resouces
// for service packs:
// Region numbers had to be recoded to avoid MUI.dll mixup
//
// This is being done to make it very obvious to the MUI folks
// that the region names have been changed (again).
//

#define DVD_REGION1_00                  3100
#define DVD_REGION1_01                  3101
#define DVD_REGION1_02                  3102
#define DVD_REGION1_03                  3103
#define DVD_REGION1_04                  3104
#define DVD_REGION1_05                  3105
#define DVD_REGION1_06                  3106
#define DVD_REGION1_07                  3107
#define DVD_MAX_REGION1                    8

#define DVD_REGION2_00                  3200
#define DVD_REGION2_01                  3201
#define DVD_REGION2_02                  3202
#define DVD_REGION2_03                  3203
#define DVD_REGION2_04                  3204
#define DVD_REGION2_05                  3205
#define DVD_REGION2_06                  3206
#define DVD_REGION2_07                  3207
#define DVD_REGION2_08                  3208
#define DVD_REGION2_09                  3209
#define DVD_REGION2_10                  3210
#define DVD_REGION2_11                  3211
#define DVD_REGION2_12                  3212
#define DVD_REGION2_13                  3213
#define DVD_REGION2_14                  3214
#define DVD_REGION2_15                  3215
#define DVD_REGION2_16                  3216
#define DVD_REGION2_17                  3217
#define DVD_REGION2_18                  3218
#define DVD_REGION2_19                  3219
#define DVD_REGION2_20                  3220
#define DVD_REGION2_21                  3221
#define DVD_REGION2_22                  3222
#define DVD_REGION2_23                  3223
#define DVD_REGION2_24                  3224
#define DVD_REGION2_25                  3225
#define DVD_REGION2_26                  3226
#define DVD_REGION2_27                  3227
#define DVD_REGION2_28                  3228
#define DVD_REGION2_29                  3229
#define DVD_REGION2_30                  3230
#define DVD_REGION2_31                  3231
#define DVD_REGION2_32                  3232
#define DVD_REGION2_33                  3233
#define DVD_REGION2_34                  3234
#define DVD_REGION2_35                  3235
#define DVD_REGION2_36                  3236
#define DVD_REGION2_37                  3237
#define DVD_REGION2_38                  3238
#define DVD_REGION2_39                  3239
#define DVD_REGION2_40                  3240
#define DVD_REGION2_41                  3241
#define DVD_REGION2_42                  3242
#define DVD_REGION2_43                  3243
#define DVD_REGION2_44                  3244
#define DVD_REGION2_45                  3245
#define DVD_REGION2_46                  3246
#define DVD_REGION2_47                  3247
#define DVD_REGION2_48                  3248
#define DVD_REGION2_49                  3249
#define DVD_REGION2_50                  3250
#define DVD_REGION2_51                  3251
#define DVD_REGION2_52                  3252
#define DVD_REGION2_53                  3253
#define DVD_REGION2_54                  3254
#define DVD_REGION2_55                  3255
#define DVD_REGION2_56                  3256
#define DVD_REGION2_57                  3257
#define DVD_REGION2_58                  3258
#define DVD_REGION2_59                  3259
#define DVD_REGION2_60                  3260
#define DVD_REGION2_61                  3261
#define DVD_REGION2_62                  3262
#define DVD_REGION2_63                  3263
#define DVD_MAX_REGION2                   64

#define DVD_REGION3_00                  3400
#define DVD_REGION3_01                  3401
#define DVD_REGION3_02                  3402
#define DVD_REGION3_03                  3403
#define DVD_REGION3_04                  3404
#define DVD_REGION3_05                  3405
#define DVD_REGION3_06                  3406
#define DVD_REGION3_07                  3407
#define DVD_REGION3_08                  3408
#define DVD_REGION3_09                  3409
#define DVD_REGION3_10                  3410
#define DVD_REGION3_11                  3411
#define DVD_REGION3_12                  3412
#define DVD_REGION3_13                  3413
#define DVD_REGION3_14                  3414
#define DVD_MAX_REGION3                   15

#define DVD_REGION4_00                  3500
#define DVD_REGION4_01                  3501
#define DVD_REGION4_02                  3502
#define DVD_REGION4_03                  3503
#define DVD_REGION4_04                  3504
#define DVD_REGION4_05                  3505
#define DVD_REGION4_06                  3506
#define DVD_REGION4_07                  3507
#define DVD_REGION4_08                  3508
#define DVD_REGION4_09                  3509
#define DVD_REGION4_10                  3510
#define DVD_REGION4_11                  3511
#define DVD_REGION4_12                  3512
#define DVD_REGION4_13                  3513
#define DVD_REGION4_14                  3514
#define DVD_REGION4_15                  3515
#define DVD_REGION4_16                  3516
#define DVD_REGION4_17                  3517
#define DVD_REGION4_18                  3518
#define DVD_REGION4_19                  3519
#define DVD_REGION4_20                  3520
#define DVD_REGION4_21                  3521
#define DVD_REGION4_22                  3522
#define DVD_REGION4_23                  3523
#define DVD_REGION4_24                  3524
#define DVD_REGION4_25                  3525
#define DVD_REGION4_26                  3526
#define DVD_REGION4_27                  3527
#define DVD_REGION4_28                  3528
#define DVD_REGION4_29                  3529
#define DVD_REGION4_30                  3530
#define DVD_REGION4_31                  3531
#define DVD_REGION4_32                  3532
#define DVD_REGION4_33                  3533
#define DVD_REGION4_34                  3534
#define DVD_REGION4_35                  3535
#define DVD_REGION4_36                  3536
#define DVD_REGION4_37                  3537
#define DVD_REGION4_38                  3538
#define DVD_REGION4_39                  3539
#define DVD_REGION4_40                  3540
#define DVD_REGION4_41                  3541
#define DVD_REGION4_42                  3542
#define DVD_REGION4_43                  3543
#define DVD_REGION4_44                  3544
#define DVD_REGION4_45                  3545
#define DVD_REGION4_46                  3546
#define DVD_REGION4_47                  3547
#define DVD_REGION4_48                  3548
#define DVD_REGION4_49                  3549
#define DVD_REGION4_50                  3550
#define DVD_REGION4_51                  3551
#define DVD_REGION4_52                  3552
#define DVD_REGION4_53                  3553
#define DVD_REGION4_54                  3554
#define DVD_REGION4_55                  3555
#define DVD_REGION4_56                  3556
#define DVD_REGION4_57                  3557
#define DVD_REGION4_58                  3558
#define DVD_REGION4_59                  3559
#define DVD_REGION4_60                  3560
#define DVD_REGION4_61                  3561
#define DVD_REGION4_62                  3562
#define DVD_REGION4_63                  3563
#define DVD_REGION4_64                  3564
#define DVD_REGION4_65                  3565
#define DVD_REGION4_66                  3566
#define DVD_REGION4_67                  3567
#define DVD_REGION4_68                  3568
#define DVD_REGION4_69                  3569
#define DVD_REGION4_70                  3570
#define DVD_REGION4_71                  3571
#define DVD_REGION4_72                  3572
#define DVD_MAX_REGION4                   73


#define DVD_REGION5_00                  3700
#define DVD_REGION5_01                  3701
#define DVD_REGION5_02                  3702
#define DVD_REGION5_03                  3703
#define DVD_REGION5_04                  3704
#define DVD_REGION5_05                  3705
#define DVD_REGION5_06                  3706
#define DVD_REGION5_07                  3707
#define DVD_REGION5_08                  3708
#define DVD_REGION5_09                  3709
#define DVD_REGION5_10                  3710
#define DVD_REGION5_11                  3711
#define DVD_REGION5_12                  3712
#define DVD_REGION5_13                  3713
#define DVD_REGION5_14                  3714
#define DVD_REGION5_15                  3715
#define DVD_REGION5_16                  3716
#define DVD_REGION5_17                  3717
#define DVD_REGION5_18                  3718
#define DVD_REGION5_19                  3719
#define DVD_REGION5_20                  3720
#define DVD_REGION5_21                  3721
#define DVD_REGION5_22                  3722
#define DVD_REGION5_23                  3723
#define DVD_REGION5_24                  3724
#define DVD_REGION5_25                  3725
#define DVD_REGION5_26                  3726
#define DVD_REGION5_27                  3727
#define DVD_REGION5_28                  3728
#define DVD_REGION5_29                  3729
#define DVD_REGION5_30                  3730
#define DVD_REGION5_31                  3731
#define DVD_REGION5_32                  3732
#define DVD_REGION5_33                  3733
#define DVD_REGION5_34                  3734
#define DVD_REGION5_35                  3735
#define DVD_REGION5_36                  3736
#define DVD_REGION5_37                  3737
#define DVD_REGION5_38                  3738
#define DVD_REGION5_39                  3739
#define DVD_REGION5_40                  3740
#define DVD_REGION5_41                  3741
#define DVD_REGION5_42                  3742
#define DVD_REGION5_43                  3743
#define DVD_REGION5_44                  3744
#define DVD_REGION5_45                  3745
#define DVD_REGION5_46                  3746
#define DVD_REGION5_47                  3747
#define DVD_REGION5_48                  3748
#define DVD_REGION5_49                  3749
#define DVD_REGION5_50                  3750
#define DVD_REGION5_51                  3751
#define DVD_REGION5_52                  3752
#define DVD_REGION5_53                  3753
#define DVD_REGION5_54                  3754
#define DVD_REGION5_55                  3755
#define DVD_REGION5_56                  3756
#define DVD_REGION5_57                  3757
#define DVD_REGION5_58                  3758
#define DVD_REGION5_59                  3759
#define DVD_REGION5_60                  3760
#define DVD_REGION5_61                  3761
#define DVD_REGION5_62                  3762
#define DVD_REGION5_63                  3763
#define DVD_REGION5_64                  3764
#define DVD_REGION5_65                  3765
#define DVD_REGION5_66                  3766
#define DVD_REGION5_67                  3767
#define DVD_REGION5_68                  3768
#define DVD_REGION5_69                  3769
#define DVD_REGION5_70                  3770
#define DVD_REGION5_71                  3771
#define DVD_REGION5_72                  3772
#define DVD_REGION5_73                  3773
#define DVD_REGION5_74                  3774
#define DVD_REGION5_75                  3775
#define DVD_REGION5_76                  3776
#define DVD_REGION5_77                  3777
#define DVD_MAX_REGION5                   78

#define DVD_REGION6_00                  3900
#define DVD_MAX_REGION6                    1

#define MAX_REGIONS                        6

#define IDC_DISK_POLICY_GROUP               5400
#define IDC_DISK_POLICY_SURPRISE            5401
#define IDC_DISK_POLICY_SURPRISE_MESG       5402
#define IDC_DISK_POLICY_ORDERLY             5403
#define IDC_DISK_POLICY_ORDERLY_MESG        5404
#define IDC_DISK_POLICY_ORDERLY_MSGD        5405
#define IDC_DISK_POLICY_WRITE_CACHE         5406
#define IDC_DISK_POLICY_WRITE_CACHE_ICON    5407
#define IDC_DISK_POLICY_WRITE_CACHE_MESG    5408
#define IDS_DISK_POLICY_WRITE_CACHE_MSG1    5409
#define IDS_DISK_POLICY_WRITE_CACHE_MSG2    5410
#define IDC_DISK_POLICY_DEFAULT             5411

#define IDS_DISK_POLICY_HOTPLUG             5601
#define IDI_DISK_POLICY_WARNING             5602
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ramdisk\debug.h ===
#ifndef _DEBUG_H_
#define _DEBUG_H_

#if DBG

#define DBG_NONE        0x00000000
#define DBG_INIT        0x00000001
#define DBG_READWRITE   0x00000002
#define DBG_POOL        0x00000004
#define DBG_IOCTL       0x00000008
#define DBG_PNP         0x00000010
#define DBG_POWER       0x00000020
#define DBG_SRB         0x00000040
#define DBG_THREAD      0x00000080
#define DBG_WINDOW      0x00000100
#define DBG_ALL         0x7FFFFFFF

#define DBG_BREAK_ON_UNRECOGNIZED_IOCTL 0x80000000

#define DBG_ERROR       0x00000001
#define DBG_NOTIFY      0x00000002
#define DBG_WARN        0x00000003
#define DBG_INFO        0x00000004
#define DBG_VERBOSE     0x00000005
#define DBG_PAINFUL     0x00000006

extern ULONG BreakOnEntry;
extern ULONG DebugComponents;
extern ULONG DebugLevel;

#define DEFAULT_BREAK_ON_ENTRY FALSE
#define DEFAULT_DEBUG_LEVEL DBG_ERROR
#define DEFAULT_DEBUG_COMPONENTS DBG_ALL

#ifndef DBG_HEADER
#define DBG_HEADER  "RAMDISK: "
#endif

#define DBGPRINT( _component, _level, _fmt ) {                                      \
    if ( ((DebugComponents & (_component)) != 0) && ((_level) <= DebugLevel) ) {    \
        KdPrint(( "%s", DBG_HEADER ));                                              \
        KdPrint( _fmt );                                                            \
    }                                                                               \
}

#define UNRECOGNIZED_IOCTL_BREAK {                                      \
    if ( (DebugComponents & DBG_BREAK_ON_UNRECOGNIZED_IOCTL) != 0 ) {   \
        ASSERT( FALSE );                                                \
    }                                                                   \
}

#else

#define DBGPRINT( _component, _level, _fmt )

#define UNRECOGNIZED_IOCTL_BREAK

#endif // DBG

#if DBG
#define POOL_DBG 1
#endif

#if !defined(POOL_DBG)

#define ALLOCATE_POOL( _type, _size, _private ) ExAllocatePoolWithTag( (_type), (_size), RAMDISK_TAG_GENERAL )
#define FREE_POOL( _addr, _private ) ExFreePool( (_addr) )

#else

VOID
RamdiskInitializePoolDebug (
    VOID
    );

PVOID
RamdiskAllocatePoolWithTag (
    POOL_TYPE PoolType,
    SIZE_T Size,
    ULONG Tag,
    LOGICAL Private,
    PCHAR File,
    ULONG Line
    );

VOID
RamdiskFreePool (
    PVOID Address,
    LOGICAL Private,
    PCHAR File,
    ULONG Line
    );

#define ALLOCATE_POOL( _type, _size, _private ) \
    RamdiskAllocatePoolWithTag(                 \
        (_type),                                \
        (_size),                                \
        RAMDISK_TAG_GENERAL,                    \
        (_private),                             \
        __FILE__,                               \
        __LINE__ )

#define FREE_POOL( _addr, _private ) RamdiskFreePool( (_addr), (_private), __FILE__, __LINE__ )

#endif

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ramdisk\precomp.h ===
#define _NTDRIVER_

#include <ntosp.h>
#include <zwapi.h>
#include <mountdev.h>

#include <stdio.h>
#include <string.h>

#include <ntdddisk.h>
#include <ntddscsi.h>
#include <ntddvol.h>
#include <ntddft.h>
#include <ntddsnap.h>
#include <scsi.h>

#include <ntddramd.h>
//#include <xip.h>

#include "ramdisk.h"
#include "debug.h"

#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ramdisk\ramdisk.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ramdisk.h

Abstract:

    This file includes extension declaration for
    the RAM Disk driver for Whistler.

Author:

    Chuck Lenzmeier (chuckl) 2001

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

//
// Pool allocation tag.
//
// ISSUE: Add this to pooltags.txt.
//

#define RAMDISK_TAG_GENERAL 'dmaR'

//
// I/O completion macro. Set the IoStatus field of the IRP and complete it.
//
// Note: IO_NO_INCREMENT is used to complete the IRP. If you want an
// increment (such as IO_DISK_INCREMENT), do it manually.
//

#define COMPLETE_REQUEST( _status, _information, _irp ) {   \
    ASSERT( (_irp) != NULL );                               \
    ASSERT( KeGetCurrentIrql() <= DISPATCH_LEVEL );         \
    _irp->IoStatus.Status = (_status);                      \
    _irp->IoStatus.Information = (_information);            \
    IoCompleteRequest( (_irp), IO_NO_INCREMENT );           \
}

//
// Types of devices serviced by this driver. BusFdo is the bus enumeration
// FDO. DiskPdo is a RAM disk device PDO.
//

typedef enum {
    RamdiskDeviceTypeBusFdo,
    RamdiskDeviceTypeDiskPdo
} RAMDISK_DEVICE_TYPE;

//
// States that a device can be in.
//

typedef enum {
    RamdiskDeviceStateStopped,
    RamdiskDeviceStateWorking,
    RamdiskDeviceStatePendingStop,
    RamdiskDeviceStatePendingRemove,
    RamdiskDeviceStateSurpriseRemoved,
    RamdiskDeviceStateRemoved,
    RamdiskDeviceStateRemovedAndNotReported,
    RamdiskDeviceStateDeleted,
    RamdiskDeviceStateMaximum
} RAMDISK_DEVICE_STATE;

//
// Bits for the DISK_EXTENSION.Status field.
//

#define RAMDISK_STATUS_PREVENT_REMOVE   0x00000001
#define RAMDISK_STATUS_CLAIMED          0x00000002

//
// Saved path to the driver's registry key.
//

extern UNICODE_STRING DriverRegistryPath;

//
// Should RAM disks be marked as removable? TRUE makes the hotplug applet play
// a sound when RAM disks appear and disappear. FALSE (the default) keeps it
// quiet.
//

extern BOOLEAN MarkRamdisksAsRemovable;

#if SUPPORT_DISK_NUMBERS

//
// Disk numbering. The disk number is only maintained so that it can be
// returned from IOCTL_STORAGE_GET_DEVICE_NUMBER.
//

#define MINIMUM_DISK_NUMBERS_BITMAP_SIZE  64
#define DEFAULT_DISK_NUMBERS_BITMAP_SIZE 256
#define MAXIMUM_DISK_NUMBERS_BITMAP_SIZE (64 * 1024)

extern ULONG DiskNumbersBitmapSize;

#endif // SUPPORT_DISK_NUMBERS

//
// Disk image windowing.
//

#define MINIMUM_MINIMUM_VIEW_COUNT   2
#define MAXIMUM_MINIMUM_VIEW_COUNT MAXIMUM_MAXIMUM_VIEW_COUNT

#define DEFAULT_DEFAULT_VIEW_COUNT  16
#define MAXIMUM_DEFAULT_VIEW_COUNT MAXIMUM_MAXIMUM_VIEW_COUNT

#define DEFAULT_MAXIMUM_VIEW_COUNT  64
#define MAXIMUM_MAXIMUM_VIEW_COUNT 256

#define MINIMUM_MINIMUM_VIEW_LENGTH (64 * 1024)
#define MAXIMUM_MINIMUM_VIEW_LENGTH MAXIMUM_MAXIMUM_VIEW_LENGTH

#define DEFAULT_DEFAULT_VIEW_LENGTH (  1 * 1024 * 1024)
#define MAXIMUM_DEFAULT_VIEW_LENGTH MAXIMUM_MAXIMUM_VIEW_LENGTH

#define DEFAULT_MAXIMUM_VIEW_LENGTH (256 * 1024 * 1024)
#define MAXIMUM_MAXIMUM_VIEW_LENGTH (  1 * 1024 * 1024 * 1024)

#define MINIMUM_MAXIMUM_PER_DISK_VIEW_LENGTH ( 16 * 1024 * 1024)
#define DEFAULT_MAXIMUM_PER_DISK_VIEW_LENGTH (256 * 1024 * 1024)
#define MAXIMUM_MAXIMUM_PER_DISK_VIEW_LENGTH MAXULONG

extern ULONG MinimumViewCount;
extern ULONG DefaultViewCount;
extern ULONG MaximumViewCount;
extern ULONG MinimumViewLength;
extern ULONG DefaultViewLength;
extern ULONG MaximumViewLength;
extern ULONG MaximumPerDiskViewLength;

typedef struct _VIEW {

    //
    // Views are kept in two lists.
    //
    // The by-offset list is sorted in ascending order by the base offset of
    // the view. (Unmapped views have offset and length both 0 and are always
    // at the front of the by-offset list.)
    //
    // The MRU list is sorted with the most recently used views at the front.
    // When we need to unmap a view and remap a new view, we take a free view
    // from the back of the MRU list.
    //

    LIST_ENTRY ByOffsetListEntry;
    LIST_ENTRY ByMruListEntry;

    //
    // Address is the virtual address at which the view is mapped.
    //
    // Offset is the offset from the start of the file that backs the RAM disk.
    //
    // Length if the length of the view. Normally this is the same as the
    // ViewLength field in the disk extension, but it can be less for the
    // view at the end of the disk image. (If we permanently map the first
    // few pages of the disk image [to keep the boot sector mapped], then the
    // first view will also be "short".
    //

    PUCHAR Address;

    ULONGLONG Offset;
    ULONG Length;

    //
    // ReferenceCount indicates how many active operations are using the view.
    // When ReferenceCount is 0, the view is a candidate for replacement.
    //
    // Permanent indicates whether the view is to remain mapped permanently.
    // If Permanent is TRUE, the ReferenceCount field is not used. (Permanent
    // is intended to be used to keep a view permanently mapped to the boot
    // sector. Currently we don't implement any permanent views.)
    //

    ULONG ReferenceCount;

    BOOLEAN Permanent;

} VIEW, *PVIEW;

//
// The device extensions for BusFdo and DiskPdo devices have a common header.
//

typedef struct  _COMMON_EXTENSION {

    //
    // Device type and state.
    //

    RAMDISK_DEVICE_TYPE DeviceType;
    RAMDISK_DEVICE_STATE DeviceState;

    //
    // Fdo points to the FDO for the device. For the BusFdo, Fdo is the device
    // that we created for the BusFdo (see RamdiskAddDevice()). For a DiskPdo,
    // Fdo is the BusFdo.
    //
    // Pdo points to the PDO for the device. For the BusFdo, Pdo is the PDO
    // that was passed in to RamdiskAddDevice(). For a DiskPdo, Pdo is the
    // device that we created for the DiskPdo (see RamdiskCreateDiskDevice()).
    //
    // LowerDeviceObject points to the device object below this device in the
    // device stack. For the BusFdo, LowerDeviceObject is returned by the call
    // to IoAttachDeviceToDeviceStack() in RamdiskAddDevice(). For a DiskPdo,
    // LowerDeviceObject is the BusFdo.
    //

    PDEVICE_OBJECT Fdo;
    PDEVICE_OBJECT Pdo;
    PDEVICE_OBJECT LowerDeviceObject;

    //
    // RemoveLock prevents removal of a device while it is busy.
    //

    IO_REMOVE_LOCK RemoveLock;

    //
    // InterfaceString is returned by IoRegisterDeviceInterface().
    //

    UNICODE_STRING InterfaceString;

    //
    // DeviceName is the name of the device.
    //

    UNICODE_STRING DeviceName;

    //
    // Mutex controls access to various fields in the device extension.
    //

    FAST_MUTEX Mutex;

} COMMON_EXTENSION, *PCOMMON_EXTENSION;

//
// The BusFdo has the following device extension. (Must start with a
// COMMON_EXTENSION!)
//

typedef struct  _BUS_EXTENSION {

    COMMON_EXTENSION ;

#if SUPPORT_DISK_NUMBERS

    //
    // DiskNumbersBitmap is a bitmap indicating which disk numbers are in
    // use by active RAM disks. Bit number 0 of the bitmap corresponds to
    // disk number 1.
    //

    RTL_BITMAP DiskNumbersBitmap;
    PULONG DiskNumbersBitmapBuffer;

#endif // SUPPORT_DISK_NUMBERS

    //
    // DiskPdoList is a list of all existing RAM disk devices.
    //

    LIST_ENTRY DiskPdoList;

} BUS_EXTENSION, *PBUS_EXTENSION;

//
// Each DiskPdo has the following device extension. (Must start with a
// COMMON_EXTENSION!)
//

typedef struct  _DISK_EXTENSION {

    COMMON_EXTENSION ;

    //
    // DiskPdoListEntry links the DiskPdo into the BusFdo's DiskPdoList.
    //

    LIST_ENTRY DiskPdoListEntry;

    //
    // DiskGuid is the GUID assigned to the disk by the creator.
    // DiskGuidFormatted is the GUID in printable format.
    //

    GUID DiskGuid;
    UNICODE_STRING DiskGuidFormatted;

    //
    // DosSymLink is the DosDevices name associated with the device. This is
    // only valid if Options.NoDosDevice is FALSE.
    //

    UNICODE_STRING DosSymLink;

#if SUPPORT_DISK_NUMBERS

    //
    // DiskNumber is the number of the disk.
    //

    ULONG DiskNumber;

#endif // SUPPORT_DISK_NUMBERS

    //
    // DiskType indicates what type of disk is being emulated. (See
    // RAMDISK_TYPE_xxx in ramdisku.h.)
    //

    ULONG DiskType;

    //
    // Status indicates whether the disk has been claimed and whether removal
    // is prevented. (See RAMDISK_STATUS_xxx above.)
    //

    ULONG Status;

    //
    // Options specifies various create options for the disk: is it readonly;
    // is it fixed or removable; does it have a drive letter; etc.
    //

    RAMDISK_CREATE_OPTIONS Options;

    //
    // DiskLength is the length of the disk image. DiskOffset is the offset
    // from the start of the backing file or memory block to the actual start
    // of the disk image. (DiskLength does NOT include DiskOffset.)
    //
    // FileRelativeEndOfDisk is the sum of DiskOffset + DiskLength. It is
    // calculated once to avoid recalculating it every time a view is mapped.
    //

    ULONGLONG DiskLength;
    ULONG DiskOffset;

    ULONGLONG FileRelativeEndOfDisk;

    //
    // BasePage indicates the base physical page when DiskType is
    // RAMDISK_TYPE_BOOT_DISK. For file-backed RAM disks, SectionObject
    // is a referenced pointer to the section. For virtual floppies,
    // BaseAddress indicates the base virtual address.
    //

    ULONG_PTR BasePage;
    PVOID SectionObject;
    PVOID BaseAddress;

    //
    // DriveLetter is the drive letter assigned to the boot disk.
    //

    WCHAR DriveLetter;

    //
    // MarkedForDeletion indicates whether user mode has informed us
    // that it is about to delete the device.
    //

    BOOLEAN MarkedForDeletion;

    //
    // Mapped image windowing.
    //
    // ViewCount is the number of views that are available. ViewLength is
    // length of each view.
    //

    ULONG ViewCount;
    ULONG ViewLength;

    //
    // ViewDescriptors points to an array of view descriptors allocated when
    // the disk was created.
    //

    PVIEW ViewDescriptors;

    //
    // ViewsByOffset and ViewsByMru are lists of view descriptors (see the
    // description of the VIEW struct).
    //

    LIST_ENTRY ViewsByOffset;
    LIST_ENTRY ViewsByMru;

    //
    // ViewSemaphore is used to wake up threads that are waiting for a free
    // view (so they can remap a new view). ViewWaiterCount is the number of
    // threads that are currently waiting for a free view. The semaphore is
    // "kicked" by this amount when a view is freed.
    //

    KSEMAPHORE ViewSemaphore;
    ULONG ViewWaiterCount;

    //
    // ISSUE: Do we really need XIP_BOOT_PARAMETERS?
    //

    //XIP_BOOT_PARAMETERS BootParameters;

    //
    // ViewSemaphore is used to wake up threads that are waiting for a free
    // view (so they can remap a new view). ViewWaiterCount is the number of
    //BIOS_PARAMETER_BLOCK BiosParameters;

    //
    // Disk geometry.
    //

    ULONG BytesPerSector;
    ULONG SectorsPerTrack;

    ULONG NumberOfCylinders;
    ULONG TracksPerCylinder;
    ULONG BytesPerCylinder;

    ULONG HiddenSectors;

    //
    // For file-backed RAM disks, FileName is the NT name of the backing file.
    //
        
    WCHAR FileName[1];

} DISK_EXTENSION, *PDISK_EXTENSION;

#if !defined( _UCHAR_DEFINED_ )

#define _UCHAR_DEFINED_

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//
typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src));       \
}

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src));       \
}

#define CopyU2char(Dst,Src) {                                \
    *((UNALIGNED UCHAR2 *)(Dst)) = *((UCHAR2 *)(Src));       \
}

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)((ULONG_PTR)(Src)));       \
}

#define CopyU4char(Dst, Src) {                               \
    *((UNALIGNED UCHAR4 *)(Dst)) = *((UCHAR4 *)(Src));       \
}

#endif // _UCHAR_DEFINED_

#define cOEM    8
#define cLABEL    11
#define cSYSID    8

//
//  Defines the packet and unpacked BPB structs used for extraction of geometry
//  from the boot sector of the ramdisk image
//

typedef struct _PACKED_BIOS_PARAMETER_BLOCK {
    UCHAR  BytesPerSector[2];                       //  offset = 0x000
    UCHAR  SectorsPerCluster[1];                    //  offset = 0x002
    UCHAR  ReservedSectors[2];                      //  offset = 0x003
    UCHAR  Fats[1];                                 //  offset = 0x005
    UCHAR  RootEntries[2];                          //  offset = 0x006
    UCHAR  Sectors[2];                              //  offset = 0x008
    UCHAR  Media[1];                                //  offset = 0x00A
    UCHAR  SectorsPerFat[2];                        //  offset = 0x00B
    UCHAR  SectorsPerTrack[2];                      //  offset = 0x00D
    UCHAR  Heads[2];                                //  offset = 0x00F
    UCHAR  HiddenSectors[4];                        //  offset = 0x011
    UCHAR  LargeSectors[4];                         //  offset = 0x015
    UCHAR  BigSectorsPerFat[4];                     //  offset = 0x019 25
    UCHAR  ExtFlags[2];                             //  offset = 0x01D 29
    UCHAR  FS_Version[2];                           //  offset = 0x01F 31
    UCHAR  RootDirStrtClus[4];                      //  offset = 0x021 33
    UCHAR  FSInfoSec[2];                            //  offset = 0x025 37
    UCHAR  BkUpBootSec[2];                          //  offset = 0x027 39
    UCHAR  Reserved[12];                            //  offset = 0x029 41
} PACKED_BIOS_PARAMETER_BLOCK;                      //  sizeof = 0x035 53

typedef PACKED_BIOS_PARAMETER_BLOCK *PPACKED_BIOS_PARAMETER_BLOCK;

typedef struct BIOS_PARAMETER_BLOCK {
    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  Fats;
    USHORT RootEntries;
    USHORT Sectors;
    UCHAR  Media;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT Heads;
    ULONG  HiddenSectors;
    ULONG  LargeSectors;
    ULONG  BigSectorsPerFat;
    USHORT ExtFlags;                            
    USHORT FS_Version;                          
    ULONG  RootDirStrtClus;                     
    USHORT FSInfoSec;                           
    USHORT BkUpBootSec;  
} BIOS_PARAMETER_BLOCK;
typedef BIOS_PARAMETER_BLOCK *PBIOS_PARAMETER_BLOCK;


//
//	Macro to unpack packed bpb
//
#define UnpackBios(Bios,Pbios) {                                          \
    CopyUchar2(&((Bios)->BytesPerSector),    (Pbios)->BytesPerSector   ); \
    CopyUchar1(&((Bios)->SectorsPerCluster), (Pbios)->SectorsPerCluster); \
    CopyUchar2(&((Bios)->ReservedSectors),   (Pbios)->ReservedSectors  ); \
    CopyUchar1(&((Bios)->Fats),              (Pbios)->Fats             ); \
    CopyUchar2(&((Bios)->RootEntries),       (Pbios)->RootEntries      ); \
    CopyUchar2(&((Bios)->Sectors),           (Pbios)->Sectors          ); \
    CopyUchar1(&((Bios)->Media),             (Pbios)->Media            ); \
    CopyUchar2(&((Bios)->SectorsPerFat),     (Pbios)->SectorsPerFat    ); \
    CopyUchar2(&((Bios)->SectorsPerTrack),   (Pbios)->SectorsPerTrack  ); \
    CopyUchar2(&((Bios)->Heads),             (Pbios)->Heads            ); \
    CopyUchar4(&((Bios)->HiddenSectors),     (Pbios)->HiddenSectors    ); \
    CopyUchar4(&((Bios)->LargeSectors),      (Pbios)->LargeSectors     ); \
}

typedef struct _PACKED_EXTENDED_BIOS_PARAMETER_BLOCK {
    UCHAR  IntelNearJumpCommand[1];
    UCHAR  BootStrapJumpOffset[2];
    UCHAR  OemData[cOEM];
    PACKED_BIOS_PARAMETER_BLOCK Bpb;
    UCHAR   PhysicalDrive[1];           // 0 = removable, 80h = fixed
    UCHAR   CurrentHead[1];             // used for dirty partition info
    UCHAR   Signature[1];               // boot signature
    UCHAR   SerialNumber[4];            // volume serial number
    UCHAR   Label[cLABEL];              // volume label, padded with spaces
    UCHAR   SystemIdText[cSYSID];       // system ID, (e.g. FAT or HPFS)
    UCHAR   StartBootCode;              // first byte of boot code

} PACKED_EXTENDED_BIOS_PARAMETER_BLOCK, *PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK;

//
// Global variables.
//

extern PDEVICE_OBJECT RamdiskBusFdo;

//
// External functions implemented in ioctl.c.
//

NTSTATUS
RamdiskDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskCreateRamDisk (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN AccessCheckOnly
    );

NTSTATUS
RamdiskCreateDiskDevice (
    IN PBUS_EXTENSION BusExtension,
    IN PRAMDISK_CREATE_INPUT CreateInput,
    IN BOOLEAN AccessCheckOnly,
    OUT PDISK_EXTENSION *DiskExtension
    );

NTSTATUS
RamdiskGetDriveLayout (
    PIRP Irp,
    PDISK_EXTENSION DiskExtension
    );

NTSTATUS
RamdiskGetPartitionInfo (
    PIRP Irp,
    PDISK_EXTENSION DiskExtension
    );

NTSTATUS
RamdiskSetPartitionInfo (
    PIRP Irp,
    PDISK_EXTENSION DiskExtension
    );

//
// External functions implemented in pnp.c.
//

NTSTATUS
RamdiskPnp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskAddDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

BOOLEAN
CreateRegistryDisks (
    IN BOOLEAN CheckPresenceOnly
    );

//
// External functions implemented in ramdisk.c.
//

VOID
RamdiskWorkerThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
RamdiskFlushBuffersReal (
    IN PDISK_EXTENSION DiskExtension
    );

//
// External functions implemented in readwrite.c.
//

NTSTATUS
RamdiskReadWrite (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskReadWriteReal (
    IN PIRP Irp,
    IN PDISK_EXTENSION DiskExtension
    );

//
// External functions implemented in scsi.c.
//

NTSTATUS
RamdiskScsi (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskScsiExecuteNone (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PSCSI_REQUEST_BLOCK Srb,
    ULONG ControlCode
    );

NTSTATUS
RamdiskScsiExecuteIo (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PSCSI_REQUEST_BLOCK Srb,
    ULONG ControlCode
    );

//
// External functions implemented in utils.c.
//

NTSTATUS
SendIrpToThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PUCHAR
RamdiskMapPages (
    IN PDISK_EXTENSION DiskExtension,
    IN ULONGLONG Offset,
    IN ULONG RequestedLength,
    OUT PULONG ActualLength
    );

VOID
RamdiskUnmapPages (
    IN PDISK_EXTENSION DiskExtension,
    IN PUCHAR Va,
    IN ULONGLONG Offset,
    IN ULONG Length
    );

NTSTATUS
RamdiskFlushViews (
    IN PDISK_EXTENSION DiskExtension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ramdisk\ioctl.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This file contains RAM disk driver code for processing IOCTLs.

Author:

    Chuck Lenzmeier (ChuckL) 2001

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>

#if !DBG

#define PRINT_CODE( _code )

#else

#define PRINT_CODE( _code )                                             \
    if ( print ) {                                                      \
        DBGPRINT( DBG_IOCTL, DBG_VERBOSE, ("%s", "  " #_code "\n") );    \
    }                                                                   \
    print = FALSE;

#endif

//
// Local functions.
//

NTSTATUS
RamdiskQueryProperty (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

//
// Declare pageable routines.
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, RamdiskDeviceControl )
#pragma alloc_text( PAGE, RamdiskCreateRamDisk )
#pragma alloc_text( PAGE, RamdiskCreateDiskDevice )
#pragma alloc_text( PAGE, RamdiskGetDriveLayout )
#pragma alloc_text( PAGE, RamdiskGetPartitionInfo )
#pragma alloc_text( PAGE, RamdiskSetPartitionInfo )
#pragma alloc_text( PAGE, RamdiskQueryProperty )

#endif // ALLOC_PRAGMA

NTSTATUS
RamdiskDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a device I/O
    control function.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    //PBIOS_PARAMETER_BLOCK bios;
    PCOMMON_EXTENSION commonExtension;
    PBUS_EXTENSION busExtension;
    PDISK_EXTENSION diskExtension;
    PIO_STACK_LOCATION irpSp;
    PRAMDISK_QUERY_INPUT queryInput;
    PRAMDISK_QUERY_OUTPUT queryOutput;
    PRAMDISK_MARK_FOR_DELETION_INPUT markInput;
    PLIST_ENTRY listEntry;
    NTSTATUS status;
    ULONG_PTR info;
    BOOLEAN lockHeld = FALSE;
    BOOLEAN calleeWillComplete = FALSE;

#if DBG
    BOOLEAN print = TRUE;
#endif

    PAGED_CODE();

    //
    // Set up device extension and IRP pointers.
    //

    commonExtension = DeviceObject->DeviceExtension;
    busExtension = DeviceObject->DeviceExtension;
    diskExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // ISSUE: what about BiosParameters?
    //
    //bios = &diskExtension->BiosParameters;

    //
    // Acquire the remove lock. If this fails, fail the I/O.
    //

    status = IoAcquireRemoveLock( &commonExtension->RemoveLock, Irp );

    if ( !NT_SUCCESS(status) ) {

        COMPLETE_REQUEST( status, 0, Irp );
        return status;
    }

    //
    // Indicate that the remove lock is held.
    //

    lockHeld = TRUE;

    //
    // Assume failure.
    //

    status = STATUS_INVALID_DEVICE_REQUEST;
    info = 0;

    //
    // Dispatch based on the device type (bus or disk).
    //

    switch ( commonExtension->DeviceType ) {
    
    case RamdiskDeviceTypeBusFdo:

        //
        // The target is the bus FDO.
        //
        // Dispatch based on the IOCTL code.
        //

        switch ( irpSp->Parameters.DeviceIoControl.IoControlCode ) {
        
        case FSCTL_CREATE_RAM_DISK:

            PRINT_CODE( FSCTL_DISK_CREATE_RAM_DISK );

            //
            // Creation of a RAM disk must be handled in thread context. But
            // before sending it off to the thread, we need to verify that
            // the caller has access to the backing file.
            //

            status = RamdiskCreateRamDisk( DeviceObject, Irp, TRUE );

            if ( NT_SUCCESS(status) ) {

                status = SendIrpToThread( DeviceObject, Irp );
            }

            break;

        case FSCTL_QUERY_RAM_DISK:

            PRINT_CODE( FSCTL_QUERY_RAM_DISK );

            //
            // Lock the disk PDO list and look for a disk with the specified
            // disk GUID.
            //
            // Verify that the input parameter buffer is big enough.
            //
        
            if ( irpSp->Parameters.DeviceIoControl.InputBufferLength <
                                                    sizeof(RAMDISK_QUERY_INPUT) ) {
        
                status = STATUS_INVALID_PARAMETER;

                break;
            }
        
            queryInput = (PRAMDISK_QUERY_INPUT)Irp->AssociatedIrp.SystemBuffer;

            if ( queryInput->Version != sizeof(RAMDISK_QUERY_INPUT) ) {
        
                status = STATUS_INVALID_PARAMETER;

                break;
            }
        
            KeEnterCriticalRegion();
            ExAcquireFastMutex( &busExtension->Mutex );

            diskExtension = NULL;

            for ( listEntry = busExtension->DiskPdoList.Flink;
                  listEntry != &busExtension->DiskPdoList;
                  listEntry = listEntry->Flink ) {

                diskExtension = CONTAINING_RECORD( listEntry, DISK_EXTENSION, DiskPdoListEntry );

                if ( memcmp(
                        &diskExtension->DiskGuid,
                        &queryInput->DiskGuid,
                        sizeof(diskExtension->DiskGuid)
                        ) == 0 ) {

                    break;
                }

                diskExtension = NULL;
            }

            if ( diskExtension == NULL ) {

                //
                // Couldn't find a matching device.
                //

                status = STATUS_NO_SUCH_DEVICE;

            } else {

                //
                // Found a matching device. Return the requested information.
                //

                status = STATUS_SUCCESS;
                info = sizeof(RAMDISK_QUERY_OUTPUT);
                if ( RAMDISK_IS_FILE_BACKED(diskExtension->DiskType) ) {
                    // NB: struct size already includes space for one wchar.
                    info += wcslen(diskExtension->FileName) * sizeof(WCHAR);
                }

                if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength < info ) {
            
                    status = STATUS_BUFFER_TOO_SMALL;
                    info = 0;

                } else {

                    queryOutput = (PRAMDISK_QUERY_OUTPUT)Irp->AssociatedIrp.SystemBuffer;

                    queryOutput->Version = sizeof(RAMDISK_QUERY_OUTPUT);
                    queryOutput->DiskGuid = diskExtension->DiskGuid;
                    queryOutput->DiskType = diskExtension->DiskType;
                    queryOutput->Options = diskExtension->Options;
                    queryOutput->DiskLength = diskExtension->DiskLength;
                    queryOutput->DiskOffset = diskExtension->DiskOffset;
                    queryOutput->ViewCount = diskExtension->ViewCount;
                    queryOutput->ViewLength = diskExtension->ViewLength;

                    if ( diskExtension->DiskType == RAMDISK_TYPE_BOOT_DISK ) {

                        queryOutput->BasePage = diskExtension->BasePage;
                        queryOutput->DriveLetter = diskExtension->DriveLetter;

                    } else if ( diskExtension->DiskType == RAMDISK_TYPE_VIRTUAL_FLOPPY ) {

                        queryOutput->BaseAddress = diskExtension->BaseAddress;

                    } else {

                        size_t remainingLength;
                        HRESULT result;

                        remainingLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
                        remainingLength -= FIELD_OFFSET( RAMDISK_QUERY_OUTPUT, FileName );

                        result = StringCbCopyW(
                                    queryOutput->FileName,
                                    remainingLength,
                                    diskExtension->FileName
                                    );
                        ASSERT( result == S_OK );
                    }
                }
            }
            
            ExReleaseFastMutex( &commonExtension->Mutex );
            KeLeaveCriticalRegion();

            break;

        case FSCTL_MARK_RAM_DISK_FOR_DELETION:

            PRINT_CODE( FSCTL_MARK_RAM_DISK_FOR_DELETION );

            //
            // Lock the disk PDO list and look for a disk with the specified
            // disk GUID.
            //
            // Verify that the input parameter buffer is big enough.
            //
        
            if ( irpSp->Parameters.DeviceIoControl.InputBufferLength <
                                                    sizeof(RAMDISK_MARK_FOR_DELETION_INPUT) ) {
        
                status = STATUS_INVALID_PARAMETER;

                break;
            }
        
            markInput = (PRAMDISK_MARK_FOR_DELETION_INPUT)Irp->AssociatedIrp.SystemBuffer;

            if ( markInput->Version != sizeof(RAMDISK_MARK_FOR_DELETION_INPUT) ) {
        
                status = STATUS_INVALID_PARAMETER;

                break;
            }
        
            KeEnterCriticalRegion();
            ExAcquireFastMutex( &busExtension->Mutex );

            diskExtension = NULL;

            for ( listEntry = busExtension->DiskPdoList.Flink;
                  listEntry != &busExtension->DiskPdoList;
                  listEntry = listEntry->Flink ) {

                diskExtension = CONTAINING_RECORD( listEntry, DISK_EXTENSION, DiskPdoListEntry );

                if ( memcmp(
                        &diskExtension->DiskGuid,
                        &markInput->DiskGuid,
                        sizeof(diskExtension->DiskGuid)
                        ) == 0 ) {

                    break;
                }

                diskExtension = NULL;
            }

            if ( diskExtension == NULL ) {

                //
                // Couldn't find a matching device.
                //

                status = STATUS_NO_SUCH_DEVICE;

            } else {

                //
                // Found a matching device. Mark it for deletion.
                //

                diskExtension->MarkedForDeletion = TRUE;

                status = STATUS_SUCCESS;
            }
            
            ExReleaseFastMutex( &commonExtension->Mutex );
            KeLeaveCriticalRegion();

            break;

        case IOCTL_STORAGE_QUERY_PROPERTY:

            PRINT_CODE( IOCTL_STORAGE_QUERY_PROPERTY );

            //
            // Call RamdiskQueryProperty() to handle the request. This routine
            // releases the lock. It also takes care of IRP completion.
            //

            status = RamdiskQueryProperty( DeviceObject, Irp );

            lockHeld = FALSE;
            calleeWillComplete = TRUE;

            break;

        default:

            //
            // The specified I/O control code is unrecognized by this driver.
            // The I/O status field in the IRP has already been set, so just
            // terminate the switch.
            //
    
            DBGPRINT( DBG_IOCTL, DBG_ERROR, ("Ramdisk:  ERROR:  unrecognized IOCTL %x\n",
                        irpSp->Parameters.DeviceIoControl.IoControlCode) );

            UNRECOGNIZED_IOCTL_BREAK;

            break;
        }

        break;
    
    case RamdiskDeviceTypeDiskPdo:

        //
        // The target is a disk PDO.
        //
        // Dispatch based on the IOCTL code.
        //

        switch ( irpSp->Parameters.DeviceIoControl.IoControlCode ) {
        
        case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:

            PRINT_CODE( IOCTL_MOUNTDEV_QUERY_DEVICE_NAME );

            {
                PMOUNTDEV_NAME mountName;
                ULONG outputLength;

                outputLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

                //
                // The output buffer must be at least big enough to hold the
                // length of the device name.
                //

                if ( outputLength < sizeof(mountName->NameLength) ) {

                    status = STATUS_INVALID_PARAMETER;

                    break;
                }

                //
                // Write the length of the device name into the output buffer.
                // If the buffer is big enough, write the name, too.
                //

                mountName = Irp->AssociatedIrp.SystemBuffer;
                mountName->NameLength = diskExtension->DeviceName.Length;
    
                if ( outputLength < (sizeof(mountName->NameLength) + mountName->NameLength) ) {

                    status = STATUS_BUFFER_OVERFLOW;
                    info = sizeof(mountName->NameLength);

                    break;
                }
    
                RtlCopyMemory(
                    mountName->Name,
                    diskExtension->DeviceName.Buffer,
                    mountName->NameLength
                    );
    
                status = STATUS_SUCCESS;
                info = sizeof(mountName->NameLength) + mountName->NameLength;
            }

            break;

        case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:

            PRINT_CODE( IOCTL_MOUNTDEV_QUERY_UNIQUE_ID );

            {
                PMOUNTDEV_UNIQUE_ID uniqueId;
                ULONG outputLength;
    
                outputLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
    
                //
                // The output buffer must be at least big enough to hold the
                // length of the unique ID.
                //

                if ( outputLength < sizeof(uniqueId->UniqueIdLength) ) {

                    status = STATUS_INVALID_PARAMETER;

                    break;
                }
    
                //
                // Write the length of the unique ID into the output buffer.
                // If the buffer is big enough, write the unique ID, too.
                //

                uniqueId = Irp->AssociatedIrp.SystemBuffer;
                uniqueId->UniqueIdLength = sizeof(diskExtension->DiskGuid);
    
                if ( outputLength <
                        (sizeof(uniqueId->UniqueIdLength) + uniqueId->UniqueIdLength) ) {

                    status = STATUS_BUFFER_OVERFLOW;
                    info = sizeof(uniqueId->UniqueIdLength);

                    break;
                }
    
                RtlCopyMemory(
                    uniqueId->UniqueId,
                    &diskExtension->DiskGuid,
                    uniqueId->UniqueIdLength
                    );
    
                status = STATUS_SUCCESS;
                info = sizeof(uniqueId->UniqueIdLength) + uniqueId->UniqueIdLength;
            }

            break;
    
        case IOCTL_MOUNTDEV_QUERY_STABLE_GUID:

            PRINT_CODE( IOCTL_MOUNTDEV_QUERY_STABLE_GUID );
    
            {
                PMOUNTDEV_STABLE_GUID stableGuid;
                ULONG outputLength;
    
                outputLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
    
                //
                // The output buffer must be at big enough to hold the GUID.
                //

                if ( outputLength < sizeof(MOUNTDEV_STABLE_GUID) ) {

                    status = STATUS_INVALID_PARAMETER;

                    break;
                }
    
                //
                // Write the GUID to the output buffer;
                //

                stableGuid = Irp->AssociatedIrp.SystemBuffer;
                stableGuid->StableGuid = diskExtension->DiskGuid;
    
                status = STATUS_SUCCESS;
                info = sizeof(MOUNTDEV_STABLE_GUID);
            }
            break;
    
        case IOCTL_DISK_GET_MEDIA_TYPES:

            PRINT_CODE( IOCTL_DISK_GET_MEDIA_TYPES );

            // Fall through.

        case IOCTL_STORAGE_GET_MEDIA_TYPES:

            PRINT_CODE( IOCTL_STORAGE_GET_MEDIA_TYPES );

            // Fall through.

        case IOCTL_DISK_GET_DRIVE_GEOMETRY:

            PRINT_CODE( IOCTL_DISK_GET_DRIVE_GEOMETRY );

            //
            // Return the drive geometry for the virtual disk.  Note that
            // we return values which were made up to suit the disk size.
            //
    
            if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(DISK_GEOMETRY) ) {
    
                status = STATUS_INVALID_PARAMETER;
                
            } else {
    
                PDISK_GEOMETRY outputBuffer;

                outputBuffer = (PDISK_GEOMETRY)Irp->AssociatedIrp.SystemBuffer;
    
                outputBuffer->MediaType = diskExtension->Options.Fixed ?
                                                    FixedMedia : RemovableMedia;
                outputBuffer->Cylinders.QuadPart = diskExtension->NumberOfCylinders;
                outputBuffer->TracksPerCylinder = diskExtension->TracksPerCylinder;
                outputBuffer->SectorsPerTrack = diskExtension->SectorsPerTrack;
                outputBuffer->BytesPerSector = diskExtension->BytesPerSector;

                DBGPRINT( DBG_IOCTL, DBG_PAINFUL,
                            ("    MediaType    = %x\n", outputBuffer->MediaType) );
                DBGPRINT( DBG_IOCTL, DBG_VERBOSE,
                            ("    Cylinders    = %x\n", outputBuffer->Cylinders) );
                DBGPRINT( DBG_IOCTL, DBG_VERBOSE,
                            ("    Tracks/cyl   = %x\n", outputBuffer->TracksPerCylinder) );
                DBGPRINT( DBG_IOCTL, DBG_VERBOSE,
                            ("    Sector/track = %x\n", outputBuffer->SectorsPerTrack) );
                DBGPRINT( DBG_IOCTL, DBG_VERBOSE,
                            ("    Bytes/sector = %x\n", outputBuffer->BytesPerSector) );
    
                status = STATUS_SUCCESS;
                info = sizeof( DISK_GEOMETRY );
            }

            break;
    
        case IOCTL_DISK_IS_WRITABLE:

            PRINT_CODE( IOCTL_DISK_IS_WRITABLE );

            //
            // Indicate whether the disk is write protected.
            //

            status = diskExtension->Options.Readonly ?
                        STATUS_MEDIA_WRITE_PROTECTED : STATUS_SUCCESS;

            break;
    
        case IOCTL_DISK_VERIFY:

            PRINT_CODE( IOCTL_DISK_VERIFY );

            {
                PVERIFY_INFORMATION	verifyInformation;
                ULONG inputLength;
                ULONGLONG ioOffset;
                ULONG ioLength;
    
                inputLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;
    
                if ( inputLength < sizeof(VERIFY_INFORMATION) ) {

                    status = STATUS_INVALID_PARAMETER;

                    break;
                }
    
                verifyInformation = Irp->AssociatedIrp.SystemBuffer;
    
                ioOffset = verifyInformation->StartingOffset.QuadPart;
                ioLength = verifyInformation->Length;

                //
                // If the requested length is 0, we have nothing to do.
                // Otherwise, verify that the request is sector aligned,
                // doesn't wrap, and doesn't extend beyond the length of
                // the disk. If the request is valid, just return success.
                //

                if ( ioLength == 0 ) {

                    status = STATUS_SUCCESS;
    
                } else if ( ((ioOffset + ioLength) < ioOffset) ||
                            ((ioOffset | ioLength) & (diskExtension->BytesPerSector - 1)) != 0 ) {

                    status = STATUS_INVALID_PARAMETER;
    
                } else if ( (ioOffset + ioLength) > diskExtension->DiskLength ) {

                    status = STATUS_NONEXISTENT_SECTOR;
    
                } else {

                    status = STATUS_SUCCESS;
                }
            }

            break;
    
        case IOCTL_DISK_GET_DRIVE_LAYOUT:

            PRINT_CODE( IOCTL_DISK_GET_DRIVE_LAYOUT );
    
            if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(DRIVE_LAYOUT_INFORMATION) ) {
    
                status = STATUS_INVALID_PARAMETER;
    
            } else {

                //
                // If the RAM disk is file-backed, we must send this off to
                // the thread for processing, because it requires reading
                // from the disk image.
                //

                if ( !RAMDISK_IS_FILE_BACKED(diskExtension->DiskType) ) {
    
                    status = RamdiskGetDriveLayout( Irp, diskExtension );
                    info = Irp->IoStatus.Information;
    
                } else {
    
                    status = SendIrpToThread( DeviceObject, Irp );
                }
            }

            break;
    
        case IOCTL_DISK_GET_PARTITION_INFO:

            PRINT_CODE( IOCTL_DISK_GET_PARTITION_INFO );

            if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(PARTITION_INFORMATION) ) {
    
                status = STATUS_INVALID_PARAMETER;
    
            } else {
    
                //
                // If the RAM disk is file-backed, we must send this off to
                // the thread for processing, because it requires reading
                // from the disk image.
                //

                if ( !RAMDISK_IS_FILE_BACKED(diskExtension->DiskType) ) {
    
                    status = RamdiskGetPartitionInfo( Irp, diskExtension );
                    info = Irp->IoStatus.Information;
    
                } else {
    
                    status = SendIrpToThread( DeviceObject, Irp );
                }
            }

            break;
    
        case IOCTL_DISK_GET_LENGTH_INFO:

            PRINT_CODE( IOCTL_DISK_GET_LENGTH_INFO );

            if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(GET_LENGTH_INFORMATION) ) {
    
                status = STATUS_INVALID_PARAMETER;
                
            } else {
    
                PGET_LENGTH_INFORMATION outputBuffer;
    
                outputBuffer = (PGET_LENGTH_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

                outputBuffer->Length.QuadPart = 
                    diskExtension->NumberOfCylinders *
                    diskExtension->TracksPerCylinder *
                    diskExtension->SectorsPerTrack *
                    diskExtension->BytesPerSector;
    
                status = STATUS_SUCCESS;
                info = sizeof(GET_LENGTH_INFORMATION);
            }

            break;
    
        case IOCTL_STORAGE_GET_DEVICE_NUMBER:

            PRINT_CODE( IOCTL_STORAGE_GET_DEVICE_NUMBER );

#if SUPPORT_DISK_NUMBERS

            if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(STORAGE_DEVICE_NUMBER) ) {
    
                status = STATUS_INVALID_PARAMETER;
                
            } else {
    
                PSTORAGE_DEVICE_NUMBER outputBuffer;
    
                outputBuffer = (PSTORAGE_DEVICE_NUMBER)Irp->AssociatedIrp.SystemBuffer;
    
                //outputBuffer->DeviceType = FILE_DEVICE_VIRTUAL_DISK;
                outputBuffer->DeviceType = FILE_DEVICE_DISK;
                outputBuffer->DeviceNumber = diskExtension->DiskNumber;
                outputBuffer->PartitionNumber = -1;
    
                status = STATUS_SUCCESS;
                info = sizeof(STORAGE_DEVICE_NUMBER);
            }

#endif // SUPPORT_DISK_NUMBERS

            break;

        case IOCTL_DISK_SET_PARTITION_INFO:

            PRINT_CODE( IOCTL_DISK_SET_PARTITION_INFO );
    
            //
            // Set information about the partition.
            //
    
            if ( irpSp->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(SET_PARTITION_INFORMATION) ) {
    
                status = STATUS_INVALID_PARAMETER;
    
            } else {
    
                //
                // If the RAM disk is file-backed, we must send this off to
                // the thread for processing, because it requires writing
                // to the disk image.
                //

                if ( !RAMDISK_IS_FILE_BACKED(diskExtension->DiskType) ) {
    
                    status = RamdiskSetPartitionInfo( Irp, diskExtension );
                    info = Irp->IoStatus.Information;
    
                } else {
    
                    status = SendIrpToThread( DeviceObject, Irp );
                }
            }

            break;
    
        case IOCTL_DISK_SET_DRIVE_LAYOUT:

            PRINT_CODE( IOCTL_DISK_SET_DRIVE_LAYOUT );

            //
            // Haven't seen this one come down yet. Set a breakpoint so that
            // if it does come down, we can verify that this code works.
            //

            UNRECOGNIZED_IOCTL_BREAK;

            //
            // Return the default error.
            //

            break;

        case IOCTL_STORAGE_QUERY_PROPERTY:

            PRINT_CODE( IOCTL_STORAGE_QUERY_PROPERTY );

            //
            // Call RamdiskQueryProperty() to handle the request. This routine
            // releases the lock. It also takes care of IRP completion.
            //

            status = RamdiskQueryProperty( DeviceObject, Irp );

            lockHeld = FALSE;
            calleeWillComplete = TRUE;

            break;

        case IOCTL_VOLUME_GET_GPT_ATTRIBUTES:

            PRINT_CODE( IOCTL_VOLUME_GET_GPT_ATTRIBUTES );

            //
            // Return disk attributes.
            //
    
            if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(VOLUME_GET_GPT_ATTRIBUTES_INFORMATION) ) {
    
                status = STATUS_INVALID_PARAMETER;
    
            } else {
    
                PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION outputBuffer;

                outputBuffer = (PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION)
                                                Irp->AssociatedIrp.SystemBuffer;
    
                outputBuffer->GptAttributes = 0;
                if ( diskExtension->Options.Readonly ) {
                    outputBuffer->GptAttributes |= GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY;
                }
                if ( diskExtension->Options.NoDriveLetter ) {
                    outputBuffer->GptAttributes |= GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER;
                }
                if ( diskExtension->Options.Hidden ) {
                    outputBuffer->GptAttributes |= GPT_BASIC_DATA_ATTRIBUTE_HIDDEN;
                }
    
                status = STATUS_SUCCESS;
                info = sizeof(VOLUME_GET_GPT_ATTRIBUTES_INFORMATION);
            }

            break;

        case IOCTL_VOLUME_SET_GPT_ATTRIBUTES:

            PRINT_CODE( IOCTL_VOLUME_SET_GPT_ATTRIBUTES );

            //
            // Set disk attributes.
            //
    
            if ( irpSp->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(VOLUME_SET_GPT_ATTRIBUTES_INFORMATION) ) {
    
                status = STATUS_INVALID_PARAMETER;
    
            } else {
    
                PVOLUME_SET_GPT_ATTRIBUTES_INFORMATION inputBuffer;

                inputBuffer = (PVOLUME_SET_GPT_ATTRIBUTES_INFORMATION)
                                                Irp->AssociatedIrp.SystemBuffer;
    
                if ( diskExtension->Options.Hidden ) {

                    if ( (inputBuffer->GptAttributes & GPT_BASIC_DATA_ATTRIBUTE_HIDDEN) == 0 ) {

                        diskExtension->Options.Hidden = FALSE;
                        status = IoSetDeviceInterfaceState(
                                    &diskExtension->InterfaceString,
                                    TRUE
                                    );
                    }

                } else {

                    if ( (inputBuffer->GptAttributes & GPT_BASIC_DATA_ATTRIBUTE_HIDDEN) != 0 ) {

                        diskExtension->Options.Hidden = TRUE;
                        status = IoSetDeviceInterfaceState(
                                    &diskExtension->InterfaceString,
                                    FALSE
                                    );
                    }
                }
    
                status = STATUS_SUCCESS;
            }

            break;

        case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS:

            PRINT_CODE( IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS );

            //
            // We only support this for volume-emulating RAM disks. For
            // disk-emulating RAM disks, this IOCTL should be handled by
            // higher layers.
            //

            if ( diskExtension->DiskType == RAMDISK_TYPE_FILE_BACKED_DISK ) {

                status = STATUS_INVALID_PARAMETER;
            
            } else if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength < 
                    sizeof(VOLUME_DISK_EXTENTS) ) {
    
                status = STATUS_BUFFER_TOO_SMALL;
    
            } else {
    
                PVOLUME_DISK_EXTENTS inputBuffer;

                inputBuffer = (PVOLUME_DISK_EXTENTS)Irp->AssociatedIrp.SystemBuffer;

                inputBuffer->NumberOfDiskExtents = 1;
                inputBuffer->Extents[0].DiskNumber = (ULONG)-1;
                inputBuffer->Extents[0].StartingOffset.QuadPart = 0;
                inputBuffer->Extents[0].ExtentLength.QuadPart = diskExtension->DiskLength;

                status = STATUS_SUCCESS;
                info = sizeof(VOLUME_DISK_EXTENTS);
            }

            break;

        //
        // The following codes return success without doing anything.
        //

        case IOCTL_DISK_CHECK_VERIFY:

            PRINT_CODE( IOCTL_DISK_CHECK_VERIFY );

            // Fall through.

        case IOCTL_STORAGE_CHECK_VERIFY:

            PRINT_CODE( IOCTL_STORAGE_CHECK_VERIFY );

            // Fall through.

        case IOCTL_STORAGE_CHECK_VERIFY2:

            PRINT_CODE( IOCTL_STORAGE_CHECK_VERIFY2 );

            // Fall through.

        case IOCTL_VOLUME_ONLINE:

            PRINT_CODE( IOCTL_VOLUME_ONLINE );

            //
            // Return STATUS_SUCCESS without actually doing anything.
            //

            status = STATUS_SUCCESS;

            break;
    
        //
        // The following codes return the default error.
        //

        case FT_BALANCED_READ_MODE:

            PRINT_CODE( FT_BALANCED_READ_MODE );
    
            // Fall through.
    
        case FT_PRIMARY_READ:

            PRINT_CODE( FT_PRIMARY_READ );
    
            // Fall through.
    
        case IOCTL_DISK_GET_DRIVE_LAYOUT_EX:

            PRINT_CODE( IOCTL_DISK_GET_DRIVE_LAYOUT_EX );

            // Fall through.
    
        case IOCTL_DISK_GET_PARTITION_INFO_EX:

            PRINT_CODE( IOCTL_DISK_GET_PARTITION_INFO_EX );
    
            // Fall through.
    
        case IOCTL_DISK_MEDIA_REMOVAL:

            PRINT_CODE( IOCTL_DISK_MEDIA_REMOVAL );
    
            // Fall through.
    
        case IOCTL_MOUNTDEV_LINK_CREATED:

            PRINT_CODE( IOCTL_MOUNTDEV_LINK_CREATED );

            // Fall through.
            
        case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:

            PRINT_CODE( IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME );

            // Fall through.
            
        case IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY:

            PRINT_CODE( IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY );
            
            // Fall through.
            
        case IOCTL_SCSI_GET_ADDRESS:

            PRINT_CODE( IOCTL_SCSI_GET_ADDRESS );

            // Fall through.
    
        case IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS:

            PRINT_CODE( IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS );

            // Fall through.
    
        case IOCTL_STORAGE_GET_HOTPLUG_INFO:

            PRINT_CODE( IOCTL_STORAGE_GET_HOTPLUG_INFO );
    
            //
            // Return the default error.
            //

            break;

        default:

            //
            // The specified I/O control code is unrecognized by this driver.
            // The I/O status field in the IRP has already been set, so just
            // terminate the switch.
            //
    
            DBGPRINT( DBG_IOCTL, DBG_ERROR, ("Ramdisk:  ERROR:  unrecognized IOCTL %x\n",
                        irpSp->Parameters.DeviceIoControl.IoControlCode) );

            UNRECOGNIZED_IOCTL_BREAK;

            break;
    
        }

        break;

    default:

        //
        // Can't get here. Return the default error if the impossible occurs.
        //

        break;
    }

    //
    // Release the remove lock, if it's still held.
    //

    if ( lockHeld ) {
        IoReleaseRemoveLock( &commonExtension->RemoveLock, Irp );
    }

    //
    // If we didn't call another routine that owns completing the IRP, and
    // we didn't send the IRP off to the thread for processing, complete the
    // IRP now.
    //

    if ( !calleeWillComplete && (status != STATUS_PENDING) ) {

        COMPLETE_REQUEST( status, info, Irp );
    }

    return status;

} // RamdiskDeviceControl

NTSTATUS
RamdiskCreateRamDisk (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN AccessCheckOnly
    )

/*++

Routine Description:

    This routine is called to handle an FSCTL_CREATE_RAM_DISK IRP. It is called
    in thread context.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

    AccessCheckOnly - If FALSE, create the RAM disk. Otherwise, just check
        whether the caller has the necessary access rights to create the disk.

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    ULONG status;
    PBUS_EXTENSION busExtension;
    PDISK_EXTENSION diskExtension;
    PIO_STACK_LOCATION irpSp;
    PRAMDISK_CREATE_INPUT createInput;
    ULONG inputLength;
    PWCHAR p;
    PWCHAR pMax;
    PLOADER_PARAMETER_BLOCK loaderBlock;

    PAGED_CODE();

    //
    // The target device object for the I/O is our bus FDO.
    //

    busExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Verify that the input parameter buffer is big enough.
    //

    inputLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;
    createInput = (PRAMDISK_CREATE_INPUT)Irp->AssociatedIrp.SystemBuffer;

    if ( inputLength < sizeof(RAMDISK_CREATE_INPUT) ) {

        return STATUS_INVALID_PARAMETER;
    }

    if ( createInput->Version != sizeof(RAMDISK_CREATE_INPUT) ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Verify that the disk type is valid. VIRTUAL_FLOPPY disks can only be
    // created via the registry, and then only during textmode setup.
    // A BOOT_DISK can only be created by the kernel early in the boot
    // process -- when the loader block still exists.
    //
    // ISSUE: If the kernel/driver interface for creating the boot disk is
    // changed, change this test to disallow RAMDISK_TYPE_BOOT_DISK.
    //

    if ( createInput->DiskType == RAMDISK_TYPE_VIRTUAL_FLOPPY ) {

        return STATUS_INVALID_PARAMETER;

    } else if ( createInput->DiskType == RAMDISK_TYPE_BOOT_DISK ) {

        loaderBlock = *(PLOADER_PARAMETER_BLOCK *)KeLoaderBlock;

        if ( loaderBlock == NULL ) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Verify that file name string (if present) is properly terminated.
    //

    if ( RAMDISK_IS_FILE_BACKED(createInput->DiskType) ) {

        pMax = (PWCHAR)((PUCHAR)createInput + inputLength);
        p = createInput->FileName;

        while ( p < pMax ) {

            if ( *p == 0 ) {
                break;
            }

            p++;
        }

        if ( p == pMax ) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Call RamdiskCreateDiskDevice to create the device. If successful, this
    // returns a pointer to the new disk PDO's device extension.
    //

    status = RamdiskCreateDiskDevice( busExtension, createInput, AccessCheckOnly, &diskExtension );

    if ( NT_SUCCESS(status) ) {

        //
        // Tell PnP that we need to reenumerate our bus.
        //

        IoInvalidateDeviceRelations( busExtension->Pdo, BusRelations );

        Irp->IoStatus.Information = 0;
    }

    return status;

} // RamdiskCreateRamDisk

NTSTATUS
RamdiskCreateDiskDevice (
    IN PBUS_EXTENSION BusExtension,
    IN PRAMDISK_CREATE_INPUT CreateInput,
    IN BOOLEAN AccessCheckOnly,
    OUT PDISK_EXTENSION *DiskExtension
    )

/*++

Routine Description:

    This routine does the work to create a new RAM disk device. It is called
    in thread context.

Arguments:

    BusExtension - a pointer to the device extension for the bus FDO

    CreateInput - a pointer to the desired parameters for the new RAM disk

    AccessCheckOnly - If FALSE, create the RAM disk. Otherwise, just check
        whether the caller has the necessary access rights to create the disk.

    DiskExtension - returns a pointer to the new disk PDO's device extension

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    ULONG status;
    ULONG_PTR basePage;
    PVOID baseAddress;
    ULONG i;
    ULONG deviceExtensionSize;
    PDEVICE_OBJECT newDeviceObject;
    WCHAR buffer[15];
    UNICODE_STRING guidString;
    UNICODE_STRING realDeviceName;
    PDISK_EXTENSION diskExtension;
    HANDLE fileHandle;
    HANDLE sectionHandle;
    PVOID sectionObject;
    NTSTATUS ntStatus;
    PVOID viewBase;
    SIZE_T viewSize;
    LARGE_INTEGER sectionOffset;
    UNICODE_STRING string;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    UNICODE_STRING dosSymLink;
    FILE_STANDARD_INFORMATION fileInfo;
    PVIEW viewDescriptors = NULL;
    HRESULT result;

#if SUPPORT_DISK_NUMBERS
    ULONG diskNumber;
#endif // SUPPORT_DISK_NUMBERS

    PAGED_CODE();

    //
    // Initialize local variables to prepare for exit cleanup.
    //

#if SUPPORT_DISK_NUMBERS
    diskNumber = 0xffffffff;
#endif // SUPPORT_DISK_NUMBERS

    fileHandle = NULL;
    sectionHandle = NULL;
    sectionObject = NULL;
    viewDescriptors = NULL;
    guidString.Buffer = NULL;
    realDeviceName.Buffer = NULL;
    dosSymLink.Buffer = NULL;

#if SUPPORT_DISK_NUMBERS

    if ( !AccessCheckOnly ) {
    
        //
        // Allocate a disk number.
        //
    
        KeEnterCriticalRegion();
        ExAcquireFastMutex( &BusExtension->Mutex );
    
        diskNumber = RtlFindClearBitsAndSet( &BusExtension->DiskNumbersBitmap, 1, 0 );
    
        ExReleaseFastMutex( &BusExtension->Mutex );
        KeLeaveCriticalRegion();
    
        if ( diskNumber == 0xffffffff ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
    
        //
        // Convert the zero-based bit number to a one-based disk number.
        //
    
        diskNumber++;
    }

#endif // SUPPORT_DISK_NUMBERS

    //
    // Initialize based on the disk type (file-backed or in-memory).
    //

    DBGPRINT( DBG_IOCTL, DBG_INFO,
                ("RamdiskCreateDiskDevice: Creating disk with length 0x%08x\n",
                CreateInput->DiskLength) );

    sectionObject = NULL;
    basePage = 0;
    baseAddress = NULL;

    if ( RAMDISK_IS_FILE_BACKED(CreateInput->DiskType) ) {

        //
        // This is a file-backed RAM disk. Open the backing file. Note that
        // we do NOT create the file here if it doesn't exist. It is up to
        // the caller to handle that.
        //

        RtlInitUnicodeString( &string, CreateInput->FileName );
        InitializeObjectAttributes( &obja, &string, OBJ_CASE_INSENSITIVE, NULL, NULL );

        status = IoCreateFile(
                    &fileHandle,
                    SYNCHRONIZE | FILE_READ_DATA | FILE_READ_ATTRIBUTES |
                        (CreateInput->Options.Readonly ? 0 : FILE_WRITE_DATA),
                    &obja,
                    &iosb,
                    NULL,
                    0,
                    FILE_SHARE_READ,
                    FILE_OPEN,
                    0,
                    NULL,
                    0,
                    CreateFileTypeNone,
                    NULL,
                    (AccessCheckOnly ? IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING : 0)
                    );

        if ( !NT_SUCCESS(status) ) {

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("RamdiskCreateDiskDevice: Can't open target file %ws: %x\n",
                        CreateInput->FileName, status) );

            goto exit;
        }

        if ( AccessCheckOnly ) {

            goto exit;
        }

        //
        // Get the size of the file.
        //

        status = ZwQueryInformationFile(
                    fileHandle,
                    &iosb,
                    &fileInfo,
                    sizeof(fileInfo),
                    FileStandardInformation
                    );

        if ( !NT_SUCCESS(status) ) {

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("RamdiskCreateDiskDevice: Can't query info for file %ws: %x\n",
                        CreateInput->FileName, status) );

            goto exit;
        }

        //
        // Verify that the file is long enough for the specified DiskOffset
        // and DiskLength.
        //

        DBGPRINT( DBG_IOCTL, DBG_INFO, ("RamdiskCreateDiskDevice: file size = %I64x\n",
                                            fileInfo.EndOfFile.QuadPart) );

        if ( (CreateInput->DiskOffset + CreateInput->DiskLength) >
                (ULONGLONG)fileInfo.EndOfFile.QuadPart ) {

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("RamdiskCreateDiskDevice: specified offset and length too big for file:"
                         " 0x%x + 0x%I64x > 0x%I64x\n",
                         CreateInput->DiskOffset, CreateInput->DiskLength,
                         fileInfo.EndOfFile.QuadPart) );

            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }

        //
        // Create a section for the file. Close the file handle.
        //

        status = ZwCreateSection(
                    &sectionHandle,
                    SECTION_ALL_ACCESS,
                    NULL,
                    0,
                    (CreateInput->Options.Readonly ? PAGE_READONLY : PAGE_READWRITE),
                    SEC_COMMIT,
                    fileHandle
                    );

        if ( !NT_SUCCESS(status) ) {

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("RamdiskCreateDiskDevice: Can't create section for %ws: %x\n",
                        CreateInput->FileName, status) );

            goto exit;
        }

        NtClose( fileHandle );
        fileHandle = NULL;

        //
        // Get a referenced pointer to the section object. Close the section.
        //

        status = ObReferenceObjectByHandle(
                    sectionHandle,
                    SECTION_ALL_ACCESS,
                    *(POBJECT_TYPE *)MmSectionObjectType,
                    KernelMode,
                    &sectionObject,
                    NULL
                    );

        if ( !NT_SUCCESS(status) ) {

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("RamdiskCreateDiskDevice: Can't reference section for %ws: %x\n",
                        CreateInput->FileName, status) );

            goto exit;
        }

        NtClose( sectionHandle );
        sectionHandle = NULL;
            
        //
        // Allocate space for view descriptors. First, get the number of views
        // to use and the size of each view.
        //

        if ( CreateInput->ViewCount == 0  ) {
            CreateInput->ViewCount = DefaultViewCount;
        } else if ( CreateInput->ViewCount < MinimumViewCount ) {
            CreateInput->ViewCount = MinimumViewCount;
        } else if ( CreateInput->ViewCount > MaximumViewCount ) {
            CreateInput->ViewCount = MaximumViewCount;
        }
            
        if ( CreateInput->ViewLength == 0 ) {
            CreateInput->ViewLength = DefaultViewLength;
        } else if ( CreateInput->ViewLength < MinimumViewLength ) {
            CreateInput->ViewLength = MinimumViewLength;
        } else if ( CreateInput->ViewLength > MaximumViewLength ) {
            CreateInput->ViewLength = MaximumViewLength;
        }

        //
        // Ensure that the total view length is not greater than the maximum
        // per-disk view length. If necessary, decrease the view count until
        // the total view length is low enough. If the view count reaches the
        // configured minimum, reduce the length of each view until the total
        // view length is low enough.
        //
        // It is possible for the administrator to configure the minimum view
        // count, minimum view length, and maximum per-disk view length such
        // that it's impossible for the minimum total view length to be less
        // than the maximum per-disk view length. (That is, the miinimum view
        // count and minimum view length are configured to high relative to
        // the configured maximum per-disk view length.) If this occurs, we
        // create the disk with the compile-time defaults instead.
        //
        
        while ( ((ULONGLONG)CreateInput->ViewCount * CreateInput->ViewLength) >
                                                        MaximumPerDiskViewLength ) {

            //
            // The total view length is too big. If possible, cut the number of
            // views in half.
            //

            if ( CreateInput->ViewCount > MinimumViewCount ) {

                //
                // The view count isn't at the minimum. Cut in half, but don't
                // go below the minimum.
                //

                CreateInput->ViewCount /= 2;
                if ( CreateInput->ViewCount < MinimumViewCount ) {
                    CreateInput->ViewCount = MinimumViewCount;
                }

            } else {

                //
                // The view count is already at the minimum. If possible,
                // cut the view length in half.
                //

                if ( CreateInput->ViewLength > MinimumViewLength ) {
    
                    //
                    // The view length isn't at the minimum. Cut in half, but
                    // don't go below the minimum.
                    //
    
                    CreateInput->ViewLength /= 2;
                    if ( CreateInput->ViewLength < MinimumViewLength ) {
                        CreateInput->ViewLength = MinimumViewLength;
                    }

                } else {
                
                    //
                    // At this point, the view count and the view length are
                    // both at the minimum allowed values, but the total view
                    // length is beyond the maximum per-disk value. Use the
                    // compile-time default values instead. Note that this will
                    // result in a total view length that is equal to the
                    // minimum allowed maximum per-disk view length, at least
                    // given the compile-time values as of this writing.
                    //

                    CreateInput->ViewCount = DEFAULT_DEFAULT_VIEW_COUNT;
                    CreateInput->ViewLength = DEFAULT_DEFAULT_VIEW_LENGTH;
                    ASSERT( ((ULONGLONG)CreateInput->ViewCount * CreateInput->ViewLength) <=
                                                        MaximumPerDiskViewLength );

                    break;
                }
            }
        }
            
        viewDescriptors = ALLOCATE_POOL(
                            PagedPool,
                            CreateInput->ViewCount * sizeof(VIEW),
                            TRUE );

        if ( viewDescriptors == NULL ) {

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("%s", "RamdiskCreateDiskDevice: Can't allocate pool for view descriptors\n") );

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }

        RtlZeroMemory( viewDescriptors, CreateInput->ViewCount * sizeof(VIEW) );

    } else if ( CreateInput->DiskType == RAMDISK_TYPE_BOOT_DISK ) {

        //
        // For a boot disk, the input parameter buffer tells us where the
        // image is in physical memory, and how big the image is.
        //

        basePage = CreateInput->BasePage;

        if ( basePage == 0 ) {
    
            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("%s", "RamdiskCreateDiskDevice: Base page for boot disk is 0?!?\n") );

            ASSERT( FALSE );
    
            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }

        //
        // Force options to the appropriate values for a boot disk.
        //

        CreateInput->Options.Fixed = TRUE;
        CreateInput->Options.Readonly = FALSE;
        CreateInput->Options.NoDriveLetter = FALSE;
        CreateInput->Options.NoDosDevice = FALSE;
        CreateInput->Options.Hidden = FALSE;

    } else if ( CreateInput->DiskType == RAMDISK_TYPE_VIRTUAL_FLOPPY ) {

        //
        // For a virtual floppy, the input parameter buffer tells us where the
        // image is in virtual memory, and how big the image is.
        //
        
        baseAddress = CreateInput->BaseAddress;

        ASSERT( baseAddress != NULL );

        //
        // Force options to the appropriate values for a virtual floppy.
        //

        CreateInput->Options.Fixed = TRUE;
        CreateInput->Options.Readonly = FALSE;
        CreateInput->Options.NoDriveLetter = TRUE;
        CreateInput->Options.NoDosDevice = FALSE;
        CreateInput->Options.Hidden = FALSE;

    } else {

        DBGPRINT( DBG_IOCTL, DBG_ERROR,
                    ("RamdiskCreateDiskDevice: Bad disk type %d\n", CreateInput->DiskType) );

        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    if ( AccessCheckOnly ) {

        status = STATUS_SUCCESS;
        goto exit;
    }

    ASSERT( (basePage != 0) || (sectionObject != NULL) || (baseAddress != NULL) );

    //
    // Create a name for the disk, based on the disk GUID. For all disk types
    // except VIRTUAL_FLOPPY, the name is of the form \Device\Ramdisk{guid}.
    // For VIRTUAL_FLOPPY, the name is of the form \Device\RamdiskN, when N is
    // specified by the Data1 field of the GUID.
    //

    if ( CreateInput->DiskType != RAMDISK_TYPE_VIRTUAL_FLOPPY ) {
    
        status = RtlStringFromGUID( &CreateInput->DiskGuid, &guidString );

    } else {

        // This variable is here to keep PREfast quiet (PREfast warning 209).
        size_t size = sizeof(buffer);

        result = StringCbPrintfW( buffer, size, L"%u", CreateInput->DiskGuid.Data1 );
        ASSERT( result == S_OK );

        status = RtlCreateUnicodeString( &guidString, buffer );
    }

    if ( !NT_SUCCESS(status) || (guidString.Buffer == NULL) ) {

        DBGPRINT( DBG_IOCTL, DBG_ERROR,
                    ("%s", "RamdiskCreateDiskDevice: can't allocate pool for pretty GUID\n") );

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    i = sizeof(RAMDISK_DEVICENAME) + guidString.Length;

    realDeviceName.Buffer = ALLOCATE_POOL( NonPagedPool, i, TRUE );

    if ( (realDeviceName.Buffer == NULL) ) {

        DBGPRINT( DBG_IOCTL, DBG_ERROR,
                    ("%s", "RamdiskCreateDiskDevice: can't allocate pool for device name\n") );

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    realDeviceName.MaximumLength = (USHORT)i;
    realDeviceName.Length = realDeviceName.MaximumLength - sizeof(WCHAR);

    result = StringCbCopyW( realDeviceName.Buffer, i, RAMDISK_DEVICENAME );
    ASSERT( result == S_OK );
    result = StringCbCatW( realDeviceName.Buffer, i, guidString.Buffer );
    ASSERT( result == S_OK );
    ASSERT( (wcslen(realDeviceName.Buffer) * sizeof(WCHAR)) == realDeviceName.Length );

    DBGPRINT( DBG_IOCTL, DBG_INFO,
                ("RamdiskCreateDiskDevice: Device name is %wZ\n", &realDeviceName) );

    //
    // Create the RAM disk device.
    //
    // ISSUE: Apply an ACL to the disk device object. (Or does the next issue obviate this?)
    // ISSUE: Should we use an autogenerated name for the PDO? This would mean
    //          that we'd have to return the device name as the IOCTL output,
    //          not just the disk number.
    //

    deviceExtensionSize = sizeof(DISK_EXTENSION);
    if ( RAMDISK_IS_FILE_BACKED(CreateInput->DiskType) ) {
        deviceExtensionSize += wcslen( CreateInput->FileName ) * sizeof(WCHAR);
    }

    status = IoCreateDevice(
                BusExtension->Fdo->DriverObject,
                deviceExtensionSize,
                &realDeviceName,
                FILE_DEVICE_DISK,
                CreateInput->Options.Fixed ? 0 : FILE_REMOVABLE_MEDIA, // | FILE_VIRTUAL_VOLUME,
                FALSE,
                &newDeviceObject
                );

    if ( !NT_SUCCESS(status) ) {

        DBGPRINT( DBG_IOCTL, DBG_ERROR,
                    ("RamdiskCreateDiskDevice: IoCreateDevice failed: %x\n", status) );

        goto exit;
    }

    diskExtension = newDeviceObject->DeviceExtension;

    //
    // Create a DosDevices link for the device.
    //

    if ( !CreateInput->Options.NoDosDevice ) {
    
        //
        // Create a DosDevices symbolic link. Ignore errors.
        //
    
        i = sizeof(RAMDISK_FULL_DOSNAME) + guidString.Length;

        dosSymLink.MaximumLength = (USHORT)i;
        dosSymLink.Length = dosSymLink.MaximumLength - sizeof(WCHAR);

        dosSymLink.Buffer = ALLOCATE_POOL( NonPagedPool, i, TRUE );

        if ( dosSymLink.Buffer == NULL ) {

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("%s", "RamdiskCreateDiskDevice: can't allocate pool for DosDevices name\n") );

            CreateInput->Options.NoDosDevice = TRUE;

        } else {
        
            result = StringCbCopyW( dosSymLink.Buffer, i, RAMDISK_FULL_DOSNAME );
            ASSERT( result == S_OK );
            result = StringCbCatW( dosSymLink.Buffer, i, guidString.Buffer );
            ASSERT( result == S_OK );
            ASSERT( (wcslen(dosSymLink.Buffer) * sizeof(WCHAR)) == dosSymLink.Length );

            status = IoCreateSymbolicLink( &dosSymLink, &realDeviceName );

            if ( !NT_SUCCESS(status) ) {
    
                DBGPRINT( DBG_IOCTL, DBG_ERROR,
                            ("RamdiskCreateDiskDevice: IoCreateSymbolicLink failed: %x\n", status) );
    
                CreateInput->Options.NoDosDevice = TRUE;

                FREE_POOL( dosSymLink.Buffer, TRUE );
                dosSymLink.Buffer = NULL;
            }
        }

        //
        // If creating the boot disk, create a drive letter.
        //

        if ( CreateInput->DiskType == RAMDISK_TYPE_BOOT_DISK ) {

            // This variable is here to keep PREfast quiet (PREfast warning 209).
            size_t size = sizeof(buffer);

            result = StringCbPrintfW(
                        buffer,
                        size,
                        L"\\DosDevices\\%wc:",
                        CreateInput->DriveLetter
                        );
            ASSERT( result == S_OK );
            RtlInitUnicodeString( &string, buffer );
            IoDeleteSymbolicLink( &string );
            IoCreateSymbolicLink( &string, &realDeviceName );

            diskExtension->DriveLetter = CreateInput->DriveLetter;
        }
    }
                
    //
    // Initialize device object and extension.
    //

    //
    // Our device does direct I/O, is XIP-capable, and is power pageable.
    // We require word alignment for I/O.
    //

    newDeviceObject->Flags |= DO_DIRECT_IO | DO_XIP | DO_POWER_PAGABLE;
    newDeviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;

    //
    // Return a pointer to the device extension to the caller.
    //

    *DiskExtension = diskExtension;

    //
    // Set the device type and state in the device extension. Initialize the
    // fast mutex and the remove lock. Save the device name string.
    //

    diskExtension->DeviceType = RamdiskDeviceTypeDiskPdo;
    diskExtension->DeviceState = RamdiskDeviceStateStopped;

    ExInitializeFastMutex( &diskExtension->Mutex );
    IoInitializeRemoveLock( &diskExtension->RemoveLock, 'dmaR', 1, 0 );

    diskExtension->DeviceName = realDeviceName;
    realDeviceName.Buffer = NULL;
    diskExtension->DosSymLink = dosSymLink;
    dosSymLink.Buffer = NULL;

    diskExtension->DiskGuid = CreateInput->DiskGuid;
    diskExtension->DiskGuidFormatted = guidString;
    guidString.Buffer = NULL;

#if SUPPORT_DISK_NUMBERS

    //
    // Save the disk number.
    //

    diskExtension->DiskNumber = diskNumber;
    diskNumber = 0xffffffff;

#endif // SUPPORT_DISK_NUMBERS

    //
    // Save object pointers. The PDO for this extension is the device
    // extension is the device object that we just created. The FDO and
    // the lower device object are the bus FDO.
    //
    
    diskExtension->Pdo = newDeviceObject;
    diskExtension->Fdo = RamdiskBusFdo;
    diskExtension->LowerDeviceObject = RamdiskBusFdo;

    //
    // ISSUE: What about BiosParameters?
    //
    //bios = &diskExtension->BiosParameters;
    //
    //diskExtension->BootParameters = xipbootparameters;
    //status = RamdDispatch(XIPCMD_GETBIOSPARAMETERS, bios, sizeof(*bios));


    //
    // Save pointers to the disk image.
    //

    diskExtension->BasePage = basePage;
    diskExtension->SectionObject = sectionObject;
    sectionObject = NULL;
    diskExtension->BaseAddress = baseAddress;
	
    if ( RAMDISK_IS_FILE_BACKED(CreateInput->DiskType) ) {

        result = StringCbCopyW(
                    diskExtension->FileName,
                    deviceExtensionSize,
                    CreateInput->FileName
                    );
        ASSERT( result == S_OK );
    }

    //
    // Save the disk type (disk or volume) and disk options.
    //

    diskExtension->DiskType = CreateInput->DiskType;
    diskExtension->Options = CreateInput->Options;

    //
    // For a file-backed disk image, set up the view descriptors.
    //
    // ISSUE: Need to consider whether to permanently map the first few pages
    // of the image. The first sector on the disk is accessed frequently, so
    // there is some value in keeping it mapped. But it might not be worth it
    // to waste a view descriptor on this. And the LRU nature of the view
    // replacement algorithm will keep the first sector mapped when necessary.
    //

    if ( viewDescriptors != NULL ) {

        PVIEW view;

        //
        // Initialize windowing fields in the disk extension.
        //

        diskExtension->ViewCount = CreateInput->ViewCount;
        diskExtension->ViewLength = CreateInput->ViewLength;
        diskExtension->ViewDescriptors = viewDescriptors;
        KeInitializeSemaphore( &diskExtension->ViewSemaphore, 0, MAXLONG );
        diskExtension->ViewWaiterCount = 0;

        //
        // Initialize the view lists, then insert in each view descriptor
        // in order. The result is a list of descriptors, each unmapped
        // (offset and length both 0).
        //

        InitializeListHead( &diskExtension->ViewsByOffset );
        InitializeListHead( &diskExtension->ViewsByMru );

        view = viewDescriptors;

        for ( i = 0; i < diskExtension->ViewCount; i++ ) {

            InsertTailList( &diskExtension->ViewsByOffset, &view->ByOffsetListEntry );
            InsertTailList( &diskExtension->ViewsByMru, &view->ByMruListEntry );

            view++;
        }

        viewDescriptors = NULL;
    }


    diskExtension->DiskLength = CreateInput->DiskLength;
    diskExtension->DiskOffset = CreateInput->DiskOffset;
    diskExtension->FileRelativeEndOfDisk = diskExtension->DiskOffset + diskExtension->DiskLength;

    //
    // Set the disk geometry. The basic geometry is constant for new disks.
    // For RAMDISK_TYPE_BOOT_DISK type volume geometry can be obtained from the partition boot sector.
    //
    
    if ( RAMDISK_TYPE_BOOT_DISK  != CreateInput->DiskType ) {
    	
		diskExtension->BytesPerSector = 0x200;
		diskExtension->SectorsPerTrack = 0x80;
		diskExtension->TracksPerCylinder = 0x10;
    }
    else {

    	//
    	//	2002/04/19-SaadSyed (Saad Syed)
    	//	Added generic geometry support to support SDI files
    	//
    	PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK BootSector = NULL;
	    ULONG mappedLength;
       BIOS_PARAMETER_BLOCK Bpb;	    
    
		//
		//	Map boot sector of boot ramdisk
		//

	    BootSector = ( PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK ) RamdiskMapPages( diskExtension, 0, PAGE_SIZE, &mappedLength );
		
	    if ( NULL != BootSector )  	{

	    	ASSERT( mappedLength == PAGE_SIZE );

            UnpackBios( &Bpb, &BootSector->Bpb );
	    	
	    	//
	    	// Extract geometry from boot sector bios parameter block
	    	//


			diskExtension->BytesPerSector = Bpb.BytesPerSector;
	    	diskExtension->SectorsPerTrack = Bpb.SectorsPerTrack;
	    	diskExtension->TracksPerCylinder = Bpb.Heads;

	      	RamdiskUnmapPages(diskExtension, (PUCHAR) BootSector, 0, mappedLength);
	      	
		   	BootSector = NULL;
	    }
	    else  {
	    	
	    	status = STATUS_INSUFFICIENT_RESOURCES;
	    	goto exit;

	    }
    }

    diskExtension->BytesPerCylinder  = diskExtension->BytesPerSector *
                                        diskExtension->SectorsPerTrack *
                                        diskExtension->TracksPerCylinder;

    diskExtension->NumberOfCylinders =   	
        (ULONG)(CreateInput->DiskLength / diskExtension->BytesPerCylinder);

	//
	//	A partition/volume does not often map to a geometry completely, the file system driver limits the
	//	volume to a capacity determined by the NumberOfSectors (in the Boot Sector) * BytesPerSector (in BPB).
	//	The FS driver uses the this geometry to determine if the NumberOfSectors is less than or
	//	equal to the total number of sectors reported by the geometry, otherwise it fails to mount the volume.
	//	Here we check if the length of disk as obtained from the ramdisk image is less than or equal to the length 
	//	obtained by the geometry. We increment the number of cylinders if this check fails. This keeps the FS driver 
	//	happy. A simple ceil operation would yield the same results.
	//

    if ( ( diskExtension->BytesPerCylinder *
           diskExtension->NumberOfCylinders ) <  CreateInput->DiskLength) {
           
		diskExtension->NumberOfCylinders++;
			
    }
           

    //
    // Link the new disk into the bus FDO's list of disks.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutex( &BusExtension->Mutex );

    InsertTailList( &BusExtension->DiskPdoList, &diskExtension->DiskPdoListEntry );

    ExReleaseFastMutex( &BusExtension->Mutex );
    KeLeaveCriticalRegion();

    //
    // Indicate that we're done initializing the device.
    //

    newDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    status = STATUS_SUCCESS;

    goto exit_exit;

exit:

    if ( dosSymLink.Buffer != NULL ) {
        FREE_POOL( dosSymLink.Buffer, TRUE );
        dosSymLink.Buffer = NULL;
    }

    if ( realDeviceName.Buffer != NULL ) {
        FREE_POOL( realDeviceName.Buffer, TRUE );
        realDeviceName.Buffer = NULL;
    }

    if ( guidString.Buffer != NULL ) {
        FREE_POOL( guidString.Buffer, FALSE );
        guidString.Buffer = NULL;
    }

    if ( viewDescriptors != NULL ) {
        FREE_POOL( viewDescriptors, TRUE );
        viewDescriptors = NULL;
    }

    if ( sectionObject != NULL ) {
        ObDereferenceObject( sectionObject );
        sectionObject = NULL;
    }

    if ( sectionHandle != NULL ) {
        NtClose( sectionHandle );
        sectionHandle = NULL;
    }

    if ( fileHandle != NULL ) {
        NtClose( fileHandle );
        fileHandle = NULL;
    }

#if SUPPORT_DISK_NUMBERS

    if ( diskNumber != 0xffffffff ) {

        KeEnterCriticalRegion();
        ExAcquireFastMutex( &BusExtension->Mutex );

        RtlClearBit( &BusExtension->DiskNumbersBitmap, diskNumber - 1 );

        ExReleaseFastMutex( &BusExtension->Mutex );
        KeLeaveCriticalRegion();

        diskNumber = 0xffffffff;
    }

#endif // SUPPORT_DISK_NUMBERS

exit_exit:

    ASSERT( fileHandle == NULL );
    ASSERT( sectionHandle == NULL );
    ASSERT( sectionObject == NULL );
    ASSERT( viewDescriptors == NULL );
    ASSERT( guidString.Buffer == NULL );
    ASSERT( realDeviceName.Buffer == NULL );
    ASSERT( dosSymLink.Buffer == NULL );

    return status;

} // RamdiskCreateDiskDevice

NTSTATUS
RamdiskGetDriveLayout (
    PIRP Irp,
    PDISK_EXTENSION DiskExtension
    )

/*++

Routine Description:

    This routine is called to handle an IOCTL_GET_DRIVE_LAYOUT IRP. It is
    called in thread context iff the disk is file-backed.

Arguments:

    Irp - a pointer to the I/O Request Packet for this request

    DiskExtension - a pointer to the device extension for the target disk

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    PIO_STACK_LOCATION irpSp;
    PDRIVE_LAYOUT_INFORMATION driveLayout;
    PPARTITION_INFORMATION partInfo;
    PPARTITION_DESCRIPTOR partitionTableEntry;
    PUCHAR va;
    ULONG mappedLength;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(DRIVE_LAYOUT_INFORMATION) ) {

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Map the first page of the image.
    //

    va = RamdiskMapPages( DiskExtension, 0, PAGE_SIZE, &mappedLength );

    if ( va == NULL ) {

        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0;

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT( mappedLength == PAGE_SIZE );

    //
    // Get a pointer to the output buffer. Fill in the header.
    //

    driveLayout = (PDRIVE_LAYOUT_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

    //
    // ISSUE: Is this right for an emulated disk? Or is this routine never
    // called for emulated disks?
    //

    driveLayout->PartitionCount = 1;
    driveLayout->Signature = 0;

    partInfo = driveLayout->PartitionEntry;

    //
    // Point to the partition table in the disk image.
    //

    partitionTableEntry = (PPARTITION_DESCRIPTOR)&((PUSHORT)va)[PARTITION_TABLE_OFFSET];

    //
    // Return information about the partition.
    //

    partInfo->StartingOffset.QuadPart = DiskExtension->BytesPerSector;

    partInfo->PartitionLength.QuadPart = 
                DiskExtension->NumberOfCylinders *
                DiskExtension->TracksPerCylinder *
                DiskExtension->SectorsPerTrack *
                DiskExtension->BytesPerSector;

    // ISSUE: Currently, HiddenSectors is always 0. Is this right?
    partInfo->HiddenSectors =  DiskExtension->HiddenSectors;

    partInfo->PartitionNumber = 0;
    partInfo->PartitionType = partitionTableEntry->PartitionType;
    partInfo->BootIndicator = (BOOLEAN)(DiskExtension->DiskType == RAMDISK_TYPE_BOOT_DISK);
    partInfo->RecognizedPartition = IsRecognizedPartition(partInfo->PartitionType);
    partInfo->RewritePartition = FALSE;

    //
    // Unmap the mapped page.
    //

    RamdiskUnmapPages( DiskExtension, va, 0, mappedLength );

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof(DRIVE_LAYOUT_INFORMATION);

    return STATUS_SUCCESS;

} // RamdiskGetDriveLayout

NTSTATUS
RamdiskGetPartitionInfo (
    PIRP Irp,
    PDISK_EXTENSION DiskExtension
    )

/*++

Routine Description:

    This routine is called to handle an IOCTL_GET_PARTITION_INFO IRP. It is
    called in thread context iff the disk is file-backed.

Arguments:

    Irp - a pointer to the I/O Request Packet for this request

    DiskExtension - a pointer to the device extension for the target disk

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    PIO_STACK_LOCATION irpSp;
    PPARTITION_INFORMATION partInfo;
    PPARTITION_DESCRIPTOR partitionTableEntry;
    PUCHAR va;
    ULONG mappedLength;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PARTITION_INFORMATION) ) {

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Map the first page of the image.
    //

    va = RamdiskMapPages( DiskExtension, 0, PAGE_SIZE, &mappedLength );

    if ( va == NULL ) {

        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT( mappedLength == PAGE_SIZE );

    //
    // Get a pointer to the output buffer.
    //

    partInfo = (PPARTITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

    //
    // Point to the partition table in the disk image.
    //

    partitionTableEntry = (PPARTITION_DESCRIPTOR)&((PUSHORT)va)[PARTITION_TABLE_OFFSET];

    //
    // Return information about the partition.
    //

    partInfo->StartingOffset.QuadPart = DiskExtension->BytesPerSector;

    partInfo->PartitionLength.QuadPart = 
                DiskExtension->NumberOfCylinders *
                DiskExtension->TracksPerCylinder *
                DiskExtension->SectorsPerTrack *
                DiskExtension->BytesPerSector;

    // ISSUE: Currently, HiddenSectors is always 0. Is this right?
    partInfo->HiddenSectors =  DiskExtension->HiddenSectors;

    partInfo->PartitionNumber = 0;
    partInfo->PartitionType = partitionTableEntry->PartitionType;
    partInfo->BootIndicator = (BOOLEAN)(DiskExtension->DiskType == RAMDISK_TYPE_BOOT_DISK);
    partInfo->RecognizedPartition = IsRecognizedPartition(partInfo->PartitionType);
    partInfo->RewritePartition = FALSE;

    //
    // Unmap the mapped page.
    //

    RamdiskUnmapPages( DiskExtension, va, 0, mappedLength );

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION);

    return STATUS_SUCCESS;

} // RamdiskGetPartitionInfo


NTSTATUS
RamdiskSetPartitionInfo (
    PIRP Irp,
    PDISK_EXTENSION DiskExtension
    )

/*++

Routine Description:

    This routine is called to handle an IOCTL_SET_PARTITION_INFO IRP. It is
    called in thread context iff the disk is file-backed.

Arguments:

    Irp - a pointer to the I/O Request Packet for this request

    DiskExtension - a pointer to the device extension for the target disk

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    PIO_STACK_LOCATION irpSp;
    PSET_PARTITION_INFORMATION partInfo;
    PPARTITION_DESCRIPTOR partitionTableEntry;
    PUCHAR va;
    ULONG mappedLength;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    if ( irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(SET_PARTITION_INFORMATION) ) {

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Map the first page of the image.
    //

    va = RamdiskMapPages( DiskExtension, 0, PAGE_SIZE, &mappedLength );

    if ( va == NULL ) {

        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT( mappedLength == PAGE_SIZE );

    //
    // Get a pointer to the output buffer.
    //

    partInfo = (PSET_PARTITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

    //
    // Point to the partition table in the disk image.
    //

    partitionTableEntry = (PPARTITION_DESCRIPTOR)&((PUSHORT)va)[PARTITION_TABLE_OFFSET];

    //
    // Write the new partition type.
    //

    partitionTableEntry->PartitionType = partInfo->PartitionType;

    //
    // Unmap the mapped page.
    //

    RamdiskUnmapPages( DiskExtension, va, 0, mappedLength );

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    return STATUS_SUCCESS;

} // RamdiskGetPartitionInfo

NTSTATUS
RamdiskQueryProperty (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles a property query request.  It builds the descriptor
    on its own if possible, otherwise it forwards the request down to lower
    level drivers.

    Since this routine may forward the request downwards the caller should
    not complete the IRP.

    This routine must be called with the remove lock held. The lock is
    released when this routine returns.

Arguments:

    DeviceObject - a pointer to the device object being queried

    Irp - a pointer to the IRP for the query

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PSTORAGE_PROPERTY_QUERY query;
    ULONG queryLength;
    PSTORAGE_DEVICE_DESCRIPTOR storageDeviceDescriptor;
    PSTORAGE_ADAPTER_DESCRIPTOR storageAdapterDescriptor;
    ULONG offset;
    ULONG length;
    PUCHAR p;

    PCOMMON_EXTENSION commonExtension;
    PBUS_EXTENSION busExtension;
    PDISK_EXTENSION diskExtension;

    STORAGE_DEVICE_DESCRIPTOR sdd;
    STORAGE_ADAPTER_DESCRIPTOR sad;

    PAGED_CODE();

    //
    // Assume success.
    //

    status = STATUS_SUCCESS;

    //
    // Get parameters from the IRP.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    query = (PSTORAGE_PROPERTY_QUERY)Irp->AssociatedIrp.SystemBuffer;
    queryLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Get the device extension pointer.
    //

    commonExtension = DeviceObject->DeviceExtension;
    busExtension = DeviceObject->DeviceExtension;
    diskExtension = DeviceObject->DeviceExtension;

    //
    // We don't support mask queries.
    //

    if ( query->QueryType >= PropertyMaskQuery ) {

        status = STATUS_INVALID_PARAMETER_1;
        Irp->IoStatus.Information = 0;

    } else {

        //
        // Dispatch based on the property ID.
        //

        switch ( query->PropertyId ) {
        
        case StorageDeviceProperty: 
        
            //
            // Make sure this is a target device.
            //
    
            if ( commonExtension->DeviceType != RamdiskDeviceTypeDiskPdo ) {

                status = STATUS_INVALID_DEVICE_REQUEST;
                Irp->IoStatus.Information = 0;

                break;
            }

            //
            // If it's a just query for whether the property exists, the
            // answer is yes.
            //

            if ( query->QueryType == PropertyExistsQuery ) {

                break;
            }

            //
            // Build a full return buffer. The output buffer might not be
            // big enough to hold the whole thing.
            //

            RtlZeroMemory( &sdd, sizeof(sdd) );

            sdd.Version = sizeof(sdd);
            sdd.DeviceType = DIRECT_ACCESS_DEVICE;
            sdd.RemovableMedia = (diskExtension->Options.Fixed ? FALSE : TRUE);
            sdd.CommandQueueing = FALSE;
            sdd.BusType = BusTypeUnknown;

            length = sizeof(sdd) +
                        ((strlen(VER_COMPANYNAME_STR) + 1 +
                          strlen(RAMDISK_DISK_DEVICE_TEXT_ANSI) + 1) * sizeof(CHAR));
            sdd.Size = length;

            //
            // Zero the output buffer.
            //

            storageDeviceDescriptor = Irp->AssociatedIrp.SystemBuffer;
            RtlZeroMemory( storageDeviceDescriptor, queryLength );

            //
            // Copy the base part of the return descriptor to the output
            // buffer.
            //

            RtlCopyMemory(
                storageDeviceDescriptor,
                &sdd,
                min( queryLength, sizeof(sdd) )
                );

            //
            // If there's no room for the rest of the data, we're done.
            //

            if ( queryLength <= sizeof(sdd) ) {

                Irp->IoStatus.Information = queryLength;

                break;
            }

            //
            // Copy as much of the rest of the data as will fit.
            //

            offset = sizeof(sdd);
            p = (PUCHAR)storageDeviceDescriptor + offset;

            length = (strlen(VER_COMPANYNAME_STR) + 1) * sizeof(CHAR);

            if ( (offset + length) > queryLength ) {

                Irp->IoStatus.Information = offset;

                break;
            }

            storageDeviceDescriptor->VendorIdOffset = offset;
            memcpy( p, VER_COMPANYNAME_STR, length );
            offset += length;
            p += length;

            length = (strlen(RAMDISK_DISK_DEVICE_TEXT_ANSI) + 1) * sizeof(CHAR);

            if ( (offset + length) > queryLength ) {

                Irp->IoStatus.Information = offset;

                break;
            }

            storageDeviceDescriptor->ProductIdOffset = offset;
            memcpy( p, RAMDISK_DISK_DEVICE_TEXT_ANSI, length );
            offset += length;
            p += length;

            storageDeviceDescriptor->ProductRevisionOffset = 0;
            storageDeviceDescriptor->SerialNumberOffset = 0;

            storageDeviceDescriptor->Size = offset;

            Irp->IoStatus.Information = offset;

            break;
    
        case StorageAdapterProperty:
    
            //
            // If this is a target device then forward it down to the
            // underlying device object.  This lets filters do their magic.
            //
    
            if ( commonExtension->DeviceType == RamdiskDeviceTypeDiskPdo ) {

                //
                // Call the lower device.
                //
    
                IoReleaseRemoveLock( &commonExtension->RemoveLock, Irp );

                IoSkipCurrentIrpStackLocation( Irp );

                return IoCallDriver( commonExtension->LowerDeviceObject, Irp );
            }
    
            //
            // If it's a just query for whether the property exists, the
            // answer is yes.
            //

            if ( query->QueryType == PropertyExistsQuery ) {

                break;
            } 
            
            //
            // Build a full return buffer. The output buffer might not be
            // big enough to hold the whole thing.
            //

            RtlZeroMemory( &sad, sizeof(sad) );

            sad.Version = sizeof(sad);
            sad.Size = sizeof(sad);
            sad.MaximumTransferLength = 0xFFFFFFFF;
            sad.MaximumPhysicalPages = 0xFFFFFFFF;
            sad.AlignmentMask = 1;
            sad.AdapterUsesPio = FALSE;
            sad.AdapterScansDown = FALSE;
            sad.CommandQueueing = FALSE;
            sad.AcceleratedTransfer = TRUE;
            sad.BusType = BusTypeUnknown;
            sad.BusMajorVersion = VER_PRODUCTMAJORVERSION;
            sad.BusMinorVersion = VER_PRODUCTMINORVERSION;

            //
            // Zero the output buffer.
            //

            storageAdapterDescriptor = Irp->AssociatedIrp.SystemBuffer;
            RtlZeroMemory( storageAdapterDescriptor, queryLength );

            //
            // Copy the base part of the return descriptor to the output
            // buffer.
            //

            RtlCopyMemory(
                storageAdapterDescriptor,
                &sad,
                min( queryLength, sizeof(sad) )
                );
            
            Irp->IoStatus.Information = min( queryLength, sizeof(sad) );

            break;
    
        case StorageDeviceIdProperty: 

            //
            // Make sure this is a target device.
            //

            if ( commonExtension->DeviceType != RamdiskDeviceTypeDiskPdo ) {

                status = STATUS_INVALID_DEVICE_REQUEST;
                Irp->IoStatus.Information = 0;

                break;
            }

            //
            // We don't support this property.
            //

            status = STATUS_NOT_SUPPORTED;
            Irp->IoStatus.Information = 0;

            break;
        
        default: 
        
            //
            // If this is a target device, then some filter beneath us may
            // handle this property.
            //

            if ( commonExtension->DeviceType == RamdiskDeviceTypeDiskPdo ) {

                //
                // Call the lower device.
                //
    
                IoReleaseRemoveLock( &commonExtension->RemoveLock, Irp );

                IoSkipCurrentIrpStackLocation( Irp );

                return IoCallDriver( commonExtension->LowerDeviceObject, Irp );
            }
    
            //
            // Nope, this property really doesn't exist.
            //
    
            status = STATUS_INVALID_PARAMETER_1;
            Irp->IoStatus.Information = 0;

            break;
        }    
    }

    //
    // At this point, we have not sent the IRP down to a lower device, so
    // we need to complete it now.
    //

    ASSERT( status != STATUS_PENDING );

    IoReleaseRemoveLock( &commonExtension->RemoveLock, Irp );

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_DISK_INCREMENT );

    return status;

} // RamdiskQueryProperty
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ramdisk\pnp.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This file contains RAM disk driver code for processing PnP IRPs.

Author:

    Chuck Lenzmeier (ChuckL) 2001

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Registry value format for virtual floppy disks created by textmode setup.
// Should be in a header file, but that's not the way it was done for the
// original virtual floppy driver.
//

typedef struct _VIRTUAL_FLOPPY_DESCRIPTOR {

    //
    // The structure starts with a system virtual address. On 32-bit systems,
    // this is padded to 64 bits.
    //

    union {
        PVOID VirtualAddress;
        ULONGLONG Reserved;     // align to 64 bits
    } ;

    //
    // The length of the virtual floppy comes next.
    //

    ULONG Length;

    //
    // Textmode writes the registry value with 12 bytes of data. In order
    // to get the right size for our check, we use of the field offset of
    // the following field. We can't use sizeof a struct that just has the
    // above fields, because that comes out as 16 bytes due to alignment.
    //

    ULONG StructSizer;

} VIRTUAL_FLOPPY_DESCRIPTOR, *PVIRTUAL_FLOPPY_DESCRIPTOR;

#if !DBG

#define PRINT_CODE( _code )

#else

#define PRINT_CODE( _code )                                             \
    if ( print ) {                                                      \
        DBGPRINT( DBG_PNP, DBG_VERBOSE, ("%s", "  " #_code "\n") );     \
    }                                                                   \
    print = FALSE;

#endif

#if DBG

PSTR StateTable[] = {
    "STOPPED",
    "WORKING",
    "PENDINGSTOP",
    "PENDINGREMOVE",
    "SURPRISEREMOVED",
    "REMOVED",
    "UNKNOWN"
};

#endif // DBG

//
// Local functions.
//

NTSTATUS
RamdiskDeleteDiskDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp OPTIONAL
    );

NTSTATUS
RamdiskIoCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

NTSTATUS
RamdiskQueryBusInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskQueryCapabilities (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskQueryId (
    IN PDISK_EXTENSION DiskExtension,
    IN PIRP Irp
    );

NTSTATUS
RamdiskQueryDeviceRelations (
    IN DEVICE_RELATION_TYPE RelationsType,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskQueryDeviceText (
    IN PDISK_EXTENSION DiskExtension,
    IN PIRP Irp
    );

NTSTATUS
RamdiskRemoveBusDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#if DBG

PSTR
GetPnpIrpName (
    IN UCHAR PnpMinorFunction
    );

PCHAR
GetDeviceRelationString (
    IN DEVICE_RELATION_TYPE Type
    );

#endif // DBG

//
// Declare pageable routines.
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, RamdiskPnp )
#pragma alloc_text( PAGE, RamdiskPower )
#pragma alloc_text( PAGE, RamdiskAddDevice )
#pragma alloc_text( PAGE, CreateRegistryDisks )
#pragma alloc_text( PAGE, RamdiskDeleteDiskDevice )
#pragma alloc_text( PAGE, RamdiskQueryBusInformation )
#pragma alloc_text( PAGE, RamdiskQueryCapabilities )
#pragma alloc_text( PAGE, RamdiskQueryId )
#pragma alloc_text( PAGE, RamdiskQueryDeviceRelations )
#pragma alloc_text( PAGE, RamdiskQueryDeviceText )
#pragma alloc_text( PAGE, RamdiskRemoveBusDevice )

#if DBG
#pragma alloc_text( PAGE, GetPnpIrpName )
#pragma alloc_text( PAGE, GetDeviceRelationString )
#endif // DBG

#endif // ALLOC_PRAGMA

NTSTATUS
RamdiskPnp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a PnP function.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PCOMMON_EXTENSION commonExtension;
    PBUS_EXTENSION busExtension;
    PDISK_EXTENSION diskExtension;
    KEVENT event;
    BOOLEAN lockHeld = FALSE;

#if DBG
    BOOLEAN print = TRUE;
#endif

    PAGED_CODE();

    //
    // Get pointers the IRP stack location and the device extension.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    commonExtension = DeviceObject->DeviceExtension;
    busExtension = DeviceObject->DeviceExtension;
    diskExtension = DeviceObject->DeviceExtension;

    ASSERT( commonExtension->DeviceState < RamdiskDeviceStateMaximum );

    DBGPRINT( DBG_PNP, DBG_INFO, ("RamdiskPnp: DO=(%p [Type=%d]) Irp=(%p %s) Device State=%s\n",
                DeviceObject, commonExtension->DeviceType, Irp,
                GetPnpIrpName(irpSp->MinorFunction), StateTable[commonExtension->DeviceState]) );

    //
    // If the device has been removed, only pass IRP_REMOVE down for cleanup.
    //

    if ( (commonExtension->DeviceState >= RamdiskDeviceStateRemoved) &&
         (irpSp->MinorFunction != IRP_MN_REMOVE_DEVICE) ) {

        DBGPRINT( DBG_PNP, DBG_VERBOSE, ("RamdiskPnp: rejecting IRP %d for Removed Device\n",
                    irpSp->MinorFunction) );

        status = STATUS_NO_SUCH_DEVICE;
        COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );

        return status;
    }

    //
    // Acquire the remove lock. If this fails, fail the I/O.
    //

    status = IoAcquireRemoveLock( &commonExtension->RemoveLock, Irp );

    if ( !NT_SUCCESS(status) ) {

        DBGPRINT( DBG_PNP, DBG_ERROR, ("RamdiskPnp: IoAcquireRemoveLock failed: %x\n", status) );

        COMPLETE_REQUEST( status, 0, Irp );

        return status;
    }

    //
    // Indicate that the remove lock is held.
    //

    lockHeld = TRUE;

    //
    // Dispatch based on the minor function.
    //

    switch ( irpSp->MinorFunction ) {
    
    case IRP_MN_START_DEVICE: 
    
        PRINT_CODE( IRP_MN_START_DEVICE );

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            //
            // Starting the bus device.
            //
            // Send the IRP down and wait for it to come back.
            //

            IoCopyCurrentIrpStackLocationToNext( Irp );

            KeInitializeEvent( &event, NotificationEvent, FALSE );
            
            IoSetCompletionRoutine(
                Irp,
                RamdiskIoCompletionRoutine,
                &event,
                TRUE,
                TRUE,
                TRUE
                );

            status = IoCallDriver( commonExtension->LowerDeviceObject, Irp );

            if ( status == STATUS_PENDING ) {

                KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
                status = Irp->IoStatus.Status;
            }

            if ( NT_SUCCESS(status) ) {

                //
                // Lower drivers didn't fail the IRP. Start the interface.
                //

                status = IoSetDeviceInterfaceState( &commonExtension->InterfaceString, TRUE );

                if ( !NT_SUCCESS(status) ) {

                    DBGPRINT( DBG_PNP, DBG_ERROR,
                                ("IoSetDeviceInterfaceState FAILED Status = 0x%x\n", status) );
                }

                //
                // Device started successfully.
                //

                commonExtension->DeviceState = RamdiskDeviceStateWorking;
            }

        } else {

            //
            // Starting a RAM disk.
            //
            // Register the device interface. If it's an emulated disk, use the
            // private RAM disk interface GUID. If it's an emulated volume, use
            // the systemwide volume GUID.
            //

            if ( commonExtension->InterfaceString.Buffer != NULL ) {
                FREE_POOL( commonExtension->InterfaceString.Buffer, FALSE );
            }

            status = IoRegisterDeviceInterface(
                        DeviceObject,
                        diskExtension->DiskType == RAMDISK_TYPE_FILE_BACKED_DISK ?
                            &RamdiskDiskInterface :
                            &VolumeClassGuid,
                        NULL,
                        &commonExtension->InterfaceString
                        );

            if ( !NT_SUCCESS(status) ) {

                DBGPRINT( DBG_PNP, DBG_ERROR,
                            ("IoRegisterDeviceInterface FAILED Status = 0x%x\n", status) );
            }

            //
            // Start the interface.
            //

            if ( !diskExtension->Options.Hidden &&
                 (commonExtension->InterfaceString.Buffer != NULL) ) {

                ULONG installState;
                ULONG resultLength;

                status = IoGetDeviceProperty(
                            DeviceObject,
                            DevicePropertyInstallState,
                            sizeof(installState),
                            &installState,
                            &resultLength
                            );

                if ( !NT_SUCCESS(status) ) {

                    DBGPRINT( DBG_PNP, DBG_ERROR,
                                ("IoGetDeviceProperty FAILED Status = 0x%x\n", status) );

                    //
                    // If we can't get the install state, we set the interface
                    // state to TRUE anyway, just to be safe.
                    //

                    installState = InstallStateInstalled;
                }

                if ( installState == InstallStateInstalled ) {

                    DBGPRINT( DBG_PNP, DBG_INFO,
                            ("%s", "Calling IoSetDeviceInterfaceState(TRUE)\n") );
                    status = IoSetDeviceInterfaceState( &commonExtension->InterfaceString, TRUE );

                    if ( !NT_SUCCESS(status) ) {

                        DBGPRINT( DBG_PNP, DBG_ERROR,
                                    ("IoSetDeviceInterfaceState FAILED Status = 0x%x\n", status) );
                    }

                } else {

                    DBGPRINT( DBG_PNP, DBG_INFO,
                            ("Skipping IoSetDeviceInterfaceState; state = 0x%x\n", installState) );
                }
            }

            //
            // Device started successfully.
            //

            commonExtension->DeviceState = RamdiskDeviceStateWorking;
        }

        //
        // Complete the I/O request.
        //

        COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );

        break;

    case IRP_MN_QUERY_STOP_DEVICE: 
    
        PRINT_CODE( IRP_MN_QUERY_STOP_DEVICE );

        //
        // Mark that a stop is pending.
        //

        commonExtension->DeviceState = RamdiskDeviceStatePendingStop;

        //
        // Indicate success. Send the IRP on down the stack.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        goto send_irp_down;

    case IRP_MN_CANCEL_STOP_DEVICE: 
    
        PRINT_CODE( IRP_MN_CANCEL_STOP_DEVICE );

        //
        // Before sending the IRP down make sure we have received 
        // a IRP_MN_QUERY_STOP_DEVICE. We may get Cancel Stop 
        // without receiving a Query Stop earlier, if the 
        // driver on top fails a Query Stop and passes down the
        // Cancel Stop.
        //

        if ( commonExtension->DeviceState == RamdiskDeviceStatePendingStop ) {

            //
            // Mark that the device is back in the working state, and
            // pass the IRP down.
            //

            commonExtension->DeviceState = RamdiskDeviceStateWorking;

            Irp->IoStatus.Status = STATUS_SUCCESS;

            goto send_irp_down;

        } else {

            //
            // A spurious Cancel Stop request. Just complete it.
            //

            status = STATUS_SUCCESS;
            COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );
        }

        break;

    case IRP_MN_STOP_DEVICE: 
    
        PRINT_CODE( IRP_MN_STOP_DEVICE );

        //
        // Mark that the device is now stopped. Send the IRP on down the stack.
        //

        commonExtension->DeviceState = RamdiskDeviceStateStopped;

        Irp->IoStatus.Status = STATUS_SUCCESS;

        goto send_irp_down;

    case IRP_MN_QUERY_REMOVE_DEVICE: 
    
        PRINT_CODE( IRP_MN_QUERY_REMOVE_DEVICE );

        //
        // Mark that the device is pending removal. Send the IRP on down the
        // stack.
        //

        commonExtension->DeviceState = RamdiskDeviceStatePendingRemove;

        Irp->IoStatus.Status = STATUS_SUCCESS;

        goto send_irp_down;

    case IRP_MN_CANCEL_REMOVE_DEVICE: 
    
        PRINT_CODE( IRP_MN_CANCEL_REMOVE_DEVICE );

        //
        // Before sending the IRP down make sure we have received 
        // a IRP_MN_QUERY_REMOVE_DEVICE. We may get Cancel Remove 
        // without receiving a Query Remove earlier, if the 
        // driver on top fails a Query Remove and passes down the
        // Cancel Remove.
        //

        if ( commonExtension->DeviceState == RamdiskDeviceStatePendingRemove ) {

            //
            // Mark that the device is back in the working state. Send the
            // IRP on down the stack.
            //

            commonExtension->DeviceState = RamdiskDeviceStateWorking;

            Irp->IoStatus.Status = STATUS_SUCCESS;
    
            goto send_irp_down;
    
        } else {

            //
            // A spurious Cancel Remove request. Just complete it.
            //

            status = STATUS_SUCCESS;
            COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );
        }

        break;

    case IRP_MN_SURPRISE_REMOVAL: 
    
        PRINT_CODE( IRP_MN_SURPRISE_REMOVAL );

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            //
            // Mark that the device has been removed, and
            // pass the IRP down.
            //

            commonExtension->DeviceState = RamdiskDeviceStateSurpriseRemoved;

            Irp->IoStatus.Status = STATUS_SUCCESS;
    
            goto send_irp_down;
    
        } else {

            //
            // Ignore surprise removal for disk PDOs.
            //

            ASSERT( FALSE );

            status = STATUS_SUCCESS;
            COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );
        }

        break;

    case IRP_MN_REMOVE_DEVICE: 
    
        PRINT_CODE( IRP_MN_REMOVE_DEVICE );

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            //
            // Remove the bus FDO.
            //
            // Note that RamdiskRemoveBusDevice() sends the IRP down the
            // device stack, so we don't complete the IRP here.
            //

            status = RamdiskRemoveBusDevice( DeviceObject, Irp );

        } else {

            //
            // Remove a disk PDO.
            //

            status = RamdiskDeleteDiskDevice( DeviceObject, Irp );

            COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );
        }

        //
        // The remove lock was released by RamdiskRemoveBusDevice or
        // RamdiskDeleteDiskDevice.
        //

        lockHeld = FALSE;

        break;

    case IRP_MN_EJECT:
    
        PRINT_CODE( IRP_MN_EJECT );

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            //
            // Ignore eject for the bus FDO. Just send the IRP down.
            //

            Irp->IoStatus.Status = STATUS_SUCCESS;
    
            goto send_irp_down;
    
        } else {

            //
            // Ignore eject for a disk PDO, too. Don't send the IRP down.
            //

            status = STATUS_SUCCESS;
            COMPLETE_REQUEST( status, 0, Irp );
        }

        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        //
        // Let RamdiskQueryDeviceRelations() do the work. Note that it
        // completes the IRP.
        //

        status = RamdiskQueryDeviceRelations(
                    irpSp->Parameters.QueryDeviceRelations.Type,
                    DeviceObject,
                    Irp
                    );

        break;

    case IRP_MN_QUERY_DEVICE_TEXT:

        //
        // For the bus FDO, just pass the IRP down. For a disk PDO, let
        // RamdiskQueryDeviceText() do the work and complete the IRP.
        //

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            goto send_irp_down;

        } else {

            status = RamdiskQueryDeviceText( diskExtension, Irp );
        }

        break;

    case IRP_MN_QUERY_BUS_INFORMATION:
    
        //
        // Let RamdiskQueryBusInformation() do the work. Note that it
        // completes the IRP.
        //

        status = RamdiskQueryBusInformation( DeviceObject, Irp );

        break;

    case IRP_MN_QUERY_CAPABILITIES:
    
        //
        // For the bus FDO, just pass the IRP down. For a disk PDO, let
        // RamdiskQueryCapabilities() do the work and complete the IRP.
        //

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            goto send_irp_down;

        } else {

            status = RamdiskQueryCapabilities( DeviceObject, Irp );
        }

        break;

    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

        //
        // We don't have any resources to add to whatever might already be
        // there, so just complete the IRP.
        //

        status = Irp->IoStatus.Status;
        COMPLETE_REQUEST( Irp->IoStatus.Status, Irp->IoStatus.Information, Irp );

        break;

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
    
        //
        // For the bus FDO, just pass the IRP down. For a disk PDO, just
        // complete the IRP.
        //

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            goto send_irp_down;

        } else {

            status = Irp->IoStatus.Status;
            COMPLETE_REQUEST( Irp->IoStatus.Status, Irp->IoStatus.Information, Irp );
        }

        break;

    case IRP_MN_QUERY_ID:
    
        //
        // For the bus FDO, just pass the IRP down. For a disk PDO, let
        // RamdiskQueryId() do the work and complete the IRP.
        //

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            goto send_irp_down;

        } else {

            status = RamdiskQueryId( diskExtension, Irp );
        }

        break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
    default: 
    
send_irp_down:

        //
        // If this is the bus FDO, and there is a lower device object,
        // send the IRP down to the next device. If this is a disk PDO,
        // just complete the IRP.
        //

        if ( (commonExtension->DeviceType == RamdiskDeviceTypeBusFdo) &&
             (commonExtension->LowerDeviceObject != NULL) ) {

            IoSkipCurrentIrpStackLocation( Irp );
            status = IoCallDriver( commonExtension->LowerDeviceObject, Irp );

        } else {

            status = Irp->IoStatus.Status;
            COMPLETE_REQUEST( Irp->IoStatus.Status, Irp->IoStatus.Information, Irp );
        }

        break;

    } // switch

    //
    // If the lock is still held, release it now.
    //

    if ( lockHeld ) {

        DBGPRINT( DBG_PNP, DBG_VERBOSE,
                    ("RamdiskPnp: done; Device State=%s\n",
                    StateTable[commonExtension->DeviceState]) );

        IoReleaseRemoveLock( &commonExtension->RemoveLock, Irp );
    }

    return status;

} // RamdiskPnp

NTSTATUS
RamdiskPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a power function.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PCOMMON_EXTENSION commonExtension;

    PAGED_CODE();

    DBGPRINT( DBG_POWER, DBG_VERBOSE,
                ("RamdiskPower: DO=(%p) Irp=(%p)\n", DeviceObject, Irp) );

    commonExtension = DeviceObject->DeviceExtension;

    if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

        //
        // This is the bus FDO. There's not much for us to do here.
        //
        // Start the next power IRP.
        //

        PoStartNextPowerIrp( Irp );

        //
        // If the device has been removed, the driver should not pass
        // the IRP down to the next lower driver.
        //

        if ( commonExtension->DeviceState >= RamdiskDeviceStateRemoved ) {

            status = STATUS_DELETE_PENDING;
            COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );

            return status;
        }

        //
        // Send the IRP on down the stack.
        //

        IoSkipCurrentIrpStackLocation( Irp );
        status = PoCallDriver( commonExtension->LowerDeviceObject, Irp );

    } else {

        PIO_STACK_LOCATION irpSp;
        POWER_STATE powerState;
        POWER_STATE_TYPE powerType;

        //
        // This is a request for a disk PDO.
        //
        // Get parameters from the IRP.
        //

        irpSp = IoGetCurrentIrpStackLocation( Irp );

        powerType = irpSp->Parameters.Power.Type;
        powerState = irpSp->Parameters.Power.State;

        //
        // Dispatch based on the minor function.
        //

        switch ( irpSp->MinorFunction ) {
        
        case IRP_MN_SET_POWER:

            //
            // For SET_POWER, we don't have to do anything but return success.
            //

            switch ( powerType ) {
            
            case DevicePowerState:
            case SystemPowerState:

                status = STATUS_SUCCESS;

                break;

            default:

                status = STATUS_NOT_SUPPORTED;

                break;
            }

            break;

        case IRP_MN_QUERY_POWER:

            //
            // For QUERY_POWER, we don't have to do anything but return
            // success.
            //

            status = STATUS_SUCCESS;

            break;

        case IRP_MN_WAIT_WAKE:
        case IRP_MN_POWER_SEQUENCE:
        default:

            status = STATUS_NOT_SUPPORTED;

            break;
        }

        if ( status != STATUS_NOT_SUPPORTED ) {

            Irp->IoStatus.Status = status;
        }

        PoStartNextPowerIrp( Irp );

        status = Irp->IoStatus.Status;
        COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );
    }

    DBGPRINT( DBG_POWER, DBG_VERBOSE, ("RamdiskPower: status = 0x%x\n", status) );

    return status;
    
} // RamdiskPower

NTSTATUS
RamdiskAddDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This routine is called by the PnP system to add a device.

    We expect to get this call exactly once, to add our bus PDO.

Arguments:

    DriverObject - a pointer to our driver object

    Pdo - a pointer to the PDO for the FDO that we create

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    UNICODE_STRING deviceName;
    PDEVICE_OBJECT fdo;
    PBUS_EXTENSION busExtension;
    PULONG bitmap;
    PLOADER_PARAMETER_BLOCK loaderBlock;

    PAGED_CODE();

    DBGPRINT( DBG_PNP, DBG_VERBOSE, ("%s", "RamdiskAddDevice: entered\n") );

    //
    // If we've already done this once, fail this call.
    //

    if ( RamdiskBusFdo != NULL ) {

        return STATUS_DEVICE_ALREADY_ATTACHED;
    }

#if SUPPORT_DISK_NUMBERS

    //
    // Allocate space for the disk numbers bitmap.
    //

    bitmap  = ALLOCATE_POOL( PagedPool, DiskNumbersBitmapSize, TRUE );

    if ( bitmap == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

#endif // SUPPORT_DISK_NUMBERS

    //
    // Create the bus device object.
    //
    // ISSUE: Apply an ACL to the bus device object. (Or does the next issue obviate this?)
    // ISSUE: We're supposed to use autogenerated names for FDOs. What is the
    //          harm in using our own name? (Benefit is that it's easier to
    //          find the device when creating/deleting disks.)
    //

    RtlInitUnicodeString( &deviceName, L"\\Device\\Ramdisk" );

    status = IoCreateDevice(
                 DriverObject,              // DriverObject
                 sizeof(BUS_EXTENSION),     // DeviceExtension
                 &deviceName,               // DeviceName
                 FILE_DEVICE_BUS_EXTENDER,  // DeviceType
                 FILE_DEVICE_SECURE_OPEN,   // DeviceCharacteristics
                 FALSE,                     // Exclusive
                 &fdo                       // DeviceObject
                 );

    if ( !NT_SUCCESS(status) ) {

        DBGPRINT( DBG_PNP, DBG_ERROR, ("RamdiskAddDevice: error %x creating bus FDO\n", status) );

#if SUPPORT_DISK_NUMBERS
        FREE_POOL( bitmap, TRUE );
#endif // SUPPORT_DISK_NUMBERS

        return status;
    }

    busExtension = fdo->DeviceExtension;
    RtlZeroMemory( busExtension, sizeof(BUS_EXTENSION) );

    //
    // Initialize device object and extension.
    //

    //
    // Our device does direct I/O and is power pageable.
    //

    fdo->Flags |= DO_DIRECT_IO | DO_POWER_PAGABLE;

    //
    // Set the device type and state in the device extension. Initialize the
    // fast mutex and the remove lock. Initialize the disk PDO list.
    //

    busExtension->DeviceType = RamdiskDeviceTypeBusFdo;
    busExtension->DeviceState = RamdiskDeviceStateStopped;

    ExInitializeFastMutex( &busExtension->Mutex );
    IoInitializeRemoveLock( &busExtension->RemoveLock, 'dmaR', 1, 0 );

    InitializeListHead( &busExtension->DiskPdoList );

    //
    // Save object pointers. The PDO for this extension is the PDO that
    // was passed in. The FDO is the device object that we just created. The
    // lower device object will be set later.
    //
    
    busExtension->Pdo = Pdo;
    busExtension->Fdo = fdo;

    //
    // Register the device interface.
    //

    status = IoRegisterDeviceInterface(
                Pdo,
                &RamdiskBusInterface,
                NULL,
                &busExtension->InterfaceString
                );

    if ( !NT_SUCCESS(status) ) {

        DBGPRINT( DBG_PNP, DBG_ERROR,
                    ("RamdiskAddDevice: error %x registering device interface for bus FDO\n",
                    status) );

        IoDeleteDevice( fdo );

#if SUPPORT_DISK_NUMBERS
        FREE_POOL( bitmap, TRUE );
#endif // SUPPORT_DISK_NUMBERS

        return status;
    }

    //
    // Attach the FDO to the PDO's device stack. Remember the lower device
    // object to which we are to forward PnP IRPs.
    //

    busExtension->LowerDeviceObject = IoAttachDeviceToDeviceStack( fdo, Pdo );

    if ( busExtension->LowerDeviceObject == NULL ) {

        DBGPRINT( DBG_PNP, DBG_ERROR,
                    ("%s", "RamdiskAddDevice: error attaching bus FDO to PDO stack\n") );

        //
        // Tell PnP that we're not going to be activating the interface that
        // we just registered. Free the symbolic link string associated with
        // the interface. Delete the device object.
        //

        IoSetDeviceInterfaceState( &busExtension->InterfaceString, FALSE );

        RtlFreeUnicodeString( &busExtension->InterfaceString );

        IoDeleteDevice( fdo );

#if SUPPORT_DISK_NUMBERS
        FREE_POOL( bitmap, TRUE );
#endif // SUPPORT_DISK_NUMBERS

        return STATUS_NO_SUCH_DEVICE;
    }

#if SUPPORT_DISK_NUMBERS

    //
    // Initialize the disk numbers bitmap.
    //

    busExtension->DiskNumbersBitmapBuffer = bitmap;
    RtlInitializeBitMap( &busExtension->DiskNumbersBitmap, bitmap, DiskNumbersBitmapSize );
    RtlClearAllBits( &busExtension->DiskNumbersBitmap );

#endif // SUPPORT_DISK_NUMBERS

    RamdiskBusFdo = fdo;

    //
    // If textmode setup is running, create any RAM disks specified in the
    // registry.
    //

    loaderBlock = *(PLOADER_PARAMETER_BLOCK *)KeLoaderBlock;

    if ( (loaderBlock != NULL) && (loaderBlock->SetupLoaderBlock != NULL) ) {

        CreateRegistryDisks( FALSE );
    }

    //
    // Indicate that we're done initializing the device.
    //

    fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;

} // RamdiskAddDevice

BOOLEAN
CreateRegistryDisks (
    IN BOOLEAN CheckPresenceOnly
    )

/*++

Routine Description:

    This routine creates virtual floppy disks specified in the registry.
    It is called only during textmode setup.

Arguments:

    CheckPresenceOnly - indicates whether this routine should just check for
        the presence of at least one disk in the registry

Return Value:

    BOOLEAN - indicates whether any disks were specified in the registry

--*/

{
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING string;
    HANDLE serviceHandle;
    HANDLE parametersHandle;
    ULONG diskNumber;
    WCHAR valueNameBuffer[15];
    UNICODE_STRING valueName;
    UCHAR valueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(VIRTUAL_FLOPPY_DESCRIPTOR)];
    PKEY_VALUE_PARTIAL_INFORMATION value;
    PVIRTUAL_FLOPPY_DESCRIPTOR descriptor;
    ULONG valueLength;
    RAMDISK_CREATE_INPUT createInput;
    PDISK_EXTENSION diskExtension;
    BOOLEAN disksPresent = FALSE;
    HRESULT result;

    value = (PKEY_VALUE_PARTIAL_INFORMATION)valueBuffer;
    descriptor = (PVIRTUAL_FLOPPY_DESCRIPTOR)value->Data;

    //
    // Open the driver's key under Services.
    //

    InitializeObjectAttributes( &obja, &DriverRegistryPath, OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = ZwOpenKey( &serviceHandle, KEY_READ, &obja );

    if ( !NT_SUCCESS(status) ) {

        DBGPRINT( DBG_INIT, DBG_ERROR, ("CreateRegistryDisks: ZwOpenKey(1) failed: %x\n", status) );

        return FALSE;
    }

    //
    // Open the Parameters subkey.
    //

    RtlInitUnicodeString( &string, L"Parameters" );
    InitializeObjectAttributes( &obja, &string, OBJ_CASE_INSENSITIVE, serviceHandle, NULL );

    status = ZwOpenKey( &parametersHandle, KEY_READ, &obja );

    NtClose( serviceHandle );

    if ( !NT_SUCCESS(status) ) {

        DBGPRINT( DBG_INIT, DBG_ERROR, ("CreateRegistryDisks: ZwOpenKey(2) failed: %x\n", status) );

        return FALSE;
    }

    //
    // Initialize static fields in the CREATE_INPUT structure that we'll pass
    // to RamdiskCreateDiskDevice.
    //

    RtlZeroMemory( &createInput, sizeof(createInput) );
    createInput.DiskType = RAMDISK_TYPE_VIRTUAL_FLOPPY;
    createInput.Options.Fixed = TRUE;
    createInput.Options.NoDriveLetter = TRUE;

    //
    // Look for values named DISKn, where n starts at 0 and increases by 1
    // each loop. Break out as soon as the expected DISKn is not found.
    // (If values named DISK0 and DISK2 are present, only DISK0 will be
    // created -- DISK2 will not be found.)
    //

    diskNumber = 0;

    while ( TRUE ) {

        // This variable is here to keep PREfast quiet (PREfast warning 209).
        size_t size = sizeof(valueNameBuffer);

        result = StringCbPrintfW(
                    valueNameBuffer,
                    size,
                    L"DISK%u",
                    diskNumber
                    );
        ASSERT( result == S_OK );

        RtlInitUnicodeString( &valueName, valueNameBuffer );

        status = ZwQueryValueKey(
                    parametersHandle,
                    &valueName,
                    KeyValuePartialInformation,
                    value,
                    sizeof(valueBuffer),
                    &valueLength
                    );

        if ( !NT_SUCCESS(status) ) {

            if ( status != STATUS_OBJECT_NAME_NOT_FOUND ) {

                DBGPRINT( DBG_INIT, DBG_ERROR,
                            ("CreateRegistryDisks: ZwQueryValueKey failed: %x\n", status) );
            }

            break;
        }

        //
        // We've found a DISKn value in the registry. For the purposes of
        // the CheckPresenceOnly flag, this is enough to know that at least
        // one virtual floppy disk is present. We don't care whether the
        // data is valid -- we just need to know that it's there.
        //

        disksPresent = TRUE;

        //
        // If we're just checking for the presence of at least one disk, we
        // can leave now.
        //

        if ( CheckPresenceOnly ) {

            break;
        }

        //
        // We expect the value to be a REG_BINARY with the correct length.
        // We don't explicitly check the value type; we assume that the
        // length check is sufficient. We also expect the base address
        // (which is a system virtual address -- either in KSEG0 or in
        // nonpaged pool) and the length to be nonzero.
        //

        if ( value->DataLength != FIELD_OFFSET(VIRTUAL_FLOPPY_DESCRIPTOR, StructSizer) ) {

            DBGPRINT( DBG_INIT, DBG_ERROR,
                        ("CreateRegistryDisks: key length wrong, wanted 0x%x, got 0x%x\n",
                            sizeof(VIRTUAL_FLOPPY_DESCRIPTOR), valueLength) );

        } else if ( (descriptor->VirtualAddress == NULL) || (descriptor->Length == 0) ) {

            DBGPRINT( DBG_INIT, DBG_ERROR,
                        ("CreateRegistryDisks: address (%x) or length (0x%x) invalid\n",
                            descriptor->VirtualAddress, descriptor->Length) );

        } else {

            //
            // Create a virtual floppy RAM disk at the specified address and
            // with the specified length. Pass the disk number in the GUID.
            //

            createInput.DiskGuid.Data1 = diskNumber;
            createInput.DiskLength = descriptor->Length;
            createInput.BaseAddress = descriptor->VirtualAddress;

            DBGPRINT( DBG_INIT, DBG_INFO,
                        ("CreateRegistryDisks: creating virtual floppy #%d at %p for %x\n",
                            diskNumber, descriptor->VirtualAddress, descriptor->Length) );

            ASSERT( RamdiskBusFdo != NULL );
            ASSERT( RamdiskBusFdo->DeviceExtension != NULL );

            status = RamdiskCreateDiskDevice(
                        RamdiskBusFdo->DeviceExtension,
                        &createInput,
                        FALSE,
                        &diskExtension
                        );
    
            if ( !NT_SUCCESS(status) ) {
    
                DBGPRINT( DBG_INIT, DBG_ERROR,
                            ("CreateRegistryDisks: RamdiskCreateDiskDevice failed: %x\n", status) );
            }
        }

        diskNumber++;
    }

    //
    // Close the Parameters key and return.
    //

    NtClose( parametersHandle );

    return disksPresent;

} // CreateRegistryDisks

NTSTATUS
RamdiskDeleteDiskDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp OPTIONAL
    )

/*++

Routine Description:

    This routine is called to delete a RAM disk device.

    NOTE: The remove lock is held on entry to this routine. It is released on
    exit. If Irp == NULL, the bus mutex is held on entry and released on exit.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request. If NULL, this
        is a call from RamdiskRemoveBusDevice().

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PDISK_EXTENSION diskExtension;
    PDISK_EXTENSION tempDiskExtension;
    PBUS_EXTENSION busExtension;
    PLIST_ENTRY listEntry;

    PAGED_CODE();

    DBGPRINT( DBG_PNP, DBG_VERBOSE, ("%s", "RamdiskDeleteDiskDevice\n") );

    diskExtension = DeviceObject->DeviceExtension;
    busExtension = diskExtension->Fdo->DeviceExtension;

    DBGPRINT( DBG_PNP, DBG_INFO,
                ("RamdiskDeleteDiskDevice: Deleting device %wZ\n", &diskExtension->DeviceName) );

    //
    // If no IRP was specified, then we delete the disk device unconditionally.
    // (It's a call from RamdiskRemoveBusDevice().) Otherwise, we need to check
    // whether we really want to delete the device now.
    //

    if ( Irp != NULL ) {

        Irp->IoStatus.Information = 0;

        //
        // Check to see if the device has been marked for removal. If not, 
        // ignore this IRP. We do this because user-mode PnP likes to remove
        // and immmediately recreate the devices that we materialize, but we
        // don't want to remove the device and lose the information about the
        // disk image.
        //
    
        if ( !diskExtension->MarkedForDeletion ) {

            //
            // This device has not really been removed, so ignore this IRP.
            // But do mark that the device is no longer claimed.
            //

            diskExtension->Status &= ~RAMDISK_STATUS_CLAIMED;

            IoReleaseRemoveLock( &diskExtension->RemoveLock, Irp );

            return STATUS_SUCCESS;
        }

        //
        // The device has been marked for deletion, so it's OK for PnP to be
        // trying to remove it. If this is PnP's first attempt at removing the
        // device, just mark it as removed and tell PnP to reenumerate the
        // bus. During reenumeration, we will skip this device, and PnP will
        // come back with another remove IRP.
        //

        if ( diskExtension->DeviceState < RamdiskDeviceStateRemoved ) {

            diskExtension->DeviceState = RamdiskDeviceStateRemoved;

            busExtension = diskExtension->Fdo->DeviceExtension;
            IoInvalidateDeviceRelations( busExtension->Pdo, BusRelations );

            IoReleaseRemoveLock( &diskExtension->RemoveLock, Irp );

            return STATUS_SUCCESS;
        }

        //
        // If the device is marked as removed, but it hasn't yet been skipped
        // in a bus enumeration, don't do anything now.
        //

        if ( diskExtension->DeviceState == RamdiskDeviceStateRemoved ) {

            IoReleaseRemoveLock( &diskExtension->RemoveLock, Irp );

            return STATUS_SUCCESS;
        }

        //
        // If we get here, we have already skipped this device in a bus
        // enumeration, so it's time to delete it. Acquire the bus mutex
        // so that we can do this.
        //

        KeEnterCriticalRegion();
        ExAcquireFastMutex( &busExtension->Mutex );
    }

    //
    // If we get here, we really do want to delete this device. If we've
    // already deleted it, don't do it again.
    //

    if ( diskExtension->DeviceState >= RamdiskDeviceStateDeleted ) {

        DBGPRINT( DBG_PNP, DBG_INFO,
                    ("RamdiskDeleteDiskDevice: device %wZ has already been deleted\n",
                    &diskExtension->DeviceName) );

        //
        // Release the bus mutex and the remove lock.
        //

        ExReleaseFastMutex( &busExtension->Mutex );
        KeLeaveCriticalRegion();
    
        IoReleaseRemoveLock( &diskExtension->RemoveLock, Irp );

        return STATUS_SUCCESS;
    }

    //
    // Indicate that the device has been deleted.
    //

    diskExtension->DeviceState = RamdiskDeviceStateDeleted;

    //
    // Remove the disk PDO from the bus FDO's list.
    //

    for ( listEntry = busExtension->DiskPdoList.Flink;
          listEntry != &busExtension->DiskPdoList;
          listEntry = listEntry->Flink ) {

        tempDiskExtension = CONTAINING_RECORD( listEntry, DISK_EXTENSION, DiskPdoListEntry );

        if ( tempDiskExtension == diskExtension ) {

            RemoveEntryList( listEntry );

#if SUPPORT_DISK_NUMBERS
            RtlClearBit( &busExtension->DiskNumbersBitmap, diskExtension->DiskNumber - 1 );
#endif // SUPPORT_DISK_NUMBERS

            break;
        }
    }

    //
    // We no longer need to hold the bus mutex and the remove lock.
    //

    ExReleaseFastMutex( &busExtension->Mutex );
    KeLeaveCriticalRegion();

    IoReleaseRemoveLockAndWait( &diskExtension->RemoveLock, Irp );

    //
    // If the interface has been started, stop it now.
    //

    if ( diskExtension->InterfaceString.Buffer != NULL ) {

        if ( !diskExtension->Options.Hidden ) {
            status = IoSetDeviceInterfaceState( &diskExtension->InterfaceString, FALSE );
        }

        RtlFreeUnicodeString( &diskExtension->InterfaceString );
    }

    //
    // Close the file backing the RAM disk, if any.
    //

    if ( diskExtension->SectionObject != NULL ) {

        if ( diskExtension->ViewDescriptors != NULL ) {

            //
            // Clean up the mapped views.
            //

            PVIEW view;

            ASSERT( diskExtension->ViewWaiterCount == 0 );

            while ( !IsListEmpty( &diskExtension->ViewsByOffset ) ) {

                listEntry = RemoveHeadList( &diskExtension->ViewsByOffset );
                view = CONTAINING_RECORD( listEntry, VIEW, ByOffsetListEntry );

                RemoveEntryList( &view->ByMruListEntry );

                ASSERT( view->ReferenceCount == 0 );

                if ( view->Address != NULL ) {

                    DBGPRINT( DBG_WINDOW, DBG_VERBOSE,
                                ("RamdiskDeleteDiskDevice: unmapping view %p; addr %p\n",
                                    view, view->Address) );

                    MmUnmapViewOfSection( PsGetCurrentProcess(), view->Address );
                }
            }

            ASSERT( IsListEmpty( &diskExtension->ViewsByMru ) );

            FREE_POOL( diskExtension->ViewDescriptors, TRUE );
        }

        ObDereferenceObject( diskExtension->SectionObject );
    }

    if ( !diskExtension->Options.NoDosDevice ) {
    
        //
        // Delete the DosDevices symbolic link.
        //

        ASSERT( diskExtension->DosSymLink.Buffer != NULL );

        status = IoDeleteSymbolicLink( &diskExtension->DosSymLink );

        if ( !NT_SUCCESS(status) ) {

            DBGPRINT( DBG_PNP, DBG_ERROR,
                        ("RamdiskDeleteDiskDevice: IoDeleteSymbolicLink failed: %x\n", status) );
        }

        FREE_POOL( diskExtension->DosSymLink.Buffer, TRUE );
    }
                
    //
    // Delete the device name string and the GUID string.
    //

    if ( diskExtension->DeviceName.Buffer != NULL ) {

        FREE_POOL( diskExtension->DeviceName.Buffer, TRUE );
    }

    if ( diskExtension->DiskGuidFormatted.Buffer != NULL ) {

        FREE_POOL( diskExtension->DiskGuidFormatted.Buffer, FALSE );
    }

    //
    // Delete the device object.
    //

    IoDeleteDevice( DeviceObject );

    return STATUS_SUCCESS;

} // RamdiskDeleteDiskDevice

NTSTATUS
RamdiskIoCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This internal routine is used as the I/O completion routine when we send
    an IRP down the device stack and want to short-circuit IRP completion so
    that we can do more work.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request

    Event - a pointer to an event that is to be set to signal the calling code
        that the lower layers have completed the IRP

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    //
    // Set the event to signal the IRP issuer that it's time to continue.
    //

    KeSetEvent( Event, 0, FALSE );

    //
    // Tell the I/O system to stop completing the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // RamdiskIoCompletionRoutine

NTSTATUS
RamdiskQueryBusInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine processes the IRP_MN_QUERY_BUS_INFORMATION IRP.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PPNP_BUS_INFORMATION busInformation;

    PAGED_CODE();

    DBGPRINT( DBG_PNP, DBG_VERBOSE,
                ("RamdiskQueryBusInformation: DO (0x%p) Type 0x%x\n",
                DeviceObject, ((PCOMMON_EXTENSION)DeviceObject->DeviceExtension)->DeviceType) );

    //
    // Allocate a buffer to use for returning the requested information.
    //

    busInformation = ALLOCATE_POOL( PagedPool, sizeof(PNP_BUS_INFORMATION), FALSE );

    if ( busInformation == NULL ) {

        //
        // Fail the IRP.
        //
        
        status = STATUS_INSUFFICIENT_RESOURCES;
        COMPLETE_REQUEST( status, 0, Irp );

        return status;
    }

    //
    // Fill in the requested information.
    //

    busInformation->BusTypeGuid = GUID_BUS_TYPE_RAMDISK;
    busInformation->LegacyBusType = PNPBus;
    busInformation->BusNumber = 0x00;

    //
    // Complete the IRP.
    //

    status = STATUS_SUCCESS;
    COMPLETE_REQUEST( status, (ULONG_PTR)busInformation, Irp );

    return status;
    
} // RamdiskQueryBusInformation

NTSTATUS
RamdiskQueryCapabilities (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine processes the IRP_MN_QUERY_CAPABILITIES IRP.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_CAPABILITIES deviceCapabilities;
    PDISK_EXTENSION diskExtension;

    PAGED_CODE();

    DBGPRINT( DBG_PNP, DBG_VERBOSE, ("%s", "RamdiskQueryCapabilities\n") );

    //
    // Get a pointer to the device extension and get parameters from the IRP.
    //

    diskExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    deviceCapabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;

    if ( (deviceCapabilities->Version != 1) ||
         (deviceCapabilities->Size < sizeof(DEVICE_CAPABILITIES)) ) {

        //
        // We don't support this version. Fail the request.
        //

        status = STATUS_UNSUCCESSFUL;

    } else {

        status = STATUS_SUCCESS;

        //
        // If this is an emulated volume, we want to allow access to the raw
        // device. (Otherwise PnP won't start the device.)
        //
        // Note that a RAM disk boot disk is an emulated volume.
        //

        deviceCapabilities->RawDeviceOK =
            (BOOLEAN)(diskExtension->DiskType != RAMDISK_TYPE_FILE_BACKED_DISK);

        //
        // Indicate that ejection is not supported.
        //

        deviceCapabilities->EjectSupported = FALSE;
    
        //
        // This flag specifies whether the device's hardware is disabled.
        // The PnP Manager only checks this bit right after the device is
        // enumerated. Once the device is started, this bit is ignored. 
        //

        deviceCapabilities->HardwareDisabled = FALSE;
    
        //
        // Indicate that the emulated device cannot be physically removed.
        // (Unless the right registry key was specified...)
        //

        deviceCapabilities->Removable = MarkRamdisksAsRemovable;

        //
        // Setting SurpriseRemovalOK to TRUE prevents the warning dialog from
        // appearing whenever the device is surprise removed. Setting it FALSE
        // allows the Hot unplug applet to stop the device.
        //
        // We don't want our disks to show up in the systray, so we set
        // SurpriseRemovalOK to TRUE. There is never really any surprise
        // removal anyway -- removal comes from the user mode control app
        // calling CM_Query_And_Remove_SubTree_Ex().
        //

        deviceCapabilities->SurpriseRemovalOK = TRUE;

        //
        // We support system-wide unique IDs. 
        //
        
        deviceCapabilities->UniqueID = TRUE;

        //
        // Indicate that the Device Manager should suppress all 
        // installation pop-ups except required pop-ups such as 
        // "no compatible drivers found." 
        //

        deviceCapabilities->SilentInstall = TRUE;

        //
        // Indicate that we do not want this device displayed in
        // Device Manager.
        //

        deviceCapabilities->NoDisplayInUI = TRUE;
    }

    //
    // Complete the request.
    //

    COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );

    return status;
    
} // RamdiskQueryCapabilities

NTSTATUS
RamdiskQueryId (
    IN PDISK_EXTENSION DiskExtension,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine processes the IRP_MN_QUERY_ID IRP for disk devices.

Arguments:

    DiskExtension - a pointer to the device extension for the device object on
        which the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
#define MAX_LOCAL_STRING 50

    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PWCHAR buffer;
    PWCHAR p;
    ULONG length;
    PWCHAR deviceType;
    HRESULT result;

    PAGED_CODE();

    DBGPRINT( DBG_PNP, DBG_VERBOSE, ("%s", "RamdiskQueryId\n") );

    //
    // Assume success.
    //

    status = STATUS_SUCCESS;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Dispatch based on the query type.
    //

    switch ( irpSp->Parameters.QueryId.IdType ) {
    
    case BusQueryDeviceID:

        //
        // DeviceID is a string to identify a device. We return the string
        // "Ramdisk\RamVolume" or "Ramdisk\RamDisk".
        //
        // Allocate pool to hold the string.
        //

        length = sizeof(RAMDISK_ENUMERATOR_TEXT) - sizeof(WCHAR) +
                    ((DiskExtension->DiskType == RAMDISK_TYPE_FILE_BACKED_DISK) ?
                        sizeof(RAMDISK_DISK_DEVICE_TEXT) : sizeof(RAMDISK_VOLUME_DEVICE_TEXT));

        buffer = ALLOCATE_POOL( PagedPool, length, FALSE );

        if ( buffer == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Copy the string into the destination buffer.
        //

        result = StringCbCopyW( buffer, length, RAMDISK_ENUMERATOR_TEXT );
        ASSERT( result == S_OK );
        result = StringCbCatW(
                    buffer,
                    length,
                    (DiskExtension->DiskType == RAMDISK_TYPE_FILE_BACKED_DISK) ?
                        RAMDISK_DISK_DEVICE_TEXT : RAMDISK_VOLUME_DEVICE_TEXT
                    );
        ASSERT( result == S_OK );
        ASSERT( ((wcslen(buffer) + 1) * sizeof(WCHAR)) == length );

        DBGPRINT( DBG_PNP, DBG_VERBOSE, ("BusQueryDeviceID=%S\n", buffer) );

        break;

    case BusQueryInstanceID:

        //
        // InstanceID is a string to identify the device instance. We return
        // the disk GUID in string form.
        //
        // Allocate pool to hold the string.
        //

        buffer = ALLOCATE_POOL( PagedPool, DiskExtension->DiskGuidFormatted.MaximumLength, FALSE );

        if ( buffer == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Copy the string into the destination buffer.
        //

        result = StringCbCopyW(
                    buffer,
                    DiskExtension->DiskGuidFormatted.MaximumLength,
                    DiskExtension->DiskGuidFormatted.Buffer
                    );
        ASSERT( result == S_OK );
        ASSERT( ((wcslen(buffer) + 1) * sizeof(WCHAR)) == DiskExtension->DiskGuidFormatted.MaximumLength );

        DBGPRINT( DBG_PNP, DBG_VERBOSE, ("BusQueryInstanceID=%S\n", buffer) );

        break;
   
    case BusQueryHardwareIDs:

        //
        // HardwareIDs is a multi-sz string to identify a device's hardware
        // type. We return the string "Ramdisk\RamVolume\0" or
        // "Ramdisk\RamDisk\0".
        //
        // Allocate pool to hold the string. Note that we allocate space
        // for two null terminators.
        //
        
        length = sizeof(RAMDISK_ENUMERATOR_TEXT) - sizeof(WCHAR) +
                 ((DiskExtension->DiskType == RAMDISK_TYPE_FILE_BACKED_DISK) ?
                     sizeof(RAMDISK_DISK_DEVICE_TEXT) : sizeof(RAMDISK_VOLUME_DEVICE_TEXT)) +
                 sizeof(WCHAR);

        buffer = ALLOCATE_POOL( PagedPool, length, FALSE );

        if ( buffer == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Copy the string into the destination buffer.
        //

        result = StringCbCopyW( buffer, length, RAMDISK_ENUMERATOR_TEXT );
        ASSERT( result == S_OK );
        result = StringCbCatW(
                    buffer,
                    length,
                    (DiskExtension->DiskType == RAMDISK_TYPE_FILE_BACKED_DISK) ?
                        RAMDISK_DISK_DEVICE_TEXT : RAMDISK_VOLUME_DEVICE_TEXT
                    );
        ASSERT( result == S_OK );
        ASSERT( ((wcslen(buffer) + 2) * sizeof(WCHAR)) == length );

        buffer[length/sizeof(WCHAR) - 1] = 0;

        DBGPRINT( DBG_PNP, DBG_VERBOSE, ("BusQueryHardwareIDs=%S\n", buffer) );

        break;

    case BusQueryCompatibleIDs:

        //
        // HardwareIDs is a multi-sz string to identify device classes that
        // are compatible with a device. For volume-emulating RAM disks, we
        // return no compatible IDs, so that the device stands on its own at
        // the volume level. For disk-emulating RAM disks, we return the
        // string "Gendisk\0", so that the device gets hooked in below disk.sys.
        //

        if ( DiskExtension->DiskType == RAMDISK_TYPE_FILE_BACKED_DISK ) {

            //
            // Disk emulation. Allocate pool to hold the string.
            //

            length = sizeof(L"GenDisk") + sizeof(WCHAR);

            buffer = ALLOCATE_POOL( PagedPool, length, FALSE );
    
            if ( buffer == NULL ) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
    
            //
            // Copy the string into the destination buffer.
            //
    
            result = StringCbCopyW( buffer, length, L"GenDisk" );
            ASSERT( result == S_OK );
            ASSERT( ((wcslen(buffer) + 2) * sizeof(WCHAR)) == length );

            buffer[length/sizeof(WCHAR) - 1] = 0;

        } else {

            //
            // Volume emulation. Do not return any compatible IDs.
            //

            buffer = NULL;

            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        DBGPRINT( DBG_PNP, DBG_VERBOSE, ("BusQueryCompatibleIDs=%S\n", buffer) );

        break;

    default:

        //
        // Unknown query type. Just leave whatever's already in the IRP there.
        //

        status = Irp->IoStatus.Status;
        buffer = (PWCHAR)Irp->IoStatus.Information;
    }

    //
    // Complete the request.
    //

    COMPLETE_REQUEST( status, (ULONG_PTR)buffer, Irp );

    return status;
    
} // RamdiskQueryId

NTSTATUS
RamdiskQueryDeviceRelations (
    IN DEVICE_RELATION_TYPE RelationsType,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine processes the IRP_MN_QUERY_DEVICE_RELATIONS IRP.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PCOMMON_EXTENSION commonExtension;
    PBUS_EXTENSION busExtension;
    PDISK_EXTENSION diskExtension;
    RAMDISK_DEVICE_TYPE deviceType;
    PLIST_ENTRY listEntry;
    PDEVICE_RELATIONS deviceRelations;
    PDEVICE_RELATIONS oldRelations;
    ULONG prevCount = 0;
    ULONG length = 0;
    ULONG numPdosPresent = 0;

    PAGED_CODE();

    //
    // Assume success.
    //

    status = STATUS_SUCCESS;

    //
    // Get the device extension pointer and save the device type.
    //

    commonExtension = (PCOMMON_EXTENSION)DeviceObject->DeviceExtension;
    deviceType = commonExtension->DeviceType;

    DBGPRINT( DBG_PNP, DBG_VERBOSE,
                ("RamdiskQueryDeviceRelations: QueryDeviceRelation Type: %s, DeviceType 0x%x\n", 
                GetDeviceRelationString(RelationsType), deviceType) );

    //
    // Dispatch based on the device type.
    //

    if ( deviceType == RamdiskDeviceTypeDiskPdo ) {

        //
        // It's a disk PDO. We only handle TargetDeviceRelation for PDOs.
        //

        diskExtension = (PDISK_EXTENSION)commonExtension;

        if ( RelationsType == TargetDeviceRelation ) {

            //
            // Allocate pool to hold the return information. (DEVICE_RELATIONS
            // has space for one entry built-in).
            //

            deviceRelations = ALLOCATE_POOL( PagedPool, sizeof(DEVICE_RELATIONS), FALSE );
                    
            if ( deviceRelations != NULL ) {

                //
                // Return a referenced pointer to the device object for this
                // device.
                //

                ObReferenceObject( DeviceObject );

                deviceRelations->Count = 1;
                deviceRelations->Objects[0] = DeviceObject;

                status = STATUS_SUCCESS;

            } else {

                //
                // Couldn't allocate pool.
                //

                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // Complete the request.
            //

            COMPLETE_REQUEST( status, (ULONG_PTR)deviceRelations, Irp );

        } else {

            //
            // PDOs just complete enumeration requests without altering
            // the status.
            //

            status = Irp->IoStatus.Status;
            COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );
        }

        return status;

    } else {

        //
        // It's the bus FDO. We only handle BusRelations for the FDO.
        //

        busExtension = (PBUS_EXTENSION)commonExtension;

        if ( RelationsType == BusRelations ) {

            //
            // Re-enumerate the device.
            //
            // Lock the disk PDO list.
            //

            KeEnterCriticalRegion();
            ExAcquireFastMutex( &busExtension->Mutex );

            //
            // There might also be device relations below and above this FDO,
            // so propagate the relations from the upper drivers.
            //

            oldRelations = (PDEVICE_RELATIONS)Irp->IoStatus.Information;

            if (oldRelations != NULL) {
                prevCount = oldRelations->Count; 
            } else {
                prevCount = 0;
            }

            // 
            // Calculate the number of PDOs actually present on the bus.
            // 

            numPdosPresent = 0;

            for ( listEntry = busExtension->DiskPdoList.Flink;
                  listEntry != &busExtension->DiskPdoList;
                  listEntry = listEntry->Flink ) {

                diskExtension = CONTAINING_RECORD( listEntry, DISK_EXTENSION, DiskPdoListEntry );

                if ( diskExtension->DeviceState < RamdiskDeviceStateRemoved ) {
                    numPdosPresent++;
                }
            }

            //
            // Allocate a new relations structure and add our PDOs to it.
            //

            length = sizeof(DEVICE_RELATIONS) +
                     ((numPdosPresent + prevCount - 1) * sizeof(PDEVICE_OBJECT));

            deviceRelations = ALLOCATE_POOL( PagedPool, length, FALSE );

            if ( deviceRelations == NULL ) {

                //
                // Fail the IRP.
                //

                ExReleaseFastMutex( &busExtension->Mutex );
                KeLeaveCriticalRegion();

                status = STATUS_INSUFFICIENT_RESOURCES;
                COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );

                return status;
            }

            //
            // Copy in the device objects so far.
            //

            if ( prevCount != 0 ) {

                RtlCopyMemory(
                    deviceRelations->Objects,
                    oldRelations->Objects,
                    prevCount * sizeof(PDEVICE_OBJECT)
                    );
            }
    
            deviceRelations->Count = prevCount + numPdosPresent;

            //
            // For each PDO present on this bus, add a pointer to the device
            // relations buffer, being sure to take out a reference to that
            // object. PnP will dereference the object when it is done with it
            // and free the device relations buffer.
            //

            for ( listEntry = busExtension->DiskPdoList.Flink;
                  listEntry != &busExtension->DiskPdoList;
                  listEntry = listEntry->Flink ) {

                diskExtension = CONTAINING_RECORD( listEntry, DISK_EXTENSION, DiskPdoListEntry );

                if ( diskExtension->DeviceState < RamdiskDeviceStateRemoved ) {

                    ObReferenceObject( diskExtension->Pdo );

                    deviceRelations->Objects[prevCount] = diskExtension->Pdo;

                    DBGPRINT( DBG_PNP, DBG_VERBOSE,
                                ("QueryDeviceRelations(BusRelations) PDO = 0x%p\n",
                                deviceRelations->Objects[prevCount]) );

                    prevCount++;

                } else {

                    if ( diskExtension->DeviceState == RamdiskDeviceStateRemoved ) {

                        diskExtension->DeviceState = RamdiskDeviceStateRemovedAndNotReported;
                    }

                    DBGPRINT( DBG_PNP, DBG_VERBOSE,
                                ("QueryDeviceRelations(BusRelations) PDO = 0x%p -- SKIPPED\n",
                                diskExtension->Pdo) );
                }
            }

            //
            // Release the lock.
            //

            ExReleaseFastMutex( &busExtension->Mutex );
            KeLeaveCriticalRegion();

            DBGPRINT( DBG_PNP, DBG_VERBOSE,
                        ("QueryDeviceRelations(BusRelations) Total #PDOs reported = %d, "
                        "%d were new\n",
                        deviceRelations->Count, numPdosPresent) );

            //
            // Replace the relations structure in the IRP with the new
            // one.
            //

            if ( oldRelations != NULL ) {
                FREE_POOL( oldRelations, FALSE );
            }

            Irp->IoStatus.Information = (ULONG_PTR)deviceRelations;
            Irp->IoStatus.Status = STATUS_SUCCESS;
        }

        //
        // Send the IRP down the device stack.
        //

        IoCopyCurrentIrpStackLocationToNext( Irp );
        status = IoCallDriver( busExtension->LowerDeviceObject, Irp );
    }

    return status;

} // RamdiskQueryDeviceRelations

NTSTATUS
RamdiskQueryDeviceText (
    IN PDISK_EXTENSION DiskExtension,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine processes the IRP_MN_QUERY_DEVICE_TEXT IRP.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    ULONG length;
    PWCHAR buffer;
    UNICODE_STRING tempString;
    HRESULT result;

    PAGED_CODE();

    DBGPRINT( DBG_PNP, DBG_VERBOSE, ("%s", "RamdiskQueryDeviceText\n") );

    //
    // Assume success.
    //

    status = STATUS_SUCCESS;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Dispatch based on the query type.
    //

    switch ( irpSp->Parameters.QueryDeviceText.DeviceTextType ) {
    
    case DeviceTextDescription:

        //
        // Description is just "RamDisk".
        //
        // Allocate pool to hold the string.
        //

        length = sizeof( RAMDISK_DISK_DEVICE_TEXT );

        buffer = ALLOCATE_POOL( PagedPool, length, FALSE );

        if ( buffer == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Copy the string into the destination buffer.
        //

        result = StringCbCopyW( buffer, length, RAMDISK_DISK_DEVICE_TEXT );
        ASSERT( result == S_OK );
        ASSERT( ((wcslen(buffer) + 1) * sizeof(WCHAR)) == length );

        break;

    case DeviceTextLocationInformation:

        //
        // LocationInformation is just "Ramdisk\\0".
        //
        // Allocate pool to hold the string.
        //

        length = sizeof( RAMDISK_ENUMERATOR_BUS_TEXT );

        buffer = ALLOCATE_POOL( PagedPool, length, FALSE );

        if ( buffer == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Copy the string into the destination buffer.
        //

        result = StringCbCopyW( buffer, length, RAMDISK_ENUMERATOR_BUS_TEXT );
        ASSERT( result == S_OK );
        ASSERT( ((wcslen(buffer) + 1) * sizeof(WCHAR)) == length );

        break;

    default:

        //
        // Unknown query type. Just leave whatever's already in the IRP there.
        //

        status = Irp->IoStatus.Status;
        buffer = (PWCHAR)Irp->IoStatus.Information;
    }

    //
    // Complete the request.
    //

    COMPLETE_REQUEST( status, (ULONG_PTR)buffer, Irp );

    return status;

} // RamdiskQueryDeviceText

NTSTATUS
RamdiskRemoveBusDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine removes the bus device.

    The remove lock must be held on entry.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PBUS_EXTENSION busExtension;
    PLIST_ENTRY listEntry;
    PDISK_EXTENSION diskExtension;

    PAGED_CODE();

    DBGPRINT( DBG_PNP, DBG_VERBOSE, ("%s", "RamdiskRemoveBusDevice\n" ) );

    //
    // Get a pointer to the device extension.
    //

    busExtension = DeviceObject->DeviceExtension;


    //
    // Lock the disk PDO list. Walk the list, deleting all remaining devices.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutex( &busExtension->Mutex );

    while ( !IsListEmpty( &busExtension->DiskPdoList ) ) {

        listEntry = busExtension->DiskPdoList.Flink;

        //
        // Delete the device and clean it up. Acquire the remove lock first.
        // RamdiskDeleteDiskDevice releases it.
        //

        diskExtension = CONTAINING_RECORD( listEntry, DISK_EXTENSION, DiskPdoListEntry );

        status = IoAcquireRemoveLock( &diskExtension->RemoveLock, NULL );
        ASSERT( NT_SUCCESS(status) );

        RamdiskDeleteDiskDevice( diskExtension->Pdo, NULL );

        KeEnterCriticalRegion();
        ExAcquireFastMutex( &busExtension->Mutex );
    }

    //
    // Release the lock.
    //

    ExReleaseFastMutex( &busExtension->Mutex );
    KeLeaveCriticalRegion();

    //
    // Pass the IRP on down to lower levels.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( busExtension->LowerDeviceObject, Irp );

    //
    // Set the device status to Removed and wait for other drivers 
    // to release the lock, then delete the device object.
    //

    busExtension->DeviceState = RamdiskDeviceStateRemoved;
    IoReleaseRemoveLockAndWait( &busExtension->RemoveLock, Irp );

    //
    // Stop the interface and free the interface string.
    //

    if ( busExtension->InterfaceString.Buffer != NULL ) {

        IoSetDeviceInterfaceState( &busExtension->InterfaceString, FALSE );

        RtlFreeUnicodeString( &busExtension->InterfaceString );
    }

    //
    // If attached to a lower device, detach now.
    //

    if ( busExtension->LowerDeviceObject != NULL ) {

        IoDetachDevice( busExtension->LowerDeviceObject );
    }

#if SUPPORT_DISK_NUMBERS

    //
    // Free the disk numbers bitmap.
    //

    ASSERT( !RtlAreBitsSet( &busExtension->DiskNumbersBitmap, 0, DiskNumbersBitmapSize ) );

    FREE_POOL( busExtension->DiskNumbersBitmapBuffer, TRUE );

#endif // SUPPORT_DISK_NUMBERS

    //
    // Indicate that we no longer have a bus FDO, and delete the device object.
    //

    RamdiskBusFdo = NULL;

    IoDeleteDevice( DeviceObject );

    DBGPRINT( DBG_PNP, DBG_NOTIFY, ("%s", "Device removed succesfully\n") );

    return status;
    
} // RamdiskRemoveBusDevice

#if DBG

PSTR
GetPnpIrpName (
    IN UCHAR PnpMinorFunction
    )
{
    static char functionName[25];
    HRESULT result;

    PAGED_CODE();

    switch ( PnpMinorFunction ) {

    case IRP_MN_START_DEVICE:

        return "IRP_MN_START_DEVICE";

    case IRP_MN_QUERY_REMOVE_DEVICE:

        return "IRP_MN_QUERY_REMOVE_DEVICE";

    case IRP_MN_REMOVE_DEVICE:

        return "IRP_MN_REMOVE_DEVICE";

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        return "IRP_MN_CANCEL_REMOVE_DEVICE";

    case IRP_MN_STOP_DEVICE:

        return "IRP_MN_STOP_DEVICE";

    case IRP_MN_QUERY_STOP_DEVICE:

        return "IRP_MN_QUERY_STOP_DEVICE";

    case IRP_MN_CANCEL_STOP_DEVICE:

        return "IRP_MN_CANCEL_STOP_DEVICE";

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        return "IRP_MN_QUERY_DEVICE_RELATIONS";

    case IRP_MN_QUERY_INTERFACE:

        return "IRP_MN_QUERY_INTERFACE";

    case IRP_MN_QUERY_CAPABILITIES:

        return "IRP_MN_QUERY_CAPABILITIES";

    case IRP_MN_QUERY_RESOURCES:

        return "IRP_MN_QUERY_RESOURCES";

    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

        return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";

    case IRP_MN_QUERY_DEVICE_TEXT:

        return "IRP_MN_QUERY_DEVICE_TEXT";

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:

        return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";

    case IRP_MN_READ_CONFIG:

        return "IRP_MN_READ_CONFIG";

    case IRP_MN_WRITE_CONFIG:

        return "IRP_MN_WRITE_CONFIG";

    case IRP_MN_EJECT:

        return "IRP_MN_EJECT";

    case IRP_MN_SET_LOCK:

        return "IRP_MN_SET_LOCK";

    case IRP_MN_QUERY_ID:

        return "IRP_MN_QUERY_ID";

    case IRP_MN_QUERY_PNP_DEVICE_STATE:

        return "IRP_MN_QUERY_PNP_DEVICE_STATE";

    case IRP_MN_QUERY_BUS_INFORMATION:

        return "IRP_MN_QUERY_BUS_INFORMATION";

    case IRP_MN_DEVICE_USAGE_NOTIFICATION:

        return "IRP_MN_DEVICE_USAGE_NOTIFICATION";

    case IRP_MN_SURPRISE_REMOVAL:

        return "IRP_MN_SURPRISE_REMOVAL";

    case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:

        return "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";

    default:

        result = StringCbPrintfA(
                    functionName,
                    sizeof( functionName ),
                    "Unknown PnP IRP 0x%02x",
                    PnpMinorFunction
                    );
        ASSERT( result == S_OK );

        return functionName;
    }

} // GetPnpIrpName

PCHAR
GetDeviceRelationString (
    IN DEVICE_RELATION_TYPE Type
    )
{
    static char relationName[30];
    HRESULT result;

    PAGED_CODE();

    switch ( Type ) {
    
    case BusRelations:

        return "BusRelations";

    case EjectionRelations:

        return "EjectionRelations";

    case RemovalRelations:

        return "RemovalRelations";

    case TargetDeviceRelation:

        return "TargetDeviceRelation";

    default:

        result = StringCbPrintfA(
                    relationName,
                    sizeof( relationName ),
                    "Unknown relation 0x%02x",
                    Type
                    );
        ASSERT( result == S_OK );

        return relationName;
    }

} // GetDeviceRelationString

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ramdisk\ramdisk.c ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    ramdisk.c

Abstract:

    This is the RAM disk driver for Windows.

Author:

    Chuck Lenzmeier (ChuckL) 2001
        based on prototype XIP driver by DavePr
            based on NT4 DDK ramdisk by RobertN

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <initguid.h>
#include <ntddstor.h>
#include <ntddramd.h>

//
// ISSUE: 2000/10/11-DavePr -- haven't decided how to define DO_XIP appropriately.
//
#ifndef DO_XIP
#define DO_XIP 0x00020000
#endif

//
// Data declarations.
//

PDEVICE_OBJECT RamdiskBusFdo = NULL;

BOOLEAN ReportDetectedDevice;

ULONG MinimumViewCount;
ULONG DefaultViewCount;
ULONG MaximumViewCount;
ULONG MinimumViewLength;
ULONG DefaultViewLength;
ULONG MaximumViewLength;

ULONG MaximumPerDiskViewLength;

UNICODE_STRING DriverRegistryPath;
BOOLEAN MarkRamdisksAsRemovable;

#if SUPPORT_DISK_NUMBERS

ULONG DiskNumbersBitmapSize;

#endif // SUPPORT_DISK_NUMBERS

#if DBG

ULONG BreakOnEntry = DEFAULT_BREAK_ON_ENTRY;
ULONG DebugComponents = DEFAULT_DEBUG_COMPONENTS;
ULONG DebugLevel = DEFAULT_DEBUG_LEVEL;

BOOLEAN DontLoad = FALSE;

#endif

//
// Local functions.
//

NTSTATUS
DriverEntry (
    IN OUT PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
RamdiskCreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskFlushBuffers (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskFlushBuffersReal (
    IN PDISK_EXTENSION DiskExtension
    );

NTSTATUS
RamdiskSystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
RamdiskUnload (
    IN PDRIVER_OBJECT DriverObject
    );

VOID
QueryParameters (
    IN PUNICODE_STRING RegistryPath
    );

#if DBG

NTSTATUS
RamdiskInvalidDeviceRequest (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
QueryDebugParameters (
    IN PUNICODE_STRING RegistryPath
    );

#endif

//
// Declare pageable routines.
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( INIT, QueryParameters )

#pragma alloc_text( PAGE, RamdiskCreateClose )
#pragma alloc_text( PAGE, RamdiskFlushBuffers )
#pragma alloc_text( PAGE, RamdiskFlushBuffersReal )
#pragma alloc_text( PAGE, RamdiskSystemControl )
#pragma alloc_text( PAGE, RamdiskUnload )
#pragma alloc_text( PAGE, RamdiskWorkerThread )

#if DBG
#pragma alloc_text( INIT, QueryDebugParameters )
#endif // DBG

#endif // ALLOC_PRAGMA

NTSTATUS
DriverEntry (
    IN OUT PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called by the operating system to initialize the driver.

Arguments:

    DriverObject - a pointer to a driver object for the driver

    RegistryPath - a pointer to our Services key in the registry

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS status;
    HANDLE handle;
    ULONG i;
    PDEVICE_OBJECT pdo = NULL;
    PLOADER_PARAMETER_BLOCK loaderBlock;

    //
    // Initialize pool debugging, if enabled.
    //

#if defined(POOL_DBG)
    RamdiskInitializePoolDebug();
#endif

    //
    // Get debugging parameters from the registry.
    //

#if DBG
    QueryDebugParameters( RegistryPath );
#endif

    DBGPRINT( DBG_INIT, DBG_VERBOSE,
                ("DriverEntry: DriverObject = %x, RegistryPath = %ws\n",
                DriverObject, RegistryPath->Buffer) );

    //
    // If requested, break into the debugger.
    //

#if DBG
    if ( BreakOnEntry ) {
        KdBreakPoint();
	}
#endif

    //
    // If requested, fail the driver load.
    //

#if DBG
    if ( DontLoad ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
#endif

    //
    // Get non-debug parameters from the registry.
    //

    QueryParameters( RegistryPath );

    //
    // Save the path to the driver's registry key.
    //

    DriverRegistryPath.Length = RegistryPath->Length;
    DriverRegistryPath.MaximumLength = (USHORT)(RegistryPath->Length + sizeof(WCHAR));
    DriverRegistryPath.Buffer = ALLOCATE_POOL( PagedPool, DriverRegistryPath.MaximumLength, TRUE );

    if ( DriverRegistryPath.Buffer == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyUnicodeString( &DriverRegistryPath, RegistryPath );
    ASSERT( DriverRegistryPath.Length == RegistryPath->Length );

    //
    // Initialize the driver object with this driver's entry points.
    //

#if DBG
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = RamdiskInvalidDeviceRequest;
    }
#endif

    DriverObject->MajorFunction[IRP_MJ_CREATE] = RamdiskCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = RamdiskCreateClose;
    DriverObject->MajorFunction[IRP_MJ_READ] = RamdiskReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = RamdiskReadWrite;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = RamdiskFlushBuffers;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = RamdiskDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP] = RamdiskPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = RamdiskPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = RamdiskSystemControl;
    DriverObject->MajorFunction[IRP_MJ_SCSI] = RamdiskScsi;

    DriverObject->DriverUnload = RamdiskUnload;
    DriverObject->DriverExtension->AddDevice = RamdiskAddDevice;

    //
    // If the registry tells us to do so, or if textmode setup is running and
    // virtual floppy RAM disks are specified in the registry, call
    // IoReportDetectedDevice to hook us up to PnP, then call RamdiskAddDevice
    // directly. This is necessary during textmode in order to get any virtual
    // floppy RAM disks created -- our AddDevice routine is not normally called
    // during textmode. Calling IoReportDetectedDevice is also necessary during
    // a boot from a RAM disk in order to get the device plumbed early enough.
    //
    // We don't want to call IoReportDetectedDevice during textmode setup if
    // no virtual floppies exist, because calling IoReportDetectedDevice
    // causes a devnode for the controller device to be written to the
    // registry, and textmode setup only deletes the devnode if virtual
    // floppies exist. If we leave the devnode in the registry, then GUI setup
    // installs ramdisk.sys on the machine, even though we don't really want
    // it to.
    //

    loaderBlock = *(PLOADER_PARAMETER_BLOCK *)KeLoaderBlock;

    if ( ReportDetectedDevice ||
         ( (loaderBlock != NULL) &&
           (loaderBlock->SetupLoaderBlock != NULL) &&
           CreateRegistryDisks( TRUE ) ) ) {
    
        //
        // Inform PnP that we have detected the bus enumerator device and will be
        // doing the AddDevice ourselves.
        //
       
        status = IoReportDetectedDevice(
                     DriverObject,
                     InterfaceTypeUndefined,
                     -1,
                     -1,
                     NULL, //allocatedResources,
                     NULL, //ioResourceReq,
                     FALSE,
                     &pdo
                 );
    
        if (!NT_SUCCESS(status)) {
            DBGPRINT( DBG_ALL, DBG_ERROR,
                        ("RamdiskDriverEntry: IoReportDetectedDevice failed: %x\n", status) );
           return status;
        }

        //
        // Attach a device object to the pdo
        //   

        status = RamdiskAddDevice(DriverObject, pdo);
        if ( !NT_SUCCESS(status) ) {
            DBGPRINT( DBG_ALL, DBG_ERROR,
                        ("RamdiskDriverEntry: RamdiskAddDevice failed: %x\n", status) );
            return status;
        }

        //
        // Indicate that the device is done initializing.
        //

        pdo->Flags &= ~DO_DEVICE_INITIALIZING;

    }

    //
    // Indicate that the driver has loaded successfully.
    //

    DBGPRINT( DBG_INIT, DBG_VERBOSE, ("%s", "DriverEntry: succeeded\n") );

    return STATUS_SUCCESS;

} // DriverEntry

NTSTATUS
RamdiskCreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when a device owned by the driver
    is opened or closed.

    No action is performed other than completing the request successfully.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - STATUS_SUCCESS

--*/

{
    PAGED_CODE();

    COMPLETE_REQUEST( STATUS_SUCCESS, FILE_OPENED, Irp );

    return STATUS_SUCCESS;

} // RamdiskCreateClose

NTSTATUS
RamdiskFlushBuffers (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when a FLUSH_BUFFERS IRP is
    issued.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PDISK_EXTENSION diskExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    //
    // If the target RAM disk is not file-backed, there's nothing to do. If it
    // is file-backed, we need to do the work in a thread.
    //

    if ( (diskExtension->DeviceType != RamdiskDeviceTypeDiskPdo) ||
         !RAMDISK_IS_FILE_BACKED(diskExtension->DiskType) ) {

        COMPLETE_REQUEST( STATUS_SUCCESS, 0, Irp );

        return STATUS_SUCCESS;
    }

    status = SendIrpToThread( DeviceObject, Irp );

    if ( status != STATUS_PENDING ) {

        COMPLETE_REQUEST( status, 0, Irp );
    }

    return status;

} // RamdiskFlushBuffers

NTSTATUS
RamdiskFlushBuffersReal (
    IN PDISK_EXTENSION DiskExtension
    )

/*++

Routine Description:

    This routine is called in a thread in the system process to handle a
    FLUSH_BUFFERS IRP.

Arguments:

    DiskExtension - a pointer to the device object extension for the target
        device

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    PAGED_CODE();

    //
    // Flush the virtual memory associated with the RAM disk.
    //

    return RamdiskFlushViews( DiskExtension );

} // RamdiskFlushBuffersReal

NTSTATUS
RamdiskSystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when a SYSTEM_CONTROL IRP is
    issued.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    PCOMMON_EXTENSION commonExtension;
    NTSTATUS status;

	PAGED_CODE();

    //
    // If the target device is a bus FDO, pass the IRP down to the next
    // device in the stack. Otherwise, the target is a disk PDO, in which
    // case we just complete the IRP with the current status.
    //

    commonExtension = DeviceObject->DeviceExtension;

    if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

        IoSkipCurrentIrpStackLocation( Irp );
        return IoCallDriver( commonExtension->LowerDeviceObject, Irp );
    }

    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;

} // RamdiskSystemControl


VOID
RamdiskUnload (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is called by the I/O system to unload the driver.

    Any resources previously allocated must be freed.

Arguments:

    DriverObject - a pointer to the object that represents our driver

Return Value:

    None.

--*/

{
    PAGED_CODE();

    if ( DriverRegistryPath.Buffer != NULL ) {

        FREE_POOL( DriverRegistryPath.Buffer, TRUE );
    }

    //
    // ISSUE: What other cleanup is needed here?
    //

    return;

} // RamdiskUnload

VOID
RamdiskWorkerThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine executes thread-based operations for the RAM disk driver.
    It runs in the context of the system process.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Context - a pointer to the IRP for the I/O operation

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PLIST_ENTRY listEntry;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PCOMMON_EXTENSION commonExtension;
    PBUS_EXTENSION busExtension;
    PDISK_EXTENSION diskExtension;
    PSCSI_REQUEST_BLOCK srb;
    ULONG controlCode;
    PUCHAR originalDataBuffer;
    PUCHAR mappedDataBuffer;
    PUCHAR inputDataBuffer;
    PUCHAR systemAddress;
    ULONG originalDataBufferOffset;
    
    PAGED_CODE();

    //
    // Get a pointer to the IRP.
    //

    irp = Context;
    irpSp = IoGetCurrentIrpStackLocation( irp );

    //
    // Free the work item.
    //

    IoFreeWorkItem( irp->Tail.Overlay.DriverContext[0] );

    //
    // Get pointers to the device extension.
    //

    commonExtension = DeviceObject->DeviceExtension;
    busExtension = DeviceObject->DeviceExtension;
    diskExtension = DeviceObject->DeviceExtension;

    //
    // Acquire the remove lock for the device. If this fails, bail out.
    //

    status = IoAcquireRemoveLock( &commonExtension->RemoveLock, irp );

    if ( !NT_SUCCESS(status) ) {
        COMPLETE_REQUEST( status, 0, irp );
        return;
    }

    //
    // Dispatch based on the IRP function.
    //

    switch ( irpSp->MajorFunction ) {
    
    case IRP_MJ_READ:
    case IRP_MJ_WRITE:
    
        status = RamdiskReadWriteReal( irp, diskExtension );

        break;

    case IRP_MJ_FLUSH_BUFFERS:
    
        status = RamdiskFlushBuffersReal( diskExtension );
        irp->IoStatus.Information = 0;

        break;

    case IRP_MJ_DEVICE_CONTROL:

        switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
        
        case IOCTL_DISK_GET_DRIVE_LAYOUT:

            status = RamdiskGetDriveLayout( irp, diskExtension );

            break;

        case IOCTL_DISK_GET_PARTITION_INFO:

            status = RamdiskGetPartitionInfo( irp, diskExtension );

            break;

        case IOCTL_DISK_SET_PARTITION_INFO:

            status = RamdiskSetPartitionInfo( irp, diskExtension );

            break;

        case FSCTL_CREATE_RAM_DISK:

            status = RamdiskCreateRamDisk( DeviceObject, irp, FALSE );

            break;

        default:

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("RamdiskThread: bogus IOCTL IRP with code %x received\n",
                        irpSp->Parameters.DeviceIoControl.IoControlCode) );
            ASSERT( FALSE );

            status = STATUS_INVALID_DEVICE_REQUEST;

            break;

        }

        break;

    case IRP_MJ_SCSI:

        srb = irpSp->Parameters.Scsi.Srb;
        controlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;

        //
        // Remember the original data buffer pointer. We might have to
        // change the pointer.
        //

        originalDataBuffer = srb->DataBuffer;

        status = STATUS_SUCCESS;

        if ( irp->MdlAddress != NULL ) {

            //
            // There is an MDL in the IRP. Get a usable system address for
            // the data buffer based on the MDL.
            //

            systemAddress = MmGetSystemAddressForMdlSafe(
                                irp->MdlAddress,
                                NormalPagePriority
                                );

            if ( systemAddress != NULL ) {

                //
                // The SRB data buffer might be at an offset from the
                // start of the MDL. Calculate that offset and add it
                // to the system address just obtained. This is the
                // data buffer address that we will use.
                //

                originalDataBufferOffset = (ULONG)(originalDataBuffer -
                                            (PCHAR)MmGetMdlVirtualAddress( irp->MdlAddress ));
                mappedDataBuffer = systemAddress + originalDataBufferOffset;
                srb->DataBuffer = mappedDataBuffer;

            } else {

                //
                // Couldn't get a system address. Abort.
                //

                srb->SrbStatus = SRB_STATUS_ABORTED;
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if ( NT_SUCCESS(status) ) {

            //
            // Remember the data buffer address that we're sending down.
            // If it doesn't change, we'll need to reset the address to
            // that which was passed in to us.
            //

            inputDataBuffer = srb->DataBuffer;

            //
            // Dispatch based on the I/O type in the SRB.
            //

            if ( controlCode == IOCTL_SCSI_EXECUTE_NONE ) {

                status = RamdiskScsiExecuteNone(
                            diskExtension->Pdo,
                            irp,
                            srb,
                            controlCode
                            );
            } else {

                status = RamdiskScsiExecuteIo(
                            diskExtension->Pdo,
                            irp,
                            srb,
                            controlCode
                            );
            }

            //
            // If the data buffer address didn't change, put the original
            // address back in the SRB.
            //

            if ( srb->DataBuffer == inputDataBuffer ) {
                srb->DataBuffer = originalDataBuffer;
            }
        }

        //
        // If the I/O worked, write the transfer length into the IRP.
        //

        if ( NT_SUCCESS(status) ) {
            irp->IoStatus.Information = srb->DataTransferLength;
        } else {
            irp->IoStatus.Information = 0;
        }

        break;

    default:

        DBGPRINT( DBG_IOCTL, DBG_ERROR,
                    ("RamdiskThread: bogus IRP with major function %x received\n",
                    irpSp->MajorFunction) );
        ASSERT( FALSE );

        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Release the remove lock and complete the request.
    //

    IoReleaseRemoveLock( &commonExtension->RemoveLock, irp );

    ASSERT( status != STATUS_PENDING );

    irp->IoStatus.Status = status;
    IoCompleteRequest( irp, IO_DISK_INCREMENT );

    return;

} // RamdiskWorkerThread

VOID
QueryParameters (
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called from DriverEntry() to get driver parameters from
    the registry. If the registry query fails, then default values are used.

Arguments:

    RegistryPath - a pointer to the service path for the registry parameters

Return Value:

    None.

--*/

{
    NTSTATUS status;
    RTL_QUERY_REGISTRY_TABLE queryTable[12];
    PRTL_QUERY_REGISTRY_TABLE queryEntry;

    PAGED_CODE();

    DBGPRINT( DBG_INIT, DBG_VERBOSE, ("%s", "QueryParameters\n") );

    ASSERT( RegistryPath->Buffer != NULL );

    //
    // Set the default values.
    //

    ReportDetectedDevice = FALSE;
    MarkRamdisksAsRemovable = FALSE;

    MinimumViewCount = MINIMUM_MINIMUM_VIEW_COUNT;
    DefaultViewCount = DEFAULT_DEFAULT_VIEW_COUNT;
    MaximumViewCount = DEFAULT_MAXIMUM_VIEW_COUNT;
    MinimumViewLength = MINIMUM_MINIMUM_VIEW_LENGTH;
    DefaultViewLength = DEFAULT_DEFAULT_VIEW_LENGTH;
    MaximumViewLength = DEFAULT_MAXIMUM_VIEW_LENGTH;

    MaximumPerDiskViewLength = DEFAULT_MAXIMUM_PER_DISK_VIEW_LENGTH;

#if SUPPORT_DISK_NUMBERS
    DiskNumbersBitmapSize = DEFAULT_DISK_NUMBERS_BITMAP_SIZE;
#endif // SUPPORT_DISK_NUMBERS

    //
    // Set up the query table.
    //

    RtlZeroMemory( queryTable, sizeof(queryTable) );

    //
    // We're looking for subkey "Parameters" under the given registry key.
    //

    queryEntry = &queryTable[0];
    queryEntry->Flags = RTL_QUERY_REGISTRY_SUBKEY;
    queryEntry->Name = L"Parameters";
    queryEntry->EntryContext = NULL;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    //
    // These are the values we want to read.
    //

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"ReportDetectedDevice";
    queryEntry->EntryContext = &ReportDetectedDevice;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"MarkRamdisksAsRemovable";
    queryEntry->EntryContext = &MarkRamdisksAsRemovable;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"MinimumViewCount";
    queryEntry->EntryContext = &MinimumViewCount;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"DefaultViewCount";
    queryEntry->EntryContext = &DefaultViewCount;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"MaximumViewCount";
    queryEntry->EntryContext = &MaximumViewCount;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"MinimumViewLength";
    queryEntry->EntryContext = &MinimumViewLength;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"DefaultViewLength";
    queryEntry->EntryContext = &DefaultViewLength;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"MaximumViewLength";
    queryEntry->EntryContext = &MaximumViewLength;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"MaximumPerDiskViewLength";
    queryEntry->EntryContext = &MaximumPerDiskViewLength;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

#if SUPPORT_DISK_NUMBERS
    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"DiskNumbersBitmapSize";
    queryEntry->EntryContext = &DiskNumbersBitmapSize;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;
#endif // SUPPORT_DISK_NUMBERS

    //
    // Do the query.
    //

    status = RtlQueryRegistryValues(
                RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,    
                RegistryPath->Buffer,
                queryTable,
                NULL,
                NULL
                );

    //
    // Check the validity of the parameters.
    //

    if ( MinimumViewCount < MINIMUM_MINIMUM_VIEW_COUNT ) {
        MinimumViewCount = MINIMUM_MINIMUM_VIEW_COUNT;
    } else if ( MinimumViewCount > MAXIMUM_MINIMUM_VIEW_COUNT ) {
        MinimumViewCount = MAXIMUM_MINIMUM_VIEW_COUNT;
    }
        
    if ( DefaultViewCount < MinimumViewCount ) {
        DefaultViewCount = MinimumViewCount;
    } else if ( DefaultViewCount > MAXIMUM_DEFAULT_VIEW_COUNT ) {
        DefaultViewCount = MAXIMUM_DEFAULT_VIEW_COUNT;
    }
        
    if ( MaximumViewCount < DefaultViewCount ) {
        MaximumViewCount = DefaultViewCount;
    } else if ( MaximumViewCount > MAXIMUM_MAXIMUM_VIEW_COUNT ) {
        MaximumViewCount = MAXIMUM_MAXIMUM_VIEW_COUNT;
    }
        
    if ( MinimumViewLength < MINIMUM_MINIMUM_VIEW_LENGTH ) {
        MinimumViewLength = MINIMUM_MINIMUM_VIEW_LENGTH;
    } else if ( MinimumViewLength > MAXIMUM_MINIMUM_VIEW_LENGTH ) {
        MinimumViewLength = MAXIMUM_MINIMUM_VIEW_LENGTH;
    }
        
    if ( DefaultViewLength < MinimumViewLength ) {
        DefaultViewLength = MinimumViewLength;
    } else if ( DefaultViewLength > MAXIMUM_DEFAULT_VIEW_LENGTH ) {
        DefaultViewLength = MAXIMUM_DEFAULT_VIEW_LENGTH;
    }
        
    if ( MaximumViewLength < DefaultViewLength ) {
        MaximumViewLength = DefaultViewLength;
    } else if ( MaximumViewLength > MAXIMUM_MAXIMUM_VIEW_LENGTH ) {
        MaximumViewLength = MAXIMUM_MAXIMUM_VIEW_LENGTH;
    }
        
    if ( MaximumPerDiskViewLength < MINIMUM_MAXIMUM_PER_DISK_VIEW_LENGTH ) {
        MaximumPerDiskViewLength = MINIMUM_MAXIMUM_PER_DISK_VIEW_LENGTH;
    } else if ( MaximumViewLength > MAXIMUM_MAXIMUM_PER_DISK_VIEW_LENGTH ) {
        MaximumPerDiskViewLength = MAXIMUM_MAXIMUM_PER_DISK_VIEW_LENGTH;
    }

#if SUPPORT_DISK_NUMBERS
    if ( DiskNumbersBitmapSize < MINIMUM_DISK_NUMBERS_BITMAP_SIZE ) {
        DiskNumbersBitmapSize = MINIMUM_DISK_NUMBERS_BITMAP_SIZE;
    } else if ( DiskNumbersBitmapSize > MAXIMUM_DISK_NUMBERS_BITMAP_SIZE ) {
        DiskNumbersBitmapSize = MAXIMUM_DISK_NUMBERS_BITMAP_SIZE;
    }
#endif // SUPPORT_DISK_NUMBERS

    DBGPRINT( DBG_INIT, DBG_INFO, ("DefaultViewCount = 0x%x\n", DefaultViewCount) );
    DBGPRINT( DBG_INIT, DBG_INFO, ("MaximumViewCount = 0x%x\n", MaximumViewCount) );
    DBGPRINT( DBG_INIT, DBG_INFO, ("DefaultViewLength = 0x%x\n", DefaultViewLength) );
    DBGPRINT( DBG_INIT, DBG_INFO, ("MaximumViewLength = 0x%x\n", MaximumViewLength) );
    DBGPRINT( DBG_INIT, DBG_INFO, ("MaximumPerDiskViewLength = 0x%x\n", MaximumPerDiskViewLength) );

#if SUPPORT_DISK_NUMBERS
    DBGPRINT( DBG_INIT, DBG_INFO, ("DiskNumbersBitmapSize = 0x%x\n", DiskNumbersBitmapSize) );
#endif // SUPPORT_DISK_NUMBERS

    return;

} // QueryParameters

#if DBG

NTSTATUS
RamdiskInvalidDeviceRequest (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when an IRP that we don't
    process is issued.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - STATUS_INVALID_DEVICE_REQUEST

--*/

{
    //
    // We really do recognize CLEANUP and SHUTDOWN IRPs. For any other IRP,
    // print a message and break into the debugger.
    //

    switch ( IoGetCurrentIrpStackLocation(Irp)->MajorFunction ) {
    
    case IRP_MJ_CLEANUP:
    case IRP_MJ_SHUTDOWN:
        break;

    default:

        DBGPRINT( DBG_IOCTL, DBG_ERROR,
                    ("Ramdisk: Unrecognized IRP: major/minor = %x/%x\n",
                    IoGetCurrentIrpStackLocation(Irp)->MajorFunction,
                    IoGetCurrentIrpStackLocation(Irp)->MinorFunction) );
        ASSERT( FALSE );

    }

    //
    // If this is a power IRP, we need to start the next one.
    //

    if ( IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_POWER ) {
        PoStartNextPowerIrp( Irp );
    }

    //
    // Tell the I/O system that we don't recognize this IRP.
    //

    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return STATUS_INVALID_DEVICE_REQUEST;

} // RamdiskInvalidDeviceRequest

VOID
QueryDebugParameters (
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called from DriverEntry() to get the debug parameters
    from the registry. If the registry query fails, then default values are
    used.

Arguments:

    RegistryPath - a pointer to the service path for the registry parameters

Return Value:

    None.

--*/

{
    NTSTATUS status;
    RTL_QUERY_REGISTRY_TABLE queryTable[5];
    PRTL_QUERY_REGISTRY_TABLE queryEntry;

    PAGED_CODE();

    DBGPRINT( DBG_INIT, DBG_VERBOSE, ("%s", "QueryDebugParameters\n") );

    ASSERT( RegistryPath->Buffer != NULL );

    //
    // Set the default values.
    //

    BreakOnEntry = DEFAULT_BREAK_ON_ENTRY;
    DebugComponents = DEFAULT_DEBUG_COMPONENTS;
    DebugLevel = DEFAULT_DEBUG_LEVEL;

    //
    // Set up the query table.
    //

    RtlZeroMemory( queryTable, sizeof(queryTable) );

    //
    // We're looking for subkey "Debug" under the given registry key.
    //

    queryEntry = &queryTable[0];
    queryEntry->Flags = RTL_QUERY_REGISTRY_SUBKEY;
    queryEntry->Name = L"Debug";
    queryEntry->EntryContext = NULL;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    //
    // These are the values we want to read.
    //

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"BreakOnEntry";
    queryEntry->EntryContext = &BreakOnEntry;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"DebugComponents";
    queryEntry->EntryContext = &DebugComponents;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"DebugLevel";
    queryEntry->EntryContext = &DebugLevel;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    //
    // Do the query.
    //

    status = RtlQueryRegistryValues(
                RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,    
                RegistryPath->Buffer,
                queryTable,
                NULL,
                NULL
                );

    DBGPRINT( DBG_INIT, DBG_INFO, ("BreakOnEntry = 0x%x\n", BreakOnEntry) );
    DBGPRINT( DBG_INIT, DBG_INFO, ("DebugComponents = 0x%x\n", DebugComponents) );
    DBGPRINT( DBG_INIT, DBG_INFO, ("DebugLevel = 0x%x\n", DebugLevel) );

    return;

} // QueryDebugParameters

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ramdisk\readwrite.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    readwrite.c

Abstract:

    This file contains RAM disk driver code for reading from and writing to
    a RAM disk.

Author:

    Chuck Lenzmeier (ChuckL) 2001

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

NTSTATUS
RamdiskReadWrite (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to read from or write to a
    device that we control.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PDISK_EXTENSION diskExtension;
    PIO_STACK_LOCATION irpSp;
    ULONGLONG ioOffset;
    ULONG ioLength;

    //
    // Get the device extension pointer. Get parameters from the IRP.
    //


    diskExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    ioOffset = irpSp->Parameters.Read.ByteOffset.QuadPart;
    ioLength = irpSp->Parameters.Read.Length;

    //
    // If this is not a disk PDO, we can't handle this IRP.
    //

    if ( diskExtension->DeviceType != RamdiskDeviceTypeDiskPdo ) {

        status = STATUS_INVALID_DEVICE_REQUEST;
        goto complete_irp;
    }

    DBGPRINT( DBG_READWRITE, DBG_PAINFUL,
                ("RamdiskReadWrite: offset %I64x, length %x\n", ioOffset, ioLength) );

    //
    // If it's a zero-length operation, we don't have to do anything.
    //

    if ( ioLength == 0 ) {

        status = STATUS_SUCCESS;
        goto complete_irp;
    }

    //
    // Check for invalid parameters:
    //  The transfer must be sector aligned.
    //  The length cannot cause the offset to wrap.
    //  The transfer cannot go beyond the end of the disk.
    //  Writes cannot be performed on a readonly disk.
    //

    if ( ((ioOffset | ioLength) & (diskExtension->BytesPerSector - 1)) != 0 ) {

        status = STATUS_INVALID_PARAMETER;
        goto complete_irp;
    }

    if ( (ioOffset + ioLength) < ioOffset ) {

        status = STATUS_INVALID_PARAMETER;
        goto complete_irp;
    }

    if ( (ioOffset + ioLength) > diskExtension->DiskLength ) {

        status = STATUS_NONEXISTENT_SECTOR;
        goto complete_irp;
    }

    if ( (irpSp->MajorFunction == IRP_MJ_WRITE) && diskExtension->Options.Readonly ) {

        status = STATUS_MEDIA_WRITE_PROTECTED;
        goto complete_irp;
    }

    //
    // If the RAM disk is not file-backed, then the disk image is in memory,
    // and we can do the operation regardless of what context we're in. If the
    // RAM disk is file-backed, we need to be in thread context to do the
    // operation.
    //

    if ( RAMDISK_IS_FILE_BACKED(diskExtension->DiskType) ) {

        status = SendIrpToThread( DeviceObject, Irp );
        if ( status != STATUS_PENDING ) {
            goto complete_irp;
        }
        return status;
    }

    status = RamdiskReadWriteReal(
                Irp,
                diskExtension
                 );

complete_irp:

    //
    // Complete the IRP.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_DISK_INCREMENT );

    return status;

} // RamdiskReadWrite

NTSTATUS
RamdiskReadWriteReal (
    IN PIRP Irp,
    IN PDISK_EXTENSION DiskExtension
    )

/*++

Routine Description:

    This routine is called in thread context to perform a read or a write.

Arguments:

    Irp - a pointer to the I/O Request Packet for this request

    DiskExtension - a pointer to the device extension for the target device

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PUCHAR bufferAddress;
    PUCHAR diskByteAddress;
    ULONGLONG ioOffset;
    ULONG ioLength;
    ULONG mappedLength;

    //
    // Get a system-space pointer to the user's buffer.  A system address must
    // be used because we may already have left the original caller's address
    // space.
    //

    ASSERT( Irp->MdlAddress != NULL );

    bufferAddress = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

    if ( bufferAddress == NULL ) {

        //
        // Unable to get a pointer to the user's buffer.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get parameters from the IRP.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    ioOffset = irpSp->Parameters.Read.ByteOffset.QuadPart;
    ioLength = irpSp->Parameters.Read.Length;

    Irp->IoStatus.Information = 0;

    while ( ioLength != 0 ) {
    
        //
        // Map the appropriate RAM disk pages.
        //
    
        diskByteAddress = RamdiskMapPages( DiskExtension, ioOffset, ioLength, &mappedLength );
    
        if ( diskByteAddress == NULL ) {
    
            //
            // Unable to map the RAM disk.
            //
    
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ASSERT( mappedLength <= ioLength );

        Irp->IoStatus.Information += mappedLength;
    
        //
        // Copy the data in the appropriate direction.
        //

        status = STATUS_SUCCESS;
    
        switch ( irpSp->MajorFunction ) {
        
        case IRP_MJ_READ:

            RtlCopyMemory( bufferAddress, diskByteAddress, mappedLength );
            break;
    
        case IRP_MJ_WRITE:

            RtlCopyMemory( diskByteAddress, bufferAddress, mappedLength );
            break;
    
        default:

            ASSERT( FALSE );
            status = STATUS_INVALID_PARAMETER;
            ioLength = mappedLength;
        }
    
        //
        // Unmap the previously mapped pages.
        //
    
        RamdiskUnmapPages( DiskExtension, diskByteAddress, ioOffset, mappedLength );

        ioLength -= mappedLength;
        ioOffset += mappedLength;
        bufferAddress += mappedLength;
    }

    return status;

} // RamdiskReadWriteReal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ramdisk\scsi.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    scsi.c

Abstract:

    This file contains RAM disk driver code for processing SCSI commands.

Author:

    Chuck Lenzmeier (ChuckL) 2001

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Local functions.
//

NTSTATUS
Do6ByteCdbCommand (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
Do10ByteCdbCommand (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
Do12ByteCdbCommand (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
BuildInquiryData (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
BuildModeSenseInfo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    );

//
// Declare pageable routines.
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, RamdiskScsiExecuteNone )
#pragma alloc_text( PAGE, RamdiskScsiExecuteIo )
#pragma alloc_text( PAGE, Do6ByteCdbCommand )
#pragma alloc_text( PAGE, Do10ByteCdbCommand )
#pragma alloc_text( PAGE, Do12ByteCdbCommand )
#pragma alloc_text( PAGE, BuildInquiryData )
#pragma alloc_text( PAGE, BuildModeSenseInfo )

#endif // ALLOC_PRAGMA

NTSTATUS
RamdiskScsi (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to process a SCSI IRP.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PDISK_EXTENSION diskExtension;

    diskExtension = DeviceObject->DeviceExtension;

    //
    // ISSUE: Can't be paged because ClassCheckMediaState calls it from timer
    // routine. (For removable disks.) Therefore we can't acquire the device
    // mutex here.
    //

    //
    // Check to see if the device is being removed.
    //

    if ( diskExtension->DeviceState > RamdiskDeviceStatePendingRemove ) {

        status = STATUS_DEVICE_DOES_NOT_EXIST;
        COMPLETE_REQUEST( status, 0, Irp );
        return status;
    }

    //
    // Acquire the remove lock for the device.
    //

    status = IoAcquireRemoveLock( &diskExtension->RemoveLock, Irp );

    if ( !NT_SUCCESS(status) ) {

        DBGPRINT( DBG_PNP, DBG_ERROR, ("%s", "RamdiskScsi: acquire RemoveLock failed\n") );

        COMPLETE_REQUEST( status, 0, Irp );
        return status;
    }

    //
    // This IRP must be processed in thread context.
    //

    status = SendIrpToThread( DeviceObject, Irp );

    if ( status != STATUS_PENDING ) {

        DBGPRINT( DBG_PNP, DBG_ERROR, ("%s", "RamdiskScsi: SendIrpToThread failed\n") );

        COMPLETE_REQUEST( status, 0, Irp );
        return status;
    }

    //
    // Release the remove lock.
    //

    IoReleaseRemoveLock(&diskExtension->RemoveLock, Irp );

    return STATUS_PENDING;

} // RamdiskScsi

NTSTATUS
RamdiskScsiExecuteNone (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PSCSI_REQUEST_BLOCK Srb,
    ULONG ControlCode
    )

/*++

Routine Description:

    This routine is called by the I/O system to process a SCSI IRP that
    does not involve I/O.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

    Srb - the SRB associated with the IRP

    ControlCode - the control code from the SRB

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    UCHAR function;
    PDISK_EXTENSION diskExtension;
    
    PAGED_CODE();

    diskExtension = DeviceObject->DeviceExtension;

    //
    // Dispatch based on the SRB function.
    //

    function = Srb->Function;

    switch( function ) {
    
    case SRB_FUNCTION_ATTACH_DEVICE:
    case SRB_FUNCTION_CLAIM_DEVICE:

        DBGPRINT( DBG_SRB, DBG_VERBOSE, ("%s", "SRB_FUNCTION_CLAIM_DEVICE\n") );

        //
        // If the device has not already been claimed, mark it so now.
        // Otherwise, indicate to the caller that the device is busy.
        //

        if ( (diskExtension->Status & RAMDISK_STATUS_CLAIMED) == 0 ) {

            diskExtension->DeviceState = RamdiskDeviceStateWorking;
            diskExtension->Status |= RAMDISK_STATUS_CLAIMED;

            Srb->DataBuffer = DeviceObject;

            status = STATUS_SUCCESS;
            Srb->ScsiStatus = SCSISTAT_GOOD;
            Srb->SrbStatus = SRB_STATUS_SUCCESS;

        } else {

            status  = STATUS_DEVICE_BUSY;
            Srb->ScsiStatus = SCSISTAT_BUSY;
            Srb->SrbStatus = SRB_STATUS_BUSY;
        }

        break;

    case SRB_FUNCTION_RELEASE_DEVICE:
    case SRB_FUNCTION_REMOVE_DEVICE:

        DBGPRINT( DBG_SRB, DBG_VERBOSE, ("%s", "SRB_FUNCTION_RELEASE_DEVICE\n") );

        //
        // Indicate that the device is no longer claimed.
        //

        diskExtension->Status &= ~RAMDISK_STATUS_CLAIMED;

        status = STATUS_SUCCESS;
        Srb->ScsiStatus = SCSISTAT_GOOD;
        Srb->SrbStatus = SRB_STATUS_SUCCESS;

        break;

    default:

        //
        // Unrecognized non-I/O function. Try the I/O path.
        //

        status = RamdiskScsiExecuteIo( DeviceObject, Irp, Srb, ControlCode );

        break;
    }

    return status;

} // RamdiskScsiExecuteNone

NTSTATUS
RamdiskScsiExecuteIo (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PSCSI_REQUEST_BLOCK Srb,
    ULONG ControlCode
    )

/*++

Routine Description:

    This routine is called by the I/O system to process a SCSI IRP that
    involves I/O.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

    Srb - the SRB associated with the IRP

    ControlCode - the control code from the SRB

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    UCHAR function;
    PDISK_EXTENSION diskExtension;
    
    PAGED_CODE();

    diskExtension = DeviceObject->DeviceExtension;

    //
    // Dispatch based on the SRB function.
    //

    function = Srb->Function;

    switch( function ) {
    
    case SRB_FUNCTION_EXECUTE_SCSI:

        Srb->SrbStatus = SRB_STATUS_SUCCESS;

        //
        // Dispatch based on the CDB length.
        //
    
        switch( Srb->CdbLength ) {
        
        case 6:

            status = Do6ByteCdbCommand( DeviceObject, Srb );

            break;

        case 10:

            status = Do10ByteCdbCommand( DeviceObject, Irp, Srb );

            break;

        case 12:

            status = Do12ByteCdbCommand( DeviceObject, Srb );

            break;

        default:

            DBGPRINT( DBG_SRB, DBG_ERROR,
                        ("Unknown CDB length 0x%x for function 0x%x, IOCTL 0x%x\n",
                        Srb->CdbLength, function, ControlCode) );
            UNRECOGNIZED_IOCTL_BREAK;

            status = STATUS_INVALID_DEVICE_REQUEST;
            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

            break;
        }

        break;

    case SRB_FUNCTION_FLUSH:
    case SRB_FUNCTION_SHUTDOWN:

        //
        // For flush and shutdown on a file-backed RAM disk, we need to flush
        // the mapped data back to the file.
        //

        status = RamdiskFlushBuffersReal( diskExtension );
        Srb->SrbStatus = SRB_STATUS_SUCCESS;

        break;

    case SRB_FUNCTION_IO_CONTROL:

        //
        // We don't handle this function, but we don't want to complain
        // when we get it.
        //

        status = STATUS_INVALID_DEVICE_REQUEST;
        Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

        break;

    default:

        DBGPRINT( DBG_SRB, DBG_ERROR,
                    ("Unknown SRB Function 0x%x for IOCTL 0x%x\n", function, ControlCode) );
        UNRECOGNIZED_IOCTL_BREAK;
        status = STATUS_INTERNAL_ERROR;
    }

    
    return status;

} // RamdiskScsiExecuteIo

NTSTATUS
Do6ByteCdbCommand (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles 6-byte CDBs.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Srb - the SRB associated with the I/O request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PDISK_EXTENSION diskExtension;
    PCDB cdb;

    PAGED_CODE();

    //
    // Get pointers to the device extension and to the CDB.
    //

    diskExtension = DeviceObject->DeviceExtension;
    cdb = (PCDB)Srb->Cdb;

    //
    // Assume success.
    //

    status = STATUS_SUCCESS;
    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    Srb->ScsiStatus = SCSISTAT_GOOD;

    ASSERT( Srb->CdbLength == 6 );
    ASSERT( cdb != NULL );

    DBGPRINT( DBG_SRB, DBG_VERBOSE,
                ("Do6ByteCdbCommand Called OpCode 0x%x\n", cdb->CDB6GENERIC.OperationCode) );

    //
    // Dispatch based on the operation code.
    //

    switch ( cdb->CDB6GENERIC.OperationCode ) {
    
    case SCSIOP_TEST_UNIT_READY:

        //
        // RAM disks are always ready.
        //

        break;

    case SCSIOP_REQUEST_SENSE:

        //
        // We don't handle request sense.
        //

        Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_INVALID_DEVICE_REQUEST;
        
        break;

    case SCSIOP_FORMAT_UNIT:

        // ISSUE: Need to do something here, like zero the image?

        break;

    case SCSIOP_INQUIRY:

        //
        // If the buffer is big enough, build the inquiry data.
        //

        if ( Srb->DataTransferLength >= INQUIRYDATABUFFERSIZE ) {

            status = BuildInquiryData( DeviceObject, Srb );

        } else {

            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        break;

    case SCSIOP_MODE_SENSE:

        //
        // Build the mode sense information.
        //

        status = BuildModeSenseInfo( DeviceObject, Srb );
        
        break;

    case SCSIOP_MEDIUM_REMOVAL:

        //
        // Remember whether media removal is allowed.
        //

        if (cdb->MEDIA_REMOVAL.Prevent == TRUE) {
            diskExtension->Status |= RAMDISK_STATUS_PREVENT_REMOVE;
        } else {
            diskExtension->Status &= ~RAMDISK_STATUS_PREVENT_REMOVE;
        }

        break;

    //case SCSIOP_READ6:
    //case SCSIOP_WRITE6:
    //case SCSIOP_REZERO_UNIT:
    //case SCSIOP_REQUEST_BLOCK_ADDR:
    //case SCSIOP_READ_BLOCK_LIMITS:
    //case SCSIOP_REASSIGN_BLOCKS:
    //case SCSIOP_SEEK6:
    //case SCSIOP_SEEK_BLOCK:
    //case SCSIOP_PARTITION:
    //case SCSIOP_READ_REVERSE:
    //case SCSIOP_WRITE_FILEMARKS:
    //case SCSIOP_SPACE:
    //case SCSIOP_VERIFY6:
    //case SCSIOP_RECOVER_BUF_DATA:
    //case SCSIOP_MODE_SELECT:
    //case SCSIOP_RESERVE_UNIT:
    //case SCSIOP_RELEASE_UNIT:
    //case SCSIOP_COPY:
    //case SCSIOP_ERASE:
    //case SCSIOP_START_STOP_UNIT:
    //case SCSIOP_RECEIVE_DIAGNOSTIC:
    //case SCSIOP_SEND_DIAGNOSTIC:

    default:

        DBGPRINT( DBG_SRB, DBG_ERROR,
                    ("Unknown CDB Function 0x%x\n", cdb->CDB6GENERIC.OperationCode) );
        UNRECOGNIZED_IOCTL_BREAK;

        status = STATUS_INVALID_DEVICE_REQUEST;
        Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
    }

    DBGPRINT( DBG_SRB, DBG_VERBOSE, ("Do6ByteCdbCommand Done status 0x%x\n", status) );

    return status;

} // Do6ByteCdbCommand

NTSTATUS
Do10ByteCdbCommand (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles 10-byte CDBs.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

    Srb - the SRB associated with the IRP

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PDISK_EXTENSION diskExtension;
    PCDB cdb;
    PREAD_CAPACITY_DATA readCapacityData;
    ULONGLONG diskSize;
    ULONG lastBlock;
    FOUR_BYTE startingBlockNumber;
    TWO_BYTE count;
    ULONG_PTR offset;
    ULONG dataSize;
    PUCHAR diskByteAddress;
    PUCHAR dataBuffer;
    ULONG mappedLength;

    PAGED_CODE();

    //
    // Get pointers to the device extension and to the CDB.
    //

    diskExtension = DeviceObject->DeviceExtension;
    cdb = (PCDB)Srb->Cdb;

    //
    // Assume success.
    //

    status = STATUS_SUCCESS;
    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    Srb->ScsiStatus = SCSISTAT_GOOD;

    ASSERT( Srb->CdbLength == 10 );
    ASSERT( cdb != NULL );
    
    DBGPRINT( DBG_SRB, DBG_VERBOSE,
                ("Do10ByteCdbCommand Called OpCode 0x%x\n", cdb->CDB10.OperationCode) );

    //
    // Dispatch based on the operation code.
    //

    switch ( cdb->CDB10.OperationCode ) {
    
    case SCSIOP_READ_CAPACITY:

        //
        // Return the disk's block size and last block number (big-endian).
        //

        readCapacityData = Srb->DataBuffer;

        diskSize = diskExtension->DiskLength;
        lastBlock = (ULONG)(diskSize / diskExtension->BytesPerSector) - 1;

        readCapacityData->BytesPerBlock = _byteswap_ulong( diskExtension->BytesPerSector );
        readCapacityData->LogicalBlockAddress = _byteswap_ulong( lastBlock );

        break;

    case SCSIOP_READ:
    case SCSIOP_WRITE:

        //
        // Read from or write to the disk.
        //

        //
        // Convert the transfer length, in blocks, from big-endian. Convert
        // that to bytes.
        //

        count.Byte0 = cdb->CDB10.TransferBlocksLsb;
        count.Byte1 = cdb->CDB10.TransferBlocksMsb;

        dataSize = count.AsUShort * diskExtension->BytesPerSector;

        //
        // If the CDB length is greater than the SRB length, use the SRB
        // length.
        //

        if ( dataSize > Srb->DataTransferLength ) {
            dataSize = Srb->DataTransferLength;
        }

        //
        // Convert the starting block number from big-endian. 
        //

        startingBlockNumber.Byte0 = cdb->CDB10.LogicalBlockByte3;
        startingBlockNumber.Byte1 = cdb->CDB10.LogicalBlockByte2;
        startingBlockNumber.Byte2 = cdb->CDB10.LogicalBlockByte1;
        startingBlockNumber.Byte3 = cdb->CDB10.LogicalBlockByte0;

        //
        // We don't handle RelativeAddress requests.
        //

        if ( cdb->CDB10.RelativeAddress ) {

            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            status = STATUS_INVALID_DEVICE_REQUEST;

            break;
        }

        //
        // Get the offset within the disk to the start of the operation.
        //

        offset = (startingBlockNumber.AsULong * diskExtension->BytesPerSector);

        //
        // If the transfer length causes the offset to wrap, or if the request
        // goes beyond the end of the disk, reject the request.
        //

        if ( ((offset + dataSize) < offset) ||
             ((offset + dataSize) > diskExtension->DiskLength) ) {

            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            status = STATUS_INVALID_DEVICE_REQUEST;

            break;
        }

        //
        // For a zero-length transfer, we don't have to do anything.
        //

        DBGPRINT( DBG_READWRITE, DBG_VERBOSE, 
            ("%s: Starting Block 0x%x, Length 0x%x at Offset 0x%I64x SrbBuffer=0x%p "
            "SrbLength=0x%x, MdlLength=0x%x\n",
            cdb->CDB10.OperationCode == SCSIOP_READ ? "Read" : "Write",
            startingBlockNumber.AsULong, count.AsUShort, offset, 
            Srb->DataBuffer,
            Srb->DataTransferLength,
            Irp->MdlAddress->ByteCount) );

        dataBuffer = Srb->DataBuffer;

        while ( dataSize != 0 ) {

            //
            // Map the target section of the disk into memory. Then copy the
            // data in the appropriate direction.
            //

            diskByteAddress = RamdiskMapPages( diskExtension, offset, dataSize, &mappedLength );

            if ( diskByteAddress != NULL ) {

                if ( cdb->CDB10.OperationCode == SCSIOP_READ ) {
    
                    memcpy( dataBuffer, diskByteAddress, mappedLength );
    
                } else {
    
                    memcpy( diskByteAddress, dataBuffer, mappedLength );
                }

                RamdiskUnmapPages( diskExtension, diskByteAddress, offset, mappedLength );

                dataSize -= mappedLength;
                offset += mappedLength;
                dataBuffer += mappedLength;

            } else {

                dataSize = 0;
                Srb->SrbStatus = SRB_STATUS_ERROR;
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

        }

        break;

    case SCSIOP_VERIFY:

        //
        // Verify always succeeds.
        //

        break;

    case SCSIOP_MODE_SENSE10:

        //
        // Build the mode sense information.
        //

        status = BuildModeSenseInfo( DeviceObject, Srb );

        break;

    //case SCSIOP_SEEK:
    //case SCSIOP_WRITE_VERIFY:
    //case SCSIOP_READ_FORMATTED_CAPACITY:
    //case SCSIOP_SEARCH_DATA_HIGH:
    //case SCSIOP_SEARCH_DATA_EQUAL:
    //case SCSIOP_SEARCH_DATA_LOW:
    //case SCSIOP_SET_LIMITS:
    //case SCSIOP_READ_POSITION:
    //case SCSIOP_SYNCHRONIZE_CACHE:
    //case SCSIOP_COMPARE:
    //case SCSIOP_COPY_COMPARE:
    //case SCSIOP_WRITE_DATA_BUFF:
    //case SCSIOP_READ_DATA_BUFF:
    //case SCSIOP_CHANGE_DEFINITION:
    //case SCSIOP_READ_SUB_CHANNEL:
    //case SCSIOP_READ_TOC:
    //case SCSIOP_READ_HEADER:
    //case SCSIOP_PLAY_AUDIO:
    //case SCSIOP_GET_CONFIGURATION:
    //case SCSIOP_PLAY_AUDIO_MSF:
    //case SCSIOP_PLAY_TRACK_INDEX:
    //case SCSIOP_PLAY_TRACK_RELATIVE:
    //case SCSIOP_GET_EVENT_STATUS:
    //case SCSIOP_PAUSE_RESUME:
    //case SCSIOP_LOG_SELECT:
    //case SCSIOP_LOG_SENSE:
    //case SCSIOP_STOP_PLAY_SCAN:
    //case SCSIOP_READ_DISK_INFORMATION:
    //case SCSIOP_READ_TRACK_INFORMATION:
    //case SCSIOP_RESERVE_TRACK_RZONE:
    //case SCSIOP_SEND_OPC_INFORMATION:
    //case SCSIOP_MODE_SELECT10:
    //case SCSIOP_CLOSE_TRACK_SESSION:
    //case SCSIOP_READ_BUFFER_CAPACITY:
    //case SCSIOP_SEND_CUE_SHEET:
    //case SCSIOP_PERSISTENT_RESERVE_IN:
    //case SCSIOP_PERSISTENT_RESERVE_OUT:

    default:

        DBGPRINT( DBG_SRB, DBG_ERROR,
                    ("Unknown CDB Function 0x%x\n", cdb->CDB10.OperationCode) );
        UNRECOGNIZED_IOCTL_BREAK;

        status = STATUS_INVALID_DEVICE_REQUEST;
        Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
    }

    DBGPRINT( DBG_SRB, DBG_VERBOSE, ("Do10ByteCdbCommand Done status 0x%x\n", status) );

    return status;

} // Do10ByteCdbCommand

NTSTATUS
Do12ByteCdbCommand (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles 12-byte CDBs.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Srb - the SRB associated with the IRP

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PDISK_EXTENSION diskExtension;
    PCDB cdb;

    PAGED_CODE();

    //
    // Get pointers to the device extension and to the CDB.
    //

    diskExtension = DeviceObject->DeviceExtension;
    cdb = (PCDB)Srb->Cdb;

    //
    // Assume success.
    //

    status = STATUS_SUCCESS;
    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    Srb->ScsiStatus = SCSISTAT_GOOD;

    ASSERT( Srb->CdbLength == 12 );
    ASSERT( cdb != NULL );
    
    DBGPRINT( DBG_SRB, DBG_VERBOSE,
                ("Do12ByteCdbCommand Called OpCode 0x%x\n", cdb->CDB12.OperationCode) );

    //
    // Dispatch based on the operation code.
    //

    switch ( cdb->CDB12.OperationCode ) {
    
    //case SCSIOP_REPORT_LUNS:
    //case SCSIOP_BLANK:
    //case SCSIOP_SEND_KEY:
    //case SCSIOP_REPORT_KEY:
    //case SCSIOP_MOVE_MEDIUM:
    //case SCSIOP_LOAD_UNLOAD_SLOT:
    //case SCSIOP_SET_READ_AHEAD:
    //case SCSIOP_READ_DVD_STRUCTURE:
    //case SCSIOP_REQUEST_VOL_ELEMENT:
    //case SCSIOP_SEND_VOLUME_TAG:
    //case SCSIOP_READ_ELEMENT_STATUS:
    //case SCSIOP_READ_CD_MSF:
    //case SCSIOP_SCAN_CD:
    //case SCSIOP_SET_CD_SPEED:
    //case SCSIOP_PLAY_CD:
    //case SCSIOP_MECHANISM_STATUS:
    //case SCSIOP_READ_CD:
    //case SCSIOP_SEND_DVD_STRUCTURE:
    //case SCSIOP_INIT_ELEMENT_RANGE:

    default:

        DBGPRINT( DBG_SRB, DBG_ERROR,
                    ("Unknown CDB Function 0x%x\n", cdb->CDB12.OperationCode) );
        UNRECOGNIZED_IOCTL_BREAK;

        status = STATUS_INVALID_DEVICE_REQUEST;
        Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
    }

    DBGPRINT( DBG_SRB, DBG_VERBOSE, ("Do12ByteCdbCommand Done status 0x%x\n", status) );

    return status;

} // Do12ByteCdbCommand

NTSTATUS
BuildInquiryData (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine builds inquiry data.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Srb - the SRB associated with the I/O request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    PDISK_EXTENSION diskExtension;
    PINQUIRYDATA inquiryData;
    STRING vendor;
    STRING product;
    STRING revLevel;

    PAGED_CODE();

    //
    // Get pointers to the device extension and to the inquiry data buffer.
    //

    diskExtension = DeviceObject->DeviceExtension;
    inquiryData = (PINQUIRYDATA)Srb->DataBuffer;

    //
    // Build the inquiry data.
    //

    RtlInitString( &vendor, "Microsoft" );
    RtlInitString( &product, "Ramdisk" );
    RtlInitString( &revLevel, "1.0" );

    RtlZeroMemory( inquiryData, INQUIRYDATABUFFERSIZE );
    inquiryData->DeviceType = DIRECT_ACCESS_DEVICE;
    inquiryData->RemovableMedia = (diskExtension->Options.Fixed ? FALSE : TRUE);
    inquiryData->ANSIVersion = 2;
    inquiryData->ResponseDataFormat = 2;
    inquiryData->AdditionalLength = INQUIRYDATABUFFERSIZE - 4;

    RtlCopyMemory(
        inquiryData->VendorId,
        vendor.Buffer,
        min( vendor.Length, sizeof(inquiryData->VendorId) )
        );
    RtlCopyMemory(
        inquiryData->ProductId,
        product.Buffer,
        min( product.Length, sizeof(inquiryData->ProductId) )
        );
    RtlCopyMemory(
        inquiryData->ProductRevisionLevel,
        revLevel.Buffer,
        min( revLevel.Length, sizeof(inquiryData->ProductRevisionLevel) )
        );

    return STATUS_SUCCESS;

} // BuildInquiryData

NTSTATUS
BuildModeSenseInfo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine builds mode sense information.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Srb - the SRB associated with the I/O request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    PDISK_EXTENSION diskExtension;
    MODE_PARAMETER_HEADER  modeHeader = {0};
    MODE_PARAMETER_HEADER10 modeHeader10 = {0};
    PVOID header = NULL;
    PVOID data = NULL;
    unsigned char headerSize;
    unsigned dataSize = 0;
    PCDB cdb;
    unsigned cdbLength;
    unsigned dataBufferLength;
    unsigned char valueType;    
    unsigned dataLength;

    PAGED_CODE();

    //
    // Get pointers to the device extension and to the inquiry data buffer.
    //

    diskExtension = DeviceObject->DeviceExtension;
    cdb = (PCDB)Srb->Cdb;
    cdbLength = Srb->CdbLength;

    //
    // Dispatch based on the CDB length.
    //

    switch ( cdbLength ) {
    
    case 6:

        dataBufferLength = cdb->MODE_SENSE.AllocationLength;
        valueType = cdb->MODE_SENSE.Pc;
        headerSize = sizeof(MODE_PARAMETER_HEADER);

        if ( valueType != 0 ) {

            //
            // We only support current value retrieval.
            //

            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            return STATUS_INVALID_DEVICE_REQUEST;
        }

        if ( dataBufferLength > headerSize ) {

            header = &modeHeader;
            data = (char*)header + headerSize;
            dataLength = headerSize - FIELD_OFFSET( MODE_PARAMETER_HEADER, MediumType );
            modeHeader.ModeDataLength = (UCHAR)dataLength;
            modeHeader.MediumType = 0x00;
            modeHeader.DeviceSpecificParameter = 0x00;
            modeHeader.BlockDescriptorLength = 0x00;
        }

        break;

    case 10:

        dataBufferLength = *(USHORT *)cdb->MODE_SENSE10.AllocationLength;
        valueType = cdb->MODE_SENSE10.Pc;
        headerSize = sizeof(MODE_PARAMETER_HEADER10);

        if ( dataBufferLength > headerSize ) {

            header = &modeHeader10;
            data = (char*)header + headerSize;
            dataLength = headerSize - FIELD_OFFSET( MODE_PARAMETER_HEADER10, MediumType );
            RtlCopyMemory(
                modeHeader10.ModeDataLength,
                &dataLength,
                sizeof(modeHeader10.ModeDataLength)
                );
            modeHeader10.MediumType = 0x00;
            modeHeader10.DeviceSpecificParameter = 0x00;
            modeHeader10.BlockDescriptorLength[0] = 0;
            modeHeader10.BlockDescriptorLength[1] = 0;
        }

        break;

    default:

        //
        // Can't get here.
        //

        ASSERT( FALSE );

        Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ( header != NULL ) {

        RtlCopyMemory( Srb->DataBuffer, header, headerSize );
        dataBufferLength -= headerSize;
    }

    if ( (data != NULL) && (dataBufferLength != 0) ) {

        RtlCopyMemory(
            (PUCHAR)Srb->DataBuffer + headerSize,
            data,
            min( dataBufferLength, dataSize )
            );
    }

    return STATUS_SUCCESS;

} // BuildModeSenseInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rbclib\rbc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       rbc.c
//
//--------------------------------------------------------------------------

#include "wdm.h"
#include "ntddstor.h"
#include "rbc.h"


NTSTATUS
Rbc_Scsi_Conversion(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PSCSI_REQUEST_BLOCK *OriginalSrb,
    IN PMODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE RbcHeaderAndPage,
    IN BOOLEAN OutgoingRequest,
    IN BOOLEAN RemovableMedia
    )
/*++

Routine Description:

    It translates scsi commands to their RBC equivalents, ONLY if they differ in each spec
    The translation is done before request is issued and in some cases, after the request is
    completed.
    On requests that have been completed it will check the Original Cdb (must be passed in)
    and try to use information from the RBC device parameters page, the caller retrieved
    prior to this call, from the device, and make up SCSI_MODE pages requested in the original
    request
    On request that are outgoing, the function will determine if it needs to save the original
    cdb and completely replace it with an RBC equivalent. In that case it will return a pointer
    to pool, allocated as aplaceholder for the original cdb, that the caller must free, after
    the request is complete..

Arguments:

    DeviceExtension - Sbp2 extension
    Srb - Pointer To scsi request block.
    DeviceParamsPage - Used only on completed requests. Contains device RBC single mode page
    OutgoingRequest - IF set to TRUE, this srb has not been issued yet

Return Value:

--*/


{
    BOOLEAN wcd;
    UCHAR pageCode;
    PCDB_RBC cdbRbc;
    PCDB cdb;

    PMODE_PARAMETER_HEADER modeHeader=NULL;
    PMODE_PARAMETER_BLOCK blockDescriptor;

    PMODE_CACHING_PAGE cachePage;
    ULONG modeHeaderLength ;
    ULONG availLength;

    NTSTATUS status = STATUS_PENDING;

    if (!OutgoingRequest) {

        //
        // completed request translation
        //
        
        if (*OriginalSrb) {

            cdb = (PCDB) &(*OriginalSrb)->Cdb[0];

        } else {

            cdb = (PCDB) &Srb->Cdb[0];
        }

        //
        // If there was an error then unwind any MODE_SENSE hacks
        //

        if (Srb->SrbStatus != SRB_STATUS_SUCCESS) {

            if (*OriginalSrb != NULL  &&

                cdb->CDB10.OperationCode == SCSIOP_MODE_SENSE) {

                if ((*OriginalSrb)->OriginalRequest !=
                        ((PIRP) Srb->OriginalRequest)->MdlAddress) {

                    IoFreeMdl (((PIRP) Srb->OriginalRequest)->MdlAddress);

                    ((PIRP) Srb->OriginalRequest)->MdlAddress =
                        (*OriginalSrb)->OriginalRequest;

                    Srb->DataBuffer = (*OriginalSrb)->DataBuffer;

                    Srb->DataTransferLength =
                        cdb->MODE_SENSE.AllocationLength;
                }

                // NOTE: *OriginalSrb will be freed by caller
            }

            return STATUS_UNSUCCESSFUL;
        }


        modeHeaderLength = sizeof(MODE_PARAMETER_HEADER)+sizeof(MODE_PARAMETER_BLOCK);

        switch (cdb->CDB10.OperationCode) {

        case SCSIOP_MODE_SENSE:

            if (cdb->MODE_SENSE.PageCode != MODE_PAGE_RBC_DEVICE_PARAMETERS) {

                if (*OriginalSrb == NULL) {

                    return STATUS_UNSUCCESSFUL;
                }

                //
                // If we used the RbcHeaderAndPage buffer then free the
                // mdl we alloc'd & restore the original mdl & data buf addrs
                //
                // Else copy the data returned in the original buffer to
                // the RbcHeaderandPage buffer so we can safely reference
                // it while munging
                //

                if (((PIRP) Srb->OriginalRequest)->MdlAddress !=
                        (*OriginalSrb)->OriginalRequest) {

                    IoFreeMdl (((PIRP) Srb->OriginalRequest)->MdlAddress);

                    ((PIRP) Srb->OriginalRequest)->MdlAddress =
                        (*OriginalSrb)->OriginalRequest;

                    Srb->DataBuffer = (*OriginalSrb)->DataBuffer;

                } else {

                    RtlCopyMemory(
                         RbcHeaderAndPage,
                         Srb->DataBuffer,
                         sizeof (*RbcHeaderAndPage)
                         );
                }

                availLength = cdb->MODE_SENSE.AllocationLength;
                Srb->DataTransferLength = availLength;

                //
                // Put back together the data the class driver expects to get
                // from the RBC device. IF it requested for 0x3f all pages,
                // we need to make block descriptors...
                //

                if (cdb->MODE_SENSE.Dbd == 0) {

                    //
                    // make mode header and block...
                    //

                    if (availLength >= modeHeaderLength) {

                        modeHeader = (PMODE_PARAMETER_HEADER) Srb->DataBuffer;
                        modeHeader->BlockDescriptorLength = sizeof(MODE_PARAMETER_BLOCK);
                        modeHeader->MediumType = 0x00;
                        modeHeader->ModeDataLength = 0 ;

                        //
                        // This means we have a removable medium otherwise
                        // all bits are 0
                        //

                        modeHeader->DeviceSpecificParameter =
                            (RbcHeaderAndPage->Page.WriteDisabled) << 7;
                        
                        modeHeader->DeviceSpecificParameter |=
                            (!RbcHeaderAndPage->Page.WriteCacheDisable) << 4;

                        //
                        // make the parameter block
                        //

                        blockDescriptor = (PMODE_PARAMETER_BLOCK)modeHeader;
                        (ULONG_PTR)blockDescriptor += sizeof(MODE_PARAMETER_HEADER);

                        blockDescriptor->DensityCode    = 0x00;
                        blockDescriptor->BlockLength[2] =
                            RbcHeaderAndPage->Page.LogicalBlockSize[1]; //LSB
                        blockDescriptor->BlockLength[1] =
                            RbcHeaderAndPage->Page.LogicalBlockSize[0]; //MSB
                        blockDescriptor->BlockLength[0] = 0;

                        RtlCopyMemory(
                            &blockDescriptor->NumberOfBlocks[0],
                            &RbcHeaderAndPage->Page.NumberOfLogicalBlocks[2],
                            3
                            ); //LSB

                        //
                        // put in the returned data a bunch of mode pages...
                        //

                        availLength -= modeHeaderLength;
                    }
                }

                //
                // right now i only support cache page.
                // add here support for more pages...
                //

                if ((availLength >= sizeof(MODE_CACHING_PAGE)) && ((cdb->MODE_SENSE.PageCode == 0x3f) ||
                    (cdb->MODE_SENSE.PageCode == MODE_PAGE_CACHING))){

                    availLength -= sizeof(MODE_CACHING_PAGE);

                    //
                    // create cache page..
                    //

                    if (modeHeader) {

                        modeHeader->ModeDataLength += sizeof(MODE_CACHING_PAGE);
                        cachePage = (PMODE_CACHING_PAGE)blockDescriptor;
                        (ULONG_PTR)cachePage += sizeof(MODE_PARAMETER_BLOCK);

                    } else {

                        cachePage = (PMODE_CACHING_PAGE)Srb->DataBuffer;
                    }

                    RtlZeroMemory(&cachePage->DisablePrefetchTransfer[0],sizeof(MODE_CACHING_PAGE));

                    cachePage->PageCode = MODE_PAGE_CACHING;
                    cachePage->PageLength = sizeof(MODE_CACHING_PAGE);

                    cachePage->WriteCacheEnable = (!RbcHeaderAndPage->Page.WriteCacheDisable);
                    cachePage->PageSavable = 1;
                    cachePage->WriteRetensionPriority = 0;
                    cachePage->ReadRetensionPriority = 0;
                    cachePage->MultiplicationFactor = 0;
                    cachePage->ReadDisableCache = 0;
                }
            }

            break;

        case SCSIOP_MODE_SELECT:

            if (Srb->DataTransferLength ==
                    sizeof(MODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE)) {

                RbcHeaderAndPage->Page.WriteCacheDisable =
                    ((PMODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE)
                        Srb->DataBuffer)->Page.WriteCacheDisable;
            }

            break;
        }

    } else {

        //
        // outgoing request translation
        //

        modeHeaderLength = sizeof(MODE_PARAMETER_HEADER)+sizeof(MODE_PARAMETER_BLOCK);
        cdbRbc = (PCDB_RBC)Srb->Cdb;
        cdb = (PCDB)Srb->Cdb;

        switch (cdb->CDB10.OperationCode) {

        case SCSIOP_START_STOP_UNIT:

            if (cdbRbc->START_STOP_RBC.Start) {

                //
                // power on
                //

                cdbRbc->START_STOP_RBC.PowerConditions = START_STOP_RBC_POWER_CND_ACTIVE;

            } else {

                cdbRbc->START_STOP_RBC.PowerConditions = START_STOP_RBC_POWER_CND_STANDBY;

            }

            if (cdbRbc->START_STOP_RBC.LoadEject) {

                cdbRbc->START_STOP_RBC.PowerConditions = 0;

            }

            break;

        case SCSIOP_MODE_SELECT:

            cdb->MODE_SELECT.PFBit = 1;
            cdb->MODE_SELECT.SPBit = 1;

            //
            // we need to ficure out what page is the driver trying to write, check if that page
            // has relevant bits that need to be changed in the single RBC page, the change this
            // mode select to actually write the RBC mode page..
            //

            cachePage = (PMODE_CACHING_PAGE) Srb->DataBuffer;
            (ULONG_PTR)cachePage += modeHeaderLength;

            //
            // the length of the request has to change also, however the RBC page
            // is always less than the size of the header blocks + any scsi mode page..
            //

            if (Srb->DataTransferLength >=
                    sizeof(MODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE)) {

                pageCode = cachePage->PageCode;

                if (pageCode == MODE_PAGE_CACHING) {

                    wcd = !cachePage->WriteCacheEnable;
                }

                cdb->MODE_SELECT.ParameterListLength = (UCHAR)
                    (Srb->DataTransferLength =
                        sizeof(MODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE));

                RtlCopyMemory(
                    Srb->DataBuffer,
                    RbcHeaderAndPage,
                    sizeof(MODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE)
                    );

                modeHeader = (PMODE_PARAMETER_HEADER) Srb->DataBuffer;

                modeHeader->ModeDataLength          =       // per SPC-2
                modeHeader->MediumType              =       // per RBC
                modeHeader->DeviceSpecificParameter =       // per RBC
                modeHeader->BlockDescriptorLength   = 0;    // per RBC

                if (pageCode == MODE_PAGE_CACHING) {

                    ((PMODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE) modeHeader)
                        ->Page.WriteCacheDisable = wcd;
                }
            }

            break;

        case SCSIOP_MODE_SENSE:

            //
            // mode senses are complicated since RBC differs ALOT from scsi.
            // We have to save the original cdb, requst fromt he device the RBC mode page
            // then upon succesful completion, re-create the data, the class drivers expect.
            //

            if (cdb->MODE_SENSE.PageCode != MODE_PAGE_RBC_DEVICE_PARAMETERS) {

                //
                // RBC devices only support requests for the RBC dev params
                // page, so we need to convert any other page requests
                //

                if (!RemovableMedia &&
                    Srb->DataTransferLength == (sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PARAMETER_BLOCK))) {

                    //
                    // They just want the mode header and mode block, so
                    // fill it in here from our cached RBC page
                    //

                    modeHeader = (PMODE_PARAMETER_HEADER) Srb->DataBuffer;
                    modeHeader->BlockDescriptorLength = sizeof(MODE_PARAMETER_BLOCK);
                    modeHeader->MediumType = 0x00;
                    modeHeader->ModeDataLength = 0 ;

                    //
                    // this means we have a removable medium otherwise all bits are 0
                    //

                    modeHeader->DeviceSpecificParameter =
                        RbcHeaderAndPage->Page.WriteDisabled << 7;
                    
                    modeHeader->DeviceSpecificParameter |=
                        (!RbcHeaderAndPage->Page.WriteCacheDisable) << 4;

                    //
                    // make the parameter block
                    //

                    blockDescriptor = (PMODE_PARAMETER_BLOCK)modeHeader;
                    (ULONG_PTR)blockDescriptor += sizeof(MODE_PARAMETER_HEADER);

                    blockDescriptor->DensityCode = 0x00;
                    blockDescriptor->BlockLength[2] =
                        RbcHeaderAndPage->Page.LogicalBlockSize[1]; //LSB
                    blockDescriptor->BlockLength[1] =
                        RbcHeaderAndPage->Page.LogicalBlockSize[0]; //MSB
                    blockDescriptor->BlockLength[0] = 0;

                    RtlCopyMemory(
                        &blockDescriptor->NumberOfBlocks[0],
                        &RbcHeaderAndPage->Page.NumberOfLogicalBlocks[2],
                        3
                        ); //LSB

                    status = STATUS_SUCCESS;

                } else {

                    //
                    // Allocate an intermediate srb that we can store some
                    // of the original request info in
                    //

                    *OriginalSrb = ExAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof (**OriginalSrb),
                        '2pbs'
                        );
        
                    if (*OriginalSrb == NULL) {

                        return STATUS_INSUFFICIENT_RESOURCES;
                    }

                    //
                    // If the data buffer isn't large enough to contain the
                    // rbc header & page then we'll use the passed-in
                    // RbcHeaderAndPage buffer to retreive the data
                    //

                    (*OriginalSrb)->OriginalRequest =
                        ((PIRP) Srb->OriginalRequest)->MdlAddress;

                    if (Srb->DataTransferLength < sizeof (*RbcHeaderAndPage)) {

                        ((PIRP) Srb->OriginalRequest)->MdlAddress =
                            IoAllocateMdl(
                                RbcHeaderAndPage,
                                sizeof (*RbcHeaderAndPage),
                                FALSE,
                                FALSE,
                                NULL
                                );

                        if (((PIRP) Srb->OriginalRequest)->MdlAddress ==NULL) {

                            ExFreePool (*OriginalSrb);
                            *OriginalSrb = NULL;

                            return STATUS_INSUFFICIENT_RESOURCES;
                        }

                        MmBuildMdlForNonPagedPool(
                            ((PIRP) Srb->OriginalRequest)->MdlAddress
                            );

                        (*OriginalSrb)->DataBuffer = Srb->DataBuffer;

                        Srb->DataBuffer = RbcHeaderAndPage;
                    }

                    //
                    // Save the original cdb values
                    //

                    RtlCopyMemory ((*OriginalSrb)->Cdb, cdb, Srb->CdbLength);

                    //
                    // Now munge the cdb as needed to get the rbc header & page
                    //

                    cdb->MODE_SENSE.Dbd = 1;
                    cdb->MODE_SENSE.PageCode = MODE_PAGE_RBC_DEVICE_PARAMETERS;

                    cdb->MODE_SENSE.AllocationLength = (UCHAR)
                    (Srb->DataTransferLength = sizeof(*RbcHeaderAndPage));
                }
            }

            break;
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ramdisk\utils.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This file contains utility code for the RAM disk driver.

Author:

    Chuck Lenzmeier (ChuckL) 2001

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA

#if defined(POOL_DBG)
#pragma alloc_text( INIT, RamdiskInitializePoolDebug )
#endif // POOL_DBG

#endif // ALLOC_PRAGMA

NTSTATUS
SendIrpToThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sends an IRP off to the worker thread so that it can be
    processed in thread context.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    None.

--*/

{
    PIO_WORKITEM workItem;

    //
    // Mark the IRP pending. Queue the IRP to a worker thread.
    //

    IoMarkIrpPending( Irp );

    workItem = IoAllocateWorkItem( DeviceObject );

    if ( workItem != NULL ) {

        //
        // Save the work item pointer so the worker thread can find it.
        //

        Irp->Tail.Overlay.DriverContext[0] = workItem;

        IoQueueWorkItem( workItem, RamdiskWorkerThread, DelayedWorkQueue, Irp );

        return STATUS_PENDING;
    }

    return STATUS_INSUFFICIENT_RESOURCES;

} // SendIrpToThread

PUCHAR
RamdiskMapPages (
    IN PDISK_EXTENSION DiskExtension,
    IN ULONGLONG Offset,
    IN ULONG RequestedLength,
    OUT PULONG ActualLength
    )

/*++

Routine Description:

    This routine maps pages of a RAM disk image into the system process.

Arguments:

    DiskExtension - a pointer to the device extension for the target device
        object

    Offset - the offset into the RAM disk image at which the mapping is to
        start

    RequestedLength - the desired length of the mapping

    ActualLength - returns the actual length of the mapping. This will be less
        than or equal to RequestedLength. If less than, the caller will need
        to call again to get the remainder of the desired range mapped.
        Because the number of available ranges may be limited, the caller
        should execute the required operation on one segment of the range and
        unmap it before mapping the next segment.

Return Value:

    PUCHAR - a pointer to the mapped space; NULL if the mapping failed

--*/

{
    NTSTATUS status;
    PUCHAR va;
    ULONGLONG diskRelativeOffset;
    ULONGLONG fileRelativeOffset;
    ULONG viewRelativeOffset;

    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                ("RamdiskMapPages: offset %I64x, length %x\n", Offset, RequestedLength) );

    //
    // The input Offset is relative to the start of the disk image, which
    // may not be the same as the start of the file or memory block. Capture
    // Offset into diskRelativeOffset, then calculate fileRelativeOffset as
    // the offset from the start of the file or memory block.
    //

    diskRelativeOffset = Offset;
    fileRelativeOffset = DiskExtension->DiskOffset + diskRelativeOffset;

    if ( RAMDISK_IS_FILE_BACKED(DiskExtension->DiskType) ) {

        //
        // For a file-backed RAM disk, we need to map the range into memory.
        //

        while ( TRUE ) {
        
            PLIST_ENTRY listEntry;
            PVIEW view;
    
            //
            // Lock the list of view descriptors.
            //
    
            KeEnterCriticalRegion();
            ExAcquireFastMutex( &DiskExtension->Mutex );
    
            //
            // Walk the list of view descriptors. Look for one that includes the
            // start of the range we're mapping.
            //
    
            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("RamdiskMapPages: looking for matching view; file offset %I64x\n",
                        fileRelativeOffset) );

            listEntry = DiskExtension->ViewsByOffset.Flink;
    
            while ( listEntry != &DiskExtension->ViewsByOffset ) {
    
                view = CONTAINING_RECORD( listEntry, VIEW, ByOffsetListEntry );
    
                DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                            ("RamdiskMapPages: view %p; offset %I64x, length %x\n",
                                view, view->Offset, view->Length) );

                ASSERT( (view->Offset + view->Length) >= view->Offset );

                if ( (view->Offset <= fileRelativeOffset) &&
                     (view->Offset + view->Length) > fileRelativeOffset ) {
    
                    //
                    // This view includes the start of our range. Reference it.
                    //
    
                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("RamdiskMapPages: choosing existing view %p; offset %I64x, length %x\n",
                                    view, view->Offset, view->Length) );
    
                    if ( !view->Permanent ) {
                    
                        view->ReferenceCount++;

                        DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                    ("RamdiskMapPages: view %p; new refcount %x\n",
                                        view, view->ReferenceCount) );
        
                    } else {

                        DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                    ("RamdiskMapPages: view %p is permanent\n", view) );
                    }

                    //
                    // Move the view to the front of the MRU list.
                    //
    
                    RemoveEntryList( &view->ByMruListEntry );
                    InsertHeadList( &DiskExtension->ViewsByMru, &view->ByMruListEntry );
    
                    ExReleaseFastMutex( &DiskExtension->Mutex );
                    KeLeaveCriticalRegion();

                    //
                    // Calculate the amount of data that the caller can look
                    // at in this range. Usually this will be the requested
                    // amount, but if the caller's offset is close to the end
                    // of a view, the caller will only be able to look at data
                    // up to the end of the view.
                    //

                    viewRelativeOffset = (ULONG)(fileRelativeOffset - view->Offset);

                    *ActualLength = view->Length - viewRelativeOffset;
                    if ( *ActualLength > RequestedLength ) {
                        *ActualLength = RequestedLength;
                    }

                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("RamdiskMapPages: requested length %x; mapped length %x\n",
                                    RequestedLength, *ActualLength) );
                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("RamdiskMapPages: view base %p; returned VA %p\n",
                                    view->Address,
                                    view->Address + viewRelativeOffset) );

                    //
                    // Return the virtual address corresponding to the caller's
                    // specified offset, which will usually be offset from the
                    // base of the view.
                    //

                    return view->Address + viewRelativeOffset;
                }
    
                //
                // This view does not include the start of our range. If the view
                // starts above the start of our range, then our range is not
                // currently mapped.
                //
    
                if ( view->Offset > fileRelativeOffset ) {
    
                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("%s", "RamdiskMapPages: view too high; our range not mapped\n") );

                    break;
                }
    
                //
                // Check the next view in the list.
                //
    
                listEntry = listEntry->Flink;
            }
    
            //
            // We didn't find a view that maps the start of our range. Look for a
            // free view descriptor.
            //

            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("%s", "RamdiskMapPages: looking for free view\n") );

            listEntry = DiskExtension->ViewsByMru.Blink;
      
            while ( listEntry != &DiskExtension->ViewsByMru ) {
      
                view = CONTAINING_RECORD( listEntry, VIEW, ByMruListEntry );
      
                DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                            ("RamdiskMapPages: view %p; permanent %x, refcount %x\n",
                                view, view->Permanent, view->ReferenceCount) );

                if ( !view->Permanent && (view->ReferenceCount == 0) ) {
      
                    //
                    // This view descriptor is free. If it's currently mapped,
                    // unmap it.
                    //
      
                    PVOID mappedAddress;
                    ULONGLONG mappedOffset;
                    SIZE_T mappedLength;
      
                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("RamdiskMapPages: view %p is free\n", view) );

                    if ( view->Address != NULL ) {
      
                        DBGPRINT( DBG_WINDOW, DBG_VERBOSE,
                                    ("RamdiskMapPages: unmapping view %p; offset %I64x, "
                                     "length %x, addr %p\n", view, view->Offset,
                                     view->Length, view->Address) );

                        MmUnmapViewOfSection( PsGetCurrentProcess(), view->Address );

                        //
                        // Reset the view descriptor and move it to the tail of
                        // the MRU list and the head of the by-offset list. We
                        // do this here in case we have to bail later (because
                        // mapping a new view fails).
                        //

                        view->Offset = 0;
                        view->Length = 0;
                        view->Address = NULL;
      
                        RemoveEntryList( listEntry );
                        InsertTailList( &DiskExtension->ViewsByMru, listEntry );

                        RemoveEntryList( &view->ByOffsetListEntry );
                        InsertHeadList( &DiskExtension->ViewsByOffset, &view->ByOffsetListEntry );
                    }
      
                    //
                    // Map a view to include the start of our range. Round the
                    // caller's offset down to the start of a view range.
                    //
      
                    mappedOffset = fileRelativeOffset & ~(ULONGLONG)(DiskExtension->ViewLength - 1);
                    mappedLength = DiskExtension->ViewLength;
                    if ( (mappedOffset + mappedLength) > DiskExtension->FileRelativeEndOfDisk) {
                        mappedLength = (SIZE_T)(DiskExtension->FileRelativeEndOfDisk - mappedOffset);
                    }
                    mappedAddress = NULL;
      
                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("RamdiskMapPages: remapping view %p; offset %I64x, "
                                 "length %x\n", view, mappedOffset, mappedLength) );

                    status = MmMapViewOfSection(
                                DiskExtension->SectionObject,
                                PsGetCurrentProcess(),
                                &mappedAddress,
                                0,
                                0,
                                (PLARGE_INTEGER)&mappedOffset,
                                &mappedLength,
                                ViewUnmap,
                                0,
                                PAGE_READWRITE
                                );
      
                    if ( !NT_SUCCESS(status) ) {
      
                        //
                        // Unable to map the range. Inform the caller by returning
                        // NULL.
                        //
                        // ISSUE: Think about unmapping another region to see if
                        // mapping will then succeed.
                        //
      
                        DBGPRINT( DBG_WINDOW, DBG_ERROR,
                                    ("RamdiskMapPages: unable to map view: %x\n", status) );
    
                        ExReleaseFastMutex( &DiskExtension->Mutex );
                        KeLeaveCriticalRegion();
        
                        return NULL;
                    }
      
                    DBGPRINT( DBG_WINDOW, DBG_VERBOSE,
                                ("RamdiskMapPages: remapped view %p; offset %I64x, "
                                 "length %x, addr %p\n", view, mappedOffset, mappedLength,
                                 mappedAddress) );

                    //
                    // Capture the mapped range information into the view
                    // descriptor. Set the reference count to 1. Insert the
                    // view at the front of the MRU list, and at the
                    // appropriate point in the by-offset list.
                    //

                    view->Offset = mappedOffset;
                    view->Length = (ULONG)mappedLength;
                    view->Address = mappedAddress;
      
                    ASSERT( (view->Offset + view->Length) >= view->Offset );

                    view->ReferenceCount = 1;
      
                    RemoveEntryList( &view->ByMruListEntry );
                    InsertHeadList( &DiskExtension->ViewsByMru, &view->ByMruListEntry );

                    //
                    // Remove the view descriptor from its current point in
                    // the by-offset list (at or near the front, because it's
                    // currently unmapped). Scan from the tail of the by-offset
                    // list (highest offset down), looking for the first view
                    // that has an offset less than or equal to the new view.
                    // Insert the new view after that view. (If there are no
                    // views with an offset <= this one, it goes at the front
                    // of the list.)
                    //

                    RemoveEntryList( &view->ByOffsetListEntry );

                    listEntry = DiskExtension->ViewsByOffset.Blink;
            
                    while ( listEntry != &DiskExtension->ViewsByOffset ) {
            
                        PVIEW view2 = CONTAINING_RECORD( listEntry, VIEW, ByOffsetListEntry );
            
                        if ( view2->Offset <= view->Offset ) {

                            break;
                        }
            
                        listEntry = listEntry->Blink;
                    }

                    InsertHeadList( listEntry, &view->ByOffsetListEntry );

                    ExReleaseFastMutex( &DiskExtension->Mutex );
                    KeLeaveCriticalRegion();
      
                    //
                    // Calculate the amount of data that the caller can look
                    // at in this range. Usually this will be the requested
                    // amount, but if the caller's offset is close to the end
                    // of a view, the caller will only be able to look at data
                    // up to the end of the view.
                    //

                    viewRelativeOffset = (ULONG)(fileRelativeOffset - view->Offset);

                    *ActualLength = view->Length - viewRelativeOffset;
                    if ( *ActualLength > RequestedLength ) {
                        *ActualLength = RequestedLength;
                    }
      
                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("RamdiskMapPages: requested length %x; mapped length %x\n",
                                    RequestedLength, *ActualLength) );
                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("RamdiskMapPages: view base %p; returned VA %p\n",
                                    view->Address,
                                    view->Address + viewRelativeOffset) );
    
                    //
                    // Return the virtual address corresponding to the caller's
                    // specified offset, which will usually be offset from the
                    // base of the view.
                    //

                    return view->Address + viewRelativeOffset;
                }
      
                //
                // This view is not free. Try the previous view in the MRU list.
                //
      
                listEntry = listEntry->Blink;
            }
      
            //
            // We were unable to find a free view descriptor. Wait for one to
            // become available and start over.
            //
            // Before leaving the critical section, increment the count of
            // waiters. Then leave the critical section and wait on the
            // semaphore. The unmap code uses the waiter count to determine
            // how many times to release the semaphore. In this way, all
            // threads that are waiting or have decided to wait when the
            // unmap code runs will be awakened.
            //
      
            DiskExtension->ViewWaiterCount++;
      
            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("RamdiskMapPages: can't find free view, so waiting; new waiter count %x\n",
                            DiskExtension->ViewWaiterCount) );

            ExReleaseFastMutex( &DiskExtension->Mutex );
            KeLeaveCriticalRegion();
            
            status = KeWaitForSingleObject(
                        &DiskExtension->ViewSemaphore,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL );

            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("%s", "RamdiskMapPages: done waiting for free view\n") );
        }

    } else if ( DiskExtension->DiskType == RAMDISK_TYPE_BOOT_DISK ) {

        //
        // For a boot disk RAM disk, the image is contained in contiguous
        // reserved physical pages. Use MmMapIoSpace to get a virtual
        // address that corresponds to the physical address.
        //

        ULONG mappingSize;
        PHYSICAL_ADDRESS physicalAddress;
        PUCHAR mappedAddress;

        //
        // Determine how many pages must be mapped. Determine the base
        // physical address of the desired range. Map the range.
        //

        mappingSize = ADDRESS_AND_SIZE_TO_SPAN_PAGES(fileRelativeOffset, RequestedLength) * PAGE_SIZE;
    
        physicalAddress.QuadPart = (DiskExtension->BasePage +
                                    (fileRelativeOffset / PAGE_SIZE)) * PAGE_SIZE;
    
        mappedAddress = MmMapIoSpace( physicalAddress, mappingSize, MmCached );

        if ( mappedAddress == NULL ) {

            //
            // Unable to map the physical pages. Return NULL.
            //

            va = NULL;

        } else {

            //
            // Add the offset in the page to the returned virtual address.
            //

            va = mappedAddress + (fileRelativeOffset & (PAGE_SIZE - 1));
        }

        *ActualLength = RequestedLength;

    } else {

        //
        // For a virtual floppy RAM disk, the image is contained in contiguous
        // virtual memory. 
        //

        ASSERT( DiskExtension->DiskType == RAMDISK_TYPE_VIRTUAL_FLOPPY );

        va = (PUCHAR)DiskExtension->BaseAddress + fileRelativeOffset;

        *ActualLength = RequestedLength;
    }

    return va;

} // RamdiskMapPages

VOID
RamdiskUnmapPages (
    IN PDISK_EXTENSION DiskExtension,
    IN PUCHAR Va,
    IN ULONGLONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine unmaps previously mapped pages of a RAM disk image.

Arguments:

    DiskExtension - a pointer to the device extension for the target device
        object

    Va - the virtual address assigned to the mapping. This is unused for
        file-backed RAM disks.

    Offset - the offset into the RAM disk image at which the mapping starts

    Length - the length of the mapping

Return Value:

    None.

--*/

{
    ULONGLONG diskRelativeOffset;
    ULONGLONG fileRelativeOffset;
    ULONG viewRelativeOffset;

    //
    // The input Offset is relative to the start of the disk image, which
    // may not be the same as the start of the file or memory block. Capture
    // Offset into diskRelativeOffset, then calculate fileRelativeOffset as
    // the offset from the start of the file or memory block.
    //

    diskRelativeOffset = Offset;
    fileRelativeOffset = DiskExtension->DiskOffset + diskRelativeOffset;

    if ( RAMDISK_IS_FILE_BACKED(DiskExtension->DiskType) ) {

        //
        // For a file-backed RAM disk, we need to decrement the reference
        // count on all views that cover the specified range.
        //
        // Note: In the current implementation, no caller ever maps more
        // than one range at a time, and therefore no call to this routine
        // will need to dereference more than one view. But this routine
        // is written to allow for ranges that cover multiple views.
        //

        PLIST_ENTRY listEntry;
        PVIEW view;
        ULONGLONG rangeStart = fileRelativeOffset;
        ULONGLONG rangeEnd = fileRelativeOffset + Length;
        BOOLEAN wakeWaiters = FALSE;

        //
        // Lock the list of view descriptors.
        //

        KeEnterCriticalRegion();
        ExAcquireFastMutex( &DiskExtension->Mutex );

        //
        // Walk the list of view descriptors. For each one that includes the
        // range that we're unmapping, decrement the reference count.
        //

        listEntry = DiskExtension->ViewsByOffset.Flink;

        while ( Length != 0 ) {

            ASSERT( listEntry != &DiskExtension->ViewsByOffset );

            view = CONTAINING_RECORD( listEntry, VIEW, ByOffsetListEntry );

            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("RamdiskUnmapPages: view %p; offset %I64x, length %x\n",
                            view, view->Offset, view->Length) );

            if ( (view->Offset + view->Length) <= rangeStart ) {

                //
                // This view lies entirely below our range. Move on.
                //

                DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                            ("%s", "RamdiskMapPages: view too low; skipping\n") );

                listEntry = listEntry->Flink;

                ASSERT( listEntry != &DiskExtension->ViewsByOffset );

                continue;
            }

            //
            // This view does not lie below our range. Since the view list
            // is ordered by offset, and we have length left to unmap, this
            // view must NOT lie entirely ABOVE our range.
            //

            ASSERT( view->Offset < rangeEnd );

            //
            // Decrement the reference count for this view. If the count goes
            // to zero, we need to inform any waiters that at least one free
            // view is available.
            //
            // ISSUE: Note that unreferenced views remain mapped indefinitely.
            // We only unmap a view when we need to map a different view. If
            // a RAM disk goes idle, its views remain mapped, using up virtual
            // address space in the system process. With the current default
            // view count and length, this is 8 MB of VA. This is probably
            // not enough to make it worthwhile to implement a timer to unmap
            // idle views.
            //

            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("RamdiskUnmapPages: dereferencing view %p; offset %I64x, length %x\n",
                            view, view->Offset, view->Length) );

            if ( !view->Permanent ) {

                view->ReferenceCount--;

                if ( view->ReferenceCount == 0 ) {
                    wakeWaiters = TRUE;
                }

                DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                            ("RamdiskUnmapPages: view %p; new refcount %x\n",
                                view, view->ReferenceCount) );

            } else {

                DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                            ("RamdiskUnmapPages: view %p is permanent\n", view) );
            }

            //
            // Subtract the length of this view from the amount we're
            // unmapping. If the view fully encompasses our range, we're done.
            //

            if ( (view->Offset + view->Length) >= rangeEnd ) {

                Length = 0;

            } else {

                viewRelativeOffset = (ULONG)(fileRelativeOffset - view->Offset);
                Length -= view->Length - viewRelativeOffset;
                Offset = view->Offset + view->Length;

                ASSERT( Length != 0 );

                //
                // Move to the next view.
                //

                listEntry = listEntry->Flink;
            }
        }

        //
        // If one or more views are now free, and there are threads waiting,
        // wake them up now.
        //

        if ( wakeWaiters && (DiskExtension->ViewWaiterCount != 0) ) {

            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("RamdiskUnmapPages: waking %x waiters\n",
                            DiskExtension->ViewWaiterCount) );

            KeReleaseSemaphore(
                &DiskExtension->ViewSemaphore,
                0,
                DiskExtension->ViewWaiterCount,
                FALSE
                );

            DiskExtension->ViewWaiterCount = 0;
        }

        ExReleaseFastMutex( &DiskExtension->Mutex );
        KeLeaveCriticalRegion();

    } else if ( DiskExtension->DiskType == RAMDISK_TYPE_BOOT_DISK ) {

        //
        // For a boot disk RAM disk, use MmUnmapIoSpace to undo what
        // RamdiskMapPages did.
        //

        PUCHAR mappedAddress;
        ULONG mappingSize;

        //
        // The actual mapped address is at the base of the page given by Va.
        // The actual length of the mapping is based on the number of pages
        // covered by the range specified by Offset and Length.
        //

        mappedAddress = Va - (fileRelativeOffset & (PAGE_SIZE - 1));
        mappingSize = ADDRESS_AND_SIZE_TO_SPAN_PAGES(fileRelativeOffset, Length) * PAGE_SIZE;

        MmUnmapIoSpace( mappedAddress, mappingSize );
    }

    return;

} // RamdiskUnmapPages

NTSTATUS
RamdiskFlushViews (
    IN PDISK_EXTENSION DiskExtension
    )
{
    NTSTATUS status;
    NTSTATUS returnStatus;
    IO_STATUS_BLOCK iosb;
    PLIST_ENTRY listEntry;
    PVIEW view;
    SIZE_T viewLength;

    PAGED_CODE();

    DBGPRINT( DBG_WINDOW, DBG_PAINFUL, ("%s", "RamdiskFlushViews\n") );

    ASSERT( RAMDISK_IS_FILE_BACKED(DiskExtension->DiskType) );

    //
    // Lock the list of view descriptors.
    //

    //
    // Walk the list of view descriptors. For each one that is currently
    // mapped, flush its virtual memory to the backing file.
    //

    returnStatus = STATUS_SUCCESS;

    KeEnterCriticalRegion();
    ExAcquireFastMutex( &DiskExtension->Mutex );

    listEntry = DiskExtension->ViewsByOffset.Flink;

    while ( listEntry != &DiskExtension->ViewsByOffset ) {

        view = CONTAINING_RECORD( listEntry, VIEW, ByOffsetListEntry );

        DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                    ("RamdiskFlushViews: view %p; addr %p, offset %I64x, length %x\n",
                        view, view->Address, view->Offset, view->Length) );

        if ( view->Address != NULL ) {

            //
            // This view is mapped. Flush it.
            //

            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("%s", "RamdiskMapPages: view mapped; flushing\n") );

            viewLength = view->Length;

            status = ZwFlushVirtualMemory(
                        NtCurrentProcess(),
                        &view->Address,
                        &viewLength,
                        &iosb
                        );

            if ( NT_SUCCESS(status) ) {
                status = iosb.Status;
            }

            if ( !NT_SUCCESS(status) ) {

                DBGPRINT( DBG_WINDOW, DBG_ERROR,
                            ("RamdiskFlushViews: ZwFlushVirtualMemory failed: %x\n", status) );

                if ( returnStatus == STATUS_SUCCESS ) {
                    returnStatus = status;
                }
            }
        }

        //
        // Move to the next view.
        //

        listEntry = listEntry->Flink;
    }

    ExReleaseFastMutex( &DiskExtension->Mutex );
    KeLeaveCriticalRegion();

    return returnStatus;

} // RamdiskFlushViews

//
// Pool allocation debugging code.
//

#if defined(POOL_DBG)

//
// Allocations owned by the driver (both allocated by and deallocated by the
// driver) have the following header.
//

typedef struct _MY_POOL {
    union {
        CHAR Signature[8];
        ULONG SigLong[2];
    } ;
    LIST_ENTRY ListEntry;
    PVOID File;
    ULONG Line;
    POOL_TYPE Type;
} MY_POOL, *PMY_POOL;

#define MY_SIGNATURE "RaMdIsK"

LIST_ENTRY RamdiskNonpagedPoolList;
LIST_ENTRY RamdiskPagedPoolList;
FAST_MUTEX RamdiskPoolMutex;
KSPIN_LOCK RamdiskPoolSpinLock;

VOID
RamdiskInitializePoolDebug (
    VOID
    )
{
    InitializeListHead( &RamdiskNonpagedPoolList );
    InitializeListHead( &RamdiskPagedPoolList );
    ExInitializeFastMutex( &RamdiskPoolMutex );
    KeInitializeSpinLock( &RamdiskPoolSpinLock );

    return;

} // RamdiskInitializePoolDebug

PVOID
RamdiskAllocatePoolWithTag (
    POOL_TYPE PoolType,
    SIZE_T Size,
    ULONG Tag,
    LOGICAL Private,
    PCHAR File,
    ULONG Line
    )
{
    PMY_POOL myPool;
    KIRQL oldIrql;
    HRESULT result;

    if ( !Private ) {

        //
        // This is not a private allocation (it will be deallocated by some
        // other piece of code). We can't put a header on it.
        //

        myPool = ExAllocatePoolWithTag( PoolType, Size, Tag );

        DBGPRINT( DBG_POOL, DBG_PAINFUL,
                    ("Allocated %d bytes at %p for %s/%d\n", Size, myPool + 1, File, Line) );

        return myPool;
    }

    //
    // Allocate the requested space plus room for our header.
    //

    myPool = ExAllocatePoolWithTag( PoolType, sizeof(MY_POOL) + Size, Tag );

    if ( myPool == NULL ) {
        return NULL;
    }

    //
    // Fill in the header.
    //

    result = StringCbCopyA( myPool->Signature, sizeof( myPool->Signature ), MY_SIGNATURE );
    ASSERT( result == S_OK );

    myPool->File = File;
    myPool->Line = Line;
    myPool->Type = PoolType;

    //
    // Link the block into the appropriate list. If nonpaged pool, we must use
    // a spin lock to guard the list, because deallocation might happen at
    // raised IRQL. The paged pool list can be guarded by a mutex.
    //
    // NB: BASE_POOL_TYPE_MASK is defined in ntos\inc\pool.h.
    //

#define BASE_POOL_TYPE_MASK 1

    if ( (PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool ) {

        KeAcquireSpinLock( &RamdiskPoolSpinLock, &oldIrql );

        InsertTailList( &RamdiskNonpagedPoolList, &myPool->ListEntry );

        KeReleaseSpinLock( &RamdiskPoolSpinLock, oldIrql );

    } else {

        KeEnterCriticalRegion();
        ExAcquireFastMutex( &RamdiskPoolMutex );

        InsertTailList( &RamdiskPagedPoolList, &myPool->ListEntry );

        ExReleaseFastMutex( &RamdiskPoolMutex );
        KeLeaveCriticalRegion();
    }

    //
    // Return a pointer to the caller's area, not to our header.
    //

    DBGPRINT( DBG_POOL, DBG_PAINFUL,
                ("Allocated %d bytes at %p for %s/%d\n", Size, myPool + 1, File, Line) );

    return myPool + 1;

} // RamdiskAllocatePoolWithTag

VOID
RamdiskFreePool (
    PVOID Address,
    LOGICAL Private,
    PCHAR File,
    ULONG Line
    )
{
    PMY_POOL myPool;
    PLIST_ENTRY list;
    PLIST_ENTRY listEntry;
    LOGICAL found;
    KIRQL oldIrql;

    //
    // The following line is here to get PREfast to stop complaining about the
    // call to KeReleaseSpinLock using an uninitialized variable.
    //

    oldIrql = 0;

    DBGPRINT( DBG_POOL, DBG_PAINFUL,
                ("Freeing pool at %p for %s/%d\n", Address, File, Line) );

    if ( !Private ) {

        //
        // This is not a private allocation (it was allocated by some other
        // piece of code). It doesn't have our header.
        //

        ExFreePool( Address );
        return;
    }

    //
    // Get the address of our header. Check that the header has our signature.
    //

    myPool = (PMY_POOL)Address - 1;

    if ( strcmp( myPool->Signature, MY_SIGNATURE ) != 0 ) {

        DbgPrint( "%s", "RAMDISK: Attempt to free pool block not owned by ramdisk.sys!!!\n" );
        DbgPrint( "  address: %p, freeing file: %s, line: %d\n", Address, File, Line );
        ASSERT( FALSE );

        //
        // Since it doesn't look like our header, assume that it wasn't
        // really a private allocation.
        //

        ExFreePool( Address );
        return;

    }

    //
    // Remove the block from the allocation list. First, acquire the
    // appropriate lock.
    //

    if ( (myPool->Type & BASE_POOL_TYPE_MASK) == NonPagedPool ) {

        list = &RamdiskNonpagedPoolList;

        KeAcquireSpinLock( &RamdiskPoolSpinLock, &oldIrql );

    } else {

        list = &RamdiskPagedPoolList;

        KeEnterCriticalRegion();
        ExAcquireFastMutex( &RamdiskPoolMutex );
    }

    //
    // Search the list for this block.
    //

    found = FALSE;

    for ( listEntry = list->Flink;
          listEntry != list;
          listEntry = listEntry->Flink ) {

        if ( listEntry == &myPool->ListEntry ) {

            //
            // Found this block. Remove it from the list and leave the loop.
            //

            RemoveEntryList( listEntry );
            found = TRUE;
            break;
        }
    }

    //
    // Release the lock.
    //

    if ( (myPool->Type & BASE_POOL_TYPE_MASK) == NonPagedPool ) {
    
        KeReleaseSpinLock( &RamdiskPoolSpinLock, oldIrql );

    } else {

        ExReleaseFastMutex( &RamdiskPoolMutex );
        KeLeaveCriticalRegion();
    }

    if ( !found ) {

        //
        // Didn't find the block in the list. Complain.
        //

        DbgPrint( "%s", "RAMDISK: Attempt to free pool block not in allocation list!!!\n" );
        DbgPrint( "  address: %p, freeing file: %s, line: %d\n", myPool, File, Line );
        DbgPrint( "  allocating file: %s, line: %d\n", myPool->File, myPool->Line );
        ASSERT( FALSE );
    }

    //
    // Free the pool block.
    //

    ExFreePool( myPool );

    return;

} // RamdiskFreePool

#endif // defined(POOL_DBG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\redbook\guids.c ===
/*++
Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    guids.c

Abstract:

    this file instantiates any and all GUIDs used by redbook.

Author:

    Henry Gabryjelski (henrygab)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <objbase.h>
#include <initguid.h>
#include <ntddredb.h>
#include <wdmguid.h>

// that's all folks...
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\redbook\errlog.c ===
/*++

Copyright (C) 1991-8  Microsoft Corporation

Module Name:

    errlog.c

Abstract:

    this module provides error logging capabilities for
    the redbook driver

Author:

    Henry Gabryjelski (henrygab) 1-Oct-1998

Environment:

    kernel mode only

Notes:

Revision History:

--*/


#include "redbook.h"
#include "proto.h"
#include "errlog.tmh"


VOID
RedBookLogError(
   IN  PREDBOOK_DEVICE_EXTENSION  DeviceExtension,
   IN  NTSTATUS                   IoErrorCode,
   IN  NTSTATUS                   FinalStatus
   )
/*++

Routine Description:

    This routine performs error logging for the redbook driver.

Arguments:

    Extension        - Extension.
    UniqueErrorValue - Values defined to uniquely identify error location.

Return Value:

    None

--*/

{
    PIO_ERROR_LOG_PACKET    errorLogPacket;
    ULONG                   count;
    ULONG                   rCount;
    USHORT                  simpleCode;
    ULONG                   packetSize;

    count  = InterlockedIncrement(&DeviceExtension->ErrorLog.Count);
    simpleCode = (USHORT)(IoErrorCode & REDBOOK_ERR_MASK);

    ASSERT(simpleCode < REDBOOK_ERR_MAXIMUM);

    switch (IoErrorCode) {
        case REDBOOK_ERR_TOO_MANY_READ_ERRORS:
        case REDBOOK_ERR_TOO_MANY_STREAM_ERRORS:
        case REDBOOK_ERR_CANNOT_OPEN_SYSAUDIO_MIXER:
        case REDBOOK_ERR_CANNOT_CREATE_VIRTUAL_SOURCE:
        case REDBOOK_ERR_CANNOT_OPEN_PREFERRED_WAVEOUT_DEVICE:
        case REDBOOK_ERR_CANNOT_GET_NUMBER_OF_PINS:
        case REDBOOK_ERR_CANNOT_CONNECT_TO_PLAYBACK_PINS:
        case REDBOOK_ERR_WMI_INIT_FAILED:
        case REDBOOK_ERR_CANNOT_CREATE_THREAD:
        case REDBOOK_ERR_INSUFFICIENT_DATA_STREAM_PAUSED:
        case REDBOOK_ERR_UNSUPPORTED_DRIVE:
            NOTHING;
            break;

        default:
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "LogErr !! Invalid error code %lx\n", IoErrorCode));
            return;
    }



    //
    // Use an exponential backoff algorithm to log events.
    //

    rCount = InterlockedIncrement(&DeviceExtension->ErrorLog.RCount[simpleCode]);

    if (CountOfSetBits(rCount) != 1) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugErrlog, "[redbook] "
                   "LogError => IoErrorCode %lx Occurance %d\n",
                   IoErrorCode, rCount));
        return;
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugErrlog, "[redbook] "
               "LogError => IoErrorCode %lx Occurance %d\n",
               IoErrorCode, rCount));

    packetSize  = sizeof(IO_ERROR_LOG_PACKET) + sizeof(ULONG);

    errorLogPacket = (PIO_ERROR_LOG_PACKET)
                     IoAllocateErrorLogEntry(DeviceExtension->SelfDeviceObject,
                                             (UCHAR)packetSize);

    if (errorLogPacket==NULL) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugErrlog, "[redbook] "
                   "LogError => unable to allocate error log packet\n"));
        return;
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugErrlog, "[redbook] "
               "LogError => allocated error log at %p, size %x\n",
               errorLogPacket, packetSize));

    //
    // this function relies upon IoAllocateErrorLogEntry() zero'ing the packet
    //


    errorLogPacket->MajorFunctionCode = -1;
    errorLogPacket->IoControlCode     = -1;
    errorLogPacket->ErrorCode         =  IoErrorCode;
    errorLogPacket->FinalStatus       =  FinalStatus;
    errorLogPacket->SequenceNumber    =  count;
    errorLogPacket->DumpDataSize      =  4; // bytes
    errorLogPacket->DumpData[0]       =  rCount;


    IoWriteErrorLogEntry(errorLogPacket);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\redbook\pnp.c ===
/*++
Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    pnp.c

Abstract:

    This file handles the plug and play portions of redbook.sys
    This also handles the AddDevice, DriverEntry, and Unload routines,
    as they are part of initialization.

Author:

    Henry Gabryjelski (henrygab)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "redbook.h"
#include "ntddredb.h"
#include "proto.h"

#include "pnp.tmh"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE,   DriverEntry                  )
    #pragma alloc_text(PAGE,   RedBookAddDevice             )
    #pragma alloc_text(PAGE,   RedBookPnp                   )
    #pragma alloc_text(PAGE,   RedBookPnpRemoveDevice       )
    #pragma alloc_text(PAGE,   RedBookPnpStartDevice        )
    #pragma alloc_text(PAGE,   RedBookPnpStopDevice         )
    #pragma alloc_text(PAGE,   RedBookUnload                )
#endif // ALLOC_PRAGMA


////////////////////////////////////////////////////////////////////////////////

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Initialize RedBook driver.
    This is the system initialization entry point
    when the driver is linked into the kernel.

Arguments:

    DriverObject

Return Value:

    NTSTATUS

--*/

{
    ULONG i;
    NTSTATUS status;
    PREDBOOK_DRIVER_EXTENSION driverExtension;

    PAGED_CODE();

    WPP_INIT_TRACING(DriverObject, RegistryPath);

    //
    // WMI requires registry path
    //

    status = IoAllocateDriverObjectExtension(DriverObject,
                                             REDBOOK_DRIVER_EXTENSION_ID,
                                             sizeof(REDBOOK_DRIVER_EXTENSION),
                                             &driverExtension);

    if (status == STATUS_OBJECT_NAME_COLLISION) {

        //
        // The extension already exists - get a pointer to it
        //

        driverExtension = IoGetDriverObjectExtension(DriverObject,
                                                     REDBOOK_DRIVER_EXTENSION_ID);

        ASSERT(driverExtension != NULL);
        status = STATUS_SUCCESS;

    }

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                   "DriverEntry !! no drvObjExt %lx\n", status));
        return status;
    }

    //
    // Copy the RegistryPath to our newly acquired driverExtension
    //

    driverExtension->RegistryPath.Buffer =
        ExAllocatePoolWithTag(NonPagedPool,
                              RegistryPath->Length + 2,
                              TAG_REGPATH);

    if (driverExtension->RegistryPath.Buffer == NULL) {

        status = STATUS_NO_MEMORY;
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                   "DriverEntry !! unable to alloc regPath %lx\n", status));
        return status;

    } else {

        driverExtension->RegistryPath.Length = RegistryPath->Length;
        driverExtension->RegistryPath.MaximumLength = RegistryPath->Length + 2;
        RtlCopyUnicodeString(&driverExtension->RegistryPath, RegistryPath);

    }

    //
    // Send everything down unless specifically handled.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i] = RedBookSendToNextDriver;

    }

    //
    // These are the only IRP_MJ types that are handled
    //

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = RedBookWmiSystemControl;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = RedBookDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_READ]           = RedBookReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]          = RedBookReadWrite;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = RedBookPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = RedBookPower;
    DriverObject->DriverExtension->AddDevice           = RedBookAddDevice;
    DriverObject->DriverUnload                         = RedBookUnload;

    return STATUS_SUCCESS;
}


NTSTATUS
RedBookAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    This routine creates and initializes a new FDO for the
    corresponding PDO.  It may perform property queries on
    the FDO but cannot do any media access operations.

Arguments:

    DriverObject - CDROM class driver object or lower level filter

    Pdo - the physical device object we are being added to

Return Value:

    status

--*/

{

    NTSTATUS                   status;
    PDEVICE_OBJECT             deviceObject;
    PREDBOOK_DEVICE_EXTENSION  extension = NULL;
    ULONG                      i;

    PAGED_CODE();

    TRY {

        //
        // Create the devObj so system doesn't unload us
        //

        status = IoCreateDevice(DriverObject,
                                sizeof(REDBOOK_DEVICE_EXTENSION),
                                NULL,
                                FILE_DEVICE_CD_ROM,
                                0,
                                FALSE,
                                &deviceObject
                                );

        if (!NT_SUCCESS(status)) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "AddDevice !! Couldn't create device %lx\n",
                       status));
            LEAVE;

        }

        extension = deviceObject->DeviceExtension;
        RtlZeroMemory(extension, sizeof(REDBOOK_DEVICE_EXTENSION));

        //
        // Attach to the stack
        //

        extension->TargetDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

        if (extension->TargetDeviceObject == NULL) {

            status = STATUS_UNSUCCESSFUL;
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "AddDevice != Couldn't attach to stack %lx\n",
                       status));
            LEAVE;

        }

        extension->DriverObject     = DriverObject;
        extension->TargetPdo        = PhysicalDeviceObject;
        extension->SelfDeviceObject = deviceObject;

        //
        // prepare the paging path additions
        //

        extension->PagingPathCount = 0;
        KeInitializeEvent(&extension->PagingPathEvent,
                          SynchronizationEvent,
                          TRUE);

        //
        // Create and acquire a remove lock for this device
        //

        IoInitializeRemoveLock(&extension->RemoveLock,
                               TAG_REMLOCK,
                               REMOVE_LOCK_MAX_MINUTES,
                               REMOVE_LOCK_HIGH_MARK);

        //
        // Initialize the Pnp states
        //

        extension->Pnp.CurrentState  = 0xff;
        extension->Pnp.PreviousState = 0xff;
        extension->Pnp.RemovePending = FALSE;

        //
        // Create thread -- PUT INTO SEPERATE ROUTINE
        //

        {
            HANDLE handle;
            PKTHREAD thread;

            //
            // have to setup a minimum amount of stuff for the thread
            // here....
            //

            extension->CDRom.StateNow = CD_STOPPED;

            //
            // Allocate memory for the numerous events all at once
            //

            extension->Thread.Events[0] =
                ExAllocatePoolWithTag(NonPagedPool,
                                      sizeof(KEVENT) * EVENT_MAXIMUM,
                                      TAG_EVENTS);

            if (extension->Thread.Events[0] == NULL) {
                status = STATUS_NO_MEMORY;
                LEAVE;
            }

            //
            // Set the pointers appropriately
            // ps - i love pointer math
            //

            for (i = 1; i < EVENT_MAXIMUM; i++) {
                extension->Thread.Events[i] = extension->Thread.Events[0] + i;
            }

            InitializeListHead(  &extension->Thread.IoctlList);
            KeInitializeSpinLock(&extension->Thread.IoctlLock);
            InitializeListHead(  &extension->Thread.WmiList);
            KeInitializeSpinLock(&extension->Thread.WmiLock);
            InitializeListHead(  &extension->Thread.DigitalList);
            KeInitializeSpinLock(&extension->Thread.DigitalLock);


            extension->Thread.IoctlCurrent = NULL;

            for ( i = 0; i < EVENT_MAXIMUM; i++) {
                KeInitializeEvent(extension->Thread.Events[i],
                                  SynchronizationEvent,
                                  FALSE);
            }

            ASSERT(extension->Thread.SelfPointer == NULL);
            ASSERT(extension->Thread.SelfHandle == 0);

            //
            // create the thread that will do most of the work
            //

            status = PsCreateSystemThread(&handle,
                                          (ACCESS_MASK) 0L,
                                          NULL, NULL, NULL,
                                          RedBookSystemThread,
                                          extension);

            if (!NT_SUCCESS(status)) {

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                           "StartDevice !! Unable to create thread %lx\n",
                           status));
                RedBookLogError(extension,
                                REDBOOK_ERR_CANNOT_CREATE_THREAD,
                                status);
                LEAVE;

            }
            ASSERT(extension->Thread.SelfHandle == 0); // shouldn't be set yet
            extension->Thread.SelfHandle = handle;

            //
            // Reference the thread so we can properly wait on it in
            // the remove device routine.
            //
            status = ObReferenceObjectByHandle(handle,
                                               THREAD_ALL_ACCESS,
                                               NULL,
                                               KernelMode,
                                               &thread,
                                               NULL);
            if (!NT_SUCCESS(status)) {

                //
                // NOTE: we would leak a thread here, but don't
                // know a way to handle this error case?
                //

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                           "StartDevice !! Unable to reference thread %lx\n",
                           status));
                RedBookLogError(extension,
                                REDBOOK_ERR_CANNOT_CREATE_THREAD,
                                status);
                LEAVE;
            }
            extension->Thread.ThreadReference = thread;
        }

    } FINALLY {

        if (!NT_SUCCESS(status)) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "AddDevice !! Failed with status %lx\n",
                       status));

            if (!deviceObject) {

                //
                // same as no device extension
                //

                return status;

            }

            if (extension &&
                extension->Thread.Events[0]) {
                ExFreePool(extension->Thread.Events[0]);
            }

            if (extension &&
                extension->TargetDeviceObject) {
                IoDetachDevice(extension->TargetDeviceObject);
            }

            IoDeleteDevice( deviceObject );

            return status;
        }
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
               "AddDevice => DevExt at %p\n", extension));

    //
    // propogate only some flags from the lower devobj.
    //

    {
        ULONG flagsToPropogate;

        flagsToPropogate = DO_BUFFERED_IO | DO_DIRECT_IO;
        flagsToPropogate &= extension->TargetDeviceObject->Flags;

        SET_FLAG(deviceObject->Flags, flagsToPropogate);

    }

    SET_FLAG(deviceObject->Flags, DO_POWER_PAGABLE);

    //
    // No longer initializing
    //

    CLEAR_FLAG(deviceObject->Flags, DO_DEVICE_INITIALIZING);

    return STATUS_SUCCESS;
}


NTSTATUS
RedBookPnp(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP            Irp
    )

/*++

Routine Description:

    Dispatch for PNP

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT targetDO = deviceExtension->TargetDeviceObject;
    ULONG cdromState;
    BOOLEAN completeRequest;
    BOOLEAN lockReleased;

    PAGED_CODE();

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "Pnp !! Remove lock failed PNP Irp type [%#02x]\n",
                   irpSp->MinorFunction));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
        return status;
    }

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "Pnp (%p,%p,%x) => Entering previous %x  current %x\n",
                   DeviceObject, Irp, irpSp->MinorFunction,
                   deviceExtension->Pnp.PreviousState,
                   deviceExtension->Pnp.CurrentState));

    lockReleased = FALSE;
    completeRequest = TRUE;

    switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:
        {
            //
            // first forward this down
            //

            status = RedBookForwardIrpSynchronous(deviceExtension, Irp);

            //
            // check status from new sent Start Irp
            //

            if (!NT_SUCCESS(status)) {

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                           "Pnp (%p,%p,%x) => failed start status = %x\n",
                           DeviceObject, Irp, irpSp->MinorFunction, status));
                break;

            }

            //
            // cannot pass this one down either, since it's already
            // done that in the startdevice routine.
            //

            status = RedBookPnpStartDevice(DeviceObject);

            if (NT_SUCCESS(status)) {

                deviceExtension->Pnp.PreviousState =
                    deviceExtension->Pnp.CurrentState;
                deviceExtension->Pnp.CurrentState =
                    irpSp->MinorFunction;

            }
            break;

        }

        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE:
        {

            //
            // if this device is in use for some reason (paging, etc...)
            // then we need to fail the request.
            //

            if (deviceExtension->PagingPathCount != 0) {

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                           "Device %p is in the paging path and cannot "
                           "be removed\n",
                           DeviceObject));
                status = STATUS_DEVICE_BUSY;
                break;
            }

            //
            // see if the query operation can succeed
            //

            if (irpSp->MinorFunction == IRP_MN_QUERY_STOP_DEVICE) {
                status = RedBookPnpStopDevice(DeviceObject, Irp);
            } else {
                status = RedBookPnpRemoveDevice(DeviceObject, Irp);
            }

            if (NT_SUCCESS(status)) {

                ASSERT(deviceExtension->Pnp.CurrentState != irpSp->MinorFunction);

                deviceExtension->Pnp.PreviousState =
                    deviceExtension->Pnp.CurrentState;
                deviceExtension->Pnp.CurrentState =
                    irpSp->MinorFunction;

                status = RedBookForwardIrpSynchronous(deviceExtension, Irp);

            }
            break;
        }

        case IRP_MN_CANCEL_REMOVE_DEVICE:
        case IRP_MN_CANCEL_STOP_DEVICE: {

            //
            // check if the cancel can succeed
            //

            if (irpSp->MinorFunction == IRP_MN_CANCEL_STOP_DEVICE) {

                status = RedBookPnpStopDevice(DeviceObject, Irp);
                ASSERTMSG("Pnp !! CANCEL_STOP_DEVICE should never be "
                          " failed!\n", NT_SUCCESS(status));

            } else {

                status = RedBookPnpRemoveDevice(DeviceObject, Irp);
                ASSERTMSG("Pnp !! CANCEL_REMOVE_DEVICE should never be "
                          "failed!\n", NT_SUCCESS(status));
            }

            Irp->IoStatus.Status = status;

            //
            // we got a CANCEL -- roll back to the previous state only if
            // the current state is the respective QUERY state.
            //

            if ((irpSp->MinorFunction == IRP_MN_CANCEL_STOP_DEVICE &&
                 deviceExtension->Pnp.CurrentState == IRP_MN_QUERY_STOP_DEVICE)
                ||
                (irpSp->MinorFunction == IRP_MN_CANCEL_REMOVE_DEVICE &&
                 deviceExtension->Pnp.CurrentState == IRP_MN_QUERY_REMOVE_DEVICE)
                ) {

                deviceExtension->Pnp.CurrentState =
                    deviceExtension->Pnp.PreviousState;
                deviceExtension->Pnp.PreviousState = 0xff;

            }

            status = RedBookForwardIrpSynchronous(deviceExtension, Irp);

            break;
        }

        case IRP_MN_STOP_DEVICE: {

            ASSERT(deviceExtension->PagingPathCount == 0);

            //
            // call into the stop device routine.
            //

            status = RedBookPnpStopDevice(DeviceObject, Irp);

            ASSERTMSG("[redbook] Pnp !! STOP_DEVICE should never be failed\n",
                      NT_SUCCESS(status));

            status = RedBookForwardIrpSynchronous(deviceExtension, Irp);

            if (NT_SUCCESS(status)) {

                deviceExtension->Pnp.CurrentState  = irpSp->MinorFunction;
                deviceExtension->Pnp.PreviousState = 0xff;

            }

            break;
        }

        case IRP_MN_REMOVE_DEVICE:
        case IRP_MN_SURPRISE_REMOVAL: {

            //
            // forward the irp (to close pending io)
            //

            status = RedBookForwardIrpSynchronous(deviceExtension, Irp);

            ASSERT(NT_SUCCESS(status));

            //
            // the remove lock is released by the remove device routine
            //

            lockReleased = TRUE;
            status = RedBookPnpRemoveDevice(DeviceObject, Irp);

            ASSERTMSG("Pnp !! REMOVE_DEVICE should never fail!\n",
                      NT_SUCCESS(status));

            //
            // move this here so i know that i am removing....
            //

            deviceExtension->Pnp.PreviousState =
                deviceExtension->Pnp.CurrentState;
            deviceExtension->Pnp.CurrentState =
                irpSp->MinorFunction;


            status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_DEVICE_USAGE_NOTIFICATION: {
            KEVENT event;
            BOOLEAN setPagable;

            if (irpSp->Parameters.UsageNotification.Type != DeviceUsageTypePaging) {
                status = RedBookForwardIrpSynchronous(deviceExtension, Irp);
                break; // out of case statement
            }

            KeWaitForSingleObject(&deviceExtension->PagingPathEvent,
                                  Executive, KernelMode,
                                  FALSE, NULL);

            //
            // if removing last paging device, need to set DO_POWER_PAGABLE
            // bit here, and possible re-set it below on failure.
            //

            setPagable = FALSE;
            if (!irpSp->Parameters.UsageNotification.InPath &&
                deviceExtension->PagingPathCount == 1) {

                //
                // removing last paging file.  must have
                // DO_POWER_PAGABLE bits set prior to forwarding
                //

                if (TEST_FLAG(DeviceObject->Flags, DO_POWER_INRUSH)) {
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                               "Pnp (%p,%p,%x) => Last paging file"
                               " removed, but DO_POWER_INRUSH set, so "
                               "not setting DO_POWER_PAGABLE\n",
                               DeviceObject, Irp, irpSp->MinorFunction));
                } else {
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                               "Pnp (%p,%p,%x) => Setting PAGABLE "
                               "bit\n", DeviceObject, Irp,
                               irpSp->MinorFunction));
                    SET_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                    setPagable = TRUE;
                }

            }

            //
            // send the irp synchronously
            //

            status = RedBookForwardIrpSynchronous(deviceExtension, Irp);

            //
            // now deal with the failure and success cases.
            // note that we are not allowed to fail the irp
            // once it is sent to the lower drivers.
            //

            if (NT_SUCCESS(status)) {

                IoAdjustPagingPathCount(
                    &deviceExtension->PagingPathCount,
                    irpSp->Parameters.UsageNotification.InPath);

                if (irpSp->Parameters.UsageNotification.InPath) {
                    if (deviceExtension->PagingPathCount == 1) {
                        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                                   "Pnp (%p,%p,%x) => Clearing PAGABLE "
                                   "bit\n", DeviceObject, Irp,
                                   irpSp->MinorFunction));
                        CLEAR_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                    }
                }

            } else {

                //
                // cleanup the changes done above
                //

                if (setPagable == TRUE) {
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                               "Pnp (%p,%p,%x) => Clearing PAGABLE bit "
                               "due to irp failiing (%x)\n",
                               DeviceObject, Irp, irpSp->MinorFunction,
                               status));
                    CLEAR_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                    setPagable = FALSE;
                }

            }
            KeSetEvent(&deviceExtension->PagingPathEvent,
                       IO_NO_INCREMENT, FALSE);

            break;

        }

        default: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "Pnp (%p,%p,%x) => Leaving  previous %x  "
                       "current %x (unhandled)\n",
                       DeviceObject, Irp, irpSp->MinorFunction,
                       deviceExtension->Pnp.PreviousState,
                       deviceExtension->Pnp.CurrentState));
            status = RedBookSendToNextDriver(DeviceObject, Irp);
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            completeRequest = FALSE;
            lockReleased = TRUE;
            break;
        }
    }

    if (completeRequest) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "Pnp (%p,%p,%x) => Leaving  previous %x  "
                   "current %x  status %x\n",
                   DeviceObject, Irp, irpSp->MinorFunction,
                   deviceExtension->Pnp.PreviousState,
                   deviceExtension->Pnp.CurrentState,
                   status));
        Irp->IoStatus.Status = status;

        IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);

        if (!lockReleased) {
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        }

    }

    return status;

}

NTSTATUS
RedBookPnpRemoveDevice(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP            Irp
    )
/*++

Routine Description:

    Dispatch for PNP

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension;
    UCHAR type;
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    type = IoGetCurrentIrpStackLocation(Irp)->MinorFunction;

    if (type == IRP_MN_QUERY_REMOVE_DEVICE ||
        type == IRP_MN_CANCEL_REMOVE_DEVICE) {
        return STATUS_SUCCESS;
    }

    //
    // Type is now either SURPRISE_REMOVAL or REMOVE_DEVICE
    //
    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
               "PnpRemove => starting %s\n",
               (type == IRP_MN_REMOVE_DEVICE ?
                "remove device" : "surprise removal")));

    deviceExtension = DeviceObject->DeviceExtension;

    deviceExtension->Pnp.RemovePending = TRUE;

    if (type == IRP_MN_REMOVE_DEVICE) {

        //
        // prevent any new io
        //

        IoReleaseRemoveLockAndWait(&deviceExtension->RemoveLock, Irp);

        //
        // cleanup the thread, if one exists
        // NOTE: a new one won't start due to the remove lock
        //

        if (deviceExtension->Thread.SelfHandle != NULL) {

            ASSERT(deviceExtension->Thread.ThreadReference);

            //
            // there is no API to wait on a handle, so we must wait on
            // the object.
            //


            KeSetEvent(deviceExtension->Thread.Events[EVENT_KILL_THREAD],
                       IO_CD_ROM_INCREMENT, FALSE);
            KeWaitForSingleObject(deviceExtension->Thread.ThreadReference,
                                  Executive, KernelMode,
                                  FALSE, NULL);
            ObDereferenceObject(deviceExtension->Thread.ThreadReference);
            deviceExtension->Thread.ThreadReference = NULL;
            deviceExtension->Thread.SelfHandle = 0;
            deviceExtension->Thread.SelfPointer = NULL;

        }

        //
        // un-register pnp notification
        //

        if (deviceExtension->Stream.SysAudioReg != NULL) {
            IoUnregisterPlugPlayNotification(deviceExtension->Stream.SysAudioReg);
            deviceExtension->Stream.SysAudioReg = NULL;
        }

        //
        // free any cached toc
        //

        if (deviceExtension->CDRom.Toc != NULL) {
            ExFreePool(deviceExtension->CDRom.Toc);
            deviceExtension->CDRom.Toc = NULL;
        }

        //
        // de-register from wmi
        //

        if (deviceExtension->WmiLibInitialized) {
            status = RedBookWmiUninit(deviceExtension);
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "PnpRemove => WMI Uninit returned %x\n", status));
            deviceExtension->WmiLibInitialized = FALSE;
        }

        //
        // Detach from the device stack
        //

        IoDetachDevice(deviceExtension->TargetDeviceObject);
        deviceExtension->TargetDeviceObject = NULL;

        //
        // free the events
        //

        if (deviceExtension->Thread.Events[0]) {
            ExFreePool(deviceExtension->Thread.Events[0]);
        }

        for (i=0;i<EVENT_MAXIMUM;i++) {
            deviceExtension->Thread.Events[i] = NULL;
        }

        //
        // make sure we aren't leaking anywhere...
        //

        ASSERT(deviceExtension->Buffer.Contexts    == NULL);
        ASSERT(deviceExtension->Buffer.ReadOk_X    == NULL);
        ASSERT(deviceExtension->Buffer.StreamOk_X  == NULL);

        //
        // Now can safely (without leaks) delete our device object
        //

        IoDeleteDevice(deviceExtension->SelfDeviceObject);
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "PnpRemove => REMOVE_DEVICE finished.\n"));

    } else {

        //
        // do nothing for a SURPRISE_REMOVAL, since a REMOVE_DEVICE
        // will soon follow.
        //

        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "PnpRemove => SURPRISE_REMOVAL finished.\n"));

    }

    return STATUS_SUCCESS;

}


NTSTATUS
RedBookPnpStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();
    return STATUS_SUCCESS;

}

NTSTATUS
RedBookPnpStartDevice(
    IN PDEVICE_OBJECT  DeviceObject
    )

/*++

Routine Description:

    Dispatch for START DEVICE.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    KEVENT event;
    ULONG i;

    PAGED_CODE();

    //
    // Never start my driver portion twice
    // system guarantees one Pnp Irp at a time,
    // so state will not change within this routine
    //

    switch ( deviceExtension->Pnp.CurrentState ) {

        case 0xff:
        case IRP_MN_STOP_DEVICE: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "StartDevice => starting driver for devobj %p\n",
                       DeviceObject));
            break;
        }
        case IRP_MN_START_DEVICE: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "StartDevice => already started for devobj %p\n",
                       DeviceObject));
            return STATUS_SUCCESS;
        }

        case IRP_MN_QUERY_REMOVE_DEVICE: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "StartDevice !! remove pending for devobj %p\n",
                       DeviceObject));
            return STATUS_UNSUCCESSFUL;
        }

        case IRP_MN_QUERY_STOP_DEVICE: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "StartDevice !! stop pending for devobj %p\n",
                       DeviceObject));
            return STATUS_UNSUCCESSFUL;
        }

        default: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "StartDevice !! unknown DeviceState for devobj %p\n",
                       DeviceObject));
            ASSERT(!"[RedBook] Pnp !! Unkown Device State");
            return STATUS_UNSUCCESSFUL;
        }
    }

    if (deviceExtension->Pnp.Initialized) {
        return STATUS_SUCCESS;
    }

    //
    // the following code will only successfully run once for each AddDevice()
    // must still ensure that we check if something is already allocated
    // if we allocate it here.  also note that everything allocated here must
    // explicitly be checked for in the RemoveDevice() routine, even if we
    // never finished a start successfully.
    //

    deviceExtension->WmiData.MaximumSectorsPerRead = -1;
    deviceExtension->WmiData.PlayEnabled = 1;
    ASSERT(deviceExtension->CDRom.Toc == NULL);
    if (deviceExtension->CDRom.Toc != NULL) {
        ExFreePool(deviceExtension->CDRom.Toc);
    }
    ASSERT(deviceExtension->Buffer.ReadOk_X     == NULL);
    ASSERT(deviceExtension->Buffer.StreamOk_X   == NULL);
    ASSERT(deviceExtension->Buffer.Contexts     == NULL);

    RtlZeroMemory(&deviceExtension->Stream, sizeof(REDBOOK_STREAM_DATA));
    deviceExtension->Stream.MixerPinId   = -1;
    deviceExtension->Stream.VolumeNodeId = -1;
    deviceExtension->Stream.Connect.Interface.Set   = KSINTERFACESETID_Standard;
    deviceExtension->Stream.Connect.Interface.Id    = KSINTERFACE_STANDARD_STREAMING;
    deviceExtension->Stream.Connect.Interface.Flags = 0;
    deviceExtension->Stream.Connect.Medium.Set   = KSMEDIUMSETID_Standard;
    deviceExtension->Stream.Connect.Medium.Id    = KSMEDIUM_STANDARD_DEVIO;
    deviceExtension->Stream.Connect.Medium.Flags = 0;
    deviceExtension->Stream.Connect.Priority.PriorityClass    = KSPRIORITY_NORMAL;
    deviceExtension->Stream.Connect.Priority.PrioritySubClass = 1;
    deviceExtension->Stream.Format.DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
    deviceExtension->Stream.Format.DataFormat.SubFormat   = KSDATAFORMAT_SUBTYPE_PCM;
    deviceExtension->Stream.Format.DataFormat.Specifier   = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;
    deviceExtension->Stream.Format.DataFormat.FormatSize  = sizeof( KSDATAFORMAT_WAVEFORMATEX );
    deviceExtension->Stream.Format.DataFormat.Reserved    = 0;
    deviceExtension->Stream.Format.DataFormat.Flags       = 0;
    deviceExtension->Stream.Format.DataFormat.SampleSize  = 0;
    deviceExtension->Stream.Format.WaveFormatEx.wFormatTag      = WAVE_FORMAT_PCM;
    deviceExtension->Stream.Format.WaveFormatEx.nChannels       = 2;
    deviceExtension->Stream.Format.WaveFormatEx.nSamplesPerSec  = 44100;
    deviceExtension->Stream.Format.WaveFormatEx.wBitsPerSample  = 16;
    deviceExtension->Stream.Format.WaveFormatEx.nAvgBytesPerSec = 44100*4;
    deviceExtension->Stream.Format.WaveFormatEx.nBlockAlign     = 4;
    deviceExtension->Stream.Format.WaveFormatEx.cbSize          = 0;

    //
    // set the volume, verify we're stopped
    //
    ASSERT(deviceExtension->CDRom.StateNow == CD_STOPPED);
    deviceExtension->CDRom.Volume.PortVolume[0] = 0xff;
    deviceExtension->CDRom.Volume.PortVolume[1] = 0xff;
    deviceExtension->CDRom.Volume.PortVolume[2] = 0xff;
    deviceExtension->CDRom.Volume.PortVolume[3] = 0xff;

    //
    // Register for Pnp Notifications for SysAudio
    //

    ASSERT(deviceExtension->Stream.SysAudioReg == NULL);

    //
    // read the defaults from the registry
    //

    RedBookRegistryRead(deviceExtension);

    //
    // get max transfer of adapter
    //

    RedBookSetTransferLength(deviceExtension);

    //
    // take the lowest common denominator
    //

    if (deviceExtension->WmiData.SectorsPerRead >
        deviceExtension->WmiData.MaximumSectorsPerRead ) {
        deviceExtension->WmiData.SectorsPerRead =
            deviceExtension->WmiData.MaximumSectorsPerRead;
    }

    //
    // and write the new values (just in case)
    //

    RedBookRegistryWrite(deviceExtension);

    //
    // also init the WmiPerf structure
    //

    KeInitializeSpinLock(&deviceExtension->WmiPerfLock);
    RtlZeroMemory(&deviceExtension->WmiPerf, sizeof(REDBOOK_WMI_PERF_DATA));


    //
    // Note dependency in OpenSysAudio() in sysaudio.c
    //

    if (deviceExtension->Stream.SysAudioReg == NULL) {
        status = IoRegisterPlugPlayNotification(
                    EventCategoryDeviceInterfaceChange,
                    PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
                    (GUID*)&KSCATEGORY_PREFERRED_WAVEOUT_DEVICE,
                    deviceExtension->DriverObject,
                    SysAudioPnpNotification,
                    deviceExtension,
                    &deviceExtension->Stream.SysAudioReg
                    );

        if (!NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "StartDevice !! Unable to register for sysaudio pnp "
                       "notifications %x\n", status));
            deviceExtension->Stream.SysAudioReg = NULL;
            return status;
        }
    }

    //
    // initialize WMI now that wmi settings are initialized
    //
    status = RedBookWmiInit(deviceExtension);

    if (!NT_SUCCESS(status)) {
        RedBookLogError(deviceExtension,
                        REDBOOK_ERR_WMI_INIT_FAILED,
                        status);
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                   "AddDevice !! WMI Init failed %lx\n",
                   status));
        return status;
    }

    //
    // log an error if drive doesn't support accurate reads
    //

    if (!deviceExtension->WmiData.CDDAAccurate) {
        RedBookLogError(deviceExtension,
                        REDBOOK_ERR_UNSUPPORTED_DRIVE,
                        STATUS_SUCCESS);
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
               "StartDevice => DO %p SavedIoIndex @ %p  Starts @ %p  "
               "Each is %x bytes in size\n",
               DeviceObject,
               &deviceExtension->SavedIoCurrentIndex,
               &(deviceExtension->SavedIo[0]),
               sizeof(SAVED_IO)));


    deviceExtension->Pnp.Initialized = TRUE;

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
               "StartDevice => Finished Initialization\n"));
    return STATUS_SUCCESS;
}


VOID
RedBookUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is called when the control panel "Unloads"
    the CDROM device.

Arguments:

    DeviceObject

Return Value:

    void

--*/

{
    PREDBOOK_DRIVER_EXTENSION driverExtension;

    PAGED_CODE();
    ASSERT( DriverObject->DeviceObject == NULL );

    driverExtension = IoGetDriverObjectExtension(DriverObject,
                                                 REDBOOK_DRIVER_EXTENSION_ID);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
               "Unload => Unloading for DriverObject %p, ext %p\n",
               DriverObject, driverExtension));

    if (driverExtension != NULL &&
        driverExtension->RegistryPath.Buffer != NULL ) {
        ExFreePool( driverExtension->RegistryPath.Buffer );
    }

    WPP_CLEANUP(DriverObject);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\redbook\redbook.c ===
/*++
Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    RedBook.c

Abstract:

    This driver translates audio IOCTLs into raw reads from audio
    tracks on compliant cdrom drives.  These reads are then passed
    to Kernel Streaming (KS) to reduce switching into/out of kernel
    mode.
    This driver also emulates most hardware functions, such as
    current head position, during play operation.  This is done to
    prevent audio stuttering or because the drive would not understand
    the request while it is not playing audio (since it is only reading).

    At initialization, the driver reads the registry to determine
    if it should attach itself to the stack and the number of
    buffers to allocate.

    The WmiData (including enable/disable) may be changed while the
    drive is not playing audio.

    Read errors cause the buffer to be zero'd out and passed
    along, much like a CD player skipping.   Too many consecutive
    errors will cause the play operation to abort.

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "redbook.h"
#include "ntddredb.h"
#include "proto.h"
#include <scsi.h>      // for SetKnownGoodDrive()
#include <stdio.h>     // vsprintf()

#include "redbook.tmh"


//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//
// Define the sections that allow for paging some of
// the code.
//


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE,   RedBookForwardIrpSynchronous  )
    #pragma alloc_text(PAGE,   RedBookGetDescriptor          )
    #pragma alloc_text(PAGE,   RedBookRegistryRead           )
    #pragma alloc_text(PAGE,   RedBookRegistryWrite          )
    #pragma alloc_text(PAGE,   RedBookSetTransferLength      )
#endif // ALLOC_PRAGMA

//
// use this to get mode pages
//

typedef struct _PASS_THROUGH_REQUEST {
    SCSI_PASS_THROUGH Srb;
    SENSE_DATA SenseInfoBuffer;
    UCHAR DataBuffer[0];
} PASS_THROUGH_REQUEST, *PPASS_THROUGH_REQUEST;



//////////////////////////////////////////////////////////////////
///                       END PROTOTYPES                       ///
//////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////


NTSTATUS
RedBookRegistryRead(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    This routine queries the registry for values for the
    corresponding PDO.  The values are then saved in the
    given DeviceExtension.

Arguments:

    PhysicalDeviceObject - the physical device object we are being added to

    DeviceExtension - the redbook device extension used

Return Value:

    status

--*/


{
    //
    // Use registry to hold key information
    //

    HANDLE                   deviceParameterHandle; // cdrom instance key
    HANDLE                   driverParameterHandle; // digital audio subkey
    OBJECT_ATTRIBUTES        objectAttributes;
    UNICODE_STRING           subkeyName;
    NTSTATUS                 status;

    // seeded in the ENUM tree by ClassInstaller
    ULONG32 regCDDAAccurate;
    ULONG32 regCDDASupported;
    ULONG32 regSectorsPerReadMask;
    // seeded first time booting, set by wmi/control panel
    ULONG32 regSectorsPerRead;
    ULONG32 regNumberOfBuffers;
    ULONG32 regVersion;
    // table for above registry entries
    RTL_QUERY_REGISTRY_TABLE queryTable[7];         // null-terminated array


    PAGED_CODE();

    deviceParameterHandle = NULL;
    driverParameterHandle = NULL;

     // CDDAAccurate and Supported set from SetKnownGoodDrive()
    regCDDAAccurate = DeviceExtension->WmiData.CDDAAccurate;
    regCDDASupported = DeviceExtension->WmiData.CDDASupported;
    regSectorsPerReadMask = -1;

    regSectorsPerRead = REDBOOK_WMI_SECTORS_DEFAULT;
    regNumberOfBuffers = REDBOOK_WMI_BUFFERS_DEFAULT;
    regVersion = 0;


    TRY {
        status = IoOpenDeviceRegistryKey(DeviceExtension->TargetPdo,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         KEY_WRITE,
                                         &deviceParameterHandle
                                         );

        if (!NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                       "RegistryRead !! CDROM PnP Instance DNE? %lx\n",
                       status));
            LEAVE;
        }

        RtlInitUnicodeString(&subkeyName, REDBOOK_REG_SUBKEY_NAME);
        InitializeObjectAttributes(&objectAttributes,
                                   &subkeyName,
                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                   deviceParameterHandle,
                                   NULL
                                   );

        status = ZwOpenKey( &driverParameterHandle,
                            KEY_READ,
                            &objectAttributes
                            );

        if (!NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                       "RegistryRead !! Subkey not opened, using "
                       "defaults %lx\n", status));
            LEAVE;
        }

        //
        // Zero out the memory
        //

        RtlZeroMemory(&queryTable[0], 7*sizeof(RTL_QUERY_REGISTRY_TABLE));

        //
        // Setup the structure to read
        //

        queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[0].Name          = REDBOOK_REG_CDDA_ACCURATE_KEY_NAME;
        queryTable[0].EntryContext  = &regCDDAAccurate;
        queryTable[0].DefaultType   = REG_DWORD;
        queryTable[0].DefaultData   = &regCDDAAccurate;
        queryTable[0].DefaultLength = 0;

        queryTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[1].Name          = REDBOOK_REG_CDDA_SUPPORTED_KEY_NAME;
        queryTable[1].EntryContext  = &regCDDASupported;
        queryTable[1].DefaultType   = REG_DWORD;
        queryTable[1].DefaultData   = &regCDDASupported;
        queryTable[1].DefaultLength = 0;

        queryTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[2].Name          = REDBOOK_REG_SECTORS_MASK_KEY_NAME;
        queryTable[2].EntryContext  = &regSectorsPerReadMask;
        queryTable[2].DefaultType   = REG_DWORD;
        queryTable[2].DefaultData   = &regSectorsPerReadMask;
        queryTable[2].DefaultLength = 0;

        queryTable[3].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[3].Name          = REDBOOK_REG_SECTORS_KEY_NAME;
        queryTable[3].EntryContext  = &regSectorsPerRead;
        queryTable[3].DefaultType   = REG_DWORD;
        queryTable[3].DefaultData   = &regSectorsPerRead;
        queryTable[3].DefaultLength = 0;

        queryTable[4].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[4].Name          = REDBOOK_REG_BUFFERS_KEY_NAME;
        queryTable[4].EntryContext  = &regNumberOfBuffers;
        queryTable[4].DefaultType   = REG_DWORD;
        queryTable[4].DefaultData   = &regNumberOfBuffers;
        queryTable[4].DefaultLength = 0;

        queryTable[5].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[5].Name          = REDBOOK_REG_VERSION_KEY_NAME;
        queryTable[5].EntryContext  = &regVersion;
        queryTable[5].DefaultType   = REG_DWORD;
        queryTable[5].DefaultData   = &regVersion;
        queryTable[5].DefaultLength = 0;

        //
        // queryTable[6] is null-filled to terminate reading
        //

        //
        // read values
        //

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR)driverParameterHandle,
                                        &queryTable[0],
                                        NULL,
                                        NULL
                                        );

        //
        // Check for failure...
        //

        if (!NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                       "RegistryRead !! default values (read "
                       "failed) %lx\n", status));
            LEAVE;
        }
        status = STATUS_SUCCESS;

    } FINALLY {

        if (deviceParameterHandle) {
            ZwClose(deviceParameterHandle);
        }

        if (driverParameterHandle) {
            ZwClose(driverParameterHandle);
        }

        if (!NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                       "RegistryRead !! Using Defaults\n"));
        }

    }

    if (regVersion > REDBOOK_REG_VERSION) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                       "RegistryRead !! Version %x in registry newer than %x\n",
                       regVersion, REDBOOK_REG_VERSION));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // successfully read from the registry, but make sure data is valid.
    //

    if (regSectorsPerReadMask == 0) {
        if (regCDDAAccurate) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                       "RegistryRead !! SectorMask==0 && CDDAAccurate?\n"));
        }
        if (regCDDASupported) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                       "RegistryRead !! SectorMask==0 && CDDASupported?\n"));
        }
        regCDDAAccurate = 0;
        regCDDASupported = 0;
    }

    if (regSectorsPerRead < REDBOOK_WMI_SECTORS_MIN) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryRead !! SectorsPerRead too small\n"));
        regSectorsPerRead = REDBOOK_WMI_SECTORS_MIN;
    }
    if (regSectorsPerRead > REDBOOK_WMI_SECTORS_MAX) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryRead !! SectorsPerRead too large\n"));
        regSectorsPerRead = REDBOOK_WMI_SECTORS_MAX;
    }

    if (regNumberOfBuffers < REDBOOK_WMI_BUFFERS_MIN) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryRead !! NumberOfBuffers too small\n"));
        regNumberOfBuffers = REDBOOK_WMI_BUFFERS_MIN;
    }
    if (regNumberOfBuffers > REDBOOK_WMI_BUFFERS_MAX) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryRead !! NumberOfBuffers too large\n"));
        regNumberOfBuffers = REDBOOK_WMI_BUFFERS_MAX;
    }

    if (regSectorsPerRead > DeviceExtension->WmiData.MaximumSectorsPerRead) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryRead !! SectorsPerRead too big for adapter\n"));
        regSectorsPerRead = DeviceExtension->WmiData.MaximumSectorsPerRead;
    }

    DeviceExtension->WmiData.CDDAAccurate = regCDDAAccurate ? 1 : 0;
    DeviceExtension->WmiData.CDDASupported = regCDDASupported ? 1: 0;

    DeviceExtension->WmiData.SectorsPerReadMask = regSectorsPerReadMask;
    DeviceExtension->WmiData.SectorsPerRead = regSectorsPerRead;
    DeviceExtension->WmiData.NumberOfBuffers = regNumberOfBuffers;

    return STATUS_SUCCESS;
}


NTSTATUS
RedBookRegistryWrite(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    This routine queries the registry for values for the
    corresponding PDO.  The values are then saved in the
    given DeviceExtension.

Arguments:

    PhysicalDeviceObject - the physical device object we are being added to

    DeviceExtension - the redbook device extension used

Return Value:

    status

--*/


{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING    subkeyName;
    HANDLE            deviceParameterHandle; // cdrom instance key
    HANDLE            driverParameterHandle; // redbook subkey

    // seeded in the ENUM tree by ClassInstaller
    ULONG32 regCDDAAccurate;
    ULONG32 regCDDASupported;
    ULONG32 regSectorsPerReadMask;
    // seeded first time booting, set by wmi/control panel
    ULONG32 regSectorsPerRead;
    ULONG32 regNumberOfBuffers;
    ULONG32 regVersion;

    NTSTATUS          status;

    PAGED_CODE();

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
               "RegistryWrite => Opening key\n"));

    status = IoOpenDeviceRegistryKey(DeviceExtension->TargetPdo,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_ALL_ACCESS,
                                     &deviceParameterHandle);

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! CDROM PnP Instance DNE? %lx\n",
                   status));
        return status;
    }

    RtlInitUnicodeString(&subkeyName, REDBOOK_REG_SUBKEY_NAME);
    InitializeObjectAttributes(&objectAttributes,
                               &subkeyName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               deviceParameterHandle,
                               (PSECURITY_DESCRIPTOR) NULL);

    //
    // Create the key or open it if it already exists
    //

    status = ZwCreateKey(&driverParameterHandle,
                         KEY_WRITE | KEY_READ,
                         &objectAttributes,
                         0,
                         (PUNICODE_STRING) NULL,
                         REG_OPTION_NON_VOLATILE,
                         NULL);

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! Subkey not created? %lx\n", status));
        ZwClose(deviceParameterHandle);
        return status;
    }

    regCDDAAccurate       = DeviceExtension->WmiData.CDDAAccurate;
    regCDDASupported      = DeviceExtension->WmiData.CDDASupported;
    regSectorsPerReadMask = DeviceExtension->WmiData.SectorsPerReadMask;
    regSectorsPerRead     = DeviceExtension->WmiData.SectorsPerRead;
    regNumberOfBuffers    = DeviceExtension->WmiData.NumberOfBuffers;
    regVersion            = REDBOOK_REG_VERSION;

    status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                   (PWSTR)driverParameterHandle,
                                   REDBOOK_REG_VERSION_KEY_NAME,
                                   REG_DWORD,
                                   &regVersion,
                                   sizeof(regVersion));

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! Failed write version %lx\n", status));
    }

    status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                   (PWSTR)driverParameterHandle,
                                   REDBOOK_REG_BUFFERS_KEY_NAME,
                                   REG_DWORD,
                                   &regNumberOfBuffers,
                                   sizeof(regNumberOfBuffers));

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! Failed write buffers %lx\n", status));
    }

    status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                   (PWSTR)driverParameterHandle,
                                   REDBOOK_REG_SECTORS_KEY_NAME,
                                   REG_DWORD,
                                   &regSectorsPerRead,
                                   sizeof(regSectorsPerRead));

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! Failed write sectors %lx\n", status));
    }

    status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                   (PWSTR) driverParameterHandle,
                                   REDBOOK_REG_SECTORS_MASK_KEY_NAME,
                                   REG_DWORD,
                                   &regSectorsPerReadMask,
                                   sizeof(regSectorsPerReadMask));

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! Failed write SectorsMask %lx\n",
                   status));
    }

    status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                   (PWSTR)driverParameterHandle,
                                   REDBOOK_REG_CDDA_SUPPORTED_KEY_NAME,
                                   REG_DWORD,
                                   &regCDDASupported,
                                   sizeof(regCDDASupported));

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! Failed write Supported %lx\n", status));
    }

    status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                   (PWSTR)driverParameterHandle,
                                   REDBOOK_REG_CDDA_ACCURATE_KEY_NAME,
                                   REG_DWORD,
                                   &regCDDAAccurate,
                                   sizeof(regCDDAAccurate));

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! Failed write Accurate %lx\n", status));
    }


    //
    // close the handles
    //

    ZwClose(driverParameterHandle);
    ZwClose(deviceParameterHandle);

    return STATUS_SUCCESS;
}


NTSTATUS
RedBookReadWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    This routine simply rejects read/write irps if currently
    playing audio.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    ULONG state;

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
        return status;
    }

    if (!deviceExtension->WmiData.PlayEnabled) {
        status = RedBookSendToNextDriver(DeviceObject, Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        return status;
    }

    state = GetCdromState(deviceExtension);

    //
    // it doesn't really matter if we allow a few reads down during
    // the start of a play, since io is not guaranteed to occur in
    // order.
    //

    if (!TEST_FLAG(state, CD_PLAYING)) {
        status = RedBookSendToNextDriver(DeviceObject, Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        return status;
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugTrace, "[redbook] "
               "ReadWrite => Rejecting a request\n"));

    Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    return STATUS_DEVICE_BUSY;


}


NTSTATUS
RedBookSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This completion routine will signal the event given as context and then
    return STATUS_MORE_PROCESSING_REQUIRED to stop event completion.  It is
    the responsibility of the routine waiting on the event to complete the
    request and free the event.

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp

    Event - a pointer to the event to signal

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    KeSetEvent(Event, IO_CD_ROM_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
RedBookSetTransferLength(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    calls ClassGetDescriptor()
    set the maxSectorsPerRead based on storage properties
    checks for knownGood drives using the extension

Arguments:

    DeviceExtension

Return Value:

    NTSTATUS

--*/
{
    PSTORAGE_DESCRIPTOR_HEADER storageDescriptor;
    PSTORAGE_ADAPTER_DESCRIPTOR adapterDescriptor;
    STORAGE_PROPERTY_ID storageProperty;
    ULONGLONG maxPageLength;
    ULONGLONG maxPhysLength;
    ULONGLONG sectorLength;
    ULONG sectors;
    NTSTATUS status;

    PAGED_CODE();

    storageDescriptor = NULL;
    storageProperty = StorageAdapterProperty;
    status = RedBookGetDescriptor( DeviceExtension,
                                   &storageProperty,
                                   &storageDescriptor
                                   );

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "SetTranLen => failed to get descriptor\n"));
        ASSERT( storageDescriptor == NULL );
        NOTHING;
    } else {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "SetTranLen => got descriptor\n"));
        ASSERT( storageDescriptor != NULL );
        adapterDescriptor = (PVOID)storageDescriptor;

        maxPhysLength  = (ULONGLONG) adapterDescriptor->MaximumTransferLength;

        maxPageLength  = (ULONGLONG) adapterDescriptor->MaximumPhysicalPages;
        maxPageLength *= PAGE_SIZE;

        sectors = -1;
        sectorLength = sectors * (ULONGLONG)PAGE_SIZE;

        if (maxPhysLength == 0 || maxPageLength == 0) {

            //
            // what to do in this case?  disable redbook?
            //

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "SetTranLen !! The adapter cannot support transfers?!\n"));
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "SetTranLen !! maxPhysLength = %I64x\n", maxPhysLength));
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "SetTranLen !! maxPageLength = %I64x\n", maxPageLength));
            ASSERT(!"[redbook] SetTranLen !! Got bogus adapter properties");

            maxPhysLength = 1;
            maxPageLength = 1;

        }


        if (maxPhysLength > sectorLength &&
            maxPageLength > sectorLength) {  // more than ulong can store?

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "SetTranLen => both Max's more than a ulong?\n" ));

        } else if ( (ULONGLONG)maxPhysLength > (ULONGLONG)maxPageLength) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "SetTranLen => restricted due to page length\n" ));
            sectorLength = maxPageLength;

        } else {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "SetTranLen => restricted due to phys length\n" ));
            sectorLength = maxPhysLength;

        }

        sectorLength -= PAGE_SIZE; // to handle non-page-aligned allocations

        if (sectorLength < RAW_SECTOR_SIZE) {
            sectorLength = RAW_SECTOR_SIZE;
        }

        //
        // took the smaller of physical transfer and page transfer,
        // therefore will never overflow sectors
        //

        sectors = (ULONG)(sectorLength / (ULONGLONG)RAW_SECTOR_SIZE);



        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "SetTranLen => MaxTransferLength      = %lx\n",
                   adapterDescriptor->MaximumTransferLength));
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "SetTranLen => MaxPhysicalPages       = %lx\n",
                   adapterDescriptor->MaximumPhysicalPages));
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "SetTranLen => Setting max sectors to = %lx\n",
                   sectors));

        DeviceExtension->WmiData.MaximumSectorsPerRead = sectors;

        if (DeviceExtension->WmiData.SectorsPerRead > sectors) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "SetTranLen => Current sectors per read (%lx) too "
                       "large. Setting to max sectors per read\n",
                       DeviceExtension->WmiData.SectorsPerRead));
            DeviceExtension->WmiData.SectorsPerRead = sectors;

        } else if (DeviceExtension->WmiData.SectorsPerRead == 0) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "SetTranLen => Current sectors per read (%lx) zero. "
                       "Setting to max sectors per read\n",
                       DeviceExtension->WmiData.SectorsPerRead));
            DeviceExtension->WmiData.SectorsPerRead = sectors;

        }


    }

    if (storageDescriptor !=NULL) {
        ExFreePool(storageDescriptor);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RedBookPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension;

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);

    deviceExtension = (PREDBOOK_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    return PoCallDriver(deviceExtension->TargetDeviceObject, Irp);
}


NTSTATUS
RedBookForwardIrpSynchronous(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, RedBookSignalCompletion, &event,
                           TRUE, TRUE, TRUE);

    status = IoCallDriver(DeviceExtension->TargetDeviceObject, Irp);

    if(status == STATUS_PENDING) {
        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}


NTSTATUS
RedBookGetDescriptor(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PSTORAGE_PROPERTY_ID PropertyId,
    OUT PSTORAGE_DESCRIPTOR_HEADER *Descriptor
    )
/*++

Routine Description:

    This routine will perform a query for the specified property id and will
    allocate a non-paged buffer to store the data in.  It is the responsibility
    of the caller to ensure that this buffer is freed.

    This routine must be run at IRQL_PASSIVE_LEVEL

Arguments:

    DeviceObject - the device to query
    DeviceInfo - a location to store a pointer to the buffer we allocate

Return Value:

    status
    if status is unsuccessful *DeviceInfo will be set to 0

--*/

{
    PDEVICE_OBJECT selfDeviceObject = DeviceExtension->SelfDeviceObject;
    PSTORAGE_DESCRIPTOR_HEADER descriptor;
    PSTORAGE_PROPERTY_QUERY query;
    PIO_STACK_LOCATION irpStack;
    PIRP irp;
    NTSTATUS status;
    ULONG length;
    UCHAR pass;

    PAGED_CODE();

    descriptor = NULL;
    irp = NULL;
    irpStack = NULL;
    query = NULL;
    pass = 0;


    //
    // Set the descriptor pointer to NULL
    //

    *Descriptor = NULL;

    TRY {

        // NOTE: should probably just use IoAllocateIrp() and
        // IoReuseIrp() when this gets updated.
        // Historical note: IoReuseIrp() was not available when
        // this was written, and verifier was just beginning and
        // complained loudly about reused irps.

        irp = ExAllocatePoolWithTag(NonPagedPool,
                                    IoSizeOfIrp(selfDeviceObject->StackSize+1),
                                    TAG_GET_DESC1);
        if (irp   == NULL) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "GetDescriptor: Unable to allocate irp\n"));
            status = STATUS_NO_MEMORY;
            LEAVE;
        }

        //
        // initialize the irp
        //

        IoInitializeIrp(irp,
                        IoSizeOfIrp(selfDeviceObject->StackSize+1),
                        (CCHAR)(selfDeviceObject->StackSize+1));
        irp->UserBuffer = NULL;

        IoSetNextIrpStackLocation(irp);

        //
        // Retrieve the property page
        //

        do {

            switch(pass) {

                case 0: {

                    //
                    // On the first pass we just want to get the first few
                    // bytes of the descriptor so we can read it's size
                    //

                    length = sizeof(STORAGE_DESCRIPTOR_HEADER);

                    descriptor = NULL;
                    descriptor = ExAllocatePoolWithTag(NonPagedPool,
                                                       MAX(sizeof(STORAGE_PROPERTY_QUERY),length),
                                                       TAG_GET_DESC2);

                    if (descriptor == NULL) {
                        status = STATUS_NO_MEMORY;
                        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                                   "GetDescriptor: unable to alloc"
                                   "memory for descriptor (%d bytes)\n",
                                   length));
                        LEAVE;
                    }

                    break;
                }

                case 1: {

                    //
                    // This time we know how much data there is so we can
                    // allocate a buffer of the correct size
                    //

                    length = descriptor->Size;
                    ExFreePool(descriptor);
                    descriptor = NULL;

                    //
                    // Note: this allocation is returned to the caller
                    //

                    descriptor = ExAllocatePoolWithTag(NonPagedPool,
                                                       MAX(sizeof(STORAGE_PROPERTY_QUERY),length),
                                                       TAG_GET_DESC);

                    if(descriptor == NULL) {
                        status = STATUS_NO_MEMORY;
                        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                                   "GetDescriptor: unable to alloc"
                                   "memory for descriptor (%d bytes)\n",
                                   length));
                        LEAVE;
                    }

                    break;
                }
            }

            irpStack = IoGetCurrentIrpStackLocation(irp);

            SET_FLAG(irpStack->Flags, SL_OVERRIDE_VERIFY_VOLUME);

            irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
            irpStack->Parameters.DeviceIoControl.IoControlCode =
                IOCTL_STORAGE_QUERY_PROPERTY;
            irpStack->Parameters.DeviceIoControl.InputBufferLength =
                sizeof(STORAGE_PROPERTY_QUERY);
            irpStack->Parameters.DeviceIoControl.OutputBufferLength = length;

            irp->UserBuffer = descriptor;
            irp->AssociatedIrp.SystemBuffer = descriptor;


            query = (PVOID)descriptor;
            query->PropertyId = *PropertyId;
            query->QueryType = PropertyStandardQuery;


            //
            // send the irp
            //
            status = RedBookForwardIrpSynchronous(DeviceExtension, irp);

            if(!NT_SUCCESS(status)) {

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                           "GetDescriptor: error %lx trying to "
                           "query properties\n", status));
                LEAVE;
            }

        } while(pass++ < 1);

    } FINALLY {

        if (irp != NULL) {
            ExFreePool(irp);
        }

        if(!NT_SUCCESS(status)) {

            if (descriptor != NULL) {
                ExFreePool(descriptor);
                descriptor = NULL;
            }

        }
        *Descriptor = descriptor;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\redbook\proto.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       proto.h
//
//--------------------------------------------------------------------------

#ifndef ___REDBOOK_PROTOTYPES_H
#define ___REDBOOK_PROTOTYPES_H

//////////////////////////////////////////////////////////////////////
//
// From redbook\pnp.c
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );
NTSTATUS
RedBookAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );
NTSTATUS
RedBookPnp(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP            Irp
    );
NTSTATUS
RedBookPnpRemoveDevice(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP            Irp
    );
NTSTATUS
RedBookPnpStopDevice(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP            Irp
    );
NTSTATUS
RedBookPnpStartDevice(
    IN PDEVICE_OBJECT  DeviceObject
    );
VOID
RedBookUnload(
    IN PDRIVER_OBJECT DriverObject
    );


//////////////////////////////////////////////////////////

#if DBG

        #define VerifyCalledByThread(D) \
            ASSERT(PsGetCurrentThread() == (D)->Thread.SelfPointer)

#else // !DBG

        #define VerifyCalledByThread(D)            // Nop

#endif // !DBG

//////////////////////////////////////////////////////////////////////
//
// From redbook\errlog.c
//

VOID
RedBookLogError(
    IN  PREDBOOK_DEVICE_EXTENSION  DeviceExtension,
    IN  NTSTATUS                   IoErrorCode,
    IN  NTSTATUS                   FinalStatus
    );


//////////////////////////////////////////////////////////////////////
//
// From redbook\wmi.c
//

NTSTATUS
RedBookWmiUninit(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
RedBookWmiInit(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
RedBookWmiQueryDataBlock (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    );

NTSTATUS
RedBookWmiSetDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
RedBookWmiSetDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
RedBookWmiSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
RedBookThreadWmiHandler(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PLIST_ENTRY ListEntry
    );

NTSTATUS
RedBookWmiQueryRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *PhysicalDeviceObject
    );

VOID
RedBookWmiCopyPerfInfo(
    IN  PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    OUT PREDBOOK_WMI_PERF_DATA Out
    );

//////////////////////////////////////////////////////////////////////
//
// From redbook\sysaudio.c
//

NTSTATUS
OpenSysAudio(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
CloseSysAudio(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
GetPinProperty(
    IN  PFILE_OBJECT FileObject,
    IN  ULONG        PropertyId,
    IN  ULONG        PinId,
    IN  ULONG        PropertySize,
    OUT PVOID        Property
    );

NTSTATUS
GetVolumeNodeId(
    IN  PFILE_OBJECT FileObject,
    OUT PULONG       VolumeNodeId
    );

NTSTATUS
UninitializeVirtualSource(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
InitializeVirtualSource(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
AttachVirtualSource(
    IN  PFILE_OBJECT FileObject,
    IN  ULONG        MixerPinId
    );

VOID
SetNextDeviceState(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    KSSTATE      State
    );

VOID
RedBookKsSetVolume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
OpenInterfaceByGuid(
    IN  CONST GUID * InterfaceClassGuid,
    OUT HANDLE       * Handle,
    OUT PFILE_OBJECT * FileObject
    );

//////////////////////////////////////////////////////////////////////
//
// From redbook\redbook.c
//

NTSTATUS
RedBookRegistryRead(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
RedBookRegistryWrite(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
RedBookReadWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
RedBookSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

NTSTATUS
RedBookSetTransferLength(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
RedBookPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RedBookDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
RedBookForwardIrpSynchronous(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

NTSTATUS
RedBookGetDescriptor(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PSTORAGE_PROPERTY_ID PropertyId,
    OUT PSTORAGE_DESCRIPTOR_HEADER *Descriptor
    );

//////////////////////////////////////////////////////////
//
// from redbook\ioctl.c
//

VOID
RedBookDCPause(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCStop(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCResume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCPlay(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCSeek(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCReadQ(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCCheckVerify(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCSetVolume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCGetVolume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCDefault(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookThreadIoctlHandler(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PLIST_ENTRY ListEntry
    );

NTSTATUS
RedBookCompleteIoctl(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PREDBOOK_THREAD_IOCTL_DATA Context,
    IN BOOLEAN SendToLowerDriver
    );

VOID
RedBookThreadIoctlCompletionHandler(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );


//////////////////////////////////////////////////////////////////////
//
// From redbook\thread.c
//

VOID
RedBookSystemThread(
    PVOID Context
    );

VOID
RedBookReadRaw(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_COMPLETION_CONTEXT Context
    );

NTSTATUS
RedBookReadRawCompletion(
    PVOID UnusableParameter,
    PIRP Irp,
    PREDBOOK_COMPLETION_CONTEXT Context
    );

VOID
RedBookStream(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_COMPLETION_CONTEXT Context
    );

NTSTATUS
RedBookStreamCompletion(
    PVOID UnusableParameter,
    PIRP Irp,
    PREDBOOK_COMPLETION_CONTEXT Context
    );


ULONG
GetCdromState(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

LONG
SetCdromState(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN LONG ExpectedOldState,
    IN LONG NewState
    );

VOID
RedBookDeallocatePlayResources(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
RedBookAllocatePlayResources(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

BOOLEAN
RedBookArePlayResourcesAllocated(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
RedBookCacheToc(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

ULONG
WhichTrackContainsThisLBA(
    PCDROM_TOC Toc,
    ULONG Lba
    );

VOID
RedBookThreadDigitalHandler(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PLIST_ENTRY ListEntry
    );

VOID
AddWmiStats(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_COMPLETION_CONTEXT Context
    );

VOID
RedBookCheckForDiscChangeAndFreeResources(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SysAudioPnpNotification(
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION Notification,
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

VOID
RedBookCheckForAudioDeviceRemoval(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

//////////////////////////////////////////////////////////////////////

__inline
ULONG
SafeMod(
    IN ULONG Value,
    IN ULONG ModBy
    )
{
    return ((Value+ModBy)%ModBy);
}

__inline
NTSTATUS
RedBookSendToNextDriver(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is sends the Irp to the next driver in line
    when the Irp is not processed by this driver.
    This happens quite often, so should not have any debug statements.
    Request this as an inline operation for speed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(((PREDBOOK_DEVICE_EXTENSION)DeviceObject->DeviceExtension)->TargetDeviceObject,Irp);
}

//////////////////////////////////////////////////////////////////////


#endif // ___REDBOOK_PROTOTYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\redbook\sysaudio.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       sysaudio.c
//
//--------------------------------------------------------------------------


#include "redbook.h"
#include "proto.h"
#include <wdmguid.h>
#include <ksmedia.h>

#include "sysaudio.tmh"

//////////////////////////////////////////////////////////////////////


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, AttachVirtualSource)
    #pragma alloc_text(PAGE, CloseSysAudio)
    #pragma alloc_text(PAGE, GetPinProperty)
    #pragma alloc_text(PAGE, GetVolumeNodeId)
    #pragma alloc_text(PAGE, InitializeVirtualSource)
    #pragma alloc_text(PAGE, OpenInterfaceByGuid)
    #pragma alloc_text(PAGE, OpenSysAudio)
    #pragma alloc_text(PAGE, RedBookKsSetVolume)
    #pragma alloc_text(PAGE, SetNextDeviceState)
    #pragma alloc_text(PAGE, SysAudioPnpNotification)
    #pragma alloc_text(PAGE, UninitializeVirtualSource)
#endif // ALLOC_PRAGMA


//////////////////////////////////////////////////////////////////////

NTSTATUS
OpenSysAudio(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    This routine is a wrapper around all the work that must be done
    just to open sysaudio for playback.  the code was swiped from
    Win98, and then translated into CSN (Cutler Standard Notation)

Arguments:

    DeviceExtensionPinConnect - if successful, this will be the pin to send data to

    PinFileObject - if successful, the file object this pin is associated
        with is returned in this structure

    PinDeviceObject - if successful, the device object this pin is
        associated with is returned in this structure

    VolumeNodeId - ?? No idea what this is... yet.

Return Value:

    status

--*/


{
    PFILE_OBJECT guidFileObject;
    PFILE_OBJECT pinFileObject;
    HANDLE deviceHandle;
    NTSTATUS status;
    HANDLE pinHandle;
    ULONG volumeNodeId;
    ULONG mixerPinId;

    ULONG pins, pinId;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    guidFileObject = NULL;
    pinFileObject = NULL;
    deviceHandle = NULL;
    status = STATUS_SUCCESS;
    pinHandle = NULL;
    volumeNodeId = -1;
    mixerPinId = DeviceExtension->Stream.MixerPinId;


    TRY {
        ASSERT( mixerPinId != MAXULONG );

        //
        // Note dependency on IoRegisterPlugPlayNotification() in pnp.c
        //

        status = OpenInterfaceByGuid(
                                     //&KSCATEGORY_SYSAUDIO,
                                     &KSCATEGORY_PREFERRED_WAVEOUT_DEVICE,
                                     &deviceHandle,
                                     &guidFileObject);

        if (!NT_SUCCESS(status)) {
            LEAVE;
        }

        //
        // Get the number of pins
        //
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "SysAudio => Getting Pin Property PIN_CTYPES\n"));

        status = GetPinProperty(guidFileObject,
                                KSPROPERTY_PIN_CTYPES,
                                0, // doesn't matter for ctypes
                                sizeof(pins),
                                &pins);

        if (!NT_SUCCESS(status)) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                       "SysAudio !! Unable to get number of pins %lx\n",
                       status));
            RedBookLogError(DeviceExtension,
                            REDBOOK_ERR_CANNOT_GET_NUMBER_OF_PINS,
                            status);
            LEAVE;
        }

        //
        // Try to get a matching pin -- brute force method
        //

        for( pinId = 0; pinId < pins; pinId++) {

            KSPIN_COMMUNICATION communication;
            KSPIN_DATAFLOW dataFlow;

            //
            // check communication of the pin. accept either
            // a sink or a pin that is both a source and sink
            //

            status = GetPinProperty(guidFileObject,
                                    KSPROPERTY_PIN_COMMUNICATION,
                                    pinId,
                                    sizeof(communication),
                                    &communication);

            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                           "SysAudio !! Pin %d communication query "
                           "failed %lx\n", pinId, status ));
                continue;
            }

            if ( communication != KSPIN_COMMUNICATION_SINK &&
                 communication != KSPIN_COMMUNICATION_BOTH ) continue;

            //
            // only use this pin if it accepts incoming data
            //

            status = GetPinProperty(guidFileObject,
                                    KSPROPERTY_PIN_DATAFLOW,
                                    pinId,
                                    sizeof(dataFlow),
                                    &dataFlow);

            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                           "SysAudio !! Pin %d dataflow query failed %lx\n",
                           pinId, status));
                continue;
            }

            if (dataFlow != KSPIN_DATAFLOW_IN) continue;

            //
            // we have found a matching pin, so attempt to connect
            //

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "SysAudio => Attempt to connect to pin %d\n", pinId));

            DeviceExtension->Stream.Connect.PinId       = pinId;
            DeviceExtension->Stream.Connect.PinToHandle = NULL;

            status = KsCreatePin(deviceHandle,
                                 &DeviceExtension->Stream.Connect,
                                 GENERIC_WRITE, // FILE_WRITE_ACCESS
                                 &pinHandle);

            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                           "SysAudio => Cannot create a writable pin %d\n",
                           pinId));
                continue;
            }

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "SysAudio => Connected to pin %d\n", pinId ));

            //
            // get the object associated with the pinHandle just created
            // so we can then get other information about the pin
            //

            status = ObReferenceObjectByHandle(pinHandle,
                                               GENERIC_READ | GENERIC_WRITE,
                                               NULL,
                                               KernelMode,
                                               &pinFileObject,
                                               NULL);

            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                             "SysAudio !! Object from handle for pin "
                             "failed %lx\n", status));
                LEAVE;
            }

            //
            // this allows us to change our output volume
            // this just sends a ks ioctl, no referencing done here
            //

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "SysAudio => Getting VolumeNodeId\n"));

            status = GetVolumeNodeId(pinFileObject,
                                     &volumeNodeId);

            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                           "SysAudio !! Unable to get volume node "
                           "id %lx\n", status));
                LEAVE;
            }

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "SysAudio => Attaching PinFileObject %p "
                       "to MixerPinId %d\n", pinFileObject,
                       mixerPinId));

            //
            // this just sends a ks ioctl, no referencing done here
            //

            status = AttachVirtualSource(pinFileObject, mixerPinId);

            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                           "SysAudio !! Unable to attach virtual "
                           "source %lx\n", status));
                LEAVE;
            }

            //
            // successful completion
            //

            status = STATUS_SUCCESS;

            LEAVE;
        }

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                   "Sysaudio !! Unable to connect to any pins\n"));
        RedBookLogError(DeviceExtension,
                        REDBOOK_ERR_CANNOT_CONNECT_TO_PLAYBACK_PINS,
                        status);

        //
        // no pin succeeded, so set status to failure
        //
        status = STATUS_INVALID_DEVICE_REQUEST;
        LEAVE;


    } FINALLY {

        //
        // the pin handle is not required, as we've referenced
        // the pin in pinFileObject.  close it here.
        //

        if (pinHandle != NULL) {
            ZwClose(pinHandle);
            pinHandle = NULL;
        }

        //
        // the device handle is only required to create
        // the actual pin.  close it here.
        //

        if (deviceHandle != NULL) {
            ZwClose(deviceHandle);
            deviceHandle = NULL;
        }

        //
        // the guidFileObject is also only required to query
        // and create the pins.  close it here.
        //
        // (pinFileObject is still important)
        //

        if (guidFileObject != NULL) {
            ObDereferenceObject(guidFileObject);
            guidFileObject = NULL;
        }

        if (!NT_SUCCESS(status)) {

            if (pinFileObject != NULL) {
                ObDereferenceObject(pinFileObject);
                pinFileObject = NULL;
            }

        }

    }

    //
    // the MixerPinId should not have changed in this function
    //

    ASSERT(mixerPinId == DeviceExtension->Stream.MixerPinId);

    if (NT_SUCCESS(status)) {

        DeviceExtension->Stream.PinFileObject   = pinFileObject;
        DeviceExtension->Stream.PinDeviceObject =
            IoGetRelatedDeviceObject(pinFileObject);
        DeviceExtension->Stream.VolumeNodeId = volumeNodeId;

    } else {

        DeviceExtension->Stream.PinFileObject   = NULL;
        DeviceExtension->Stream.PinDeviceObject = NULL;
        DeviceExtension->Stream.VolumeNodeId = -1;

    }

    return status;

}

NTSTATUS
    CloseSysAudio(
        PREDBOOK_DEVICE_EXTENSION DeviceExtension
        )
{
    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    ASSERT(DeviceExtension->Stream.PinFileObject);
    ASSERT(DeviceExtension->Stream.PinDeviceObject);

    ObDereferenceObject(DeviceExtension->Stream.PinFileObject);
    DeviceExtension->Stream.PinDeviceObject = NULL;
    DeviceExtension->Stream.PinFileObject = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
GetPinProperty(
    IN  PFILE_OBJECT FileObject,
    IN  ULONG        PropertyId,
    IN  ULONG        PinId,
    IN  ULONG        PropertySize,
    OUT PVOID        Property
    )
/*++

Routine Description:

    another wrapper to hide getting pin properties

Arguments:

    FileObject - file object to query

    PropertyId - what property to query

    PinId - which pin to query

    PropertySize - size of output buffer

    Property - output buffer for property

Return Value:

    status

--*/
{
    ULONG    bytesReturned;
    KSP_PIN  prop;
    NTSTATUS status;

    PAGED_CODE();

    prop.Property.Set       = KSPROPSETID_Pin;
    prop.Property.Id        = PropertyId;
    prop.Property.Flags     = KSPROPERTY_TYPE_GET;
    prop.PinId              = PinId;
    prop.Reserved           = 0;

    status = KsSynchronousIoControlDevice( FileObject,
                                           KernelMode,
                                           IOCTL_KS_PROPERTY,
                                           &prop,
                                           sizeof(prop),
                                           Property,
                                           PropertySize,
                                           &bytesReturned
                                           );

    if ( !NT_SUCCESS(status) ) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                   "GetPinProperty !! fileobj %p  property %p  "
                   "pin %d  status %lx\n",
                   FileObject, Property, PinId, status));
        return status;
    }

    ASSERT( bytesReturned == PropertySize );
    return status;
}

NTSTATUS
GetVolumeNodeId(
    IN  PFILE_OBJECT FileObject,
    OUT PULONG       VolumeNodeId
    )
/*++

Routine Description:

    Gets the pin to set the volume for playback

Arguments:

    FileObject - The fileobject which contains the pin

    VolumeNodeId - id of the volume node

Return Value:

    status

--*/
{
    KSPROPERTY property;
    ULONG      bytesReturned;
    NTSTATUS   status;

    PAGED_CODE();

    property.Set   = KSPROPSETID_Sysaudio_Pin;
    property.Id    = KSPROPERTY_SYSAUDIO_PIN_VOLUME_NODE;
    property.Flags = KSPROPERTY_TYPE_GET;

    status = KsSynchronousIoControlDevice( FileObject,
                                           KernelMode,
                                           IOCTL_KS_PROPERTY,
                                           &property,
                                           sizeof(property),
                                           VolumeNodeId,
                                           sizeof(ULONG),
                                           &bytesReturned
                                           );

    if ( !NT_SUCCESS(status) ) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                   "GetVolumeNodeId !! fileobj %p status %lx\n",
                   FileObject, status));
        return status;
    }

    ASSERT(bytesReturned == sizeof(ULONG));
    return(status);
}


NTSTATUS
UninitializeVirtualSource(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    ASSERT(DeviceExtension->Stream.MixerPinId != -1);
    ASSERT(DeviceExtension->Stream.MixerFileObject != NULL);

    state = GetCdromState(DeviceExtension);
    ASSERT(state == CD_STOPPED);

    DeviceExtension->Stream.MixerPinId = -1;
    ObDereferenceObject(DeviceExtension->Stream.MixerFileObject);
    DeviceExtension->Stream.MixerFileObject = NULL;

    return STATUS_SUCCESS;
}


NTSTATUS
InitializeVirtualSource(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

Arguments:

    MixerPinId - initialized to the correct pin id of mixer

Return Value:

    status

--*/
{
    SYSAUDIO_CREATE_VIRTUAL_SOURCE createVirtualSource;
    PFILE_OBJECT                   fileObject;
    NTSTATUS                       status;
    HANDLE                         deviceHandle;
    ULONG                          bytesReturned;
    ULONG                          mixerPinId;
    ULONG                          state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    ASSERT(DeviceExtension->Stream.MixerPinId == -1);
    ASSERT(DeviceExtension->Stream.MixerFileObject == NULL);

    state = GetCdromState(DeviceExtension);
    ASSERT(state == CD_STOPPED);

    fileObject = NULL;
    status = STATUS_SUCCESS;
    deviceHandle = NULL;
    mixerPinId = -1;

    //
    // use IoGetDeviceInterfaces()
    //
    status = OpenInterfaceByGuid(&KSCATEGORY_SYSAUDIO,
                                 &deviceHandle,
                                 &fileObject);

    if ( !NT_SUCCESS(status) ) {
        RedBookLogError(DeviceExtension,
                        REDBOOK_ERR_CANNOT_OPEN_SYSAUDIO_MIXER,
                        status);
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                   "CreateVirtSource !! Unable to open sysaudio\\mixer %lx\n",
                   status));
        goto exit;
    }

    createVirtualSource.Property.Set   = KSPROPSETID_Sysaudio;
    createVirtualSource.Property.Id    = KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE;
    createVirtualSource.Property.Flags = KSPROPERTY_TYPE_GET;
    createVirtualSource.PinCategory    = KSNODETYPE_CD_PLAYER;
    createVirtualSource.PinName        = KSNODETYPE_CD_PLAYER;

    status = KsSynchronousIoControlDevice(fileObject,
                                          KernelMode,
                                          IOCTL_KS_PROPERTY,
                                          &createVirtualSource,
                                          sizeof(createVirtualSource),
                                          &mixerPinId,
                                          sizeof(ULONG), // MixerPinId
                                          &bytesReturned
                                          );

    if ( !NT_SUCCESS(status) ) {
        RedBookLogError(DeviceExtension,
                        REDBOOK_ERR_CANNOT_CREATE_VIRTUAL_SOURCE,
                        status);
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                   "CreateVirtSource !! creating virtual source "
                   "failed %lx\n", status));
        goto exit;
    }

    ASSERT( bytesReturned == sizeof(ULONG) );

exit:

    if (NT_SUCCESS(status)) {

        DeviceExtension->Stream.MixerPinId = mixerPinId;
        DeviceExtension->Stream.MixerFileObject = fileObject;

    } else if (fileObject != NULL) {

        //
        // failed to open, so deref object if non-null
        //

        ObDereferenceObject(fileObject);
        fileObject = NULL;

    }

    if (deviceHandle != NULL) {
        ZwClose(deviceHandle);
        deviceHandle = NULL;
    }


    return status;
}

NTSTATUS
AttachVirtualSource(
    IN  PFILE_OBJECT PinFileObject,
    IN  ULONG        MixerPinId
    )
/*++

Routine Description:


Arguments:

    FileObject - ??

    MixerPinId - ??

Return Value:

    status

--*/
{
    SYSAUDIO_ATTACH_VIRTUAL_SOURCE attachVirtualSource;
    NTSTATUS status;
    ULONG bytesReturned;

    PAGED_CODE();

    //
    // if the source hasn't been initialized, reject this
    // request as invalid
    //

    if(MixerPinId == MAXULONG) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                   "AttatchVirtSource !! Mixer Pin uninitialized\n"));
        ASSERT(!"Mixer Pin Uninitialized");
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    attachVirtualSource.Property.Set   = KSPROPSETID_Sysaudio_Pin;
    attachVirtualSource.Property.Id    = KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE;
    attachVirtualSource.Property.Flags = KSPROPERTY_TYPE_SET;
    attachVirtualSource.MixerPinId     = MixerPinId;

    status = KsSynchronousIoControlDevice(PinFileObject,
                                          KernelMode,
                                          IOCTL_KS_PROPERTY,
                                          &attachVirtualSource,
                                          sizeof(attachVirtualSource),
                                          NULL,
                                          0,
                                          &bytesReturned
                                          );

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                   "AttachVirtSource !! Couldn't attatch %lx\n", status));
        return status;
    }
    return status;
}

VOID
SetNextDeviceState(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    KSSTATE State
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KSIDENTIFIER stateProperty;
    NTSTATUS     status;
    ULONG        bytesReturned;
    KSSTATE      acquireState;
    PFILE_OBJECT fileObject;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    fileObject = DeviceExtension->Stream.PinFileObject;

    acquireState = KSSTATE_ACQUIRE;

    stateProperty.Set   = KSPROPSETID_Connection;
    stateProperty.Id    = KSPROPERTY_CONNECTION_STATE;
    stateProperty.Flags = KSPROPERTY_TYPE_SET;

    ASSERT(fileObject);
    status = KsSynchronousIoControlDevice(fileObject,
                                          KernelMode,
                                          IOCTL_KS_PROPERTY,
                                          &stateProperty,
                                          sizeof(stateProperty),
                                          &acquireState,
                                          sizeof(acquireState),
                                          &bytesReturned
                                          );

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                   "SetDeviceState => (1) Audio device error %x.  need to "
                   "stop playback AND change audio devices\n", status));
    }

    //
    // now that it's acquired, set the new state
    //

    stateProperty.Set   = KSPROPSETID_Connection;
    stateProperty.Id    = KSPROPERTY_CONNECTION_STATE;
    stateProperty.Flags = KSPROPERTY_TYPE_SET;

    status = KsSynchronousIoControlDevice(fileObject,
                                          KernelMode,
                                          IOCTL_KS_PROPERTY,
                                          &stateProperty,
                                          sizeof(stateProperty),
                                          &State,
                                          sizeof(State),
                                          &bytesReturned
                                          );
    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                   "SetDeviceState => (2) Audio device error %x.  need to "
                   "stop playback AND change audio devices\n", status));
    }
    return;
}

//////////////////////////////////////////////////////////////////////
//                                                                  //
// this table is in 1/65536 decibles for a UCHAR setting:           //
//    20 * log10( Level / 256 ) * 65536                             //
//                                                                  //
//////////////////////////////////////////////////////////////////////

AttenuationTable[] = {
    0x7fffffff, 0xffcfd5d0, 0xffd5db16, 0xffd960ad, //  0- 3
    0xffdbe05c, 0xffddd08a, 0xffdf65f3, 0xffe0bcb7, //  4- 7
    0xffe1e5a2, 0xffe2eb89, 0xffe3d5d0, 0xffe4a9be, //  8- b
    0xffe56b39, 0xffe61d34, 0xffe6c1fd, 0xffe75b67, //  c- f
    0xffe7eae8, 0xffe871b6, 0xffe8f0cf, 0xffe96908, // 10-13
    0xffe9db16, 0xffea4793, 0xffeaaf04, 0xffeb11dc, // 14-17
    0xffeb707f, 0xffebcb44, 0xffec227a, 0xffec7665, // 18-1b
    0xffecc743, 0xffed154b, 0xffed60ad, 0xffeda996, // 1c-1f
    0xffedf02e, 0xffee349b, 0xffee76fc, 0xffeeb771, // 20-23
    0xffeef615, 0xffef3302, 0xffef6e4e, 0xffefa810, // 24-27
    0xffefe05c, 0xfff01744, 0xfff04cda, 0xfff0812c, // 28-2b
    0xfff0b44b, 0xfff0e643, 0xfff11722, 0xfff146f4, // 2c-2f
    0xfff175c5, 0xfff1a39e, 0xfff1d08a, 0xfff1fc93, // 30-33
    0xfff227c0, 0xfff2521b, 0xfff27bab, 0xfff2a478, // 34-37
    0xfff2cc89, 0xfff2f3e5, 0xfff31a91, 0xfff34093, // 38-3b
    0xfff365f3, 0xfff38ab4, 0xfff3aedc, 0xfff3d270, // 3c-3f
    0xfff3f574, 0xfff417ee, 0xfff439e1, 0xfff45b51, // 40-43
    0xfff47c42, 0xfff49cb8, 0xfff4bcb7, 0xfff4dc42, // 44-47
    0xfff4fb5b, 0xfff51a07, 0xfff53848, 0xfff55621, // 48-4b
    0xfff57394, 0xfff590a5, 0xfff5ad56, 0xfff5c9aa, // 4c-4f
    0xfff5e5a2, 0xfff60142, 0xfff61c8a, 0xfff6377e, // 50-53
    0xfff65220, 0xfff66c70, 0xfff68672, 0xfff6a027, // 54-57
    0xfff6b991, 0xfff6d2b1, 0xfff6eb89, 0xfff7041b, // 58-5b
    0xfff71c68, 0xfff73472, 0xfff74c3a, 0xfff763c2, // 5c-5f
    0xfff77b0b, 0xfff79216, 0xfff7a8e4, 0xfff7bf77, // 60-63
    0xfff7d5d0, 0xfff7ebf0, 0xfff801d9, 0xfff8178a, // 64-67
    0xfff82d06, 0xfff8424d, 0xfff85761, 0xfff86c42, // 68-6b
    0xfff880f1, 0xfff89570, 0xfff8a9be, 0xfff8bdde, // 6c-6f
    0xfff8d1cf, 0xfff8e593, 0xfff8f92b, 0xfff90c96, // 70-73
    0xfff91fd7, 0xfff932ed, 0xfff945d9, 0xfff9589d, // 74-77
    0xfff96b39, 0xfff97dad, 0xfff98ffa, 0xfff9a221, // 78-7b
    0xfff9b422, 0xfff9c5fe, 0xfff9d7b6, 0xfff9e94a, // 7c-7f
    0xfff9faba, 0xfffa0c08, 0xfffa1d34, 0xfffa2e3e, // 80-83
    0xfffa3f27, 0xfffa4fef, 0xfffa6097, 0xfffa711f, // 84-87
    0xfffa8188, 0xfffa91d3, 0xfffaa1ff, 0xfffab20d, // 88-8b
    0xfffac1fd, 0xfffad1d1, 0xfffae188, 0xfffaf122, // 8c-8f
    0xfffb00a1, 0xfffb1004, 0xfffb1f4d, 0xfffb2e7a, // 90-93
    0xfffb3d8e, 0xfffb4c87, 0xfffb5b67, 0xfffb6a2d, // 94-97
    0xfffb78da, 0xfffb876f, 0xfffb95eb, 0xfffba450, // 98-9b
    0xfffbb29c, 0xfffbc0d2, 0xfffbcef0, 0xfffbdcf7, // 9c-9f
    0xfffbeae8, 0xfffbf8c3, 0xfffc0688, 0xfffc1437, // a0-a3
    0xfffc21d0, 0xfffc2f55, 0xfffc3cc4, 0xfffc4a1f, // a4-a7
    0xfffc5766, 0xfffc6498, 0xfffc71b6, 0xfffc7ec1, // a8-ab
    0xfffc8bb8, 0xfffc989c, 0xfffca56d, 0xfffcb22b, // ac-af
    0xfffcbed7, 0xfffccb70, 0xfffcd7f7, 0xfffce46c, // b0-b3
    0xfffcf0cf, 0xfffcfd21, 0xfffd0961, 0xfffd1590, // b4-b7
    0xfffd21ae, 0xfffd2dbc, 0xfffd39b8, 0xfffd45a4, // b8-bb
    0xfffd5180, 0xfffd5d4c, 0xfffd6908, 0xfffd74b4, // bc-bf
    0xfffd8051, 0xfffd8bde, 0xfffd975c, 0xfffda2ca, // c0-c3
    0xfffdae2a, 0xfffdb97b, 0xfffdc4bd, 0xfffdcff1, // c4-c7
    0xfffddb16, 0xfffde62d, 0xfffdf136, 0xfffdfc31, // c8-cb
    0xfffe071f, 0xfffe11fe, 0xfffe1cd0, 0xfffe2795, // cc-cf
    0xfffe324c, 0xfffe3cf6, 0xfffe4793, 0xfffe5224, // d0-d3
    0xfffe5ca7, 0xfffe671e, 0xfffe7188, 0xfffe7be6, // d4-d7
    0xfffe8637, 0xfffe907d, 0xfffe9ab6, 0xfffea4e3, // d8-db
    0xfffeaf04, 0xfffeb91a, 0xfffec324, 0xfffecd22, // dc-df
    0xfffed715, 0xfffee0fd, 0xfffeead9, 0xfffef4aa, // e0-e3
    0xfffefe71, 0xffff082c, 0xffff11dc, 0xffff1b82, // e4-e7
    0xffff251d, 0xffff2ead, 0xffff3833, 0xffff41ae, // e8-eb
    0xffff4b1f, 0xffff5486, 0xffff5de3, 0xffff6736, // ec-ef
    0xffff707f, 0xffff79be, 0xffff82f3, 0xffff8c1e, // f0-f3
    0xffff9540, 0xffff9e58, 0xffffa767, 0xffffb06c, // f4-f7
    0xffffb968, 0xffffc25b, 0xffffcb44, 0xffffd425, // f8-fb
    0xffffdcfc, 0xffffe5ca, 0xffffee90, 0x00000000, // fc-ff
};

#define DA_CHANNEL_LEFT  0
#define DA_CHANNEL_RIGHT 1
#define DA_CHANNEL_MAX   2

VOID
RedBookKsSetVolume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    KSNODEPROPERTY_AUDIO_CHANNEL volumeProperty;
    VOLUME_CONTROL volume;
    NTSTATUS status;
    ULONG32 channel;
    ULONG32 bytesReturned = 0;
    BOOLEAN mute;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    volume = DeviceExtension->CDRom.Volume;

    //
    // These settings are common for all the sets
    //

    volumeProperty.NodeProperty.Property.Set   = KSPROPSETID_Audio;
    volumeProperty.NodeProperty.Property.Flags = KSPROPERTY_TYPE_SET |
                                                 KSPROPERTY_TYPE_TOPOLOGY;
    volumeProperty.NodeProperty.NodeId = DeviceExtension->Stream.VolumeNodeId;

    //
    // Do both Left and right channels
    //

    for ( channel = 0; channel < DA_CHANNEL_MAX; channel++ ) {

        //
        // handle the correct channel
        //

        volumeProperty.Channel = channel;

        //
        // if not muting the channel, set the volume
        //

        if ( volume.PortVolume[channel] != 0 ) {
            ULONG32 level;
            ULONG32 index;

            volumeProperty.NodeProperty.Property.Id = KSPROPERTY_AUDIO_VOLUMELEVEL;

            level = AttenuationTable[ volume.PortVolume[channel] ];

            ASSERT(DeviceExtension->Stream.PinFileObject);

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "SetVolume => Setting channel %d to %lx\n",
                       channel, level ));
            status = KsSynchronousIoControlDevice(DeviceExtension->Stream.PinFileObject,
                                                  KernelMode,
                                                  IOCTL_KS_PROPERTY,
                                                  &volumeProperty,
                                                  sizeof(volumeProperty),
                                                  &level,
                                                  sizeof(level),
                                                  &bytesReturned
                                                  );
            // ASSERT( NT_SUCCESS(status) );
            mute = FALSE;
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "SetVolume => Un-Muting channel %d\n", channel));
        } else {
            mute = TRUE;
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "SetVolume => Muting channel %d\n", channel));
        }
        volumeProperty.NodeProperty.Property.Id    = KSPROPERTY_AUDIO_MUTE;

        status = KsSynchronousIoControlDevice(DeviceExtension->Stream.PinFileObject,
                                              KernelMode,
                                              IOCTL_KS_PROPERTY,
                                              &volumeProperty,
                                              sizeof(volumeProperty),
                                              &mute,
                                              sizeof(mute),
                                              &bytesReturned
                                              );
        // ASSERT( NT_SUCCESS(status) );

    }

    //
    // End of all channels
    //

    return;

}


NTSTATUS
OpenInterfaceByGuid(
    IN  CONST GUID   * InterfaceClassGuid,
    OUT HANDLE       * Handle,
    OUT PFILE_OBJECT * FileObject
    )
{
    PWSTR tempString;
    PWSTR symbolicLinkList;
    HANDLE localHandle;
    PFILE_OBJECT localFileObject;
    NTSTATUS status;

    PAGED_CODE();

    localHandle = NULL;
    tempString = NULL;
    symbolicLinkList = NULL;
    *Handle = NULL;
    *FileObject = NULL;

    status = IoGetDeviceInterfaces(InterfaceClassGuid,
                                   // currently, the GUID is one of
                                   //  KSCATEGORY_PREFERRED_WAVEOUT_DEVICE
                                   //  or KSCATEGORY_SYSAUDIO
                                   NULL, // no preferred device object
                                   0,
                                   &symbolicLinkList);
    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                   "OpenDevice !! IoGetDeviceInterfaces failed %x\n",
                   status));
        return status;
    }

#if DBG
    tempString = symbolicLinkList;
    while (*tempString != UNICODE_NULL) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "OpenDevice => Possible Device: %ws\n", tempString));

        //
        // get the next symbolic link
        //

        while(*tempString++ != UNICODE_NULL) {
            NOTHING;
        }
    }
#endif

    //
    // this code is proudly propogated from wdmaud.sys
    //

    tempString = symbolicLinkList;
    while (*tempString != UNICODE_NULL) {

        IO_STATUS_BLOCK   ioStatusBlock;
        UNICODE_STRING    deviceString;
        OBJECT_ATTRIBUTES objectAttributes;

        RtlInitUnicodeString( &deviceString, tempString);

        InitializeObjectAttributes(&objectAttributes,
                                   &deviceString,
                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                   NULL,
                                   NULL
                                   );

        //
        // could use IoCreateFile(), based on
        // ntos\dd\wdm\audio\legacy\wdmaud.sys\sysaudio.c:OpenDevice()
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "OpenDevice => Opening %ws\n", tempString));
        status = ZwCreateFile(&localHandle,
                              GENERIC_READ | GENERIC_WRITE,
                              &objectAttributes,
                              &ioStatusBlock,
                              NULL,       // ignored on non-create
                              FILE_ATTRIBUTE_NORMAL,
                              0,          // no share access
                              FILE_OPEN,  // open the existing file
                              0, NULL, 0  // options
                              );

        if (NT_SUCCESS(status)) {

            ASSERT(localHandle != NULL);
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "OpenDevice => Opened %ws\n", tempString));
            break; // out of the while loop

        }

        ASSERT(localHandle == NULL);

        //
        // get the next symbolic link
        //

        while(*tempString++ != UNICODE_NULL) {
            NOTHING;
        }

    }

    if (symbolicLinkList != NULL) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "OpenDevice => Freeing list from IoGetDevInt...\n"));
        ExFreePool(symbolicLinkList);
        symbolicLinkList = NULL;
        tempString = NULL;
    }


    //
    // if succeeded to open the file, try to get
    // the FileObject that is related to this handle.
    //

    if (localHandle != NULL) {

        status = ObReferenceObjectByHandle(localHandle,
                                           GENERIC_READ | GENERIC_WRITE,
                                           NULL,
                                           KernelMode,
                                           &localFileObject, // double pointer
                                           NULL);

        if (NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "OpenDevice => Succeeded\n"));

            *Handle = localHandle;
            *FileObject = localFileObject;

            return status; // Exit point for success
        }

        ZwClose(localHandle);
        localHandle = NULL;

    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
               "OpenDevice => unable to open any audio devices\n"));
    status = STATUS_NO_SUCH_DEVICE;
    return status;


}


NTSTATUS
SysAudioPnpNotification(
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION Notification,
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    InterlockedExchange(&DeviceExtension->Stream.UpdateMixerPin, 1);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\redbook\redbook.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       redbook.h
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////

#ifndef __REDBOOK_H__
#define __REDBOOK_H__

//
// these two includes required for stuctures
// used in device extension for kernel streaming
//

#include <ntddk.h>
#include <ntddscsi.h>
#include <ntddcdrm.h>
#include <ntdddisk.h>  // IOCTL_DISK_CHECK_VERIFY
#include <ntddredb.h>  // wmi structure and ids

#include <stdio.h>     // vsprintf()
#include <wmistr.h>    // WMIREG_FLAG_INSTANCE_PDO
#include <wmilib.h>    // WMILIB_CONTEXT
#include <windef.h>    // for ks.h
#include <ks.h>        // for mmsystem.h
#include <mmsystem.h>  // for ksmedia.h
#include <ksmedia.h>   // required.
#include "errlog.h"

#include "trace.h"   // ETW enabling

#ifndef POOL_TAGGING
    #ifdef ExAllocatePoolWithTag
        #undef ExAllocatePoolWithTag
    #endif
    #define ExAllocatePoolWithTag(a,b,c) ExAllocatePool(a,b)

    #ifdef ExAllocatePoolWithTagPriority
        #undef ExAllocatePoolWithTagPriority
    #endif
    #define ExAllocatePoolWithTagPriority(a,b,c,d) ExAllocatePool(a,b)
#endif // endif POOL_TAGGING

#define MOFRESOURCENAME L"Redbook"

// static alloc's
#define TAG_GET_DESC   'edBR' // storage descriptor (returned to caller)
#define TAG_GET_DESC1  '1dBR' // getting storage descriptor
#define TAG_GET_DESC2  '2dBR' // getting storage descriptor
#define TAG_MODE_PAGE  'apBR' // mode pages (returned to caller)
#define TAG_MODE_PAGE1 '1pBR' // getting mode pages
#define TAG_MODE_PAGE2 '2pBR' // getting mode pages

#define TAG_EVENTS     'veBR' // extension->Thread.Events[]
#define TAG_REGPATH    'grBR' // driverExtensionObject->RegistryPath
#define TAG_REMLOCK    'lrBR' // Remove lock

#define TAG_T_IOCTL    'itBR' // THREAD_IOCTL   struct
#define TAG_T_WMI      'wtBR' // THREAD_WMI     struct
#define TAG_T_DIGITAL  'dtBR' // THREAD_DIGITAL struct

// allocs when playing
#define TAG_BUFFER     'uBBR' // Buffer->SkipBuffer
#define TAG_CC         'cCBR' // Buffer->StreamContext
#define TAG_READX      'xRBR' // Buffer->ReadOk_X
#define TAG_STREAMX    'xSBR' // Buffer->StreamOk_X

#define TAG_TOC        'oTBR' // deviceExtension->Cached.Toc
#define TAG_CV_BUFFER  'vCBR' // deviceExtension->Thread.CheckVerifyIrp->AssociatedIrp.SystemBuffer

#define CD_STOPPED         0x00000001
#define CD_PAUSED          0x00000002
#define CD_PLAYING         0x00000004
#define CD_STOPPING        0x00000010 // temp states
#define CD_PAUSING         0x00000020 // temp states

// NOTE: CD_MASK_STATE must have exactly one bit set.
// NOTE: CD_MASK_TEMP  may have zero or one bit set.
#define CD_MASK_TEMP       0x00000030 // mask of bits for transition states
#define CD_MASK_STATE      0x00000007 // mask of bits for non-temp state
#define CD_MASK_ALL        0x00000037 // mask of currently used bits

#define REMOVE_LOCK_MAX_MINUTES 10    // ten minutes max time per io
#define REMOVE_LOCK_HIGH_MARK   10000 // ten thousand concurrent ios?

#define REDBOOK_REG_SUBKEY_NAME             (L"DigitalAudio")
#define REDBOOK_REG_CDDA_ACCURATE_KEY_NAME  (L"CDDAAccurate")
#define REDBOOK_REG_CDDA_SUPPORTED_KEY_NAME (L"CDDASupported")
#define REDBOOK_REG_SECTORS_MASK_KEY_NAME   (L"SectorsPerReadMask")
#define REDBOOK_REG_SECTORS_KEY_NAME        (L"SectorsPerRead")
#define REDBOOK_REG_BUFFERS_KEY_NAME        (L"NumberOfBuffers")
#define REDBOOK_REG_VERSION_KEY_NAME        (L"RegistryVersion")

#define REDBOOK_MAX_CONSECUTIVE_ERRORS 10

#define REDBOOK_WMI_BUFFERS_MAX        30 // must be at least 3 due to
#define REDBOOK_WMI_BUFFERS_MIN         4 // method used to reduce stuttering

#define REDBOOK_WMI_SECTORS_MAX        27 // 64k per read -- 1/3 sec.
#define REDBOOK_WMI_SECTORS_MIN         1 // most processor-intensive

#define REDBOOK_REG_VERSION             1

//
// A single sector from a CD is 2352 bytes
//

#define RAW_SECTOR_SIZE            2352
#define COOKED_SECTOR_SIZE         2048

//
// these events are initialized to false, and are waited
// upon by the system thread. synchronization events all
//
// order is important, as the thread will wait on either
// events 0-3  _OR_  1-4 to allow easy processing of
// ioctls that require multiple state changes.
//

#define EVENT_IOCTL        0  // an ioctl, possibly state change
#define EVENT_WMI          1  // a wmi request, possibly buffer size changes
#define EVENT_DIGITAL      2  // digital reads/digital play
#define EVENT_KILL_THREAD  3  // thread is about to die
#define EVENT_COMPLETE     4  // complete processing of an ioctl
#define EVENT_MAXIMUM      5  // how many events we have



typedef struct _REDBOOK_STREAM_DATA
    *PREDBOOK_STREAM_DATA;
typedef struct _REDBOOK_BUFFER_DATA
    *PREDBOOK_BUFFER_DATA;
typedef struct _REDBOOK_CDROM_INFO
    *PREDBOOK_CDROM_INFO;
typedef struct _REDBOOK_DEVICE_EXTENSION
    *PREDBOOK_DEVICE_EXTENSION;
typedef struct _REDBOOK_COMPLETION_CONTEXT
    *PREDBOOK_COMPLETION_CONTEXT;

//
// Device Extension
//

typedef struct _REDBOOK_ERROR_LOG_DATA {
    LONG  Count;                       // how many errors messages sent
    ULONG RCount[REDBOOK_ERR_MAXIMUM]; // count of each error
} REDBOOK_ERROR_LOG_DATA, *PREDBOOK_ERROR_LOG_DATA;

typedef struct _REDBOOK_STREAM_DATA {

    PFILE_OBJECT    PinFileObject;  // FileObject for pin
    PDEVICE_OBJECT  PinDeviceObject;// DeviceObject for pin
    ULONG           VolumeNodeId;   // where is the device for this though?
    ULONG           MixerPinId;     // Pin of the mixer in sysaudio
    PFILE_OBJECT    MixerFileObject;// keeps a reference to the object

    ULONG           UpdateMixerPin; // PnpNotification arrived
    PVOID           SysAudioReg;    // For SysAudio PnpNotification

    //
    // the next two are win98's 'MY_PIN'
    // THESE TWO STRUCTS MUST BE KEPT CONTIGUOUS
    //
    struct {
        KSPIN_CONNECT  Connect;
        KSDATAFORMAT_WAVEFORMATEX Format;
    };

} REDBOOK_STREAM_DATA, *PREDBOOK_STREAM_DATA;

//
// move this struct's parts into REDBOOK_THREAD_DATA,
// since nothing here should be accessed outside the thread
//

typedef struct _REDBOOK_CDROM_INFO {

    //
    // cache both Table of Contents and
    // number of times disc was changed
    // (CheckVerifyStatus)
    //

    PCDROM_TOC Toc;
    ULONG StateNow;          // interlocked state, support routines to access
    ULONG CheckVerify;

    ULONG NextToRead;        // next sector to read upon getting a free buffer
    ULONG NextToStream;      // next sector to play when KS ready
    ULONG FinishedStreaming; // last to go through ks

    ULONG EndPlay;           // last sector to read/play
    ULONG ReadErrors;        // stop on errors
    ULONG StreamErrors;      // stop on errors

    //
    // CDRom State
    //

    VOLUME_CONTROL Volume;   // sizeof(char)*4

} REDBOOK_CDROM_INFO, *PREDBOOK_CDROM_INFO;

typedef struct _REDBOOK_BUFFER_DATA {

    PUCHAR  SkipBuffer;             // circular buffer
    PREDBOOK_COMPLETION_CONTEXT Contexts;
    PULONG  ReadOk_X;               //  + inuse flag for completion routines
    PULONG  StreamOk_X;             //  + to guarantee data integrity

    PUCHAR  SilentBuffer;           // when need to send silence
    PMDL    SilentMdl;              // when need to send silence

    ULONG   IndexToRead;
    ULONG   IndexToStream;

    union {
        struct {
            UCHAR   MaxIrpStack;    // allows cleaner IoInitializeIrp
            UCHAR   Paused;         // essentially a boolean
            UCHAR   FirstPause;     // so don't log pauses too often
        };
        ULONG   Reserved1;          // force alignment to ulong
    };

} REDBOOK_BUFFER_DATA, *PREDBOOK_BUFFER_DATA;

//
// Read/Stream completion routine context(s)
//

#define REDBOOK_CC_READ              1
#define REDBOOK_CC_STREAM            2
#define REDBOOK_CC_READ_COMPLETE     3
#define REDBOOK_CC_STREAM_COMPLETE   4

typedef struct _REDBOOK_COMPLETION_CONTEXT {
    LIST_ENTRY ListEntry;          // for queueing
    PREDBOOK_DEVICE_EXTENSION DeviceExtension;
    ULONG  Reason;                 // REDBOOK_CC_*

    ULONG  Index;                   // buffer index
    PUCHAR Buffer;                 // Buffer
    PMDL   Mdl;                    // Mdl for buffer
    PIRP   Irp;                    // Irp for buffer

    LARGE_INTEGER TimeReadReady;   // time the buffer was ready to read into
    LARGE_INTEGER TimeReadSent;    // time buffer was sent to read
    LARGE_INTEGER TimeStreamReady; // time the buffer was ready to stream
    LARGE_INTEGER TimeStreamSent;  // time buffer was sent to stream

    KSSTREAM_HEADER Header;        // have to be allocated, keep w/buffer
} REDBOOK_COMPLETION_CONTEXT, *PREDBOOK_COMPLETION_CONTEXT;

typedef struct _REDBOOK_THREAD_DATA {

    //
    // Handle to the thread
    //

    HANDLE SelfHandle;

    //
    // pointer to thread
    //

    PETHREAD SelfPointer;

    //
    // object pointer we referenced so we can safely wait for thread to exit
    //

    PKTHREAD ThreadReference;

    //
    // irp used to verify media hasn't changed
    //

    PIRP CheckVerifyIrp;

    //
    // Three queues: Ioctl, Wmi, Kill
    // Currently Processing is LIST_ENTRY pointer
    //

    LIST_ENTRY IoctlList;   // dump ioctls here
    LIST_ENTRY WmiList;     // dump wmi requests here
    LIST_ENTRY DigitalList; // dump rawread/stream requests here

    //
    // Three spinlocks: one for each queue
    //

    KSPIN_LOCK IoctlLock;
    KSPIN_LOCK WmiLock;
    KSPIN_LOCK DigitalLock;

    //
    // may need to wait for digital to complete for this
    //

    PLIST_ENTRY IoctlCurrent;

    //
    // keep count of pending io
    //
    ULONG PendingRead;
    ULONG PendingStream;

    //
    // Events for the thread
    //

    PKEVENT Events[EVENT_MAXIMUM];
    KWAIT_BLOCK EventBlock[EVENT_MAXIMUM];


} REDBOOK_THREAD_DATA, *PREDBOOK_THREAD_DATA;

// the kill event is just a list_entry

typedef struct _REDBOOK_THREAD_IOCTL_DATA {
    LIST_ENTRY ListEntry;
    PIRP Irp;
} REDBOOK_THREAD_IOCTL_DATA, *PREDBOOK_THREAD_IOCTL_DATA;

typedef struct _REDBOOK_THREAD_WMI_DATA {
    LIST_ENTRY ListEntry;
    PIRP Irp;
} REDBOOK_THREAD_WMI_DATA, *PREDBOOK_THREAD_WMI_DATA;

#define SAVED_IO_MAX (1)        // increase this for thread ioctl history
typedef struct _SAVED_IO {
    union {
        struct {
            PIRP              OriginalIrp;     // see where it finished
            IRP               IrpWithoutStack;
            IO_STACK_LOCATION Stack[8];
        };
        UCHAR Reserved[0x200];  // to make my tracing easier (real size: 0x194)
    };
} SAVED_IO, *PSAVED_IO;



//
// Device Extension
//

typedef struct _REDBOOK_DEVICE_EXTENSION {

    //
    // Driver Object
    //

    PDRIVER_OBJECT DriverObject;

    //
    // Target Device Object
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    // Target Physical Device Object
    //

    PDEVICE_OBJECT TargetPdo;

    //
    // Back pointer to device object
    //

    PDEVICE_OBJECT SelfDeviceObject;

    //
    // PagingPath Count
    //

    ULONG PagingPathCount;
    KEVENT PagingPathEvent;

    //
    // Pnp State
    //

    struct {
        UCHAR CurrentState;
        UCHAR PreviousState;
        BOOLEAN RemovePending;
        BOOLEAN Initialized;
    } Pnp;

    REDBOOK_ERROR_LOG_DATA ErrorLog;
    REDBOOK_CDROM_INFO  CDRom;
    REDBOOK_BUFFER_DATA Buffer;
    REDBOOK_STREAM_DATA Stream;
    REDBOOK_THREAD_DATA Thread;

    //
    // WMI Information
    //

    REDBOOK_WMI_STD_DATA WmiData;
    REDBOOK_WMI_PERF_DATA WmiPerf;
    KSPIN_LOCK WmiPerfLock;
    WMILIB_CONTEXT WmiLibInfo;
    BOOLEAN WmiLibInitialized;

    //
    // Remove Lock -- Important while playing audio
    //

    IO_REMOVE_LOCK RemoveLock;

    ULONG    SavedIoCurrentIndex;
    SAVED_IO SavedIo[SAVED_IO_MAX];

} REDBOOK_DEVICE_EXTENSION, *PREDBOOK_DEVICE_EXTENSION;


//
// Driver Extension
//

typedef struct _REDBOOK_DRIVER_EXTENSION {
    UNICODE_STRING RegistryPath;
} REDBOOK_DRIVER_EXTENSION, *PREDBOOK_DRIVER_EXTENSION;

#define REDBOOK_DRIVER_EXTENSION_ID DriverEntry

//
// Macros to make life easy
//

#define LBA_TO_RELATIVE_MSF(Lba,Minutes,Seconds,Frames)      \
{                                                            \
    (Minutes) = (UCHAR)( ((Lba)+  0) / (60 * 75)      );     \
    (Seconds) = (UCHAR)((((Lba)+  0) % (60 * 75)) / 75);     \
    (Frames)  = (UCHAR)((((Lba)+  0) % (60 * 75)) % 75);     \
}

#define LBA_TO_MSF(Lba,Minutes,Seconds,Frames)               \
{                                                            \
    (Minutes) = (UCHAR)( ((Lba)+150) / (60 * 75)      );     \
    (Seconds) = (UCHAR)((((Lba)+150) % (60 * 75)) / 75);     \
    (Frames)  = (UCHAR)((((Lba)+150) % (60 * 75)) % 75);     \
}

#define MSF_TO_LBA(Minutes,Seconds,Frames)                   \
    (ULONG)(75*((60*(Minutes))+(Seconds))+(Frames) - 150)

//
// Algebraically equal to:
//      75*60*Minutes +
//      75*Seconds    +
//      Frames        - 150
//


#define MIN(_a,_b) (((_a) <= (_b)) ? (_a) : (_b))
#define MAX(_a,_b) (((_a) >= (_b)) ? (_a) : (_b))

//
// neat little hacks to count number of bits set
//
__inline ULONG CountOfSetBits(ULONG _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
__inline ULONG CountOfSetBits32(ULONG32 _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
__inline ULONG CountOfSetBits64(ULONG64 _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   (((Flags) & (Bit)) != 0)

#ifdef TRY
    #undef TRY
#endif
#ifdef LEAVE
    #undef LEAVE
#endif
#ifdef FINALLY
    #undef FINALLY
#endif

#define TRY
#define LEAVE   goto __label;
#define FINALLY __label:


#endif // __REDBOOK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\redbook\ioctl.c ===
/*++
Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    RedBook.c

Abstract:

Author:


Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "redbook.h"
#include "ntddredb.h"
#include "proto.h"
#include <scsi.h>      // for SetKnownGoodDrive()
#include <stdio.h>     // vsprintf()

#include "ioctl.tmh"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE,   RedBookCheckForDiscChangeAndFreeResources )
    #pragma alloc_text(PAGE,   RedBookCompleteIoctl                      )
    #pragma alloc_text(PAGE,   RedBookDCCheckVerify                      )
    #pragma alloc_text(PAGE,   RedBookDCDefault                          )
    #pragma alloc_text(PAGE,   RedBookDCGetVolume                        )
    #pragma alloc_text(PAGE,   RedBookDCPause                            )
    #pragma alloc_text(PAGE,   RedBookDCPlay                             )
    #pragma alloc_text(PAGE,   RedBookDCReadQ                            )
    #pragma alloc_text(PAGE,   RedBookDCResume                           )
    #pragma alloc_text(PAGE,   RedBookDCSeek                             )
    #pragma alloc_text(PAGE,   RedBookDCSetVolume                        )
    #pragma alloc_text(PAGE,   RedBookDCStop                             )
    #pragma alloc_text(PAGE,   RedBookThreadIoctlCompletionHandler       )
    #pragma alloc_text(PAGE,   RedBookThreadIoctlHandler                 )
    #pragma alloc_text(PAGE,   WhichTrackContainsThisLBA                 )
#endif // ALLOC_PRAGMA

////////////////////////////////////////////////////////////////////////////////


NTSTATUS
RedBookDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O subsystem for device controls.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation( Irp );
    ULONG cdromState;
    NTSTATUS status;

    BOOLEAN putOnQueue = FALSE;
    BOOLEAN completeRequest = FALSE;

    //
    // ioctls not guaranteed at passive, making this whole
    // section non-paged
    //

    //
    // Prevent a remove from occuring while IO pending
    //

    status = IoAcquireRemoveLock( &deviceExtension->RemoveLock, Irp );

    if ( !NT_SUCCESS(status) ) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DeviceControl !! Unable to acquire remove lock %lx\n",
                   status));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_CD_ROM_INCREMENT );
        return status;
    }

#if DBG
    //
    // save some info for the last N device ioctls that came through
    //
    {
        ULONG index;
        ULONG sizeToCopy;
        ULONG stacksToCopy;
        PSAVED_IO savedIo;

        index = InterlockedIncrement(&deviceExtension->SavedIoCurrentIndex);
        index %= SAVED_IO_MAX;

        savedIo = &(deviceExtension->SavedIo[index]);

        //
        // copy as much of the irp as we can....
        //

        savedIo->OriginalIrp = Irp;
        if (Irp->StackCount > 7) {

            sizeToCopy = IoSizeOfIrp(8);
            RtlFillMemory(savedIo, sizeToCopy, 0xff);
            sizeToCopy -= sizeof(IO_STACK_LOCATION);
            RtlCopyMemory(savedIo, Irp, sizeToCopy);

        } else {

            sizeToCopy = IoSizeOfIrp(Irp->StackCount);
            RtlZeroMemory(savedIo, sizeof(SAVED_IO));
            RtlCopyMemory(savedIo, Irp, sizeToCopy);

        }
    } // end of saved io
#endif // DBG

    //
    // if handled, just verify the paramters in this routine.
    //

    status = STATUS_UNSUCCESSFUL;
    cdromState = GetCdromState(deviceExtension);

    switch ( currentIrpStack->Parameters.DeviceIoControl.IoControlCode ) {

        case IOCTL_CDROM_PAUSE_AUDIO: {
            if (TEST_FLAG(cdromState, CD_STOPPED)) {
                Irp->IoStatus.Information = 0;
                status = STATUS_INVALID_DEVICE_REQUEST;
                completeRequest = TRUE;
            } else {
                putOnQueue = TRUE;
            }

            break;
        }

        case IOCTL_CDROM_STOP_AUDIO: {
            if (TEST_FLAG(cdromState, CD_STOPPED)) {
                Irp->IoStatus.Information = 0;
                status = STATUS_SUCCESS;
                completeRequest = TRUE;
            } else {
                putOnQueue = TRUE;
            }
            break;
        }

        case IOCTL_CDROM_RESUME_AUDIO: {
            if (TEST_FLAG(cdromState, CD_STOPPED)) {
                Irp->IoStatus.Information = 0;
                status = STATUS_INVALID_DEVICE_REQUEST;
                completeRequest = TRUE;
            } else {
                putOnQueue = TRUE;
            }

            break;
        }

        case IOCTL_CDROM_PLAY_AUDIO_MSF: {
            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_PLAY_AUDIO_MSF)) {
                Irp->IoStatus.Information = sizeof(CDROM_PLAY_AUDIO_MSF);
                status = STATUS_BUFFER_TOO_SMALL;
                completeRequest = TRUE;
            } else {
                putOnQueue = TRUE;
            }
            break;
        }

        case IOCTL_CDROM_SEEK_AUDIO_MSF: {
            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_SEEK_AUDIO_MSF)) {
                Irp->IoStatus.Information = sizeof(CDROM_SEEK_AUDIO_MSF);
                status = STATUS_BUFFER_TOO_SMALL;
                completeRequest = TRUE;
            } else if (TEST_FLAG(cdromState, CD_STOPPED)) {
                // default -- passthrough
                // REQUIRED to reduce latency for some drives.
                // drives may still fail the request
            } else {
                putOnQueue = TRUE;
            }
            break;
        }

        case IOCTL_CDROM_READ_Q_CHANNEL: {

            PCDROM_SUB_Q_DATA_FORMAT inputBuffer;

            inputBuffer = Irp->AssociatedIrp.SystemBuffer;

            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SUB_Q_CHANNEL_DATA)) {
                Irp->IoStatus.Information = sizeof(SUB_Q_CHANNEL_DATA);
                status = STATUS_BUFFER_TOO_SMALL;
                completeRequest = TRUE;
            } else if (inputBuffer->Format != IOCTL_CDROM_CURRENT_POSITION &&
                       inputBuffer->Format != IOCTL_CDROM_MEDIA_CATALOG &&
                       inputBuffer->Format != IOCTL_CDROM_TRACK_ISRC ) {
                Irp->IoStatus.Information = 0;
                status = STATUS_INVALID_PARAMETER;
                completeRequest = TRUE;
            } else if (TEST_FLAG(cdromState, CD_STOPPED)) {
                // default -- passthrough
            } else {
                putOnQueue = TRUE;
            }
            break;
        }

        case IOCTL_CDROM_SET_VOLUME: {

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(VOLUME_CONTROL)) {
                Irp->IoStatus.Information = sizeof(VOLUME_CONTROL);
                status = STATUS_BUFFER_TOO_SMALL;
                completeRequest = TRUE;
            } else if (TEST_FLAG(cdromState, CD_STOPPED)) {
                // default -- passthrough
                // BUGBUG -- this should set our internal volume
            } else {
                putOnQueue = TRUE;
            }
            break;
        }

        case IOCTL_CDROM_GET_VOLUME: {

            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(VOLUME_CONTROL)) {
                Irp->IoStatus.Information = sizeof(VOLUME_CONTROL);
                status = STATUS_BUFFER_TOO_SMALL;
                completeRequest = TRUE;
            } else if (TEST_FLAG(cdromState, CD_STOPPED)) {
                // default -- passthrough
                // BUGBUG -- this should return our internal volume
            } else {
                putOnQueue = TRUE;
            }
            break;
        }

        case IOCTL_STORAGE_CHECK_VERIFY2:
        case IOCTL_STORAGE_CHECK_VERIFY:
        case IOCTL_CDROM_CHECK_VERIFY:
        case IOCTL_DISK_CHECK_VERIFY: {

            if ((currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength) &&
                (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG))) {
                Irp->IoStatus.Information = sizeof(ULONG);
                status = STATUS_BUFFER_TOO_SMALL;
                completeRequest = TRUE;
            } else if (TEST_FLAG(cdromState, CD_STOPPED)) {
                // default -- passthrough
            } else {
                putOnQueue = TRUE;
            }
            break;
        }

        default: {

            if (TEST_FLAG(cdromState, CD_STOPPED)) {
                // default -- passthrough
            } else {
                putOnQueue = TRUE;
            }
            break;
        }
    }

    if (putOnQueue) {

        PREDBOOK_THREAD_IOCTL_DATA ioctlData;

        ASSERT(completeRequest == FALSE);

        //
        // need to allocate some info for each ioctl we handle
        //

        ioctlData =
            (PREDBOOK_THREAD_IOCTL_DATA)ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof(REDBOOK_THREAD_IOCTL_DATA),
                TAG_T_IOCTL);
        if (ioctlData == NULL) {
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_NO_MEMORY;
            IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            return STATUS_NO_MEMORY;
        }

        RtlZeroMemory(ioctlData, sizeof(REDBOOK_THREAD_IOCTL_DATA));
        ioctlData->Irp = Irp;
        ioctlData->Irp->IoStatus.Status = STATUS_PENDING;
        IoMarkIrpPending(ioctlData->Irp);

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DeviceControl => Queue Ioctl Irp %p (%p)\n",
                   ioctlData->Irp, ioctlData));

        //
        // queue them, allow thread to handle request
        //

        ExInterlockedInsertTailList(&deviceExtension->Thread.IoctlList,
                                    &ioctlData->ListEntry,
                                    &deviceExtension->Thread.IoctlLock);
        KeSetEvent(deviceExtension->Thread.Events[EVENT_IOCTL],
                   IO_NO_INCREMENT, FALSE);


        status = STATUS_PENDING;

    } else if (completeRequest) {

        ASSERT(putOnQueue == FALSE);

        //
        // some error, ie. invalid buffer length
        //
        if (!NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "DeviceControl => Completing Irp %p with error %x\n",
                       Irp, status));
        } else {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "DeviceControl => Completing Irp %p early?\n",
                       Irp));
        }
        Irp->IoStatus.Status = status;

        IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    } else {

        //
        // pass it through
        //

        status = RedBookSendToNextDriver(DeviceObject, Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    }


    return status;
}
////////////////////////////////////////////////////////////////////////////////


VOID
RedBookThreadIoctlCompletionHandler(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    PIO_STACK_LOCATION irpStack;
    PREDBOOK_THREAD_IOCTL_DATA ioctlData;
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    ioctlData = CONTAINING_RECORD(DeviceExtension->Thread.IoctlCurrent,
                                  REDBOOK_THREAD_IOCTL_DATA,
                                  ListEntry);

    state = GetCdromState(DeviceExtension);
    irpStack = IoGetCurrentIrpStackLocation(ioctlData->Irp);

    //
    // final state should be set by the digital handler
    //

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_CDROM_PAUSE_AUDIO: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "IoctlComp => Finishing pause %p\n", ioctlData->Irp));

            ASSERT(state == CD_PAUSED);

            ioctlData->Irp->IoStatus.Information = 0;
            ioctlData->Irp->IoStatus.Status = STATUS_SUCCESS;
            RedBookCompleteIoctl(DeviceExtension, ioctlData, FALSE);
            break;
        }

        case IOCTL_CDROM_SEEK_AUDIO_MSF: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "IoctlComp => Finishing seek %p\n", ioctlData->Irp));

            ASSERT(state == CD_PLAYING);

            DeviceExtension->Buffer.FirstPause = 1;
            KeSetEvent(DeviceExtension->Thread.Events[EVENT_DIGITAL],
                       IO_CD_ROM_INCREMENT, FALSE);
            ioctlData->Irp->IoStatus.Information = 0;
            ioctlData->Irp->IoStatus.Status = STATUS_SUCCESS;
            RedBookCompleteIoctl(DeviceExtension, ioctlData, FALSE);
            break;
        }

        case IOCTL_CDROM_STOP_AUDIO: {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "IoctlComp => Finishing stop %p\n", ioctlData->Irp));

            ASSERT(TEST_FLAG(state, CD_STOPPED));

            ioctlData->Irp->IoStatus.Information = 0;
            ioctlData->Irp->IoStatus.Status = STATUS_SUCCESS;
            RedBookCompleteIoctl(DeviceExtension, ioctlData, FALSE);
            break;
        }

        default: {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "IoctlComp => Unhandled Irp %p\n", ioctlData->Irp));
            ASSERT(FALSE);

            ioctlData->Irp->IoStatus.Information = 0;
            ioctlData->Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            RedBookCompleteIoctl(DeviceExtension, ioctlData, FALSE);
            break;

        }
    }

    return;
}


NTSTATUS
RedBookCompleteIoctl(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PREDBOOK_THREAD_IOCTL_DATA Context,
    IN BOOLEAN SendToLowerDriver
    )
{
    PIRP irp = Context->Irp;

    //
    // only to be called from the thread
    //

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    //
    // should be properly setup for completion
    //

    if (DeviceExtension->Thread.IoctlCurrent == &Context->ListEntry) {

        //
        // an ioctl that required post-processing is finished.
        // allow the next one to occur
        //
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "CompleteIoctl => state-changing Irp %p completed\n",
                   irp));
        DeviceExtension->Thread.IoctlCurrent = NULL;

    }

    ExFreePool(Context);
    Context = NULL;

    if (SendToLowerDriver) {
        NTSTATUS status;
        status = RedBookSendToNextDriver(DeviceExtension->SelfDeviceObject, irp);
        IoReleaseRemoveLock(&DeviceExtension->RemoveLock, irp);
        return status;


    } else {
        IoCompleteRequest(irp, IO_CD_ROM_INCREMENT);
        IoReleaseRemoveLock(&DeviceExtension->RemoveLock, irp);
        return STATUS_SUCCESS;
    }
}


VOID
RedBookThreadIoctlHandler(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PLIST_ENTRY ListEntry
    )
{
    PREDBOOK_THREAD_IOCTL_DATA data;
    PIO_STACK_LOCATION currentIrpStack;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    //
    // should never happen if a state-changing ioctl is in progress
    //

    ASSERT(DeviceExtension->Thread.IoctlCurrent == NULL);

    //
    // don't use stale info
    //

    RedBookCheckForDiscChangeAndFreeResources(DeviceExtension);

    //
    // get the ioctl that set this event and
    // start working on state changes neccessary
    //

    data = CONTAINING_RECORD(ListEntry, REDBOOK_THREAD_IOCTL_DATA, ListEntry);

    currentIrpStack = IoGetCurrentIrpStackLocation(data->Irp);

    //
    // now guaranteed it's ok to run this ioctl
    // it's the responsibility of these routines to call RedBookCompleteIoctl()
    // *** OR *** to set DeviceExtension->Thread.IoctlCurrent to
    // Context->ListEntry if it requires post-processing, as this
    // is the mechanism used to determine the ioctl is still inprogress
    //

    switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_CDROM_PLAY_AUDIO_MSF: {
            RedBookDCPlay(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_PAUSE_AUDIO: {
            RedBookDCPause(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_RESUME_AUDIO: {
            RedBookDCResume(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_STOP_AUDIO: {
            RedBookDCStop(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_SEEK_AUDIO_MSF: {
            RedBookDCSeek(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_READ_Q_CHANNEL: {
            RedBookDCReadQ(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_SET_VOLUME: {
            RedBookDCSetVolume(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_GET_VOLUME: {
            RedBookDCGetVolume(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_CHECK_VERIFY:
        case IOCTL_DISK_CHECK_VERIFY:
        case IOCTL_STORAGE_CHECK_VERIFY:
        case IOCTL_STORAGE_CHECK_VERIFY2: {
            RedBookDCCheckVerify(DeviceExtension, data);
            break;
        }

        default: {
            data->Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
            data->Irp->IoStatus.Information = 0;
            RedBookCompleteIoctl(DeviceExtension, data, TRUE);
            break;
        }
    }
    return;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


VOID
RedBookDCCheckVerify(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION currentIrpStack;
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    state = GetCdromState(DeviceExtension);

    currentIrpStack = IoGetCurrentIrpStackLocation(Context->Irp);

    if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCCheckVerify => not playing\n"));
        RedBookCompleteIoctl(DeviceExtension, Context, TRUE);
        return;
    }

    //
    // data buffer is optional for this ioctl
    //

    if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength) {

        *((PULONG)Context->Irp->AssociatedIrp.SystemBuffer) =
            DeviceExtension->CDRom.CheckVerify;
        Context->Irp->IoStatus.Information = sizeof(ULONG);

    } else {

        Context->Irp->IoStatus.Information = 0;

    }

    Context->Irp->IoStatus.Status = STATUS_SUCCESS;

    RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
    return;

}


VOID
RedBookDCDefault(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    state = GetCdromState(DeviceExtension);

    //
    // IOCTLs are not all guaranteed to be called at passive irql,
    // so this can never be paged code.
    // there is a window of opportunity to send an ioctl while playing
    // audio digitally, but it can be ignored.  this allows much more
    // pagable code.
    //

    if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls

        RedBookCompleteIoctl(DeviceExtension, Context, TRUE);

    } else {

        //
        // Complete the Irp
        //

        Context->Irp->IoStatus.Information = 0;
        Context->Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);

    }
    return;

}


VOID
RedBookDCGetVolume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION currentIrpStack;
    NTSTATUS status;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCGetVolume => Entering %p\n", Context->Irp));

    //
    // guaranteed the volume info will not change
    //

    RtlCopyMemory(Context->Irp->AssociatedIrp.SystemBuffer, // to
                  &DeviceExtension->CDRom.Volume,  // from
                  sizeof(VOLUME_CONTROL));

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCGetVolume => volume was:"
               " (hex) %2x %2x %2x %2x\n",
               DeviceExtension->CDRom.Volume.PortVolume[0],
               DeviceExtension->CDRom.Volume.PortVolume[1],
               DeviceExtension->CDRom.Volume.PortVolume[2],
               DeviceExtension->CDRom.Volume.PortVolume[3]));

    //
    // Complete the Irp (IoStatus.Information set above)
    //

    Context->Irp->IoStatus.Information = sizeof(VOLUME_CONTROL);
    Context->Irp->IoStatus.Status = STATUS_SUCCESS;

    RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
    return;
}


VOID
RedBookDCPause(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    state = GetCdromState(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCPause => Entering %p\n", Context->Irp));

    if (!TEST_FLAG(state, CD_PLAYING)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCPause => Not playing\n"));
        Context->Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        Context->Irp->IoStatus.Information = 0;
        RedBookCompleteIoctl(DeviceExtension, Context, TRUE);
        return;

    }

    if (TEST_FLAG(state, CD_PAUSED)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCPause => Already paused %p\n", Context->Irp));
        Context->Irp->IoStatus.Status = STATUS_SUCCESS;
        Context->Irp->IoStatus.Information = 0;
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
        return;

    } else {

        //
        // since setting to a temp state, it is not appropriate to
        // complete the irp until the operation itself completes.
        //

        ASSERT(!TEST_FLAG(state, CD_PAUSING));
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCPause => Starting pause %p\n", Context->Irp));
        DeviceExtension->Thread.IoctlCurrent = &Context->ListEntry;
        state = SetCdromState(DeviceExtension, state, state | CD_PAUSING);
        return;
    }
}


VOID
RedBookDCPlay(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PCDROM_PLAY_AUDIO_MSF     inputBuffer;
    PIO_STACK_LOCATION        thisIrpStack;
    PIO_STACK_LOCATION        nextIrpStack;
    PREVENT_MEDIA_REMOVAL     mediaRemoval;
    ULONG                     sector;
    ULONG                     i;
    ULONG                     state;
    NTSTATUS                  status;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    inputBuffer  = Context->Irp->AssociatedIrp.SystemBuffer;
    thisIrpStack = IoGetCurrentIrpStackLocation(Context->Irp);
    nextIrpStack = IoGetNextIrpStackLocation(Context->Irp);


    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCPlay => Entering %p\n", Context->Irp));

    status = RedBookCacheToc(DeviceExtension);

    if (!NT_SUCCESS(status)) {
        Context->Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        Context->Irp->IoStatus.Information = 0;
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
        return;
    }

    sector = MSF_TO_LBA(inputBuffer->EndingM,
                        inputBuffer->EndingS,
                        inputBuffer->EndingF);

    DeviceExtension->CDRom.EndPlay = sector;

    sector = MSF_TO_LBA(inputBuffer->StartingM,
                        inputBuffer->StartingS,
                        inputBuffer->StartingF);

    DeviceExtension->CDRom.NextToRead   = sector;
    DeviceExtension->CDRom.NextToStream = sector;
    DeviceExtension->CDRom.FinishedStreaming = sector;

    //
    // Make sure the ending sector is within disc
    // bounds or return STATUS_INVALID_DEVICE_REQUEST?
    // this will prevent success on play, followed by an
    // immediate stop.
    //

    if (0) {
        PCDROM_TOC toc = DeviceExtension->CDRom.Toc;
        LONG track;
        LONG endTrack;

        //
        // ensure end has an lba greater than start
        //

        if (DeviceExtension->CDRom.EndPlay <=
            DeviceExtension->CDRom.NextToRead) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "Play => End sector (%x) must be more than start "
                       "sector (%x)\n",
                       DeviceExtension->CDRom.EndPlay,
                       DeviceExtension->CDRom.NextToRead
                       ));
            Context->Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            Context->Irp->IoStatus.Information = 0;
            RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
            return;
        }

        //
        // what track(s) are we playing?
        //

        track    = WhichTrackContainsThisLBA(toc, DeviceExtension->CDRom.NextToRead);
        endTrack = WhichTrackContainsThisLBA(toc, DeviceExtension->CDRom.EndPlay);

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "Play => Playing sector %x to %x (track %x to %x)\n",
                   DeviceExtension->CDRom.NextToRead,
                   DeviceExtension->CDRom.EndPlay,
                   track,
                   endTrack));

        //
        // make sure the tracks are actually valid
        //

        if (track    < 0   ||
            endTrack < 0   ||
            endTrack <= (toc->LastTrack - toc->FirstTrack)
            ) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "Play => Track %x is invalid\n", track));
            Context->Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            Context->Irp->IoStatus.Information = 0;
            RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
            return;

        }

        for (;track <= endTrack;track++) {
            if (toc->TrackData[track].Adr & AUDIO_DATA_TRACK) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                           "Play => Track %x is not audio\n", track));
                Context->Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
                Context->Irp->IoStatus.Information = 0;
                RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
                return;
            }
        }
    }

    //
    // if not paused, then state must equal stopped, which means we need
    // to allocate the resources.
    //

    state = GetCdromState(DeviceExtension);

    if (TEST_FLAG(state, CD_PAUSED)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCPlay => Resuming playback?\n"));

    } else {

        //
        // this function will allocate them iff they are not
        // already allocated.
        //

        status = RedBookAllocatePlayResources(DeviceExtension);
        if (!NT_SUCCESS(status)) {
            Context->Irp->IoStatus.Status = STATUS_NO_MEMORY;
            Context->Irp->IoStatus.Information = 0;
            RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
            return;
        }

    }

    //
    // Set the new device state (thread will begin playing)
    //

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCPlay => Setting state to CD_PLAYING\n"));
    state = SetCdromState(DeviceExtension, state, CD_PLAYING);
    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCPlay => Exiting successfully\n"));

    //
    // finish the request if it's a user
    // request for a new play operation
    //

    Context->Irp->IoStatus.Status = STATUS_SUCCESS;
    Context->Irp->IoStatus.Information = 0;
    RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
    return;

}


VOID
RedBookDCReadQ(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PCDROM_SUB_Q_DATA_FORMAT inputBuffer;
    PIO_STACK_LOCATION currentIrpStack;
    UCHAR              formatCode;
    ULONG              state;
    NTSTATUS           status;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    inputBuffer = Context->Irp->AssociatedIrp.SystemBuffer;
    currentIrpStack = IoGetCurrentIrpStackLocation(Context->Irp);
    state = GetCdromState(DeviceExtension);

    if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls

        //
        // no need to handle this irp
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCReadQ => Not playing\n"));
        RedBookCompleteIoctl(DeviceExtension, Context, TRUE);
        return;
    }

    if (inputBuffer->Format != IOCTL_CDROM_CURRENT_POSITION) {
        Context->Irp->IoStatus.Information = 0;
        Context->Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCReadQ => Bad Format %x\n", inputBuffer->Format));
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
        return;
    }

    //
    // we are in the midst of playback or pause.  fake the information
    // a real cdrom would have returned if it was playing audio at the
    // same location that we are currently at.
    //

    {
        PSUB_Q_CURRENT_POSITION outputBuffer;
        PCDROM_TOC toc;
        ULONG lbaTrack;
        ULONG lbaRelative;
        ULONG instantLba;
        UCHAR timeAbsolute[3];
        UCHAR timeRelative[3];
        LONG trackNumber;

        outputBuffer = Context->Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(outputBuffer,
                      currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength);

        //
        // Still playing audio
        //

        outputBuffer->Header.Reserved      = 0;
        if (TEST_FLAG(state, CD_PAUSED)) {
            outputBuffer->Header.AudioStatus = AUDIO_STATUS_PAUSED;
        } else if (TEST_FLAG(state, CD_PLAYING)) {
            outputBuffer->Header.AudioStatus = AUDIO_STATUS_IN_PROGRESS;
        } else {
            ASSERT(!"State was invalid?");
            outputBuffer->Header.AudioStatus = AUDIO_STATUS_IN_PROGRESS;
        }
        outputBuffer->Header.DataLength[0] =
            (sizeof(SUB_Q_CURRENT_POSITION) - sizeof(SUB_Q_HEADER)) >> 8;
        outputBuffer->Header.DataLength[1] =
            (sizeof(SUB_Q_CURRENT_POSITION) - sizeof(SUB_Q_HEADER)) & 0xFF;


        //
        // we are in the thread, which alloc's/dealloc's the toc
        //

        toc = DeviceExtension->CDRom.Toc;
        ASSERT(toc);

        //
        // we return the last played sector as a result per the spec
        //

        instantLba = DeviceExtension->CDRom.FinishedStreaming;

        trackNumber = WhichTrackContainsThisLBA(toc, instantLba);


        ASSERT(trackNumber >= 0);

        outputBuffer->FormatCode  = IOCTL_CDROM_CURRENT_POSITION;
        outputBuffer->Control     = toc->TrackData[trackNumber].Control;
        outputBuffer->ADR         = toc->TrackData[trackNumber].Adr;
        outputBuffer->TrackNumber = toc->TrackData[trackNumber].TrackNumber;

        //
        // Get the track's LBA
        //

        lbaTrack = MSF_TO_LBA(toc->TrackData[trackNumber].Address[1],
                              toc->TrackData[trackNumber].Address[2],
                              toc->TrackData[trackNumber].Address[3]);

        //
        // Get the current play LBA
        //

        lbaRelative = instantLba;

        //
        // Subtract the track's LBA to get the relative LBA
        //

        lbaRelative -= lbaTrack;

        //
        // Finally convert it back to MSF
        //

        LBA_TO_MSF(instantLba,
                   timeAbsolute[0],
                   timeAbsolute[1],
                   timeAbsolute[2]);
        LBA_TO_RELATIVE_MSF(lbaRelative,
                            timeRelative[0],
                            timeRelative[1],
                            timeRelative[2]);

        outputBuffer->IndexNumber             = (UCHAR)trackNumber;
        outputBuffer->AbsoluteAddress[0]      = 0;
        outputBuffer->AbsoluteAddress[1]      = timeAbsolute[0];
        outputBuffer->AbsoluteAddress[2]      = timeAbsolute[1];
        outputBuffer->AbsoluteAddress[3]      = timeAbsolute[2];

        outputBuffer->TrackRelativeAddress[0] = 0;
        outputBuffer->TrackRelativeAddress[1] = timeRelative[0];
        outputBuffer->TrackRelativeAddress[2] = timeRelative[1];
        outputBuffer->TrackRelativeAddress[3] = timeRelative[2];

        //
        // The one line debug info...
        //
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctlV, "[redbook] "
                   "ReadQ => "
                   "Trk [%#02x] Indx [%#02x] "
                   "Abs [%#02d:%#02d.%#02d] Rel [%#02d:%#02d.%#02d]\n",
                   outputBuffer->TrackNumber,
                   trackNumber,
                   timeAbsolute[0], timeAbsolute[1], timeAbsolute[2],
                   timeRelative[0], timeRelative[1], timeRelative[2]));

    }
    //
    // Complete the Irp
    //

    Context->Irp->IoStatus.Information = sizeof(SUB_Q_CURRENT_POSITION);
    Context->Irp->IoStatus.Status      = STATUS_SUCCESS;
    RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
    return;
}


VOID
RedBookDCResume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    state = GetCdromState(DeviceExtension);

    if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCResume => Not Playing\n"));
        RedBookCompleteIoctl(DeviceExtension, Context, TRUE);
        return;
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCResume => Entering\n"));

    if (TEST_FLAG(state, CD_PAUSED)) {

        //
        // we need to start the resume operation
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCResume => Resuming playback\n"));
        state = SetCdromState(DeviceExtension, state, CD_PLAYING);
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCResume => Resume succeeded\n"));

    } else {

        //
        // if not paused, return success
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCResume => Not paused -- succeeded\n"));

    }

    //
    // always complete the Irp
    //

    Context->Irp->IoStatus.Information = 0;
    Context->Irp->IoStatus.Status = STATUS_SUCCESS;
    RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
    return;

}


VOID
RedBookDCSeek(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

    same as a IOCTL_CDROM_STOP

Arguments:

Return Value:

--*/
{
    NTSTATUS                  status;
    ULONG                     state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCSeek => Entering\n"));
    state = GetCdromState(DeviceExtension);

    if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCSeek => Not Playing\n"));
        Context->Irp->IoStatus.Information = 0;
        Context->Irp->IoStatus.Status = STATUS_SUCCESS;
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
        return;
    }

    //
    // stop the stream if currently playing
    //

    if (TEST_FLAG(state, CD_PAUSED)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCSeek => Paused, setting to stopped\n"));
        state = SetCdromState(DeviceExtension, state, CD_STOPPED);
        Context->Irp->IoStatus.Information = 0;
        Context->Irp->IoStatus.Status = STATUS_SUCCESS;
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
        return;
    }

    //
    // since setting to a temp state, it is not appropriate to
    // complete the irp until the operation itself completes.
    //
    
    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCSeek => stopping the stream\n"));
    DeviceExtension->Thread.IoctlCurrent = &Context->ListEntry;
    state = SetCdromState(DeviceExtension, state, state | CD_STOPPING);
    return;
}


VOID
RedBookDCSetVolume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION currentIrpStack;
    ULONG state;
    NTSTATUS status;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCSetVolume => Entering\n"));

    //
    // guaranteed the volume info will not change right now
    //

    RtlCopyMemory(&DeviceExtension->CDRom.Volume,  // to
                  Context->Irp->AssociatedIrp.SystemBuffer, // from
                  sizeof(VOLUME_CONTROL));

    state = GetCdromState(DeviceExtension);

    if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCSetVolume => Not Playing\n"));
        RedBookCompleteIoctl(DeviceExtension, Context, TRUE);
        return;
    }

    //
    // not set above since don't have volume control
    //

    RedBookKsSetVolume(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctlV, "[redbook] "
                 "DCSetVolume => volume set to:"
                 " (hex) %2x %2x %2x %2x\n",
                 DeviceExtension->CDRom.Volume.PortVolume[0],
                 DeviceExtension->CDRom.Volume.PortVolume[1],
                 DeviceExtension->CDRom.Volume.PortVolume[2],
                 DeviceExtension->CDRom.Volume.PortVolume[3]));

    //
    // Complete the Irp (IoStatus.Information set above)
    //

    Context->Irp->IoStatus.Information = 0;
    Context->Irp->IoStatus.Status = STATUS_SUCCESS;
    RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
    return;
}


VOID
RedBookDCStop(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS status;
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCStop => Entering %p\n", Context->Irp));
    state = GetCdromState(DeviceExtension);

    if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCStop => Stop when already stopped\n"));
        Context->Irp->IoStatus.Information = 0;
        Context->Irp->IoStatus.Status = STATUS_SUCCESS;
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
        return;
    }

    //
    // Still playing audio. if paused, just call the stop finish routine
    //

    if (TEST_FLAG(state, CD_PAUSED)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCStop => Stop when paused\n"));
        state = SetCdromState(DeviceExtension, state, CD_STOPPED);
        Context->Irp->IoStatus.Information = 0;
        Context->Irp->IoStatus.Status = STATUS_SUCCESS;
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
        return;
    }

    //
    // since setting to a temp state, it is not appropriate to
    // complete the irp until the operation itself completes.
    //

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCStop => stopping the stream\n"));
    DeviceExtension->Thread.IoctlCurrent = &Context->ListEntry;
    state = SetCdromState(DeviceExtension, state, state | CD_STOPPING);
    return;

}
////////////////////////////////////////////////////////////////////////////////


VOID
RedBookCheckForDiscChangeAndFreeResources(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )

//
// if we've paused, and the disc has changed, don't
// want to be returning stale toc info when the player
// resumes playback.
//

{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    PULONG count;
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    //
    // only do this if we are in a PAUSED or STOPPED state
    //

    state = GetCdromState(DeviceExtension);
    if ((!TEST_FLAG(state, CD_STOPPED))  &&
        (!TEST_FLAG(state, CD_PAUSED))) {
        return;
    }

    //
    // resources might already be deallocated.
    //

    irp = DeviceExtension->Thread.CheckVerifyIrp;
    if (irp == NULL) {
        return;
    }

    irpStack = IoGetCurrentIrpStackLocation(irp);

#if DBG
    {
        //
        // the irp must be setup when it's allocated.  we rely on this.
        //

        ASSERT(irpStack->Parameters.DeviceIoControl.InputBufferLength == 0);
        ASSERT(irpStack->Parameters.DeviceIoControl.OutputBufferLength ==
               sizeof(ULONG));
        ASSERT(irpStack->Parameters.DeviceIoControl.IoControlCode ==
               IOCTL_CDROM_CHECK_VERIFY);
        ASSERT(irpStack->Parameters.DeviceIoControl.Type3InputBuffer == NULL);
        ASSERT(irp->AssociatedIrp.SystemBuffer != NULL);
    }
#endif

    count = (PULONG)(irp->AssociatedIrp.SystemBuffer);
    *count = 0;

    RedBookForwardIrpSynchronous(DeviceExtension, irp);

    if (!NT_SUCCESS(irp->IoStatus.Status) ||
        ((*count) != DeviceExtension->CDRom.CheckVerify)
        ) {

        //
        // if the count has changed set the state to STOPPED.
        // (old state is either STOPPED or PAUSED, so either one can
        //  seemlessly transition to the STOPPED state without any
        //  trouble.)
        //
        // also free currently held play resources
        //

        state = SetCdromState(DeviceExtension, state, CD_STOPPED);
        RedBookDeallocatePlayResources(DeviceExtension);

    }
    return;
}


ULONG
WhichTrackContainsThisLBA(
    PCDROM_TOC Toc,
    ULONG Lba
    )
//
// returns -1 if not found
//
{
    LONG trackNumber;
    UCHAR msf[3];

    PAGED_CODE();

    LBA_TO_MSF(Lba, msf[0], msf[1], msf[2]);

    for (trackNumber = Toc->LastTrack - Toc->FirstTrack;
         trackNumber >= 0;
         trackNumber-- ) {

        //
        // we have found the track if
        // Minutes is less or
        // Minutes is equal and Seconds is less or
        // Minutes and Seconds are equal Frame is less or
        // Minutes, Seconds, and Frame are equal
        //
        // the compiler optimizes this nicely.
        //

        if (Toc->TrackData[trackNumber].Address[1] < msf[0] ) {
            break;
        } else
        if (Toc->TrackData[trackNumber].Address[1] == msf[0] &&
            Toc->TrackData[trackNumber].Address[2] <  msf[1] ) {
            break;
        } else
        if (Toc->TrackData[trackNumber].Address[1] == msf[0] &&
            Toc->TrackData[trackNumber].Address[2] == msf[1] &&
            Toc->TrackData[trackNumber].Address[3] <  msf[2] ) {
            break;
        } else
        if (Toc->TrackData[trackNumber].Address[1] == msf[0] &&
            Toc->TrackData[trackNumber].Address[2] == msf[1] &&
            Toc->TrackData[trackNumber].Address[3] == msf[2] ) {
            break;
        }
    }

    return trackNumber;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\redbook\trace.h ===
/*

    WPP_DEFINE_CONTROL_GUID specifies the GUID used for this filter.
    *** REPLACE THE GUID WITH YOUR OWN UNIQUE ID ***
    WPP_DEFINE_BIT allows setting debug bit masks to selectively print.
    
    everything else can revert to the default?

*/

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(Redbook,(58db8e03,0537,45cb,b29b,597f6cbebbfe), \
        WPP_DEFINE_BIT(RedbookDebugError)         /* bit  0 = 0x00000001 */ \
        WPP_DEFINE_BIT(RedbookDebugWarning)       /* bit  1 = 0x00000002 */ \
        WPP_DEFINE_BIT(RedbookDebugTrace)         /* bit  2 = 0x00000004 */ \
        WPP_DEFINE_BIT(RedbookDebugInfo)          /* bit  3 = 0x00000008 */ \
        WPP_DEFINE_BIT(RedbookDebugD04)           /* bit  4 = 0x00000010 */ \
        WPP_DEFINE_BIT(RedbookDebugErrlog)        /* bit  5 = 0x00000020 */ \
        WPP_DEFINE_BIT(RedbookDebugRegistry)      /* bit  6 = 0x00000040 */ \
        WPP_DEFINE_BIT(RedbookDebugAllocPlay)     /* bit  7 = 0x00000080 */ \
        WPP_DEFINE_BIT(RedbookDebugPnp)           /* bit  8 = 0x00000100 */ \
        WPP_DEFINE_BIT(RedbookDebugThread)        /* bit  9 = 0x00000200 */ \
        WPP_DEFINE_BIT(RedbookDebugWmi)           /* bit 10 = 0x00000400 */ \
        WPP_DEFINE_BIT(RedbookDebugIoctl)         /* bit 11 = 0x00000800 */ \
        WPP_DEFINE_BIT(RedbookDebugIoctlV)        /* bit 12 = 0x00001000 */ \
        WPP_DEFINE_BIT(RedbookDebugSysaudio)      /* bit 13 = 0x00002000 */ \
        WPP_DEFINE_BIT(RedbookDebugDigitalR)      /* bit 14 = 0x00004000 */ \
        WPP_DEFINE_BIT(RedbookDebugDigitalS)      /* bit 15 = 0x00008000 */ \
        WPP_DEFINE_BIT(FilterDebugD16)            /* bit 16 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD17)            /* bit 17 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD18)            /* bit 18 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD19)            /* bit 19 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD20)            /* bit 20 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD21)            /* bit 21 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD22)            /* bit 22 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD23)            /* bit 23 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD24)            /* bit 24 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD25)            /* bit 25 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD26)            /* bit 26 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD27)            /* bit 27 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD28)            /* bit 28 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD29)            /* bit 29 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD30)            /* bit 30 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD31)            /* bit 31 = 0x00000000 */ \
        )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\redbook\thread.c ===
/*++
Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    thread.c

Abstract:


Author:


Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "redbook.h"
#include "ntddredb.h"
#include "proto.h"
#include <scsi.h>      // for SetKnownGoodDrive()
#include <stdio.h>     // vsprintf()

#include "thread.tmh"

//
// this is how many seconds until resources are free'd from
// a play, and also how long (in seconds) before a frozen state
// is detected (and a fix attempted).
//

#define REDBOOK_THREAD_FIXUP_SECONDS          10
#define REDBOOK_THREAD_SYSAUDIO_CACHE_SECONDS  2
#define REDBOOK_PERFORM_STUTTER_CONTROL        0

#if DBG

    //
    // allows me to send silence to ks as needed
    //

    ULONG RedBookForceSilence = FALSE;

#endif

#ifdef ALLOC_PRAGMA

    #pragma alloc_text(PAGE,   RedBookAllocatePlayResources      )
    #pragma alloc_text(PAGE,   RedBookCacheToc                   )
    #pragma alloc_text(PAGE,   RedBookDeallocatePlayResources    )
    #pragma alloc_text(PAGERW, RedBookReadRaw                    )
    #pragma alloc_text(PAGERW, RedBookStream                     )
    #pragma alloc_text(PAGE,   RedBookSystemThread               )
    #pragma alloc_text(PAGE,   RedBookCheckForAudioDeviceRemoval )
    #pragma alloc_text(PAGE,   RedBookThreadDigitalHandler       )

/*
    but last two CANNOT be unlocked when playing,
    so they are (temporarily) commented out.
    eventually will only have them locked when playing

    #pragma alloc_text(PAGERW, RedBookReadRawCompletion          )
    #pragma alloc_text(PAGERW, RedBookStreamCompletion           )

*/

#endif ALLOC_PRAGMA


VOID
RedBookSystemThread(
    PVOID Context
    )
/*++

Routine Description:

    This system thread will wait on events,
    sending buffers to Kernel Streaming as they
    become available.

Arguments:

    Context - deviceExtension

Return Value:

    status

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = Context;
    LARGE_INTEGER timeout;
    NTSTATUS waitStatus;
    NTSTATUS status;
    ULONG    i;
    ULONG    timeouts;
    LARGE_INTEGER stopTime;

    //
    // some per-thread state
    //

    BOOLEAN  killed = FALSE;

    PAGED_CODE();

    deviceExtension->Thread.SelfPointer = PsGetCurrentThread();
    
    //
    // perf fix -- run at low realtime priority
    //
    
    KeSetPriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY);
    
    timeouts = 0;
    stopTime.QuadPart = 0;

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
               "Thread => UpdateMixerPin at %p\n",
               &deviceExtension->Stream.UpdateMixerPin));

    //
    // Just loop waiting for events.
    //

    //waitForNextEvent:
    while ( 1 ) {

        //
        // if are killed, just wait on singular event--EVENT_DIGITAL until
        // can finish processing.  there should not be anything left in the
        // IOCTL_LIST (since the kill calls RemoveLockAndWait() first)
        //
        // this also implies that a kill will never occur while ioctls are
        // still being processed.  this does not guarantee the state will
        // be STOPPED, just that no IO will be occurring.
        //


        //
        // nanosecond is 10^-9, units is 100 nanoseconds
        // so seconds is 10,000,000 units
        // must wait in relative time, which requires negative numbers
        //

        timeout.QuadPart = (LONGLONG)(-1 * 10 * 1000 * (LONGLONG)1000);

        //
        // note: we are using a timeout mechanism mostly to catch bugs
        //       where the state would lock up.  we also "auto adjust"
        //       our internal state if things get too wierd, basically
        //       auto-fixing ourselves.  note that this does cause the
        //       thread's stack to be swapped in, so this shouldn't
        //       be done when we're 100% stopped.
        //

        if (deviceExtension->Thread.IoctlCurrent == NULL) {
            
            //
            // wait on an ioctl, but not the ioctl completion event
            //
            
            ULONG state = GetCdromState(deviceExtension);
            if ((state == CD_STOPPED) &&
                (!RedBookArePlayResourcesAllocated(deviceExtension))
                ) {

                //
                // if we've got no current ioctl and we haven't allocated
                // any resources, there're no need to timeout.
                // this will prevent this stack from getting swapped in
                // needlessly, reducing effective footprint a bit
                //

                stopTime.QuadPart = 0;
                waitStatus = KeWaitForMultipleObjects(EVENT_MAXIMUM - 1,
                                                      (PVOID)(&deviceExtension->Thread.Events[0]),
                                                      WaitAny,
                                                      Executive,
                                                      UserMode,
                                                      FALSE, // Alertable
                                                      NULL,
                                                      deviceExtension->Thread.EventBlock
                                                      );

            } else {

                //
                // we've got no current ioctl, but we're also not stopped.
                // it is also possible to be waiting to cleanup resources here.
                // even if we're paused, we want to keep track of what's
                // going on, since it's possible for the state to get
                // messed up here.
                //

                waitStatus = KeWaitForMultipleObjects(EVENT_MAXIMUM - 1,
                                                      (PVOID)(&deviceExtension->Thread.Events[0]),
                                                      WaitAny,
                                                      Executive,
                                                      UserMode,
                                                      FALSE, // Alertable
                                                      &timeout,
                                                      deviceExtension->Thread.EventBlock
                                                      );

            }


        } else {
            
            //
            // wait on the ioctl completion, but not the ioctl event
            //

            waitStatus = KeWaitForMultipleObjects(EVENT_MAXIMUM - 1,
                                                  (PVOID)(&deviceExtension->Thread.Events[1]),
                                                  WaitAny,
                                                  Executive,
                                                  UserMode,
                                                  FALSE, // Alertable
                                                  &timeout,
                                                  deviceExtension->Thread.EventBlock
                                                  );
            if (waitStatus != STATUS_TIMEOUT) {
                waitStatus ++; // to account for offset
            }

        }

        //
        // need to check if we are stopped for too long -- if so, free
        // the resources.
        //
        {
            ULONG state = GetCdromState(deviceExtension);

            if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) {
    
                LARGE_INTEGER now;
    
                // not playing, 
                if (stopTime.QuadPart == 0) {
    
                    LONGLONG offset;
                    
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                               "StopTime => Determining when to dealloc\n"));
    
                    // query the time
                    KeQueryTickCount( &stopTime );
    
                    // add appropriate offset
                    // nanosecond is 10^-9, units is 100 nanoseconds
                    // so seconds is 10,000,000 units
                    //
                    offset = REDBOOK_THREAD_SYSAUDIO_CACHE_SECONDS;
                    offset *= (LONGLONG)(10 * 1000 * (LONGLONG)1000);
                    
                    // divide offset by time increment
                    offset /= (LONGLONG)KeQueryTimeIncrement();
                    
                    // add those ticks to store when we should release
                    // our resources
                    stopTime.QuadPart += offset;
    
                }
    
                KeQueryTickCount(&now);
    
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                           "StopTime => Is %I64x >= %I64x?\n",
                           now.QuadPart,
                           stopTime.QuadPart
                           ));
    
                if (now.QuadPart >= stopTime.QuadPart) {
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                               "StopTime => Deallocating resources\n"));
                    RedBookDeallocatePlayResources(deviceExtension);
                }
    
            } else {
    
                stopTime.QuadPart = 0;
    
            }
        }


        RedBookCheckForAudioDeviceRemoval(deviceExtension);

        //
        // To enable a single thread for multiple cdroms, just set events
        // at offset of (DEVICE_ID * EVENT_MAX) + EVENT_TO_SET
        // set deviceExtension = waitStatus / EVENT_MAX
        // switch ( waitStatus % EVENT_MAX )
        //
        if (waitStatus == EVENT_DIGITAL) {
            timeouts = 0;
        }

        switch ( waitStatus ) {

            case EVENT_IOCTL: {

                PLIST_ENTRY listEntry;
                while ((listEntry = ExInterlockedRemoveHeadList(
                            &deviceExtension->Thread.IoctlList,
                            &deviceExtension->Thread.IoctlLock)) != NULL) {

                    RedBookThreadIoctlHandler(deviceExtension, listEntry);

                    if (deviceExtension->Thread.IoctlCurrent) {
                        // special case
                        break;
                    }

                }

                break;
            }
            case EVENT_COMPLETE: {
                RedBookThreadIoctlCompletionHandler(deviceExtension);
                break;
            }

            case EVENT_WMI: {

                PLIST_ENTRY listEntry;
                while ((listEntry = ExInterlockedRemoveHeadList(
                            &deviceExtension->Thread.WmiList,
                            &deviceExtension->Thread.WmiLock)) != NULL) {

                    RedBookThreadWmiHandler(deviceExtension, listEntry);

                }
                break;
            }

            case EVENT_DIGITAL: {

                PLIST_ENTRY listEntry;
                while ((listEntry = ExInterlockedRemoveHeadList(
                            &deviceExtension->Thread.DigitalList,
                            &deviceExtension->Thread.DigitalLock)) != NULL) {

                    RedBookThreadDigitalHandler(deviceExtension, listEntry);

                }
                break;
            }

            case EVENT_KILL_THREAD: {

                ULONG state = GetCdromState(deviceExtension);

                killed = TRUE;

                //
                // i don't think this can occur with outstanding io, since
                // the remove lock is taken first.  nonetheless, it's better
                // to be safe than sorry.
                //

                if (!TEST_FLAG(state, CD_STOPPED)) {
                    state = SetCdromState(deviceExtension, state, CD_STOPPING);
                    break;
                }

                RedBookDeallocatePlayResources(deviceExtension);

                //
                // else we can safely terminate.
                //

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                           "STExit => Thread was killed\n"));
                ASSERT(deviceExtension->Thread.PendingRead   == 0);
                ASSERT(deviceExtension->Thread.PendingStream == 0);
                PsTerminateSystemThread(STATUS_SUCCESS);
                ASSERT(!"[redbook] Thread should never reach past self-terminate code");
                break;
            }

            case STATUS_TIMEOUT: {

                ULONG state = GetCdromState(deviceExtension);

                timeouts++;

                if (timeouts < REDBOOK_THREAD_FIXUP_SECONDS) {
                    break;
                } else {
                    timeouts = 0;
                }

                //
                // these tests all occur once every ten seconds.
                // the most basic case is where we want to deallocate
                // our cached TOC, but we also perform lots of
                // sanity testing here -- ASSERTing on CHK builds and
                // trying to fix ourselves up when possible.
                //

                if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls

                    // not playing, so free resources
                    RedBookDeallocatePlayResources(deviceExtension);

                } else if (TEST_FLAG(state, CD_STOPPING)) {
                    
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                               "STTime !! %x seconds inactivity\n",
                               REDBOOK_THREAD_FIXUP_SECONDS));

                    if (IsListEmpty(&deviceExtension->Thread.DigitalList)) {

                        if ((deviceExtension->Thread.PendingRead == 0) &&
                            (deviceExtension->Thread.PendingStream == 0) &&
                            (deviceExtension->Thread.IoctlCurrent != NULL)) {
    
                             KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError,
                                        "[redbook] "
                                        "STTime !! No Reads, No Streams, In a temp "
                                        "state (%x) and have STOP irp %p "
                                        "pending?!\n",
                                        state,
                                        ((PREDBOOK_THREAD_IOCTL_DATA)deviceExtension->Thread.IoctlCurrent)->Irp
                                        ));
                             ASSERT(!"STTime !! CD_STOPPING Fixup with no reads nor streams but STOP pending\n");
                             SetCdromState(deviceExtension, state, CD_STOPPED);
                             KeSetEvent(deviceExtension->Thread.Events[EVENT_COMPLETE],
                                        IO_NO_INCREMENT, FALSE);
                            
                        } else {

                            ASSERT(!"STTime !! CD_STOPPING Fixup with empty list and no pending ioctl?\n");

                        }

                    } else {
                        
                        ASSERT(!"STTime !! CD_STOPPING Fixup with list items\n");
                        KeSetEvent(deviceExtension->Thread.Events[EVENT_DIGITAL],
                                   IO_NO_INCREMENT, FALSE);

                    }

                } else if (TEST_FLAG(state, CD_PAUSING)) {
                    
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                               "STTime !! %x seconds inactivity\n",
                               REDBOOK_THREAD_FIXUP_SECONDS));

                    if (IsListEmpty(&deviceExtension->Thread.DigitalList)) {
                        
                        if ((deviceExtension->Thread.PendingRead == 0) &&
                            (deviceExtension->Thread.PendingStream == 0) &&
                            (deviceExtension->Thread.IoctlCurrent != NULL)) {
    
                             KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError,
                                        "[redbook] "
                                        "STTime !! No Reads, No Streams, In a temp "
                                        "state (%x) and have PAUSE irp %p "
                                        "pending?!\n",
                                        state,
                                        ((PREDBOOK_THREAD_IOCTL_DATA)deviceExtension->Thread.IoctlCurrent)->Irp
                                        ));
                             ASSERT(!"STTime !! CD_PAUSING Fixup with no reads nor streams but PAUSE pending\n");
                             SetCdromState(deviceExtension, state, CD_PAUSED);
                             KeSetEvent(deviceExtension->Thread.Events[EVENT_COMPLETE],
                                        IO_NO_INCREMENT, FALSE);
                            
                        } else {

                            ASSERT(!"STTime !! CD_PAUSING Fixup with empty list and no pending ioctl?\n");

                        }

                    } else {

                        ASSERT(!"STTime !! CD_PAUSING Fixup with list items\n");
                        KeSetEvent(deviceExtension->Thread.Events[EVENT_DIGITAL],
                                   IO_NO_INCREMENT, FALSE);

                    }

                } else if (TEST_FLAG(state, CD_PAUSED)) {

                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                               "STTime => Still paused\n"));

                } else {

                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                               "STTime !! %x seconds inactivity\n",
                               REDBOOK_THREAD_FIXUP_SECONDS));

                    if (IsListEmpty(&deviceExtension->Thread.DigitalList)) {
                        ASSERT(!"STTime !! CD_PLAYING Fixup with empty list\n");
                    } else {
                        ASSERT(!"STTime !! CD_PLAYING Fixup with list items\n");
                        KeSetEvent(deviceExtension->Thread.Events[EVENT_DIGITAL],
                                   IO_NO_INCREMENT, FALSE);
                    }

                }
                break;

            }

            default: {

                if (waitStatus > 0 && waitStatus < EVENT_MAXIMUM) {
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                               "ST     !! Unhandled event: %lx\n",
                               waitStatus));
                } else {
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                               "ST     !! event too large/small: %lx\n",
                               waitStatus));
                }

                ASSERT(!"[redbook] ST !! Unhandled event");
                break;
            }

        } // end of the huge case statement.

        //
        // check if ioctl waiting or killed.  if so, and state is no longer
        // in an intermediate state, set the appropriate event.
        // ordered to short-curcuit quickly.
        //

        {
            ULONG state = GetCdromState(deviceExtension);

            if (killed &&
                deviceExtension->Thread.PendingRead == 0 &&
                deviceExtension->Thread.PendingStream == 0) {

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                           "ST => Killing Thread %p\n",
                           deviceExtension->Thread.SelfPointer));

                ASSERT(!TEST_FLAG(state, CD_MASK_TEMP));

                state = SetCdromState(deviceExtension, state, CD_STOPPED);

                KeSetEvent(deviceExtension->Thread.Events[EVENT_KILL_THREAD],
                           IO_NO_INCREMENT, FALSE);
            }
        }

        continue;
    } // while(1) loop
    ASSERT(!"[redbook] ST !! somehow broke out of while(1) loop?");
}


VOID
RedBookReadRaw(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_COMPLETION_CONTEXT Context
    )

/*++

Routine Description:

    Reads raw audio data off the cdrom.
    Must either reinsert Context into queue and set an event
    or set a completion routine which will do so.

Arguments:

    DeviceObject - CDROM class driver object or lower level filter

Return Value:

    status

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION nextIrpStack;
    PRAW_READ_INFO readInfo;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalR, "[redbook] "
               "ReadRaw => Entering\n"));

    status = IoAcquireRemoveLock(&DeviceExtension->RemoveLock, Context->Irp);

    if (!NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalR, "[redbook] "
                   "ReadRaw !! RemoveLock failed %lx\n", status));

        // end of thread loop will check for no outstanding io
        // and on too many errors set stopping
        // don't forget perf info

        Context->TimeReadSent.QuadPart = 0; // special value
        Context->Irp->IoStatus.Status = status;
        Context->Reason = REDBOOK_CC_READ_COMPLETE;

        //
        // put it on the queue and set the event
        //

        ExInterlockedInsertTailList(&DeviceExtension->Thread.DigitalList,
                                    &Context->ListEntry,
                                    &DeviceExtension->Thread.DigitalLock);
        KeSetEvent(DeviceExtension->Thread.Events[EVENT_DIGITAL],
                   IO_CD_ROM_INCREMENT, FALSE);
        return;
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalR, "[redbook] "
               "ReadRaw => Index %x sending Irp %p\n",
               Context->Index, Context->Irp));

    //
    // (no failure from this point forward)
    //

    IoReuseIrp(Context->Irp, STATUS_UNSUCCESSFUL);

    Context->Irp->MdlAddress = Context->Mdl;

    //
    // irp is from kernel mode
    //

    Context->Irp->AssociatedIrp.SystemBuffer = NULL;

    //
    // fill in the completion context
    //

    ASSERT(Context->DeviceExtension == DeviceExtension);

    //
    // setup the irpstack for the raw read
    //

    nextIrpStack = IoGetNextIrpStackLocation(Context->Irp);

    SET_FLAG(nextIrpStack->Flags, SL_OVERRIDE_VERIFY_VOLUME);

    nextIrpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    nextIrpStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_CDROM_RAW_READ;
    nextIrpStack->Parameters.DeviceIoControl.Type3InputBuffer =
        Context->Buffer;
    nextIrpStack->Parameters.DeviceIoControl.InputBufferLength =
        sizeof(RAW_READ_INFO);
    nextIrpStack->Parameters.DeviceIoControl.OutputBufferLength =
        (RAW_SECTOR_SIZE * DeviceExtension->WmiData.SectorsPerRead);

    //
    // setup the read info (uses same buffer)
    //

    readInfo                      = (PRAW_READ_INFO)(Context->Buffer);
    readInfo->DiskOffset.QuadPart =
        (ULONGLONG)(DeviceExtension->CDRom.NextToRead)*COOKED_SECTOR_SIZE;
    readInfo->SectorCount         = DeviceExtension->WmiData.SectorsPerRead;
    readInfo->TrackMode           = CDDA;

    //
    // send it.
    //

    IoSetCompletionRoutine(Context->Irp, RedBookReadRawCompletion, Context,
                           TRUE, TRUE, TRUE);
    KeQueryTickCount(&Context->TimeReadSent);
    IoCallDriver(DeviceExtension->TargetDeviceObject, Context->Irp);

    return;
}


NTSTATUS
RedBookReadRawCompletion(
    PVOID UnusableParameter,
    PIRP Irp,
    PREDBOOK_COMPLETION_CONTEXT Context
    )
/*++

Routine Description:

    When a read completes, use zero'd buffer if error occurred.
    Make buffer available to ks, then set ks event.

Arguments:

    DeviceObject - NULL, due to being originator of IRP

    Irp - pointer to buffer to send to KS
          must check error to increment/clear error count

    Context - REDBOOK_COMPLETION_CONTEXT

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = Context->DeviceExtension;

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalR, "[redbook] "
               "ReadRaw => Completed Irp %p\n", Irp));

    KeQueryTickCount(&Context->TimeStreamReady);
    Context->Reason = REDBOOK_CC_READ_COMPLETE;

    ExInterlockedInsertTailList(&deviceExtension->Thread.DigitalList,
                                &Context->ListEntry,
                                &deviceExtension->Thread.DigitalLock);

    KeSetEvent(deviceExtension->Thread.Events[EVENT_DIGITAL],
               IO_CD_ROM_INCREMENT, FALSE);
    
    //
    // safe to release it since we wait for thread termination
    //

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Context->Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
RedBookStream(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_COMPLETION_CONTEXT Context
    )
/*++

Routine Description:

    Send buffer to KS.
    Must either reinsert Context into queue and set an event
    or set a completion routine which will do so.

Arguments:

    Context - DeviceExtension

Return Value:

    status

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION nextIrpStack;

    PUCHAR buffer;
    PKSSTREAM_HEADER header;

    ULONG bufferSize;

    PULONG streamOk;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalS, "[redbook] "
               "Stream => Entering\n"));

    bufferSize = DeviceExtension->WmiData.SectorsPerRead * RAW_SECTOR_SIZE;

    status = IoAcquireRemoveLock(&DeviceExtension->RemoveLock, Context->Irp);

    if (!NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalS, "[redbook] "
                   "Stream !! RemoveLock failed %lx\n", status));

        // end of thread loop will check for no outstanding io
        // and on too many errors set CD_STOPPING
        // don't forget perf info

        Context->TimeReadSent.QuadPart = 0; // special value
        Context->Irp->IoStatus.Status = status;
        Context->Reason = REDBOOK_CC_STREAM_COMPLETE;

        //
        // put it on the queue and set the event
        //

        ExInterlockedInsertTailList(&DeviceExtension->Thread.DigitalList,
                                    &Context->ListEntry,
                                    &DeviceExtension->Thread.DigitalLock);
        KeSetEvent(DeviceExtension->Thread.Events[EVENT_DIGITAL],
                   IO_CD_ROM_INCREMENT, FALSE);
        return;
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalS, "[redbook] "
               "Stream => Index %x sending Irp %p\n",
               Context->Index, Context->Irp));

    //
    // CONSIDER - how does STOPPED occur?
    // SUGGEST - out of loop, if no error and none pending, set to STOPPED?
    //

    //
    // (no failure from this point forward)
    //

    //
    // use a zero'd buffer if an error occurred during the read
    //

    if (NT_SUCCESS(Context->Irp->IoStatus.Status)) {
        IoReuseIrp(Context->Irp, STATUS_SUCCESS);
        buffer = Context->Buffer; // good data
        Context->Irp->MdlAddress = Context->Mdl;
    } else {
        IoReuseIrp(Context->Irp, STATUS_SUCCESS);
        buffer = DeviceExtension->Buffer.SilentBuffer; // zero'd data
        Context->Irp->MdlAddress = DeviceExtension->Buffer.SilentMdl;
    }

#if DBG
    if (RedBookForceSilence) {
        buffer = DeviceExtension->Buffer.SilentBuffer; // zero'd data
        Context->Irp->MdlAddress = DeviceExtension->Buffer.SilentMdl;
    }
#endif // RedBookUseSilence


    nextIrpStack = IoGetNextIrpStackLocation(Context->Irp);

    //
    // get and fill in the context
    //

    ASSERT(Context->DeviceExtension == DeviceExtension);

    //
    // setup the irpstack for streaming the buffer
    //

    nextIrpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    nextIrpStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_KS_WRITE_STREAM;
    nextIrpStack->Parameters.DeviceIoControl.OutputBufferLength =
        sizeof(KSSTREAM_HEADER);
    nextIrpStack->Parameters.DeviceIoControl.InputBufferLength =
        sizeof(KSSTREAM_HEADER);
    nextIrpStack->FileObject = DeviceExtension->Stream.PinFileObject;

    Context->Header.FrameExtent       = bufferSize;
    Context->Header.DataUsed          = bufferSize;
    Context->Header.Size              = sizeof(KSSTREAM_HEADER);
    Context->Header.TypeSpecificFlags = 0;
    Context->Header.Data              = buffer;
    Context->Header.OptionsFlags      = 0;

    Context->Irp->AssociatedIrp.SystemBuffer = &Context->Header;



#if REDBOOK_PERFORM_STUTTER_CONTROL

#if REDBOOK_WMI_BUFFERS_MIN < 3
    #error "The minimum number of buffers must be at least three due to the method used to prevent stuttering"
#endif // REDBOOK_WMI_BUFFERS_MIN < 3

    //
    // perform my own pausing to prevent stuttering
    //

    if (DeviceExtension->Thread.PendingStream <= 3 &&
        DeviceExtension->Buffer.Paused == 0) {

        //
        // only one buffer (or less) was pending play,
        // so pause the output to prevent horrible
        // stuttering.
        // since this is serialized from a thread,
        // can set a simple boolean in the extension
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalS, "[redbook] "
                   "Stream => Pausing, few buffers pending\n"));

        if (DeviceExtension->Buffer.FirstPause == 0) {
            RedBookLogError(DeviceExtension,
                            REDBOOK_ERR_INSUFFICIENT_DATA_STREAM_PAUSED,
                            STATUS_SUCCESS
                            );
            InterlockedIncrement(&DeviceExtension->WmiPerf.StreamPausedCount);
        } else {
            DeviceExtension->Buffer.FirstPause = 0;
        }

        DeviceExtension->Buffer.Paused = 1;
        SetNextDeviceState(DeviceExtension, KSSTATE_PAUSE);

    } else if (DeviceExtension->Buffer.Paused == 1 &&
               DeviceExtension->Thread.PendingStream ==
               DeviceExtension->WmiData.NumberOfBuffers ) {

        ULONG i;

        //
        // are now using the maximum number of buffers,
        // all pending stream.  this allows smooth play again.
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalS, "[redbook] "
                   "Stream => Resuming, %d buffers pending\n",
                   DeviceExtension->WmiData.NumberOfBuffers));
        DeviceExtension->Buffer.Paused = 0;

        //
        // prevent these statistics from being added.
        //

        for (i=0;i<DeviceExtension->WmiData.NumberOfBuffers;i++) {
            (DeviceExtension->Buffer.Contexts + i)->TimeReadSent.QuadPart = 0;
        }

        //
        // let the irps go!
        //

        SetNextDeviceState(DeviceExtension, KSSTATE_RUN);

    } // end of stutter prevention
#endif // REDBOOK_PERFORM_STUTTER_CONTROL

    //
    // get perf counters at last possible second
    //

    KeQueryTickCount(&Context->TimeStreamSent);
    IoSetCompletionRoutine(Context->Irp, RedBookStreamCompletion, Context,
                           TRUE, TRUE, TRUE);
    IoCallDriver(DeviceExtension->Stream.PinDeviceObject, Context->Irp);

    return;
}


NTSTATUS
RedBookStreamCompletion(
    PVOID UnusableParameter,
    PIRP Irp,
    PREDBOOK_COMPLETION_CONTEXT Context
    )
/*++

Routine Description:

Arguments:

    DeviceObject - CDROM class driver object or lower level filter

    Irp - pointer to buffer to send to KS
          must check error to increment/clear error count

    Context - sector of disk (ordered number)

Return Value:

    status

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = Context->DeviceExtension;

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalS, "[redbook] "
               "Stream => Completed Irp %p\n", Irp));

    KeQueryTickCount(&Context->TimeReadReady);
    Context->Reason = REDBOOK_CC_STREAM_COMPLETE;

    ExInterlockedInsertTailList(&deviceExtension->Thread.DigitalList,
                                &Context->ListEntry,
                                &deviceExtension->Thread.DigitalLock);

    KeSetEvent(deviceExtension->Thread.Events[EVENT_DIGITAL],
               IO_CD_ROM_INCREMENT, FALSE);

    //
    // safe to release it since we wait for thread termination
    //

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Context->Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


#if DBG
VOID
ValidateCdromState(ULONG State)
{
    ULONG temp;

    if (State == 0) {
        ASSERT(!"Invalid Cdrom State");
    } else
    if (TEST_FLAG(State, ~CD_MASK_ALL)) {
        ASSERT(!"Invalid Cdrom State");
    }

    temp = State & CD_MASK_TEMP;
    if (temp  & (temp - 1)) {  // see if zero or one bits are set
        ASSERT(!"Invalid Cdrom State");
    }

    temp = State & CD_MASK_STATE;
    if (temp == 0) {           // dis-allow zero bits for STATE
        ASSERT(!"Invalid Cdrom State");
    } else
    if (temp  & (temp - 1)) {  // see if zero or one bits are set
        ASSERT(!"Invalid Cdrom State");
    }

    return;
}

#else
VOID ValidateCdromState(ULONG State) {return;}
#endif


ULONG
GetCdromState(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    //
    // this routine may be called by anyone, whether in the thread's
    // context or not.  setting the state is restricted, however.
    //
    ULONG state;
    state = InterlockedCompareExchange(&DeviceExtension->CDRom.StateNow,0,0);
    ValidateCdromState(state);
    return state;
}


LONG
SetCdromState(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN LONG ExpectedOldState,
    IN LONG NewState
    )
{
    LONG trueOldState;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    // ensure when set to:     also setting:
    // CD_PAUSING              CD_PLAYING
    // CD_STOPPING             CD_PLAYING

    if (TEST_FLAG(NewState, CD_PAUSING)) {
        SET_FLAG(NewState, CD_PLAYING);
    }

    if (TEST_FLAG(NewState, CD_STOPPING)) {
        SET_FLAG(NewState, CD_PLAYING);
    }

    ValidateCdromState(ExpectedOldState);
    ValidateCdromState(NewState);

    //attempt to change it
    trueOldState = InterlockedCompareExchange(
        &DeviceExtension->CDRom.StateNow,
        NewState,
        ExpectedOldState
        );

    ASSERTMSG("State set outside of thread",
              trueOldState == ExpectedOldState);

    //
    // see if an event should be fired, volume set, and/or
    // stream state set
    //
    if (ExpectedOldState == NewState) {

        //
        // if state is not changing, don't do anything
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "Setting state to same as expected?! %x == %x\n",
                   ExpectedOldState, NewState));

    } else if (TEST_FLAG(ExpectedOldState, CD_MASK_TEMP)) {

        //
        // should not go from temp state to temp state
        //

        ASSERT(!TEST_FLAG(NewState, CD_MASK_TEMP));

        //
        // ioctl is being processed, and state is no longer
        // in a temp state, so should process the ioctl again
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "SetState => EVENT_COMPLETE should be set soon "
                   "for %p\n", DeviceExtension->Thread.IoctlCurrent));

    } else if (TEST_FLAG(NewState, CD_MASK_TEMP)) {

        //
        // going to either pausing or stopping, both of which must
        // be specially handled by stopping the KS stream also.
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "SetState => %s, setting device state "
                   "to KSSTATE_STOP\n",
                   (TEST_FLAG(NewState, CD_STOPPING) ? "STOP" : "PAUSE")));

        SetNextDeviceState(DeviceExtension, KSSTATE_STOP);

    } else if (TEST_FLAG(NewState, CD_PAUSED)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "SetState => Finishing a PAUSE operation\n"));

    } else if (TEST_FLAG(NewState, CD_PLAYING)) {

        ULONG i;
        PREDBOOK_COMPLETION_CONTEXT context;

        ASSERT(NewState == CD_PLAYING);

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "SetState => Starting a PLAY operation\n"));

        //
        // not same state, not from temp state,
        // so must either be paused or stopped.
        //

        ASSERT(TEST_FLAG(ExpectedOldState,CD_STOPPED) ||
               TEST_FLAG(ExpectedOldState,CD_PAUSED));

        //
        // set some deviceextension stuff
        //


        RtlZeroMemory(&DeviceExtension->WmiPerf,
                      sizeof(REDBOOK_WMI_PERF_DATA));
        DeviceExtension->CDRom.ReadErrors     = 0;
        DeviceExtension->CDRom.StreamErrors   = 0;
        DeviceExtension->Buffer.Paused        = 0;
        DeviceExtension->Buffer.FirstPause    = 1;
        DeviceExtension->Buffer.IndexToRead   = 0;
        DeviceExtension->Buffer.IndexToStream = 0;

        //
        // reset the buffer state
        //

        ASSERT(DeviceExtension->Buffer.Contexts);
        context = DeviceExtension->Buffer.Contexts;

        for (i=0; i<DeviceExtension->WmiData.NumberOfBuffers;i++) {

            *(DeviceExtension->Buffer.ReadOk_X   + i) = 0;
            *(DeviceExtension->Buffer.StreamOk_X + i) = 0;

            context->Reason = REDBOOK_CC_READ;
            context->Irp->IoStatus.Status = STATUS_SUCCESS;

            ExInterlockedInsertTailList(&DeviceExtension->Thread.DigitalList,
                                        &context->ListEntry,
                                        &DeviceExtension->Thread.DigitalLock);

            context++; // pointer arithmetic
        }
        context = NULL;

        //
        // start the digital playback
        //

        SetNextDeviceState(DeviceExtension, KSSTATE_RUN);
        RedBookKsSetVolume(DeviceExtension);
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "SetState => Setting DIGITAL event\n"));
        KeSetEvent(DeviceExtension->Thread.Events[EVENT_DIGITAL],
                   IO_CD_ROM_INCREMENT, FALSE);


    } else {

        //
        // ReadQ Channel or some such nonsense
        //

    }


    return GetCdromState(DeviceExtension);
}


VOID
RedBookDeallocatePlayResources(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    PREDBOOK_COMPLETION_CONTEXT context;
    ULONG i;
    BOOLEAN freedSomething = FALSE;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);
#if DBG
    {
        ULONG state = GetCdromState(DeviceExtension);
        ASSERT(!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED));
    }
#endif


    //
    // free all resources
    //

    if (DeviceExtension->Buffer.StreamOk_X) {
        freedSomething = TRUE;
        ExFreePool(DeviceExtension->Buffer.StreamOk_X);
        DeviceExtension->Buffer.StreamOk_X = NULL;
    }

    if (DeviceExtension->Buffer.ReadOk_X) {
        freedSomething = TRUE;
        ExFreePool(DeviceExtension->Buffer.ReadOk_X);
        DeviceExtension->Buffer.ReadOk_X = NULL;
    }

    if (DeviceExtension->Buffer.Contexts) {

        context = DeviceExtension->Buffer.Contexts;
        for (i=0;i<DeviceExtension->WmiData.NumberOfBuffers;i++) {
            if (context->Irp) {
                IoFreeIrp(context->Irp);
            }
            if (context->Mdl) {
                IoFreeMdl(context->Mdl);
            }
            context++; // pointer arithmetic
        }
        context = NULL;

        freedSomething = TRUE;
        ExFreePool(DeviceExtension->Buffer.Contexts);
        DeviceExtension->Buffer.Contexts = NULL;
    }

    if (DeviceExtension->Buffer.SilentMdl) {
        freedSomething = TRUE;
        IoFreeMdl(DeviceExtension->Buffer.SilentMdl);
        DeviceExtension->Buffer.SilentMdl = NULL;
    }

    if (DeviceExtension->Buffer.SkipBuffer) {
        freedSomething = TRUE;
        ExFreePool(DeviceExtension->Buffer.SkipBuffer);
        DeviceExtension->Buffer.SkipBuffer = NULL;
    }

    if (DeviceExtension->Thread.CheckVerifyIrp) {
        PIRP irp = DeviceExtension->Thread.CheckVerifyIrp;
        freedSomething = TRUE;
        if (irp->MdlAddress) {
            IoFreeMdl(irp->MdlAddress);
        }
        if (irp->AssociatedIrp.SystemBuffer) {
            ExFreePool(irp->AssociatedIrp.SystemBuffer);
        }

        IoFreeIrp(DeviceExtension->Thread.CheckVerifyIrp);
        DeviceExtension->Thread.CheckVerifyIrp = NULL;
    }

    if (DeviceExtension->Stream.PinFileObject) {
        freedSomething = TRUE;
        CloseSysAudio(DeviceExtension);
    }

    if (DeviceExtension->CDRom.Toc) {
        freedSomething = TRUE;
        ExFreePool(DeviceExtension->CDRom.Toc);
        DeviceExtension->CDRom.Toc = NULL;
    }

    if (freedSomething) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "DeallocatePlay => Deallocated play resources\n"));
    }

    return;
}

BOOLEAN
RedBookArePlayResourcesAllocated(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
//
// just choose one, since it's all done in a batch in
// one thread context it's always safe.
//
{
    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);
    return (DeviceExtension->Stream.PinFileObject != NULL);
}



NTSTATUS
RedBookAllocatePlayResources(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
//
// allocate resources if they are not already allocated
//
{
    PREDBOOK_COMPLETION_CONTEXT context;
    NTSTATUS status;
    KEVENT event;
    ULONG numBufs;
    ULONG numSectors;
    ULONG bufSize;
    ULONG i;
    CCHAR maxStack;
    BOOLEAN sysAudioOpened = FALSE;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    //
    // NOTE:
    // The call to update the mixer Id may de-allocate all play
    // resources, since the stack sizes may change.  it must
    // therefore be the first call within this routine.
    //

    if (DeviceExtension->Stream.MixerPinId == -1) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "AllocatePlay => No mixer set?\n"));
        return STATUS_UNSUCCESSFUL;
    }

    if (DeviceExtension->Buffer.Contexts != NULL) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "AllocatePlay => Using existing resources\n"));
        return STATUS_SUCCESS;
    }

#if DBG
    {
        ULONG state = GetCdromState(DeviceExtension);
        ASSERT(!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED));
    }
#endif

    ASSERT(DeviceExtension->Buffer.Contexts == NULL);
    ASSERT(DeviceExtension->Buffer.SkipBuffer == NULL);

    numBufs = DeviceExtension->WmiData.NumberOfBuffers;
    numSectors = DeviceExtension->WmiData.SectorsPerRead;
    bufSize = RAW_SECTOR_SIZE * numSectors;

    TRY {

        ASSERT(DeviceExtension->Stream.MixerPinId != -1);

        //
        // may need to allocate the CheckVerifyIrp
        //

        {
            PIO_STACK_LOCATION irpStack;
            PIRP irp;
            irp = DeviceExtension->Thread.CheckVerifyIrp;

            if (irp == NULL) {
                irp = IoAllocateIrp(
                    (CCHAR)(DeviceExtension->SelfDeviceObject->StackSize+1),
                    FALSE);
            }
            if (irp == NULL) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                           "AllocatePlay => No CheckVerifyIrp\n"));
                status = STATUS_NO_MEMORY;
                LEAVE;
            }

            irp->AssociatedIrp.SystemBuffer = irp->MdlAddress = NULL;

            irp->AssociatedIrp.SystemBuffer =
                ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                      sizeof(ULONG),
                                      TAG_CV_BUFFER);
            if (irp->AssociatedIrp.SystemBuffer == NULL) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                           "AllocatePlay => No CheckVerify Buffer\n"));
                status = STATUS_NO_MEMORY;
                LEAVE;
            }

            irp->MdlAddress = IoAllocateMdl(irp->AssociatedIrp.SystemBuffer,
                                            sizeof(ULONG),
                                            FALSE, FALSE, NULL);
            if (irp->MdlAddress == NULL) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                           "AllocatePlay => No CheckVerify Mdl\n"));
                status = STATUS_NO_MEMORY;
                LEAVE;
            }

            MmBuildMdlForNonPagedPool(irp->MdlAddress);

            IoSetNextIrpStackLocation(irp);
            irpStack = IoGetCurrentIrpStackLocation(irp);

            irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;

            irpStack->Parameters.DeviceIoControl.InputBufferLength =
                0;
            irpStack->Parameters.DeviceIoControl.OutputBufferLength =
                sizeof(ULONG);
            irpStack->Parameters.DeviceIoControl.IoControlCode =
                IOCTL_CDROM_CHECK_VERIFY;

            DeviceExtension->Thread.CheckVerifyIrp = irp;
        }


        //
        // connect to sysaudio
        //

        {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                       "AllocatePlay => Preparing to open sysaudio\n"));

            ASSERT(DeviceExtension->Stream.MixerPinId != MAXULONG);

            status = OpenSysAudio(DeviceExtension);

            if ( !NT_SUCCESS(status) ) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                           "AllocatePlay !! Unable to open sysaudio %lx\n",
                           status));
                LEAVE;
            }

            // else the pin is open
            sysAudioOpened = TRUE;
        }

        maxStack = MAX(DeviceExtension->TargetDeviceObject->StackSize,
                       DeviceExtension->Stream.PinDeviceObject->StackSize);
        DeviceExtension->Buffer.MaxIrpStack = maxStack;

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "AllocateePlay => Stacks: Cdrom %x  Stream %x\n",
                   DeviceExtension->TargetDeviceObject->StackSize,
                   DeviceExtension->Stream.PinDeviceObject->StackSize));
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "AllocateePlay => Allocating %x stacks per irp\n",
                   maxStack));


        DeviceExtension->Buffer.SkipBuffer =
            ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                  bufSize * (numBufs + 1),
                                  TAG_BUFFER);

        if (DeviceExtension->Buffer.SkipBuffer == NULL) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "AllocatePlay => No Skipbuffer\n"));
            status = STATUS_NO_MEMORY;
            LEAVE;
        }
        RtlZeroMemory(DeviceExtension->Buffer.SkipBuffer,
                      bufSize * (numBufs + 1));

        DeviceExtension->Buffer.Contexts =
            ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(REDBOOK_COMPLETION_CONTEXT) * numBufs,
                                  TAG_CC);

        if (DeviceExtension->Buffer.Contexts   == NULL) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                       "AllocatePlay => No Contexts\n"));
            status = STATUS_NO_MEMORY;
            LEAVE;
        }

        RtlZeroMemory(DeviceExtension->Buffer.Contexts,
                      sizeof(REDBOOK_COMPLETION_CONTEXT) * numBufs);

        context = DeviceExtension->Buffer.Contexts;
        for (i=0;i<numBufs;i++) {

            context->DeviceExtension = DeviceExtension;
            context->Reason = REDBOOK_CC_READ;
            context->Index = i;
            context->Buffer = DeviceExtension->Buffer.SkipBuffer +
                (bufSize * i); // pointer arithmetic of UCHARS

            //
            // allocate irp, mdl
            //

            context->Irp = IoAllocateIrp(maxStack, FALSE);
            context->Mdl = IoAllocateMdl(context->Buffer, bufSize,
                                         FALSE, FALSE, NULL);
            if (context->Irp == NULL ||
                context->Mdl == NULL) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                           "AllocatePlay => Irp/Mdl %x failed\n", i));
                status = STATUS_NO_MEMORY;
                LEAVE;
            }

            MmBuildMdlForNonPagedPool(context->Mdl);

            context++; // pointer arithmetic of CONTEXTS
        }
        context = NULL; // safety

        //
        // allocated above as part of SkipBuffer
        //

        DeviceExtension->Buffer.SilentBuffer =
            DeviceExtension->Buffer.SkipBuffer + (bufSize * numBufs);


        DeviceExtension->Buffer.SilentMdl =
            IoAllocateMdl(DeviceExtension->Buffer.SkipBuffer, bufSize,
                          FALSE, FALSE, NULL);
        if (DeviceExtension->Buffer.SilentMdl == NULL) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                       "AllocatePlay => Silent Mdl failed\n"));
            status = STATUS_NO_MEMORY;
            LEAVE;
        }

        DeviceExtension->Buffer.ReadOk_X =
            ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                  sizeof(ULONG) * numBufs,
                                  TAG_READX);
        if (DeviceExtension->Buffer.ReadOk_X == NULL) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                       "AllocatePlay => ReadOk_X failed\n"));
            status = STATUS_NO_MEMORY;
            LEAVE;
        }
        RtlZeroMemory(DeviceExtension->Buffer.ReadOk_X,
                      sizeof(ULONG) * numBufs);

        DeviceExtension->Buffer.StreamOk_X =
            ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                  sizeof(ULONG) * numBufs,
                                  TAG_STREAMX);
        if (DeviceExtension->Buffer.StreamOk_X == NULL) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                       "AllocatePlay => ReadOk_X failed\n"));
            status = STATUS_NO_MEMORY;
            LEAVE;
        }
        RtlZeroMemory(DeviceExtension->Buffer.StreamOk_X,
                      sizeof(ULONG) * numBufs);

        MmBuildMdlForNonPagedPool(DeviceExtension->Buffer.SilentMdl);

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "AllocatePlay => Allocated All Resources\n"));

        status = STATUS_SUCCESS;

    } FINALLY {

        if (!NT_SUCCESS(status)) {

            RedBookDeallocatePlayResources(DeviceExtension);
            return status;
        }
    }

    //
    // else all resources allocated
    //

    return STATUS_SUCCESS;

}


NTSTATUS
RedBookCacheToc(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    PCDROM_TOC newToc;
    PIRP irp;
    ULONG mediaChangeCount;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    //
    // cache the number of times the media has changed
    // use this to prevent redundant reads of the toc
    // and to return Q channel info during playback
    //

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // first get the mediaChangeCount to see if we've already
    // cached this toc
    //

    irp = IoBuildDeviceIoControlRequest(IOCTL_CDROM_CHECK_VERIFY,
                                        DeviceExtension->TargetDeviceObject,
                                        NULL, 0,
                                        &mediaChangeCount, sizeof(ULONG),
                                        FALSE,
                                        &event, &ioStatus);
    if (irp == NULL) {
        return STATUS_NO_MEMORY;
    }

    SET_FLAG(IoGetNextIrpStackLocation(irp)->Flags, SL_OVERRIDE_VERIFY_VOLUME);

    status = IoCallDriver(DeviceExtension->TargetDeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "CacheToc !! CheckVerify failed %lx\n", status));
        return status;
    }

    //
    // read TOC only we don't have the correct copy cached
    //

    if (DeviceExtension->CDRom.Toc         != NULL &&
        DeviceExtension->CDRom.CheckVerify == mediaChangeCount) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "CacheToc => Using cached toc\n"));
        return STATUS_SUCCESS;

    }

    //
    // Allocate for the cached TOC
    //

    newToc = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                   sizeof(CDROM_TOC),
                                   TAG_TOC);

    if (newToc == NULL) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "CacheToc !! Unable to allocate new TOC\n"));
        return STATUS_NO_MEMORY;
    }

    KeClearEvent(&event);

    irp = IoBuildDeviceIoControlRequest(IOCTL_CDROM_READ_TOC,
                                        DeviceExtension->TargetDeviceObject,
                                        NULL, 0,
                                        newToc, sizeof(CDROM_TOC),
                                        FALSE,
                                        &event, &ioStatus);
    if (irp == NULL) {
        ExFreePool(newToc);
        newToc = NULL;
        return STATUS_NO_MEMORY;
    }

    SET_FLAG(IoGetNextIrpStackLocation(irp)->Flags, SL_OVERRIDE_VERIFY_VOLUME);

    status = IoCallDriver(DeviceExtension->TargetDeviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    //
    // set the new toc, or if error free it
    // return the status
    //

    if (!NT_SUCCESS(status)) {

        ExFreePool(newToc);
        newToc = NULL;
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "CacheToc !! Failed to get TOC %lx\n", status));

    } else {

        if (DeviceExtension->CDRom.Toc) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                       "CacheToc => Freeing old toc %p\n",
                       DeviceExtension->CDRom.Toc));
            ExFreePool(DeviceExtension->CDRom.Toc);
        }
        DeviceExtension->CDRom.Toc = newToc;
        DeviceExtension->CDRom.CheckVerify = mediaChangeCount;

    }
    return status;
}


VOID
RedBookThreadDigitalHandler(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PLIST_ENTRY ListEntry
    )
//
//  DECREMENT StreamPending/ReadPending if it's a completion
//  SET stopped, error, etc. states
//  INCREMENT StreamPending/ReadPending if it's to be sent again
//
{
    PREDBOOK_COMPLETION_CONTEXT Context;
    ULONG index;
    ULONG mod;
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);
    ASSERT(DeviceExtension->WmiData.NumberOfBuffers);
    ASSERT(DeviceExtension->Buffer.SkipBuffer);

    //
    // Increment/Decrement PendingRead/PendingStream
    //

    Context = CONTAINING_RECORD(ListEntry, REDBOOK_COMPLETION_CONTEXT, ListEntry);

    index = Context->Index;
    mod = DeviceExtension->WmiData.NumberOfBuffers;

    state = GetCdromState(DeviceExtension);

    //
    // decrement the number reading/streaming if needed
    //

    if (Context->Reason == REDBOOK_CC_READ_COMPLETE) {

        if (!NT_SUCCESS(Context->Irp->IoStatus.Status)) {

            if (IoIsErrorUserInduced(Context->Irp->IoStatus.Status)) {

                DeviceExtension->CDRom.ReadErrors = REDBOOK_MAX_CONSECUTIVE_ERRORS;

            } else {

                DeviceExtension->CDRom.ReadErrors++;
            }

        } else {
            DeviceExtension->CDRom.ReadErrors = 0;
        }

        DeviceExtension->Thread.PendingRead--;
        Context->Reason = REDBOOK_CC_STREAM;

    } else if (Context->Reason == REDBOOK_CC_STREAM_COMPLETE) {

        if (!NT_SUCCESS(Context->Irp->IoStatus.Status)) {
            DeviceExtension->CDRom.StreamErrors++;
        } else {
            DeviceExtension->CDRom.StreamErrors = 0;
        }


        //
        // if stream succeeded OR we are _NOT_ stopping audio,
        // increment FinishedStreaming and save wmi stats
        //

        if (NT_SUCCESS(Context->Irp->IoStatus.Status) ||
            !TEST_FLAG(state, CD_MASK_TEMP)) {

            DeviceExtension->CDRom.FinishedStreaming +=
                DeviceExtension->WmiData.SectorsPerRead;

            AddWmiStats(DeviceExtension, Context);

        }

        DeviceExtension->Thread.PendingStream--;
        Context->Reason = REDBOOK_CC_READ;

    }

    if (DeviceExtension->CDRom.StreamErrors >= REDBOOK_MAX_CONSECUTIVE_ERRORS &&
        !TEST_FLAG(state, CD_MASK_TEMP)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "Digital => Too many stream errors, beginning STOP\n"));
        ASSERT(!TEST_FLAG(state, CD_STOPPED));
        ASSERT(!TEST_FLAG(state, CD_PAUSED));
        state = SetCdromState(DeviceExtension, state, CD_STOPPING);
    }

    if (DeviceExtension->CDRom.ReadErrors >= REDBOOK_MAX_CONSECUTIVE_ERRORS &&
        !TEST_FLAG(state, CD_MASK_TEMP)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "Digital => Too many read errors, beginning STOP\n"));

        state = SetCdromState(DeviceExtension, state, CD_STOPPING);
    }

    //
    // if stopping/pausing/etc, and no reads/streams are pending,
    // set the new state and return.
    // the while() loop in the thread will do the right thing
    // when there is no more outstanding io--it will call the ioctl
    // completion handler to do whatever post-processing is needed.
    //

    if (TEST_FLAG(state, CD_MASK_TEMP)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "Digital => Temp state %x, not continuing (%d, %d)\n",
                   state,
                   DeviceExtension->Thread.PendingRead,
                   DeviceExtension->Thread.PendingStream
                   ));

        if (DeviceExtension->Thread.PendingRead   == 0 &&
            DeviceExtension->Thread.PendingStream == 0) {

            //
            // Set NextToRead and NextToStream to FinishedStreaming
            //

            DeviceExtension->CDRom.NextToRead =
                DeviceExtension->CDRom.NextToStream =
                DeviceExtension->CDRom.FinishedStreaming;

            if (TEST_FLAG(state, CD_PAUSING)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                           "Digital => completing PAUSED\n"));
                state = SetCdromState(DeviceExtension, state, CD_PAUSED);
            } else if (TEST_FLAG(state, CD_STOPPING)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                           "Digital => completing STOPPED\n"));
                state = SetCdromState(DeviceExtension, state, CD_STOPPED);
            } else {
                ASSERT(!"Unknown state?");
            }

            if (DeviceExtension->Thread.IoctlCurrent) {
                KeSetEvent(DeviceExtension->Thread.Events[EVENT_COMPLETE],
                           IO_CD_ROM_INCREMENT, FALSE);
            }
        }
        return;
    }

    if (DeviceExtension->CDRom.NextToRead >= DeviceExtension->CDRom.EndPlay &&
        Context->Reason == REDBOOK_CC_READ) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "Digital => End play, ignoring READ\n"));
        if (DeviceExtension->Thread.PendingRead   == 0 &&
            DeviceExtension->Thread.PendingStream == 0) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                       "Digital => All IO done, setting STOPPED\n"));
            state = SetCdromState(DeviceExtension, state, CD_STOPPED);
        }
        return;
    }

    if (DeviceExtension->CDRom.NextToStream >= DeviceExtension->CDRom.EndPlay &&
        Context->Reason == REDBOOK_CC_STREAM) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "Digital => End play, ignoring STREAM\n"));
        if (DeviceExtension->Thread.PendingRead   == 0 &&
            DeviceExtension->Thread.PendingStream == 0) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                       "Digital => All IO done, setting STOPPED\n"));
            state = SetCdromState(DeviceExtension, state, CD_STOPPED);

        }
        return;
    }

    switch(Context->Reason) {

        case REDBOOK_CC_READ: {

            // mark this buffer as off the queue/usable
            ASSERT(DeviceExtension->Buffer.ReadOk_X[index] == 0);
            DeviceExtension->Buffer.ReadOk_X[index] = 1;

            if (index != DeviceExtension->Buffer.IndexToRead) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                           "Digital => Delaying read, index %x\n", index));
                return;
            }

            if (DeviceExtension->CDRom.NextToRead >
                DeviceExtension->CDRom.EndPlay) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                           "Digital => End of Play\n"));
                return;
            }

            for (index = Context->Index;
                 DeviceExtension->Buffer.ReadOk_X[index] != 0;
                 index = (index + 1) % mod) {

                // mark this buffer as in use BEFORE attempting to read
                DeviceExtension->Buffer.ReadOk_X[index] = 0;
                DeviceExtension->Thread.PendingRead++;

                RedBookReadRaw(DeviceExtension,
                               &DeviceExtension->Buffer.Contexts[index]);

                // increment where reading from AFTER attempting to read
                DeviceExtension->CDRom.NextToRead +=
                    DeviceExtension->WmiData.SectorsPerRead;

                // inc/mod the index AFTER attempting to read
                DeviceExtension->Buffer.IndexToRead++;
                DeviceExtension->Buffer.IndexToRead %= mod;
            }

            break;
        }

        case REDBOOK_CC_STREAM: {

            // mark this buffer as off the queue/usable
            ASSERT(DeviceExtension->Buffer.StreamOk_X[index] == 0);
            DeviceExtension->Buffer.StreamOk_X[index] = 1;

            if (index != DeviceExtension->Buffer.IndexToStream) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                           "Delaying stream of index %x\n", index));
                return;
            }

            for (index = Context->Index;
                 DeviceExtension->Buffer.StreamOk_X[index] != 0;
                 index = (index + 1) % mod) {

                // mark this buffer as in use BEFORE attempting to read
                DeviceExtension->Buffer.StreamOk_X[index] = 0;
                DeviceExtension->Thread.PendingStream++;

                RedBookStream(DeviceExtension,
                              &DeviceExtension->Buffer.Contexts[index]);

                // increment where reading from AFTER attempting to read
                DeviceExtension->CDRom.NextToStream +=
                    DeviceExtension->WmiData.SectorsPerRead;

                // inc/mod the index AFTER attempting to read
                DeviceExtension->Buffer.IndexToStream++;
                DeviceExtension->Buffer.IndexToStream %= mod;
            }

            break;
        }

        default: {
            ASSERT(!"Unhandled Context->Reason\n");
            break;
        }

    } // end switch (Context->Reason)
    return;
}


VOID
AddWmiStats(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_COMPLETION_CONTEXT Context
    )
{
    KIRQL oldIrql;
    ULONG timeIncrement;

    if (Context->TimeReadSent.QuadPart == 0) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "Not Saving WMI Stats for REASON:\n"));
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "(ReadError, StreamError, Paused?)\n"));
        return;
    }

    timeIncrement = KeQueryTimeIncrement(); // amount of time for each tick

    KeAcquireSpinLock(&DeviceExtension->WmiPerfLock, &oldIrql);

    DeviceExtension->WmiPerf.TimeReadDelay    +=
        (Context->TimeReadSent.QuadPart      -
         Context->TimeReadReady.QuadPart     ) *
        timeIncrement;
    DeviceExtension->WmiPerf.TimeReading      +=
        (Context->TimeStreamReady.QuadPart   -
         Context->TimeReadSent.QuadPart      ) *
        timeIncrement;
    DeviceExtension->WmiPerf.TimeStreamDelay  +=
        (Context->TimeStreamSent.QuadPart    -
         Context->TimeStreamReady.QuadPart   ) *
        timeIncrement;
    DeviceExtension->WmiPerf.TimeStreaming    +=
        (Context->TimeReadReady.QuadPart     -
         Context->TimeStreamSent.QuadPart    ) *
        timeIncrement;

    DeviceExtension->WmiPerf.DataProcessed    +=
        DeviceExtension->WmiData.SectorsPerRead * RAW_SECTOR_SIZE;

    KeReleaseSpinLock( &DeviceExtension->WmiPerfLock, oldIrql );
    return;
}
////////////////////////////////////////////////////////////////////////////////


VOID
RedBookCheckForAudioDeviceRemoval(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG state = GetCdromState(DeviceExtension);

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
               "STCheckForRemoval => Checking if audio device changed\n"));

    if (TEST_FLAG(state, CD_MASK_TEMP)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "STCheckForRemoval => delaying -- temp state\n"));
        return;
    }

    if (DeviceExtension->Stream.UpdateMixerPin == 0) {
        return;
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
               "STCheckForRemoval => Audio Device may have changed\n"));

    if (TEST_FLAG(state, CD_PLAYING)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "STCheckForRemoval => playing, so stopping\n"));
        state = SetCdromState(DeviceExtension, state, CD_STOPPING);
        return;
    }

    if (TEST_FLAG(state, CD_STOPPED)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "STCheckForRemoval => stopped, updating\n"));

    } else if (TEST_FLAG(state, CD_PAUSED)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "STCheckForRemoval => paused, updating\n"));
        
        //
        // ISSUE-2000/5/24-henrygab - may not need to stop
        //                            unless mixer becomes -1,
        //                            since we could then send
        //                            to the new audio device.
        //
        state = SetCdromState(DeviceExtension, state, CD_STOPPED);

    }

    ASSERT(TEST_FLAG(GetCdromState(DeviceExtension), CD_STOPPED));

    //
    // set the value to zero (iff the value was one)
    // check if the value was one, and if so, update the mixerpin
    //

    if (InterlockedCompareExchange(&DeviceExtension->Stream.UpdateMixerPin,
                                   0, 1) == 1) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "STCheckForRemoval => Updating MixerPin\n"));

        //
        // free any in-use play resources
        //

        RedBookDeallocatePlayResources(DeviceExtension);

        if (DeviceExtension->Stream.MixerPinId != -1) {
            UninitializeVirtualSource(DeviceExtension);
        }

        InitializeVirtualSource(DeviceExtension);

        if (DeviceExtension->Stream.MixerPinId == -1) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "STCheckForRemoval => Update of mixerpin "
                       "failed -- will retry later\n"));
            InterlockedExchange(&DeviceExtension->Stream.UpdateMixerPin, 1);
            return;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\database.c ===
/*
 *  DATABASE.C
 *
 *      RSM Service :  Database management
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\debug.c ===
/*
 *  DEBUG.C
 *
 *      RSM Service :  Debug code
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\debug.h ===
/*
 *  DEBUG.H
 *
 *      RSM Service : Debug code
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */





#if DEBUG
    #define ASSERT(fact) { if (!(fact)) MessageBox(NULL, (LPSTR)#fact, (LPSTR)"NTMSSVC assertion failed", MB_OK); }
    #define DBGERR(args_in_parens)     // BUGBUG FINISH
    #define DBGWARN(args_in_parens)     // BUGBUG FINISH
#else
    #define ASSERT(fact)
    #define DBGERR(args_in_parens)     
    #define DBGWARN(args_in_parens)     
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\redbook\wmi.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wmi.c
//
//--------------------------------------------------------------------------


#include "redbook.h"
#include "ntddredb.h"
#include "proto.h"

#include "wmi.tmh"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE,   RedBookThreadWmiHandler)
    #pragma alloc_text(PAGE,   RedBookWmiInit)
    #pragma alloc_text(PAGE,   RedBookWmiQueryDataBlock)
    #pragma alloc_text(PAGE,   RedBookWmiQueryRegInfo)
    #pragma alloc_text(PAGE,   RedBookWmiSetDataBlock)
    #pragma alloc_text(PAGE,   RedBookWmiSetDataItem)
    #pragma alloc_text(PAGE,   RedBookWmiSystemControl)
    #pragma alloc_text(PAGE,   RedBookWmiUninit)
#endif // ALLOC_PRAGMA


#define REDBOOK_STD_INDEX      0   // index into WMIGUIDREGINFO
#define REDBOOK_PERF_INDEX     1   // index into WMIGUIDREGINFO

WMIGUIDREGINFO RedBookWmiGuidList[] =
{
    // GUID,  # of data blocks,  flags
    { &MSRedbook_DriverInformationGuid, 1, 0 },  // RedBook driver info
    { &MSRedbook_PerformanceGuid, 1, 0 }  // some perf stuff also
};
/////////////////////////////////////////////////////////

NTSTATUS
RedBookWmiUninit(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PAGED_CODE();

    if (DeviceExtension->WmiLibInitialized) {
        status = IoWMIRegistrationControl(DeviceExtension->SelfDeviceObject,
                                          WMIREG_ACTION_DEREGISTER);
        ASSERT(NT_SUCCESS(status)); // can not fail?
        DeviceExtension->WmiLibInitialized = 0;
    }
    return status;
    
}


NTSTATUS
RedBookWmiInit(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    if (DeviceExtension->WmiLibInitialized) {
        return STATUS_SUCCESS;
    }

    DeviceExtension->WmiLibInfo.GuidCount = sizeof(RedBookWmiGuidList) /
                                            sizeof(WMIGUIDREGINFO);

    ASSERT(DeviceExtension->WmiLibInfo.GuidCount > 0);
    DeviceExtension->WmiLibInfo.GuidList           = RedBookWmiGuidList;
    DeviceExtension->WmiLibInfo.QueryWmiDataBlock  = RedBookWmiQueryDataBlock;
    DeviceExtension->WmiLibInfo.QueryWmiRegInfo    = RedBookWmiQueryRegInfo;
    DeviceExtension->WmiLibInfo.SetWmiDataBlock    = RedBookWmiSetDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataItem     = RedBookWmiSetDataItem;
    DeviceExtension->WmiLibInfo.ExecuteWmiMethod   = NULL;
    DeviceExtension->WmiLibInfo.WmiFunctionControl = NULL;

    status = IoWMIRegistrationControl(DeviceExtension->SelfDeviceObject,
                                      WMIREG_ACTION_REGISTER);

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                   "WmiInit !! Failed [%#010lx]\n", status));
    } else {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "WmiInit => Successfully registered\n"));
        DeviceExtension->WmiLibInitialized = 1;
    }
    
    return status;

}


NTSTATUS
RedBookWmiQueryDataBlock (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    )

/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call RedBookWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the instance within the GuidIndex to query

    InstanceCount is ???

    InstanceLengthArray is a pointer to an array of ULONG that returns
        the lengths of each instance of the data block.  If this is NULL
        then there was not enough space in the output buffer to fulfill
        the request so the irp should be completed with the buffer needed.

    OutputBufferSize has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block

Return Value:

    status

--*/

{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    ULONG size = 0;

    PAGED_CODE();

    //
    // Only one instance per GUID
    //

    ASSERT( InstanceIndex == 0 );
    ASSERT( InstanceCount == 1 );

    switch (GuidIndex) {
    case REDBOOK_STD_INDEX: {

        if (InstanceIndex != 0) {
            status = STATUS_WMI_INSTANCE_NOT_FOUND;
            break;
        }

        //
        // Reject the request if not enough space alloc'd
        //

        if (OutBufferSize < sizeof(REDBOOK_WMI_STD_DATA)) {
            size   = sizeof(REDBOOK_WMI_STD_DATA);
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // requests for wmi information can occur while
        // the system is playing audio.  just copy the info
        //

        RtlCopyMemory( Buffer,
                       &deviceExtension->WmiData,
                       sizeof(REDBOOK_WMI_STD_DATA)
                       );

        //
        // Set the size for each instance
        //

        InstanceLengthArray[InstanceIndex] = sizeof(REDBOOK_WMI_STD_DATA);
        size += sizeof(REDBOOK_WMI_STD_DATA);

        status = STATUS_SUCCESS;
        break;
    }
    case REDBOOK_PERF_INDEX: {

        if (InstanceIndex != 0) {
            status = STATUS_WMI_INSTANCE_NOT_FOUND;
            break;
        }

        //
        // reject the request if not enough space alloc'd
        //

        if (OutBufferSize < sizeof(REDBOOK_WMI_PERF_DATA)) {
            size = sizeof(REDBOOK_WMI_PERF_DATA);
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // Requests for wmi information can occur while
        // the system is playing audio. just copy the info
        //

        RedBookWmiCopyPerfInfo(deviceExtension, (PVOID)Buffer);

        //
        // set the size for each instance
        //

        InstanceLengthArray[InstanceIndex] = sizeof(REDBOOK_WMI_PERF_DATA);
        size += sizeof(REDBOOK_WMI_PERF_DATA);
        status = STATUS_SUCCESS;
        break;
    }

    default: {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "WmiQueryDataBlock !! Invalid GUID [%#010lx]\n",
                   GuidIndex));
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
               "WmiQueryDataBlock => internal status [%#010lx]\n",
               status));

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                size,
                                IO_CD_ROM_INCREMENT);

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "WmiQueryDataBlock => IoWMICompleteRequest failed [%#010lx]\n",
                   status));
    }
    return status;
}


NTSTATUS
RedBookWmiSetDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )

/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block.
    When the driver has finished filling the data block it must call
    IoWMICompleteRequest(???) to complete the irp.
    The driver can return STATUS_PENDING if the irp cannot be
    completed immediately.

Arguments:

    DeviceObject - the device whose data block is being queried

    Irp - Irp that makes this request

    GuidIndex - index into the list of guids provided
        when the device registered

    InstanceIndex - the index that denotes which index of the
        data block is being set

    BufferSize - the size of the data block passed

    Buffer - the new values for the data block

Return Value:

    status

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    ULONG size = 0;
    NTSTATUS status;

    PAGED_CODE();

    switch( GuidIndex ) {
    case REDBOOK_STD_INDEX: {

        REDBOOK_WMI_STD_DATA wmiData;
        ULONG state;

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "WmiSetDataBlock => Instance: [%#010lx]  BuffSize: [%#010lx]\n",
                   InstanceIndex, BufferSize));

        state = GetCdromState(deviceExtension);

        if (!TEST_FLAG(state, CD_STOPPED)) {
            status = STATUS_DEVICE_BUSY;
            break;
        }

        if (InstanceIndex != 0) {
            status = STATUS_WMI_INSTANCE_NOT_FOUND;
            break;
        }


        if ( BufferSize != sizeof(REDBOOK_WMI_STD_DATA) ) {
            status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        wmiData = *(PREDBOOK_WMI_STD_DATA)Buffer;

        //
        // verify the buffer contains valid information
        //

        if ( wmiData.NumberOfBuffers > REDBOOK_WMI_BUFFERS_MAX ||
             wmiData.NumberOfBuffers < REDBOOK_WMI_BUFFERS_MIN ) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                       "WmiSetDataBlock !! Invalid number of bufers [%#010lx]\n",
                       wmiData.NumberOfBuffers));
            status = STATUS_WMI_SET_FAILURE;
            break;
        }
        if ( wmiData.SectorsPerRead > REDBOOK_WMI_SECTORS_MAX   ||
             wmiData.SectorsPerRead < REDBOOK_WMI_SECTORS_MIN   ||
             wmiData.SectorsPerRead > wmiData.MaximumSectorsPerRead ) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                       "WmiSetDataBlock !! Invalid number of sectors per read [%#010lx]\n",
                       wmiData.SectorsPerRead));
            status = STATUS_WMI_SET_FAILURE;
            break;
        }
        if ( wmiData.PlayEnabled != TRUE &&
             wmiData.PlayEnabled != FALSE
             ) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                       "WmiSetDataBlock !! Invalid setting for play enabled [%#010lx]\n",
                       wmiData.PlayEnabled));
            status = STATUS_WMI_SET_FAILURE;
            break;
        }

        deviceExtension->WmiData.NumberOfBuffers = wmiData.NumberOfBuffers;
        deviceExtension->WmiData.SectorsPerRead  = wmiData.SectorsPerRead;
        deviceExtension->WmiData.PlayEnabled     = wmiData.PlayEnabled;
        RedBookRegistryWrite(deviceExtension);

        status = STATUS_SUCCESS;
        break;
    }
    case REDBOOK_PERF_INDEX: {
        status = STATUS_WMI_READ_ONLY;
        break;
    }
    default: {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "WmiSetDataBlock !! Invalid GuidIndex [%#010lx]\n",
                   GuidIndex));
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }
    }

    IoReleaseRemoveLock( &deviceExtension->RemoveLock, Irp );
    status = WmiCompleteRequest( DeviceObject,
                                 Irp,
                                 status,
                                 sizeof(REDBOOK_WMI_STD_DATA),
                                 IO_CD_ROM_INCREMENT);
    return status;

}

NTSTATUS
RedBookWmiSetDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block.
    ??? When the driver has finished filling the data block it
        must call ClassWmiCompleteRequest(???) to complete the irp.
    The driver can return STATUS_PENDING if the irp cannot be
    completed immediately.

Arguments:

    DeviceObject - the device whose data block is being queried

    Irp - Irp that makes this request

    GuidIndex - index into the list of guids provided
        when the device registered

    DataItemId - Id of the data item being set

    BufferSize - the size of the data block passed

    Buffer - the new values for the data block

Return Value:

    status

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    ULONG size = 0;
    NTSTATUS status;

    PAGED_CODE();

    switch( GuidIndex ) {
    case REDBOOK_STD_INDEX: {

        ULONG state;

        if (InstanceIndex != 0) {
            status = STATUS_WMI_INSTANCE_NOT_FOUND;
            break;
        }

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                     "WmiSetDataItem => Id: [%#010lx]  Size: [%#010lx]\n",
                     DataItemId, BufferSize));

        state = GetCdromState(deviceExtension);

        if (!TEST_FLAG(state, CD_STOPPED)) {
            status = STATUS_DEVICE_BUSY;
            break;
        }

        switch (DataItemId) {

            //
            // These are the only four settable items
            //

            case REDBOOK_WMI_NUMBER_OF_BUFFERS_ID:

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                           "WmiSetDataItem => Setting NumberOfBuffers\n"));

                if (BufferSize != REDBOOK_WMI_NUMBER_OF_BUFFERS_SIZE) {
                    status = STATUS_WMI_SET_FAILURE;
                    break;
                }

                deviceExtension->WmiData.NumberOfBuffers = *(PULONG32)Buffer;
                RedBookRegistryWrite(deviceExtension);
                status = STATUS_SUCCESS;
                break;

            case REDBOOK_WMI_SECTORS_PER_READ_ID:

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                           "WmiSetDataItem => Setting SectorsPerRead\n"));
                if (BufferSize != REDBOOK_WMI_SECTORS_PER_READ_SIZE) {
                    status = STATUS_WMI_SET_FAILURE;
                    break;
                }

                if (*(PULONG32)Buffer >
                    deviceExtension->WmiData.MaximumSectorsPerRead) {
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                               "WmiSetDataBlock => Interface Card / "
                               "CDROM combo does not support this size\n"));
                    status = STATUS_DEVICE_BUSY;
                    break;
                }

                deviceExtension->WmiData.SectorsPerRead = *(PULONG32)Buffer;
                RedBookRegistryWrite(deviceExtension);
                status = STATUS_SUCCESS;
                break;

            case REDBOOK_WMI_PLAY_ENABLED_ID:

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                           "WmiSetDataItem => Setting PlayEnabled\n"));
                if ( BufferSize != REDBOOK_WMI_PLAY_ENABLED_SIZE ) {
                    status = STATUS_WMI_SET_FAILURE;
                    break;
                }

                deviceExtension->WmiData.PlayEnabled = *(PBOOLEAN)Buffer;
                status = STATUS_SUCCESS;
                break;

                //
                // The remaining are invalid sets, as they are Read-Only values
                //
            case REDBOOK_WMI_SECTORS_PER_READ_MASK_ID:
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                           "WmiSetDataItem => Cannot set SectorsPerReadMask\n"));
                status = STATUS_WMI_READ_ONLY;
                break;

            case REDBOOK_WMI_CDDA_SUPPORTED_ID:
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                           "WmiSetDataItem => Cannot set Supported\n"));
                status = STATUS_WMI_READ_ONLY;
                break;

            case REDBOOK_WMI_CDDA_ACCURATE_ID:
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                           "WmiSetDataItem => Cannot set KnownGood\n"));
                status = STATUS_WMI_READ_ONLY;
                break;

            default:
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                           "WmiSetDataItem => Cannot set unknown "
                           "id %#010lx\n", DataItemId));
                status = STATUS_WMI_ITEMID_NOT_FOUND;
                break;
        }

        //
        // the status is now correctly set.
        // what should size be?
        //
        size = 0;
        break;
    }

    case REDBOOK_PERF_INDEX: {

        if (InstanceIndex != 0) {
            status = STATUS_WMI_INSTANCE_NOT_FOUND;
            break;
        }

        status = STATUS_WMI_READ_ONLY;
        size = 0;
        break;

    }
    default: {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "WmiSetDataItem !! Invalid GuidIndex: %#010lx\n",
                   GuidIndex));
        status = STATUS_WMI_GUID_NOT_FOUND;
        size = 0;
        break;
    }
    }

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    status = WmiCompleteRequest( DeviceObject,
                                 Irp,
                                 status,
                                 size,
                                 IO_CD_ROM_INCREMENT
                                 );
    return status;

}


NTSTATUS
RedBookWmiSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    System Control Irp
    Presume it is a WMI Irp and call into the WMI system to
    handle this IRP for us.

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PREDBOOK_THREAD_WMI_DATA wmiData;
    NTSTATUS status;

    PAGED_CODE();

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if ( !NT_SUCCESS(status) ) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_CD_ROM_INCREMENT );
        return status;
    }

    wmiData = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(REDBOOK_THREAD_WMI_DATA),
                                    TAG_T_WMI);
    if (wmiData == NULL) {
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NO_MEMORY;
        IoCompleteRequest( Irp, IO_CD_ROM_INCREMENT );
        return STATUS_NO_MEMORY;
    }

    wmiData->Irp = Irp;

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
               "DispatchWmi => Queueing Irp %p\n", wmiData->Irp));

    //
    // queue them, allow thread to handle the request.
    //

    IoMarkIrpPending(Irp);

    ExInterlockedInsertTailList(&deviceExtension->Thread.WmiList,
                                &wmiData->ListEntry,
                                &deviceExtension->Thread.WmiLock);
    KeSetEvent(deviceExtension->Thread.Events[EVENT_WMI],
               IO_NO_INCREMENT, FALSE);

    return STATUS_PENDING;
}

VOID
RedBookThreadWmiHandler(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PLIST_ENTRY ListEntry
    )
{
    SYSCTL_IRP_DISPOSITION disposition;
    PREDBOOK_THREAD_WMI_DATA wmiData;
    PIRP irp;
    NTSTATUS status;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    wmiData = CONTAINING_RECORD(ListEntry, REDBOOK_THREAD_WMI_DATA, ListEntry);

    irp = wmiData->Irp;
    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
               "HandleWmi => Processing Irp %p\n", irp));

    ExFreePool(wmiData);
    wmiData = NULL;

    //
    // just process the irp now.
    //

    status = WmiSystemControl( &DeviceExtension->WmiLibInfo,
                               DeviceExtension->SelfDeviceObject,
                               irp,
                               &disposition);

    switch ( disposition ) {
        case IrpProcessed: {
            //
            // this irp has been processed and may be completed or pending
            //
            break;
        }
        case IrpNotCompleted: {
            //
            // this irp has not been completed, but has been fully processed.
            // we will complete it now.
            //
            IoReleaseRemoveLock(&DeviceExtension->RemoveLock, irp);
            IoCompleteRequest(irp, IO_CD_ROM_INCREMENT);
            break;
        }
        case IrpNotWmi:
        case IrpForward: {
            //
            // this irp is either not a wmi irp or is a wmi irp targetted
            // at a device lower in the stack.
            //
            IoReleaseRemoveLock(&DeviceExtension->RemoveLock, irp);
            IoSkipCurrentIrpStackLocation(irp);
            IoCallDriver(DeviceExtension->TargetDeviceObject, irp);
            break;
        }
        default: {
            //
            // we should never really get here, but if we do, just forward...
            //
            ASSERT(!"[redbook] WmiSystemControl (unhandled case)");
            IoReleaseRemoveLock(&DeviceExtension->RemoveLock, irp);
            IoSkipCurrentIrpStackLocation(irp);
            IoCallDriver(DeviceExtension->TargetDeviceObject, irp);
            break;
        }
    }

    return;
}



NTSTATUS
RedBookWmiQueryRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine is a callback into the driver to retrieve the
    list of guids or data blocks that the driver wants to register
    with WMI.  This routine may not pend or block.

Arguments:

    DeviceObject - the device whose data block is being queried

    RegFlags - Returns with a set of flags that describe the guids
        registered for this device. If the device wants to enable
        and disable collection callbacks before receiving queries
        for the registered guids then it should return the
        WMIREG_FLAG_EXPENSIVE flag. Also the returned flags may
        specify WMIREG_FLAG_INSTANCE_PDO in which case the instance
        name is determined from the PDO associated with the device
        object. Note that the PDO must have an associated devnode.
        If WMIREG_FLAG_INSTANCE_PDO is not set then Name must return
        a unique name for the device.

    InstanceName - Returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned RegFlags.
        The caller will call ExFreePool with the buffer returned.

    RegistryPath - Returns with the registry path of the driver

    MofResourceName - Returns with the name of the MOF resource attached
        to the binary file.  If the driver does not have a mof resource
        attached then this can be returned as NULL.

    PhysicalDeviceObject - Returns with the device object for the PDO
        associated with this device if the WMI_REG_FLAG_INSTANCE_PDO
        flag is returned in RegFlags

Return Value:

    status

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PREDBOOK_DRIVER_EXTENSION driverExtension;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(InstanceName);

    driverExtension = IoGetDriverObjectExtension(deviceExtension->DriverObject,
                                                 REDBOOK_DRIVER_EXTENSION_ID);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
               "WmiQueryRegInfo => driverExtension is [%p]\n",
               driverExtension));
    ASSERT(driverExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
               "WmiQueryRegInfo => Registry Path = %ws\n",
               driverExtension->RegistryPath.Buffer));

    *RegFlags     = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &(driverExtension->RegistryPath);
    *PhysicalDeviceObject = deviceExtension->TargetPdo;

    return STATUS_SUCCESS;
}


VOID
RedBookWmiCopyPerfInfo(
    IN  PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    OUT PREDBOOK_WMI_PERF_DATA Out
    )
{
    KIRQL irql;

    //
    // cannot be paged due to spinlock, which allows copy of
    // the LARGE_INTEGERS without problems.
    //

    KeAcquireSpinLock( &DeviceExtension->WmiPerfLock, &irql );
    RtlCopyMemory( Out,
                   &DeviceExtension->WmiPerf,
                   sizeof(REDBOOK_WMI_PERF_DATA)
                   );
    KeReleaseSpinLock( &DeviceExtension->WmiPerfLock, irql );

    //
    // now add InterlockedXxx() calls to safely get a couple of the items.
    //

    Out->StreamPausedCount =
        InterlockedCompareExchange(&DeviceExtension->WmiPerf.StreamPausedCount,0,0);

    //
    // finished.
    //
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\globals.c ===
/*
 *  GLOBALS.C
 *
 *      Global data for RSM Service 
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


CRITICAL_SECTION g_globalServiceLock;
LIST_ENTRY g_allLibrariesList;
LIST_ENTRY g_allSessionsList;
HANDLE g_terminateServiceEvent = NULL;
HINSTANCE g_hInstance = NULL;



BOOLEAN RSMServiceGlobalInit()
{
    BOOLEAN result = FALSE;

    InitializeCriticalSection(&g_globalServiceLock);

    InitializeListHead(&g_allLibrariesList);
    InitializeListHead(&g_allSessionsList);

    g_terminateServiceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (g_terminateServiceEvent){
        result = TRUE;
    }

    ASSERT(result);
    return result;
}


VOID RSMServiceGlobalShutdown()
{
    /*
     *  This may be called on a failed startup,
     *  so check each handle before freeing.
     */

    if (g_terminateServiceEvent){
        CloseHandle(g_terminateServiceEvent);
        g_terminateServiceEvent = NULL;
    }

    DeleteCriticalSection(&g_globalServiceLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\drive.c ===
/*
 *  DRIVES.C
 *
 *      RSM Service :  Drives
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


DRIVE *NewDrive(LIBRARY *lib, PWCHAR path)
{
    DRIVE *drive;

    drive = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(DRIVE));
    if (drive){
        drive->lib = lib;
        WStrNCpy(drive->path, path, MAX_PATH);

        drive->objHeader.objType = OBJECTTYPE_DRIVE;
        drive->objHeader.refCount = 1;   
    }

    ASSERT(drive);
    return drive;
}


VOID FreeDrive(DRIVE *drive)
{
    GlobalFree(drive);
}


DRIVE *FindDrive(LPNTMS_GUID driveId)
{
    DRIVE *drive = NULL;

    if (driveId){
        OBJECT_HEADER *objHdr;
        
        objHdr = FindObjectInGuidHash(driveId);
        if (objHdr){
            if (objHdr->objType == OBJECTTYPE_DRIVE){
                drive = (DRIVE *)objHdr;
            }
            else {
                DerefObject(objHdr);
            }
        }
    }
    
    return drive;
}


HRESULT DeleteDrive(DRIVE *drive)
{
    HRESULT result;

    // BUGBUG FINISH
    ASSERT(0);
    result = ERROR_CALL_NOT_IMPLEMENTED;

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\guidhash.c ===
/*
 *  GUIDHASH.C
 *
 *      RSM Service :  RSM Object Hash (by GUID)
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


/*
 *  Our HASH is indexed by a function on an object's GUID.
 *  There is a linked list at each hash table entry to resolve collisions.
 */
#define HASH_SIZE   256
#define HASH_FUNC(lpGuid) (UINT)(UCHAR)(*(PUCHAR)(lpGuid) + *((PUCHAR)(lpGuid)+sizeof(NTMS_GUID)-1))
LIST_ENTRY guidHashTable[HASH_SIZE];


VOID InitGuidHash()
{
     int i;

     for (i = 0; i < HASH_SIZE; i++){
        InitializeListHead(&guidHashTable[i]);
     }
}


VOID InsertObjectInGuidHash(OBJECT_HEADER *obj)
{
    UINT index = HASH_FUNC(&obj->guid);

    /*
     *  Unfortunately, have to use a global spinlock for the hash table.
     */
    EnterCriticalSection(&g_globalServiceLock);
    ASSERT(IsEmptyList(&obj->hashListEntry));
    ASSERT(!obj->isDeleted);
    InsertTailList(&guidHashTable[index], &obj->hashListEntry);
    LeaveCriticalSection(&g_globalServiceLock);
}


VOID RemoveObjectFromGuidHash(OBJECT_HEADER *obj)
{

    /*
     *  Unfortunately, have to use a global spinlock for the hash table.
     */
    EnterCriticalSection(&g_globalServiceLock);
    ASSERT(!IsEmptyList(&obj->hashListEntry));
    ASSERT(!IsEmptyList(&guidHashTable[HASH_FUNC(obj->guid)]));
    RemoveEntryList(&obj->hashListEntry);
    InitializeListHead(&obj->hashListEntry);
    LeaveCriticalSection(&g_globalServiceLock);
}


OBJECT_HEADER *FindObjectInGuidHash(NTMS_GUID *guid)
{
    UINT index = HASH_FUNC(guid);
    OBJECT_HEADER *foundObj = NULL;
    LIST_ENTRY *listEntry;

    /*
     *  Unfortunately, have to use a global spinlock for the hash table.
     */
    EnterCriticalSection(&g_globalServiceLock);
    listEntry = &guidHashTable[index];
    while ((listEntry = listEntry->Flink) != &guidHashTable[index]){
        OBJECT_HEADER *thisObj = CONTAINING_RECORD(listEntry, OBJECT_HEADER, hashListEntry);
        if (RtlEqualMemory(&thisObj->guid, guid, sizeof(NTMS_GUID))){
            if (!foundObj->isDeleted){
                foundObj = thisObj;
                RefObject(thisObj);
            }
            break;
        }
    }
    LeaveCriticalSection(&g_globalServiceLock);

    return foundObj;
}


/*
 *  RefObject
 *
 *      Add a reference to the object.
 *      An object's refCount is incremented when:
 *          1.  a pointer to it is returned from a guid hash lookup
 *                  or
 *          2.  its handle or GUID is returned to an RSM client app
 *
 */
VOID RefObject(PVOID objectPtr)
{
    OBJECT_HEADER *objHdr = (OBJECT_HEADER *)objectPtr;
    InterlockedIncrement(&objHdr->refCount);
}


VOID DerefObject(PVOID objectPtr)
{
    OBJECT_HEADER *objHdr = (OBJECT_HEADER *)objectPtr;
    LONG newRefCount;

    newRefCount = InterlockedDecrement(&objHdr->refCount);
    ASSERT(newRefCount >= 0);
    if (newRefCount == 0){
        ASSERT(objHdr->isDeleted);
        
        // BUGBUG FINISH
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\libmgr.c ===
/*
 *  LIBMGR.C
 *
 *      RSM Service :  Library Manager 
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


VOID StartLibraryManager()
{
    // LmInitConfigNewDevices();    


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\lock.c ===
/*
 *  LOCK.C
 *
 *      RSM Service :  Locking functions for Physical Media and Media Pools
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"

BOOLEAN LockPhysicalMediaWithPool_Iter(PHYSICAL_MEDIA *physMedia, ULONG numTries);
BOOLEAN LockPhysicalMediaWithLibrary_Iter(PHYSICAL_MEDIA *physMedia, ULONG numTries);

/*
 *  LockPhysicalMediaWithPool
 *
 *      Warning:  ugly function
 *
 *      We frequently need to lock a piece of media as well as
 *      its media pool.  
 *      To avoid deadlock, we have to acquire the locks top-down
 *      (starting with the pool).  But that's difficult since we're starting
 *      with the physical media pointer.
 *      This function enters the media pool and physical media
 *      critical sections in the right order.  
 *      Subsequently, the caller can safely call subroutines that re-enter 
 *      these critical sections in any order.
 */
BOOLEAN LockPhysicalMediaWithPool(PHYSICAL_MEDIA *physMedia)
{
    return LockPhysicalMediaWithPool_Iter(physMedia, 10);
}
BOOLEAN LockPhysicalMediaWithPool_Iter(PHYSICAL_MEDIA *physMedia, ULONG numTries){
    MEDIA_POOL *mediaPool;
    BOOLEAN success = FALSE;

    /*
     *  1.  Get an (unreliable) snapshot of the heirarchy without grabbing
     *      more than one lock at a time.  If the media is in a pool,
     *      reference it temporarily so that it doesn't go away while
     *      we drop the media lock (which can then lose its ref on the pool).
     */
    EnterCriticalSection(&physMedia->lock);
    mediaPool = physMedia->owningMediaPool;
    if (mediaPool){
        RefObject(mediaPool);
    }
    LeaveCriticalSection(&physMedia->lock);

    /*
     *  2.  Now grab the locks for the pool and media in the right order.
     *      Then check the hierarchy again.  
     *      If its the same, we're done; otherwise, try again.
     *      
     */
    if (mediaPool){
        /*
         *  We referenced the media pool, so its guaranteed to still exist.
         *  But the media may have been moved out of it while we
         *  let go of the lock.  If the hierarchy is still the same, then
         *  we've got both the media and pool locked in the right order.
         *  Otherwise, we have to back off and try again.
         */
        EnterCriticalSection(&mediaPool->lock);
        EnterCriticalSection(&physMedia->lock);
        if (physMedia->owningMediaPool == mediaPool){
            success = TRUE;
        }
        else {
            LeaveCriticalSection(&physMedia->lock);
            LeaveCriticalSection(&mediaPool->lock);
        }
        
        DerefObject(mediaPool);
    }
    else {
        /*
         *  If after locking the media again it is still not in any pool,
         *  we are set to go.
         */
        EnterCriticalSection(&physMedia->lock);
        if (physMedia->owningMediaPool){
            LeaveCriticalSection(&physMedia->lock);
        }
        else {
            success = TRUE;
        }
    }

    if (!success && (numTries > 0)){
        /*
         *  Try again by calling ourselves RECURSIVELY.
         */
        Sleep(1);
        success = LockPhysicalMediaWithPool_Iter(physMedia, numTries-1);                
    }

    return success;
}


/*
 *  UnlockPhysicalMediaWithPool
 *
 *      Undo LockPhysicalMediaWithPool.
 */
VOID UnlockPhysicalMediaWithPool(PHYSICAL_MEDIA *physMedia)
{
    if (physMedia->owningMediaPool){
        LeaveCriticalSection(&physMedia->owningMediaPool->lock);
    }
    LeaveCriticalSection(&physMedia->lock);
}


/*
 *  LockPhysicalMediaWithLibrary
 *
 *      Warning:  ugly function
 *
 *      Like LockPhysicalMediaWithPool, but locks the  media pool
 *  and the library.  Acquires locks in the right
 *  order (top to down) despite the fact that we're starting 
 *  from the bottom with the media.
 *      Note that we don't have to actually grab locks for all
 *  the media sub-pools in the hierarchy.  The media pool configuration
 *  does not change while the library lock is held.
 */
BOOLEAN LockPhysicalMediaWithLibrary(PHYSICAL_MEDIA *physMedia)
{
    return LockPhysicalMediaWithLibrary_Iter(physMedia, 10);
}
BOOLEAN LockPhysicalMediaWithLibrary_Iter(PHYSICAL_MEDIA *physMedia, ULONG numTries)
{
    LIBRARY *lib = NULL;
    MEDIA_POOL *mediaPool = NULL;
    BOOLEAN success = FALSE;
    
    success = LockPhysicalMediaWithPool(physMedia);
    if (success){
        /*
         *  Reference the library so it doesn't go away while
         *  we drop the locks.
         */
        mediaPool = physMedia->owningMediaPool;
        if (mediaPool){
            RefObject(mediaPool);
            lib = mediaPool->owningLibrary;
            if (lib){
                RefObject(lib);
            }
        }
        UnlockPhysicalMediaWithPool(physMedia);

        /*
         *  Now grab the locks in the right order and check if 
         *  the configuration hasn't changed while we dropped the lock.
         */
        if (lib){
            EnterCriticalSection(&lib->lock);
            success = LockPhysicalMediaWithPool(physMedia);
            if (success){
                if (physMedia->owningMediaPool &&
                    (physMedia->owningMediaPool->owningLibrary == lib)){

                }
                else {
                    UnlockPhysicalMediaWithPool(physMedia);
                    success = FALSE;
                }
            }

            if (!success){
                LeaveCriticalSection(&lib->lock);
            }
            DerefObject(lib);
        }
        else {
            /*
             *  Media is not in any pool or lib ?  
             *  Just make sure nothing's changed while we dropped the lock.
             */           
            success = LockPhysicalMediaWithPool(physMedia);
            if (mediaPool){
                if ((physMedia->owningMediaPool == mediaPool) &&
                    (mediaPool->owningLibrary == lib)){
                }
                else {
                    UnlockPhysicalMediaWithPool(physMedia);
                    success = FALSE;
                }
            }
        }
        
    }

    if (!success && (numTries > 0)){
        success = LockPhysicalMediaWithLibrary_Iter(physMedia, numTries-1);
    }
    return success;
}


VOID UnlockPhysicalMediaWithLibrary(PHYSICAL_MEDIA *physMedia)
{
    if (physMedia->owningMediaPool && 
        physMedia->owningMediaPool->owningLibrary){

        LeaveCriticalSection(&physMedia->owningMediaPool->owningLibrary->lock);
    }
    UnlockPhysicalMediaWithPool(physMedia);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\internal.h ===
/*
 *  INTERNAL.H
 *
 *      Internal header for RSM Service
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


typedef struct _SESSION SESSION;
typedef struct _WORKITEM WORKITEM;
typedef struct _WORKGROUP WORKGROUP;

typedef struct _LIBRARY LIBRARY;
typedef struct _TRANSPORT TRANSPORT;
typedef struct _PICKER PICKER;
typedef struct _SLOT SLOT;
typedef struct _DRIVE DRIVE;

typedef struct _MEDIA_POOL MEDIA_POOL;
typedef struct _PHYSICAL_MEDIA PHYSICAL_MEDIA;
typedef struct _MEDIA_PARTITION MEDIA_PARTITION;

typedef struct _OPERATOR_REQUEST OPERATOR_REQUEST;
typedef struct _MEDIA_TYPE_OBJECT MEDIA_TYPE_OBJECT;
    
typedef struct _OBJECT_HEADER OBJECT_HEADER;


/*
 *  RSM Object Types
 *
 *      The media hierarchy is as follows:
 *      ------------------------------
 *
 *      Library
 *          Media Pool
 *              Media Sub-Pool - a subset (child pool) of a media pool
 *                  ...
 *
 *                  Physical Media 
 *                      - a connected set of partitions that have to move together
 *                        e.g. a cartridge or both sides of a disk
 *
 *                      Media Partition
 *                          - e.g. a side of a disk or catridge tape
 *
 *
 *      Other library elements:
 *      --------------------
 *
 *          Drives - for reading/writing data on media
 *
 *          Slots - for passively storing media
 *
 *          Changers - for moving media between and amongst slots and drives. 
 *                     A changer consists of a moving transport with 
 *                     one or more pickers.
 *                      
 *      
 *          Logical media ID - a persistent GUID which identifies a media partition.
 *
 *          Media type object - represents a recognized media type
 *
 */
enum objectType {
                    OBJECTTYPE_NONE = 0,

                    OBJECTTYPE_LIBRARY,
                    OBJECTTYPE_MEDIAPOOL,
                    OBJECTTYPE_PHYSICALMEDIA,
                    OBJECTTYPE_MEDIAPARTITION,

                    OBJECTTYPE_DRIVE,
                    OBJECTTYPE_SLOT,
                    OBJECTTYPE_TRANSPORT,
                    OBJECTTYPE_PICKER,

                    OBJECTTYPE_MEDIATYPEOBJECT,
                    
                    // OBJECTTYPE_OPERATORREQUEST, // BUGBUG - keep in session queue
};


/*
 *  This is a common header for all RSM objects that have GUIDs.
 *  It is used to sort guid-identified objects in our hash table.
 */
struct _OBJECT_HEADER {
                    LIST_ENTRY hashListEntry;
                    enum objectType objType;
                    NTMS_GUID guid;
                    
                    ULONG refCount;
                    BOOL isDeleted;
};


enum libraryTypes {
                    LIBTYPE_NONE = 0,

                    LIBTYPE_UNKNOWN,
                    
                    LIBTYPE_STANDALONE,
                    LIBTYPE_AUTOMATED,
};

enum libraryStates {

                    LIBSTATE_NONE = 0,

                    LIBSTATE_INITIALIZING,
                    LIBSTATE_ONLINE,
                    LIBSTATE_OFFLINE,

                    LIBSTATE_ERROR,
};


struct _LIBRARY {
                    OBJECT_HEADER objHeader;

                    enum libraryStates state;

                    enum libraryTypes type;
                    
                    LIST_ENTRY allLibrariesListEntry;   // entry in g_allLibrariesList

                    ULONG numMediaPools;
                    LIST_ENTRY mediaPoolsList;

                    ULONG numDrives;
                    DRIVE *drives;

                    ULONG numSlots;
                    SLOT *slots;

                    /*
                     *  One (and only one) slot may be designated as a cleaner
                     *  slot.  That slot may receive a cleaner cartridge (via InjectNtmsCleaner).
                     *  A cleaner cartridge has a limited number of cleans that it is good for.
                     */
                    #define NO_SLOT_INDEX (ULONG)(-1)
                    ULONG cleanerSlotIndex; // index of cleaner slot or -1.
                    ULONG numCleansLeftInCartridge;
                    
                    ULONG numTransports;
                    TRANSPORT *transports;

                    ULONG numTotalWorkItems;
                    LIST_ENTRY freeWorkItemsList;
                    LIST_ENTRY pendingWorkItemsList;
                    LIST_ENTRY completeWorkItemsList;

                    HANDLE somethingToDoEvent;

                    /*
                     *  There is one thread per library.  This is its handle.
                     */
                    HANDLE hThread;

                    CRITICAL_SECTION lock;
};


enum mediaPoolTypes {

                    MEDIAPOOLTYPE_NONE = 0, 

                    /*
                     *  These are the 3 standard pool types.
                     */
                    MEDIAPOOLTYPE_FREE,
                    MEDIAPOOLTYPE_IMPORT,
                    MEDIAPOOLTYPE_UNRECOGNIZED,
                    
                    MEDIAPOOLTYPE_OTHER,
                    
};


struct _MEDIA_POOL {
                    OBJECT_HEADER objHeader;

                    /*
                     *  Entry in library's mediaPoolsList or
                     *  parent pool's childPoolsList.
                     */
                    LIST_ENTRY mediaPoolsListEntry;  

                    LIBRARY *owningLibrary;

                    /*
                     *  A media pool has a (default?) media type.
                     */
                    MEDIA_TYPE_OBJECT *mediaTypeObj;

                    /*
                     *  Media pools can be divided heirarchically into sub-pools.
                     *  If a pool is top-level, its parentPool pointer is NULL.
                     */
                    MEDIA_POOL *parentPool;
                    ULONG numChildPools;
                    LIST_ENTRY childPoolsList;

                    ULONG numPhysMedia;
                    LIST_ENTRY physMediaList;

                    HANDLE newMediaEvent;

                    WCHAR name[NTMS_OBJECTNAME_LENGTH];
                    
                    CRITICAL_SECTION lock;
};




// BUGBUG - should this be in physical media or mediaTypeObj ?
enum physicalMediaTypes {
                    PHYSICALMEDIATYPE_NONE = 0,

                    PHYSICALMEDIATYPE_SINGLEPARTITION, // e.g. 1 disk,tape
                    PHYSICALMEDIATYPE_CARTRIDGE,
};

enum physicalMediaStates {
                    PHYSICALMEDIASTATE_NONE = 0,

                    PHYSICALMEDIASTATE_INITIALIZING,
                    PHYSICALMEDIASTATE_AVAILABLE,   // i.e. in a slot
                    PHYSICALMEDIASTATE_INUSE,       // i.e. in a drive
                    PHYSICALMEDIASTATE_RESERVED,
};

struct _PHYSICAL_MEDIA {
                    OBJECT_HEADER objHeader;

                    LIST_ENTRY physMediaListEntry;  // entry in pool partition's physMediaList
                    
                    enum physicalMediaStates state;


                    /*
                     *  Pointer to application-defined media type object.
                     */
                    MEDIA_TYPE_OBJECT *mediaTypeObj;
                    
                    MEDIA_POOL *owningMediaPool;

                    SLOT *currentSlot;
                    DRIVE *currentDrive;

                    ULONG numPartitions;
                    MEDIA_PARTITION *partitions;

                    /*
                     *  The owning session of a physicalMedia also holds
                     *  the exclusive right to allocate partitions on it.
                     */
                    SESSION *owningSession;
                    ULONG numPartitionsOwnedBySession;
                    
                    HANDLE mediaFreeEvent;
                    
                    CRITICAL_SECTION lock;
};


enum mediaPartitionTypes {
                    MEDIAPARTITIONTYPE_NONE = 0,

                    /*
                     *  Major types
                     */
                    MEDIAPARTITIONTYPE_TAPE,
                    MEDIAPARTITIONTYPE_DISK,

                    /*
                     *  Subtypes
                     */
                    // BUGBUG FINISH
};


enum mediaPartitionStates {

                    MEDIAPARTITIONSTATE_NONE = 0,

                    MEDIAPARTITIONSTATE_AVAILABLE,
                    MEDIAPARTITIONSTATE_ALLOCATED,
                    MEDIAPARTITIONSTATE_MOUNTED,
                    MEDIAPARTITIONSTATE_INUSE,
                    MEDIAPARTITIONSTATE_DECOMMISSIONED,
};


struct _MEDIA_PARTITION {
                    OBJECT_HEADER objHeader;

                    enum mediaPartitionTypes type;
                    enum mediaPartitionTypes subType;

                    enum mediaPartitionStates state;

                    /*
                     *  When a media partition is 'complete', 
                     *  it is no longer writeable.
                     */
                    BOOLEAN isComplete;

                    /*
                     *  Can the owning physical medium be moved
                     *  into a new media pool ?
                     */
                    BOOLEAN allowImport;    

                    
                    PHYSICAL_MEDIA *owningPhysicalMedia;

                    /*
                     *  The logical media id is the persistent identifier
                     *  of a media partition that apps use to find it.
                     */
                    GUID logicalMediaGuid;

                    SESSION *owningSession;
};





enum driveStates {
                    DRIVESTATE_NONE = 0,

                    DRIVESTATE_INITIALIZING,
                    DRIVESTATE_AVAILABLE,
                    DRIVESTATE_INUSE,
                    DRIVESTATE_RESERVED,
};


struct _DRIVE {
                    OBJECT_HEADER objHeader;

                    enum driveStates state;        
                    ULONG driveIndex;     // index into library's drives array

                    PHYSICAL_MEDIA *insertedMedia;

                    WCHAR path[MAX_PATH+1];

                    LIBRARY *lib;
};


enum slotStates {

                    SLOTSTATE_NONE = 0,

                    SLOTSTATE_EMPTY,
                    SLOTSTATE_OCCUPIED,
};

struct _SLOT {
                    OBJECT_HEADER objHeader;

                    enum slotStates state;
                    UINT slotIndex;         // index into library's slots array

                    PHYSICAL_MEDIA *insertedMedia;

                    /*
                     *  Is this the unique slot designated to hold the
                     *  library's cleaner cartridge ?
                     */
                    BOOLEAN isCleanerSlot;
                    
                    GUID slotId;

                    LIBRARY *lib;
};


enum transportStates {

                    TRANSPORTSTATE_NONE = 0,

                    TRANSPORTSTATE_AVAILABLE,
                    TRANSPORTSTATE_INUSE,

};

struct _TRANSPORT {
                    OBJECT_HEADER objHeader;
    
                    enum transportStates state;
                    ULONG transportIndex;     // index into library's transports array

                    ULONG numPickers;
                    PICKER *pickers;

                    LIBRARY *lib;
};

struct _PICKER {
                    OBJECT_HEADER objHeader;

                    TRANSPORT *owningTransport;
};


struct _SESSION {
                    #define SESSION_SIG 'SmsR'
                    ULONG sig;

                    LIST_ENTRY allSessionsListEntry;   // entry in g_allSessionsList

                    LIST_ENTRY operatorRequestList; 

                   
                    CRITICAL_SECTION lock;
                    
                    WCHAR serverName[NTMS_COMPUTERNAME_LENGTH];
                    WCHAR applicationName[NTMS_APPLICATIONNAME_LENGTH];
                    WCHAR clientName[NTMS_COMPUTERNAME_LENGTH];
                    WCHAR userName[NTMS_USERNAME_LENGTH];
};


struct _MEDIA_TYPE_OBJECT {
                    OBJECT_HEADER objHeader;

                    LIBRARY *lib;
                    
                    /*
                     *  The number of physical media pointing to this type
                     *  as their media type.
                     */
                    ULONG numPhysMediaReferences;

                    // BUGBUG FINISH - media type characteristics

                    CRITICAL_SECTION lock;
};

enum workItemStates {
                    WORKITEMSTATE_NONE,

                    /*
                     *  WorkItem is in one of the library queues:
                     *  free, pending, or complete.
                     */
                    WORKITEMSTATE_FREE,
                    WORKITEMSTATE_PENDING,
                    WORKITEMSTATE_COMPLETE,
            
                    /*
                     *  WorkItem is not in any library queue.
                     *  It is in transit or being staged in a workGroup.
                     */
                    WORKITEMSTATE_STAGING,
};

struct _WORKITEM {    
                    enum workItemStates state;

                    LIST_ENTRY libListEntry;   // entry in one of a libraries workItem lists
                    LIST_ENTRY workGroupListEntry;  // entry in work group workItemList
                    
                    LIBRARY *owningLib;

                    /*
                     *  The current work group with which this 
                     *  work item is associated.
                     */
                    WORKGROUP *workGroup;
                    
                    // BUGBUG - ok to have a handle for each event ?
                    HANDLE workItemCompleteEvent;

                    /*
                     *  Fields describing the workItem's current operation.
                     */
                    struct { 

                        ULONG opcode;
                        ULONG options;

                        HRESULT resultStatus;

                        DRIVE *drive;
                        PHYSICAL_MEDIA *physMedia;
                        MEDIA_PARTITION *mediaPartition;

                        ULONG lParam;
                        NTMS_GUID guidArg;  // in/out guid used by some ops
                        PVOID buf;
                        ULONG bufLen;
                        
                        SYSTEMTIME timeQueued;
                        SYSTEMTIME timeCompleted;

                        /*
                         *  Request identifier, used to cancel a pending workItem.
                         */
                        NTMS_GUID requestGuid;

                        //
                        // BUGBUG - unscrubbed fields from NtmsDbWorkItem 
                        //          clean this up.
                        //
                        // NtmsDbGuid m_PartitionId; 
                        // NtmsDbGuid m_AssocWorkItem;
                        // short m_protected;
                        // unsigned long m_Priority;

                    } currentOp;
};


/*
 *  A WORKGROUP is a collection of WORKITEMs, 
 *  not necessarily all on the same library.
 */
struct _WORKGROUP {

                LIST_ENTRY  workItemsList;

                ULONG numTotalWorkItems;
                ULONG numPendingWorkItems;

                HANDLE allWorkItemsCompleteEvent;

                HRESULT resultStatus;
                
                CRITICAL_SECTION lock;
};


struct _OPERATOR_REQUEST {

                        LIST_ENTRY sessionOpReqsListEntry;    // entry in session's operatorRequestList

                        SESSION *invokingSession;

                        ULONG numWaitingThreads;    // num threads waiting for completion

                        // BUGBUG - I don't think we need an op request thread
                        HANDLE hThread; // thread spawned for op request

                        enum NtmsOpreqCommand opRequestCommand;
                        enum NtmsOpreqState state;
                        NTMS_GUID arg1Guid;
                        NTMS_GUID arg2Guid;

                        WCHAR appMessage[NTMS_MESSAGE_LENGTH];
                        WCHAR rsmMessage[NTMS_MESSAGE_LENGTH];
                        // NOTIFYICONDATA notifyData; // BUGBUG - use this in RSM Monitor app ?

                        NTMS_GUID opReqGuid;


                        SYSTEMTIME timeSubmitted;
                        HANDLE completedEvent;
};


/*
 *  The number of free workItems with which we initialize a library.
 */
#define MIN_LIBRARY_WORKITEMS   0

/*
 *  The maximum total number of workItems that we allow in a library pool.
 *  We will allocate new workItems as needed up to this number.
 */
#define MAX_LIBRARY_WORKITEMS   10000       // BUGBUG ?



/*
 *  List macros -- not defined in winnt.h for some reason.
 */
#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))
#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))
#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }


#define MIN(a, b)   ((a) < (b) ? (a) : (b))
#define MAX(a, b)   ((a) > (b) ? (a) : (b))

/*
 *  Internal function prototypes
 */
BOOLEAN RSMServiceGlobalInit();
VOID RSMServiceGlobalShutdown();
DWORD RSMServiceHandler(IN DWORD dwOpcode, IN DWORD dwEventType, IN PVOID pEventData, IN PVOID pData);
BOOL InitializeRSMService();
VOID ShutdownRSMService();
VOID RSMServiceLoop();
VOID StartLibraryManager();
LIBRARY *NewRSMLibrary(ULONG numDrives, ULONG numSlots, ULONG numTransports);
VOID FreeRSMLibrary(LIBRARY *lib);
LIBRARY *FindLibrary(LPNTMS_GUID libId);
SLOT *FindLibrarySlot(LIBRARY *lib, LPNTMS_GUID slotId);
BOOL ValidateSessionHandle(HANDLE hSession);
BOOL ValidateWStr(LPCWSTR str);
BOOL ValidateAStr(LPCSTR s);
BOOL ValidateBuffer(PVOID buf, ULONG len);
WORKITEM *NewWorkItem(LIBRARY *lib);
VOID FreeWorkItem(WORKITEM *workItem);
VOID EnqueueFreeWorkItem(LIBRARY *lib, WORKITEM *workItem);
WORKITEM *DequeueFreeWorkItem(LIBRARY *lib, BOOL allocOrYieldIfNeeded);
VOID EnqueuePendingWorkItem(LIBRARY *lib, WORKITEM *workItem);
WORKITEM *DequeuePendingWorkItem(LIBRARY *lib, WORKITEM *specificWorkItem);
WORKITEM *DequeuePendingWorkItemByGuid(LIBRARY *lib, LPNTMS_GUID lpRequestId);
VOID EnqueueCompleteWorkItem(LIBRARY *lib, WORKITEM *workItem);
WORKITEM *DequeueCompleteWorkItem(LIBRARY *lib, WORKITEM *specificWorkItem);
BOOL StartLibrary(LIBRARY *lib);
VOID HaltLibrary(LIBRARY *lib);
DWORD __stdcall LibraryThread(void *context);
VOID Library_DoWork(LIBRARY *lib);
BOOL ServiceOneWorkItem(LIBRARY *lib, WORKITEM *workItem);
OPERATOR_REQUEST *NewOperatorRequest(DWORD dwRequest, LPCWSTR lpMessage, LPNTMS_GUID lpArg1Id, LPNTMS_GUID lpArg2Id);
VOID FreeOperatorRequest(OPERATOR_REQUEST *opReq);
BOOL EnqueueOperatorRequest(SESSION *thisSession, OPERATOR_REQUEST *opReq);
OPERATOR_REQUEST *DequeueOperatorRequest(SESSION *thisSession, OPERATOR_REQUEST *specificOpReq, LPNTMS_GUID specificOpReqGuid);
OPERATOR_REQUEST *FindOperatorRequest(SESSION *thisSession, LPNTMS_GUID opReqGuid);
HRESULT CompleteOperatorRequest(SESSION *thisSession, LPNTMS_GUID lpRequestId, enum NtmsOpreqState completeState);
DWORD __stdcall OperatorRequestThread(void *context);
SESSION *NewSession(LPCWSTR lpServer, LPCWSTR lpApplication, LPCWSTR lpClientName, LPCWSTR lpUserName);
VOID FreeSession(SESSION *thisSession);
ULONG WStrNCpy(WCHAR *dest, const WCHAR *src, ULONG maxWChars);
ULONG AsciiToWChar(WCHAR *dest, const char *src, ULONG maxChars);
ULONG WCharToAscii(char *dest, WCHAR *src, ULONG maxChars);
BOOL WStringsEqualN(PWCHAR s, PWCHAR p, BOOL caseSensitive, ULONG maxLen);
VOID ConvertObjectInfoAToWChar(LPNTMS_OBJECTINFORMATIONW wObjInfo, LPNTMS_OBJECTINFORMATIONA aObjInfo);
VOID InitGuidHash();
VOID InsertObjectInGuidHash(OBJECT_HEADER *obj);
VOID RemoveObjectFromGuidHash(OBJECT_HEADER *obj);
OBJECT_HEADER *FindObjectInGuidHash(NTMS_GUID *guid);
MEDIA_POOL *NewMediaPool(LPCWSTR name, LPNTMS_GUID mediaType, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
MEDIA_POOL *FindMediaPool(LPNTMS_GUID mediaPoolId);
MEDIA_POOL *FindMediaPoolByName(PWSTR poolName);
PHYSICAL_MEDIA *FindPhysicalMedia(LPNTMS_GUID physMediaId);
VOID RefObject(PVOID objectPtr);
VOID DerefObject(PVOID objectPtr);
PHYSICAL_MEDIA *NewPhysicalMedia();
HRESULT AllocatePhysicalMediaExclusive(SESSION *thisSession, PHYSICAL_MEDIA *physMedia, LPNTMS_GUID lpPartitionId, DWORD dwTimeoutMsec);
HRESULT AllocateNextPartitionOnExclusiveMedia(SESSION *thisSession, PHYSICAL_MEDIA *physMedia, MEDIA_PARTITION **ppNextPartition);
HRESULT AllocateMediaFromPool(SESSION *thisSession, MEDIA_POOL *mediaPool, DWORD dwTimeoutMsec, PHYSICAL_MEDIA **ppPhysMedia, BOOL opReqIfNeeded);
MEDIA_PARTITION *FindMediaPartition(LPNTMS_GUID lpLogicalMediaId);
HRESULT ReleaseMediaPartition(SESSION *thisSession, MEDIA_PARTITION *thisMediaPartition);
MEDIA_POOL *FindMediaPoolByName(PWSTR poolName);
MEDIA_POOL *FindMediaPoolByNameInLibrary(LIBRARY *lib, PWSTR poolName);
HRESULT SetMediaPartitionState(MEDIA_PARTITION *mediaPart, enum mediaPartitionStates newState);
HRESULT SetMediaPartitionComplete(MEDIA_PARTITION *mediaPart);
HRESULT DeletePhysicalMedia(PHYSICAL_MEDIA *physMedia);
VOID InsertPhysicalMediaInPool(MEDIA_POOL *mediaPool, PHYSICAL_MEDIA *physMedia);
VOID RemovePhysicalMediaFromPool(PHYSICAL_MEDIA *physMedia);
HRESULT MovePhysicalMediaToPool(MEDIA_POOL *destMediaPool, PHYSICAL_MEDIA *physMedia, BOOLEAN setMediaTypeToPoolType);
BOOLEAN LockPhysicalMediaWithPool(PHYSICAL_MEDIA *physMedia);
VOID UnlockPhysicalMediaWithPool(PHYSICAL_MEDIA *physMedia);
BOOLEAN LockPhysicalMediaWithLibrary(PHYSICAL_MEDIA *physMedia);
VOID UnlockPhysicalMediaWithLibrary(PHYSICAL_MEDIA *physMedia);
HRESULT DeleteMediaPool(MEDIA_POOL *mediaPool);
MEDIA_TYPE_OBJECT *NewMediaTypeObject();
VOID DestroyMediaTypeObject(MEDIA_TYPE_OBJECT *mediaTypeObj);
MEDIA_TYPE_OBJECT *FindMediaTypeObject(LPNTMS_GUID lpMediaTypeId);
HRESULT DeleteMediaTypeObject(MEDIA_TYPE_OBJECT *mediaTypeObj);
VOID SetMediaType(PHYSICAL_MEDIA *physMedia, MEDIA_TYPE_OBJECT *mediaTypeObj);
WORKGROUP *NewWorkGroup();
VOID FreeWorkGroup(WORKGROUP *workGroup);
VOID FlushWorkGroup(WORKGROUP *workGroup);
VOID FlushWorkItem(WORKITEM *workItem);
HRESULT BuildMountWorkGroup(WORKGROUP *workGroup, LPNTMS_GUID lpMediaOrPartitionIds, LPNTMS_GUID lpDriveIds, DWORD dwCount, DWORD dwOptions, DWORD dwPriority);
VOID BuildSingleMountWorkItem(WORKITEM *workItem, DRIVE *drive OPTIONAL, OBJECT_HEADER *mediaOrPartObj, ULONG dwOptions, int dwPriority);
HRESULT BuildDismountWorkGroup(WORKGROUP *workGroup, LPNTMS_GUID lpMediaOrPartitionIds, DWORD dwCount, DWORD dwOptions);
VOID BuildSingleDismountWorkItem(WORKITEM *workItem, OBJECT_HEADER *mediaOrPartObj, DWORD dwOptions);
HRESULT ScheduleWorkGroup(WORKGROUP *workGroup);
DRIVE *NewDrive(LIBRARY *lib, PWCHAR path);
VOID FreeDrive(DRIVE *drive);
DRIVE *FindDrive(LPNTMS_GUID driveId);
VOID BuildEjectWorkItem(WORKITEM *workItem, PHYSICAL_MEDIA *physMedia, LPNTMS_GUID lpEjectOperation, ULONG dwAction);
VOID BuildInjectWorkItem(WORKITEM *workItem, LPNTMS_GUID lpInjectOperation, ULONG dwAction);
HRESULT StopCleanerInjection(LIBRARY *lib, LPNTMS_GUID lpInjectOperation);
HRESULT StopCleanerEjection(LIBRARY *lib, LPNTMS_GUID lpEjectOperation);
HRESULT DeleteLibrary(LIBRARY *lib);
HRESULT DeleteDrive(DRIVE *drive);


/*
 *  Externs for internal global data.
 */
extern CRITICAL_SECTION g_globalServiceLock;
extern LIST_ENTRY g_allLibrariesList;
extern LIST_ENTRY g_allSessionsList;
extern HANDLE g_terminateServiceEvent;
extern HINSTANCE g_hInstance;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\mediaprt.c ===
/*
 *  MEDIAPRT.C
 *
 *      RSM Service :  Media Partitions (i.e. "sides")
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"



MEDIA_PARTITION *FindMediaPartition(LPNTMS_GUID lpLogicalMediaId)
{
    MEDIA_PARTITION *foundMediaPartition = NULL;
    
    if (lpLogicalMediaId){
        OBJECT_HEADER *objHdr;
        
        objHdr = FindObjectInGuidHash(lpLogicalMediaId);
        if (objHdr){
            if (objHdr->objType == OBJECTTYPE_MEDIAPARTITION){
                foundMediaPartition = (MEDIA_PARTITION *)objHdr;
            }
            else {
                DerefObject(objHdr);
            }
        }

    }

    return foundMediaPartition;
}


HRESULT ReleaseMediaPartition(SESSION *thisSession, MEDIA_PARTITION *thisMediaPartition)
{
    PHYSICAL_MEDIA *physMedia = thisMediaPartition->owningPhysicalMedia;
    HRESULT result;
    
    EnterCriticalSection(&physMedia->lock);

    if (thisMediaPartition->owningSession == thisSession){
        thisMediaPartition->owningSession = NULL;
        if (physMedia->owningSession == thisSession){
            ASSERT(physMedia->numPartitionsOwnedBySession > 0);
            physMedia->numPartitionsOwnedBySession--;
            if (physMedia->numPartitionsOwnedBySession == 0){
                physMedia->owningSession = NULL;

                // BUGBUG FINISH - move to scratch pool ?
            }
        }
        else {
            ASSERT(!physMedia->owningSession);
        }
        result = ERROR_SUCCESS;
    }
    else {
        ASSERT(thisMediaPartition->owningSession == thisSession);
        result = ERROR_INVALID_MEDIA;
    }
    
    LeaveCriticalSection(&physMedia->lock);

    return result;
}


HRESULT SetMediaPartitionState( MEDIA_PARTITION *mediaPart,
                                    enum mediaPartitionStates newState)
{
    PHYSICAL_MEDIA *physMedia = mediaPart->owningPhysicalMedia;
    HRESULT result;
    
    EnterCriticalSection(&physMedia->lock);

    switch (newState){
        
        case MEDIAPARTITIONSTATE_AVAILABLE:
            // BUGBUG FINISH
            result = ERROR_CALL_NOT_IMPLEMENTED;
            break;

        case MEDIAPARTITIONSTATE_ALLOCATED:
            // BUGBUG FINISH
            result = ERROR_CALL_NOT_IMPLEMENTED;
            break;
            
        case MEDIAPARTITIONSTATE_MOUNTED:
            // BUGBUG FINISH
            result = ERROR_CALL_NOT_IMPLEMENTED;
            break;
            
        case MEDIAPARTITIONSTATE_INUSE:
            // BUGBUG FINISH
            result = ERROR_CALL_NOT_IMPLEMENTED;
            break;
            
        case MEDIAPARTITIONSTATE_DECOMMISSIONED:
            if (mediaPart->state == MEDIAPARTITIONSTATE_AVAILABLE){
                mediaPart->state = MEDIAPARTITIONSTATE_DECOMMISSIONED;
                result = ERROR_SUCCESS;
            }
            else {
                result = ERROR_INVALID_STATE;
            }
            break;
            
        default:
            DBGERR(("illegal state (%xh) in SetMediaPartitionState", newState));
            result = ERROR_INVALID_STATE;
            break;
    }

    LeaveCriticalSection(&physMedia->lock);

    return result;
}


HRESULT SetMediaPartitionComplete(MEDIA_PARTITION *mediaPart)
{
    PHYSICAL_MEDIA *physMedia = mediaPart->owningPhysicalMedia;
    HRESULT result;
    
    EnterCriticalSection(&physMedia->lock);

    switch (mediaPart->state){
        
        case MEDIAPARTITIONSTATE_ALLOCATED:
            if (mediaPart->isComplete){
                DBGWARN(("SetMediaPartitionComplete: media partition is already complete."));
            }
            else {
                mediaPart->isComplete = TRUE;
            }
            result = ERROR_SUCCESS;
            break;
            
        case MEDIAPARTITIONSTATE_AVAILABLE:
        case MEDIAPARTITIONSTATE_MOUNTED:
        case MEDIAPARTITIONSTATE_INUSE:
        case MEDIAPARTITIONSTATE_DECOMMISSIONED:
            result = ERROR_INVALID_STATE;
            break;
             
        default:
            DBGERR(("illegal state (%xh) in SetMediaPartitionComplete", mediaPart->state));
            result = ERROR_INVALID_STATE;
            break;
    }

    LeaveCriticalSection(&physMedia->lock);

    return result;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\library.c ===
/*
 *  LIBRARY.C
 *
 *      RSM Service :  Library management
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


LIBRARY *NewRSMLibrary(ULONG numDrives, ULONG numSlots, ULONG numTransports)
{
    LIBRARY *lib;

    lib = (LIBRARY *)GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(LIBRARY));
    if (lib){
        BOOL success = FALSE;

        lib->state = LIBSTATE_INITIALIZING;

        InitializeCriticalSection(&lib->lock);

        InitializeListHead(&lib->allLibrariesListEntry);
        InitializeListHead(&lib->mediaPoolsList);
        InitializeListHead(&lib->freeWorkItemsList);
        InitializeListHead(&lib->pendingWorkItemsList);
        InitializeListHead(&lib->completeWorkItemsList);
        
        /*
         *  Enqueue the new library
         */
        EnterCriticalSection(&g_globalServiceLock);
        InsertTailList(&g_allLibrariesList, &lib->allLibrariesListEntry);
        LeaveCriticalSection(&g_globalServiceLock);


        lib->somethingToDoEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        /*
         *  Allocate arrays for drives, slots, and transports.
         *  If the library has zero of any of these,
         *  go ahead and allocate a zero-length array for consistency.
         */
        lib->drives = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, numDrives*sizeof(DRIVE));
        lib->slots = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, numSlots*sizeof(SLOT));
        lib->transports = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, numTransports*sizeof(TRANSPORT));
        
        if (lib->somethingToDoEvent && 
            lib->drives && lib->slots && lib->transports){

            lib->numDrives = numDrives;
            lib->numSlots = numSlots;
            lib->numTransports = numTransports;

            lib->objHeader.objType = OBJECTTYPE_LIBRARY;
            lib->objHeader.refCount = 1;
            
            success = TRUE;
        }
        else {
            ASSERT(0);
        }

        if (!success){
            FreeRSMLibrary(lib);
            lib = NULL;
        }
    }
    else {
        ASSERT(lib);
    }

    return lib;
}


VOID FreeRSMLibrary(LIBRARY *lib)
{
    WORKITEM *workItem;
    LIST_ENTRY *listEntry;

    ASSERT(lib->state == LIBSTATE_HALTED);
 
    /*
     *  Dequeue library
     */
    EnterCriticalSection(&g_globalServiceLock);
    ASSERT(!IsEmptyList(&lib->allLibrariesListEntry));
    ASSERT(!IsEmptyList(&g_allLibrariesList));
    RemoveEntryList(&lib->allLibrariesListEntry);
    InitializeListHead(&lib->allLibrariesListEntry);
    LeaveCriticalSection(&g_globalServiceLock);

    /*
     *  Free all the workItems
     */
    while (workItem = DequeueCompleteWorkItem(lib, NULL)){
        DBGERR(("there shouldn't be any completed workItems left"));
        FreeWorkItem(workItem);
    }
    while (workItem = DequeuePendingWorkItem(lib, NULL)){
        DBGERR(("there shouldn't be any pending workItems left"));
        FreeWorkItem(workItem);
    }
    while (workItem = DequeueFreeWorkItem(lib, FALSE)){
        FreeWorkItem(workItem);
    }
    ASSERT(lib->numTotalWorkItems == 0);    

    /*
     *  Free other internal resources.  
     *  Note that this is also called from a failed NewRSMLibrary() call,
     *  so check each resource before freeing.
     */
    if (lib->somethingToDoEvent) CloseHandle(lib->somethingToDoEvent);
    if (lib->drives) GlobalFree(lib->drives);
    if (lib->slots) GlobalFree(lib->slots);
    if (lib->transports) GlobalFree(lib->transports);

    DeleteCriticalSection(&lib->lock);

    GlobalFree(lib);
}


LIBRARY *FindLibrary(LPNTMS_GUID libId)
{
    LIBRARY *lib = NULL;

    if (libId){
        OBJECT_HEADER *objHdr;
        
        objHdr = FindObjectInGuidHash(libId);
        if (objHdr){
            if (objHdr->objType == OBJECTTYPE_LIBRARY){
                lib = (LIBRARY *)objHdr;
            }
            else {
                DerefObject(objHdr);
            }
        }
    }
    
    return lib;
}


BOOL StartLibrary(LIBRARY *lib)
{
    DWORD threadId;
    BOOL result;

    lib->hThread = CreateThread(NULL, 0, LibraryThread, lib, 0, &threadId);
    if (lib->hThread){

        result = TRUE;
    }
    else {
        ASSERT(lib->hThread);
        lib->state = LIBSTATE_ERROR;
        result = FALSE;
    }

    ASSERT(result);
    return result;
}


/*
 *  HaltLibrary
 *
 *      Take a library offline.
 */
VOID HaltLibrary(LIBRARY *lib)
{
    
    // BUGBUG - deal with multiple threads trying to halt at the same time
    //          (e.g. can't use PulseEvent)

    EnterCriticalSection(&lib->lock);
    lib->state = LIBSTATE_OFFLINE;
    PulseEvent(lib->somethingToDoEvent);
    LeaveCriticalSection(&lib->lock);

    /*
     *  The library thread may be doing some work.
     *  Wait here until it has exited its loop.
     *  (a thread handle gets signalled when the thread terminates).
     */
    WaitForSingleObject(lib->hThread, INFINITE);
    CloseHandle(lib->hThread);
}


DWORD __stdcall LibraryThread(void *context)
{
    LIBRARY *lib = (LIBRARY *)context;
    enum libraryStates libState;

    ASSERT(lib);

    EnterCriticalSection(&lib->lock);
    ASSERT((lib->state == LIBSTATE_INITIALIZING) || (lib->state == LIBSTATE_OFFLINE));
    libState = lib->state = LIBSTATE_ONLINE;
    LeaveCriticalSection(&lib->lock);

    while (libState == LIBSTATE_ONLINE){

        WaitForSingleObject(lib->somethingToDoEvent, INFINITE);

        Library_DoWork(lib);

        EnterCriticalSection(&lib->lock);
        libState = lib->state;
        LeaveCriticalSection(&lib->lock);
    }

    ASSERT(libState == LIBSTATE_OFFLINE);

    return NO_ERROR;
}


VOID Library_DoWork(LIBRARY *lib)
{
    WORKITEM *workItem;

    while (workItem = DequeuePendingWorkItem(lib, NULL)){
        BOOL complete;

        // BUGBUG FINISH - service the work item

        /*
         *  Service the work item.  
         *  The workItem is 'complete' if we are done with it,
         *  regardless of whether or not there was an error.
         */
        complete = ServiceOneWorkItem(lib, workItem);
        if (complete){
            /*
             *  All done.  
             *  Put the workItem in the complete queue and signal
             *  the originating thread.
             */
            EnqueueCompleteWorkItem(lib, workItem);
        }
    }
}


HRESULT DeleteLibrary(LIBRARY *lib)
{
    HRESULT result;
    
    EnterCriticalSection(&lib->lock);

    /*
     *  Take the library offline.
     */
    lib->state = LIBSTATE_OFFLINE;   

    // BUGBUG FINISH - move any media to the offline library

    // BUGBUG FINISH - delete all media pools, etc.

    // BUGBUG FINISH - wait for all workItems, opReqs, etc to complete

    ASSERT(0);
    result = ERROR_CALL_NOT_IMPLEMENTED; // BUGBUG ?
    
    /*
     *  Mark the library as deleted.  
     *  This will cause it not to get any new references.
     */
    ASSERT(!lib->objHeader.isDeleted);
    lib->objHeader.isDeleted = TRUE;
    
    /*
     *  This dereference will cause the library's refcount to eventually go
     *  to zero, upon which it will get deleted.  We can still use our pointer
     *  though because the caller added a refcount to get his lib pointer.
     */
    DerefObject(lib);
    
    LeaveCriticalSection(&lib->lock);


    return result;
}


SLOT *FindLibrarySlot(LIBRARY *lib, LPNTMS_GUID slotId)
{
    SLOT *slot = NULL;

    if (slotId){
        ULONG i;

        EnterCriticalSection(&lib->lock);
        
        for (i = 0; i < lib->numSlots; i++){
            SLOT *thisSlot = &lib->slots[i];
            if (RtlEqualMemory(&thisSlot->objHeader.guid, slotId, sizeof(NTMS_GUID))){
                /*
                 *  Found the slot.  Reference it since we're returning a pointer to it.
                 */
                ASSERT(thisSlot->slotIndex == i);
                slot = thisSlot;
                RefObject(slot);
                break;
            }
        }

        LeaveCriticalSection(&lib->lock);
    }
    
    return slot;
}


HRESULT StopCleanerInjection(LIBRARY *lib, LPNTMS_GUID lpInjectOperation)
{
    HRESULT result;

    // BUGBUG FINISH
    ASSERT(0);
    result = ERROR_CALL_NOT_IMPLEMENTED;
    
    return result;
}


HRESULT StopCleanerEjection(LIBRARY *lib, LPNTMS_GUID lpEjectOperation)
{
    HRESULT result;

    // BUGBUG FINISH
    ASSERT(0);
    result = ERROR_CALL_NOT_IMPLEMENTED;
    
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\media.c ===
/*
 *  MEDIA.C
 *
 *      RSM Service :  Physical Media
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


PHYSICAL_MEDIA *NewPhysicalMedia()
{
    PHYSICAL_MEDIA *physMedia;

    physMedia = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(PHYSICAL_MEDIA));
    if (physMedia){
        physMedia->mediaFreeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (physMedia->mediaFreeEvent){
            InitializeCriticalSection(&physMedia->lock);
            InitializeListHead(&physMedia->physMediaListEntry);

            physMedia->objHeader.objType = OBJECTTYPE_PHYSICALMEDIA;
            physMedia->objHeader.refCount = 1;
            
            // BUGBUG FINISH
        }
        else {
            GlobalFree(physMedia);
            physMedia = NULL;
        }
    }

    ASSERT(physMedia);
    return physMedia;
}


VOID DestroyPhysicalMedia(PHYSICAL_MEDIA *physMedia)
{
        // BUGBUG FINISH

    CloseHandle(physMedia->mediaFreeEvent);    
    DeleteCriticalSection(&physMedia->lock);

    GlobalFree(physMedia);
}


PHYSICAL_MEDIA *FindPhysicalMedia(LPNTMS_GUID physMediaId)
{
    PHYSICAL_MEDIA *foundPhysMedia = NULL;

    if (physMediaId){
        OBJECT_HEADER *objHdr;
        
        objHdr = FindObjectInGuidHash(physMediaId);
        if (objHdr){
            if (objHdr->objType == OBJECTTYPE_PHYSICALMEDIA){
                foundPhysMedia = (PHYSICAL_MEDIA *)objHdr;
            }
            else {
                DerefObject(objHdr);
            }
        }
    }
    
    return foundPhysMedia;
}


/*
 *  AllocatePhysicalMediaExclusive
 *
 *      Allocate a partition on the specified physicalMedia with an exclusive
 *      hold on the other partitions.
 */
HRESULT AllocatePhysicalMediaExclusive(SESSION *thisSession, 
                                            PHYSICAL_MEDIA *physMedia, 
                                            LPNTMS_GUID lpPartitionId, 
                                            DWORD dwTimeoutMsec)
{
    DWORD startTime = GetTickCount();
    HRESULT result;

    ASSERT(lpPartitionId);
    
    while (TRUE){
        BOOL gotMedia;
        MEDIA_PARTITION *reservedMediaPartition = NULL;
        ULONG i;
        
        EnterCriticalSection(&physMedia->lock);

        /*
         *  Check that the media is not held.
         */
        if (physMedia->owningSession){
            ASSERT(physMedia->owningSession != thisSession);
            gotMedia = FALSE;
        }
        else {
            /*
             *  Check that none of the partitions are held.
             */
            gotMedia = TRUE;
            for (i = 0; i < physMedia->numPartitions; i++){
                MEDIA_PARTITION *thisPartition = &physMedia->partitions[i];
                if (thisPartition->owningSession){
                    gotMedia = FALSE;
                    break;
                }
                else if (RtlEqualMemory(&thisPartition->objHeader.guid, lpPartitionId, sizeof(NTMS_GUID))){
                    ASSERT(!reservedMediaPartition);
                    reservedMediaPartition = thisPartition;
                }
            }
             
        }

        if (gotMedia){
            if (reservedMediaPartition){
                physMedia->owningSession = thisSession;
                reservedMediaPartition->owningSession = thisSession;
                physMedia->numPartitionsOwnedBySession = 1;
                RefObject(physMedia);
                RefObject(reservedMediaPartition);
                result = ERROR_SUCCESS;
            }
            else {
                result = ERROR_INVALID_MEDIA;
            }
        }
        else {
            result = ERROR_MEDIA_UNAVAILABLE;
        }
        
        LeaveCriticalSection(&physMedia->lock);

        /*
         *  If appropriate, wait for the media to become free.
         */
        if ((result == ERROR_MEDIA_UNAVAILABLE) && (dwTimeoutMsec > 0)){
            /*
             *  Wait for the media to become available.
             */
            DWORD waitRes = WaitForSingleObject(physMedia->mediaFreeEvent, dwTimeoutMsec); 
            if (waitRes == WAIT_TIMEOUT){
                result = ERROR_TIMEOUT;
                break;
            }
            else {
                /*
                 *  Loop around and try again.
                 */
                DWORD timeNow = GetTickCount();
                ASSERT(timeNow >= startTime);
                dwTimeoutMsec -= MIN(dwTimeoutMsec, timeNow-startTime);
            }
        }
        else {
            break;
        }
    }

    // BUGBUG FINISH - need to move media to different media pool ?
    
    return result;
}


/*
 *  AllocateNextPartitionOnExclusiveMedia
 *
 *      The calling session should already hold exclusive access to the media.
 *      This call simply reserves another partition for the caller.
 */
HRESULT AllocateNextPartitionOnExclusiveMedia(SESSION *thisSession, 
                                                    PHYSICAL_MEDIA *physMedia,
                                                    MEDIA_PARTITION **ppNextPartition)
{
    MEDIA_PARTITION *reservedMediaPartition = NULL;
    HRESULT result;

    ASSERT(physMedia->numPartitionsOwnedBySession >= 1);
    
    EnterCriticalSection(&physMedia->lock);

    if (physMedia->owningSession == thisSession){
        ULONG i;

        /*
         *  Just reserve the next available partition
         */
        result = ERROR_MEDIA_UNAVAILABLE;
        for (i = 0; i < physMedia->numPartitions; i++){
            MEDIA_PARTITION *thisPartition = &physMedia->partitions[i];
            if (thisPartition->owningSession){
                ASSERT(thisPartition->owningSession == thisSession);
            }
            else {
                reservedMediaPartition = thisPartition;
                reservedMediaPartition->owningSession = thisSession;
                RefObject(reservedMediaPartition);
                physMedia->numPartitionsOwnedBySession++;
                result = ERROR_SUCCESS;
                break;
            }
        }
    }
    else {
        ASSERT(physMedia->owningSession == thisSession);
        result = ERROR_INVALID_MEDIA;
    }
    
    LeaveCriticalSection(&physMedia->lock);

    *ppNextPartition = reservedMediaPartition;
    return result;
}


HRESULT AllocateMediaFromPool(  SESSION *thisSession, 
                                    MEDIA_POOL *mediaPool, 
                                    DWORD dwTimeoutMsec,
                                    PHYSICAL_MEDIA **ppPhysMedia,
                                    BOOL opReqIfNeeded)
{
    DWORD startTime = GetTickCount();
    HRESULT result;

    while (TRUE){
        PHYSICAL_MEDIA *physMedia = NULL;
        LIST_ENTRY *listEntry;
        ULONG i;
        
        EnterCriticalSection(&mediaPool->lock);

        if (!IsListEmpty(&mediaPool->physMediaList)){
            /*
             *  Remove the media.  
             *  Deref both the pool and the media since they no longer
             *  point to each other.
             */
            PLIST_ENTRY listEntry = RemoveHeadList(&mediaPool->physMediaList);
            physMedia = CONTAINING_RECORD(listEntry, PHYSICAL_MEDIA, physMediaListEntry);    
            DerefObject(mediaPool);
            DerefObject(physMedia);
        }    
        
        LeaveCriticalSection(&mediaPool->lock);

        if (physMedia){
            
            // BUGBUG FINISH - enqueue it in a 'inUse' queue, change state ?
            
            *ppPhysMedia = physMedia;

            /*
             *  Reference the media since we're returning a pointer to it.
             */
            RefObject(physMedia);
            result = ERROR_SUCCESS;
            break;
        }
        else {
            
            // BUGBUG FINISH - based on policy, try free/scratch pool

            if (opReqIfNeeded){
                // BUGBUG FINISH - do op request and try again ...
            }
            
            result = ERROR_MEDIA_UNAVAILABLE;
        }

        /*
         *  If appropriate, wait for media to become free.
         */
        if ((result == ERROR_MEDIA_UNAVAILABLE) && (dwTimeoutMsec > 0)){
            /*
             *  Wait on the designated media pool to receive new media.
             *  The media pool's event will get signalled when either it
             *  OR THE SCRATCH POOL receives new media.
             */
            DWORD waitRes = WaitForSingleObject(mediaPool->newMediaEvent, dwTimeoutMsec); 
            if (waitRes == WAIT_TIMEOUT){
                result = ERROR_TIMEOUT;
                break;
            }
            else {
                /*
                 *  Loop around and try again.
                 */
                DWORD timeNow = GetTickCount();
                dwTimeoutMsec -= MIN(dwTimeoutMsec, timeNow-startTime);
            }
        }
        else {
            break;
        }
        
    }
    
    return result;
}


HRESULT DeletePhysicalMedia(PHYSICAL_MEDIA *physMedia)
{
    HRESULT result;
    
    // BUGBUG FINISH
    DBGERR(("not implemented"));
    result = ERROR_CALL_NOT_IMPLEMENTED;
    
    return result;
}



/*
 *  InsertPhysicalMediaInPool
 *
 *      Insert the physical media (which may not currently be in any pool)
 *      into the designated media pool.
 */
VOID InsertPhysicalMediaInPool( MEDIA_POOL *mediaPool,
                                    PHYSICAL_MEDIA *physMedia)
{

    ASSERT(!physMedia->owningMediaPool);
    
    EnterCriticalSection(&mediaPool->lock);
    EnterCriticalSection(&physMedia->lock);

    InsertTailList(&mediaPool->physMediaList, &physMedia->physMediaListEntry); 
    mediaPool->numPhysMedia++;
    physMedia->owningMediaPool = mediaPool;

    /*
     *  Reference both objects since they now point to each other.
     */
    RefObject(mediaPool);
    RefObject(physMedia);
    
    LeaveCriticalSection(&physMedia->lock);
    LeaveCriticalSection(&mediaPool->lock);
    
}


/*
 *  RemovePhysicalMediaFromPool
 *
 *      Remove the physical media from containing media pool (if any).
 *
 *      Must be called with physical media lock held.
 *      If the media is indeed in a pool, pool lock must be held as well
 *      (use LockPhysicalMediaWithPool).
 */
VOID RemovePhysicalMediaFromPool(PHYSICAL_MEDIA *physMedia)
{
    MEDIA_POOL *mediaPool = physMedia->owningMediaPool;
    HRESULT result;   

    if (mediaPool){
        ASSERT(!IsListEmpty(&mediaPool->physMediaList));
        ASSERT(!IsListEmpty(&physMedia->physMediaListEntry));
        ASSERT(mediaPool->numPhysMedia > 0);
        
        RemoveEntryList(&physMedia->physMediaListEntry); 
        InitializeListHead(&physMedia->physMediaListEntry);
        mediaPool->numPhysMedia--;
        physMedia->owningMediaPool = NULL; 

        /*
         *  Dereference both objects since they no longer point to each other.
         */
        DerefObject(mediaPool);
        DerefObject(physMedia);
    }
    else {
        /*
         *  The media is not in any pool.  So succeed.
         */
    }

}


/*
 *  MovePhysicalMediaToPool
 *
 *      Remove the physical media from whatever pool it is currently in
 *      and move it to destMediaPool.  
 */
HRESULT MovePhysicalMediaToPool(    MEDIA_POOL *destMediaPool, 
                                            PHYSICAL_MEDIA *physMedia,
                                            BOOLEAN setMediaTypeToPoolType)
{
    HRESULT result;
    BOOLEAN allowImport;
    ULONG i;
    
    if (LockPhysicalMediaWithPool(physMedia)){
    
        /*
         *  We can only move the media if all media partitions are 
         *  in an importable state.
         */
        allowImport = TRUE;
        for (i = 0; i < physMedia->numPartitions; i++){
            MEDIA_PARTITION *thisMediaPart = &physMedia->partitions[i];
            if (!thisMediaPart->allowImport){
                allowImport = FALSE;
                break;
            }
        }

        if (allowImport){

            // BUGBUG FINISH - also check that media types match, etc.
            
            RemovePhysicalMediaFromPool(physMedia);
            result = ERROR_SUCCESS;
        }
        else {
            result = ERROR_ACCESS_DENIED;
        }

        /*
         *  Drop the lock before touching the destination media pool.
         *  We cannot hold locks on two pools at once (may cause deadlock).
         */
        UnlockPhysicalMediaWithPool(physMedia);
        
        if (result == ERROR_SUCCESS){
            InsertPhysicalMediaInPool(destMediaPool, physMedia);

            if (setMediaTypeToPoolType){
                /*
                 *  Set the media's type to the media pool's type.
                 *
                 *  This part is failable.  BUGBUG ?
                 */
                if (LockPhysicalMediaWithPool(physMedia)){
                    /*
                     *  Make sure that the media didn't move while
                     *  we dropped the lock.  If it did, that's ok;
                     *  we can just leave it alone and let the new pool
                     *  take over.
                     */
                    if (physMedia->owningMediaPool == destMediaPool){
                        SetMediaType(physMedia, destMediaPool->mediaTypeObj);
                    }
                    
                    UnlockPhysicalMediaWithPool(physMedia);
                }
            }
        }
    }
    else {
        result = ERROR_BUSY;
    }
    
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\mediatyp.c ===
/*
 *  MEDIATYP.C
 *
 *      RSM Service :  Media Type Objects
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


MEDIA_TYPE_OBJECT *NewMediaTypeObject(LIBRARY *lib)
{
    MEDIA_TYPE_OBJECT *mediaTypeObj;
    
    mediaTypeObj = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(MEDIA_TYPE_OBJECT));
    if (mediaTypeObj){
        mediaTypeObj->lib = lib;
        mediaTypeObj->numPhysMediaReferences = 0;
        InitializeCriticalSection(&mediaTypeObj->lock);
    }
    else {
        ASSERT(mediaTypeObj);
    }

    return mediaTypeObj;
}


VOID DestroyMediaTypeObject(MEDIA_TYPE_OBJECT *mediaTypeObj)
{
    // BUGBUG FINISH
    DeleteCriticalSection(&mediaTypeObj->lock);
    GlobalFree(mediaTypeObj);
}


MEDIA_TYPE_OBJECT *FindMediaTypeObject(LPNTMS_GUID lpMediaTypeId)
{
    MEDIA_TYPE_OBJECT *mediaTypeObj = NULL;

    if (lpMediaTypeId){
        OBJECT_HEADER *objHdr;
        
        objHdr = FindObjectInGuidHash(lpMediaTypeId);
        if (objHdr){
            if (objHdr->objType == OBJECTTYPE_MEDIATYPEOBJECT){
                mediaTypeObj = (MEDIA_TYPE_OBJECT *)objHdr;
            }
            else {
                DerefObject(objHdr);
            }
        }
    }
    
    return mediaTypeObj;
}


HRESULT DeleteMediaTypeObject(MEDIA_TYPE_OBJECT *mediaTypeObj)
{
    HRESULT result;

    EnterCriticalSection(&mediaTypeObj->lock);

    if (mediaTypeObj->numPhysMediaReferences == 0){
        /*
         *  Dereference the media type object.
         *  This will cause it to get deleted once its reference
         *  count goes to zero.  We can still use our pointer
         *  since the caller has a reference.
         */
        mediaTypeObj->objHeader.isDeleted = TRUE;
        DerefObject(mediaTypeObj);
        result = ERROR_SUCCESS;
    }
    else {
        /*
         *  There are physical media referencing this media type object
         *  as their type.  So we can't delete this type object.
         */
        result = ERROR_BUSY;
    }
    
    LeaveCriticalSection(&mediaTypeObj->lock);

    return result;
}


/*
 *  SetMediaType
 *
 *      Must be called with physical media lock held.
 *      MEDIA_TYPE_OBJECT lock should NOT be held as we may have
 *      to grab another MEDIA_TYPE_OBJECT's lock 
 *      (acquiring both simulataneously might lead to deadlock).
 */
VOID SetMediaType(PHYSICAL_MEDIA *physMedia, MEDIA_TYPE_OBJECT *mediaTypeObj)
{
    /*
     *  Remove the current type, if any.
     */
    if (physMedia->mediaTypeObj){
        EnterCriticalSection(&physMedia->mediaTypeObj->lock);
        
        ASSERT(physMedia->mediaTypeObj->numPhysMediaReferences > 0);
        physMedia->mediaTypeObj->numPhysMediaReferences--;

        /*
         *  Dereference both objects since they no longer point to each other.
         */
        DerefObject(physMedia);
        DerefObject(physMedia->mediaTypeObj);
        
        LeaveCriticalSection(&physMedia->mediaTypeObj->lock);
        
        physMedia->mediaTypeObj = NULL;
    }

    /*
     *  Now set the new media type.
     */
    EnterCriticalSection(&mediaTypeObj->lock);
    mediaTypeObj->numPhysMediaReferences++;
    physMedia->mediaTypeObj = mediaTypeObj;
    RefObject(physMedia);
    RefObject(mediaTypeObj);
    LeaveCriticalSection(&mediaTypeObj->lock);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\opreq.c ===
/*
 *  OPREQ.C
 * 
 *      RSM Service :  Operator Requests
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>
#include <objbase.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


OPERATOR_REQUEST *NewOperatorRequest(    DWORD dwRequest,
                                        LPCWSTR lpMessage,
                                        LPNTMS_GUID lpArg1Id,
                                        LPNTMS_GUID lpArg2Id)
{
    OPERATOR_REQUEST *newOpReq;

    newOpReq = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(OPERATOR_REQUEST));
    if (newOpReq){

        newOpReq->completedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (newOpReq->completedEvent){    

            InitializeListHead(&newOpReq->sessionOpReqsListEntry);

            newOpReq->opRequestCommand = dwRequest;
            newOpReq->state = NTMS_OPSTATE_UNKNOWN;
		    WStrNCpy((WCHAR *)newOpReq->appMessage, (WCHAR *)lpMessage, sizeof(newOpReq->appMessage)/sizeof(WCHAR));
		    memcpy(&newOpReq->arg1Guid, lpArg1Id, sizeof(NTMS_GUID));
		    memcpy(&newOpReq->arg2Guid, lpArg2Id, sizeof(NTMS_GUID));

            #if 0   // BUGBUG - do this in RSM Monitor app ?
                /*
                 *  Initialize the NOTIFYICONDATA structure 
                 *  for the message display (used in the Shell_NotifyIcon call).
                 *  Make it hidden initially.
                 *  BUGBUG - make this work with RSM monitor (need hWnd and callback msg id)
                 */
                newOpReq->notifyData.cbSize = sizeof(NOTIFYICONDATA);
                newOpReq->notifyData.hWnd = NULL;
                newOpReq->notifyData.uID = (ULONG_PTR)newOpReq;
                newOpReq->notifyData.uFlags = NIF_ICON | NIF_TIP | NIF_STATE;
                newOpReq->notifyData.uCallbackMessage = 0;
                newOpReq->notifyData.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_OPREQ_ICON));
                LoadString(g_hInstanceMonitor, IDS_OPTIP, newOpReq->notifyData.szTip, sizeof(newOpReq->notifyData.szTip)/sizeof(TCHAR));
                newOpReq->notifyData.dwState = NIS_HIDDEN;
                newOpReq->notifyData.dwStateMask = NIS_HIDDEN;
                LoadString(g_hInstanceMonitor, IDS_OPINFO, newOpReq->notifyData.szInfo, sizeof(newOpReq->notifyData.szInfo)/sizeof(TCHAR));
                newOpReq->notifyData.uTimeout = 60000;  // 1 minute
                LoadString(g_hInstanceMonitor, IDS_OPTIP, newOpReq->notifyData.szInfoTitle, sizeof(newOpReq->notifyData.szInfoTitle)/sizeof(TCHAR));
                newOpReq->notifyData.dwInfoFlags = NIIF_INFO;
                Shell_NotifyIcon(NIM_ADD, &newOpReq->notifyData);
            #endif

            /*
             *  Create a unique identifier for this op request
             */
            CoCreateGuid(&newOpReq->opReqGuid);
        }
        else {
            FreeOperatorRequest(newOpReq);
            newOpReq = NULL;
        }
    }

    ASSERT(newOpReq);
    return newOpReq;
}


VOID FreeOperatorRequest(OPERATOR_REQUEST *opReq)
{
    ASSERT(IsListEmpty(&opReq->sessionOpReqsListEntry));

    if (opReq->completedEvent) CloseHandle(opReq->completedEvent);

    // BUGBUG ? if (opReq->notifyData.hIcon) DestroyIcon(opReq->notifyData.hIcon);

    GlobalFree(opReq);
}


BOOL EnqueueOperatorRequest(SESSION *thisSession, OPERATOR_REQUEST *opReq)
{
    DWORD threadId;
    BOOL ok = FALSE;

    #if 0   // BUGBUG - do this in RSM Monitor app ?
        /*
         *  Make the notification display visible on the tray
         */
        newOpReq->notifyData.uFlags = NIF_MESSAGE | NIF_INFO | NIF_STATE;
        newOpReq->notifyData.dwState = 0;
        newOpReq->notifyData.uTimeout = 60000;  // 1 minute
        Shell_NotifyIcon(NIM_MODIFY, &newOpReq->notifyData);
    #endif

    // BUGBUG FINISH - make rsm monitor put up dialog UI for op req msg

    opReq->invokingSession = thisSession;
    GetSystemTime(&opReq->timeSubmitted);

    EnterCriticalSection(&thisSession->lock);

            // BUGBUG - I don't think we need an op request thread
    opReq->hThread = CreateThread(NULL, 0, OperatorRequestThread, opReq, 0, &threadId);
    if (opReq->hThread){    
        InsertTailList(&thisSession->operatorRequestList, &opReq->sessionOpReqsListEntry);
        opReq->state = NTMS_OPSTATE_SUBMITTED;
        ok = TRUE;
    }
    else {
        ASSERT(opReq->hThread);
    }

    LeaveCriticalSection(&thisSession->lock);

    return ok;
}


/*
 *  DequeueOperatorRequest
 *
 *      Callable 3 ways:
 *          dequeue given op request (specificOpReq non-null)
 *          dequeue op request with given GUID (specificOpReqGuid non-null)
 *          dequeue first op request (both NULL)
 */
OPERATOR_REQUEST *DequeueOperatorRequest(    SESSION *thisSession, 
                                            OPERATOR_REQUEST *specificOpReq,
                                            LPNTMS_GUID specificOpReqGuid)
{
    OPERATOR_REQUEST *opReq;
    LIST_ENTRY *listEntry;

    /*
     *  If an op request is passed in, dequeue that one.
     *  Else, dequeue the first.
     */
    EnterCriticalSection(&thisSession->lock);
    if (specificOpReq){
        ASSERT(!IsListEmpty(&specificOpReq->sessionOpReqsListEntry));
        ASSERT(!IsListEmpty(&thisSession->operatorRequestList));
        RemoveEntryList(&specificOpReq->sessionOpReqsListEntry);
        InitializeListHead(&specificOpReq->sessionOpReqsListEntry);
        opReq = specificOpReq;
    }
    else if (specificOpReqGuid){
        opReq = FindOperatorRequest(thisSession, specificOpReqGuid);
        if (opReq){
           RemoveEntryList(&opReq->sessionOpReqsListEntry);
        }
    }
    else {
        if (IsListEmpty(&thisSession->operatorRequestList)){
            opReq = NULL;
        }
        else {
            listEntry = RemoveHeadList(&thisSession->operatorRequestList);
            opReq = CONTAINING_RECORD(listEntry, OPERATOR_REQUEST, sessionOpReqsListEntry);
        }
    }
    LeaveCriticalSection(&thisSession->lock);

    return opReq;
}


/*
 *  FindOperatorRequest
 *
 *      ** Must be called with session lock held
 */
OPERATOR_REQUEST *FindOperatorRequest(SESSION *thisSession, LPNTMS_GUID opReqGuid)
{
    OPERATOR_REQUEST *opReq = NULL;
    LIST_ENTRY *listEntry;

    listEntry = &thisSession->operatorRequestList;
    while ((listEntry = listEntry->Flink) != &thisSession->operatorRequestList){
        OPERATOR_REQUEST *thisOpReq = CONTAINING_RECORD(listEntry, OPERATOR_REQUEST, sessionOpReqsListEntry);
        if (RtlEqualMemory(&thisOpReq->opReqGuid, opReqGuid, sizeof(NTMS_GUID))){
            opReq = thisOpReq;
            break;
        }
    }

    return opReq;
}


/*
 *  CompleteOperatorRequest
 *
 *      Complete and free the op request, synchronizing with any threads
 *      waiting on its completion.
 */
HRESULT CompleteOperatorRequest(    SESSION *thisSession, 
                                    LPNTMS_GUID lpRequestId,
                                    enum NtmsOpreqState completeState)
{
    HRESULT result;

    if (lpRequestId){
        OPERATOR_REQUEST *opReq;
    
        opReq = DequeueOperatorRequest(thisSession, NULL, lpRequestId);
        if (opReq){

            /*
             *  Remove the notification display from the tray
             */
            // BUGBUG - do this in RSM Monitor app ?
            // Shell_NotifyIcon(NIM_DELETE, &opReq->notifyData);

            /*
             *  Make sure there are no threads waiting on the
             *  operator request before freeing it.
             */
            EnterCriticalSection(&thisSession->lock);

            /*
             *  Kill the op request thread
             */
            TerminateThread(opReq->hThread, ERROR_SUCCESS);
            CloseHandle(opReq->hThread);
 
            /*
             *  There may be some threads waiting in WaitForNtmsOperatorRequest
             *  for this op request to complete.  Need to flush them
             *  before freeing the op request.
             */
            opReq->state = completeState;
            SetEvent(opReq->completedEvent);

            /*
             *  Drop the lock and wait for the waiting threads to exit.
             */
            while (opReq->numWaitingThreads > 0){
                LeaveCriticalSection(&thisSession->lock);
                Sleep(1);
                EnterCriticalSection(&thisSession->lock);
            }

            LeaveCriticalSection(&thisSession->lock);

            FreeOperatorRequest(opReq);
            result = ERROR_SUCCESS;
        }
        else {
            result = ERROR_OBJECT_NOT_FOUND;
        }
    }
    else {
        ASSERT(lpRequestId);
        result = ERROR_INVALID_PARAMETER;
    }

    return result;
}

            // BUGBUG - I don't think we need an op request thread
DWORD __stdcall OperatorRequestThread(void *context)
{
    OPERATOR_REQUEST *opReq = (OPERATOR_REQUEST *)context;



    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\ntmsapi.c ===
/*
 *  NTMSAPI.C
 *
 *      RSM Service :  Service API
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


     // BUGBUG - these need to be exposed as a COM interface w/ RPC


HANDLE WINAPI OpenNtmsServerSessionW(   LPCWSTR lpServer,
                                        LPCWSTR lpApplication,
                                        LPCWSTR lpClientName,
                                        LPCWSTR lpUserName,
                                        DWORD   dwOptions,
                                        LPVOID  lpConnectionContext)
{
    SESSION *newSession;

    newSession = NewSession(lpServer, lpApplication, lpClientName, lpUserName);
    if (newSession){
    }
    else {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return (HANDLE)newSession;
}


HANDLE WINAPI OpenNtmsServerSessionA( LPCSTR lpServer,
                                LPCSTR lpApplication,
                                LPCSTR lpClientName,
                                LPCSTR lpUserName,
                                DWORD  dwOptions,
                                LPVOID  lpConnectionContext)
{
    SESSION *newSession;
    WCHAR wServerName[NTMS_COMPUTERNAME_LENGTH];
    WCHAR wAppName[NTMS_APPLICATIONNAME_LENGTH];
    WCHAR wClientName[NTMS_COMPUTERNAME_LENGTH];
    WCHAR wUserName[NTMS_USERNAME_LENGTH];

    AsciiToWChar(wServerName, lpServer, NTMS_COMPUTERNAME_LENGTH);
    AsciiToWChar(wAppName, lpApplication, NTMS_APPLICATIONNAME_LENGTH);
    AsciiToWChar(wClientName, lpClientName, NTMS_COMPUTERNAME_LENGTH);
    AsciiToWChar(wUserName, lpUserName, NTMS_USERNAME_LENGTH);

    newSession = OpenNtmsServerSessionW(    wServerName, 
                                            wAppName,
                                            wClientName,
                                            wUserName,
                                            dwOptions,
                                            lpConnectionContext);

    return newSession;

}


DWORD WINAPI CloseNtmsSession(HANDLE hSession)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        FreeSession(thisSession);

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI SubmitNtmsOperatorRequestW(    HANDLE hSession,
                                            DWORD dwRequest,
                                            LPCWSTR lpMessage,
                                            LPNTMS_GUID lpArg1Id,
                                            LPNTMS_GUID lpArg2Id,
                                            LPNTMS_GUID lpRequestId)
{   
    HRESULT result = ERROR_SUCCESS;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        switch (dwRequest){

            case NTMS_OPREQ_DEVICESERVICE:
            case NTMS_OPREQ_MOVEMEDIA:
            case NTMS_OPREQ_NEWMEDIA:
                if (!lpArg1Id){
                    result = ERROR_INVALID_PARAMETER;
                }
                break;

            case NTMS_OPREQ_CLEANER:
            case NTMS_OPREQ_MESSAGE:
                break;

            default:
                DBGERR(("SubmitNtmsOperatorRequestW: unrecognized request"));
                result = ERROR_NOT_SUPPORTED;
                break;

        }
    
        if (result == ERROR_SUCCESS){
            OPERATOR_REQUEST *opReq;

            opReq = NewOperatorRequest(dwRequest, lpMessage, lpArg1Id, lpArg2Id);
            if (opReq){

                /*
                 *  Retrieve the localized RSM message for this op request.
                 */
                switch (dwRequest){
                    case NTMS_OPREQ_DEVICESERVICE:
                        LoadStringW(g_hInstance, IDS_OPREQUESTDEVICESVC, opReq->rsmMessage, sizeof(opReq->rsmMessage)/sizeof(WCHAR));
                        break;
                    case NTMS_OPREQ_MOVEMEDIA:
                        LoadStringW(g_hInstance, IDS_OPREQUESTMOVEMEDIA, opReq->rsmMessage, sizeof(opReq->rsmMessage)/sizeof(WCHAR));
                        break;
                    case NTMS_OPREQ_NEWMEDIA:
                        LoadStringW(g_hInstance, IDS_OPREQUESTNEWMEDIA, opReq->rsmMessage, sizeof(opReq->rsmMessage)/sizeof(WCHAR));
                        break;
                    case NTMS_OPREQ_CLEANER:
                        LoadStringW(g_hInstance, IDS_OPREQUESTCLEANER, opReq->rsmMessage, sizeof(opReq->rsmMessage)/sizeof(WCHAR));
                        break;
                    case NTMS_OPREQ_MESSAGE:
                        LoadStringW(g_hInstance, IDS_OPREQUESTMESSAGE, opReq->rsmMessage, sizeof(opReq->rsmMessage)/sizeof(WCHAR));
                        break;
                }

                *lpRequestId = opReq->opReqGuid;

                if (EnqueueOperatorRequest(thisSession, opReq)){
                    result = ERROR_SUCCESS;
                }
                else {
                    FreeOperatorRequest(opReq);
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else {
                result = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI SubmitNtmsOperatorRequestA(    HANDLE hSession,
                                            DWORD dwRequest,
                                            LPCSTR lpMessage,
                                            LPNTMS_GUID lpArg1Id,
                                            LPNTMS_GUID lpArg2Id,
                                            LPNTMS_GUID lpRequestId)
{
    WCHAR wMessage[NTMS_MESSAGE_LENGTH];
    HRESULT result;

    AsciiToWChar(wMessage, lpMessage, NTMS_MESSAGE_LENGTH);
    result = SubmitNtmsOperatorRequestW(hSession,
                                        dwRequest,
                                        wMessage,
                                        lpArg1Id,
                                        lpArg2Id,
                                        lpRequestId);
    return result;
}


DWORD WINAPI WaitForNtmsOperatorRequest(    HANDLE hSession, 
                                            LPNTMS_GUID lpRequestId,
                                            DWORD dwTimeout)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        OPERATOR_REQUEST *opReq;

        EnterCriticalSection(&thisSession->lock);

        opReq = FindOperatorRequest(thisSession, lpRequestId);
        if (opReq){
            
            if ((opReq->state == NTMS_OPSTATE_COMPLETE) ||
                (opReq->state == NTMS_OPSTATE_REFUSED)){

                result = ERROR_SUCCESS;
            }
            else {
                opReq->numWaitingThreads++;

                /*
                 *  Drop the lock and wait for the op request to complete.
                 *  No race here: the opReq won't get deleted while
                 *  numWaitingThreads > 0.
                 */
                LeaveCriticalSection(&thisSession->lock);
                WaitForSingleObject(opReq->completedEvent, dwTimeout);
                EnterCriticalSection(&thisSession->lock);

                result = (opReq->state == NTMS_OPSTATE_COMPLETE) ? ERROR_SUCCESS :
                         (opReq->state == NTMS_OPSTATE_REFUSED) ? ERROR_CANCELLED :
                         ERROR_TIMEOUT;   

                ASSERT(opReq->numWaitingThreads > 0);
                opReq->numWaitingThreads--;
            }

        }
        else {
            result = ERROR_OBJECT_NOT_FOUND;
        }

        LeaveCriticalSection(&thisSession->lock);
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI CancelNtmsOperatorRequest(HANDLE hSession, LPNTMS_GUID lpRequestId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        result = CompleteOperatorRequest(thisSession, lpRequestId, NTMS_OPSTATE_REFUSED);
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI SatisfyNtmsOperatorRequest(HANDLE hSession, LPNTMS_GUID lpRequestId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        result = CompleteOperatorRequest(thisSession, lpRequestId, NTMS_OPSTATE_COMPLETE);
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI ImportNtmsDatabase(HANDLE hSession)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI ExportNtmsDatabase(HANDLE hSession)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
        // BUGBUG - this API not documented and I don't understand it
HRESULT WINAPI GetNtmsMountDrives(  HANDLE hSession,
                                    LPNTMS_MOUNT_INFORMATION lpMountInfo,
                                    LPNTMS_GUID lpDriveId,
                                    DWORD dwCount)        
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        if (lpMountInfo && lpMountInfo->lpReserved && lpDriveId && dwCount){

            // BUGBUG FINISH

            result = ERROR_SUCCESS;
        }
        else {
            result = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI AllocateNtmsMedia( HANDLE hSession,
                                LPNTMS_GUID lpMediaPoolId,
                                LPNTMS_GUID lpPartitionId,    // optional
                                LPNTMS_GUID lpMediaId,      // in/out
                                DWORD dwOptions,
                                DWORD dwTimeout,
                                LPNTMS_ALLOCATION_INFORMATION lpAllocateInfo)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_POOL *mediaPool;
        
        mediaPool = FindMediaPool(lpMediaPoolId);
        if (mediaPool){
            PHYSICAL_MEDIA *physMedia;

            if (dwOptions & NTMS_ALLOCATE_NEW){
                /*
                 *  Allocate the first partition (side) of the specified media
                 *  with a reservation on all other partitions.
                 */
                if (lpPartitionId){
                    physMedia = FindPhysicalMedia(lpMediaId);
                    if (physMedia){
                        result = AllocatePhysicalMediaExclusive(thisSession, physMedia, lpPartitionId, dwTimeout);
                        DerefObject(physMedia);
                    }
                    else {
                        result = ERROR_INVALID_PARAMETER;
                    }
                }
                else {
                    ASSERT(lpPartitionId);
                    result = ERROR_INVALID_PARAMETER;
                }
            }
            else if (dwOptions & NTMS_ALLOCATE_NEXT){
                /*
                 *  The specified media is (ostensibly) owned by the caller.  
                 *  Allocate the next available partition for him.
                 */
                physMedia = FindPhysicalMedia(lpMediaId);
                if (physMedia){
                    MEDIA_PARTITION *nextMediaPartition;
                    ASSERT(!lpPartitionId);
                    result = AllocateNextPartitionOnExclusiveMedia(thisSession, physMedia, &nextMediaPartition);
                    if (result == ERROR_SUCCESS){
                        *lpMediaId = nextMediaPartition->logicalMediaGuid;
                    }
                    DerefObject(physMedia);
                }
                else {
                    result = ERROR_INVALID_PARAMETER;
                }            
            }
            else {
                // BUGBUG - are we reserving a physMedia or just 
                //           a partition here ?
                
                BOOL opReqIfNeeded = (dwOptions & NTMS_ALLOCATE_ERROR_IF_UNAVAILABLE) ? FALSE : TRUE;
                result = AllocateMediaFromPool(thisSession, mediaPool, dwTimeout, &physMedia, opReqIfNeeded);
                if (result == ERROR_SUCCESS){
                    // BUGBUG - return logicalMediaId ??
                    *lpMediaId = physMedia->objHeader.guid;
                }
            }

            DerefObject(mediaPool);
        }
        else {
            result = ERROR_INVALID_MEDIA_POOL;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DeallocateNtmsMedia(   HANDLE hSession,
                                    LPNTMS_GUID lpLogicalMediaId,
                                    DWORD dwOptions)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_PARTITION *thisMediaPartition;

        thisMediaPartition = FindMediaPartition(lpLogicalMediaId);
        if (thisMediaPartition){
            result = ReleaseMediaPartition(thisSession, thisMediaPartition);
        }
        else {
            result = ERROR_INVALID_MEDIA;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}        


DWORD WINAPI SwapNtmsMedia(   HANDLE hSession,
                                LPNTMS_GUID lpMediaId1,
                                LPNTMS_GUID lpMediaId2)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DecommissionNtmsMedia(   HANDLE hSession,
                                        LPNTMS_GUID lpMediaPartId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_PARTITION *mediaPart;

        mediaPart = FindMediaPartition(lpMediaPartId);
        if (mediaPart){
            result = SetMediaPartitionState( mediaPart, 
                                        MEDIAPARTITIONSTATE_DECOMMISSIONED);
            DerefObject(mediaPart);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}
        


DWORD WINAPI SetNtmsMediaComplete(    HANDLE hSession,
                                        LPNTMS_GUID lpMediaPartId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_PARTITION *mediaPart;

        mediaPart = FindMediaPartition(lpMediaPartId);
        if (mediaPart){
            result = SetMediaPartitionComplete(mediaPart);
            DerefObject(mediaPart);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DeleteNtmsMedia( HANDLE hSession,
                                LPNTMS_GUID lpPhysMediaId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        PHYSICAL_MEDIA *physMedia;

        physMedia = FindPhysicalMedia(lpPhysMediaId);
        if (physMedia){
            result = DeletePhysicalMedia(physMedia);
            DerefObject(physMedia);           
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}
    
    
DWORD WINAPI CreateNtmsMediaPoolW(    HANDLE hSession,
                                        LPCWSTR lpPoolName,
                                        LPNTMS_GUID lpMediaType,
                                        DWORD dwAction,
                                        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                        OUT LPNTMS_GUID lpPoolId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_POOL *mediaPool;

        mediaPool = FindMediaPoolByName((PWSTR)lpPoolName);

        if (dwAction == NTMS_OPEN_EXISTING){
            if (mediaPool){
                *lpPoolId = mediaPool->objHeader.guid;
                result = ERROR_SUCCESS;
            }
            else {
                result = ERROR_OBJECT_NOT_FOUND;
            }
        }
        else if (dwAction == NTMS_OPEN_ALWAYS){
            if (mediaPool){
                *lpPoolId = mediaPool->objHeader.guid;
                result = ERROR_SUCCESS;
            }
            else {
                mediaPool = NewMediaPool(lpPoolName, lpMediaType, lpSecurityAttributes);
                if (mediaPool){
                    // BUGBUG FINISH
                    *lpPoolId = mediaPool->objHeader.guid;
                    result = ERROR_SUCCESS;
                }
                else {
                    result = ERROR_DATABASE_FAILURE;
                }
            }
        }
        else if (dwAction == NTMS_CREATE_NEW){
            /*
             *  Caller is trying to open a new media pool.
             *  So if one by that name already exists, fail.
             */
            if (mediaPool){
                DerefObject(mediaPool);
                result = ERROR_ALREADY_EXISTS;
            }
            else {
                mediaPool = NewMediaPool(lpPoolName, lpMediaType, lpSecurityAttributes);
                if (mediaPool){
                    // BUGBUG FINISH
                    *lpPoolId = mediaPool->objHeader.guid;
                    result = ERROR_SUCCESS;
                }
                else {
                    result = ERROR_DATABASE_FAILURE;
                }
            }
        
        }
        else {
            result = ERROR_INVALID_PARAMETER;
        }
        
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI CreateNtmsMediaPoolA(  HANDLE hSession,
                                    LPCSTR lpPoolName,
                                    LPNTMS_GUID lpMediaType,
                                    DWORD dwAction,
                                    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                    OUT LPNTMS_GUID lpPoolId)
{
    HRESULT result;
    WCHAR wPoolName[NTMS_OBJECTNAME_LENGTH];

    AsciiToWChar(wPoolName, lpPoolName, NTMS_OBJECTNAME_LENGTH);

    result = CreateNtmsMediaPoolW(  hSession,
                                    wPoolName,
                                    lpMediaType,
                                    dwAction,
                                    lpSecurityAttributes,
                                    lpPoolId);
    return result;
}


DWORD WINAPI GetNtmsMediaPoolNameW(   HANDLE hSession,
                                        LPNTMS_GUID lpPoolId,
                                        LPWSTR lpBufName,
                                        LPDWORD lpdwNameSize)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_POOL *mediaPool;

        mediaPool = FindMediaPool(lpPoolId);
        if (mediaPool){
            ULONG numChars;

            EnterCriticalSection(&mediaPool->lock);
            
            numChars = wcslen(mediaPool->name)+1;
            ASSERT(numChars < NTMS_OBJECTNAME_LENGTH);
            
            if (*lpdwNameSize >= numChars){
                numChars = WStrNCpy(lpBufName, mediaPool->name, *lpdwNameSize);
                result = ERROR_SUCCESS;
            }
            else {
                result = ERROR_INSUFFICIENT_BUFFER;
            }
            
            *lpdwNameSize = numChars;

            LeaveCriticalSection(&mediaPool->lock);
            
            DerefObject(mediaPool);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI GetNtmsMediaPoolNameA( HANDLE hSession,
                                    LPNTMS_GUID lpPoolId,
                                    LPSTR lpBufName,
                                    LPDWORD lpdwNameSize)
{
    HRESULT result;

    if (*lpdwNameSize > NTMS_OBJECTNAME_LENGTH){
        ASSERT(*lpdwNameSize <= NTMS_OBJECTNAME_LENGTH);
        result = ERROR_INVALID_PARAMETER;
    }
    else {    
        WCHAR wBufName[NTMS_OBJECTNAME_LENGTH];
        
        result = GetNtmsMediaPoolNameW(hSession, lpPoolId, wBufName, lpdwNameSize);
        if (result == ERROR_SUCCESS){
            WCharToAscii(lpBufName, wBufName, *lpdwNameSize);
        }
    }
    return result;
}

        
DWORD WINAPI MoveToNtmsMediaPool(   HANDLE hSession, 
                                    LPNTMS_GUID lpPhysMediaId, 
                                    LPNTMS_GUID lpPoolId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        PHYSICAL_MEDIA *physMedia;

        physMedia = FindPhysicalMedia(lpPhysMediaId);
        if (physMedia){
            MEDIA_POOL *destMediaPool;
            
            destMediaPool = FindMediaPool(lpPoolId);
            if (destMediaPool){

                result = MovePhysicalMediaToPool(destMediaPool, physMedia, FALSE);
               
                DerefObject(destMediaPool);
            }
            else {
                result = ERROR_INVALID_HANDLE;
            }

            DerefObject(physMedia);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DeleteNtmsMediaPool(HANDLE hSession, LPNTMS_GUID lpPoolId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_POOL *mediaPool;

        mediaPool = FindMediaPool(lpPoolId);
        if (mediaPool){
            result = DeleteMediaPool(mediaPool);
            DerefObject(mediaPool);
        }
        else {
            result = ERROR_INVALID_MEDIA_POOL;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI AddNtmsMediaType(  HANDLE hSession,
                                LPNTMS_GUID lpMediaTypeId,
                                LPNTMS_GUID lpLibId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibId);
        if (lib){
            MEDIA_TYPE_OBJECT *mediaTypeObj;

            mediaTypeObj = FindMediaTypeObject(lpMediaTypeId);
            if (mediaTypeObj){
                /*
                 *  The media type is already defined.  Succeed.
                 */
                DerefObject(mediaTypeObj);
                result = ERROR_SUCCESS;
            }
            else {
                mediaTypeObj = NewMediaTypeObject(lib);
                if (mediaTypeObj){

                    // BUGBUG FINISH - create new standard media pools

                    result = ERROR_SUCCESS;
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_LIBRARY;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DeleteNtmsMediaType(   HANDLE hSession,
                                    LPNTMS_GUID lpMediaTypeId,
                                    LPNTMS_GUID lpLibId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibId);
        if (lib){
            MEDIA_TYPE_OBJECT *mediaTypeObj;

            mediaTypeObj = FindMediaTypeObject(lpMediaTypeId);
            if (mediaTypeObj){
                result = DeleteMediaTypeObject(mediaTypeObj);
                DerefObject(mediaTypeObj);
            }
            else {
                result = ERROR_INVALID_PARAMETER;
            }

            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_LIBRARY;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


/*
 *  ChangeNtmsMediaType
 *
 *      Move the media to the media pool and change the media's
 *      type to the pool's media type.
 */
DWORD WINAPI ChangeNtmsMediaType(   HANDLE hSession,
                                    LPNTMS_GUID lpMediaId,
                                    LPNTMS_GUID lpPoolId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        PHYSICAL_MEDIA *physMedia;

        physMedia = FindPhysicalMedia(lpMediaId);
        if (physMedia){
            MEDIA_POOL *destMediaPool;
            
            destMediaPool = FindMediaPool(lpPoolId);
            if (destMediaPool){

                result = MovePhysicalMediaToPool(destMediaPool, physMedia, TRUE);
               
                DerefObject(destMediaPool);
            }
            else {
                result = ERROR_INVALID_HANDLE;
            }

            DerefObject(physMedia);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI MountNtmsMedia(HANDLE hSession,
                            LPNTMS_GUID lpMediaOrPartitionIds,
                            IN OUT LPNTMS_GUID lpDriveIds,
                            DWORD dwCount,
                            DWORD dwOptions,
                            int dwPriority,
                            DWORD dwTimeout,
                            LPNTMS_MOUNT_INFORMATION lpMountInfo)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        /*
         *  Validate that we can safely read the media and drive GUIDs
         *  that were passed in by the caller (this just verifies that the
         *  buffers are readable; it doesn't verify the GUIDs themselves).
         */
        if (ValidateBuffer(lpMediaOrPartitionIds, dwCount*sizeof(NTMS_GUID))){
            if (ValidateBuffer(lpDriveIds, dwCount*sizeof(NTMS_GUID))){
                WORKGROUP *workGroup;

                /*
                 *  Create a work group, which is a group of workItems,
                 *  to service each component of the mount.
                 */
                workGroup = NewWorkGroup();
                if (workGroup){
                    result = BuildMountWorkGroup( workGroup,
                                                lpMediaOrPartitionIds,
                                                lpDriveIds,
                                                dwCount,
                                                dwOptions,
                                                dwPriority);
                    if (result == ERROR_SUCCESS){

                        /*
                         *  Give the mount workItems to the library thread.
                         */
                        result = ScheduleWorkGroup(workGroup);
                        if (result == ERROR_SUCCESS){
                            DWORD waitRes;

                            /*
                             *  Wait for all the mounts to complete.
                             */
                            waitRes = WaitForSingleObject(workGroup->allWorkItemsCompleteEvent, dwTimeout);
                            if (waitRes == WAIT_TIMEOUT){
                                result = ERROR_TIMEOUT;
                            }
                            else {
                                result = workGroup->resultStatus;
                            }
                        }
                        
                        FreeWorkGroup(workGroup);
                    }
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else {
                result = ERROR_INVALID_DRIVE;
            }
        }
        else {
            result = ERROR_INVALID_MEDIA;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DismountNtmsMedia( HANDLE hSession,
                                LPNTMS_GUID lpMediaOrPartitionIds,
                                DWORD dwCount,
                                DWORD dwOptions)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        if (ValidateBuffer(lpMediaOrPartitionIds, dwCount*sizeof(NTMS_GUID))){
            WORKGROUP *workGroup;

            /*
             *  Create a work group, which is a group of workItems,
             *  to service each component of the mount.
             */
            workGroup = NewWorkGroup();
            if (workGroup){
                result = BuildDismountWorkGroup(  workGroup,
                                                lpMediaOrPartitionIds,
                                                dwCount,
                                                dwOptions);
                if (result == ERROR_SUCCESS){

                    /*
                     *  Give the mount workItems to the library thread.
                     */
                    result = ScheduleWorkGroup(workGroup);
                    if (result == ERROR_SUCCESS){
                        /*
                         *  Wait for all the mounts to complete.
                         */
                        WaitForSingleObject(workGroup->allWorkItemsCompleteEvent, INFINITE);
                        
                        result = workGroup->resultStatus;
                    }
                        
                    FreeWorkGroup(workGroup);
                }
            }
            else {
                result = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else {
            result = ERROR_INVALID_MEDIA;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI EjectNtmsMedia(HANDLE hSession,
                            LPNTMS_GUID lpMediaId,
                            LPNTMS_GUID lpEjectOperation,
                            DWORD dwAction)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        PHYSICAL_MEDIA *physMedia;

        physMedia = FindPhysicalMedia(lpMediaId);
        if (physMedia){
            MEDIA_POOL *mediaPool;
            LIBRARY *lib;

            /*
             *  Get the library for this media.
             */
            LockPhysicalMediaWithLibrary(physMedia);
            mediaPool = physMedia->owningMediaPool;
            lib = mediaPool ? mediaPool->owningLibrary : NULL;
            if (lib){
                RefObject(lib);
            }
            UnlockPhysicalMediaWithLibrary(physMedia);

            if (lib){
                WORKITEM *workItem;
                
                workItem = DequeueFreeWorkItem(lib, TRUE);
                if (workItem){
                    /*
                     *  Build the workItem for the eject.
                     */
                    BuildEjectWorkItem(workItem, physMedia, lpEjectOperation, dwAction);
                    
                    /*
                     *  Give this workItem to the library and wake up the library thread.
                     *  Then wait for the workItem to complete.
                     */
                    EnqueuePendingWorkItem(workItem->owningLib, workItem);

                    WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                    /*
                     *  Get result from the completed workItem.
                     *  Also get result parameters (eject guid is returned
                     *  when dwAction = NTMS_EJECT_START).
                     */
                    result = workItem->currentOp.resultStatus;    
                    *lpEjectOperation = workItem->currentOp.guidArg;

                    EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }

                DerefObject(lib);
            }
            else {
                result = ERROR_DATABASE_FAILURE;
            }

            DerefObject(physMedia);
        }
        else {
            result = ERROR_INVALID_MEDIA;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}



DWORD WINAPI InjectNtmsMedia(   HANDLE hSession,
                                LPNTMS_GUID lpLibraryId,
                                LPNTMS_GUID lpInjectOperation,
                                DWORD dwAction)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){
            if (lib->state == LIBSTATE_ONLINE){
                WORKITEM *workItem;
                    
                workItem = DequeueFreeWorkItem(lib, TRUE);
                if (workItem){
                    /*
                     *  Build the workItem for the inject.
                     */
                    BuildInjectWorkItem(workItem, lpInjectOperation, dwAction);
                   
                    /*
                     *  Give this workItem to the library and wake up the library thread.
                     *  Then wait for the workItem to complete.
                     */
                    EnqueuePendingWorkItem(workItem->owningLib, workItem);

                    WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                    /*
                     *  Get result from the completed workItem.
                     */
                    result = workItem->currentOp.resultStatus;    
                    *lpInjectOperation = workItem->currentOp.guidArg;

                    EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else {
                result = ERROR_LIBRARY_OFFLINE;
            }
            
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

     
DWORD WINAPI AccessNtmsLibraryDoor( HANDLE hSession,
                                    LPNTMS_GUID lpLibraryId,
                                    DWORD dwAction)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){
            if (lib->state == LIBSTATE_ONLINE){
                WORKITEM *workItem;
                    
                workItem = DequeueFreeWorkItem(lib, TRUE);
                if (workItem){
                    /*
                     *  Build the workItem for the door unlock.
                     */
                    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
                    workItem->currentOp.opcode = NTMS_LM_DOORACCESS;
                    workItem->currentOp.options = dwAction;
                    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
                   
                    /*
                     *  Give this workItem to the library and wake up the library thread.
                     */
                    EnqueuePendingWorkItem(workItem->owningLib, workItem);

                    /*
                     *  Wait for the request to be processed by the library thread.
                     *  Note:  If the library is busy, the workItem will be completed 
                     *        immediately and the door will be unlocked later.
                     */
                    WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                    /*
                     *  Get result from the completed workItem.
                     */
                    result = workItem->currentOp.resultStatus;    

                    EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else {
                result = ERROR_LIBRARY_OFFLINE;
            }
            
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI CleanNtmsDrive(HANDLE hSession, LPNTMS_GUID lpDriveId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        DRIVE *drive;

        drive = FindDrive(lpDriveId);
        if (drive){
            WORKITEM *workItem;

            ASSERT(drive->lib);
                    
            workItem = DequeueFreeWorkItem(drive->lib, TRUE);
            if (workItem){
                /*
                 *  Build the workItem to clean the drive.
                 *  Reference every object pointed to by the workItem.
                 */
                RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
                workItem->currentOp.opcode = NTMS_LM_CLEANDRIVE;
                workItem->currentOp.drive = drive;
                workItem->currentOp.resultStatus = ERROR_IO_PENDING;
                RefObject(drive);
                
                /*
                 *  Give this workItem to the library and wake up the library thread.
                 */
                EnqueuePendingWorkItem(workItem->owningLib, workItem);

                /*
                 *  Wait for the request to be processed by the library thread.
                 */
                WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                /*
                 *  Get result from the completed workItem.
                 */
                result = workItem->currentOp.resultStatus;    

                EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
            }
            else {
                result = ERROR_NOT_ENOUGH_MEMORY;
            }

            DerefObject(drive);
        }
        else {
            result = ERROR_INVALID_DRIVE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DismountNtmsDrive(HANDLE hSession, LPNTMS_GUID lpDriveId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        DRIVE *drive;

        drive = FindDrive(lpDriveId);
        if (drive){
            WORKITEM *workItem;
               
            workItem = DequeueFreeWorkItem(drive->lib, TRUE);
            if (workItem){
                /*
                 *  Build the workItem to dismount.
                 *  Reference every object pointed to by the workItem.
                 */
                RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
                workItem->currentOp.opcode = NTMS_LM_DISMOUNT;
                workItem->currentOp.drive = drive;
                workItem->currentOp.resultStatus = ERROR_IO_PENDING;
                RefObject(drive);
                
                /*
                 *  Give this workItem to the library and wake up the library thread.
                 */
                EnqueuePendingWorkItem(workItem->owningLib, workItem);

                /*
                 *  Wait for the request to be processed by the library thread.
                 */
                WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                /*
                 *  Get result from the completed workItem.
                 */
                result = workItem->currentOp.resultStatus;    

                EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
            }
            else {
                result = ERROR_NOT_ENOUGH_MEMORY;
            }

            DerefObject(drive);
        }
        else {
            result = ERROR_INVALID_DRIVE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI InventoryNtmsLibrary(  HANDLE hSession,
                                    LPNTMS_GUID lpLibraryId,
                                    DWORD dwAction)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){
            if (lib->state == LIBSTATE_ONLINE){
                WORKITEM *workItem;
                    
                workItem = DequeueFreeWorkItem(lib, TRUE);
                if (workItem){
                    /*
                     *  Build the workItem for the inventory.
                     */
                    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
                    workItem->currentOp.opcode = NTMS_LM_INVENTORY;
                    workItem->currentOp.options = dwAction;
                    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
                   
                    /*
                     *  Give this workItem to the library and wake up the library thread.
                     */
                    EnqueuePendingWorkItem(workItem->owningLib, workItem);

                    /*
                     *  Wait for the request to be processed by the library thread.
                     *  Note:  If the library is busy, the workItem will be completed 
                     *        immediately and the inventory will happen later.
                     */
                    WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                    /*
                     *  Get result from the completed workItem.
                     */
                    result = workItem->currentOp.resultStatus;    

                    EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else {
                result = ERROR_LIBRARY_OFFLINE;
            }
            
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}
        

DWORD WINAPI UpdateNtmsOmidInfo(    HANDLE hSession,
                                    LPNTMS_GUID lpLogicalMediaId,
                                    DWORD labelType,
                                    DWORD numberOfBytes,
                                    LPVOID lpBuffer)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_PARTITION *mediaPart;

        mediaPart = FindMediaPartition(lpLogicalMediaId);
        if (mediaPart){
            MEDIA_POOL *mediaPool;
            LIBRARY *lib;
            
            ASSERT(mediaPart->owningPhysicalMedia);

            /*
             *  Get the library for this media.
             */
            LockPhysicalMediaWithLibrary(mediaPart->owningPhysicalMedia);
            mediaPool = mediaPart->owningPhysicalMedia->owningMediaPool;
            lib = mediaPool ? mediaPool->owningLibrary : NULL;
            if (lib){
                RefObject(lib);
            }
            UnlockPhysicalMediaWithLibrary(mediaPart->owningPhysicalMedia);

            if (lib){
                WORKITEM *workItem;
                    
                workItem = DequeueFreeWorkItem(lib, TRUE);
                if (workItem){
                    /*
                     *  Build the workItem.
                     */
                    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
                    workItem->currentOp.opcode = NTMS_LM_UPDATEOMID;
                    workItem->currentOp.options = labelType;
                    workItem->currentOp.buf = lpBuffer;
                    workItem->currentOp.bufLen = numberOfBytes;
                    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
                   
                    /*
                     *  Give this workItem to the library and wake up the library thread.
                     */
                    EnqueuePendingWorkItem(workItem->owningLib, workItem);

                    /*
                     *  Wait for the request to be processed by the library thread.
                     */
                    WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                    /*
                     *  Get result from the completed workItem.
                     */
                    result = workItem->currentOp.resultStatus;    

                    EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }

                DerefObject(lib);
            }
            else {
                result = ERROR_DATABASE_FAILURE;             
            }

            DerefObject(mediaPart);
        }
        else {
            result = ERROR_INVALID_MEDIA;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}
     
   
DWORD WINAPI CancelNtmsLibraryRequest(HANDLE hSession, LPNTMS_GUID lpRequestId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        WORKITEM *workItem = NULL;
        LIST_ENTRY *listEntry;
        
        /*
         *  Go through every library and find the workItem to cancel.
         *  This is HUGELY INEFFICIENT but this is a rare call.
         *  This is better than putting every request into the database.
         *
         *  BUGBUG - this only cancels workItems that are still pending.
         *            what about workItems currently being processed ?
         */
        EnterCriticalSection(&g_globalServiceLock);
        listEntry = &g_allLibrariesList;
        while ((listEntry = listEntry->Flink) != &g_allLibrariesList){
            LIBRARY *lib = CONTAINING_RECORD(listEntry, LIBRARY, allLibrariesListEntry);
            workItem = DequeuePendingWorkItemByGuid(lib, lpRequestId);
            if (workItem){
                break;
            }
        }
        LeaveCriticalSection(&g_globalServiceLock);

        if (workItem){
            /*
             *  Found the workItem to cancel.
             *  Dereference any objects pointed to by the workItem
             *  and put it back in the free list.
             */
            FlushWorkItem(workItem);
            EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
            result = ERROR_SUCCESS;            
        }
        else {
            result = ERROR_OBJECT_NOT_FOUND;
        }       
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI ReserveNtmsCleanerSlot(    HANDLE hSession,
                                        LPNTMS_GUID lpLibraryId,
                                        LPNTMS_GUID lpSlotId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){
            SLOT *slot;

            slot = FindLibrarySlot(lib, lpSlotId);
            if (slot){
                /*
                 *  To be reserved as the cleaner slot, the slot must
                 *  be empty and the library must have no cleaner slot reserved.
                 *  Redundant calls to reserve the same cleaner slot fail.
                 */
                EnterCriticalSection(&lib->lock); 
                if (lib->cleanerSlotIndex == NO_SLOT_INDEX){
                    ASSERT(!slot->isCleanerSlot);
                    if (slot->insertedMedia){
                        result = ERROR_RESOURCE_NOT_AVAILABLE; // BUGBUG ERROR_SLOT_FULL; not defined
                    }
                    else {
                        lib->cleanerSlotIndex = slot->slotIndex;
                        slot->isCleanerSlot = TRUE;
                        result = ERROR_SUCCESS;
                    }
                }
                else {
                    result = ERROR_CLEANER_SLOT_SET;
                }
                LeaveCriticalSection(&lib->lock); 

                DerefObject(slot);
            }
            else {
                result = ERROR_INVALID_HANDLE; // BUGBUG ERROR_INVALID_SLOT not defined
            }
            
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_LIBRARY;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}
        

DWORD WINAPI ReleaseNtmsCleanerSlot(HANDLE hSession, LPNTMS_GUID lpLibraryId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){
            if (lib->cleanerSlotIndex == NO_SLOT_INDEX){
                /*
                 *  There is no cleaner slot configured.
                 */
                result = ERROR_CLEANER_SLOT_NOT_SET;   
            }
            else {
                SLOT *slot;

                ASSERT(lib->cleanerSlotIndex < lib->numSlots);
                slot = &lib->slots[lib->cleanerSlotIndex];
                ASSERT(slot->isCleanerSlot);
                
                if (slot->insertedMedia){
                    result = ERROR_RESOURCE_NOT_AVAILABLE; // BUGBUG ERROR_SLOT_FULL; not defined
                }
                else {
                    slot->isCleanerSlot = FALSE;
                    lib->cleanerSlotIndex = NO_SLOT_INDEX;
                    result = ERROR_SUCCESS;
                }     
            }
            
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_LIBRARY;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI InjectNtmsCleaner( HANDLE hSession,
                                LPNTMS_GUID lpLibraryId,
                                LPNTMS_GUID lpInjectOperation,
                                DWORD dwNumberOfCleansLeft,
                                DWORD dwAction)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){
            
            EnterCriticalSection(&lib->lock);

            /*
             *  The library must have a designated cleaner slot index reserved
             *  in order to receive the cleaner.
             *
             *  BUGBUG - move all these checks to the lib thread.
             */           
            if (lib->cleanerSlotIndex == NO_SLOT_INDEX){
                result = ERROR_CLEANER_SLOT_NOT_SET;
            }
            else {
                SLOT *slot = &lib->slots[lib->cleanerSlotIndex];
                ASSERT(lib->cleanerSlotIndex < lib->numSlots);
                ASSERT(slot->isCleanerSlot);
                if (slot->insertedMedia){
                    result = ERROR_RESOURCE_NOT_AVAILABLE; // BUGBUG ERROR_SLOT_FULL; not defined
                }
                else {

                    if (dwAction == NTMS_INJECT_START){
                        WORKITEM *workItem;

                        workItem = DequeueFreeWorkItem(lib, TRUE);
                        if (workItem){
                            /*
                             *  Build the workItem.
                             */
                            RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
                            workItem->currentOp.opcode = NTMS_LM_INJECTCLEANER;
                            workItem->currentOp.lParam = dwNumberOfCleansLeft;
                            workItem->currentOp.resultStatus = ERROR_IO_PENDING;
                           
                            /*
                             *  Give this workItem to the library and wake up the library thread.
                             */
                            EnqueuePendingWorkItem(workItem->owningLib, workItem);

                            /*
                             *  When we enqueued the workItem in the pending queue,
                             *  it got assigned a requestGuid.  Since we're holding the
                             *  library lock, that workItem hasn't gone anywhere yet.
                             *  So its ok to read out the requestGuid from the workItem.
                             */
                            *lpInjectOperation = workItem->currentOp.requestGuid; 

                            /*
                             *  Wait for the request to be processed by the library thread.
                             *  Note:  The workItem will complete as soon as the library thread
                             *         starts the injection.  The app may cancel the cleaner
                             *         injection using NTMS_INJECT_STOP and the returned GUID.
                             *  BUGBUG ?
                             */
                            WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                            /*
                             *  Get result from the completed workItem.
                             */
                            result = workItem->currentOp.resultStatus;    

                            EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
                        }
                        else {
                            result = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                    else if (dwAction == NTMS_INJECT_STOP){
                        result = StopCleanerInjection(lib, lpInjectOperation);
                    }
                    else {
                        result = ERROR_INVALID_PARAMETER;
                    }
                }
            }
                
            LeaveCriticalSection(&lib->lock);
            
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_LIBRARY;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI EjectNtmsCleaner(  HANDLE hSession,
                                LPNTMS_GUID lpLibraryId,
                                LPNTMS_GUID lpEjectOperation,
                                DWORD dwAction)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){

            EnterCriticalSection(&lib->lock);
            
            if (dwAction == NTMS_EJECT_START){
                WORKITEM *workItem;

                workItem = DequeueFreeWorkItem(lib, TRUE);
                if (workItem){
                    /*
                     *  Build the workItem.
                     */
                    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
                    workItem->currentOp.opcode = NTMS_LM_EJECTCLEANER;
                    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
                           
                    /*
                     *  Give this workItem to the library and wake up the library thread.
                     */
                    EnqueuePendingWorkItem(workItem->owningLib, workItem);

                    /*
                     *  When we enqueued the workItem in the pending queue,
                     *  it got assigned a requestGuid.  Since we're holding the
                     *  library lock, that workItem hasn't gone anywhere yet.
                     *  So its ok to read out the requestGuid from the workItem.
                     */
                    *lpEjectOperation = workItem->currentOp.requestGuid; 

                    /*
                     *  Wait for the request to be processed by the library thread.
                     *  Note:  The workItem will complete as soon as the library thread
                     *         starts the ejection.  The app may cancel the cleaner
                     *         ejection using NTMS_EJECT_STOP and the returned GUID.
                     *  BUGBUG ?
                     */
                    WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                    /*
                     *  Get result from the completed workItem.
                     */
                    result = workItem->currentOp.resultStatus;    

                    EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else if (dwAction == NTMS_EJECT_STOP){
                result = StopCleanerEjection(lib, lpEjectOperation);
            }
            else {
                result = ERROR_INVALID_PARAMETER;
            }

            LeaveCriticalSection(&lib->lock);

            DerefObject(lib);                          
        }
        else {
            result = ERROR_INVALID_LIBRARY;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}        


DWORD WINAPI DeleteNtmsLibrary(HANDLE hSession, LPNTMS_GUID lpLibraryId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){

            result = DeleteLibrary(lib);
            
            /*
             *  Dereference the library due to the reference that happened
             *  when we called FindLibrary.  The library will get deleted
             *  once all references go away.
             */
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_LIBRARY;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DeleteNtmsDrive(HANDLE hSession, LPNTMS_GUID lpDriveId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        DRIVE *drive;

        drive = FindDrive(lpDriveId);
        if (drive){
            
            result = DeleteDrive(drive);

            /*
             *  Dereference the drive due to the reference that happened
             *  when we called FindDrive.  The drive will get deleted
             *  once all references go away.
             */
            DerefObject(drive);
        }
        else {
            result = ERROR_INVALID_DRIVE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI GetNtmsRequestOrder(   HANDLE hSession,
                                    LPNTMS_GUID lpRequestId,
                                    LPDWORD lpdwOrderNumber)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        if (lpRequestId){
            LIST_ENTRY *listEntry;
            
            result = ERROR_INVALID_HANDLE;
            *lpdwOrderNumber = 0;

            EnterCriticalSection(&g_globalServiceLock);
            
            /*
             *  Go through every library and find the pending workItem.
             *  This is HUGELY INEFFICIENT but this is a rare call.
             *  This is better than putting every request into the database.
             */            
            listEntry = &g_allLibrariesList;
            while ((listEntry = listEntry->Flink) != &g_allLibrariesList){
                LIBRARY *lib = CONTAINING_RECORD(listEntry, LIBRARY, allLibrariesListEntry);
                LIST_ENTRY *listEntry2;
                ULONG requestOrder = 1;

                EnterCriticalSection(&lib->lock);
                
                listEntry2 = &lib->pendingWorkItemsList;
                while ((listEntry2 = listEntry2->Flink) != &lib->pendingWorkItemsList){
                    WORKITEM *workItem = CONTAINING_RECORD(listEntry2, WORKITEM, libListEntry);
                    if (RtlEqualMemory(&workItem->currentOp.requestGuid, lpRequestId, sizeof(NTMS_GUID))){
                        *lpdwOrderNumber = requestOrder;
                        result = ERROR_SUCCESS;
                        break;
                    }
                    else {
                        requestOrder++;
                    }
                }

                LeaveCriticalSection(&lib->lock);
                
                if (result == ERROR_SUCCESS){
                    break;
                }
            }
            
            LeaveCriticalSection(&g_globalServiceLock);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsRequestOrder(   HANDLE hSession,
                                    LPNTMS_GUID lpRequestId,
                                    DWORD dwOrderNumber)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI DeleteNtmsRequests(HANDLE hSession,
                                LPNTMS_GUID lpRequestId,
                                DWORD dwType,
                                DWORD dwCount)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI BeginNtmsDeviceChangeDetection(HANDLE hSession, LPHANDLE lpDetectHandle)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}
 
       
DWORD WINAPI SetNtmsDeviceChangeDetection(  HANDLE hSession,
                                            HANDLE DetectHandle,
                                            LPNTMS_GUID lpRequestId,
                                            DWORD dwType,
                                            DWORD dwCount)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI EndNtmsDeviceChangeDetection(HANDLE hSession, HANDLE DetectHandle)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}






/******** BUGBUG: INtmsObjectManagement1 APIs *********************/

DWORD WINAPI GetNtmsObjectSecurity(     HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        DWORD dwType,
                                        SECURITY_INFORMATION RequestedInformation,
                                        PSECURITY_DESCRIPTOR lpSecurityDescriptor,
                                        DWORD nLength,
                                        LPDWORD lpnLengthNeeded)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsObjectSecurity(     HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        DWORD dwType,
                                        SECURITY_INFORMATION SecurityInformation,
                                        PSECURITY_DESCRIPTOR lpSecurityDescriptor)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}
        

DWORD WINAPI GetNtmsObjectAttributeW(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCWSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            LPDWORD lpAttributeSize)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI GetNtmsObjectAttributeA(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            LPDWORD lpAttributeSize)
{
    HRESULT result;
    WCHAR wAttributeName[NTMS_OBJECTNAME_LENGTH];

    AsciiToWChar(wAttributeName, lpAttributeName, NTMS_OBJECTNAME_LENGTH);
    result = GetNtmsObjectAttributeW(   hSession,
                                        lpObjectId,
                                        dwType,
                                        wAttributeName,
                                        lpAttributeData,
                                        lpAttributeSize);
    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsObjectAttributeA(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            DWORD dwAttributeSize)
{
    HRESULT result;
    WCHAR wAttributeName[NTMS_OBJECTNAME_LENGTH];

    AsciiToWChar(wAttributeName, lpAttributeName, NTMS_OBJECTNAME_LENGTH);
    result = SetNtmsObjectAttributeW(   hSession,
                                        lpObjectId,
                                        dwType,
                                        wAttributeName,
                                        lpAttributeData,
                                        dwAttributeSize);
    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsObjectAttributeW(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCWSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            DWORD AttributeSize)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI EnumerateNtmsObject(   HANDLE hSession,
                                    const LPNTMS_GUID lpContainerId,
                                    LPNTMS_GUID lpList,
                                    LPDWORD lpdwListSize,
                                    DWORD dwType,
                                    DWORD dwOptions)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI EnableNtmsObject(HANDLE hSession, DWORD dwType, LPNTMS_GUID lpObjectId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI DisableNtmsObject(HANDLE hSession, DWORD dwType, LPNTMS_GUID lpObjectId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}




/******* BUGBUG: INtmsObjectInfo1 APIs  ****************************/

                    // BUGBUG - these 4 functions have another form with type,size as last args


HRESULT WINAPI GetNtmsServerObjectInformationW( HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONW lpInfo,
                                                int revision)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


HRESULT WINAPI GetNtmsServerObjectInformationA( HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONA lpInfo,
                                                int revision)
{
    HRESULT result;

    if (lpInfo){
        NTMS_OBJECTINFORMATIONW wObjInfo;

        ConvertObjectInfoAToWChar(&wObjInfo, lpInfo);
        result = GetNtmsServerObjectInformationW(hSession, lpObjectId, &wObjInfo, revision);
    }
    else {
        result = ERROR_INVALID_PARAMETER;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


HRESULT WINAPI SetNtmsServerObjectInformationW( HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONW lpInfo,
                                                int revision)\
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


HRESULT WINAPI SetNtmsServerObjectInformationA( HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONA lpInfo,
                                                int revision)
{
    HRESULT result;

    if (lpObjectId && lpInfo){
        NTMS_OBJECTINFORMATIONW wObjInfo;

        ConvertObjectInfoAToWChar(&wObjInfo, lpInfo);
        result = SetNtmsServerObjectInformationW(hSession, lpObjectId, &wObjInfo, revision);
    }
    else {
        result = ERROR_INVALID_PARAMETER;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI CreateNtmsMediaA(      HANDLE hSession,
                                    LPNTMS_OBJECTINFORMATIONA lpMedia,
                                    LPNTMS_OBJECTINFORMATIONA lpList,
                                    DWORD dwOptions)
{
    HRESULT result;

    if (lpMedia && lpList){
        NTMS_OBJECTINFORMATIONW wObjInfoMedia, wObjInfoList;

        ConvertObjectInfoAToWChar(&wObjInfoMedia, lpMedia);
        ConvertObjectInfoAToWChar(&wObjInfoList, lpList);
        result = CreateNtmsMediaW(hSession, &wObjInfoMedia, &wObjInfoList, dwOptions);
    }
    else {
        result = ERROR_INVALID_PARAMETER;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI CreateNtmsMediaW(      HANDLE hSession,
                                    LPNTMS_OBJECTINFORMATIONW lpMedia,
                                    LPNTMS_OBJECTINFORMATIONW lpList,
                                    DWORD dwOptions)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}



DWORD WINAPI GetNtmsObjectInformationA( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONA lpInfo)
{
    HRESULT result;

    if (lpInfo){
        NTMS_OBJECTINFORMATIONW wObjInfo;

        ConvertObjectInfoAToWChar(&wObjInfo, lpInfo);
        result = GetNtmsObjectInformationW(hSession, lpObjectId, &wObjInfo);
    }
    else {
        result = ERROR_INVALID_PARAMETER;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI GetNtmsObjectInformationW( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONW lpInfo)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        if (lpObjectId && lpInfo){

            // BUGBUG FINISH

            result = ERROR_SUCCESS;
        }
        else {
            result = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsObjectInformationA( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONA lpInfo)
{
    HRESULT result;

    if (lpInfo){
        NTMS_OBJECTINFORMATIONW wObjInfo;

        ConvertObjectInfoAToWChar(&wObjInfo, lpInfo);
        result = SetNtmsObjectInformationW(hSession, lpObjectId, &wObjInfo);
    }
    else {
        result = ERROR_INVALID_PARAMETER;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsObjectInformationW( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONW lpInfo)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        if (lpObjectId && lpInfo){

            // BUGBUG FINISH
            result = ERROR_SUCCESS;
        }
        else {
            result = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


HANDLE WINAPI OpenNtmsNotification(HANDLE hSession, DWORD dwType)
{
    HANDLE hNotify;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH
        hNotify = NULL;
    }
    else {
        SetLastError(ERROR_INVALID_HANDLE);
        hNotify = NULL;
    }

    return hNotify;
}


DWORD WINAPI WaitForNtmsNotification(   HANDLE hNotification,
                                        LPNTMS_NOTIFICATIONINFORMATION lpNotificationInformation,
                                        DWORD dwTimeout)
{
    HRESULT result;

    // BUGBUG FINISH
    result = ERROR_SUCCESS;

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI CloseNtmsNotification(HANDLE hNotification)
{
    HRESULT result;

    // BUGBUG FINISH
    result = ERROR_SUCCESS;

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}



DWORD WINAPI EjectDiskFromSADriveA( LPCSTR lpComputerName,
                                    LPCSTR lpAppName,
                                    LPCSTR lpDeviceName,
                                    HWND hWnd,
                                    LPCSTR lpTitle,
                                    LPCSTR lpMessage,
                                    DWORD dwOptions)
{
    HRESULT result;

    // BUGBUG FINISH
    result = ERROR_SUCCESS;

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI EjectDiskFromSADriveW( LPCWSTR lpComputerName,
                                    LPCWSTR lpAppName,
                                    LPCWSTR lpDeviceName,
                                    HWND hWnd,
                                    LPCWSTR lpTitle,
                                    LPCWSTR lpMessage,
                                    DWORD dwOptions)
{
    HRESULT result;

    // BUGBUG FINISH
    result = ERROR_SUCCESS;

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI GetVolumesFromDriveA(  LPSTR pszDriveName,
                                    LPSTR* VolumeNameBufferPtr,
                                    LPSTR* DriveLetterBufferPtr)
{
    HRESULT result;

    // BUGBUG FINISH
    result = ERROR_SUCCESS;

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI GetVolumesFromDriveW(  LPWSTR pszDriveName,
                                    LPWSTR *VolumeNameBufferPtr,
                                    LPWSTR *DriveLetterBufferPtr)
{
    HRESULT result;

    // BUGBUG FINISH
    result = ERROR_SUCCESS;

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI IdentifyNtmsSlot(HANDLE hSession, LPNTMS_GUID lpSlotId, DWORD dwOption)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI GetNtmsUIOptionsA( HANDLE hSession,
                                const LPNTMS_GUID lpObjectId,
                                DWORD dwType,
                                LPSTR lpszDestination,
                                LPDWORD lpAttributeSize)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI GetNtmsUIOptionsW( HANDLE hSession,
                                const LPNTMS_GUID lpObjectId,
                                DWORD dwType,
                                LPWSTR lpszDestination,
                                LPDWORD lpdwSize)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsUIOptionsA( HANDLE hSession,
                                const LPNTMS_GUID lpObjectId,
                                DWORD dwType,
                                DWORD dwOperation,
                                LPCSTR lpszDestination)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsUIOptionsW( HANDLE hSession,
                                const LPNTMS_GUID lpObjectId,
                                DWORD dwType,
                                DWORD dwOperation,
                                LPCWSTR lpszDestination)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\pool.c ===
/*
 *  POOL.C
 *
 *      RSM Service :  Media Pools
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"



MEDIA_POOL *NewMediaPool(LPCWSTR name, LPNTMS_GUID mediaType, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    MEDIA_POOL *newMediaPool;
    
    newMediaPool = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(MEDIA_POOL));
    if (newMediaPool){
        
        newMediaPool->newMediaEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (newMediaPool->newMediaEvent){
            
            WStrNCpy(newMediaPool->name, name, NTMS_OBJECTNAME_LENGTH);
            InitializeCriticalSection(&newMediaPool->lock);

            newMediaPool->objHeader.objType = OBJECTTYPE_MEDIAPOOL;
            newMediaPool->objHeader.refCount = 1;
            
            // BUGBUG FINISH
        }
        else {
            GlobalFree(newMediaPool);
            newMediaPool = NULL;
        }
    }

    ASSERT(newMediaPool);
    return newMediaPool;
}


/*
 *  DestroyMediaPool
 *
 *      Actually delete a media pool.
 *      Assumes that there are no remaining references on the pool, etc.
 */
VOID DestroyMediaPool(MEDIA_POOL *mediaPool)
{

    // BUGBUG FINISH
    DeleteCriticalSection(&mediaPool->lock);
    GlobalFree(mediaPool);
}


MEDIA_POOL *FindMediaPool(LPNTMS_GUID mediaPoolId)
{
    MEDIA_POOL *foundMediaPool = NULL;

    if (mediaPoolId){
        OBJECT_HEADER *objHdr;
        
        objHdr = FindObjectInGuidHash(mediaPoolId);
        if (objHdr){
            if (objHdr->objType == OBJECTTYPE_MEDIAPOOL){
                foundMediaPool = (MEDIA_POOL *)objHdr;
            }
            else {
                DerefObject(objHdr);
            }
        }
    }
    
    return foundMediaPool;
}


MEDIA_POOL *FindMediaPoolByName(PWSTR poolName)
{
    MEDIA_POOL *mediaPool = NULL;
    LIST_ENTRY *listEntry;

    EnterCriticalSection(&g_globalServiceLock);

    listEntry = &g_allLibrariesList;
    while ((listEntry = listEntry->Flink) != &g_allLibrariesList){
        LIBRARY *lib = CONTAINING_RECORD(listEntry, LIBRARY, allLibrariesListEntry);
        mediaPool = FindMediaPoolByNameInLibrary(lib, poolName);
        if (mediaPool){
            break;
        }
    }

    LeaveCriticalSection(&g_globalServiceLock);

    return mediaPool;
}


MEDIA_POOL *FindMediaPoolByNameInLibrary(LIBRARY *lib, PWSTR poolName)
{
    MEDIA_POOL *mediaPool = NULL;
    LIST_ENTRY *listEntry;

    EnterCriticalSection(&lib->lock);

    listEntry = &lib->mediaPoolsList;
    while ((listEntry = listEntry->Flink) != &lib->mediaPoolsList){
        MEDIA_POOL *thisMediaPool = CONTAINING_RECORD(listEntry, MEDIA_POOL, mediaPoolsListEntry);
        if (WStringsEqualN(thisMediaPool->name, poolName, FALSE, NTMS_OBJECTNAME_LENGTH)){
            mediaPool = thisMediaPool;
            RefObject(mediaPool);
            break;
        }
    }
    
    LeaveCriticalSection(&lib->lock);
    
    return mediaPool;
}


HRESULT DeleteMediaPool(MEDIA_POOL *mediaPool)
{
    HRESULT result;
    
    EnterCriticalSection(&mediaPool->lock);

    /*
     *  The pool can only be deleted if it is empty and has no
     *  child pools.
     */
    if (mediaPool->numPhysMedia || mediaPool->numChildPools){
        result = ERROR_NOT_EMPTY;
    }
    else if (mediaPool->objHeader.isDeleted){
        /*
         *  Already deleted.  Do nothing.
         */
        result = ERROR_SUCCESS;
    }
    else {
        /*
         *  If the mediaPool can be deleted, mark it as deleted and
         *  dereference it.
         *  This will cause no new references to be opened on it
         *  and will cause it to actually get deleted once all existing
         *  references go away.
         *  We can still use our mediaPool pointer because the caller 
         *  has a reference on it (by virtue of having a pointer).
         */
        mediaPool->objHeader.isDeleted = TRUE;
        DerefObject(mediaPool);
        result = ERROR_SUCCESS;
    }

    LeaveCriticalSection(&mediaPool->lock);
    
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\resource.h ===
/*
 *  RESOURCE.H
 *
 *      RSM Service :  Resources header
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


/*
 *  Identifiers for icons
 */
#define IDI_MOUNT_ICON      1                          
#define IDI_OPREQ_ICON      2


/*
 *  Identifiers for localizable string resources
 */
#define IDS_LMPROCFAILED__FORMAT						101
#define IDS_LMCLASSIFY                                  102
#define IDS_LMCLEANDRIVE                                103
#define IDS_LMDISABLECHANGER							104
#define IDS_LMENABLECHANGER                             105
#define IDS_LMDISABLEMEDIA                              106
#define IDS_LMENABLEMEDIA                               107
#define IDS_LMDISABLEDRIVE                              108
#define IDS_LMENABLEDRIVE                               109
#define IDS_LMEJECT                                     110
#define IDS_LMINJECT                                    111
#define IDS_LMDOORACCESS                                112
#define IDS_LMMOUNT                                     113
#define IDS_LMDISMOUNT                                  114
#define IDS_LMINVENTORY                                 115
#define IDS_LMSTOPINVENTORY                             116
#define IDS_LMREMOVE                                    117
#define IDS_LMUPDATEOMID                                120
#define IDS_LMWRITESCRATCH                              121
#define IDS_LMRESERVECLEANER                            122
#define IDS_LMRELEASECLEANER                            123
#define IDS_LMINJECTCLEANER                             124
#define IDS_LMEJECTCLEANER                              125

#define IDS_OPREQUESTNEWMEDIA                           200
#define IDS_OPREQUESTCLEANER                            201
#define IDS_OPREQ_DRIVE_NEEDS_CLEANING__FORMAT          202
#define IDS_OPREQ_DRIVE_DIRTY                           203
#define IDS_OPREQ_NEEDS_NEW_CLEANER__FORMAT             204
#define IDS_OPREQ_REPLACE_CLEANER                       205
#define IDS_OPREQUESTDEVICESVC                          206
#define IDS_OPREQUESTMOVEMEDIA                          207
#define IDS_OPREQUESTMESSAGE                            208

#define IDS_SERVICE_STOPPED                             301
#define IDS_SERVICE_RUNNING                             302
#define IDS_SERVICE_START_PENDING                       303
#define IDS_SERVICE_STOP_PENDING                        304
#define IDS_SERVICE_CONTINUE_PENDING                    305
#define IDS_SERVICE_PAUSE_PENDING                       306
#define IDS_SERVICE_PAUSED                              307
#define IDS_SERVICE_UNKNOWN                             308
#define IDS_OPREQ_CFGFAIL_NAME                          309
#define IDS_OPREQ_CFGFAIL__FORMAT                       310

#define IDS_OPREQ_MANUALCFG_ALERT__FORMAT               401
#define IDS_OPREQ_MANUALCFG_ALERT_NAME                  402
#define IDS_OPREQ_NO_DEVICE_NUMBER__FORMAT              403

#define IDS_DATABASE                                    501
#define IDS_DATABASE_PROBLEM                            502
#define IDS_SCSI_PORT                                   503
#define IDS_SCSI_BUS                                    504
#define IDS_TARGET_ID                                   505
#define IDS_LUID                                        506
#define IDS_UNIT                                        507

#define IDS_WRITESCRATCH_FAILED__FORMAT                 601
#define IDS_WRITESCRATCH_FAILED_NAME                    602
#define IDS_OPENDOOR_MSG__FORMAT                        603
#define IDS_OPENDOOR                                    604
#define IDS_CLOSEDOOR_MSG__FORMAT                       605
#define IDS_CLOSEDOOR                                   606
#define IDS_INSERT_CLEANER                              607
#define IDS_INSERT_CLEANER_MSG__FORMAT                  608
#define IDS_PROCESS_OMID                                609
#define IDS_BACK_BACK_DOT_BACK                          610
#define IDS_MOUNTMESSAGE__FORMAT                        611
#define IDS_ADDMEDIAMESSAGE__FORMAT                     612
#define IDS_ADDFREEMEDIAMESSAGE__FORMAT                 613
#define IDS_NEW_CLEANER_NEEDED_MSG__FORMAT              614
#define IDS_NEW_CLEANER_NEEDED                          615
#define IDS_CLOSE_PORT_MSG__FORMAT                      616
#define IDS_CLOSE_PORT                                  617    


#define IDS_INJECTMEDIAMESSAGE__FORMAT                  801
#define IDS_INJECTMULTISIDEDMEDIA_MSG__FORMAT           802
#define IDS_OVERFILLED_LIB_MSG__FORMAT                  803
#define IDS_OVERFILLED_LIB                              804
#define IDS_INVALID_MEDIA_MSG__FORMAT                   805
#define IDS_INVALID_MEDIA                               806
#define IDS_CHANGER_INOPERABLE                          807
#define IDS_CHANGER_INOPERABLE_MSG__FORMAT              808
#define IDS_OVERFILLED_EJECT                            809
#define IDS_OVERFILLED_EJECT_MSG__FORMAT                810
#define IDS_INJECT_CLEANER_MSG__FORMAT                  811
#define IDS_INJECT_CLEANER                              812

#define IDS_LIBTIP                                      901
#define IDS_LIBINFO                                     902
#define IDS_OPTIP                                       903
#define IDS_OPINFO                                      904
#define IDS_STATIC_USER                                 905
#define IDS_MESG_BUSY                                   906
#define IDS_MESG_NOT_AVAILABLE                          907
#define IDS_MESG_UNABLE_TO_UNLOAD                       908
#define IDS_MESG_UNEXPECTED_OMID                        909
#define IDS_MESG_UNKNOWN                                910
#define IDS_INFO_BUSY__FORMAT                           911
#define IDS_INFO_NOT_AVAILABLE__FORMAT                  912
#define IDS_INFO_UNABLE_TO_UNLOAD__FORMAT               913    
#define IDS_INFO_UNEXPECTED_OMID__FORMAT                914
#define IDS_INFO_UNKNOWN__FORMAT                        915
#define IDS_STATIC_SUGGESTION__FORMAT                   916
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\service.c ===
/*
 *  SERVICE.C
 *
 *      Entrypoint for RSM Service 
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"




DWORD RSMServiceHandler(	IN DWORD dwOpcode,
							IN DWORD dwEventType,
							IN PVOID pEventData,
							IN PVOID pData)
{
    DWORD status = NO_ERROR;

    switch (dwOpcode){

        case SERVICE_CONTROL_STOP:
            break;

        case SERVICE_CONTROL_PAUSE:
            break;

        case SERVICE_CONTROL_CONTINUE:
            break;

        case SERVICE_CONTROL_INTERROGATE:
            break;

        case SERVICE_CONTROL_SHUTDOWN:
            break;

        case SERVICE_CONTROL_PARAMCHANGE:
            break;

        case SERVICE_CONTROL_DEVICEEVENT:
            break;

        case SERVICE_CONTROL_NETBINDREMOVE:
            break;

        default:
            break;

    }

    return status;
}


BOOL InitializeRSMService()
{
    BOOL result = FALSE;
    DWORD dwStatus;

    InitGuidHash();

    StartLibraryManager();


    // BUGBUG FINISH
    // create global events
    // Initialize Device Notifications (InitializeDeviceNotClass)
    // WMI initialization (WmiOpenBlock, etc)

    /*
     *  Populate the RSM database with default objects.
     */
    #if 0       // BUGBUG FINISH
        dwStatus = NtmsDbInstall();
        if ((dwStatus == ERROR_SUCCESS) || (dwStatus == ERROR_ALREADY_EXISTS)){

            // BUGBUG FINISH
            result = TRUE;
        }
        else {
        }
    #endif

    return result;
}


VOID ShutdownRSMService()
{


}


VOID RSMServiceLoop()
{
    MSG msg;

    /*
     *  Loop in message pump
     *  Unlike an app window's message pump, 
     *  a NULL-window message pump dispatches messages posted to
     *  the current thread via PostThreadMessage().
     */
    while (GetMessage(&msg, NULL, 0, 0)){
        DispatchMessage(&msg);
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\session.c ===
/*
 *  SESSION.C
 *
 *      RSM Service :  Sessions
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


SESSION *NewSession(LPCWSTR lpServer, 
                    LPCWSTR lpApplication,
                    LPCWSTR lpClientName,
                    LPCWSTR lpUserName)
{
    SESSION *newSession;

    newSession = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(SESSION));
    if (newSession){

        newSession->sig = SESSION_SIG;

        InitializeCriticalSection(&newSession->lock);
        InitializeListHead(&newSession->operatorRequestList);
        InitializeListHead(&newSession->allSessionsListEntry);

        WStrNCpy(newSession->serverName, lpServer, NTMS_COMPUTERNAME_LENGTH);
        WStrNCpy(newSession->applicationName, lpApplication, NTMS_APPLICATIONNAME_LENGTH);
        WStrNCpy(newSession->clientName, lpClientName, NTMS_COMPUTERNAME_LENGTH);
        WStrNCpy(newSession->userName, lpUserName, NTMS_USERNAME_LENGTH);

        EnterCriticalSection(&g_globalServiceLock);
        InsertTailList(&g_allSessionsList, &newSession->allSessionsListEntry);
        LeaveCriticalSection(&g_globalServiceLock);
    }
    else {
        ASSERT(newSession);
    }

    return newSession;
}


VOID FreeSession(SESSION *thisSession)
{
    // BUGBUG FINISH - clean up mounts, etc.

    ASSERT(IsEmptyList(&s->operatorRequestList));

    /*
     *  Dequeue the session
     */
    EnterCriticalSection(&g_globalServiceLock);
    ASSERT(!IsEmptyList(&thisSession->allSessionsListEntry));
    ASSERT(!IsEmptyList(&g_allSessionsList));
    RemoveEntryList(&thisSession->allSessionsListEntry);
    InitializeListHead(&thisSession->allSessionsListEntry);
    LeaveCriticalSection(&g_globalServiceLock);

    DeleteCriticalSection(&thisSession->lock);
    
    GlobalFree(thisSession);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\svcapi.c ===
/*
 *  SVCAPI.C
 *
 *      Interfaces for RSM Service
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"



STDAPI DllRegisterServer(void)
{
    HRESULT hres;

    // BUGBUG FINISH
    hres = S_OK;

    return hres;
}


STDAPI DllUnregisterServer(void)
{
    HRESULT hres;

    // BUGBUG FINISH
    hres = S_OK;

    return hres;
}


VOID WINAPI ServiceMain(DWORD dwNumServiceArgs, LPWSTR *lpServiceArgVectors)
{
    SERVICE_STATUS_HANDLE hService;

    ASSERT(g_hInstance);

    hService = RegisterServiceCtrlHandlerEx("NtmsSvc", RSMServiceHandler, 0);
    if (hService){
        BOOL ok;

        ok = InitializeRSMService();
        if (ok){

            /*
             *  WAIT HERE UNTIL SERVICE TERMINATES
             */
            WaitForSingleObject(g_terminateServiceEvent, INFINITE);
        }

        ShutdownRSMService();
    }

}


// BUGBUG - how does old ntmssvc's DllMain get called 
//          without being declared in the .def file ?
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason){
        case DLL_PROCESS_ATTACH:
            /*
             *  This service DLL has its own process space,
             *  so it should only get once instance handle ever.
             *  BUGBUG -- is this right ?
             */
            ASSERT(!g_hInstance || (hInstance == g_hInstance));
            g_hInstance = hInstance;
            break;  

        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\validate.c ===
/*
 *  VALIDATE.C
 *
 *      RSM Service :  Handle validation code
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"



#pragma optimize("agpswy", off)
BOOL ValidateSessionHandle(HANDLE hSession)
{
    BOOL ok;

    /*
     *  The server runs in its own context.
     *  So just need to validate:
     *      (1) its our context (we can write to it), and
     *      (2) its a session context (not another one of our contexts)
     */
    __try {
        SESSION *s = (SESSION *)hSession;
        ok = (s->sig == SESSION_SIG);
    }
    __except (EXCEPTION_EXECUTE_HANDLER){
        DWORD exceptionCode = GetExceptionCode();
        ok = FALSE;
        DBGERR(("invalid session handle (%xh) (code=%xh)", hSession, exceptionCode));
    }

    return ok;
}
#pragma optimize("agpswy", on)  // BUGBUG - how to set back to 'default' ?


#pragma optimize("agpswy", off)
BOOL ValidateWStr(LPCWSTR ws)
{
    BOOL ok;

    __try {
        while (*ws++);
        ok = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER){
        DWORD exceptionCode = GetExceptionCode();
        ok = FALSE;
        DBGERR(("invalid string arg (code=%xh)", exceptionCode));
    }

    return ok;
}
#pragma optimize("agpswy", on)  // BUGBUG - how to set back to 'default' ?


#pragma optimize("agpswy", off)
BOOL ValidateAStr(LPCSTR s)
{
    BOOL ok;

    __try {
        while (*s++);
        ok = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER){
        DWORD exceptionCode = GetExceptionCode();
        ok = FALSE;
        DBGERR(("invalid string arg (code=%xh)", exceptionCode));
    }

    return ok;
}
#pragma optimize("agpswy", on)  // BUGBUG - how to set back to 'default' ?

#pragma optimize("agpswy", off)
BOOL ValidateBuffer(PVOID buf, ULONG len)
{
    PUCHAR bufPtr = (PUCHAR) buf;
    BOOL ok;

    __try {
        while (len > 0){
            *bufPtr = *bufPtr;
        }
        ok = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER){
        DWORD exceptionCode = GetExceptionCode();
        ok = FALSE;
        DBGERR(("invalid buffer (code=%xh)", exceptionCode));
    }

    return ok;
}
#pragma optimize("agpswy", on)  // BUGBUG - how to set back to 'default' ?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\util.c ===
/*
 *  UTIL.C
 *
 *      RSM Service :  Utilities
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"




/*
 *  WStrNCpy
 *
 *      Like wcsncpy, but terminates the string if truncated.
 *      Also, tolerates NULL src string.
 */
ULONG WStrNCpy(WCHAR *dest, const WCHAR *src, ULONG maxWChars)
{
    ULONG wCharsWritten = 0;

    ASSERT(dest);

    if (src){
        while ((maxWChars-- > 1) && (*dest++ = *src++)){
            wCharsWritten++;
        }
        if (maxWChars == 1){
            *dest = (WCHAR)NULL;
            wCharsWritten++;
        }
    }
    else {
        *dest = (WCHAR)NULL;
        wCharsWritten++;
    }

    return wCharsWritten;
}


/*
 *  AsciiToWChar
 *
 *      Like mbstowcs, but terminates the string if truncated.
 *      Also, tolerates NULL ascii string.
 */
ULONG AsciiToWChar(WCHAR *dest, const char *src, ULONG maxChars)
{
    ULONG charsWritten = 0;

    if (src){
        while ((maxChars-- > 1) && (*dest++ = (WCHAR)*src++)){
            charsWritten++;
        }
        if (maxChars == 1){
            *dest = (WCHAR)NULL;
            charsWritten++;
        }
    }
    else {
        *dest = (WCHAR)NULL;
        charsWritten++;
    }

    return charsWritten;
}


/*
 *  WCharToAscii
 *
 *      Reverse of AsciiToWChar.
 *      Terminates the string if truncated.
 *      Also, tolerates NULL wchar string.
 */
ULONG WCharToAscii(char *dest, WCHAR *src, ULONG maxChars)
{
    ULONG charsWritten = 0;

    if (src){
        while ((maxChars-- > 1) && (*dest++ = (char)(unsigned char)*src++)){
            charsWritten++;
        }
        if (maxChars == 1){
            *dest = (char)NULL;
            charsWritten++;
        }
    }
    else {
        *dest = (char)NULL;
        charsWritten++;
    }

    return charsWritten;
}


/*
 *  WStringsEqual
 *
 *      Like RtlEqualString (but ntrtl.h doesn't compile with our other headers).
 */
BOOL WStringsEqualN(PWCHAR s, PWCHAR p, BOOL caseSensitive, ULONG maxLen)
{
    BOOL result = TRUE;

    while (maxLen > 0){
        if (!*s && !*p){
            break;
        }
        else if (!*s || !*p){
            result = FALSE;
            break;
        }
        else if (caseSensitive){
            if (*s != *p){
                result = FALSE;
                break;
            }
        }
        else {
            if ((*s | 0x20) != (*p | 0x20)){
                result = FALSE;
                break;
            }
        }
        s++, p++;
        maxLen--;
    }

    return result;
}

/*
 *  ConvertObjectInfoAToWChar
 *
 *      Just converts the NTMS_OBJECTINFORMATION structure and all its parts
 *      from ascii to wide-char.
 */
VOID ConvertObjectInfoAToWChar(LPNTMS_OBJECTINFORMATIONW wObjInfo, LPNTMS_OBJECTINFORMATIONA aObjInfo)
{
    wObjInfo->dwSize = aObjInfo->dwSize;
    wObjInfo->dwType = aObjInfo->dwType;
    wObjInfo->Created = aObjInfo->Created;
    wObjInfo->Modified = aObjInfo->Modified;
    wObjInfo->ObjectGuid = aObjInfo->ObjectGuid;
    wObjInfo->Enabled = aObjInfo->Enabled;
    wObjInfo->dwOperationalState = aObjInfo->dwOperationalState;
    AsciiToWChar(wObjInfo->szName, aObjInfo->szName, NTMS_OBJECTNAME_LENGTH);
    AsciiToWChar(wObjInfo->szDescription, aObjInfo->szDescription, NTMS_OBJECTNAME_LENGTH);

    /*
     *  Convert the Union portion of the structure, based on its 'union' type.
     */
    switch (aObjInfo->dwType){
        case NTMS_DRIVE:
            {
                NTMS_DRIVEINFORMATIONA *driveInfoA = &aObjInfo->Info.Drive;
                NTMS_DRIVEINFORMATIONW *driveInfoW = &wObjInfo->Info.Drive;
                driveInfoW->Number = driveInfoA->Number;
                driveInfoW->State = driveInfoA->State;
                driveInfoW->DriveType = driveInfoA->DriveType;
                AsciiToWChar(driveInfoW->szDeviceName, driveInfoA->szDeviceName, sizeof(driveInfoA->szDeviceName));
                AsciiToWChar(driveInfoW->szSerialNumber, driveInfoA->szSerialNumber, sizeof(driveInfoA->szSerialNumber));
                AsciiToWChar(driveInfoW->szRevision, driveInfoA->szRevision, sizeof(driveInfoA->szRevision));
                driveInfoW->ScsiPort = driveInfoA->ScsiPort;
                driveInfoW->ScsiBus = driveInfoA->ScsiBus;
                driveInfoW->ScsiTarget = driveInfoA->ScsiTarget;
                driveInfoW->ScsiLun = driveInfoA->ScsiLun;
                driveInfoW->dwMountCount = driveInfoA->dwMountCount;
                driveInfoW->LastCleanedTs = driveInfoA->LastCleanedTs;
                driveInfoW->SavedPartitionId = driveInfoA->SavedPartitionId;
                driveInfoW->Library = driveInfoA->Library;
                driveInfoW->Reserved = driveInfoA->Reserved;
                driveInfoW->dwDeferDismountDelay = driveInfoA->dwDeferDismountDelay;
            }
            break;
        case NTMS_DRIVE_TYPE:
            {
                NTMS_DRIVETYPEINFORMATIONA *driveTypeInfoA = &aObjInfo->Info.DriveType;
                NTMS_DRIVETYPEINFORMATIONW *driveTypeInfoW = &wObjInfo->Info.DriveType;
                AsciiToWChar(driveTypeInfoW->szVendor, driveTypeInfoA->szVendor, sizeof(driveTypeInfoA->szVendor));
                AsciiToWChar(driveTypeInfoW->szProduct, driveTypeInfoA->szProduct, sizeof(driveTypeInfoA->szVendor));
                driveTypeInfoW->NumberOfHeads = driveTypeInfoA->NumberOfHeads;
                driveTypeInfoW->DeviceType = driveTypeInfoA->DeviceType;
            }
            break;
        case NTMS_LIBRARY:
            {
                NTMS_LIBRARYINFORMATION *libInfoA = &aObjInfo->Info.Library;
                NTMS_LIBRARYINFORMATION *libInfoW = &wObjInfo->Info.Library;
                *libInfoW = *libInfoA;
            }
            break;
        case NTMS_CHANGER:
            {
                NTMS_CHANGERINFORMATIONA *changerInfoA = &aObjInfo->Info.Changer;
                NTMS_CHANGERINFORMATIONW *changerInfoW = &wObjInfo->Info.Changer;
                changerInfoW->Number = changerInfoA->Number;
                changerInfoW->ChangerType = changerInfoA->ChangerType;
                AsciiToWChar(changerInfoW->szSerialNumber, changerInfoA->szSerialNumber, sizeof(changerInfoA->szSerialNumber));
                AsciiToWChar(changerInfoW->szRevision, changerInfoA->szRevision, sizeof(changerInfoA->szRevision));
                AsciiToWChar(changerInfoW->szDeviceName, changerInfoA->szDeviceName, sizeof(changerInfoA->szDeviceName));
                changerInfoW->ScsiPort = changerInfoA->ScsiPort;
                changerInfoW->ScsiBus = changerInfoA->ScsiBus;
                changerInfoW->ScsiTarget = changerInfoA->ScsiTarget;
                changerInfoW->ScsiLun = changerInfoA->ScsiLun;
                changerInfoW->Library = changerInfoA->Library;
            }
            break;
        case NTMS_CHANGER_TYPE:
            {
                NTMS_CHANGERTYPEINFORMATIONA *changerTypeInfoA = &aObjInfo->Info.ChangerType;
                NTMS_CHANGERTYPEINFORMATIONW *changerTypeInfoW = &wObjInfo->Info.ChangerType;
                AsciiToWChar(changerTypeInfoW->szVendor, changerTypeInfoA->szVendor, sizeof(changerTypeInfoA->szVendor));
                AsciiToWChar(changerTypeInfoW->szProduct, changerTypeInfoA->szProduct, sizeof(changerTypeInfoA->szProduct));
                changerTypeInfoW->DeviceType = changerTypeInfoA->DeviceType;
            }
            break;
        case NTMS_STORAGESLOT:
            {
                NTMS_STORAGESLOTINFORMATION *slotInfoA = &aObjInfo->Info.StorageSlot;
                NTMS_STORAGESLOTINFORMATION *slotInfoW = &wObjInfo->Info.StorageSlot;
                *slotInfoW = *slotInfoA;
            }
            break;
         case NTMS_IEDOOR:
            {
                NTMS_IEDOORINFORMATION *ieDoorA = &aObjInfo->Info.IEDoor;
                NTMS_IEDOORINFORMATION *ieDoorW = &wObjInfo->Info.IEDoor;
                *ieDoorW = *ieDoorA;
            }
            break;
        case NTMS_IEPORT:
            {
                NTMS_IEPORTINFORMATION *iePortA = &aObjInfo->Info.IEPort;
                NTMS_IEPORTINFORMATION *iePortW = &wObjInfo->Info.IEPort;
                *iePortW = *iePortA;
            }
            break;
        case NTMS_PHYSICAL_MEDIA:
            {
                NTMS_PMIDINFORMATIONA *physMediaA = &aObjInfo->Info.PhysicalMedia;
                NTMS_PMIDINFORMATIONW *physMediaW = &wObjInfo->Info.PhysicalMedia;
                physMediaW->CurrentLibrary = physMediaA->CurrentLibrary;
                physMediaW->MediaPool = physMediaA->MediaPool;
                physMediaW->Location = physMediaA->Location;
                physMediaW->LocationType = physMediaA->LocationType;
                physMediaW->MediaType = physMediaA->MediaType;
                physMediaW->HomeSlot = physMediaA->HomeSlot;
                AsciiToWChar(physMediaW->szBarCode, physMediaA->szBarCode, sizeof(physMediaA->szBarCode));
                physMediaW->BarCodeState = physMediaA->BarCodeState;
                AsciiToWChar(physMediaW->szSequenceNumber, physMediaA->szSequenceNumber, sizeof(physMediaA->szSequenceNumber));
                physMediaW->MediaState = physMediaA->MediaState;
                physMediaW->dwNumberOfPartitions = physMediaA->dwNumberOfPartitions;
                physMediaW->dwMediaTypeCode = physMediaA->dwMediaTypeCode;
                physMediaW->dwDensityCode = physMediaA->dwDensityCode;
                physMediaW->MountedPartition = physMediaA->MountedPartition;
            }
            break;
        case NTMS_LOGICAL_MEDIA:
            {
                NTMS_LMIDINFORMATION *logMediaA = &aObjInfo->Info.LogicalMedia;
                NTMS_LMIDINFORMATION *logMediaW = &wObjInfo->Info.LogicalMedia;
                *logMediaW = *logMediaA;
            }
            break;
        case NTMS_PARTITION:
            {
                NTMS_PARTITIONINFORMATIONA *partitionInfoA = &aObjInfo->Info.Partition;
                NTMS_PARTITIONINFORMATIONW *partitionInfoW = &wObjInfo->Info.Partition;
                memcpy(&partitionInfoW->PhysicalMedia, &partitionInfoA->PhysicalMedia, sizeof(partitionInfoA->PhysicalMedia));
                memcpy(&partitionInfoW->LogicalMedia, &partitionInfoA->LogicalMedia, sizeof(partitionInfoA->LogicalMedia));
                partitionInfoW->State = partitionInfoA->State;
                partitionInfoW->Side = partitionInfoA->Side;
                partitionInfoW->dwOmidLabelIdLength = partitionInfoA->dwOmidLabelIdLength;
                memcpy(partitionInfoW->OmidLabelId, partitionInfoA->OmidLabelId, sizeof(partitionInfoA->OmidLabelId));
                AsciiToWChar(partitionInfoW->szOmidLabelType, partitionInfoA->szOmidLabelType, sizeof(partitionInfoA->szOmidLabelType));
                AsciiToWChar(partitionInfoW->szOmidLabelInfo, partitionInfoA->szOmidLabelInfo, sizeof(partitionInfoA->szOmidLabelInfo));
                partitionInfoW->dwMountCount = partitionInfoA->dwMountCount;
                partitionInfoW->dwAllocateCount = partitionInfoA->dwAllocateCount;
                partitionInfoW->Capacity = partitionInfoA->Capacity;
            }
            break;
        case NTMS_MEDIA_POOL:
            {
                NTMS_MEDIAPOOLINFORMATION *mediaPoolInfoA = &aObjInfo->Info.MediaPool;
                NTMS_MEDIAPOOLINFORMATION *mediaPoolInfoW = &wObjInfo->Info.MediaPool;
                *mediaPoolInfoW = *mediaPoolInfoA;
            }
            break;
        case NTMS_MEDIA_TYPE:
            {
                NTMS_MEDIATYPEINFORMATION *mediaTypeInfoA = &aObjInfo->Info.MediaType;
                NTMS_MEDIATYPEINFORMATION *mediaTypeInfoW = &wObjInfo->Info.MediaType;
                *mediaTypeInfoW = *mediaTypeInfoA;
            }
            break;
        case NTMS_LIBREQUEST:
            {
                NTMS_LIBREQUESTINFORMATIONA *libReqInfoA = &aObjInfo->Info.LibRequest;
                NTMS_LIBREQUESTINFORMATIONW *libReqInfoW = &wObjInfo->Info.LibRequest;
                libReqInfoW->OperationCode = libReqInfoA->OperationCode;
                libReqInfoW->OperationOption = libReqInfoA->OperationOption;
                libReqInfoW->State = libReqInfoA->State;
                memcpy(&libReqInfoW->PartitionId, &libReqInfoA->PartitionId, sizeof(NTMS_GUID));
                memcpy(&libReqInfoW->DriveId, &libReqInfoA->DriveId, sizeof(NTMS_GUID));
                memcpy(&libReqInfoW->PhysMediaId, &libReqInfoA->PhysMediaId, sizeof(NTMS_GUID));
                memcpy(&libReqInfoW->Library, &libReqInfoA->Library, sizeof(NTMS_GUID));
                memcpy(&libReqInfoW->SlotId, &libReqInfoA->SlotId, sizeof(NTMS_GUID));
                libReqInfoW->TimeQueued = libReqInfoA->TimeQueued;
                libReqInfoW->TimeCompleted = libReqInfoA->TimeCompleted;
                AsciiToWChar(libReqInfoW->szApplication, libReqInfoA->szApplication, sizeof(libReqInfoA->szApplication));
                AsciiToWChar(libReqInfoW->szUser, libReqInfoA->szUser, sizeof(libReqInfoA->szUser));
                AsciiToWChar(libReqInfoW->szComputer, libReqInfoA->szComputer, sizeof(libReqInfoA->szComputer));
                libReqInfoW->dwErrorCode = libReqInfoA->dwErrorCode;
                libReqInfoW->WorkItemId = libReqInfoA->WorkItemId;
                libReqInfoW->dwPriority = libReqInfoA->dwPriority;
            }
            break;
        case NTMS_OPREQUEST:
            {
                NTMS_OPREQUESTINFORMATIONA *opReqInfoA = &aObjInfo->Info.OpRequest;
                NTMS_OPREQUESTINFORMATIONW *opReqInfoW = &wObjInfo->Info.OpRequest;
                opReqInfoW->Request = opReqInfoA->Request;
                opReqInfoW->Submitted = opReqInfoA->Submitted;
                opReqInfoW->State = opReqInfoA->State;
                AsciiToWChar(opReqInfoW->szMessage, opReqInfoA->szMessage, sizeof(opReqInfoA->szMessage));
                opReqInfoW->Arg1Type = opReqInfoA->Arg1Type;
                memcpy(&opReqInfoW->Arg1, &opReqInfoA->Arg1, sizeof(NTMS_GUID));
                opReqInfoW->Arg2Type = opReqInfoA->Arg2Type;
                memcpy(&opReqInfoW->Arg2, &opReqInfoA->Arg2, sizeof(NTMS_GUID));
                AsciiToWChar(opReqInfoW->szApplication, opReqInfoA->szApplication, sizeof(opReqInfoA->szApplication));
                AsciiToWChar(opReqInfoW->szUser, opReqInfoA->szUser, sizeof(opReqInfoA->szUser));
                AsciiToWChar(opReqInfoW->szComputer, opReqInfoA->szComputer, sizeof(opReqInfoA->szComputer));
            }
            break;
        case NTMS_COMPUTER:
            {
                NTMS_COMPUTERINFORMATION *compInfoA = &aObjInfo->Info.Computer;
                NTMS_COMPUTERINFORMATION *compInfoW = &wObjInfo->Info.Computer;
                *compInfoW = *compInfoA;
            }
            break;
        default:
            DBGERR(("ConvertObjectInfoToWChar: unrecognized dwType"));
            break;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\work.c ===
/*
 *  WORK.C
 *
 *      RSM Service :  Code to service a work item
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"



BOOL ServiceOneWorkItem(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL workItemCompleted = FALSE;

    // BUGBUG FINISH

    return workItemCompleted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\workitem.c ===
/*
 *  WORKITEM.C
 *
 *      RSM Service :  Library work items
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>
#include <objbase.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


WORKITEM *NewWorkItem(LIBRARY *lib)
{
    WORKITEM *newWorkItem;

    newWorkItem = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(WORKITEM));
    if (newWorkItem){

        newWorkItem->state = WORKITEMSTATE_NONE;
        InitializeListHead(&newWorkItem->libListEntry);
        InitializeListHead(&newWorkItem->workGroupListEntry);

        newWorkItem->workItemCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (newWorkItem->workItemCompleteEvent){
            
            EnterCriticalSection(&lib->lock);
            lib->numTotalWorkItems++;
            newWorkItem->owningLib = lib;
            LeaveCriticalSection(&lib->lock);
        }
        else {
            GlobalFree(newWorkItem);
            newWorkItem = NULL;
        }
    }

    ASSERT(newWorkItem);
    return newWorkItem;
}


VOID FreeWorkItem(WORKITEM *workItem)
{

    EnterCriticalSection(&workItem->owningLib->lock);
    ASSERT(IsEmptyList(&workItem->libListEntry));
    ASSERT(IsEmptyList(&workItem->workGroupListEntry));
    ASSERT(lib->numTotalWorkItems > 0);
    workItem->owningLib->numTotalWorkItems--;
    LeaveCriticalSection(&workItem->owningLib->lock);
    
    CloseHandle(workItem->workItemCompleteEvent);
    GlobalFree(workItem);
}


VOID EnqueueFreeWorkItem(LIBRARY *lib, WORKITEM *workItem)
{
    ASSERT(workItem->owningLib == lib);
    workItem->state = WORKITEMSTATE_FREE;

    EnterCriticalSection(&lib->lock);
    InsertTailList(&lib->freeWorkItemsList, &workItem->libListEntry);
    LeaveCriticalSection(&lib->lock);
}


WORKITEM *DequeueFreeWorkItem(LIBRARY *lib, BOOL allocOrYieldIfNeeded)
{
    WORKITEM *workItem;

    EnterCriticalSection(&lib->lock);

    if (IsListEmpty(&lib->freeWorkItemsList)){

        if (allocOrYieldIfNeeded){
            /*
             *  No free workItems immediately available.
             *  If possible, try allocating a new one.
             *  Otherwise, go do some work and maybe that'll free some up.
             */
            if (lib->numTotalWorkItems < MAX_LIBRARY_WORKITEMS){
                workItem = NewWorkItem(lib);
            }
            else {

                /*
                 *  Give the library thread a chance to free up some workItems.
                 */
                LeaveCriticalSection(&lib->lock);
                Sleep(10);
                EnterCriticalSection(&lib->lock);

                if (IsListEmpty(&lib->freeWorkItemsList)){
                    workItem = NULL;
                }
                else {
                    LIST_ENTRY *listEntry = RemoveHeadList(&lib->freeWorkItemsList);
                    workItem = CONTAINING_RECORD(listEntry, WORKITEM, libListEntry);
                    InitializeListHead(&workItem->libListEntry);
                }
            }
        }
        else {
            workItem = NULL;
        }
    }
    else {
        LIST_ENTRY *listEntry = RemoveHeadList(&lib->freeWorkItemsList);
        workItem = CONTAINING_RECORD(listEntry, WORKITEM, libListEntry);
        InitializeListHead(&workItem->libListEntry);
    }

    if (workItem){
        workItem->state = WORKITEMSTATE_STAGING;
    }
    
    LeaveCriticalSection(&lib->lock);

    return workItem;
}


VOID EnqueuePendingWorkItem(LIBRARY *lib, WORKITEM *workItem)
{
    workItem->state = WORKITEMSTATE_PENDING;

    /*
     *  Make sure workItemCompleteEvent is reset to non-signalled.
     */
    ResetEvent(workItem->workItemCompleteEvent);

    /*
     *  Create a unique identifier for this workItem,
     *  which can be used to enumerate and cancel it.
     */
    CoCreateGuid(&workItem->currentOp.requestGuid);
    
    EnterCriticalSection(&lib->lock);
    InsertTailList(&lib->pendingWorkItemsList, &workItem->libListEntry);
    LeaveCriticalSection(&lib->lock);

    /*
     *  Wake up the library thread so it can process this workItem.
     */
    PulseEvent(lib->somethingToDoEvent);
}


WORKITEM *DequeuePendingWorkItem(LIBRARY *lib, WORKITEM *specificWorkItem)
{
    WORKITEM *workItem;
    
    EnterCriticalSection(&lib->lock);

    if (specificWorkItem){
        ASSERT(!IsListEmpty(&lib->pendingWorkItemsList));
        ASSERT(!IsListEmpty(&specificWorkItem->libListEntry));
        RemoveEntryList(&specificWorkItem->libListEntry);
        InitializeListHead(&specificWorkItem->libListEntry);
        workItem = specificWorkItem;
    }
    else {
        if (IsListEmpty(&lib->pendingWorkItemsList)){
            workItem = NULL;
        }
        else {
            LIST_ENTRY *listEntry = RemoveHeadList(&lib->pendingWorkItemsList);
            workItem = CONTAINING_RECORD(listEntry, WORKITEM, libListEntry);
            InitializeListHead(&workItem->libListEntry);
        }
    }
    
    LeaveCriticalSection(&lib->lock);

    return workItem;
}


WORKITEM *DequeuePendingWorkItemByGuid(LIBRARY *lib, LPNTMS_GUID lpRequestId)
{
    WORKITEM *workItem = NULL;
    LIST_ENTRY *listEntry;
    
    EnterCriticalSection(&lib->lock);

    listEntry = &lib->pendingWorkItemsList;
    while ((listEntry = listEntry->Flink) != &lib->pendingWorkItemsList){
        WORKITEM *thisWorkItem = CONTAINING_RECORD(listEntry, WORKITEM, libListEntry);
        if (RtlEqualMemory(&workItem->currentOp.requestGuid, lpRequestId, sizeof(NTMS_GUID))){
            workItem = thisWorkItem;
            RemoveEntryList(&workItem->libListEntry);
            InitializeListHead(&workItem->libListEntry);
            break;
        }
    }
    
    LeaveCriticalSection(&lib->lock);

    return workItem;
}

VOID EnqueueCompleteWorkItem(LIBRARY *lib, WORKITEM *workItem)
{
    
    EnterCriticalSection(&lib->lock);
    
    /*
     *  Put the workItem in the complete queue and signal its complete event
     *  to wake up the thread that originally queued this event.
     */
    workItem->state = WORKITEMSTATE_COMPLETE;
    InsertTailList(&lib->completeWorkItemsList, &workItem->libListEntry);
    PulseEvent(workItem->workItemCompleteEvent);

    /*
     *  If the workItem is a member of a workGroup, decrement
     *  the count in the workGroup.  If the entire workGroup is complete,
     *  signal the workGroup's complete event.
     */
    if (workItem->workGroup){
        EnterCriticalSection(&workItem->workGroup->lock);
        ASSERT(workItem->workGroup->numPendingWorkItems > 0);
        ASSERT(workItem->workGroup->numPendingWorkItems <= workItem->workGroup->numTotalWorkItems);
        workItem->workGroup->numPendingWorkItems--;
        if (workItem->workGroup->numPendingWorkItems == 0){
            PulseEvent(workItem->workGroup->allWorkItemsCompleteEvent);
        }
        LeaveCriticalSection(&workItem->workGroup->lock);
    }
    
    LeaveCriticalSection(&lib->lock);

}


WORKITEM *DequeueCompleteWorkItem(LIBRARY *lib, WORKITEM *specificWorkItem)
{
    WORKITEM *workItem;
    
    EnterCriticalSection(&lib->lock);

    if (specificWorkItem){
        ASSERT(!IsListEmpty(&lib->completeWorkItemsList));
        ASSERT(!IsListEmpty(&specificWorkItem->libListEntry));
        RemoveEntryList(&specificWorkItem->libListEntry);
        InitializeListHead(&specificWorkItem->libListEntry);
        workItem = specificWorkItem;
    }
    else {
        if (IsListEmpty(&lib->completeWorkItemsList)){
            workItem = NULL;
        }
        else {
            LIST_ENTRY *listEntry = RemoveHeadList(&lib->completeWorkItemsList);
            workItem = CONTAINING_RECORD(listEntry, WORKITEM, libListEntry);
            InitializeListHead(&workItem->libListEntry);
        }
    }
    
    LeaveCriticalSection(&lib->lock);

    return workItem;
}


/*
 *  FlushWorkItem
 *
 *      Dereference any objects pointed to by the workItem 
 *      and zero out the current op.
 */
VOID FlushWorkItem(WORKITEM *workItem)
{
    if (workItem->currentOp.drive) DerefObject(workItem->currentOp.drive); 
    if (workItem->currentOp.physMedia) DerefObject(workItem->currentOp.physMedia);
    if (workItem->currentOp.mediaPartition) DerefObject(workItem->currentOp.mediaPartition);
        
    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
}


VOID BuildSingleMountWorkItem(  WORKITEM *workItem, 
                                    DRIVE *drive OPTIONAL, 
                                    OBJECT_HEADER *mediaOrPartObj,
                                    ULONG dwOptions,
                                    int dwPriority)
{

    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
    workItem->currentOp.opcode = NTMS_LM_MOUNT;
    workItem->currentOp.options = dwOptions;
    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
    workItem->currentOp.drive = drive;
    
    switch (mediaOrPartObj->objType){
        case OBJECTTYPE_PHYSICALMEDIA:
            workItem->currentOp.physMedia = (PHYSICAL_MEDIA *)mediaOrPartObj;
            break;
        case OBJECTTYPE_MEDIAPARTITION:
            workItem->currentOp.mediaPartition = (MEDIA_PARTITION *)mediaOrPartObj;
            break;
        default:
            ASSERT(0);
            break;
    }

    /*
     *  Reference every object that we're pointing this workItem to.
     */
    if (drive) RefObject(drive);
    RefObject(mediaOrPartObj);
    
}


VOID BuildSingleDismountWorkItem(   WORKITEM *workItem,
                                            OBJECT_HEADER *mediaOrPartObj,
                                            DWORD dwOptions)
{

    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
    workItem->currentOp.opcode = NTMS_LM_DISMOUNT;
    workItem->currentOp.options = dwOptions;
    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
    
    switch (mediaOrPartObj->objType){
        case OBJECTTYPE_PHYSICALMEDIA:
            workItem->currentOp.physMedia = (PHYSICAL_MEDIA *)mediaOrPartObj;
            break;
        case OBJECTTYPE_MEDIAPARTITION:
            workItem->currentOp.mediaPartition = (MEDIA_PARTITION *)mediaOrPartObj;
            break;
        default:
            ASSERT(0);
            break;
    }

    /*
     *  Reference every object that we're pointing this workItem to.
     */
    RefObject(mediaOrPartObj);
    
}


VOID BuildInjectWorkItem(   WORKITEM *workItem, 
                                LPNTMS_GUID lpInjectOperation, 
                                ULONG dwAction)
{

    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
    workItem->currentOp.opcode = NTMS_LM_INJECT;
    workItem->currentOp.options = dwAction;
    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
    workItem->currentOp.guidArg = *lpInjectOperation;
}


VOID BuildEjectWorkItem(   WORKITEM *workItem, 
                                PHYSICAL_MEDIA *physMedia,
                                LPNTMS_GUID lpEjectOperation, 
                                ULONG dwAction)
{

    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
    workItem->currentOp.opcode = NTMS_LM_EJECT;
    workItem->currentOp.options = dwAction;
    workItem->currentOp.physMedia = physMedia;
    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
    workItem->currentOp.guidArg = *lpEjectOperation;

    /*
     *  Reference every object that we point the workItem to.
     */
    RefObject(physMedia);   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\dll\workgrp.c ===
/*
 *  WORKGRP.C
 *
 *      RSM Service :  Work Groups (collections of work items)
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


WORKGROUP *NewWorkGroup()
{
    WORKGROUP *workGroup;

    workGroup = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(WORKGROUP));
    if (workGroup){
        
        workGroup->allWorkItemsCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (workGroup->allWorkItemsCompleteEvent){
            InitializeListHead(&workGroup->workItemsList);
            InitializeCriticalSection(&workGroup->lock);
        }
        else {
            GlobalFree(workGroup);
            workGroup = NULL;
        }
    }

    ASSERT(workGroup);
    return workGroup;
}


VOID FreeWorkGroup(WORKGROUP *workGroup)
{
    FlushWorkGroup(workGroup);
    
    CloseHandle(workGroup->allWorkItemsCompleteEvent);
    DeleteCriticalSection(&workGroup->lock);
    GlobalFree(workGroup);
}


/*
 *  FlushWorkGroup
 *
 *      Release all the workItems in the workGroup.
 */
VOID FlushWorkGroup(WORKGROUP *workGroup)
{

    EnterCriticalSection(&workGroup->lock);
    
    while (!IsListEmpty(&workGroup->workItemsList)){
        LIST_ENTRY *listEntry;
        WORKITEM *workItem;

        listEntry = RemoveHeadList(&workGroup->workItemsList);
        workItem = CONTAINING_RECORD(listEntry, WORKITEM, workGroupListEntry);
            
        InitializeListHead(&workItem->workGroupListEntry);
        workItem->workGroup = NULL;

        /*
         *  Dereference the objects in the workItem.
         */
        FlushWorkItem(workItem);
             
        /*
         *  Get the workItem back in the library's free queue.
         */
        switch (workItem->state){
            case WORKITEMSTATE_FREE:
                break;
            case WORKITEMSTATE_PENDING:
                // BUGBUG FINISH - have to abort whatever the library thread
                //                  is doing with this workItem.
                DequeuePendingWorkItem(workItem->owningLib, workItem);
                EnqueueFreeWorkItem(workItem->owningLib, workItem);     
                break;
            case WORKITEMSTATE_COMPLETE:
                DequeueCompleteWorkItem(workItem->owningLib, workItem);
                EnqueueFreeWorkItem(workItem->owningLib, workItem);     
                break;
            case WORKITEMSTATE_STAGING:
                EnqueueFreeWorkItem(workItem->owningLib, workItem);     
                break;
            default:
                DBGERR(("bad workItem state in FlushWorkGroup"));
                break;
        }
    }

    LeaveCriticalSection(&workGroup->lock);

}


/*
 *  BuildMountWorkGroup
 *
 *      Build a work group (collection of work items) for a mount
 *      request, which may include multiple mounts, possibly spanning
 *      more than one library.
 */
HRESULT BuildMountWorkGroup(WORKGROUP *workGroup,
                                    LPNTMS_GUID lpMediaOrPartitionIds,
                                    LPNTMS_GUID lpDriveIds,
                                    DWORD dwCount,
                                    DWORD dwOptions,
                                    DWORD dwPriority)
{
    HRESULT result;
    ULONG i;
    
    ASSERT(IsListEmpty(&workGroup->workItemsList));

    /*
     *  1.  Create a workItem for each mount request.
     *      We will only proceed if all the mount requests are valid.
     */
    result = ERROR_SUCCESS; 
    for (i = 0; i < dwCount; i++){
        DRIVE *drive;

        /*
         *  If NTMS_MOUNT_SPECIFIC_DRIVE is set,
         *  we must mount a specific drive. 
         *  Otherwise, we select the drives and return them in lpDriveIds.
         */
        if (dwOptions & NTMS_MOUNT_SPECIFIC_DRIVE){
            drive = FindDrive(&lpDriveIds[i]);
        }
        else {
            drive = NULL;
        }

        if (drive || !(dwOptions & NTMS_MOUNT_SPECIFIC_DRIVE)){
            PHYSICAL_MEDIA *physMedia = NULL;
            MEDIA_PARTITION *mediaPart = NULL;
            
            /*
             *  We may be given either a physical media or a 
             *  media partition to mount.  Figure out which one
             *  by trying to resolve the GUID as either.
             */
            physMedia = FindPhysicalMedia(&lpMediaOrPartitionIds[i]);
            if (!physMedia){
                mediaPart = FindMediaPartition(&lpMediaOrPartitionIds[i]);
                if (mediaPart){
                    physMedia = mediaPart->owningPhysicalMedia;
                }
            }
            if (physMedia){               
                LIBRARY *lib;
                BOOLEAN ok;
                
                /*
                 *  Figure out what library we're dealing with.
                 *  Since we may not be given a specific drive, 
                 *  we have to figure it out from the media.
                 *  For sanity, check that the media is in a pool.
                 *
                 *  BUGBUG - how do we keep the media from moving
                 *            before the work item fires ?
                 */

                ok = LockPhysicalMediaWithLibrary(physMedia);
                if (ok){
                    LIBRARY *lib;

                    lib = physMedia->owningMediaPool ? 
                            physMedia->owningMediaPool->owningLibrary : 
                            NULL;
                    if (lib){
                        /*
                         *  If we're targetting a specific drive, then
                         *  it should be in the same library.
                         */
                        if (!drive || (drive->lib == lib)){
                            OBJECT_HEADER *mediaOrPartObj = 
                                            mediaPart ? 
                                            (OBJECT_HEADER *)mediaPart : 
                                            (OBJECT_HEADER *)physMedia;
                            WORKITEM *workItem;

                            workItem = DequeueFreeWorkItem(lib, TRUE);
                            if (workItem){
                                BuildSingleMountWorkItem( workItem,
                                                        drive,
                                                        mediaOrPartObj,
                                                        dwOptions,
                                                        dwPriority);
                                /*
                                 *  We've built one of the mount requests.
                                 *  Put it in the work group.
                                 */
                                InsertTailList( &workGroup->workItemsList, 
                                            &workItem->workGroupListEntry);
                                workItem->workGroup = workGroup;
                            }
                            else {
                                result = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        else {
                            result = ERROR_DRIVE_MEDIA_MISMATCH;
                        }
                    }
                    else {
                        result = ERROR_INVALID_LIBRARY;
                    }
                    
                    UnlockPhysicalMediaWithLibrary(physMedia);
                }
                else {
                    result = ERROR_DATABASE_FAILURE;
                }
            }
            else {
                result = ERROR_INVALID_MEDIA;
            }
        }
        else {
            result = ERROR_INVALID_DRIVE;
        }

        if (result != ERROR_SUCCESS){
            break;
        }
    }


    if (result == ERROR_SUCCESS){
        workGroup->numTotalWorkItems = workGroup->numPendingWorkItems = dwCount;
    }
    else {
        /*
         *  If we failed, release any work items that we did create.
         */
        FlushWorkGroup(workGroup);
    }
    
    return result;
}


/*
 *  BuildDismountWorkGroup
 *
 *      Build a work group (collection of work items) for a dismount
 *      request, which may include multiple dismounts, possibly spanning
 *      more than one library.
 */
HRESULT BuildDismountWorkGroup( WORKGROUP *workGroup,
                                       LPNTMS_GUID lpMediaOrPartitionIds,
                                       DWORD dwCount,
                                       DWORD dwOptions)
{
    HRESULT result;
    ULONG i;
    
    ASSERT(IsListEmpty(&workGroup->workItemsList));

    /*
     *  1.  Create a workItem for each dismount request.
     *      We will only proceed if all the dismount requests are valid.
     */
    result = ERROR_SUCCESS; 
    for (i = 0; i < dwCount; i++){
        PHYSICAL_MEDIA *physMedia = NULL;
        MEDIA_PARTITION *mediaPart = NULL;
            
        /*
         *  We may be given either a physical media or a 
         *  media partition to mount.  Figure out which one
         *  by trying to resolve the GUID as either.
         */
        physMedia = FindPhysicalMedia(&lpMediaOrPartitionIds[i]);
        if (!physMedia){
            mediaPart = FindMediaPartition(&lpMediaOrPartitionIds[i]);
            if (mediaPart){
                physMedia = mediaPart->owningPhysicalMedia;
            }
        }
        if (physMedia){               
            LIBRARY *lib;
            BOOLEAN ok;
                
            /*
             *  Figure out what library we're dealing with.
             */
            ok = LockPhysicalMediaWithLibrary(physMedia);
            if (ok){
                LIBRARY *lib;

                lib = physMedia->owningMediaPool ? 
                        physMedia->owningMediaPool->owningLibrary : 
                        NULL;
                if (lib){
                    OBJECT_HEADER *mediaOrPartObj = 
                                            mediaPart ? 
                                            (OBJECT_HEADER *)mediaPart : 
                                            (OBJECT_HEADER *)physMedia;
                    WORKITEM *workItem;

                    workItem = DequeueFreeWorkItem(lib, TRUE);
                    if (workItem){
                        BuildSingleDismountWorkItem( workItem,
                                                    mediaOrPartObj,
                                                    dwOptions);
                        /*
                         *  We've built one of the mount requests.
                         *  Put it in the work group.
                         */
                        InsertTailList( &workGroup->workItemsList, 
                                    &workItem->workGroupListEntry);
                        workItem->workGroup = workGroup;
                    }
                    else {
                        result = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                else {
                    result = ERROR_DRIVE_MEDIA_MISMATCH;
                }
                    
                UnlockPhysicalMediaWithLibrary(physMedia);
            }
            else {
                result = ERROR_DATABASE_FAILURE;
            }
        }
        else {
            result = ERROR_INVALID_MEDIA;
        }
    }


    if (result == ERROR_SUCCESS){
        workGroup->numTotalWorkItems = workGroup->numPendingWorkItems = dwCount;
    }
    else {
        /*
         *  If we failed, release any work items that we did create and clean up.
         */
        FlushWorkGroup(workGroup);
    }
        
    return result;
}

/*
 *  ScheduleWorkGroup
 *
 *      Submit all the work items in the work group.
 */
HRESULT ScheduleWorkGroup(WORKGROUP *workGroup)
{
    LIST_ENTRY *listEntry;
    HRESULT result;
    
    EnterCriticalSection(&workGroup->lock);

    /*
     *  Set the workGroup's status to success.
     *  If any workItems fail, they'll set this to an error code.
     */
    workGroup->resultStatus = ERROR_SUCCESS;

    listEntry = &workGroup->workItemsList;
    while ((listEntry = listEntry->Flink) != &workGroup->workItemsList){
        WORKITEM *workItem = CONTAINING_RECORD(listEntry, WORKITEM, workGroupListEntry);
        ASSERT(workItem->state == WORKITEMSTATE_STAGING);

        /*
         *  Give this workItem to the library and wake up the library thread.
         */
        EnqueuePendingWorkItem(workItem->owningLib, workItem);
    }

    LeaveCriticalSection(&workGroup->lock);

    result = ERROR_SUCCESS;
    
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\sbp2port\ntm_api.h ===
/*
    private api for ntmap to path an SG list 
    to sbp2port or usbstor

     irpStack->Parameters.Others.Argument1
         set to NTMAP_SCATTER_GATHER_SIG
             
     irpStack->Parameters.Others.Argument2 
        set to PNTMAP_SG_REQUEST
     
*/

typedef struct _NTMAP_SG_REQUEST
{
    PSCSI_REQUEST_BLOCK Srb;
    SCATTER_GATHER_LIST SgList;

} NTMAP_SG_REQUEST, *PNTMAP_SG_REQUEST;


#define NTMAP_SCATTER_GATHER_SIG   'pmTN'


/*

from ntddk.h

typedef struct _SCATTER_GATHER_ELEMENT
{
    PHYSICAL_ADDRESS    Address;
    ULONG               Length;
    ULONG_PTR           Reserved;

} SCATTER_GATHER_ELEMENT, *PSCATTER_GATHER_ELEMENT;

typedef struct _SCATTER_GATHER_LIST
{
    ULONG                   NumberOfElements;
    ULONG_PTR               Reserved;
    SCATTER_GATHER_ELEMENT  Elements[];

} SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\rsm2\service\inc\rsmsvc.h ===
/*
 *  SVCAPI.H
 *
 *      RSM Service :  Service API header (NEW)
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

    // BUGBUG - contains many redundancies and errors


HANDLE WINAPI OpenNtmsServerSessionW(   LPCWSTR lpServer,
                                        LPCWSTR lpApplication,
                                        LPCWSTR lpClientName,
                                        LPCWSTR lpUserName,
                                        DWORD   dwOptions,
                                        LPVOID  lpConnectionContext);
HANDLE WINAPI OpenNtmsSessionA( LPCSTR lpServer,
                                LPCSTR lpApplication,
                                LPCSTR lpClientName,
                                LPCSTR lpUserName,
                                DWORD  dwOptions,
                                LPVOID  lpConnectionContext);
HRESULT WINAPI CloseNtmsSession(HANDLE hSession);
HRESULT WINAPI SubmitNtmsOperatorRequestW(  HANDLE hSession,
                                            DWORD dwRequest,
                                            LPCWSTR lpMessage,
                                            LPNTMS_GUID lpArg1Id,
                                            LPNTMS_GUID lpArg2Id,
                                            LPNTMS_GUID lpRequestId);
HRESULT WINAPI SubmitNtmsOperatorRequestA(  HANDLE hSession,
                                            DWORD dwRequest,
                                            LPCSTR lpMessage,
                                            LPNTMS_GUID lpArg1Id,
                                            LPNTMS_GUID lpArg2Id,
                                            LPNTMS_GUID lpRequestId);
HRESULT WINAPI WaitForNtmsOperatorRequest(  HANDLE hSession, 
                                            LPNTMS_GUID lpRequestId,
                                            DWORD dwTimeout);
HRESULT WINAPI CancelNtmsOperatorRequest(HANDLE hSession, LPNTMS_GUID lpRequestId);
HRESULT WINAPI SatisfyNtmsOperatorRequest(HANDLE hSession, LPNTMS_GUID lpRequestId);
HRESULT WINAPI ImportNtmsDatabase(HANDLE hSession);
HRESULT WINAPI ExportNtmsDatabase(HANDLE hSession);
HRESULT WINAPI GetNtmsMountDrives(  HANDLE hSession,
                                    LPNTMS_MOUNT_INFORMATION lpMountInformation,
                                    LPNTMS_GUID lpDriveId,
                                    DWORD dwCount);       
HRESULT WINAPI AllocateNtmsMedia(   HANDLE hSession,
                                    LPNTMS_GUID lpMediaPool,
                                    LPNTMS_GUID lpPartition,    // optional
                                    LPNTMS_GUID lpMediaId,      // OUTPUT, media id o
                                    DWORD dwOptions,
                                    DWORD dwTimeout,
                                    LPNTMS_ALLOCATION_INFORMATION lpAllocateInformation);
HRESULT WINAPI DeallocateNtmsMedia( HANDLE hSession,
                                    LPNTMS_GUID lpMediaId,
                                    DWORD dwOptions);
HRESULT WINAPI SwapNtmsMedia(   HANDLE hSession,
                                LPNTMS_GUID lpMediaId1,
                                LPNTMS_GUID lpMediaId2);
HRESULT WINAPI DecommissionNtmsMedia(   HANDLE hSession,
                                        LPNTMS_GUID lpMediaId);
HRESULT WINAPI SetNtmsMediaComplete(    HANDLE hSession,
                                        LPNTMS_GUID lpMediaId);
HRESULT WINAPI DeleteNtmsMedia( HANDLE hSession,
                                LPNTMS_GUID lpMediaId);
HRESULT WINAPI CreateNtmsMediaPoolA(    HANDLE hSession,
                                        LPCSTR lpPoolName,
                                        LPNTMS_GUID lpMediaType,
                                        DWORD dwAction,
                                        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                        OUT LPNTMS_GUID lpPoolId);
HRESULT WINAPI CreateNtmsMediaPoolW(    HANDLE hSession,
                                        LPCWSTR lpPoolName,
                                        LPNTMS_GUID lpMediaType,
                                        DWORD dwAction,
                                        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                        OUT LPNTMS_GUID lpPoolId);
HRESULT WINAPI GetNtmsMediaPoolNameA(   HANDLE hSession,
                                        LPNTMS_GUID lpPoolId,
                                        LPSTR lpBufName,
                                        LPDWORD lpdwNameSize);
HRESULT WINAPI GetNtmsMediaPoolNameW(   HANDLE hSession,
                                        LPNTMS_GUID lpPoolId,
                                        LPWSTR lpBufName,
                                        LPDWORD lpdwNameSize);
HRESULT WINAPI MoveToNtmsMediaPool( HANDLE hSession,
                                    LPNTMS_GUID lpMediaId,
                                    LPNTMS_GUID lpPoolId);
HRESULT WINAPI DeleteNtmsMediaPool(HANDLE hSession, LPNTMS_GUID lpPoolId);
HRESULT WINAPI AddNtmsMediaType(    HANDLE hSession,
                                    LPNTMS_GUID lpMediaTypeId,
                                    LPNTMS_GUID lpLibId);
HRESULT WINAPI DeleteNtmsMediaType( HANDLE hSession,
                                    LPNTMS_GUID lpMediaTypeId,
                                    LPNTMS_GUID lpLibId);
HRESULT WINAPI ChangeNtmsMediaType( HANDLE hSession,
                                    LPNTMS_GUID lpMediaId,
                                    LPNTMS_GUID lpPoolId);
HRESULT WINAPI MountNtmsMedia(  HANDLE hSession,
                                LPNTMS_GUID lpMediaId,
                                LPNTMS_GUID lpDriveId,
                                DWORD dwCount,
                                DWORD dwOptions,
                                int dwPriority,
                                DWORD dwTimeout,
                                LPNTMS_MOUNT_INFORMATION lpMountInformation);
HRESULT WINAPI DismountNtmsMedia(   HANDLE hSession,
                                    LPNTMS_GUID lpMediaId,
                                    DWORD dwCount,
                                    DWORD dwOptions);
DWORD WINAPI EjectNtmsMedia(    HANDLE hSession,
                                LPNTMS_GUID lpMediaId,
                                LPNTMS_GUID lpEjectOperation,
                                DWORD dwAction);
DWORD WINAPI InjectNtmsMedia(   HANDLE hSession,
                                LPNTMS_GUID lpLibraryId,
                                LPNTMS_GUID lpInjectOperation,
                                DWORD dwAction);
DWORD WINAPI AccessNtmsLibraryDoor( HANDLE hSession,
                                    LPNTMS_GUID lpLibraryId,
                                    DWORD dwAction);
DWORD WINAPI CleanNtmsDrive(            HANDLE hSession,
                                        LPNTMS_GUID lpDriveId);
DWORD WINAPI DismountNtmsDrive(         HANDLE hSession,
                                        LPNTMS_GUID lpDriveId);
DWORD WINAPI InventoryNtmsLibrary(
        HANDLE hSession,
        LPNTMS_GUID lpLibraryId,
        DWORD dwAction
        )
DWORD WINAPI UpdateNtmsOmidInfo(    HANDLE hSession,
                                    LPNTMS_GUID lpMediaId,
                                    DWORD labelType,
                                    DWORD numberOfBytes,
                                    LPVOID lpBuffer);
DWORD WINAPI CancelNtmsLibraryRequest(  HANDLE hSession,
                                        LPNTMS_GUID lpRequestId);
DWORD WINAPI ReserveNtmsCleanerSlot(    HANDLE hSession,
                                        LPNTMS_GUID lpLibrary,
                                        LPNTMS_GUID lpSlot);
DWORD WINAPI ReleaseNtmsCleanerSlot(    HANDLE hSession,
                                        LPNTMS_GUID lpLibrary);
DWORD WINAPI InjectNtmsCleaner(     HANDLE hSession,
                                    LPNTMS_GUID lpLibrary,
                                    LPNTMS_GUID lpInjectOperation,
                                    DWORD dwNumberOfCleansLeft,
                                    DWORD dwAction);
DWORD WINAPI EjectNtmsCleaner(      HANDLE hSession,
                                    LPNTMS_GUID lpLibrary,
                                    LPNTMS_GUID lpEjectOperation,
                                    DWORD dwAction);
DWORD WINAPI DeleteNtmsLibrary(HANDLE hSession, LPNTMS_GUID lpLibraryId);
DWORD WINAPI DeleteNtmsDrive(HANDLE hSession, LPNTMS_GUID lpDriveId);
DWORD WINAPI GetNtmsRequestOrder(   HANDLE hSession,
                                    LPNTMS_GUID lpRequestId,
                                    LPDWORD lpdwOrderNumber);
DWORD WINAPI SetNtmsRequestOrder(   HANDLE hSession,
                                    LPNTMS_GUID lpRequestId,
                                    DWORD dwOrderNumber);
DWORD WINAPI DeleteNtmsRequests(    HANDLE hSession,
                                    LPNTMS_GUID lpRequestId,
                                    DWORD dwType,
                                    DWORD dwCount);
DWORD WINAPI BeginNtmsDeviceChangeDetection(HANDLE hSession, LPHANDLE lpDetectHandle);
DWORD WINAPI SetNtmsDeviceChangeDetection(  HANDLE hSession,
                                            HANDLE DetectHandle,
                                            LPNTMS_GUID lpRequestId,
                                            DWORD dwType,
                                            DWORD dwCount);
DWORD WINAPI EndNtmsDeviceChangeDetection(HANDLE hSession, HANDLE DetectHandle);

/******** BUGBUG: INtmsObjectManagement1 APIs *********************/

DWORD WINAPI GetNtmsObjectSecurity(     HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        DWORD dwType,
                                        SECURITY_INFORMATION RequestedInformation,
                                        PSECURITY_DESCRIPTOR lpSecurityDescriptor,
                                        DWORD nLength,
                                        LPDWORD lpnLengthNeeded);
DWORD WINAPI SetNtmsObjectSecurity(     HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        DWORD dwType,
                                        SECURITY_INFORMATION SecurityInformation,
                                        PSECURITY_DESCRIPTOR lpSecurityDescriptor);
DWORD WINAPI GetNtmsObjectAttributeA(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            LPDWORD lpAttributeSize);
DWORD WINAPI GetNtmsObjectAttributeW(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCWSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            LPDWORD lpAttributeSize);
DWORD WINAPI SetNtmsObjectAttributeA(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            DWORD dwAttributeSize);
DWORD WINAPI SetNtmsObjectAttributeW(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCWSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            DWORD AttributeSize);
DWORD WINAPI EnumerateNtmsObject(   HANDLE hSession,
                                    const LPNTMS_GUID lpContainerId,
                                    LPNTMS_GUID lpList,
                                    LPDWORD lpdwListSize,
                                    DWORD dwType,
                                    DWORD dwOptions);
DWORD WINAPI EnableNtmsObject(          HANDLE hSession,
                                        DWORD dwType,
                                        LPNTMS_GUID lpObjectId);
DWORD WINAPI DisableNtmsObject(         HANDLE hSession,
                                        DWORD dwType,
                                        LPNTMS_GUID lpObjectId);

/******* BUGBUG: INtmsObjectInfo1 APIs  ****************************/

                    // BUGBUG - these 4 functions have another form with type,size as last args
DWORD WINAPI GetNtmsServerObjectInformationA(   HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONA lpInfo,
                                                int revision);
DWORD WINAPI GetNtmsServerObjectInformationW(   HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONW lpInfo,
                                                int revision);
DWORD WINAPI SetNtmsServerObjectInformationA(   HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONA lpInfo,
                                                int revision);
DWORD WINAPI SetNtmsServerObjectInformationW(   HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONW lpInfo,
                                                int revision);
DWORD WINAPI CreateNtmsMediaA(      HANDLE hSession,
                                    LPNTMS_OBJECTINFORMATIONA lpMedia,
                                    LPNTMS_OBJECTINFORMATIONA lpList,
                                    DWORD dwOptions);
DWORD WINAPI CreateNtmsMediaW(      HANDLE hSession,
                                    LPNTMS_OBJECTINFORMATIONW lpMedia,
                                    LPNTMS_OBJECTINFORMATIONW lpList,
                                    DWORD dwOptions);
DWORD WINAPI GetNtmsObjectInformationA( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONA lpInfo);
DWORD WINAPI GetNtmsObjectInformationW( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONW lpInfo);
DWORD WINAPI SetNtmsObjectInformationA( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONA lpInfo);
DWORD WINAPI SetNtmsObjectInformationW( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONW lpInfo);
DWORD WINAPI SubmitNtmsOperatorRequestA(        HANDLE hSession,
                                                DWORD dwRequest,
                                                LPCSTR lpMessage,
                                                LPNTMS_GUID lpArg1Id,
                                                LPNTMS_GUID lpArg2Id,
                                                LPNTMS_GUID lpRequestId);
DWORD WINAPI SubmitNtmsOperatorRequestW(        HANDLE hSession,
                                                DWORD dwRequest,
                                                LPCWSTR lpMessage,
                                                LPNTMS_GUID lpArg1Id,
                                                LPNTMS_GUID lpArg2Id,
                                                LPNTMS_GUID lpRequestId);
DWORD WINAPI WaitForNtmsOperatorRequest(    HANDLE hSession,
                                            LPNTMS_GUID lpRequestId,
                                            DWORD dwTimeout);
DWORD WINAPI CancelNtmsOperatorRequest(HANDLE hSession, LPNTMS_GUID lpRequestId);
DWORD WINAPI SatisfyNtmsOperatorRequest(HANDLE hSession, LPNTMS_GUID lpRequestId);
HANDLE WINAPI OpenNtmsNotification(HANDLE hSession, DWORD dwType);
DWORD WINAPI WaitForNtmsNotification(   HANDLE hNotification,
                                        LPNTMS_NOTIFICATIONINFORMATION lpNotificationInformation,
                                        DWORD dwTimeout);
DWORD WINAPI CloseNtmsNotification(HANDLE hNotification);
DWORD WINAPI ImportNtmsDatabase(HANDLE hSession);
DWORD WINAPI ExportNtmsDatabase(HANDLE hSession);
DWORD WINAPI EjectDiskFromSADriveA(     LPCSTR lpComputerName,
                                        LPCSTR lpAppName,
                                        LPCSTR lpDeviceName,
                                        HWND hWnd,
                                        LPCSTR lpTitle,
                                        LPCSTR lpMessage,
                                        DWORD dwOptions);
DWORD WINAPI EjectDiskFromSADriveW(     LPCWSTR lpComputerName,
                                        LPCWSTR lpAppName,
                                        LPCWSTR lpDeviceName,
                                        HWND hWnd,
                                        LPCWSTR lpTitle,
                                        LPCWSTR lpMessage,
                                        DWORD dwOptions);
DWORD WINAPI GetVolumesFromDriveA(      LPSTR pszDriveName,
                                        LPSTR* VolumeNameBufferPtr,
                                        LPSTR* DriveLetterBufferPtr);
DWORD WINAPI GetVolumesFromDriveW(      LPWSTR pszDriveName,
                                        LPWSTR *VolumeNameBufferPtr,
                                        LPWSTR *DriveLetterBufferPtr);
DWORD WINAPI IdentifyNtmsSlot(          HANDLE hSession,
                                        LPNTMS_GUID lpSlotId,
                                        DWORD dwOption);
DWORD WINAPI GetNtmsUIOptionsA(     HANDLE hSession,
                                    const LPNTMS_GUID lpObjectId,
                                    DWORD dwType,
                                    LPSTR lpszDestination,
                                    LPDWORD lpAttributeSize);
DWORD WINAPI GetNtmsUIOptionsW(     HANDLE hSession,
                                    const LPNTMS_GUID lpObjectId,
                                    DWORD dwType,
                                    LPWSTR lpszDestination,
                                    LPDWORD lpdwSize);
DWORD WINAPI SetNtmsUIOptionsA(     HANDLE hSession,
                                    const LPNTMS_GUID lpObjectId,
                                    DWORD dwType,
                                    DWORD dwOperation,
                                    LPCSTR lpszDestination);

DWORD WINAPI SetNtmsUIOptionsW(     HANDLE hSession,
                                    const LPNTMS_GUID lpObjectId,
                                    DWORD dwType,
                                    DWORD dwOperation,
                                    LPCWSTR lpszDestination);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\sbp2port\prop.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2001

Module Name:

    prop.c

Abstract:

    This is the NT SBP2 port/filter driver.  This module contains code relating to
    property queries

Authors:

    georgioc

Environment:

    kernel mode only

Notes:

Revision History:

    georgioc    - grabbed this module from scsiport, since i needed to duplicate this functionality
                  in order to present sbp2port as a storage port

--*/

#include "sbp2port.h"
#include "stdio.h"

NTSTATUS
Sbp2BuildDeviceDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    );

NTSTATUS
Sbp2BuildAdapterDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_ADAPTER_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    );


NTSTATUS
Sbp2QueryProperty(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP QueryIrp
    )

/*++

Routine Description:

    This routine will handle a property query request.  It will build the
    descriptor on it's own if possible, or it may forward the request down
    to lower level drivers.

    Since this routine may forward the request downwards the caller should
    not complete the irp

    This routine is asynchronous.
    This routine must be called at <= IRQL_DISPATCH

Arguments:

    DeviceObject - a pointer to the device object being queried

    QueryIrp - a pointer to the irp for the query

Return Value:

    STATUS_PENDING if the request cannot be completed yet
    STATUS_SUCCESS if the query was successful

    STATUS_INVALID_PARAMETER_1 if the property id does not exist
    STATUS_INVALID_PARAMETER_2 if the query type is invalid
    STATUS_INVALID_PARAMETER_3 if an invalid optional parameter was passed

    STATUS_INVALID_DEVICE_REQUEST if this request cannot be handled by this
    device

    other error values as applicable

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(QueryIrp);

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    PSTORAGE_PROPERTY_QUERY query = QueryIrp->AssociatedIrp.SystemBuffer;
    ULONG queryLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    NTSTATUS status;

    //
    // We don't handle mask queries yet
    //

    if (query->QueryType >= PropertyMaskQuery) {

        status = STATUS_INVALID_PARAMETER_1;
        QueryIrp->IoStatus.Status = status;
        QueryIrp->IoStatus.Information = 0;
        IoCompleteRequest(QueryIrp, IO_NO_INCREMENT);
        return status;
    }

    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, NULL);

    if (!NT_SUCCESS (status)) {

        QueryIrp->IoStatus.Status = status;
        QueryIrp->IoStatus.Information = 0;
        IoCompleteRequest(QueryIrp, IO_NO_INCREMENT);
        return status;
    }

    switch (query->PropertyId) {

        case StorageDeviceProperty:

            if (query->QueryType == PropertyExistsQuery) {

                status = STATUS_SUCCESS;

            } else {

                status = Sbp2BuildDeviceDescriptor(
                            DeviceObject,
                            QueryIrp->AssociatedIrp.SystemBuffer,
                            &queryLength);

                QueryIrp->IoStatus.Information = queryLength;
            }

            break;

        case StorageAdapterProperty:

            //
            // Although we are a filter, we are essentially presenting the
            // 1394 bus driver as a Port driver, so this is handled here
            //

            if (query->QueryType == PropertyExistsQuery) {

                status = STATUS_SUCCESS;

            } else {

                status = Sbp2BuildAdapterDescriptor(
                            DeviceObject,
                            QueryIrp->AssociatedIrp.SystemBuffer,
                            &queryLength);

                QueryIrp->IoStatus.Information = queryLength;
            }

            break;

        default:

            //
            // Nope, this property really doesn't exist
            //

            status = STATUS_INVALID_PARAMETER_1;
            QueryIrp->IoStatus.Information = 0;
            break;
    }

    QueryIrp->IoStatus.Status = status;
    IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
    IoCompleteRequest (QueryIrp, IO_DISK_INCREMENT);

    return status;
}

NTSTATUS
Sbp2BuildDeviceDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    )

/*++

Routine Description:

    This routine will create a device descriptor based on the information in
    it's device extension.  It will copy as much data as possible into
    the Descriptor and will update the DescriptorLength to indicate the
    number of bytes copied

Arguments:

    DeviceObject - a pointer to the PDO we are building a descriptor for

    Descriptor - a buffer to store the descriptor in

    DescriptorLength - the length of the buffer and the number of bytes
                       returned

    QueryIrp - unused

Return Value:

    status

--*/

{
    LONG    maxLength = *DescriptorLength;
    LONG    bytesRemaining = maxLength;
    ULONG   realLength = sizeof (STORAGE_DEVICE_DESCRIPTOR);
    ULONG   infoLength;
    PUCHAR  currentOffset = (PUCHAR) Descriptor;

    PINQUIRYDATA                inquiryData;
    PDEVICE_EXTENSION           deviceExtension =DeviceObject->DeviceExtension;
    STORAGE_DEVICE_DESCRIPTOR   tmp;

    inquiryData = &deviceExtension->InquiryData;

    //
    // The info includes VendorId, ProductId, ProductRevsisionLevel,
    // and (sprintf'd) EUI64 strings, plus ascii NULL terminators for each
    //

    infoLength =
        sizeof (inquiryData->VendorId) + 1 +
        sizeof (inquiryData->ProductId) + 1 +
        sizeof (inquiryData->ProductRevisionLevel) + 1 +
        16 + 1;

    realLength += infoLength;

    RtlZeroMemory (Descriptor, maxLength);

    //
    // Build the device descriptor structure on the stack then copy as much as
    // can be copied over
    //

    RtlZeroMemory (&tmp, sizeof (STORAGE_DEVICE_DESCRIPTOR));

    tmp.Version = sizeof (STORAGE_DEVICE_DESCRIPTOR);
    tmp.Size = realLength;

    tmp.DeviceType = deviceExtension->InquiryData.DeviceType;

    tmp.DeviceTypeModifier = 0;

    if (deviceExtension->InquiryData.RemovableMedia ||
        (tmp.DeviceType == READ_ONLY_DIRECT_ACCESS_DEVICE)) {

        tmp.RemovableMedia = TRUE;
        DeviceObject->Characteristics |= FILE_REMOVABLE_MEDIA;

    } else {

        //
        // default case, if INQUIRY failed..
        //

        tmp.RemovableMedia = FALSE;
    }

    tmp.BusType = BusType1394;

    //
    // always true for sbp2 targets
    //

    tmp.CommandQueueing = TRUE;

    RtlCopyMemory(
        currentOffset,
        &tmp,
        min (sizeof (STORAGE_DEVICE_DESCRIPTOR), bytesRemaining)
        );

    bytesRemaining -= sizeof (STORAGE_DEVICE_DESCRIPTOR);

    if (bytesRemaining <= 0) {

        return STATUS_SUCCESS;
    }

    currentOffset += sizeof (STORAGE_DEVICE_DESCRIPTOR);

    //
    // If our inquiry buffer is empty, make up some strings...
    //

    if (deviceExtension->InquiryData.VendorId[0] == 0) {

        sprintf (inquiryData->VendorId, "Vendor");
        sprintf (inquiryData->ProductId, "Sbp2");
        sprintf (inquiryData->ProductRevisionLevel, "1.0");
    }

    //
    // First the vendor id + NULL
    //

    if (bytesRemaining <= sizeof (inquiryData->VendorId)) {

        return STATUS_SUCCESS;
    }

    RtlCopyMemory(
        currentOffset,
        inquiryData->VendorId,
        sizeof (inquiryData->VendorId)
        );

    Descriptor->VendorIdOffset = (ULONG)
        ((ULONG_PTR) currentOffset - (ULONG_PTR) Descriptor);

    bytesRemaining -= sizeof (inquiryData->VendorId) + sizeof (UCHAR);

    currentOffset += sizeof (inquiryData->VendorId) + sizeof (UCHAR);

    //
    // Now the product id + NULL
    //

    if (bytesRemaining <= sizeof (inquiryData->ProductId)) {

        return STATUS_SUCCESS;
    }

    RtlCopyMemory(
        currentOffset,
        inquiryData->ProductId,
        sizeof (inquiryData->ProductId)
        );

    Descriptor->ProductIdOffset = (ULONG)
        ((ULONG_PTR) currentOffset - (ULONG_PTR) Descriptor);

    bytesRemaining -= sizeof (inquiryData->ProductId) + sizeof (UCHAR);

    currentOffset += sizeof (inquiryData->ProductId) + sizeof (UCHAR);

    //
    // Now the product revision + NULL
    //

    if (bytesRemaining <= sizeof (inquiryData->ProductRevisionLevel)) {

        return STATUS_SUCCESS;
    }

    RtlCopyMemory(
        currentOffset,
        inquiryData->ProductRevisionLevel,
        sizeof (inquiryData->ProductRevisionLevel)
        );

    Descriptor->ProductRevisionOffset = (ULONG)
        ((ULONG_PTR) currentOffset - (ULONG_PTR) Descriptor);

    bytesRemaining -=
        sizeof (inquiryData->ProductRevisionLevel) + sizeof (UCHAR);

    currentOffset +=
        sizeof (inquiryData->ProductRevisionLevel) + sizeof (UCHAR);

    //
    // And finally the device serial number (use the UniqueId
    // converted from binary to string format) + NULL
    //

    if (bytesRemaining <= 16) {

        return STATUS_SUCCESS;
    }

    sprintf(
        currentOffset,
        "%08x%08x",
        deviceExtension->DeviceInfo->ConfigRom->CR_Node_UniqueID[0],
        deviceExtension->DeviceInfo->ConfigRom->CR_Node_UniqueID[1]
        );

    Descriptor->SerialNumberOffset = (ULONG)
        ((ULONG_PTR) currentOffset - (ULONG_PTR) Descriptor);

    *DescriptorLength = realLength;

    return STATUS_SUCCESS;
}


NTSTATUS
Sbp2BuildAdapterDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_ADAPTER_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    STORAGE_ADAPTER_DESCRIPTOR tmp;
    ULONG realLength;

    realLength = sizeof(STORAGE_ADAPTER_DESCRIPTOR);

    tmp.Version = sizeof(STORAGE_ADAPTER_DESCRIPTOR);
    tmp.Size = sizeof(STORAGE_ADAPTER_DESCRIPTOR);

    if (*DescriptorLength < realLength ) {

        RtlCopyMemory (Descriptor,&tmp,*DescriptorLength);
        return STATUS_SUCCESS;
    }

    tmp.MaximumTransferLength = deviceExtension->DeviceInfo->MaxClassTransferSize;
    tmp.MaximumPhysicalPages = tmp.MaximumTransferLength/PAGE_SIZE ;

    tmp.AlignmentMask = SBP2_ALIGNMENT_MASK;

    tmp.AdapterUsesPio = FALSE;
    tmp.AdapterScansDown = FALSE;
    tmp.CommandQueueing = TRUE;
    tmp.AcceleratedTransfer = TRUE;

    tmp.BusType = BusType1394;
    tmp.BusMajorVersion = 1;
    tmp.BusMinorVersion = 0;

    RtlCopyMemory(Descriptor,
                  &tmp,
                  sizeof(STORAGE_ADAPTER_DESCRIPTOR));

    *DescriptorLength =  sizeof(STORAGE_ADAPTER_DESCRIPTOR);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\sbp2port\sbp2.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sbp2.h

Abstract:

    Definitions for SBP2 protocol

Author:

    georgioc 22-Jan-97

Environment:

    Kernel mode only

Revision History:


--*/
#ifndef _SBP2_
#define _SBP2_

#ifndef SBP2KDX
#include "wdm.h"
#endif

#include "1394.h"
#include "rbc.h"

#include "scsi.h"
#include "ntddstor.h"

typedef union _QUADLET {
    
    ULONG QuadPart;
    struct {
        USHORT LowPart;
        USHORT HighPart;
    } u;

} QUADLET, *PQUADLET;


typedef struct _B1394_ADDRESS {
    USHORT Off_High;        // little endian ordering within an octlet
    NODE_ADDRESS NodeId;
    ULONG  Off_Low;
} B1394_ADDRESS, *PB1394_ADDRESS;



typedef union _OCTLET {
    LONGLONG OctletPart;
    B1394_ADDRESS BusAddress;
    struct {
        QUADLET HighQuad;
        QUADLET LowQuad;
    } u;
    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
        UCHAR Byte4;
        UCHAR Byte5;
        UCHAR Byte6;
        UCHAR Byte7;
    } ByteArray;

} OCTLET, *POCTLET;



//
// Various ORB and block definitions
//

typedef struct _ORB_NORMAL_CMD {
    OCTLET  NextOrbAddress;
    OCTLET  DataDescriptor;
    QUADLET OrbInfo;
    UCHAR  Cdb[12];
} ORB_NORMAL_CMD, *PORB_NORMAL_CMD;

#define CMD_ORB_HEADER_SIZE 0x14


typedef struct _ORB_LOGIN {
    OCTLET  Password;
    OCTLET  LoginResponseAddress;
    QUADLET OrbInfo;
    QUADLET LengthInfo;
    OCTLET  StatusBlockAddress;
} ORB_LOGIN, *PORB_LOGIN;

typedef struct _ORB_QUERY_LOGIN {
    OCTLET  Reserved;
    OCTLET  QueryResponseAddress;
    QUADLET OrbInfo;
    QUADLET LengthInfo;
    OCTLET  StatusBlockAddress;
} ORB_QUERY_LOGIN, *PORB_QUERY_LOGIN;

typedef struct _ORB_SET_PASSWORD {
    OCTLET  Password;
    OCTLET  Reserved;
    QUADLET OrbInfo;
    QUADLET LengthInfo;
    OCTLET  StatusBlockAddress;
} ORB_SET_PASSWORD, *PORB_SET_PASSWORD;

typedef struct _ORB_MNG {
    OCTLET  Reserved[2];
    QUADLET OrbInfo;
    QUADLET Reserved1;
    OCTLET  StatusBlockAddress;
} ORB_MNG, *PORB_MNG;

typedef struct _ORB_TASK_MNG {
    OCTLET  OrbAddress;
    OCTLET  Reserved;
    QUADLET OrbInfo;
    QUADLET Reserved1;
    OCTLET  StatusBlockAddress;
} ORB_TASK_MNG, *PORB_TASK_MNG;



typedef struct _ORB_DUMMY {
    OCTLET  NextOrbAddress;
    OCTLET  NotUsed;
    QUADLET OrbInfo;
    OCTLET  Unused[3];
} ORB_DUMMY, *PORB_DUMMY;

typedef struct _LOGIN_RESPONSE {
    QUADLET LengthAndLoginId;
    QUADLET Csr_Off_High;
    QUADLET Csr_Off_Low;
    QUADLET Reserved;
} LOGIN_RESPONSE, *PLOGIN_RESPONSE;

typedef struct _QUERY_RESPONSE_ELEMENT {
    QUADLET NodeAndLoginId;
    OCTLET  EUI64;
} QUERY_RESPONSE_ELEMENT, *PQUERY_RESPONSE_ELEMENT;

typedef struct _QUERY_LOGIN_RESPONSE {
    QUADLET LengthAndNumLogins;
    QUERY_RESPONSE_ELEMENT Elements[4];
} QUERY_LOGIN_RESPONSE, *PQUERY_LOGIN_RESPONSE;

typedef struct _STATUS_FIFO_BLOCK {
    OCTLET AddressAndStatus;
    OCTLET Contents[3];
} STATUS_FIFO_BLOCK, *PSTATUS_FIFO_BLOCK;

#define SBP2_MIN_ORB_SIZE 32
#define SBP2_ORB_CDB_SIZE 12

#define SBP2_MAX_DIRECT_BUFFER_SIZE (ULONG) (65535) // (64K - 1) max size for direct addressing buffer
#define SBP2_MAX_PAGE_SIZE SBP2_MAX_DIRECT_BUFFER_SIZE

//
// MANAGEMENT Transactions
//

#define TRANSACTION_LOGIN 0x00
#define TRANSACTION_QUERY_LOGINS 0x01
#define TRANSACTION_ISOCHRONOUS_LOGIN 0x02
#define TRANSACTION_RECONNECT 0x03
#define TRANSACTION_SET_PASSWORD        0x04
#define TRANSACTION_LOGOUT 0x07
#define TRANSACTION_TERMINATE_TASK 0x0b
#define TRANSACTION_ABORT_TASK 0x0b
#define TRANSACTION_ABORT_TASK_SET 0x0c
#define TRANSACTION_CLEAR_TASK_SET 0x0D
#define TRANSACTION_LOGICAL_UNIT_RESET 0x0E
#define TRANSACTION_TARGET_RESET 0x0F


#define MANAGEMENT_AGENT_REG_ADDRESS_LOW 0xF0010000
#define CSR_REG_ADDRESS_LOW 0xF0010000

//
// Register Names
//
#define MANAGEMENT_AGENT_REG    0x0000
#define AGENT_STATE_REG         0x0001
#define AGENT_RESET_REG         0x0002
#define ORB_POINTER_REG         0x0004
#define DOORBELL_REG            0x0008
#define UNSOLICITED_STATUS_REG  0x0010
#define CORE_RESET_REG          0x0020
#define CORE_BUSY_TIMEOUT_REG   0x0040
#define TEST_REG                0x0080

//
// register access type
//
#define REG_WRITE_SYNC          0x0100
#define REG_READ_SYNC           0x0200
#define REG_WRITE_ASYNC         0x0400

#define REG_TYPE_MASK           0x00FF



//
// Relative offsets from base of Target's CSR
//

#define AGENT_STATE_REG_OFFSET      0x00
#define AGENT_RESET_REG_OFFSET      0x04
#define ORB_POINTER_REG_OFFSET      0x08
#define DOORBELL_REG_OFFSET         0x10
#define UNSOLICITED_STATUS_REG_OFFSET   0x14
#define TEST_REG_OFFSET             0x10020

//
// config rom stuff
//

#define CR_BASE_ADDRESS_LOW 0xF0000400
#define CR_MODULE_ID_OFFSET (0x06 * sizeof(QUADLET))
#define CSR_OFFSET_KEY_SIGNATURE 0x54
#define LUN_CHARACTERISTICS_KEY_SIGNATURE 0x3A
#define FIRMWARE_REVISION_KEY_SIGNATURE 0x3C
#define LUN_KEY_SIGNATURE 0x14
#define LU_DIRECTORY_KEY_SIGNATURE 0xD4
#define SW_VERSION_KEY_SIGNATURE 0x13
#define CMD_SET_ID_KEY_SIGNATURE 0x39
#define CMD_SET_SPEC_ID_KEY_SIGNATURE 0x38

#define SBP2_LUN_DEVICE_TYPE_MASK 0x00FF0000

#define SBP2_PHY_RESET_SETTLING_TIME (-10000000 * 1) // 1 sec in units of 100 nsecs


#define SCSI_COMMAND_SET_ID 0x0104D8

//
// vendor hacks
//

#define LSI_VENDOR_ID   0x0000A0B8


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\sbp2port\sbp2scsi.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    sbp2scsi.c

Abstract:

    module for the SBP-2 SCSI interface routines

    Author:

    George Chrysanthakopoulos January-1997 (started)

Environment:

    Kernel mode

Revision History :

--*/

#include "sbp2port.h"


NTSTATUS
Sbp2ScsiRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles all IRP_MJ_SCSI requests and queues them on
    our device queue. Then it calls StartNextPacket so our StartIo
    will run and process the request.

Arguments:

    DeviceObject - this driver's device object
    Irp - the class driver request

Return Value:
    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb;
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    KIRQL cIrql;


    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, NULL);

    if (!NT_SUCCESS (status)) {

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Get a pointer to the SRB.
    //

    srb = irpStack->Parameters.Scsi.Srb;

    switch (srb->Function) {

    case SRB_FUNCTION_EXECUTE_SCSI:

        if (TEST_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_REMOVED | DEVICE_FLAG_PNP_STOPPED |
                    DEVICE_FLAG_DEVICE_FAILED)
                )) {

            //
            // we got a REMOVE/STOP, we can't accept any more requests...
            //

            status = STATUS_DEVICE_DOES_NOT_EXIST;

            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->InternalStatus = status;


            DEBUGPRINT2((
                "Sbp2Port: ScsiReq: ext=x%p rmv/stop (fl=x%x), status=x%x\n",
                deviceExtension,
                deviceExtension->DeviceFlags,
                status
                ));

            Irp->IoStatus.Status = srb->InternalStatus;
            IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
            IoCompleteRequest (Irp,IO_NO_INCREMENT);
            return status;
        }

        //
        // check if this is a request that can be failed if we are powered down..
        //

        if (TEST_FLAG(srb->SrbFlags,SRB_FLAGS_NO_KEEP_AWAKE)) {

            //
            // if we are in d3 punt this irp...
            //

            if (deviceExtension->DevicePowerState == PowerDeviceD3) {

                DEBUGPRINT2((
                    "Sbp2Port: ScsiReq: ext=x%p power down, punt irp=x%p\n",
                    deviceExtension,
                    Irp
                    ));

                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                srb->SrbStatus = SRB_STATUS_NOT_POWERED;
                IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
                IoCompleteRequest (Irp, IO_NO_INCREMENT);
                return STATUS_UNSUCCESSFUL;
            }
        }

        IoMarkIrpPending (Irp);

        if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_QUEUE_LOCKED) &&
            TEST_FLAG(srb->SrbFlags,SRB_FLAGS_BYPASS_LOCKED_QUEUE)) {

            //
            // by pass queueing, this guy has to be processed immediately.
            // Since queue is locked, no other requests are being processed
            //

            if (TEST_FLAG(deviceExtension->DeviceFlags,(DEVICE_FLAG_LOGIN_IN_PROGRESS | DEVICE_FLAG_RECONNECT))){

                //
                // we are in the middle of a bus reset reconnect..
                // defere this until after we have established a connection again
                //

                Sbp2DeferPendingRequest (deviceExtension, Irp);

            } else {

                KeRaiseIrql (DISPATCH_LEVEL, &cIrql);
                Sbp2StartIo (DeviceObject, Irp);
                KeLowerIrql (cIrql);
            }

        } else {

            Sbp2StartPacket (DeviceObject, Irp, &srb->QueueSortKey);
        }

        return STATUS_PENDING;
        break;

    case SRB_FUNCTION_CLAIM_DEVICE:

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);

        if (TEST_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_CLAIMED)) {

            status = STATUS_DEVICE_BUSY;
            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->InternalStatus = STATUS_DEVICE_BUSY;

        } else {

            SET_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_CLAIMED);
            srb->DataBuffer = DeviceObject;
            srb->SrbStatus = SRB_STATUS_SUCCESS;
            status = STATUS_SUCCESS;
        }

        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);
        break;

    case SRB_FUNCTION_RELEASE_DEVICE:

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_CLAIMED);
        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        srb->SrbStatus = SRB_STATUS_SUCCESS;
        status = STATUS_SUCCESS;
        break;

    case SRB_FUNCTION_FLUSH_QUEUE:
    case SRB_FUNCTION_FLUSH:

        DEBUGPRINT3(("Sbp2Port: ScsiReq: Flush Queue/ORB list\n" ));

        if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_STOPPED)) {

            CleanupOrbList(deviceExtension,STATUS_REQUEST_ABORTED);

            srb->SrbStatus = SRB_STATUS_SUCCESS;
            status = STATUS_SUCCESS;

        } else {

            //
            // ISSUE-georgioc-2000/02/20  FLUSH_QUEUE should be failed if they
            //      cannot be handled.
            //

            DEBUGPRINT3(("Sbp2Port: ScsiReq: Cannot Flush active queue\n" ));
            srb->SrbStatus = SRB_STATUS_SUCCESS;
            status = STATUS_SUCCESS;
        }

        break;

    case SRB_FUNCTION_RESET_BUS:

        status = Sbp2Issue1394BusReset(deviceExtension);

        DEBUGPRINT3(("Sbp2Port: ScsiReq: Issuing a 1394 bus reset. \n" ));

        if (!NT_SUCCESS(status)) {

            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->InternalStatus = status;

        } else {

            srb->SrbStatus = SRB_STATUS_SUCCESS;
        }

        break;

    case SRB_FUNCTION_LOCK_QUEUE:

        //
        // lock the queue
        //

        if (TEST_FLAG(deviceExtension->DeviceFlags,(DEVICE_FLAG_REMOVED | DEVICE_FLAG_STOPPED)) ) {

            status = STATUS_DEVICE_DOES_NOT_EXIST;
            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->InternalStatus = STATUS_DEVICE_DOES_NOT_EXIST;

        } else {

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            SET_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_QUEUE_LOCKED);
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            status = STATUS_SUCCESS;
            srb->SrbStatus = SRB_STATUS_SUCCESS;

            DEBUGPRINT2(("Sbp2Port: ScsiReq: ext=x%p, LOCK_QUEUE\n", deviceExtension));
        }

        break;

    case SRB_FUNCTION_UNLOCK_QUEUE:

        //
        // re-enable the device queue...
        //

        DEBUGPRINT2(("Sbp2Port: ScsiReq: ext=x%p, UNLOCK_QUEUE\n", deviceExtension));

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_QUEUE_LOCKED);
        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        //
        // check if there was a request that was deferred until we were powerd up..
        //
        //

        if (deviceExtension->PowerDeferredIrp) {

            PIRP tIrp = deviceExtension->PowerDeferredIrp;

            DEBUGPRINT2((
                "Sbp2Port: ScsiReq: restart powerDeferredIrp=x%p\n",
                tIrp
                ));

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            deviceExtension->PowerDeferredIrp = NULL;
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            Sbp2StartPacket (DeviceObject, tIrp, NULL);
        }

        if (deviceExtension->DevicePowerState == PowerDeviceD0) {

            //
            // the queue was just unlocked and we are in D0, which means we can resume
            // packet processing...
            //

            KeRaiseIrql (DISPATCH_LEVEL, &cIrql);

            Sbp2StartNextPacketByKey(
                DeviceObject,
                deviceExtension->CurrentKey
                );

            KeLowerIrql (cIrql);
        }

        if (TEST_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_REMOVED)) {

            status = STATUS_DEVICE_DOES_NOT_EXIST;
            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->InternalStatus = STATUS_DEVICE_DOES_NOT_EXIST;
            break;

        } else if (deviceExtension->DevicePowerState == PowerDeviceD3) {

            //
            // Clean up any deferred FREEs so we HAVE to use the ORB_POINTER
            // write on the next insertion to the pending list
            //

            KeAcquireSpinLock(&deviceExtension->OrbListSpinLock,&cIrql);

            if (deviceExtension->NextContextToFree) {

                FreeAsyncRequestContext(deviceExtension,deviceExtension->NextContextToFree);
                deviceExtension->NextContextToFree = NULL;
            }

            KeReleaseSpinLock (&deviceExtension->OrbListSpinLock,cIrql);

            if (deviceExtension->SystemPowerState != PowerSystemWorking) {

                KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);

                //
                // we need to invalidate our generation because on resume we might try to issue
                // a request BEFORE we get the bus reset notification..
                //

                deviceExtension->CurrentGeneration = 0xFFFFFFFF;
                KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            }

            srb->SrbStatus = SRB_STATUS_SUCCESS;
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);

            if (deviceExtension->SystemPowerState == PowerSystemWorking) {
#if DBG
                if (!IsListEmpty (&DeviceObject->DeviceQueue.DeviceListHead)) {

                    DEBUGPRINT2((
                        "\nSbp2Port: ScsiReq: ext=x%p, RESTARTING NON-EMPTY " \
                            "DEV_Q AT D3!\n",
                        deviceExtension
                        ));
                }
#endif
                KeRaiseIrql (DISPATCH_LEVEL, &cIrql);

                Sbp2StartNextPacketByKey(
                    DeviceObject,
                    deviceExtension->CurrentKey
                    );

                KeLowerIrql (cIrql);
            }

            IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);

            return STATUS_SUCCESS;
        }

        status = STATUS_SUCCESS;
        srb->SrbStatus = SRB_STATUS_SUCCESS;
        break;

    default:

        status = STATUS_NOT_SUPPORTED;
        srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        srb->InternalStatus = STATUS_NOT_SUPPORTED;
        DEBUGPRINT3(("Sbp2Port: ScsiReq: SRB Function not handled, srb->CdbLength %x, Exiting.\n",srb->CdbLength ));
        break;
    }

    if (!NT_SUCCESS(status)) {

        //
        // it'll either have gone to the StartIo routine or have been
        // failed before hitting the device.  Therefore ensure that
        // srb->InternalStatus is set correctly.
        //

        ASSERT(srb->SrbStatus == SRB_STATUS_INTERNAL_ERROR);
        ASSERT((LONG)srb->InternalStatus == status);
    }

    Irp->IoStatus.Status = status;
    IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
}


VOID
Sbp2StartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Takes incoming, queued requests, and sends them down to the 1394 bus

Arguments:
    DeviceObject - Our device object
    Irp - Request from class drivers,

Return Value:

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb;
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PASYNC_REQUEST_CONTEXT context;


    //
    // Get a pointer to the SRB.
    //

    srb = irpStack->Parameters.Scsi.Srb;

    Irp->IoStatus.Status = STATUS_PENDING;
    srb->SrbStatus = SRB_STATUS_PENDING;

    if (TEST_FLAG(
            deviceExtension->DeviceFlags,
            (DEVICE_FLAG_REMOVED | DEVICE_FLAG_PNP_STOPPED |
                DEVICE_FLAG_DEVICE_FAILED | DEVICE_FLAG_ABSENT_ON_POWER_UP)
            )) {

        //
        // Removed, stopped, or absent, so can't accept any more requests
        //

        status = STATUS_DEVICE_DOES_NOT_EXIST;
        srb->SrbStatus = SRB_STATUS_NO_DEVICE;

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

        DEBUGPRINT2((
            "Sbp2Port: StartIo: dev stopped/removed/absent, fail irp=x%p\n",
            Irp
            ));

       Sbp2StartNextPacketByKey (DeviceObject, 0);

       IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);

       return;
    }

    if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_QUEUE_LOCKED)) {

        if (!TEST_FLAG(srb->SrbFlags,SRB_FLAGS_BYPASS_LOCKED_QUEUE)) {

            if (!Sbp2InsertByKeyDeviceQueue(
                    &DeviceObject->DeviceQueue,
                    &Irp->Tail.Overlay.DeviceQueueEntry,
                    srb->QueueSortKey)) {

                //
                // ISSUE-georgioc-2000/02/20  deadlock possible because
                //    queue is now busy and noone has called StartIo().
                //    should instead queue the request and then later,
                //    after an UNLOCK arrives, process this queue of
                //    requests that occurred when the queue was locked.
                //    OR should comment why this is not a deadlock
                //

                DEBUGPRINT2((
                    "Sbp2Port: StartIo: insert failed, compl irp=x%p\n",
                    Irp
                    ));

                srb->SrbStatus = SRB_STATUS_BUSY;
                Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
                IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
                IoCompleteRequest(Irp,IO_NO_INCREMENT);
            }

            return;
        }

    } else {

        //
        // CASE 1: Device powered Down, but system running.
        //
        // Queue this request, Power up device, then when done start
        // processing requests
        //

        if ((deviceExtension->DevicePowerState == PowerDeviceD3) &&
            (deviceExtension->SystemPowerState == PowerSystemWorking)) {

            BOOLEAN     queued;
            POWER_STATE state;


            queued = Sbp2InsertByKeyDeviceQueue(
                &DeviceObject->DeviceQueue,
                &Irp->Tail.Overlay.DeviceQueueEntry,
                srb->QueueSortKey
                );

            if (!queued) {

                DEBUGPRINT2((
                    "Sbp2Port: StartIo: dev q not busy, defer irp=x%p\n",
                    Irp
                    ));

                ASSERT(deviceExtension->PowerDeferredIrp == NULL);

                KeAcquireSpinLockAtDpcLevel(
                    &deviceExtension->ExtensionDataSpinLock
                    );

                deviceExtension->PowerDeferredIrp = Irp;

                KeReleaseSpinLockFromDpcLevel(
                    &deviceExtension->ExtensionDataSpinLock
                    );
            }

            //
            // We need to send our own stack a d0 irp, so the device
            // powers up and can process this request.
            // Block until the Start_STOP_UNIT to start, is called.
            // This has to happen in two steps:
            // 1: Send D Irp to stack, which might power up the controller
            // 2: Wait for completion of START UNIT send by class driver,
            //    if success start processing requests...
            //

            DEBUGPRINT2((
                "Sbp2Port: StartIo: dev powered down, q(%x) irp=x%p " \
                    "til power up\n",
                queued,
                Irp
                ));

            state.DeviceState = PowerDeviceD0;

            DEBUGPRINT1((
                "Sbp2Port: StartIo: sending D irp for state %x\n",
                state
                ));

            status = PoRequestPowerIrp(
                         deviceExtension->DeviceObject,
                         IRP_MN_SET_POWER,
                         state,
                         NULL,
                         NULL,
                         NULL);

            if (!NT_SUCCESS(status)) {

                //
                // not good, we cant power up the device..
                //

                DEBUGPRINT1(("Sbp2Port: StartIo: D irp err=x%x\n", status));

                if (!queued) {

                    KeAcquireSpinLockAtDpcLevel(
                        &deviceExtension->ExtensionDataSpinLock
                        );

                    if (deviceExtension->PowerDeferredIrp == Irp) {

                        deviceExtension->PowerDeferredIrp = NULL;

                    } else {

                        Irp = NULL;
                    }

                    KeReleaseSpinLockFromDpcLevel(
                        &deviceExtension->ExtensionDataSpinLock
                        );

                } else {

                    //
                    // If the irp is still in the device queue then remove it.
                    // Don't worry about the queue's busy flag - if irp found
                    // then queue gets restarted by StartNextPacket below,
                    // else another thread processed the irp, thereby
                    // restarting the queue.
                    //

                    PIRP            qIrp = NULL;
                    PLIST_ENTRY     entry;
                    PKDEVICE_QUEUE  queue = &DeviceObject->DeviceQueue;


                    KeAcquireSpinLockAtDpcLevel (&queue->Lock);

                    for(
                        entry = queue->DeviceListHead.Flink;
                        entry != &queue->DeviceListHead;
                        entry = entry->Flink
                        ) {

                        qIrp = CONTAINING_RECORD(
                            entry,
                            IRP,
                            Tail.Overlay.DeviceQueueEntry.DeviceListEntry
                            );

                        if (qIrp == Irp) {

                            RemoveEntryList (entry);
                            break;
                        }
                    }

                    KeReleaseSpinLockFromDpcLevel (&queue->Lock);

                    if (qIrp != Irp) {

                        Irp = NULL;
                    }
                }

                if (Irp) {

                    srb->SrbStatus = SRB_STATUS_ERROR;
                    Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                    IoCompleteRequest (Irp,IO_NO_INCREMENT);

                    Sbp2StartNextPacketByKey (DeviceObject, 0);

                    IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);

                } else {

                    //
                    // Another thread processed this irp, it will take
                    // care of the cleanup
                    //

                    DEBUGPRINT1(("Sbp2Port: StartIo: ... irp NOT FOUND!\n"));
                }
            }

            return;
        }

        //
        // case 2: Reset in progress (either reconnect or login in progress)
        //
        // Queue request until we are done. When reset over, start
        // processing again.
        //

        if (TEST_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_RESET_IN_PROGRESS
                )) {

            //
            // Queue request (twice, in case queue wasn't busy the 1st time).
            // We acquire the spinlock to prevent the case where we try to
            // insert to a non-busy queue, then a 2nd thread completing
            // the reset calls StartNextPacket (which would reset the q busy
            // flag), then we try to insert again and fail - the result
            // being deadlock since no one will restart the queue.
            //

            KeAcquireSpinLockAtDpcLevel(
                &deviceExtension->ExtensionDataSpinLock
                );

            if (TEST_FLAG(
                    deviceExtension->DeviceFlags,
                    DEVICE_FLAG_RESET_IN_PROGRESS
                    )) {

                if (Sbp2InsertByKeyDeviceQueue(
                        &DeviceObject->DeviceQueue,
                        &Irp->Tail.Overlay.DeviceQueueEntry,
                        srb->QueueSortKey
                        ) ||

                    Sbp2InsertByKeyDeviceQueue(
                        &DeviceObject->DeviceQueue,
                        &Irp->Tail.Overlay.DeviceQueueEntry,
                        srb->QueueSortKey
                        )) {

                    KeReleaseSpinLockFromDpcLevel(
                        &deviceExtension->ExtensionDataSpinLock
                        );

                    DEBUGPRINT2((
                        "Sbp2Port: StartIo: ext=x%p resetting, q irp=x%p\n",
                        deviceExtension,
                        Irp
                        ));

                    return;
                }

                KeReleaseSpinLockFromDpcLevel(
                    &deviceExtension->ExtensionDataSpinLock
                    );

                DEBUGPRINT1((
                    "Sbp2Port: StartIo: ext=x%p 2xQ err, fail irp=x%p\n",
                    deviceExtension,
                    Irp
                    ));

                ASSERT (FALSE); // should never get here

                srb->SrbStatus = SRB_STATUS_BUSY;
                Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
                IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
                IoCompleteRequest(Irp,IO_NO_INCREMENT);

                return;
            }

            KeReleaseSpinLockFromDpcLevel(
                &deviceExtension->ExtensionDataSpinLock
                );
        }

        //
        // CASE 3: System is powered down, and so is device (better be).
        // Queue all requests until system comes up from sleep
        //

        if ((deviceExtension->DevicePowerState != PowerDeviceD0) &&
            (deviceExtension->SystemPowerState != PowerSystemWorking)) {

            //
            // our device is powered down AND the system is powered down.
            // just queue this request...
            //

            if (!Sbp2InsertByKeyDeviceQueue(
                    &DeviceObject->DeviceQueue,
                    &Irp->Tail.Overlay.DeviceQueueEntry,
                    srb->QueueSortKey)) {

                ASSERT(deviceExtension->PowerDeferredIrp == NULL);

                KeAcquireSpinLockAtDpcLevel(
                    &deviceExtension->ExtensionDataSpinLock
                    );

                deviceExtension->PowerDeferredIrp = Irp;

                KeReleaseSpinLockFromDpcLevel(
                    &deviceExtension->ExtensionDataSpinLock
                    );

                DEBUGPRINT2((
                    "Sbp2Port: StartIo: powered down, defer irp=x%p\n",
                    Irp
                    ));

            } else {

                DEBUGPRINT2((
                    "Sbp2Port: StartIo: powered down, q irp=%p\n",
                    Irp
                    ));
            }

            return;
        }
    }

    if (!TEST_FLAG (srb->SrbFlags, SRB_FLAGS_NO_KEEP_AWAKE)) {

        if (deviceExtension->IdleCounter) {

            PoSetDeviceBusy (deviceExtension->IdleCounter);
        }
    }

    //
    // create a context ,a CMD orb and the appropriate data descriptor
    //

    Create1394TransactionForSrb (deviceExtension, srb, &context);

    return;
}


VOID
Create1394TransactionForSrb(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PASYNC_REQUEST_CONTEXT *RequestContext
    )
/*++

Routine Description:

    Always called at DPC level...
    This routine is responsible for allocating all the data structures and
    getting all the 1394 addresses required for incoming scsi requests.
    It will fill in Command ORBs, create page table if necessery, and
    most importantly setup a request Context, so when the status callback
    is called, we can find the srb Associated with completed ORB. Since we
    have a FreeList, this request will always use pre-allocated contexts
    and page tables, so we dont have to do it dynamically...

Arguments:

    DeviceObject - Our device object
    Srb - SRB from class drivers,
    RequestContext - Pointer To Context used for this request.
    Mdl - MDL with data buffer for this request

Return Value:

--*/
{
    NTSTATUS status= STATUS_SUCCESS;
    PMDL requestMdl;

    PASYNC_REQUEST_CONTEXT callbackContext;

    PVOID mdlVa;

    //
    // Allocate a context for this requestfrom our freeList
    //

    callbackContext  = (PASYNC_REQUEST_CONTEXT) ExInterlockedPopEntrySList(
        &DeviceExtension->FreeContextListHead,
        &DeviceExtension->FreeContextLock
        );

    if (callbackContext) {

        callbackContext = RETRIEVE_CONTEXT(callbackContext,LookasideList);

    } else {

        DEBUGPRINT1((
            "Sbp2Port: Create1394XactForSrb: ERROR! ext=x%p, no ctx's\n",
            DeviceExtension
            ));

        status = STATUS_INSUFFICIENT_RESOURCES;
        Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        Srb->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

        Sbp2CreateRequestErrorLog(DeviceExtension->DeviceObject,NULL,status);

        goto exitCreate1394ReqForSrb;
    }

    //
    // Acquire the OrbListSpinLock to serialize this OrbListDepth
    // change & save with those done in Sbp2GlobalStatusCallback
    // (when freeing async requests), to insure we won't make too
    // many or too few calls to StartNextPacket
    //

    KeAcquireSpinLockAtDpcLevel (&DeviceExtension->OrbListSpinLock);

    callbackContext->OrbListDepth = InterlockedIncrement(
        &DeviceExtension->OrbListDepth
        );

    KeReleaseSpinLockFromDpcLevel (&DeviceExtension->OrbListSpinLock);


    *RequestContext = callbackContext;

    //
    // Initialize srb-related entries in our context
    //

    callbackContext->OriginalSrb = NULL;
    callbackContext->DataMappingHandle = NULL;
    callbackContext->Packet = NULL;
    callbackContext->Tag = SBP2_ASYNC_CONTEXT_TAG;
    callbackContext->Srb = Srb;
    callbackContext->DeviceObject = DeviceExtension->DeviceObject;

    callbackContext->Flags = 0;

    //
    // filter commands so they conform to RBC..
    //

    status = Sbp2_SCSI_RBC_Conversion(callbackContext);

    if (status != STATUS_PENDING){

        //
        // the call was handled immediately. Complete the irp here...
        //

        callbackContext->Srb = NULL;
        FreeAsyncRequestContext(DeviceExtension,callbackContext);

        if (NT_SUCCESS(status)) {

            Srb->SrbStatus = SRB_STATUS_SUCCESS;

            ((PIRP) Srb->OriginalRequest)->IoStatus.Information = Srb->DataTransferLength;

        } else {

            DEBUGPRINT1((
                "Sbp2Port: Create1394XactForSrb: RBC translation failed!!!\n"
                ));

            //
            // since translation errors are always internal errors,
            // set SRB_STATUS to reflect an internal (not device) error
            //

            Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            Srb->InternalStatus = status;
            ((PIRP)Srb->OriginalRequest)->IoStatus.Information = 0;
        }

        ((PIRP)Srb->OriginalRequest)->IoStatus.Status = status;
        IoCompleteRequest (((PIRP) Srb->OriginalRequest), IO_NO_INCREMENT);

        Sbp2StartNextPacketByKey(
            DeviceExtension->DeviceObject,
            DeviceExtension->CurrentKey
            );

        IoReleaseRemoveLock (&DeviceExtension->RemoveLock, NULL);

        return;
    }

    status = STATUS_SUCCESS;

    //
    // Figure the maximum number of different 1394 addresses we need to span this request's data buffer
    //

    if ((Srb->DataTransferLength == 0) || TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER)) {

        //
        // No need to get a 1394 address for data, since there is none
        //

        Sbp2InitializeOrb (DeviceExtension, callbackContext);

    } else {

        //
        // if this request is apart of split request, we need to make our own mdl...
        //

        requestMdl = ((PIRP) Srb->OriginalRequest)->MdlAddress;

        mdlVa = MmGetMdlVirtualAddress (requestMdl);

        if (mdlVa != (PVOID) Srb->DataBuffer) {

            //
            // split request
            //

            callbackContext->PartialMdl = IoAllocateMdl(Srb->DataBuffer,Srb->DataTransferLength,FALSE,FALSE,NULL);

            if (!callbackContext->PartialMdl) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
                Srb->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

                DEBUGPRINT1((
                    "Sbp2Port: Create1394XactForSrb: REQ_ALLOC addr err!\n"
                    ));

                goto exitCreate1394ReqForSrb;
            }

            IoBuildPartialMdl(requestMdl,callbackContext->PartialMdl,Srb->DataBuffer, Srb->DataTransferLength );
            requestMdl = callbackContext->PartialMdl;
            DEBUGPRINT4(("Sbp2Port: Create1394TransactionForSrb: Allocating Partial Mdl %p\n",requestMdl));

        } else {

            callbackContext->PartialMdl = NULL;
        }

        callbackContext->RequestMdl = requestMdl;

        //
        // according to what the port driver can handle, map the data buffer to 1394 addresses and create
        // an sbp2 page table if necessery
        //

        status = Sbp2BusMapTransfer(DeviceExtension,callbackContext);

        //
        // NOTE: On success, above returns STATUS_PENDING
        // all errors are internal errors.
        //

        if (!NT_SUCCESS(status)) {

            DEBUGPRINT1(("\n Sbp2Create1394TransactionForSrb failed %x\n",status));

            if (callbackContext->PartialMdl) {

                IoFreeMdl(callbackContext->PartialMdl);

                callbackContext->PartialMdl = NULL;
            }
        }
    }

exitCreate1394ReqForSrb:

    if (status == STATUS_PENDING) {

        //
        // Sbp2StartNextPacketByKey will be called when the
        // notification alloc callback is called
        //

        return;

    } else if (status == STATUS_SUCCESS) { // ISSUE-geogioc-2000/02/20 - NT_SUCCESS(status) should be used

        //
        // SUCCESS, place
        //

        Sbp2InsertTailList(DeviceExtension,callbackContext);
        return;

    } else {

        //
        // since the request could not have actually been processed by
        // the device, this is an internal error and should be propogated
        // up the stack as such.
        //

        if (callbackContext) {

            callbackContext->Srb = NULL;
            FreeAsyncRequestContext(DeviceExtension,callbackContext);
        }

        Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        Srb->InternalStatus = status;

        ((PIRP)Srb->OriginalRequest)->IoStatus.Status = status;
        ((PIRP)Srb->OriginalRequest)->IoStatus.Information = 0;

        IoCompleteRequest(((PIRP)Srb->OriginalRequest),IO_NO_INCREMENT);

        Sbp2StartNextPacketByKey (DeviceExtension->DeviceObject, 0);

        IoReleaseRemoveLock (&DeviceExtension->RemoveLock, NULL);

        return;
    }

    return;
}


NTSTATUS
Sbp2_SCSI_RBC_Conversion(
    IN PASYNC_REQUEST_CONTEXT Context
    )
/*++

Routine Description:

    Always called at DPC level...
    It translates scsi commands to their RBC equivalents, ONLY if they differ in each spec
    The translation is done before request is issued and in some cases, after the request is
    completed

Arguments:

    DeviceExtension - Sbp2 extension
    RequestContext - Pointer To Context used for this request.

Return Value:

--*/
{
    PCDB cdb;


    if (TEST_FLAG(Context->Flags, ASYNC_CONTEXT_FLAG_COMPLETED)) {

        //
        // completed request translation
        //

        if ( ((PDEVICE_EXTENSION)Context->DeviceObject->DeviceExtension)->InquiryData.DeviceType == \
            RBC_DEVICE){

            return Rbc_Scsi_Conversion(Context->Srb,
                                &(PSCSI_REQUEST_BLOCK)Context->OriginalSrb,
                                &((PDEVICE_EXTENSION)Context->DeviceObject->DeviceExtension)->DeviceModeHeaderAndPage,
                                FALSE,
                                ((PDEVICE_EXTENSION)Context->DeviceObject->DeviceExtension)->InquiryData.RemovableMedia
                                );
        }

    } else {

        //
        // outgoing request translation
        //

        if (((PDEVICE_EXTENSION)Context->DeviceObject->DeviceExtension)->InquiryData.DeviceType == \
            RBC_DEVICE){

            return Rbc_Scsi_Conversion(Context->Srb,
                                &(PSCSI_REQUEST_BLOCK)Context->OriginalSrb,
                                &((PDEVICE_EXTENSION)Context->DeviceObject->DeviceExtension)->DeviceModeHeaderAndPage,
                                TRUE,
                                ((PDEVICE_EXTENSION)Context->DeviceObject->DeviceExtension)->InquiryData.RemovableMedia
                                );

        } else if (((PDEVICE_EXTENSION)Context->DeviceObject->DeviceExtension)->InquiryData.DeviceType == \
            READ_ONLY_DIRECT_ACCESS_DEVICE){

            switch (Context->Srb->Cdb[0]) {

            case SCSIOP_MODE_SENSE10:

                //
                // mmc2 type of device..
                //

                cdb = (PCDB) &Context->Srb->Cdb[0];
                cdb->MODE_SENSE10.Dbd = 1;

                break;
            }
        }
    }

    return STATUS_PENDING;
}


NTSTATUS
Sbp2BusMapTransfer(
    PDEVICE_EXTENSION DeviceExtension,
    PASYNC_REQUEST_CONTEXT CallbackContext
    )
/*++

Routine Description:

    Always called at DPC level...
    It calls the port driver to map the data buffer to physical/1394 addresses

Arguments:

    DeviceExtension - Sbp2 extension
    RequestContext - Pointer To Context used for this request.
    Mdl - MDL with data buffer for this request

Return Value:

--*/
{
    NTSTATUS status;

#if DBG

    ULONG maxNumberOfPages;


    maxNumberOfPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
        CallbackContext->Srb->DataBuffer,
        CallbackContext->Srb->DataTransferLength
        );

    ASSERT (CallbackContext->PageTableContext.PageTable != NULL);
    ASSERT (maxNumberOfPages <= SBP2_NUM_PAGE_TABLE_ENTRIES);

#endif

    //
    // Do the DATA alloc.
    //

    SET_FLAG(CallbackContext->Flags, ASYNC_CONTEXT_FLAG_PAGE_ALLOC);
    CallbackContext->Packet = NULL;
    Sbp2AllocComplete (CallbackContext);

    DEBUGPRINT4((
        "Sbp2Port: Sbp2MapAddress: alloc done, ctx=x%p, dataHandle=x%p\n",
        CallbackContext,
        CallbackContext->DataMappingHandle
        ));

    if (TEST_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_DATA_ALLOC_FAILED)) {

        CLEAR_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_DATA_ALLOC);
        CLEAR_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_DATA_ALLOC_FAILED);

        DEBUGPRINT1((
            "Sbp2Port: Sbp2MapAddress: (page table present) REQ_ALLOC data " \
                "err, ctx=x%p\n",
            CallbackContext
            ));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_PENDING;
}


VOID
Sbp2AllocComplete(
    IN PASYNC_REQUEST_CONTEXT CallbackContext
    )
{

    PDEVICE_EXTENSION deviceExtension = CallbackContext->DeviceObject->DeviceExtension;
    PIRBIRP packet = CallbackContext->Packet;
    PPORT_PHYS_ADDR_ROUTINE routine = deviceExtension->HostRoutineAPI.PhysAddrMappingRoutine;
    PSCSI_REQUEST_BLOCK srb;

    NTSTATUS status;
    BOOLEAN bDirectCall = FALSE;

    DEBUGPRINT4(("Sbp2AllocateComplete: ctx=x%p, flags=x%x\n",CallbackContext,CallbackContext->Flags));

    //
    // this same function is used for the alloc complete notification of a pagetable
    // AND of the actuall data tranfser. So we have to check which case this is
    // This is a simple state machine with two states:
    // startIo-> A: PAGE TABLE ALLOC -> B
    // B: DATA ALLOC ->exit
    //

    if (TEST_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_PAGE_ALLOC)) {

        CLEAR_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_PAGE_ALLOC);

        if (CallbackContext->Packet) {

            //
            // we have just received the page table alloc...
            //

            ASSERT (FALSE); // should never get here any more

        } else {

            //
            // We were called directly since a sufficient page table was
            // already in the context
            //

            AllocateIrpAndIrb (deviceExtension,&packet);

            if (!packet) {

                return;
            }

            CallbackContext->Packet = packet;
            bDirectCall = TRUE;
        }

        //
        // indicate that now we are in the DATA transfer alloc case
        //

        SET_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_DATA_ALLOC);

        //
        // reuse the same irb/irp
        // prepare the irb for calling the 1394 bus/port driver synchronously
        //

        packet->Irb->FunctionNumber = REQUEST_ALLOCATE_ADDRESS_RANGE;

        //
        // we only want a call back when we get a status from the target
        // Now allocate 1394 addresses for the data buffer with no notification
        //

        packet->Irb->u.AllocateAddressRange.nLength = CallbackContext->Srb->DataTransferLength;
        packet->Irb->u.AllocateAddressRange.fulNotificationOptions = NOTIFY_FLAGS_NEVER;

        if (TEST_FLAG(CallbackContext->Srb->SrbFlags,SRB_FLAGS_DATA_IN)) {

            packet->Irb->u.AllocateAddressRange.fulAccessType = ACCESS_FLAGS_TYPE_WRITE;

        } else {

            packet->Irb->u.AllocateAddressRange.fulAccessType = ACCESS_FLAGS_TYPE_READ;
        }

        packet->Irb->u.AllocateAddressRange.fulFlags = ALLOCATE_ADDRESS_FLAGS_USE_BIG_ENDIAN;

        //
        // the callback for physical address is used to notify that the async allocate request
        // is now complete..
        //

        packet->Irb->u.AllocateAddressRange.Callback= Sbp2AllocComplete;
        packet->Irb->u.AllocateAddressRange.Context= CallbackContext;

        packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_High = 0;
        packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_Low = 0;

        packet->Irb->u.AllocateAddressRange.FifoSListHead = NULL;
        packet->Irb->u.AllocateAddressRange.FifoSpinLock = NULL;

        packet->Irb->u.AllocateAddressRange.AddressesReturned = 0;
        packet->Irb->u.AllocateAddressRange.DeviceExtension = deviceExtension;
        packet->Irb->u.AllocateAddressRange.p1394AddressRange = (PADDRESS_RANGE) &(CallbackContext->PageTableContext.PageTable[0]);

        packet->Irb->u.AllocateAddressRange.Mdl = CallbackContext->RequestMdl; //MDL from original request
        packet->Irb->u.AllocateAddressRange.MaxSegmentSize = (SBP2_MAX_DIRECT_BUFFER_SIZE+1)/2;

        CallbackContext->Packet = packet;

        //
        // Send allocateRange request to bus driver , indicating that we dont want the irp to be freed
        // If the port driver supports a direct mapping routine, call that instead
        //

        status = (*routine) (deviceExtension->HostRoutineAPI.Context,packet->Irb);

        if (status == STATUS_SUCCESS) {

             return;

        } else {

            DEBUGPRINT1(("Sbp2Port: Sbp2AllocComplete: REQUEST_ALLOCATE Address failed, ctx=x%p, direct=%x!!\n",CallbackContext,bDirectCall));

            DeAllocateIrpAndIrb(deviceExtension,packet);
            CallbackContext->Packet = NULL;
            CallbackContext->DataMappingHandle = NULL;
            SET_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_DATA_ALLOC_FAILED);

            if (bDirectCall) {

                return;

            } else {

                //
                // we were indirectly called, so the irp has already been marked pending..
                // we must abort it here and complete the context with error...
                //

                srb = CallbackContext->Srb;
                CallbackContext->Srb = NULL;

                FreeAsyncRequestContext(deviceExtension,CallbackContext);

                srb->SrbStatus = SRB_STATUS_ERROR;

                ((PIRP)srb->OriginalRequest)->IoStatus.Status = status;
                ((PIRP)srb->OriginalRequest)->IoStatus.Information = 0;

                IoCompleteRequest(((PIRP)srb->OriginalRequest),IO_NO_INCREMENT);

                Sbp2StartNextPacketByKey (deviceExtension->DeviceObject, 0);

                IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
                return;
            }
        }
    }

    if (TEST_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_DATA_ALLOC)) {

        //
        // we have a page table so this means we just been notified that the DATA alloc is over
        // Save the handle to the data descriptor's memory range
        //

        CLEAR_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_DATA_ALLOC);

        CallbackContext->DataMappingHandle = CallbackContext->Packet->Irb->u.AllocateAddressRange.hAddressRange;

        //
        // number of page table elements required
        //

        CallbackContext->PageTableContext.NumberOfPages = CallbackContext->Packet->Irb->u.AllocateAddressRange.AddressesReturned;

        DeAllocateIrpAndIrb(deviceExtension,CallbackContext->Packet);
        CallbackContext->Packet = NULL;

        Sbp2InitializeOrb(deviceExtension,CallbackContext);
        Sbp2InsertTailList(deviceExtension,CallbackContext);
    }

    return;
}


VOID
Sbp2InitializeOrb(
    IN PDEVICE_EXTENSION DeviceExtension,
    PASYNC_REQUEST_CONTEXT CallbackContext
    )
{
    ULONG   i, size;


    //
    // zero the ORB CDB and ORB Flags fields
    //

    CallbackContext->CmdOrb->OrbInfo.QuadPart = 0;


    if (!CallbackContext->DataMappingHandle) {

        CallbackContext->PageTableContext.NumberOfPages = 0;
        CallbackContext->CmdOrb->DataDescriptor.OctletPart = 0xFFFFFFFFFFFFFFFF;

    } else {

        if (CallbackContext->PageTableContext.NumberOfPages > 1) {

            CallbackContext->CmdOrb->DataDescriptor.BusAddress = \
                CallbackContext->PageTableContext.AddressContext.Address.BusAddress;

            octbswap(CallbackContext->CmdOrb->DataDescriptor);

            //
            // If the host does not convert the table to big endian (or
            // there's an associated scatter gather list), do it here
            //

            if ((DeviceExtension->HostRoutineAPI.PhysAddrMappingRoutine == NULL)
                    ||  (CallbackContext->RequestMdl == NULL)) {

                for (i=0;i<CallbackContext->PageTableContext.NumberOfPages;i++) {

                    octbswap(CallbackContext->PageTableContext.PageTable[i]); // convert to big endian
                }
            }


            //
            // setup the cmd orb for a page table
            //

            CallbackContext->CmdOrb->OrbInfo.u.HighPart |= ORB_PAGE_TABLE_BIT_MASK;

            //
            // we define a data size equal (since we are in page table mode)
            // to number of pages. The page table has already been allocated .
            //

            CallbackContext->CmdOrb->OrbInfo.u.LowPart = (USHORT) CallbackContext->PageTableContext.NumberOfPages;

        } else {

            CallbackContext->CmdOrb->DataDescriptor = CallbackContext->PageTableContext.PageTable[0];

            //
            // If the host does not convert the table to big endian (or
            // there's an associated scatter gather list), do it here
            //

            if ((DeviceExtension->HostRoutineAPI.PhysAddrMappingRoutine == NULL)
                    ||  (CallbackContext->RequestMdl == NULL)) {

                CallbackContext->CmdOrb->DataDescriptor.BusAddress.NodeId = DeviceExtension->InitiatorAddressId;

                octbswap(CallbackContext->CmdOrb->DataDescriptor);

            } else {

                //
                // address already in big endian, just put the NodeID in the proper place
                //

                CallbackContext->CmdOrb->DataDescriptor.ByteArray.Byte0 = *((PUCHAR)&DeviceExtension->InitiatorAddressId+1);
                CallbackContext->CmdOrb->DataDescriptor.ByteArray.Byte1 = *((PUCHAR)&DeviceExtension->InitiatorAddressId);
            }

            //
            // Data size of buffer data descriptor points to
            //

            CallbackContext->CmdOrb->OrbInfo.u.LowPart = (USHORT) CallbackContext->Srb->DataTransferLength;
        }
    }

    //
    // Start building the ORB used to carry this srb
    // By default notify bit, rq_fmt field and page_size field are all zero..
    // Also the nextOrbAddress is NULL ( which is 0xFFFF..F)
    //

    CallbackContext->CmdOrb->NextOrbAddress.OctletPart = 0xFFFFFFFFFFFFFFFF;

    //
    // Max speed supported
    //

    CallbackContext->CmdOrb->OrbInfo.u.HighPart |= (0x0700 & ((DeviceExtension->MaxControllerPhySpeed) << 8));

    //
    // set notify bit for this command ORB
    //

    CallbackContext->CmdOrb->OrbInfo.u.HighPart |= ORB_NOTIFY_BIT_MASK;

    if (TEST_FLAG(CallbackContext->Srb->SrbFlags,SRB_FLAGS_DATA_IN)) {

        //
        // Read request. Set direction bit to 1
        //

        CallbackContext->CmdOrb->OrbInfo.u.HighPart |= ORB_DIRECTION_BIT_MASK;

        // Max payload size, (its entered in the orb, in the form of  2^(size+2)

        CallbackContext->CmdOrb->OrbInfo.u.HighPart |= DeviceExtension->OrbReadPayloadMask ;

    } else {

        //
        // Write request, direction bit is zero
        //

        CallbackContext->CmdOrb->OrbInfo.u.HighPart &= ~ORB_DIRECTION_BIT_MASK;
        CallbackContext->CmdOrb->OrbInfo.u.HighPart |= DeviceExtension->OrbWritePayloadMask ;
    }

    //
    // Now copy the CDB from the SRB to our ORB
    //

    ASSERT (CallbackContext->Srb->CdbLength >= 6);
    ASSERT (CallbackContext->Srb->CdbLength <= SBP2_MAX_CDB_SIZE);

    size = min (SBP2_MAX_CDB_SIZE, CallbackContext->Srb->CdbLength);

    RtlZeroMemory(&CallbackContext->CmdOrb->Cdb, SBP2_MAX_CDB_SIZE);
    RtlCopyMemory(&CallbackContext->CmdOrb->Cdb, CallbackContext->Srb->Cdb,size);

    //
    // we are done here.... convert command ORB to Big Endian...
    //

    CallbackContext->CmdOrb->OrbInfo.QuadPart = bswap(CallbackContext->CmdOrb->OrbInfo.QuadPart);
}


VOID
Sbp2InsertTailList(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PASYNC_REQUEST_CONTEXT Context
    )
{
    ULONG                   orbListDepth, timeOutValue;
    OCTLET                  newAddr ;
    NTSTATUS                status;
    PASYNC_REQUEST_CONTEXT  prevCtx;


    orbListDepth = Context->OrbListDepth;

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->OrbListSpinLock);

    DeviceExtension->CurrentKey = Context->Srb->QueueSortKey+1;

    if (IsListEmpty (&DeviceExtension->PendingOrbList)) {

        //
        // Empty list, this is the first request
        // This ORB is now at end-of-list, its next_ORB address is set to NULL
        //

        Context->CmdOrb->NextOrbAddress.OctletPart = 0xFFFFFFFFFFFFFFFF;

        //
        // start the timer tracking this request
        // If the list is non empty, only the head of the list is timed...
        //

        timeOutValue = Context->Srb->TimeOutValue;

        DeviceExtension->DueTime.QuadPart =
            ((LONGLONG) timeOutValue) * (-10*1000*1000);

        SET_FLAG(Context->Flags, ASYNC_CONTEXT_FLAG_TIMER_STARTED);

        KeSetTimer(
            &Context->Timer,
            DeviceExtension->DueTime,
            &Context->TimerDpc
            );

        InsertTailList (&DeviceExtension->PendingOrbList,&Context->OrbList);
        newAddr = Context->CmdOrbAddress;

        //
        // ISSUE: Seems like we should always be able to write to the
        //        dev's orb pointer at this point, but we were seeing
        //        timeouts on some devices if we did that (notably
        //        hd's with Oxford Semiconductor silicon doing dv cam
        //        captures), so am sticking with the piggyback logic
        //        for WinXP.  This is a perf hit, because dev has to
        //        read in the old orb to get the next orb addr, then
        //        fetch the new orb.   DanKn 25-Jun-2001
        //

        if (DeviceExtension->NextContextToFree  &&
            DeviceExtension->AppendToNextContextToFree) {

            DeviceExtension->AppendToNextContextToFree = FALSE;

            //
            // There is an end-of-list ORB, just piggy back on it
            //

            octbswap (newAddr);

            DeviceExtension->NextContextToFree->CmdOrb->NextOrbAddress =
                newAddr;
            DeviceExtension->NextContextToFree->CmdOrb->NextOrbAddress.
                ByteArray.Byte0 = 0; // make Null bit zero
            DeviceExtension->NextContextToFree->CmdOrb->NextOrbAddress.
                ByteArray.Byte1 = 0; // make Null bit zero

            //
            // The guy that was the end of the list cannot be freed
            // until this ORB is fetched
            //

            KeReleaseSpinLockFromDpcLevel (&DeviceExtension->OrbListSpinLock);

            DEBUGPRINT3((
                "Sbp2Port: InsertTailList: empty, ring bell, ctx=x%p\n",
                Context
                ));

            status = Sbp2AccessRegister(
                DeviceExtension,
                &DeviceExtension->Reserved,
                DOORBELL_REG | REG_WRITE_ASYNC
                );

        } else {

            //
            // list is empty, write directly to orb_pointer
            //

            KeReleaseSpinLockFromDpcLevel (&DeviceExtension->OrbListSpinLock);

            DEBUGPRINT3((
                "Sbp2Port: InsertTailList: write ORB_PTR, ctx=x%p\n",
                Context
                ));

            status = Sbp2AccessRegister(
                DeviceExtension,
                &newAddr,
                ORB_POINTER_REG | REG_WRITE_ASYNC
                );
        }

        //
        // The following handles the case where a device is removed
        // while machine is on standby, and then machine is resumed.
        // In the storage case, classpnp.sys sends down a start unit
        // srb (in reponse to the power D-irp) with a timeout of
        // 240 seconds.  The problem is that sbp2port.sys does not get
        // notified of the remove until *after* the start unit has
        // timed out (the power irp blocks the pnp irp), and the user
        // gets a bad 240-second wait experience.
        //
        // So what we do here in the case of an invalid generation error
        // & a lengthy timeout is to reset the timer with a more reasonable
        // timeout value.  If the device is still around the bus reset
        // notification routine should get called & clean everything up
        // anyway, and same goes for normal remove (while machine is not
        // hibernated).
        //

        if (status == STATUS_INVALID_GENERATION) {

            KeAcquireSpinLockAtDpcLevel (&DeviceExtension->OrbListSpinLock);

            if ((DeviceExtension->PendingOrbList.Flink == &Context->OrbList) &&
                (timeOutValue > 5)) {

                KeCancelTimer (&Context->Timer);

                DeviceExtension->DueTime.QuadPart = (-5 * 10 * 1000 * 1000);

                KeSetTimer(
                    &Context->Timer,
                    DeviceExtension->DueTime,
                    &Context->TimerDpc
                    );
#if DBG
                timeOutValue = 1;

            } else {

                timeOutValue = 0;
#endif
            }

            KeReleaseSpinLockFromDpcLevel (&DeviceExtension->OrbListSpinLock);

            if (timeOutValue) {

                DEBUGPRINT1((
                    "Sbp2port: InsertTailList: ext=x%p, lowered req timeout\n",
                    DeviceExtension
                    ));
            }
        }

    } else {

        //
        // We have already a list in memory. Append this request to list,
        // modify last request's ORB to point to this ORB.
        //

        newAddr = Context->CmdOrbAddress;

        //
        // Init the list pointer for this request context
        //

        Context->CmdOrb->NextOrbAddress.OctletPart = 0xFFFFFFFFFFFFFFFF;

        //
        // Modify the previous request's command ORB next_ORB address,
        // to point to this ORB.  Convert our address to BigEndian first,
        // since the prev command ORB is stored in BigEndian.
        //
        // Note that the previous end-of-list orb may be the completed
        // one pointed at by NextContextToFree (rather the last one in
        // the PendingOrbList), and AppendToNextContextToFree will tell
        // whether that is really the case.
        //

        octbswap (newAddr);

        if (DeviceExtension->NextContextToFree  &&
            DeviceExtension->AppendToNextContextToFree) {

            prevCtx = DeviceExtension->NextContextToFree;

            DeviceExtension->AppendToNextContextToFree = FALSE;

        } else {

            prevCtx = (PASYNC_REQUEST_CONTEXT)
                DeviceExtension->PendingOrbList.Blink;
        }

        prevCtx->CmdOrb->NextOrbAddress = newAddr;
        prevCtx->CmdOrb->NextOrbAddress.ByteArray.Byte0 = 0; //make addr active
        prevCtx->CmdOrb->NextOrbAddress.ByteArray.Byte1 = 0;

        //
        // update the end of list
        //

        InsertTailList (&DeviceExtension->PendingOrbList, &Context->OrbList);

        KeReleaseSpinLockFromDpcLevel (&DeviceExtension->OrbListSpinLock);

        DEBUGPRINT3((
            "Sbp2Port: InsertTailList: ring bell, !empty, dep=%d, ctx=x%p\n",
            DeviceExtension->OrbListDepth,
            Context
            ));

        //
        // Ring the door bell to notify the target that our linked list
        // of ORB's has changed
        //

        Sbp2AccessRegister(
            DeviceExtension,
            &DeviceExtension->Reserved,
            DOORBELL_REG | REG_WRITE_ASYNC
            );
    }

    if (orbListDepth < DeviceExtension->MaxOrbListDepth) {

        Sbp2StartNextPacketByKey(
            DeviceExtension->DeviceObject,
            DeviceExtension->CurrentKey
            );
    }
}


NTSTATUS
Sbp2IssueInternalCommand(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN UCHAR Scsiop
    )
/*++

Routine Description:

    This routine will a SCSI inquiry command to the target, so we can retireve information about the device
    It should be called only after login and BEFORE we start issueing requests to the device
    It copies the inquiry data into the device extension, for future use

Arguments:

    DeviceExtension - extension for sbp2 driver

Return Value:

--*/

{
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    PSENSE_DATA         senseInfoBuffer;
    NTSTATUS            status = STATUS_INSUFFICIENT_RESOURCES;
    ULONG               retryCount = 0;
    PREQUEST_CONTEXT    context = NULL;
    PMDL                inquiryMdl;
    PIRP                irp;
    PIO_STACK_LOCATION  irpStack;
    PMDL                modeMdl;
    KEVENT              event;
    LARGE_INTEGER       waitValue;
    ULONG               i;

    //
    // Sense buffer is in non-paged pool.
    //

    context = (PREQUEST_CONTEXT) \
        ExInterlockedPopEntrySList(&DeviceExtension->BusRequestContextListHead,&DeviceExtension->BusRequestLock);

    if (!context) {

        DEBUGPRINT1(("Sbp2Port: IssueIntl: can't allocate request context\n"));
        return status;
    }

    context->RequestType = SYNC_1394_REQUEST;
    context->DeviceExtension = DeviceExtension;
    context->Packet = NULL;

    senseInfoBuffer = ExAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                      SENSE_BUFFER_SIZE,'2pbs');

    if (senseInfoBuffer == NULL) {

        DEBUGPRINT1(("Sbp2Port: IssueIntl: can't allocate request sense buffer\n"));
        return status;
    }

    srb = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                         sizeof(SCSI_REQUEST_BLOCK),'2pbs');

    if (srb == NULL) {

        ExFreePool(senseInfoBuffer);

        ExInterlockedPushEntrySList (&DeviceExtension->BusRequestContextListHead,
                                     &context->ListPointer,
                                     &DeviceExtension->BusRequestLock);

        DEBUGPRINT1(("Sbp2Port: IssueIntl: can't allocate request sense buffer\n"));
        return status;
    }

    irp = IoAllocateIrp((CCHAR)(DeviceExtension->DeviceObject->StackSize), FALSE);

    if (irp == NULL) {

        ExFreePool(senseInfoBuffer);
        ExFreePool(srb);

        ExInterlockedPushEntrySList (&DeviceExtension->BusRequestContextListHead,
                                     &context->ListPointer,
                                     &DeviceExtension->BusRequestLock);

        DEBUGPRINT1(("Sbp2Port: IssueIntl: can't allocate IRP\n"));
        return status;
    }

    do {

        //
        // Construct the IRP stack for the lower level driver.
        //

        irpStack = IoGetNextIrpStackLocation(irp);
        irpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SCSI_EXECUTE_IN;
        irpStack->Parameters.Scsi.Srb = srb;

        //
        // Fill in SRB fieldsthat Create1394RequestFromSrb needs.
        //

        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

        srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
        srb->Length = sizeof(SCSI_REQUEST_BLOCK);

        //
        // Set flags to disable synchronous negociation.
        //

        srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

        srb->SrbStatus = srb->ScsiStatus = 0;

        //
        // Set timeout to 12 seconds.
        //

        srb->TimeOutValue = 24;

        srb->CdbLength = 6;

        //
        // Enable auto request sense.
        //

        srb->SenseInfoBuffer = senseInfoBuffer;
        srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

        cdb = (PCDB)srb->Cdb;

        switch (Scsiop) {

        case SCSIOP_INQUIRY:

            srb->DataBuffer = &DeviceExtension->InquiryData;
            srb->DataTransferLength = INQUIRYDATABUFFERSIZE;

            //
            // Set CDB LUN.
            //

            cdb->CDB6INQUIRY.LogicalUnitNumber = (UCHAR) DeviceExtension->DeviceInfo->Lun.u.LowPart;
            cdb->CDB6INQUIRY.Reserved1 = 0;
            cdb->CDB6INQUIRY.AllocationLength = INQUIRYDATABUFFERSIZE;


            //
            // Zero reserve field and
            // Set EVPD Page Code to zero.
            // Set Control field to zero.
            // (See SCSI-II Specification.)
            //

            cdb->CDB6INQUIRY.PageCode = 0;
            cdb->CDB6INQUIRY.IReserved = 0;
            cdb->CDB6INQUIRY.Control = 0;

            if (!retryCount) {

                inquiryMdl = IoAllocateMdl(&DeviceExtension->InquiryData, INQUIRYDATABUFFERSIZE,FALSE,FALSE,NULL);

                if (!inquiryMdl) {

                    goto exitSbp2Internal;
                }

                MmBuildMdlForNonPagedPool(inquiryMdl);
            }

            irp->MdlAddress = inquiryMdl;

            break;

        case SCSIOP_MODE_SENSE:

            srb->DataBuffer = &DeviceExtension->DeviceModeHeaderAndPage;
            srb->DataTransferLength = sizeof(DeviceExtension->DeviceModeHeaderAndPage);

            //
            // Setup CDB.
            //

            cdb->MODE_SENSE.Dbd      = 1;   // disable block descriptors
            cdb->MODE_SENSE.PageCode = MODE_PAGE_RBC_DEVICE_PARAMETERS;
            cdb->MODE_SENSE.Pc       = 0;   // get current values
            cdb->MODE_SENSE.AllocationLength = sizeof(DeviceExtension->DeviceModeHeaderAndPage);

            if (!retryCount) {

                modeMdl = IoAllocateMdl(
                    &DeviceExtension->DeviceModeHeaderAndPage,
                    sizeof (DeviceExtension->DeviceModeHeaderAndPage),
                    FALSE,
                    FALSE,
                    NULL
                    );

                if (!modeMdl) {

                    goto exitSbp2Internal;
                }

                MmBuildMdlForNonPagedPool(modeMdl);
            }

            irp->MdlAddress = modeMdl;

            break;
        }

        //
        // Set CDB operation code.
        //

        cdb->CDB6GENERIC.OperationCode = Scsiop;

        srb->OriginalRequest = irp;

        KeInitializeEvent(&context->Event,
                          NotificationEvent,
                          FALSE);

        IoSetCompletionRoutine(irp,
                               Sbp2RequestCompletionRoutine,
                               context,
                               TRUE,
                               TRUE,
                               TRUE);

        DEBUGPRINT2(("Sbp2Port: IssueIntl: sending scsiop x%x, irp=x%p\n", Scsiop, irp));

        status = IoCallDriver(DeviceExtension->DeviceObject, irp);


        if(!NT_SUCCESS(irp->IoStatus.Status) && status!=STATUS_PENDING) {

            status = irp->IoStatus.Status;
            DEBUGPRINT1(("Sbp2Port: IssueIntl: scsiop=x%x irp=x%p err, sts=x%x srbSts=x%x\n",Scsiop,irp, status,srb->SrbStatus));
            break;
        }

        KeWaitForSingleObject (&context->Event, Executive, KernelMode, FALSE, NULL);

        if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

            DEBUGPRINT3(("Sbp2Port: IssueIntl: scsiop=x%x err, srbSts=%x\n",Scsiop, srb->SrbStatus));

            if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

                DEBUGPRINT1(("Sbp2Port: IssueIntl: Data underrun \n"));

                status = STATUS_SUCCESS;

            } else if ((srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
                 senseInfoBuffer->SenseKey == SCSI_SENSE_ILLEGAL_REQUEST){

                 //
                 // A sense key of illegal request was recieved.  This indicates
                 // that the logical unit number of not valid but there is a
                 // target device out there.
                 //

                 status = STATUS_INVALID_DEVICE_REQUEST;
                 retryCount++;

            } else {

                //
                // If the device timed out the request chances are the
                // irp will have been completed by CleanupOrbList with
                // and SRB...FLUSHED error, and we don't want to
                // entertain any devices which are timing out requests
                //

                if ((SRB_STATUS(srb->SrbStatus) ==
                        SRB_STATUS_REQUEST_FLUSHED) &&

                    (retryCount > 0)) {

                    status = STATUS_DEVICE_BUSY;
                    break;
                }

                retryCount++;

                DEBUGPRINT1((
                    "Sbp2Port: IssueIntl: ext=x%p, cdb=x%x, retry %d\n",
                    DeviceExtension,
                    Scsiop,
                    retryCount
                    ));

                status = STATUS_UNSUCCESSFUL;
            }

            //
            // If unsuccessful & a reset is in progress & retries not max'd
            // then give things some time to settle before retry. Check at
            // one second intervals for a few seconds to give soft & hard
            // resets time to complete  :
            //
            //     SBP2_RESET_TIMEOUT + SBP2_HARD_RESET_TIMEOUT + etc
            //

            if ((status != STATUS_SUCCESS)  &&

                (DeviceExtension->DeviceFlags &
                    DEVICE_FLAG_RESET_IN_PROGRESS) &&

                (retryCount < 3)) {

                DEBUGPRINT1((
                    "Sbp2Port: IssueIntl: ext=x%p, reset in progress, " \
                        "so wait...\n",
                    DeviceExtension,
                    Scsiop,
                    retryCount
                    ));

                for (i = 0; i < 6; i++) {

                    ASSERT(InterlockedIncrement(&DeviceExtension->ulInternalEventCount) == 1);

                    KeInitializeEvent (&event, NotificationEvent, FALSE);

                    waitValue.QuadPart = -1 * 1000 * 1000 * 10;

                    KeWaitForSingleObject(
                        &event,
                        Executive,
                        KernelMode,
                        FALSE,
                        &waitValue
                        );

                    ASSERT(InterlockedDecrement(&DeviceExtension->ulInternalEventCount) == 0);

                    if (!(DeviceExtension->DeviceFlags &
                            DEVICE_FLAG_RESET_IN_PROGRESS)) {

                        break;
                    }
                }
            }

        } else {

            status = STATUS_SUCCESS;
        }

    } while ((retryCount < 3)  &&  (status != STATUS_SUCCESS));

exitSbp2Internal:

    //
    // Free request sense buffer.
    //

    ExFreePool(senseInfoBuffer);
    ExFreePool(srb);

    IoFreeMdl(irp->MdlAddress);
    IoFreeIrp(irp);

    ExInterlockedPushEntrySList (&DeviceExtension->BusRequestContextListHead,
                                 &context->ListPointer,
                                 &DeviceExtension->BusRequestLock);

    return status;
}


NTSTATUS
Sbp2SendPassThrough (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    )
/*++

Routine Description:

    This function sends a user specified SCSI request block.
    It creates an srb which is processed normally by the port driver.
    This call is synchornous.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    RequestIrp - Supplies a pointe to the Irp which made the original request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/
{
    PIRP                    irp;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_PASS_THROUGH      srbControl;
    SCSI_REQUEST_BLOCK      srb;
    KEVENT                  event;
    LARGE_INTEGER           startingOffset;
    IO_STATUS_BLOCK         ioStatusBlock;
    ULONG                   outputLength;
    ULONG                   length;
    ULONG_PTR               bufferOffset;
    PVOID                   buffer;
    PVOID                   endByte;
    PVOID                   senseBuffer;
    UCHAR                   majorCode;
    NTSTATUS                status;

    PAGED_CODE();
    startingOffset.QuadPart = (LONGLONG) 1;

    //
    // Get a pointer to the control block.
    //

    irpStack = IoGetCurrentIrpStackLocation(RequestIrp);
    srbControl = RequestIrp->AssociatedIrp.SystemBuffer;

    //
    // Validate the user buffer.
    //

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SCSI_PASS_THROUGH)){

        DEBUGPRINT1(("Sbp2Passthrough: Input buffer too small \n"));
        return(STATUS_INVALID_PARAMETER);
    }

    if (srbControl->Length != sizeof(SCSI_PASS_THROUGH) &&
        srbControl->Length != sizeof(SCSI_PASS_THROUGH_DIRECT)) {

        DEBUGPRINT1(("Sbp2Passthrough: Revision mismatch, control buffer wrong size\n"));
        return(STATUS_REVISION_MISMATCH);
    }

    outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Validate the rest of the buffer parameters.
    //

    if (srbControl->CdbLength > 16) {

        DEBUGPRINT1(("Sbp2Passthrough: CdbLength >16, invalid\n"));
        return(STATUS_INVALID_PARAMETER);
    }

    if (srbControl->SenseInfoLength != 0 &&
        (srbControl->Length > srbControl->SenseInfoOffset) ||
        ((srbControl->SenseInfoOffset + srbControl->SenseInfoLength) >
         srbControl->DataBufferOffset && (srbControl->DataTransferLength != 0)) ) {

        DEBUGPRINT1(("Sbp2Passthrough: Sense buffer length and offset is wrong\n"));
        return(STATUS_INVALID_PARAMETER);
    }

    majorCode = !srbControl->DataIn ? IRP_MJ_WRITE : IRP_MJ_READ;

    if (srbControl->DataTransferLength == 0) {

        length = 0;
        buffer = NULL;
        bufferOffset = 0;
        majorCode = IRP_MJ_FLUSH_BUFFERS;
        DEBUGPRINT1(("Sbp2Passthrough: No data transfer since data length is zero\n"));

    } else if (srbControl->DataBufferOffset > outputLength &&
        srbControl->DataBufferOffset > irpStack->Parameters.DeviceIoControl.InputBufferLength) {

        //
        // The data buffer offset is greater than system buffer.  Assume this
        // is a user mode address.
        //

        if (srbControl->SenseInfoOffset + srbControl->SenseInfoLength  > outputLength
            && srbControl->SenseInfoLength) {

            DEBUGPRINT1(("Sbp2Passthrough: senseinfo offset/length too large"));
            return(STATUS_INVALID_PARAMETER);
        }

        //
        // Make sure the buffer is properly aligned.
        //

        if (srbControl->DataBufferOffset & SBP2_ALIGNMENT_MASK) {

            DEBUGPRINT1(("Sbp2Passthrough: Buffer not aligned on a quad boundary"));
            return(STATUS_INVALID_PARAMETER);
        }

        length = srbControl->DataTransferLength;
        buffer = (PCHAR) srbControl->DataBufferOffset;
        bufferOffset = 0;

        //
        // make sure the user buffer is valid
        //
        if (RequestIrp->RequestorMode != KernelMode) {
            if (length) {
                endByte =  (PVOID)((PCHAR)buffer + length - 1);
                if (buffer >= endByte) {

                    DEBUGPRINT1(("Sbp2Passthrough: Buffer larger than what claimed in length\n"));
                    return STATUS_INVALID_USER_BUFFER;
                }
            }
        }

    } else {

        if (srbControl->DataIn != SCSI_IOCTL_DATA_IN) {

            if ((srbControl->SenseInfoOffset + srbControl->SenseInfoLength > outputLength
                && srbControl->SenseInfoLength != 0) ||
                srbControl->DataBufferOffset + srbControl->DataTransferLength >
                irpStack->Parameters.DeviceIoControl.InputBufferLength ||
                srbControl->Length > srbControl->DataBufferOffset) {

                DEBUGPRINT1(("Sbp2Passthrough: Sense buffer length and offset is wrong\n"));
                return STATUS_INVALID_PARAMETER;
            }
        }

        if (srbControl->DataIn) {

            if (srbControl->DataBufferOffset + srbControl->DataTransferLength > outputLength ||
                srbControl->Length > srbControl->DataBufferOffset) {

                DEBUGPRINT1(("Sbp2Passthrough: Data length and offset is too big\n"));
                return STATUS_INVALID_PARAMETER;
            }
        }

#ifdef _WIN64
        //
        // This code path should be examined more closely.
        //

        ASSERT( srbControl->DataBufferOffset + srbControl->DataTransferLength <=
                (ULONG)0xFFFFFFFF );
#endif

        length = (ULONG)(srbControl->DataBufferOffset +
                         srbControl->DataTransferLength);
        buffer = (PUCHAR) srbControl;
        bufferOffset = srbControl->DataBufferOffset;
    }

    //
    // Validate that the request isn't too large
    //

    if (srbControl->DataTransferLength &&
        ((ADDRESS_AND_SIZE_TO_SPAN_PAGES(
              ((PUCHAR)buffer+bufferOffset),
              srbControl->DataTransferLength
              ) > DeviceExtension->DeviceInfo->MaxClassTransferSize/PAGE_SIZE) ||
        (DeviceExtension->DeviceInfo->MaxClassTransferSize < srbControl->DataTransferLength))) {

        DEBUGPRINT1(("Sbp2Passthrough: Data length larger than max transfer size\n"));
        return(STATUS_INVALID_PARAMETER);
    }


    if (srbControl->TimeOutValue == 0 ||
        srbControl->TimeOutValue > 30 * 60 * 60) {

        DEBUGPRINT1(("Sbp2Passthrough: Timeout either zero or too big\n"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check for illegal command codes.
    //

    if (srbControl->Cdb[0] == SCSIOP_COPY ||
        srbControl->Cdb[0] == SCSIOP_COMPARE ||
        srbControl->Cdb[0] == SCSIOP_COPY_COMPARE) {

        DEBUGPRINT1(("Sbp2Passthrough: Invalid Cdb SCSIOP, copy, copy/compare not supported\n"));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // If this request came through a normal device control rather than from
    // class driver then the device must exist and be unclaimed. Class drivers
    // will set the minor function code for the device control.  It is always
    // zero for a user request.
    //

    if((irpStack->MinorFunction == 0) && (DeviceExtension->DeviceFlags & DEVICE_FLAG_CLAIMED)) {

        DEBUGPRINT1(("Sbp2Passthrough: This came down from class driver, should not happen, irp %p\n",RequestIrp));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Allocate an aligned request sense buffer.
    //

    if (srbControl->SenseInfoLength != 0) {

        senseBuffer = ExAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                      srbControl->SenseInfoLength,'2pbs');

        if (senseBuffer == NULL) {

            return(STATUS_INSUFFICIENT_RESOURCES);
        }

    } else {

        senseBuffer = NULL;
    }

    //
    // Initialize the notification event.
    //

    KeInitializeEvent (&event, NotificationEvent, FALSE);

    //
    // Build IRP for this request.
    // Note we do this synchronously for two reasons.  If it was done
    // asynchonously then the completion code would have to make a special
    // check to deallocate the buffer.  Second if a completion routine were
    // used then an addation stack locate would be needed.
    //

    try {

        irp = IoBuildSynchronousFsdRequest(
                    majorCode,
                    DeviceExtension->DeviceObject,
                    buffer,
                    length,
                    &startingOffset,
                    &event,
                    &ioStatusBlock);

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred while attempting to probe the
        // caller's parameters.  Dereference the file object and return
        // an appropriate error status code.
        //

        if (senseBuffer != NULL) {

            ExFreePool(senseBuffer);
        }

        return GetExceptionCode();
    }

    if (irp == NULL) {

        if (senseBuffer != NULL) {
            ExFreePool(senseBuffer);
        }

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set major code.
    //

    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->MinorFunction = 1;

    //
    // Fill in SRB fields.
    //

    irpStack->Parameters.Others.Argument1 = &srb;

    //
    // Zero out the srb.
    //

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Fill in the srb.
    //

    srb.Length = SCSI_REQUEST_BLOCK_SIZE;
    srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb.SrbStatus = SRB_STATUS_PENDING;
    srb.PathId = 0;
    srb.TargetId = 0;
    srb.Lun = 0;
    srb.CdbLength = srbControl->CdbLength;
    srb.SenseInfoBufferLength = srbControl->SenseInfoLength;

    switch (srbControl->DataIn) {

    case SCSI_IOCTL_DATA_OUT:

       if (srbControl->DataTransferLength) {

           srb.SrbFlags = SRB_FLAGS_DATA_OUT;
       }

       break;

    case SCSI_IOCTL_DATA_IN:

       if (srbControl->DataTransferLength) {

           srb.SrbFlags = SRB_FLAGS_DATA_IN;
       }

       break;

    default:

        srb.SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT;
        break;
    }

    if (srbControl->DataTransferLength == 0) {

        srb.SrbFlags = 0;

    } else {

        //
        // Flush the data buffer for output. This will insure that the data is
        // written back to memory.
        //

        KeFlushIoBuffers(irp->MdlAddress, FALSE, TRUE);

    }

    srb.DataTransferLength = srbControl->DataTransferLength;
    srb.TimeOutValue = srbControl->TimeOutValue;
    srb.DataBuffer = (PCHAR) buffer + bufferOffset;
    srb.SenseInfoBuffer = senseBuffer;

    // srb.OriginalRequest = irp;

    srb.OriginalRequest = irp;

    RtlCopyMemory(srb.Cdb, srbControl->Cdb, srbControl->CdbLength);

    //
    // Disable autosense if there's no sense buffer to put the data in.
    //

    if (senseBuffer == NULL) {

        SET_FLAG(srb.SrbFlags, SRB_FLAGS_DISABLE_AUTOSENSE);
    }

    //
    // Call port driver to handle this request.
    //

    status = IoCallDriver(DeviceExtension->DeviceObject, irp);

    //
    // Wait for request to complete.
    //

    if (status == STATUS_PENDING) {

          KeWaitForSingleObject(&event,
                                Executive,
                                KernelMode,
                                FALSE,
                                NULL);
    }

    //
    // Copy the returned values from the srb to the control structure.
    //

    srbControl->ScsiStatus = srb.ScsiStatus;

    if (srb.SrbStatus  & SRB_STATUS_AUTOSENSE_VALID) {

        //
        // Set the status to success so that the data is returned.
        //

        ioStatusBlock.Status = STATUS_SUCCESS;
        srbControl->SenseInfoLength = srb.SenseInfoBufferLength;

        //
        // Copy the sense data to the system buffer.
        //

        RtlCopyMemory((PUCHAR) srbControl + srbControl->SenseInfoOffset,
                      senseBuffer,
                      srb.SenseInfoBufferLength);

    } else {

        srbControl->SenseInfoLength = 0;
    }

    //
    // Free the sense buffer.
    //

    if (senseBuffer != NULL) {

        ExFreePool(senseBuffer);
    }

    //
    // If the srb status is buffer underrun then set the status to success.
    // This insures that the data will be returned to the caller.
    //

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        ioStatusBlock.Status = STATUS_SUCCESS;
    }

    srbControl->DataTransferLength = srb.DataTransferLength;

    //
    // Set the information length
    //

    if (!srbControl->DataIn || bufferOffset == 0) {

        RequestIrp->IoStatus.Information = srbControl->SenseInfoOffset +
            srbControl->SenseInfoLength;

    } else {

        RequestIrp->IoStatus.Information = srbControl->DataBufferOffset +
            srbControl->DataTransferLength;
    }

    RequestIrp->IoStatus.Status = ioStatusBlock.Status;

    return ioStatusBlock.Status;
}


BOOLEAN
ConvertSbp2SenseDataToScsi(
    IN PSTATUS_FIFO_BLOCK StatusBlock,
    OUT PUCHAR SenseBuffer,
    ULONG SenseBufferLength
    )
/*++

Routine Description:

    This routine will convert the sense information returned in an SBP-2 status block, to SCSI-2/3 sense data
    and put them the translated on the SenseBuffer passed as an argument

Arguments:

    StatusBlock - Sbp2 staus for completed ORB
    SenseBuffer - Buffer to fill in with translated Sense Data. This buffer comes with the original SRB

Return Value:

--*/
{
    BOOLEAN validSense = FALSE;

    if (!SenseBuffer || (SenseBufferLength < 0xE) ) {

        return FALSE;
    }

    RtlZeroMemory(SenseBuffer,SenseBufferLength);

    //
    // determine sense error code
    //

    if ((StatusBlock->Contents[0].ByteArray.Byte0 & STATUS_BLOCK_SFMT_MASK) == SENSE_DATA_STATUS_BLOCK ) {

        SenseBuffer[0] = 0x70;
        validSense = TRUE;

    } else if ((StatusBlock->Contents[0].ByteArray.Byte0 & STATUS_BLOCK_SFMT_MASK) == SENSE_DATA_DEFF_STATUS_BLOCK){

        SenseBuffer[0] = 0x71;
        validSense = TRUE;
    }

    if (validSense) {

        SenseBuffer[0] |= 0x80 & StatusBlock->Contents[0].ByteArray.Byte1; // valid bit

        SenseBuffer[1] = 0; // segment number not supported in sbp2

        SenseBuffer[2] = (0x70 & StatusBlock->Contents[0].ByteArray.Byte1) << 1; // filemark bit, eom bit, ILI bit
        SenseBuffer[2] |= 0x0f & StatusBlock->Contents[0].ByteArray.Byte1; // sense key

        SenseBuffer[3] = StatusBlock->Contents[0].ByteArray.Byte4; // Information field
        SenseBuffer[4] = StatusBlock->Contents[0].ByteArray.Byte5;
        SenseBuffer[5] = StatusBlock->Contents[0].ByteArray.Byte6;
        SenseBuffer[6] = StatusBlock->Contents[0].ByteArray.Byte7;

        SenseBuffer[7] = 0xb; // additional sense length

        SenseBuffer[8] = StatusBlock->Contents[1].ByteArray.Byte0; // Command Block dependent bytes
        SenseBuffer[9] = StatusBlock->Contents[1].ByteArray.Byte1;
        SenseBuffer[10] = StatusBlock->Contents[1].ByteArray.Byte2;
        SenseBuffer[11] = StatusBlock->Contents[1].ByteArray.Byte3;

        SenseBuffer[12] = StatusBlock->Contents[0].ByteArray.Byte2; // sense code
        SenseBuffer[13] = StatusBlock->Contents[0].ByteArray.Byte3; // additional sense code qualifier

        if (SenseBufferLength >= SENSE_BUFFER_SIZE ) {

            // FRU byte

            SenseBuffer[14] |= StatusBlock->Contents[1].ByteArray.Byte4;

            // Sense key dependent bytes

            SenseBuffer[15] = StatusBlock->Contents[1].ByteArray.Byte5;
            SenseBuffer[16] = StatusBlock->Contents[1].ByteArray.Byte6;
            SenseBuffer[17] = StatusBlock->Contents[1].ByteArray.Byte7;
        }
    }

    return validSense;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\sbp2port\sbp2port.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    sbp2port.h

Abstract:

    Definitions for SBP2 protocol

Author:

    georgioc 22-Jan-97

Environment:

    Kernel mode only

Revision History:


--*/


#ifndef _SBP2PORT_
#define _SBP2PORT_

#include "sbp2.h"
#include "ntddsbp2.h"
#include <ntddscsi.h>

//
// define this if we a re running on a TI controller
//

#if DBG

extern ULONG Sbp2DebugLevel;

#define DEBUGPRINT1(_x_)        {if (Sbp2DebugLevel >= 1) \
                                KdPrint (_x_);}

#define DEBUGPRINT2(_x_)        {if (Sbp2DebugLevel >= 2) \
                                KdPrint (_x_);}

#define DEBUGPRINT3(_x_)        {if (Sbp2DebugLevel >= 3) \
                                KdPrint (_x_);}
#define DEBUGPRINT4(_x_)        {if (Sbp2DebugLevel >= 4) \
                                KdPrint (_x_);}

#else

#define DEBUGPRINT1(_x_)
#define DEBUGPRINT2(_x_)
#define DEBUGPRINT3(_x_)
#define DEBUGPRINT4(_x_)

#endif

//
// Remove lock definitions
//

#define REMLOCK_TIMEOUT         2       // minutes
#define REMLOCK_HIGH_WATERMARK  0x2000  // # irps, devctl.exe test sends *alot*

//
// The following FILE_CHARACTERISTICS_XXX constants are copied from
// NTDDK.H and dup'd here, since we include WDM.H and that doesn't
// support these constants.
//
// The FILE_EXPECT flags will only exist for WinXP. After that they will be
// ignored and an IRP will be sent in their place.
//

#define FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL     0x00000200
#define FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL    0x00000300
#define FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK        0x00000300

//
// pool of preallocate async contexts. Has to be less than
// ((PAGE_SIZE / (SBP2_MIN_ORB_SIZE+sizeof(PASYNC_REQUEST_CONTEXT)))
// The numbers below are chosen so they can work as boundary check masks that are ANDed
// with the current pointer into the continious pool
//

#define MAX_ORB_LIST_DEPTH 8
#define MIN_ORB_LIST_DEPTH 5



typedef struct _IRBIRP {

    SINGLE_LIST_ENTRY ListPointer;
    PIRB    Irb;
    PIRP    Irp;
    OCTLET  Octlet;

} IRBIRP, *PIRBIRP;


typedef struct _ADDRESS_CONTEXT {

    PDEVICE_OBJECT  DeviceObject;
    OCTLET          Address;
    OCTLET          ReservedAddr;
    HANDLE          AddressHandle;
    PMDL            RequestMdl;
    ULONG           TransactionType;
    PVOID           Reserved;

} ADDRESS_CONTEXT, *PADDRESS_CONTEXT;


typedef struct _PAGE_TABLE_CONTEXT {

    ULONG            MaxPages;
    ULONG            NumberOfPages;
    POCTLET          PageTable;
    ADDRESS_CONTEXT  AddressContext;

} PAGE_TABLE_CONTEXT, *PPAGE_TABLE_CONTEXT;


#define SBP2_ASYNC_CONTEXT_TAG 0xADEAFFAB

typedef struct _ASYNC_REQUEST_CONTEXT {

    LIST_ENTRY          OrbList;
    SINGLE_LIST_ENTRY   LookasideList;
    ULONG               Tag;

    PDEVICE_OBJECT      DeviceObject;
    PSCSI_REQUEST_BLOCK Srb;
    ULONG               Flags;
    PORB_NORMAL_CMD     CmdOrb;

    OCTLET              CmdOrbAddress;
    PMDL                    PartialMdl;
    PMDL                RequestMdl;

    PAGE_TABLE_CONTEXT  PageTableContext;
    HANDLE              DataMappingHandle;

    KDPC                TimerDpc;
    KTIMER              Timer;

    PIRBIRP             Packet;
    PVOID               OriginalSrb;

    ULONG               OrbListDepth;

} ASYNC_REQUEST_CONTEXT, *PASYNC_REQUEST_CONTEXT;


#define ASYNC_CONTEXT_FLAG_TIMER_STARTED    0x00000001
#define ASYNC_CONTEXT_FLAG_COMPLETED        0x00000002
#define ASYNC_CONTEXT_FLAG_PAGE_ALLOC       0x00000004
#define ASYNC_CONTEXT_FLAG_DATA_ALLOC       0x00000008
#define ASYNC_CONTEXT_FLAG_DATA_ALLOC_FAILED    0x00000010


#define SBP2_PDO                ((ULONG) 'ODPs')
#define SBP2_PDO_DELETED        ((ULONG) 'ODPx')
#define SBP2_FDO                ((ULONG) 'ODFs')
#define SBP2_MAX_LUNS_PER_NODE  10
#define MAX_GENERIC_NAME_LENGTH 16


typedef struct _DEVICE_INFORMATION {

    PDEVICE_OBJECT      DeviceObject;
    QUADLET             Lun;
    QUADLET             CmdSetId;
    QUADLET             CmdSetSpecId;

    QUADLET             UnitCharacteristics;
    PCONFIG_ROM         ConfigRom;
    PTEXTUAL_LEAF       ModelLeaf;
    PTEXTUAL_LEAF       VendorLeaf;

    OCTLET              ManagementAgentBaseReg;
    OCTLET              CsrRegisterBase;

    ULONG               MaxClassTransferSize;

    UCHAR               GenericName[MAX_GENERIC_NAME_LENGTH];

} DEVICE_INFORMATION, *PDEVICE_INFORMATION;


typedef struct _FDO_DEVICE_EXTENSION {

    PDEVICE_OBJECT      DeviceObject;
    PDEVICE_OBJECT      LowerDeviceObject;
    ULONG               Type;
    ULONG               DeviceFlags;

    PTEXTUAL_LEAF       VendorLeaf;
    ULONG               MaxClassTransferSize;
    HANDLE              Sbp2ObjectDirectory;
    PDEVICE_OBJECT      Pdo;
    PIRP                SystemPowerIrp;
    DEVICE_POWER_STATE  DevicePowerState;
    SYSTEM_POWER_STATE  SystemPowerState;
    ULONG               NumPDOsStarted;
    KMUTEX              EnableBusResetNotificationMutex;
    ULONG               DeviceListSize;
    KSPIN_LOCK          DeviceListLock;
    DEVICE_INFORMATION  DeviceList[SBP2_MAX_LUNS_PER_NODE];
    CONFIG_ROM          ConfigRom;

    FAST_MUTEX          ResetMutex;
    IO_REMOVE_LOCK      RemoveLock;

#if DBG
    ULONG               ulWorkItemCount;
    ULONG               ulBusResetMutexCount;
#endif

} FDO_DEVICE_EXTENSION, *PFDO_DEVICE_EXTENSION;


typedef struct _ARCP_ORB {

    PASYNC_REQUEST_CONTEXT  AsyncReqCtx;
    ORB_NORMAL_CMD          Orb;

} ARCP_ORB, *PARCP_ORB;


typedef struct _COMMON_BUFFER_DATA {

    ORB_TASK_MNG        TaskOrb;
    ORB_MNG             ManagementOrb;
    LOGIN_RESPONSE      LoginResponse;
    QUERY_LOGIN_RESPONSE QueryLoginResponse;

#if PASSWORD_SUPPORT
    ORB_SET_PASSWORD    PasswordOrb;
#endif

    ARCP_ORB            CmdOrbs[MAX_ORB_LIST_DEPTH];

} COMMON_BUFFER_DATA, *PCOMMON_BUFFER_DATA;


typedef struct _DEVICE_EXTENSION {

    PDEVICE_OBJECT      DeviceObject;
    PDEVICE_OBJECT      LowerDeviceObject;
    ULONG               Type;
    ULONG               DeviceFlags;

    PDEVICE_OBJECT      BusFdo;
    PDEVICE_INFORMATION DeviceInfo;
    ULONG               MaxOrbListDepth;
    KSPIN_LOCK          OrbListSpinLock;

    LIST_ENTRY          PendingOrbList;
    ULONG               OrbListDepth;
    ULONG               CurrentKey;

    PASYNC_REQUEST_CONTEXT  NextContextToFree;
    BOOLEAN                 AppendToNextContextToFree;
    DEVICE_POWER_STATE      DevicePowerState;
    SYSTEM_POWER_STATE      SystemPowerState;

    PIRP                PowerDeferredIrp;
    PIRP                DeferredPowerRequest;
    ULONG               PagingPathCount;
    ULONG               HibernateCount;

    ULONG               CrashDumpCount;
    ULONG               HandleCount;
    PULONG              IdleCounter;
    ULONG               Reserved;

    NTSTATUS            LastTransactionStatus;
    LARGE_INTEGER       DueTime;
    PMDL                ReservedMdl;  // quadlet only requests

    //
    // inquiry Data
    //

    INQUIRYDATA InquiryData;

    //
    // RBC Device Parameters page
    //

    MODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE DeviceModeHeaderAndPage;

    //
    // 1394 addresses to node registers
    //

    NODE_ADDRESS InitiatorAddressId;
    ULONG   CurrentGeneration;

    //
    // node and controller capabilities
    //

    ULONG   MaxControllerPhySpeed;
    USHORT  OrbReadPayloadMask;
    USHORT  OrbWritePayloadMask;

    GET_LOCAL_HOST_INFO2 HostControllerInformation;
    GET_LOCAL_HOST_INFO4 HostRoutineAPI;

    //
    // Keep a dummy, task and management ORBs around
    //

    ORB_NORMAL_CMD          Dummy;
    ADDRESS_CONTEXT         DummyContext;

    //
    //
    //

    PCOMMON_BUFFER_DATA     CommonBuffer;
    ADDRESS_CONTEXT         CommonBufferContext;


    PORB_TASK_MNG           TaskOrb;
    ADDRESS_CONTEXT         TaskOrbContext;

    PORB_MNG                ManagementOrb;
    ADDRESS_CONTEXT         ManagementOrbContext;

    PLOGIN_RESPONSE         LoginResponse;
    ADDRESS_CONTEXT         LoginRespContext;

    PQUERY_LOGIN_RESPONSE   QueryLoginResponse;
    ADDRESS_CONTEXT         QueryLoginRespContext;

#if PASSWORD_SUPPORT

    PORB_SET_PASSWORD       PasswordOrb;
    ADDRESS_CONTEXT         PasswordOrbContext;

#endif

    ADDRESS_CONTEXT         OrbPoolContext;

    //
    //
    //

    STATUS_FIFO_BLOCK   ManagementOrbStatusBlock;
    ADDRESS_CONTEXT     ManagementOrbStatusContext;

    STATUS_FIFO_BLOCK   TaskOrbStatusBlock;
    ADDRESS_CONTEXT     TaskOrbStatusContext;

    ADDRESS_CONTEXT     GlobalStatusContext;

#if PASSWORD_SUPPORT

    STATUS_FIFO_BLOCK   PasswordOrbStatusBlock;
    ADDRESS_CONTEXT     PasswordOrbStatusContext;

#endif


    //
    // single list containing status fifos
    //

    SLIST_HEADER StatusFifoListHead;
    KSPIN_LOCK StatusFifoLock;

    //
    // pool with the actuall fifo buffer and address_fifo structs
    //

    PVOID StatusFifoBase;

    SLIST_HEADER FreeContextListHead;

    //
    // look aside for request contexts, and other fixed size requests
    //

    SLIST_HEADER BusRequestContextListHead;
    SLIST_HEADER BusRequestIrpIrbListHead;
    KSPIN_LOCK  BusRequestLock;

    //
    // this spin locks are never used on advanced x86s or alphas ( other than 486' than cant do 64 atomic exchange)
    //

    KSPIN_LOCK FreeContextLock;

    //
    // The driver keeps a pool of request contexts, and CMD ORBs in its deviceExtension
    // We use to lookaside list for the bus driver Irps, Irp request contexts
    // and the ORB contexts that have pointers to the SRB, etc
    //

    PASYNC_REQUEST_CONTEXT AsyncContextBase;

    //
    // the base va for the pool of orbs is int he reserved field of the address_Context struct
    //

    KSPIN_LOCK  ExtensionDataSpinLock;

    //
    // used to track time outs in resets, reconnects, etc...
    //

    KDPC DeviceManagementTimeoutDpc;
    KTIMER DeviceManagementTimer;

    UNICODE_STRING UniSymLinkName;

    //
    // Tracks the number of outstanding/deferred calls to
    // Sbp2StartNextPacketByKey
    //

    LONG StartNextPacketCount;

    IO_REMOVE_LOCK  RemoveLock;

#if DBG
    ULONG           ulPendingEvents;
    ULONG           ulInternalEventCount;
#endif

#if PASSWORD_SUPPORT

    ULONG Exclusive;

#endif

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef struct _REQUEST_CONTEXT {

    SINGLE_LIST_ENTRY   ListPointer;
    PDEVICE_EXTENSION   DeviceExtension;
    KEVENT              Event;
    ULONG               RequestType;
    PIRBIRP             Packet;
    ULONG               Complete;

} REQUEST_CONTEXT, *PREQUEST_CONTEXT;

//
// Useful macros
//

#define octbswap(octlet)                {octlet.u.HighQuad.QuadPart = bswap(octlet.u.HighQuad.QuadPart); \
                                         octlet.u.LowQuad.QuadPart =  bswap(octlet.u.LowQuad.QuadPart); }

#define min(a,b)                        (((a) < (b)) ? (a) : (b))
#define max(a,b)                        (((a) > (b)) ? (a) : (b))

#define RETRIEVE_CONTEXT(pointer,fieldname) \
            CONTAINING_RECORD(pointer,ASYNC_REQUEST_CONTEXT,fieldname)




#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))

//
// One status fifo element for every possible outstanding orb, and a few
// more for unsolicited status
//

#define NUM_PREALLOCATED_STATUS_FIFO_ELEMENTS (2*MAX_ORB_LIST_DEPTH)


#define MIN_PAGE_TABLE_ALLOC_SIZE   64


#define SBP2_ENERGY_IDLE_TIMEOUT    60
#define SBP2_PERF_IDLE_TIMEOUT      60


//
// symbolic link stuff
//

#define SBP2_BASE_DEVICE_NAME                        L"\\Device\\Sbp2port"
#define SBP2_BASE_SYMBOLIC_LINK_NAME                 L"\\DosDevices\\Sbp2"
#define SBP2_MAX_SUFFIX_SIZE                         5*sizeof(WCHAR)
#define BASE_SBP2_PNP_ID_DEVICE_NAME                 L"SBP2\\"
#define SBP2_MAX_TEXT_LEAF_LENGTH                    0x100

//
// Device state flags
//

#define DEVICE_FLAG_STOPPED                 0x00000001
#define DEVICE_FLAG_RESET_IN_PROGRESS       0x00000002
#define DEVICE_FLAG_REMOVED                 0x00000004
#define DEVICE_FLAG_LOGIN_IN_PROGRESS       0x00000008
#define DEVICE_FLAG_RECONNECT               0x00000010
#define DEVICE_FLAG_CLAIMED                 0x00000020
#define DEVICE_FLAG_INITIALIZING            0x00000040
#define DEVICE_FLAG_QUEUE_LOCKED            0x00000080
#define DEVICE_FLAG_SPC_CMD_SET             0x00000100
#define DEVICE_FLAG_INITIALIZED             0x00000200
#define DEVICE_FLAG_REMOVE_PENDING          0x00000400
#define DEVICE_FLAG_DEVICE_FAILED           0x00000800
#define DEVICE_FLAG_UNSTARTED_AND_REMOVED   0x00001000
#define DEVICE_FLAG_ABSENT_ON_POWER_UP      0x00002000
#define DEVICE_FLAG_SURPRISE_REMOVED        0x00004000
#define DEVICE_FLAG_PNP_STOPPED             0x00008000
#define DEVICE_FLAG_REPORTED_FAILED         0x00010000


//
// timeout values
//

#define SBP2_LOGIN_TIMEOUT 20 // secs

#define SBP2_RELOGIN_DELAY        (ULONG)(-1*10*1000*1000) // 1s, 100 ns units
#define SBP2_RECONNECT_TIMEOUT    (ULONG)(-2*10*1000*1000) // 2s, 100 ns units
#define SBP2_HARD_RESET_TIMEOUT   (ULONG)(-2*10*1000*1000) // 2s, 100 ns units
#define SBP2_RESET_TIMEOUT        (ULONG)(-2*10*1000*1000) // 2s, 100 ns units
#define SBP2_MAX_REQUEST_DELAY    (ULONG)(-7*10*1000*1000) // 7s, 100 ns units

#if PASSWORD_SUPPORT
#define SBP2_SET_PASSWORD_TIMEOUT (ULONG)(-4*10*1000*1000) // 4s, 100 ns units
#endif

//
// Our pre-allocated page tables must fit in one page of memory (each entry
// is an OCTLET in size).  So, the max xfer size equals the number of table
// entries (minus one, in case 1st entry is not a full page of data) times
// the page size
//

#define SBP2_NUM_PAGE_TABLE_ENTRIES (ULONG) (PAGE_SIZE / sizeof (OCTLET))
#define SBP2_MAX_TRANSFER_SIZE (ULONG) \
                                ((SBP2_NUM_PAGE_TABLE_ENTRIES - 1) * PAGE_SIZE)
#define SBP2_MAX_CDB_SIZE 12

#define SBP2_LOGIN_RETRIES          2
#define SBP2_SYNCHRONOUS_RETRIES    3
#define SBP2_ASYNC_RETRIES          2


//
// Minimum unit directory entries that will make this device a proper SBP-2 device
//

#define SBP2_MIN_UNIT_DIR_ENTRIES   2



//
// Masks used to decode the status block and for setting up the ORB flags
//

#define STATUS_BLOCK_UNSOLICITED_BIT_MASK   0x8000 // bit 15
#define STATUS_BLOCK_ENDOFLIST_BIT_MASK     0x4000 // bit 14
#define STATUS_BLOCK_RESP_MASK              0x3000 // protect bits 12-13 (0-15)
#define STATUS_BLOCK_SBP_STATUS_MASK        0x00FF // protect bits 0-7 (0-15)
#define STATUS_BLOCK_DEAD_BIT_MASK          0x0800 // protect bits 0-7 (0-15)


#define STATUS_BLOCK_LEN_MASK   0x0800  // protect bits 0-7 (0-15)

#define STATUS_BLOCK_SFMT_MASK  0xC0    // protect bits 15,14 of second octlet

#define SBP2_ALIGNMENT_MASK         FILE_LONG_ALIGNMENT


//
// status type , if the SFMT field is 0 or 1
//
#define SENSE_DATA_STATUS_BLOCK         0x00
#define SENSE_DATA_DEFF_STATUS_BLOCK    0x01

//
// Status types
//

#define DUMMY_ORB_STATUS_BLOCK      0x01
#define TASK_STATUS_BLOCK           0x02
#define MANAGEMENT_STATUS_BLOCK     0x04
#define CMD_ORB_STATUS_BLOCK        0x08
#define UNSOLICITED_STATUS_BLOCK    0x10

#if PASSWORD_SUPPORT
#define PASSWORD_STATUS_BLOCK       0x20
#endif

#define ORB_PAGE_TABLE_BIT_MASK     0x0008
#define ORB_DIRECTION_BIT_MASK      0x0800


#define ORB_NOTIFY_BIT_MASK         0x8000
#define ORB_DUMMY_RQ_FMT_VALUE      0x6000
#define ORB_MNG_RQ_FMT_VALUE        0x0000
#define ORB_MNG_EXCLUSIVE_BIT_MASK  0x1000

//
// 1394 transaction layer allowed timeouts
//

#define BUSY_TIMEOUT_SETTING 0x0000000F


//
// Values used to indicate what data structure we are swapping (little->Big->little endian)
//

#define SWAP_LOGIN_RESPONSE_BLOCK   0
#define SWAP_LOGIN_ORB              1
#define SWAP_NORMAL_CMD_ORB         2
#define SWAP_STATUS_BLOCK           3


//
// request types for sending small read/writes to the bus driver
//

#define ASYNC_1394_REQUEST      0x01
#define SYNC_1394_REQUEST       0x02
#define ASYNC_SYNC_1394_REQUEST 0x03

//
// different values for exclusive flag
//
#if PASSWORD_SUPPORT
#define EXCLUSIVE_FLAG_CLEAR        0x00000000  // no password
#define EXCLUSIVE_FLAG_SET          0x00000001  // password is set
#define EXCLUSIVE_FLAG_ENABLE       0x00000002  // password needs to be enabled
#endif

//
// Function definitions
//

VOID
AllocateIrpAndIrb(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRBIRP *Packet
    );


NTSTATUS
AllocateAddressForStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PADDRESS_CONTEXT Context,
    IN UCHAR StatusType
    );

NTSTATUS
AllocateSingle1394Address(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG AccessType,
    IN OUT PADDRESS_CONTEXT Context
    );


NTSTATUS
CheckStatusResponseValue(
    IN PSTATUS_FIFO_BLOCK Status
    );


VOID
CleanupOrbList(
    PDEVICE_EXTENSION   DeviceExtension,
    NTSTATUS CompletionStatus
    );


BOOLEAN
ConvertSbp2SenseDataToScsi(
    IN PSTATUS_FIFO_BLOCK StatusBlock,
    OUT PVOID SenseBuffer,
    IN ULONG SenseBufferLength
    );

VOID
Create1394TransactionForSrb(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PASYNC_REQUEST_CONTEXT *Context
    );


VOID
DeAllocateIrpAndIrb(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRBIRP Packet
    );

VOID
Free1394DataMapping(
    PDEVICE_EXTENSION DeviceExtension,
    PASYNC_REQUEST_CONTEXT Context
    );

VOID
FreeAddressRange(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PADDRESS_CONTEXT Context
    );

ULONG
FreeAsyncRequestContext(
    PDEVICE_EXTENSION DeviceExtension,
    PASYNC_REQUEST_CONTEXT Context
    );

NTSTATUS
GetRegistryParameters(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN OUT PULONG DiagnosticFlags,
    IN OUT PULONG MaxTransferSize
    ) ;

NTSTATUS
GetRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    );

NTSTATUS
Sbp2_SCSI_RBC_Conversion(
    IN PASYNC_REQUEST_CONTEXT Context
    );

NTSTATUS
Sbp2AccessRegister(
    PDEVICE_EXTENSION DeviceExtension,
    PVOID Data,
    USHORT Register
    );

NTSTATUS
Sbp2BusMapTransfer(
    PDEVICE_EXTENSION DeviceExtension,
    PASYNC_REQUEST_CONTEXT CallbackContext
    );

void
Sbp2BusResetNotification(
    PFDO_DEVICE_EXTENSION   FdoExtension
    );

BOOLEAN
Sbp2CleanDeviceExtension(
    IN PDEVICE_OBJECT DeviceObject,
    BOOLEAN DeviceRemoved
);


VOID
Sbp2ConvertScsiToReducedCommandSet(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
Sbp2AllocComplete(
    IN PASYNC_REQUEST_CONTEXT CallbackContext
    );


VOID
Sbp2CreateRequestErrorLog(
    IN PDEVICE_OBJECT DeviceObject,
    IN PASYNC_REQUEST_CONTEXT Context,
    IN NTSTATUS Status
    );

VOID
Sbp2DeferPendingRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

VOID
Sbp2DeviceManagementTimeoutDpc(
    IN PKDPC Dpc,
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
Sbp2Get1394ConfigInfo(
    PFDO_DEVICE_EXTENSION DeviceExtension,
    PSBP2_REQUEST Sbp2Req
    );

RCODE
Sbp2GlobalStatusCallback(
    IN PNOTIFICATION_INFO NotificationInfo
    );

NTSTATUS
Sbp2GetControllerInfo(
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
Sbp2HandleApiRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

VOID
Sbp2HandleRemove(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
Sbp2HandleUnsolicited(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSTATUS_FIFO_BLOCK StatusFifo
    );

NTSTATUS
Sbp2IssueInternalCommand(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN UCHAR Scsiop
    );


NTSTATUS
Sbp2InitializeDeviceExtension(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
Sbp2InitializeOrb(
    IN PDEVICE_EXTENSION DeviceExtendion,
    PASYNC_REQUEST_CONTEXT CallbackContext
    );

VOID
Sbp2InsertTailList(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PASYNC_REQUEST_CONTEXT Context
    );

NTSTATUS
Sbp2Issue1394BusReset (
    IN PDEVICE_EXTENSION DeviceExtension
    );


NTSTATUS
Sbp2ManagementTransaction(
    IN PDEVICE_EXTENSION DeviceExtension,
    ULONG Type
    );

#if PASSWORD_SUPPORT

NTSTATUS
Sbp2SetPasswordTransaction(
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN ULONG                Type
    );

RCODE
Sbp2SetPasswordOrbStatusCallback(
    IN PNOTIFICATION_INFO   NotificationInfo
    );

#endif

RCODE
Sbp2ManagementOrbStatusCallback(
    IN PNOTIFICATION_INFO NotificationInfo
    );

VOID
Sbp2ParseTextLeaf(
    PFDO_DEVICE_EXTENSION DeviceExtension,
    PVOID UnitDepDir,
    PIO_ADDRESS ModelLeafLocation,
    PVOID *ModelLeaf
    );

NTSTATUS
Sbp2PreAllocateLists(
    IN PDEVICE_EXTENSION DeviceExtension
    );


NTSTATUS
Sbp2QueryProperty(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP QueryIrp
    );

VOID
Sbp2RequestTimeoutDpc(
    IN PKDPC Dpc,
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
Sbp2Reset(
    PDEVICE_OBJECT DeviceObject,
    BOOLEAN Cleanup
);

NTSTATUS
Sbp2RequestCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PREQUEST_CONTEXT Context
    );

VOID
Sbp2PdoDIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP SIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
Sbp2ScsiRequests
(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Sbp2SendPassThrough (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    );

VOID
Sbp2StartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



NTSTATUS
Sbp2SendRequest(
    PDEVICE_EXTENSION DeviceExtension,
    PIRBIRP Packet,
    ULONG TransferMode
    );

RCODE
Sbp2TaskOrbStatusCallback(
    IN PNOTIFICATION_INFO NotificationInfo
    );


NTSTATUS
Sbp2UpdateNodeInformation(
    PDEVICE_EXTENSION DeviceExtension
    );

VOID
ValidateTextLeaf(
    IN PTEXTUAL_LEAF Leaf
    );

NTSTATUS
Sbp2FdoSIrpCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Unused
    );

VOID
Sbp2FdoDIrpCompletion(
    IN PDEVICE_OBJECT           TargetDeviceObject,
    IN UCHAR                    MinorFunction,
    IN POWER_STATE              PowerState,
    IN PFDO_DEVICE_EXTENSION    FdoExtension,
    IN PIO_STATUS_BLOCK         IoStatus
    );

BOOLEAN
Sbp2EnableBusResetNotification(
    PDEVICE_EXTENSION   DeviceExtension,
    BOOLEAN             Enable
    );

VOID
Sbp2LoginCompletion(
    PNOTIFICATION_INFO  NotificationInfo,
    NTSTATUS            Status
    );

VOID
Sbp2StartNextPacketByKey(
    IN PDEVICE_OBJECT   DeviceObject,
    IN ULONG            Key
    );

VOID
Sbp2StartPacket(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PULONG           Key OPTIONAL
    );

PKDEVICE_QUEUE_ENTRY
Sbp2RemoveByKeyDeviceQueueIfBusy (
    IN PKDEVICE_QUEUE   DeviceQueue,
    IN ULONG            SortKey
    );

BOOLEAN
Sbp2InsertByKeyDeviceQueue(
    PKDEVICE_QUEUE          DeviceQueue,
    PKDEVICE_QUEUE_ENTRY    DeviceQueueEntry,
    ULONG                   SortKey
    );

NTSTATUS
Sbp2GetExclusiveValue(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    OUT PULONG          Exclusive
    );

NTSTATUS
Sbp2SetExclusiveValue(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    IN PULONG           Exclusive
    );

void
Sbp2BusResetNotificationWorker(
    PDEVICE_OBJECT      DeviceObject,
    PIO_WORKITEM        WorkItem
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\sbp2port\util.c ===
/*++


Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    util.c

Abstract:

    Utility functions for the SBP-2 port driver

    Author:

    George Chrysanthakopoulos January-1997

Environment:

    Kernel mode

Revision History :

--*/


#include "sbp2port.h"


VOID
AllocateIrpAndIrb(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRBIRP *Packet
    )
{
    PIRBIRP pkt;


    if (DeviceExtension->Type == SBP2_PDO) {

        *Packet = (PIRBIRP) ExInterlockedPopEntrySList (&DeviceExtension->BusRequestIrpIrbListHead,
                                                        &DeviceExtension->BusRequestLock);

    } else {

        *Packet = NULL;
    }

    if (*Packet == NULL) {

        //
        // run out , allocate a new one
        //

        pkt = ExAllocatePoolWithTag(NonPagedPool,sizeof(IRBIRP),'2pbs');

        if (pkt) {

            pkt->Irb = NULL;
            pkt->Irb = ExAllocatePoolWithTag(NonPagedPool,sizeof(IRB),'2pbs');

            if (!pkt->Irb) {

                ExFreePool(pkt);
                return;
            }

            pkt->Irp = NULL;
            pkt->Irp = IoAllocateIrp(DeviceExtension->LowerDeviceObject->StackSize,FALSE);

            if (!pkt->Irp) {

                ExFreePool(pkt->Irb);
                ExFreePool(pkt);
                return;
            }

            DEBUGPRINT3((
                "Sbp2Port: AllocPkt: %sdo, new irp=x%p, irb=x%p\n",
                (DeviceExtension->Type == SBP2_PDO ? "p" : "f"),
                pkt->Irp,
                pkt->Irb
                ));

        } else {

            return;
        }

        *Packet = pkt;
    }

    pkt = *Packet;
}


VOID
DeAllocateIrpAndIrb(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRBIRP Packet
    )
{
    if (DeviceExtension->Type == SBP2_PDO) {

        ExInterlockedPushEntrySList (&DeviceExtension->BusRequestIrpIrbListHead,
                                     &Packet->ListPointer,
                                     &DeviceExtension->BusRequestLock);

    } else {

        IoFreeIrp(Packet->Irp);
        ExFreePool(Packet->Irb);
        ExFreePool(Packet);
    }
}


NTSTATUS
AllocateSingle1394Address(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG AccessType,
    IN OUT PADDRESS_CONTEXT Context
    )

/*++

Routine Description:

    A wrapper to the bus driver AllocateAddressRange call, for Async Requests
    or ORB's that dont use callbacks.

Arguments:

    DeviceObject - Sbp2 device object
    Buffer - Data buffer to mapped to 1394 address space
    Length - Size of buffer in bytes
    AccessType - 1394 bus access  to allocated range
    Address - Returned Address, from 1394 address space
    AddressHanle - Handle associated with the 1394 address
    RequestMedl - Mdl associated with this range

Return Value:
    NTSTATUS

--*/

{
    ULONG               finalTransferMode;
    PIRBIRP             packet;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;


    AllocateIrpAndIrb (deviceExtension, &packet);

    if (!packet) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    packet->Irb->FunctionNumber = REQUEST_ALLOCATE_ADDRESS_RANGE;
    packet->Irb->Flags = 0;

    packet->Irb->u.AllocateAddressRange.MaxSegmentSize = 0;
    packet->Irb->u.AllocateAddressRange.nLength = Length;
    packet->Irb->u.AllocateAddressRange.fulAccessType = AccessType;
    packet->Irb->u.AllocateAddressRange.fulNotificationOptions = NOTIFY_FLAGS_NEVER;

    packet->Irb->u.AllocateAddressRange.Callback = NULL;
    packet->Irb->u.AllocateAddressRange.Context = NULL;

    packet->Irb->u.AllocateAddressRange.FifoSListHead = NULL;
    packet->Irb->u.AllocateAddressRange.FifoSpinLock = NULL;

    packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_High = 0;
    packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_Low = 0;

    packet->Irb->u.AllocateAddressRange.AddressesReturned = 0;
    packet->Irb->u.AllocateAddressRange.DeviceExtension = deviceExtension;
    packet->Irb->u.AllocateAddressRange.p1394AddressRange = (PADDRESS_RANGE) &Context->Address;

    if (Buffer) {

        packet->Irb->u.AllocateAddressRange.fulFlags = 0;

        Context->RequestMdl = IoAllocateMdl (Buffer, Length, FALSE, FALSE, NULL);

        if (!Context->RequestMdl) {

            DeAllocateIrpAndIrb (deviceExtension,packet);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        MmBuildMdlForNonPagedPool (Context->RequestMdl);

        packet->Irb->u.AllocateAddressRange.Mdl = Context->RequestMdl;

    } else {

        packet->Irb->u.AllocateAddressRange.fulFlags =
            ALLOCATE_ADDRESS_FLAGS_USE_COMMON_BUFFER;

        packet->Irb->u.AllocateAddressRange.Mdl = NULL;
    }

    status = Sbp2SendRequest (deviceExtension, packet, SYNC_1394_REQUEST);

    if (NT_SUCCESS(status)) {

        Context->AddressHandle =
            packet->Irb->u.AllocateAddressRange.hAddressRange;
        Context->Address.BusAddress.NodeId =
            deviceExtension->InitiatorAddressId;

        if (!Buffer) {

            //
            // For common buffers we get an mdl *back* from the
            // bus/port driver, & need to retrieve a corresponding VA
            //

            Context->RequestMdl = packet->Irb->u.AllocateAddressRange.Mdl;

            Context->Reserved = MmGetMdlVirtualAddress (Context->RequestMdl);
        }
    }

    DeAllocateIrpAndIrb (deviceExtension, packet);

    return status;
}


NTSTATUS
AllocateAddressForStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PADDRESS_CONTEXT Context,
    IN UCHAR StatusType
    )

/*++

Routine Description:

    A wrapper to 1394 bus IOCTL AllocateAddressRange for status blocks that
    need a Callback notification when the device access the 1394 range...

Arguments:

    DeviceObject - Device Object for the sbp2 driver
    ADDRESS_CONTEXT - Mini Context for an individual 1394 request

Return Value:
    NTSTATUS

--*/

{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    OCTLET address[2];
    PIRBIRP packet = NULL;


    AllocateIrpAndIrb (deviceExtension,&packet);

    if (!packet) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    packet->Irb->FunctionNumber = REQUEST_ALLOCATE_ADDRESS_RANGE;
    packet->Irb->Flags = 0;
    packet->Irb->u.AllocateAddressRange.nLength = sizeof(STATUS_FIFO_BLOCK);
    packet->Irb->u.AllocateAddressRange.fulAccessType = ACCESS_FLAGS_TYPE_WRITE;
    packet->Irb->u.AllocateAddressRange.fulNotificationOptions = NOTIFY_FLAGS_AFTER_WRITE;

    packet->Irb->u.AllocateAddressRange.FifoSListHead = NULL;
    packet->Irb->u.AllocateAddressRange.FifoSpinLock = NULL;
    packet->Irb->u.AllocateAddressRange.fulFlags = 0;

    packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_High = 0;
    packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_Low = 0;

    packet->Irb->u.AllocateAddressRange.AddressesReturned = 0;
    packet->Irb->u.AllocateAddressRange.MaxSegmentSize = 0;
    packet->Irb->u.AllocateAddressRange.DeviceExtension = deviceExtension;

    switch (StatusType) {
    
    case TASK_STATUS_BLOCK:

        packet->Irb->u.AllocateAddressRange.Callback = Sbp2TaskOrbStatusCallback;

        Context->RequestMdl = IoAllocateMdl(&deviceExtension->TaskOrbStatusBlock, sizeof (STATUS_FIFO_BLOCK),FALSE,FALSE,NULL);

        if (!Context->RequestMdl) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exitAllocateAddress;
        }

        break;

    case MANAGEMENT_STATUS_BLOCK:

        packet->Irb->u.AllocateAddressRange.Callback = Sbp2ManagementOrbStatusCallback;

        Context->RequestMdl = IoAllocateMdl(&deviceExtension->ManagementOrbStatusBlock, sizeof (STATUS_FIFO_BLOCK),FALSE,FALSE,NULL);

        if (!Context->RequestMdl) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exitAllocateAddress;
        }

        break;

    case CMD_ORB_STATUS_BLOCK:
    
        //
        // setup the FIFO list that will receive the status blocks
        //

        packet->Irb->u.AllocateAddressRange.Callback = Sbp2GlobalStatusCallback;

        Context->RequestMdl = packet->Irb->u.AllocateAddressRange.Mdl = NULL;

        packet->Irb->u.AllocateAddressRange.FifoSListHead = &deviceExtension->StatusFifoListHead;
        packet->Irb->u.AllocateAddressRange.FifoSpinLock = &deviceExtension->StatusFifoLock;

        break;

#if PASSWORD_SUPPORT

    case PASSWORD_STATUS_BLOCK:

        packet->Irb->u.AllocateAddressRange.Callback =
            Sbp2SetPasswordOrbStatusCallback;

        Context->RequestMdl = IoAllocateMdl(
            &deviceExtension->PasswordOrbStatusBlock,
            sizeof(STATUS_FIFO_BLOCK),
            FALSE,
            FALSE,
            NULL
            );

        if (!Context->RequestMdl) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exitAllocateAddress;
        }

        break;
#endif
    }

    if (Context->RequestMdl) {

        MmBuildMdlForNonPagedPool(Context->RequestMdl);
    }

    packet->Irb->u.AllocateAddressRange.Mdl = Context->RequestMdl;
    packet->Irb->u.AllocateAddressRange.Context = Context;

    packet->Irb->u.AllocateAddressRange.p1394AddressRange = (PADDRESS_RANGE) &address;

    status = Sbp2SendRequest (deviceExtension, packet, SYNC_1394_REQUEST);

    if (NT_SUCCESS(status)) {

        //
        // Setup the address context for the status block
        //

        Context->Address = address[0];
        Context->AddressHandle = packet->Irb->u.AllocateAddressRange.hAddressRange;
        Context->DeviceObject = DeviceObject;

        Context->Address.BusAddress.NodeId = deviceExtension->InitiatorAddressId;
    }

exitAllocateAddress:

    DeAllocateIrpAndIrb (deviceExtension, packet);

    return status;
}


VOID
CleanupOrbList(
    PDEVICE_EXTENSION   DeviceExtension,
    NTSTATUS CompletionStatus
    )
/*++

Routine Description:

    This routine will free a linked list of RequestContexts
    and will also free the 1394 addresses associated with the 
    buffers in the context. If the DEVICE_FLAG_RECONNECT i set
    instead of completing pending irps, it will requeue them...

Arguments:

    DeviceExtension - Device Extension of the sbp2 device
    CompletionSTATUS - If one of the linked requests is not completed,
                        complete it with this status
Return Value:
    None
--*/

{
    PIRP requestIrp;
    PASYNC_REQUEST_CONTEXT currentListItem;
    PASYNC_REQUEST_CONTEXT lastItem,nextItem;

    KIRQL oldIrql;

    //
    // Go through the linked list, complete its original Irp and
    // free all the associated memory and 1394 resources...
    // Since this function is called when we get a REMOVE irp,
    // all irps will be terminated with error status
    // 

    KeAcquireSpinLock(&DeviceExtension->OrbListSpinLock,&oldIrql);

    if (DeviceExtension->NextContextToFree) {

        FreeAsyncRequestContext(DeviceExtension,DeviceExtension->NextContextToFree);

        DeviceExtension->NextContextToFree = NULL;
    }

    if (IsListEmpty (&DeviceExtension->PendingOrbList)) {

        //
        // nothing to do
        //

        KeReleaseSpinLock (&DeviceExtension->OrbListSpinLock,oldIrql);
        return;

    } else {

        nextItem = RETRIEVE_CONTEXT(DeviceExtension->PendingOrbList.Flink,OrbList);

        lastItem = RETRIEVE_CONTEXT(DeviceExtension->PendingOrbList.Blink,OrbList);

        InitializeListHead(&DeviceExtension->PendingOrbList);

        KeReleaseSpinLock(&DeviceExtension->OrbListSpinLock,oldIrql);
    }


    //
    // Qe have essentially detached this pending context list from
    // the main list so we can now free it without holding the lock
    // and allowing other requests to be processed.
    //

    do {

        currentListItem = nextItem;
        nextItem = (PASYNC_REQUEST_CONTEXT) currentListItem->OrbList.Flink;
        if (!TEST_FLAG(currentListItem->Flags,ASYNC_CONTEXT_FLAG_COMPLETED)) {

            SET_FLAG(currentListItem->Flags,ASYNC_CONTEXT_FLAG_COMPLETED);

            CLEAR_FLAG(currentListItem->Flags, ASYNC_CONTEXT_FLAG_TIMER_STARTED);

            Sbp2_SCSI_RBC_Conversion (currentListItem); // unwind MODE_SENSE hacks

            KeCancelTimer(&currentListItem->Timer);

            requestIrp =(PIRP)currentListItem->Srb->OriginalRequest;
            requestIrp->IoStatus.Status = CompletionStatus;

            switch (CompletionStatus) {

            case STATUS_DEVICE_DOES_NOT_EXIST:

                currentListItem->Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
                break;

            case STATUS_REQUEST_ABORTED:

                currentListItem->Srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
                break;

            case STATUS_IO_TIMEOUT:

                currentListItem->Srb->SrbStatus = SRB_STATUS_TIMEOUT;
                break;

            default:

                currentListItem->Srb->SrbStatus = SRB_STATUS_ERROR;
                break;
            }

            if (requestIrp->Type == IO_TYPE_IRP) {

                if (TEST_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_RECONNECT)) {

                    Sbp2StartPacket(
                        DeviceExtension->DeviceObject,
                        requestIrp,
                        &currentListItem->Srb->QueueSortKey
                        );

                    //
                    // free everything related to this request
                    //
        
                    currentListItem->Srb = NULL;

                    FreeAsyncRequestContext (DeviceExtension, currentListItem);

                } else {

                    //
                    // free everything related to this request
                    //
        
                    currentListItem->Srb = NULL;

                    FreeAsyncRequestContext (DeviceExtension, currentListItem);

                    DEBUGPRINT2(("Sbp2Port: CleanupOrbList: aborted irp x%p compl\n", requestIrp));

                    IoReleaseRemoveLock (&DeviceExtension->RemoveLock, NULL);

                    IoCompleteRequest (requestIrp, IO_NO_INCREMENT);
                }
            }

        } else {

            //
            // free everything related to this request
            //

            FreeAsyncRequestContext (DeviceExtension, currentListItem);
        }

    } while (lastItem != currentListItem); // while loop

    return;
}


VOID
FreeAddressRange(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PADDRESS_CONTEXT Context
    )
/*++

Routine Description:

    1394 BUS IOCTL call for freeing an address range.

Arguments:

    DeviceExtension - Pointer to sbp2 deviceExtension.

    context - address context

Return Value:
    NTSTATUS
--*/

{
    PIRBIRP packet ;


    if (Context->AddressHandle == NULL) {

        return;
    }

    AllocateIrpAndIrb (DeviceExtension, &packet);

    if (!packet) {

        return;
    }

    //
    // FreeAddressRange is synchronous call
    //

    packet->Irb->FunctionNumber = REQUEST_FREE_ADDRESS_RANGE;
    packet->Irb->Flags = 0;

    //
    // We always free one address handle even it refers to multiple
    // 1394 addresses.  The mdl associated with the original Allocate
    // is freed by the port driver.
    //

    packet->Irb->u.FreeAddressRange.nAddressesToFree = 1;
    packet->Irb->u.FreeAddressRange.p1394AddressRange = (PADDRESS_RANGE) &Context->Address;
    packet->Irb->u.FreeAddressRange.pAddressRange = &Context->AddressHandle;

    if (Context->RequestMdl) {

        if (Context == &DeviceExtension->CommonBufferContext) {

            Context->RequestMdl = NULL; // common buffer, we didn't alloc mdl

        } else {

            packet->Irb->u.FreeAddressRange.p1394AddressRange->AR_Length =
                (USHORT) MmGetMdlByteCount(Context->RequestMdl);
        }

    } else if (Context == (PADDRESS_CONTEXT) &DeviceExtension->GlobalStatusContext) {

        packet->Irb->u.FreeAddressRange.p1394AddressRange->AR_Length = sizeof(STATUS_FIFO_BLOCK);
    }

    packet->Irb->u.FreeAddressRange.DeviceExtension = DeviceExtension;
    
    if ((KeGetCurrentIrql() >= DISPATCH_LEVEL) && !Context->Address.BusAddress.Off_High) {

        PPORT_PHYS_ADDR_ROUTINE routine = DeviceExtension->HostRoutineAPI.PhysAddrMappingRoutine;

        (*routine) (DeviceExtension->HostRoutineAPI.Context,packet->Irb);

    } else {
    
        //
        // dont care about the status of this op
        //
    
        Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);
    }

    Context->AddressHandle = NULL;

    if (Context->RequestMdl) {

        IoFreeMdl (Context->RequestMdl);
        Context->RequestMdl = NULL;
    }

    DeAllocateIrpAndIrb (DeviceExtension, packet);
}


VOID
Free1394DataMapping(
    PDEVICE_EXTENSION DeviceExtension,
    PASYNC_REQUEST_CONTEXT Context
    )
{
    PIRBIRP packet ;


    if (Context->DataMappingHandle == NULL) {

        return;
    }

    AllocateIrpAndIrb (DeviceExtension, &packet);

    if (!packet) {

        return;
    }

    //
    // Free the data buffer's 1394 address range
    //

    packet->Irb->FunctionNumber = REQUEST_FREE_ADDRESS_RANGE;
    packet->Irb->Flags = 0;
    packet->Irb->u.FreeAddressRange.nAddressesToFree = 1;
    packet->Irb->u.FreeAddressRange.p1394AddressRange = (PADDRESS_RANGE) NULL;
    packet->Irb->u.FreeAddressRange.pAddressRange = &Context->DataMappingHandle;
    packet->Irb->u.FreeAddressRange.DeviceExtension = DeviceExtension;

    if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {

        PPORT_PHYS_ADDR_ROUTINE routine = DeviceExtension->HostRoutineAPI.PhysAddrMappingRoutine;

        (*routine) (DeviceExtension->HostRoutineAPI.Context, packet->Irb);

    } else {

        //
        // dont care about the status of this op
        //
    
        Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);
    }

    if (Context->PartialMdl) {

        IoFreeMdl (Context->PartialMdl);
        Context->PartialMdl = NULL;
    }

    Context->DataMappingHandle = NULL;

    DeAllocateIrpAndIrb (DeviceExtension, packet);
}


ULONG
FreeAsyncRequestContext(
    PDEVICE_EXTENSION DeviceExtension,
    PASYNC_REQUEST_CONTEXT Context
    )
/*++

Routine Description:

    This routine will free a single RequestContext and will cleanup all
    its buffers and 1394 ranges, ONLY of the device is marked as STOPPED.
    Otherwise it will add the context to the FreeList, so it can be reused
    later one by another request. This way we are drastically speeding up
    each request.

Arguments:

    DeviceExtension - Device Extension of the sbp2 device
    Context - Context to freed or returned to FreeList

Return Value:

    None - The result of the decrement of DeviceExtension->OrbListDepth

--*/

{
    //
    // This ORB can now be freed along with its data descriptor,
    // page tables and context
    //

    if (!Context || (Context->Tag != SBP2_ASYNC_CONTEXT_TAG)) {

        DEBUGPRINT2((
            "Sbp2Port: FreeAsyncReqCtx: attempt to push freed ctx=x%p\n",
            Context
            ));

        ASSERT(FALSE);
        return 0;
    }

    ASSERT(Context->Srb == NULL);

    if (Context->DataMappingHandle) {

        Free1394DataMapping(DeviceExtension,Context);
        ASSERT(Context->DataMappingHandle==NULL);
    }

    //
    // Re-initiliaze this context so it can be reused
    // This context is still part on our FreeAsyncContextPool
    // All we have to do is initialize some flags, so next time
    // we try to retrieve it, we think its empty
    //

    Context->Flags |= ASYNC_CONTEXT_FLAG_COMPLETED;
    Context->Tag = 0;

    if (Context->OriginalSrb) {

        ExFreePool(Context->OriginalSrb);
        Context->OriginalSrb = NULL;
    }

    DEBUGPRINT3(("Sbp2Port: FreeAsyncReqCtx: push ctx=x%p on free list\n",Context));

    ExInterlockedPushEntrySList(&DeviceExtension->FreeContextListHead,
                                &Context->LookasideList,
                                &DeviceExtension->FreeContextLock);

    return InterlockedDecrement (&DeviceExtension->OrbListDepth);
}


NTSTATUS
Sbp2SendRequest(
    PDEVICE_EXTENSION   DeviceExtension,
    PIRBIRP             RequestPacket,
    ULONG               TransferMode
    )
/*++

Routine Description:

    Function used to send requests to the 1394 bus driver. It attaches
    a completion routine to each request it sends down, and it also wraps
    them in a small context, so we can track their completion

Arguments:

    DeviceExtension - Sbp2 device extension
    Irp - Irp to send to the bus driver
    Irb - Bus driver packet, in the Irp
    TransferMode - Indicates if we want ot send this request synchronously
        or asynchronously
    FinalTransferMode - Indicates whether the request was sent synchronously
        or asynchronously

Return Value:

    NTSTATUS

--*/

{
    ULONG               originalTransferMode = TransferMode;
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject = DeviceExtension->DeviceObject;
    PREQUEST_CONTEXT    requestContext = NULL;
    PIO_STACK_LOCATION  nextIrpStack;


    if (DeviceExtension->Type == SBP2_PDO) {

        //
        // if device is removed, dont send any requests down
        //
    
        if (TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_REMOVED)  &&
            (RequestPacket->Irb->FunctionNumber != REQUEST_FREE_ADDRESS_RANGE)) {

            return STATUS_UNSUCCESSFUL;
        }
    
        //
        // get a context for this request, from our pool
        //
    
        requestContext = (PREQUEST_CONTEXT) \
            ExInterlockedPopEntrySList(&DeviceExtension->BusRequestContextListHead,&DeviceExtension->BusRequestLock);

    } else {

        requestContext = ExAllocatePool (NonPagedPool,sizeof(REQUEST_CONTEXT));
    }

    if (!requestContext) {

        DEBUGPRINT2((
            "Sbp2Port: SendReq: ERROR, couldn't allocate bus req ctx\n"
            ));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (TransferMode == SYNC_1394_REQUEST) {

        if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {

            //
            // Since we can't block at this level, we will have to do the
            // synch request asynchronously
            //

            TransferMode = ASYNC_SYNC_1394_REQUEST;
            requestContext->Complete = 0;

        } else {

            KeInitializeEvent(
                &requestContext->Event,
                NotificationEvent,
                FALSE
                );
        }
    }

    requestContext->DeviceExtension = DeviceExtension;
    requestContext->RequestType = TransferMode;

    if (TransferMode == SYNC_1394_REQUEST){

        requestContext->Packet = NULL;

    } else {

        requestContext->Packet = RequestPacket;
    }

    nextIrpStack = IoGetNextIrpStackLocation (RequestPacket->Irp);

    nextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    nextIrpStack->Parameters.Others.Argument1 = RequestPacket->Irb;

    IoSetCompletionRoutine(RequestPacket->Irp,
                           Sbp2RequestCompletionRoutine,
                           requestContext,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    status = IoCallDriver(
                DeviceExtension->LowerDeviceObject,
                RequestPacket->Irp
                );

    if (status == STATUS_INVALID_GENERATION) {

        DEBUGPRINT1(("Sbp2Port: SendReq: Bus drv ret'd invalid generation\n"));
        RequestPacket->Irp->IoStatus.Status = STATUS_REQUEST_ABORTED;
    }

    if (originalTransferMode == SYNC_1394_REQUEST ) {

        if (TransferMode == SYNC_1394_REQUEST) {

            if (status == STATUS_PENDING) {

                //
                // < DISPATCH_LEVEL so wait on an event
                //

                KeWaitForSingleObject(
                    &requestContext->Event,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL
                    );
             }

        } else { // ASYNC_SYNC_1394_REQUEST

            //
            // >= DISPATCH_LEVEL so we can't wait, do the nasty...
            //

            volatile ULONG *pComplete = &requestContext->Complete;

            while (*pComplete == 0);

            status = RequestPacket->Irp->IoStatus.Status;
        }

        //
        // Free the context (the Irp.Irb will be returnd by the caller)
        //

        if (DeviceExtension->Type == SBP2_PDO) {

            ExInterlockedPushEntrySList(
                &DeviceExtension->BusRequestContextListHead,
                &requestContext->ListPointer,
                &DeviceExtension->BusRequestLock
                );

        } else {

            ExFreePool (requestContext);
        }

        return RequestPacket->Irp->IoStatus.Status;
    }

    return status;
}


NTSTATUS
Sbp2RequestCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PREQUEST_CONTEXT Context
    )

/*++

Routine Description:

    Completion routine used for all requests to 1394 bus driver

Arguments:

    DriverObject - Pointer to driver object created by system.

    Irp - Irp that just completed

    Event - Event we'll signal to say Irp is done

Return Value:

    None.

--*/

{
    ASSERT(Context!=NULL);
    ASSERT(Context->DeviceExtension);

    if (Context->RequestType == SYNC_1394_REQUEST) {

        //
        // Synch request completion (either synch, or synch at DPC)
        //

        KeSetEvent (&Context->Event, IO_NO_INCREMENT, FALSE);

    } else if (Context->RequestType == ASYNC_1394_REQUEST) {

        //
        // Asynchronous request completion, so do any necessary
        // post-processing & return the context and the Irp/Irb
        // to the free lists.
        //

        if (Context->Packet) {

            switch (Context->Packet->Irb->FunctionNumber) {

            case REQUEST_ASYNC_READ:
            case REQUEST_ASYNC_WRITE:

                if (Context->Packet->Irb->u.AsyncWrite.nNumberOfBytesToWrite ==
                        sizeof(OCTLET)) {

                    IoFreeMdl (Context->Packet->Irb->u.AsyncRead.Mdl);

                    Context->Packet->Irb->u.AsyncRead.Mdl = NULL;
                }

                break;
            }

            DeAllocateIrpAndIrb (Context->DeviceExtension, Context->Packet);
        }

        if (Context->DeviceExtension->Type == SBP2_PDO) {

            ExInterlockedPushEntrySList(
                &Context->DeviceExtension->BusRequestContextListHead,
                &Context->ListPointer,
                &Context->DeviceExtension->BusRequestLock
                );

        } else {

            ExFreePool (Context);
        }

    } else { // ASYNC_SYNC_1394_REQUEST

        //
        // Just set the Complete flag to unblock Sbp2SendRequest
        //

        Context->Complete = 1;
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
Sbp2CreateRequestErrorLog(
    IN PDEVICE_OBJECT DeviceObject,
    IN PASYNC_REQUEST_CONTEXT Context,
    IN NTSTATUS Status
    )

{
    PIO_ERROR_LOG_PACKET errorLogEntry;


    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        DeviceObject,
        sizeof(IO_ERROR_LOG_PACKET) + sizeof(ORB_NORMAL_CMD)
        );

    if (errorLogEntry) {

        switch (Status) {

        case STATUS_DEVICE_POWER_FAILURE:

            errorLogEntry->ErrorCode = IO_ERR_NOT_READY;
            break;

        case STATUS_INSUFFICIENT_RESOURCES:

            errorLogEntry->ErrorCode = IO_ERR_INSUFFICIENT_RESOURCES;
            break;

        case STATUS_TIMEOUT:

            errorLogEntry->ErrorCode = IO_ERR_TIMEOUT;
            break;

        case STATUS_DEVICE_PROTOCOL_ERROR:

            errorLogEntry->ErrorCode = IO_ERR_BAD_FIRMWARE;
            break;


        case STATUS_INVALID_PARAMETER:
        case STATUS_INVALID_DEVICE_REQUEST:

            errorLogEntry->ErrorCode = IO_ERR_INVALID_REQUEST;
            break;

        case STATUS_REQUEST_ABORTED:
    
            errorLogEntry->ErrorCode = IO_ERR_RESET;
            break;
    
        default:

            errorLogEntry->ErrorCode = IO_ERR_BAD_FIRMWARE;
            break;
        }
    
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = IRP_MJ_SCSI;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = Status;

        if (Context) {

            errorLogEntry->DumpDataSize = sizeof(ORB_NORMAL_CMD);
            RtlCopyMemory(&(errorLogEntry->DumpData[0]),Context->CmdOrb,sizeof(ORB_NORMAL_CMD));

        } else {

            errorLogEntry->DumpDataSize = 0;
        }

        IoWriteErrorLogEntry(errorLogEntry);

        DEBUGPRINT2((
            "Sbp2Port: ErrorLog: dev=x%p, status=x%x, ctx=x%p\n",
            DeviceObject,
            Status,
            Context
            ));

    } else {

        DEBUGPRINT2 (("Sbp2Port: ErrorLog: failed to allocate log entry\n"));
    }
}


NTSTATUS
CheckStatusResponseValue(
    IN PSTATUS_FIFO_BLOCK StatusBlock
    )
/*++

Routine Description:

    It checks the status block result bits and maps the errors to
    NT status errors

Arguments:

    DeviceExtension - Sbp2 device extension

    ManagementStatus - If true then we check the management orb status

Return Value:

    NTSTATUS

++*/

{
    NTSTATUS status;
    UCHAR   resp;
    USHORT  statusFlags = StatusBlock->AddressAndStatus.u.HighQuad.u.HighPart;


    if (statusFlags & STATUS_BLOCK_UNSOLICITED_BIT_MASK) {

        //
        // The unsolicited bit is set, which means this status is
        // not related to anything...
        //

        status = STATUS_NOT_FOUND;

    } else {

        resp = statusFlags & STATUS_BLOCK_RESP_MASK;

        if (resp == 0x01) {

            resp = (statusFlags & STATUS_BLOCK_RESP_MASK) & 0x0F;

            //
            // This a protocol/transport error. Check the redefined sbp-status field for serial-bus erros
            //

            switch (resp) {

            case 0x02: //time out
            case 0x0D: // data error
            case 0x0C: // conflict error

                status = STATUS_DEVICE_PROTOCOL_ERROR;
                break;

            case 0x04: // busy retry limit exceeded

                status = STATUS_DEVICE_BUSY;
                break;

            case 0x09: // rejected

                status = STATUS_INVALID_DEVICE_REQUEST;
                break;

            case 0x0F: // address error

                status = STATUS_INVALID_ADDRESS;
                break;

            case 0x0E: // type error

                status = STATUS_INVALID_PARAMETER;
                break;

            default:

                status = STATUS_UNSUCCESSFUL;
                break;
            }
            return status;
        }

        if (resp == 0x02) {

            return STATUS_ILLEGAL_FUNCTION;
        }

        //
        // REQUEST_COMPLETE. Check sbp_status field for more info
        //

        if (resp == 0x00) {

            switch ((statusFlags & STATUS_BLOCK_SBP_STATUS_MASK)) {

            case 0x11: //dummy orb completed
            case 0x00: // no additional status to report

                status = STATUS_SUCCESS;
                break;

            case 0x01: // request type not supported
            case 0x02: // speed not supported
            case 0x03: // page size not supported

                status = STATUS_NOT_SUPPORTED;
                break;

            case 0x10: // login id not recognized

                status = STATUS_TRANSACTION_INVALID_ID;
                break;

            case 0xFF: // unspecifed error

                status = STATUS_UNSUCCESSFUL;
                break;

            case 0x09: // function rejected

                status = STATUS_ILLEGAL_FUNCTION;
                break;

            case 0x04: // access denied
            case 0x05: //LUN not supported

                status = STATUS_ACCESS_DENIED;
                break;

            case 0x07:
            case 0x08:

                status = STATUS_INSUFFICIENT_RESOURCES;
                break;

            default:

                status = STATUS_UNSUCCESSFUL;
                break;
            }
        }
    }

    return status;
}


NTSTATUS 
GetRegistryParameters(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN OUT PULONG DiagnosticFlags,
    IN OUT PULONG MaxTransferSize
    )

/*++

Routine Description:
    
    This function gets some values out of the registry for initialization

Arguments:

    PhysicalDeviceObject - The Port driver's parent device object

    DiagnosticFlags - Used for debugging

    ReceiveWorkers - Max number of receive worker structures

    TransmitWorkers - Max number of xmit worker structures

    bAllowPhyConfigPackets - do we allow phy config packets to be sent

Return Value:

    Status is returned from Irp

--*/

{

    NTSTATUS status;
    HANDLE handle;
    WCHAR diagnosticModeKey[] = L"DiagnosticFlags";
    WCHAR maxTransferSizeKey[]  = L"MaxTransferSize";

    status = IoOpenDeviceRegistryKey(
                PhysicalDeviceObject,
                PLUGPLAY_REGKEY_DEVICE,
                STANDARD_RIGHTS_ALL,
               &handle
                );
                                     
    if (NT_SUCCESS(status)) {

        GetRegistryKeyValue(
            handle,
            diagnosticModeKey,
            sizeof(diagnosticModeKey),
            DiagnosticFlags,
            sizeof(*DiagnosticFlags)
            );
              
        GetRegistryKeyValue(
            handle,
            maxTransferSizeKey,
            sizeof(maxTransferSizeKey),
            MaxTransferSize,
            sizeof(*MaxTransferSize)
            );
            

        ZwClose(handle);
    }

    DEBUGPRINT3((
        "Sbp2Port: GetRegParams: status=x%x, diag=x%x, maxXfer=x%x\n",
        status,
        *DiagnosticFlags,
        *MaxTransferSize
        ));

    return (status);
}


NTSTATUS 
GetRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    )

/*++

Routine Description:
    
    This routine gets the specified value out of the registry

Arguments:

    Handle - Handle to location in registry

    KeyNameString - registry key we're looking for

    KeyNameStringLength - length of registry key we're looking for

    Data - where to return the data

    DataLength - how big the data is

Return Value:

    status is returned from ZwQueryValueKey

--*/

{
    NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING keyName;
    ULONG length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;


    RtlInitUnicodeString(&keyName, KeyNameString);
    
    length = sizeof(KEY_VALUE_FULL_INFORMATION) + 
            KeyNameStringLength + DataLength;
            
    fullInfo = ExAllocatePoolWithTag(PagedPool, length,'2pbs'); 
    
    if (fullInfo) { 
       
        status = ZwQueryValueKey(
                    Handle,
                   &keyName,
                    KeyValueFullInformation,
                    fullInfo,
                    length,
                   &length
                    );
                        
        if (NT_SUCCESS(status)){

            if (DataLength == fullInfo->DataLength) {

                RtlCopyMemory(
                    Data,
                    ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                    DataLength
                    );

            } else {

                DEBUGPRINT1((
                    "Sbp2Port: GetRegKeyVal: keyLen!=exp, dataLen=x%x " \
                        "fullInfoLen=x%x\n",
                    DataLength,
                    fullInfo->DataLength
                    ));
            }
        }

        ExFreePool(fullInfo);
    }
    
    return (status);
}


VOID
ValidateTextLeaf(
    IN PTEXTUAL_LEAF Leaf
    )
{
    PUCHAR buff;
    PWCHAR wBuff;
    ULONG byteSwappedData;


    //
    // check the lengths. insert null terminators if they are
    // too long...
    //

    byteSwappedData = bswap(*((PULONG)Leaf+1));
    wBuff = (PWCHAR) &Leaf->TL_Data;
    buff = &Leaf->TL_Data;

    if (Leaf->TL_Length > SBP2_MAX_TEXT_LEAF_LENGTH) {

        ASSERT(Leaf->TL_Length <= SBP2_MAX_TEXT_LEAF_LENGTH);
        buff[SBP2_MAX_TEXT_LEAF_LENGTH-1] = 0;
        buff[SBP2_MAX_TEXT_LEAF_LENGTH-2] = 0;
    }

    //
    // check for invalid characters and replace them with _
    //

    if (byteSwappedData & 0x80000000) {

        //
        // unicode
        //

        for (wBuff = (PWCHAR) &Leaf->TL_Data; *wBuff; wBuff++) {

            if ((*wBuff < L' ')  || (*wBuff > (WCHAR)0x7F) || (*wBuff == L',')) {

                *wBuff = L'_';
            }
        }

    } else {

        //
        // ascii
        //

        for (buff = &Leaf->TL_Data; *buff; buff++) {

            if ((*buff < L' ')  || (*buff > (CHAR)0x7F) || (*buff == L',')) {

                *buff = L'_';
            }
        }
    }
}


VOID
Sbp2StartNextPacketByKey(
    IN PDEVICE_OBJECT   DeviceObject,
    IN ULONG            Key
    )
/*++

Routine Description:

    This routine was lifted from the Io sources
    (IopStartNextPacketByKey), and duplicated/modifed here for
    two reasons: 1) we got tired of hitting the queue-not-busy assert
    in KeRemoveXxx, and 2) we needed a way to prevent stack-blowing
    recursion, for example, arising from a bunch of requests sent to
    a stopped device (all failed in StartIo, which calls this func).

    These routines were originally designed with the idea that there
    would only be one outstanding request at a time, but this driver
    can have multiple outstanding requests, and it frequently ends up
    making redundant calls to XxStartNextPacket(ByKey), which result
    in the aforementioned assert.

    Rolling our own version of this also allows us to get rid the
    the cancel overhead, since we do not (currently) support cancels.

Arguments:

    DeviceObject - Pointer to device object itself

    Key - Specifics the Key used to remove the entry from the queue

Return Value:

    None

--*/
{
    PIRP                 irp;
    PDEVICE_EXTENSION    deviceExtension = (PDEVICE_EXTENSION)
                             DeviceObject->DeviceExtension;
    PKDEVICE_QUEUE_ENTRY packet;


    //
    // Increment the StartNextPacketCount, and if result is != 1
    // then just return because we don't want to worry about
    // recursion & blowing the stack.  The instance of this
    // function that caused the SNPCount 0 to 1 transition
    // will eventually make another pass through the loop below
    // on this instance's behalf.
    //

    if (InterlockedIncrement (&deviceExtension->StartNextPacketCount) != 1) {

        return;
    }

    do {

        //
        // Attempt to remove the indicated packet according to the key
        // from the device queue.  If one is found, then process it.
        //

        packet = Sbp2RemoveByKeyDeviceQueueIfBusy(
            &DeviceObject->DeviceQueue,
            Key
            );

        if (packet) {

            irp = CONTAINING_RECORD (packet,IRP,Tail.Overlay.DeviceQueueEntry);

            Sbp2StartIo (DeviceObject, irp);
        }

    } while (InterlockedDecrement (&deviceExtension->StartNextPacketCount));
}


VOID
Sbp2StartPacket(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PULONG           Key OPTIONAL
    )
/*++

Routine Description:

    (See routine description for Sbp2StartNextPacketByKey)

Arguments:

    DeviceObject - Pointer to device object itself

    Irp - I/O Request Packet which should be started on the device

Return Value:

    None

--*/
{
    KIRQL                oldIrql;
    BOOLEAN              inserted;
    PLIST_ENTRY          nextEntry;
    PKDEVICE_QUEUE       queue = &DeviceObject->DeviceQueue;
    PKDEVICE_QUEUE_ENTRY queueEntry = &Irp->Tail.Overlay.DeviceQueueEntry,
                         queueEntry2;


    //
    // Raise the IRQL of the processor to dispatch level for synchronization
    //

    KeRaiseIrql (DISPATCH_LEVEL, &oldIrql);

    KeAcquireSpinLockAtDpcLevel (&queue->Lock);

    if (Key) {

        //
        // Insert the specified device queue entry in the device queue at the
        // position specified by the sort key if the device queue is busy.
        // Otherwise set the device queue busy an don't insert the device
        // queue entry.
        //

        queueEntry->SortKey = *Key;

        if (queue->Busy == TRUE) {

            inserted = TRUE;

            nextEntry = queue->DeviceListHead.Flink;

            while (nextEntry != &queue->DeviceListHead) {

                queueEntry2 = CONTAINING_RECORD(
                    nextEntry,
                    KDEVICE_QUEUE_ENTRY,
                    DeviceListEntry
                    );

                if (*Key < queueEntry2->SortKey) {

                    break;
                }

                nextEntry = nextEntry->Flink;
            }

            nextEntry = nextEntry->Blink;

            InsertHeadList (nextEntry, &queueEntry->DeviceListEntry);

        } else {

            queue->Busy = TRUE;
            inserted = FALSE;
        }

    } else {

        //
        // Insert the specified device queue entry at the end of the device
        // queue if the device queue is busy. Otherwise set the device queue
        // busy and don't insert the device queue entry.
        //

        if (queue->Busy == TRUE) {

            inserted = TRUE;

            InsertTailList(
                &queue->DeviceListHead,
                &queueEntry->DeviceListEntry
                );

        } else {

            queue->Busy = TRUE;
            inserted = FALSE;
        }
    }

    queueEntry->Inserted = inserted;

    KeReleaseSpinLockFromDpcLevel (&queue->Lock);

    //
    // If the packet was not inserted into the queue, then this request is
    // now the current packet for this device.  Indicate so by storing its
    // address in the current IRP field, and begin processing the request.
    //

    if (!inserted) {

        //
        // Invoke the driver's start I/O routine to get the request going
        // on the device
        //

        Sbp2StartIo (DeviceObject, Irp);
    }

    //
    // Restore the IRQL back to its value upon entry to this function before
    // returning to the caller
    //

    KeLowerIrql (oldIrql);
}


PKDEVICE_QUEUE_ENTRY
Sbp2RemoveByKeyDeviceQueueIfBusy(
    IN PKDEVICE_QUEUE   DeviceQueue,
    IN ULONG            SortKey
    )
/*++

Routine Description:

    This routine was lifted directly from Ke sources
    (KeRemoveByKeyDeviceQueueIfBusy) to allow this driver to maintain
    WDM compatibility, since the Ke API does not exist on Win9x or Win2k.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    SortKey - Supplies the sort key by which the position to remove the device
        queue entry is to be determined.

Return Value:

    A NULL pointer is returned if the device queue is empty. Otherwise a
    pointer to a device queue entry is returned.

--*/
{
    PLIST_ENTRY             nextEntry;
    PKDEVICE_QUEUE_ENTRY    queueEntry;


    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Lock specified device queue.
    //

    KeAcquireSpinLockAtDpcLevel (&DeviceQueue->Lock);

    //
    // If the device queue is busy, then attempt to remove an entry from
    // the queue using the sort key. Otherwise, set the device queue not
    // busy.
    //

    if (DeviceQueue->Busy != FALSE) {

        if (IsListEmpty (&DeviceQueue->DeviceListHead) != FALSE) {

            DeviceQueue->Busy = FALSE;
            queueEntry = NULL;

        } else {

            nextEntry = DeviceQueue->DeviceListHead.Flink;

            while (nextEntry != &DeviceQueue->DeviceListHead) {

                queueEntry = CONTAINING_RECORD(
                    nextEntry,
                    KDEVICE_QUEUE_ENTRY,
                    DeviceListEntry
                    );

                if (SortKey <= queueEntry->SortKey) {

                    break;
                }

                nextEntry = nextEntry->Flink;
            }

            if (nextEntry != &DeviceQueue->DeviceListHead) {

                RemoveEntryList (&queueEntry->DeviceListEntry);

            } else {

                nextEntry = RemoveHeadList (&DeviceQueue->DeviceListHead);

                queueEntry = CONTAINING_RECORD(
                    nextEntry,
                    KDEVICE_QUEUE_ENTRY,
                    DeviceListEntry
                    );
            }

            queueEntry->Inserted = FALSE;
        }

    } else {

        queueEntry = NULL;
    }

    //
    // Unlock specified device queue and return address of device queue
    // entry.
    //

    KeReleaseSpinLockFromDpcLevel (&DeviceQueue->Lock);

    return queueEntry;
}


BOOLEAN
Sbp2InsertByKeyDeviceQueue(
    PKDEVICE_QUEUE          DeviceQueue,
    PKDEVICE_QUEUE_ENTRY    DeviceQueueEntry,
    ULONG                   SortKey
    )
/*++

Routine Description:

    (Again, stolen from Ke src to maintain consistent use of spinlocks.)

    This function inserts a device queue entry into the specified device
    queue according to a sort key. If the device is not busy, then it is
    set busy and the entry is not placed in the device queue. Otherwise
    the specified entry is placed in the device queue at a position such
    that the specified sort key is greater than or equal to its predecessor
    and less than its successor.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    DeviceQueueEntry - Supplies a pointer to a device queue entry.

    SortKey - Supplies the sort key by which the position to insert the device
        queue entry is to be determined.

Return Value:

    If the device is not busy, then a value of FALSE is returned. Otherwise a
    value of TRUE is returned.

--*/
{
    BOOLEAN              inserted;
    PLIST_ENTRY          nextEntry;
    PKDEVICE_QUEUE       queue = DeviceQueue;
    PKDEVICE_QUEUE_ENTRY queueEntry = DeviceQueueEntry,
                         queueEntry2;


    KeAcquireSpinLockAtDpcLevel (&queue->Lock);

    //
    // Insert the specified device queue entry in the device queue at the
    // position specified by the sort key if the device queue is busy.
    // Otherwise set the device queue busy an don't insert the device
    // queue entry.
    //

    queueEntry->SortKey = SortKey;

    if (queue->Busy == TRUE) {

        inserted = TRUE;

        nextEntry = queue->DeviceListHead.Flink;

        while (nextEntry != &queue->DeviceListHead) {

            queueEntry2 = CONTAINING_RECORD(
                nextEntry,
                KDEVICE_QUEUE_ENTRY,
                DeviceListEntry
                );

            if (SortKey < queueEntry2->SortKey) {

                break;
            }

            nextEntry = nextEntry->Flink;
        }

        nextEntry = nextEntry->Blink;

        InsertHeadList (nextEntry, &queueEntry->DeviceListEntry);

    } else {

        queue->Busy = TRUE;
        inserted = FALSE;
    }

    KeReleaseSpinLockFromDpcLevel (&queue->Lock);

    return inserted;
}

#if PASSWORD_SUPPORT

NTSTATUS
Sbp2GetExclusiveValue(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    OUT PULONG          Exclusive
    )
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    HANDLE              RootHandle = NULL;
    UNICODE_STRING      uniTempName;


    // set default value...

    *Exclusive = EXCLUSIVE_FLAG_CLEAR;

    uniTempName.Buffer = NULL;

    ntStatus = IoOpenDeviceRegistryKey( PhysicalDeviceObject,
                                        PLUGPLAY_REGKEY_DEVICE,
                                        KEY_ALL_ACCESS,
                                        &RootHandle
                                        );

    if (!NT_SUCCESS(ntStatus)) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Sbp2GetExclusiveValue;
    }

    uniTempName.Length = 0;
    uniTempName.MaximumLength = 128;

    uniTempName.Buffer = ExAllocatePool(
        NonPagedPool,
        uniTempName.MaximumLength
        );

    if (!uniTempName.Buffer) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Sbp2GetExclusiveValue;
    }

    {
        PKEY_VALUE_PARTIAL_INFORMATION      KeyInfo;
        ULONG                               KeyLength;
        ULONG                               ResultLength;

        KeyLength = sizeof (KEY_VALUE_PARTIAL_INFORMATION) + sizeof (ULONG);

        KeyInfo = ExAllocatePool (NonPagedPool, KeyLength);

        if (KeyInfo == NULL) {

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit_Sbp2GetExclusiveValue;
        }

        RtlZeroMemory(uniTempName.Buffer, uniTempName.MaximumLength);
        uniTempName.Length = 0;
        RtlAppendUnicodeToString(&uniTempName, L"Exclusive");

        ntStatus = ZwQueryValueKey( RootHandle,
                                    &uniTempName,
                                    KeyValuePartialInformation,
                                    KeyInfo,
                                    KeyLength,
                                    &ResultLength
                                    );

        if (NT_SUCCESS(ntStatus)) {

            *Exclusive = *((PULONG) &KeyInfo->Data);

            DEBUGPRINT1 (("Sbp2Port: GetExclVal: excl=x%x\n", *Exclusive));

        } else {

            DEBUGPRINT1((
                "Sbp2Port: GetExclVal: QueryValueKey err=x%x\n",
                ntStatus
                ));
        }

        ExFreePool (KeyInfo);
    }

Exit_Sbp2GetExclusiveValue:

    if (RootHandle) {

        ZwClose (RootHandle);
    }

    if (uniTempName.Buffer) {

        ExFreePool (uniTempName.Buffer);
    }

    return ntStatus;
}


NTSTATUS
Sbp2SetExclusiveValue(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    IN PULONG           Exclusive
    )
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    HANDLE              RootHandle = NULL;
    UNICODE_STRING      uniTempName;


    uniTempName.Buffer = NULL;

    ntStatus = IoOpenDeviceRegistryKey( PhysicalDeviceObject,
                                        PLUGPLAY_REGKEY_DEVICE,
                                        KEY_ALL_ACCESS,
                                        &RootHandle
                                        );

    if (!NT_SUCCESS(ntStatus)) {

        goto Exit_Sbp2SetExclusiveValue;
    }

    uniTempName.Length = 0;
    uniTempName.MaximumLength = 128;

    uniTempName.Buffer = ExAllocatePool(
        NonPagedPool,
        uniTempName.MaximumLength
        );

    if (!uniTempName.Buffer) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Sbp2SetExclusiveValue;
    }

    RtlZeroMemory (uniTempName.Buffer, uniTempName.MaximumLength);
    uniTempName.Length = 0;
    RtlAppendUnicodeToString(&uniTempName, L"Exclusive");

    ntStatus = ZwSetValueKey( RootHandle,
                              &uniTempName,
                              0,
                              REG_DWORD,
                              Exclusive,
                              sizeof(ULONG)
                              );
                                  
    if (!NT_SUCCESS(ntStatus)) {

        DEBUGPRINT1(("Sbp2Port: SetExclVal: SetValueKey err=x%x\n", ntStatus));
        *Exclusive = 0;
    }
    else {

        DEBUGPRINT1(("Sbp2Port: SetExclVal: excl=x%x\n", *Exclusive));
    }

Exit_Sbp2SetExclusiveValue:

    if (RootHandle) {

        ZwClose(RootHandle);
    }

    if (uniTempName.Buffer) {

        ExFreePool(uniTempName.Buffer);
    }

    return ntStatus;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\sbp2port\sbp21394.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    sbp21394.c

Abstract:

    1394 bus driver to SBP2 interface routines

    Author:

    George Chrysanthakopoulos January-1997

Environment:

    Kernel mode

Revision History :

--*/

#include "sbp2port.h"


NTSTATUS
Sbp2Issue1394BusReset (
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    PIRBIRP     packet = NULL;
    NTSTATUS    status;


    AllocateIrpAndIrb (DeviceExtension, &packet);

    if (!packet) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Issue a 1394 bus reset
    //

    packet->Irb->FunctionNumber = REQUEST_BUS_RESET;
    packet->Irb->Flags = BUS_RESET_FLAGS_PERFORM_RESET;

    status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1((
            "Sbp2Port: IssueBusReset: err=x%x issuing bus reset\n",
            status
            ));
    }

    DeAllocateIrpAndIrb(DeviceExtension,packet);

    return status;
}

void
Sbp2BusResetNotification(
    PFDO_DEVICE_EXTENSION   FdoExtension
    )
{
    NTSTATUS        ntStatus;
    PIO_WORKITEM    WorkItem;

    ntStatus = IoAcquireRemoveLock(&FdoExtension->RemoveLock, NULL);

    if (NT_SUCCESS(ntStatus)) {

        WorkItem = IoAllocateWorkItem(FdoExtension->DeviceObject);

        IoQueueWorkItem( WorkItem,
                         Sbp2BusResetNotificationWorker,
                         CriticalWorkQueue,
                         WorkItem
                         );
    }

    return;
}

void
Sbp2BusResetNotificationWorker(
    PDEVICE_OBJECT      DeviceObject,
    PIO_WORKITEM        WorkItem
    )
{
    PFDO_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PDEVICE_EXTENSION deviceExtension;
    PSCSI_REQUEST_BLOCK pendingPowerSrb = NULL;
    ULONG i=0;
    BOOLEAN doReconnect;
    KIRQL DeviceListIrql, DataIrql;
    NTSTATUS ntStatus;

    ExAcquireFastMutex(&fdoExtension->ResetMutex);

#if DBG
    InterlockedIncrement(&fdoExtension->ulWorkItemCount);
#endif

    //
    // dont check if alloc failed here, its not critical
    //

    //
    // go through each children, and do whats necessry (reconnect/cleanup)
    //

    KeAcquireSpinLock(&fdoExtension->DeviceListLock, &DeviceListIrql);

    if (fdoExtension->DeviceListSize == 0) {

        DEBUGPRINT1(("Sbp2Port:Sbp2BusResetNotification, NO PDOs, exiting..\n"));
        goto Exit_Sbp2BusResetNotificationWorker;
    }

    for (i = 0;i < fdoExtension->DeviceListSize; i++) {

        if (!fdoExtension->DeviceList[i].DeviceObject) {

            break;
        }

        deviceExtension = fdoExtension->DeviceList[i].DeviceObject->DeviceExtension;

        if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_REMOVED) ||
            !TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_INITIALIZED)){

            continue;
        }

        KeCancelTimer(&deviceExtension->DeviceManagementTimer);

        ntStatus = IoAcquireRemoveLock(&deviceExtension->RemoveLock, NULL);

        if (!NT_SUCCESS(ntStatus))
            continue;

        //
        // if this a login-per-use device, we might be logged at the moment
        // so we do need to re-init but not reconnect
        //

        if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_STOPPED)) {

            doReconnect = FALSE;

        } else {

            //
            // Turn on the RESET & RECONNECT flags, and turn off the LOGIN
            // flag just in case the reset interrupted a previous (re-)LOGIN.
            // All address mappings are invalidated after a reset
            //

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock, &DataIrql);
            CLEAR_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_LOGIN_IN_PROGRESS);
            SET_FLAG(deviceExtension->DeviceFlags, (DEVICE_FLAG_RESET_IN_PROGRESS | DEVICE_FLAG_RECONNECT));
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock, DataIrql);
            doReconnect = TRUE;
        }

        KeReleaseSpinLock(&fdoExtension->DeviceListLock, DeviceListIrql);

        DEBUGPRINT1((
            "\nSbp2Port: BusResetNotification: ext=x%x, lun=x%x\n",
            deviceExtension,
            deviceExtension->DeviceInfo->Lun.u.LowPart
            ));

        Sbp2DeferPendingRequest(deviceExtension, NULL);

        Sbp2CleanDeviceExtension(deviceExtension->DeviceObject,FALSE);

        //
        // all the resident 1394 memory addresses's that we have, are
        // now invalidated... So we need to free them and re-allocate
        // them

        Sbp2InitializeDeviceExtension(deviceExtension);

        if (doReconnect) {

            deviceExtension->DueTime.HighPart = -1;
            deviceExtension->DueTime.LowPart = -((deviceExtension->DeviceInfo->UnitCharacteristics.u.LowPart >> 8) & 0x000000FF) * 1000 * 1000 * 5;
            KeSetTimer(&deviceExtension->DeviceManagementTimer,deviceExtension->DueTime,&deviceExtension->DeviceManagementTimeoutDpc);

            Sbp2ManagementTransaction(deviceExtension, TRANSACTION_RECONNECT);

        } else {

            DEBUGPRINT1(("Sbp2Port:Sbp2BusResetNotification, NO need for reconnect, device stopped\n"));
            SET_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED);
        }

        KeAcquireSpinLock(&fdoExtension->DeviceListLock, &DeviceListIrql);

        IoReleaseRemoveLock(&deviceExtension->RemoveLock, NULL);
    }

Exit_Sbp2BusResetNotificationWorker:

    KeReleaseSpinLock(&fdoExtension->DeviceListLock, DeviceListIrql);

#if DBG
    InterlockedDecrement(&fdoExtension->ulWorkItemCount);
#endif

    ExReleaseFastMutex(&fdoExtension->ResetMutex);
    IoFreeWorkItem(WorkItem);

    IoReleaseRemoveLock(&fdoExtension->RemoveLock, NULL);
    return;
}


VOID
Sbp2DeferPendingRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
{
    KIRQL   oldIrql;

    //
    // If the queue is locked, it means that we might be trying to process
    // a power request.   We cannot abort it, since that would prevent the
    // device from powering up/down.  So save the SRB and irp, free the
    // context, and then after we are done-reinitializing, call StartIo
    // directly with the power request
    //

    if (TEST_FLAG (DeviceExtension->DeviceFlags, DEVICE_FLAG_QUEUE_LOCKED)) {

        KeAcquireSpinLock (&DeviceExtension->OrbListSpinLock, &oldIrql);

        if (!IsListEmpty (&DeviceExtension->PendingOrbList)) {

            PASYNC_REQUEST_CONTEXT tail = \
                RETRIEVE_CONTEXT(DeviceExtension->PendingOrbList.Flink,OrbList);

            ASSERT (Irp == NULL);

            if (TEST_FLAG(tail->Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE)) {

                DEBUGPRINT1((
                    "Sbp2Port: DeferPendingReq: ext=x%p, defer irp=x%p cdb=x%x\n",
                    DeviceExtension,
                    tail->Srb->OriginalRequest,
                    tail->Srb->Cdb[0]
                    ));

                ASSERT (DeviceExtension->DeferredPowerRequest == NULL);

                DeviceExtension->DeferredPowerRequest =
                    tail->Srb->OriginalRequest;

                //
                // Since a bus reset has occured it's safe to remove the
                // pending ORB from the list... this only works if there
                // is only one pending ORB (the power one)
                //

                ASSERT (tail->OrbList.Flink == tail->OrbList.Blink);

                tail->Srb = NULL;

                CLEAR_FLAG (tail->Flags, ASYNC_CONTEXT_FLAG_TIMER_STARTED);
                KeCancelTimer (&tail->Timer);

                FreeAsyncRequestContext (DeviceExtension, tail);
                InitializeListHead (&DeviceExtension->PendingOrbList);

            } else {

                DeviceExtension->DeferredPowerRequest = NULL;
            }

        } else if (Irp) {

            DEBUGPRINT1((
                "Sbp2Port: DeferPendingReq: ext=x%p, defer irp=x%p\n",
                DeviceExtension,
                Irp
                ));

            ASSERT (DeviceExtension->DeferredPowerRequest == NULL);

            DeviceExtension->DeferredPowerRequest = Irp;
        }

        KeReleaseSpinLock (&DeviceExtension->OrbListSpinLock, oldIrql);
    }
}


NTSTATUS
Sbp2Get1394ConfigInfo(
    IN PFDO_DEVICE_EXTENSION DeviceExtension,
    IN OUT PSBP2_REQUEST Sbp2Req
    )
/*++

Routine Description:

    Reads the configuration ROM from the SBP2 device. Retrieve any SBP2 required info
    for accessing the device and updates our device extension.

Arguments:

    DeviceExtension - Pointer to device extension.
    Sbp2Req - Sbp2 request packet to read/parse a text leaf for a give key. When this parameter is defined
        this routine does NOT re-enumerate the crom, looking for pdos and sbp2 keys

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_INFORMATION devInfo, firstDevInfo;
    NTSTATUS status;
    ULONG directoryLength, vendorLeafLength, modelLeafLength,
          depDirLength, devListSize = DeviceExtension->DeviceListSize;

    ULONG i,j,dirInfoQuad;
    ULONG currentGeneration;

    ULONG unitDirEntries = 0;
    BOOLEAN sbp2Device = FALSE;
    BOOLEAN firstOne = FALSE;

    PVOID unitDirectory = NULL;
    PVOID unitDependentDirectory = NULL;
    PVOID modelLeaf = NULL;
    PVOID vendorLeaf = NULL;
    IO_ADDRESS cromOffset, cromOffset1;
    ULONG offset;

    PIRBIRP packet = NULL;


    AllocateIrpAndIrb ((PDEVICE_EXTENSION) DeviceExtension, &packet);

    if (!packet) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // find out how much configuration space we need by setting lengths to zero.
    //

    packet->Irb->FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;
    packet->Irb->Flags = 0;
    packet->Irb->u.GetConfigurationInformation.UnitDirectoryBufferSize = 0;
    packet->Irb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize = 0;
    packet->Irb->u.GetConfigurationInformation.VendorLeafBufferSize = 0;
    packet->Irb->u.GetConfigurationInformation.ModelLeafBufferSize = 0;

    status = Sbp2SendRequest(
        (PDEVICE_EXTENSION) DeviceExtension,
        packet,
        SYNC_1394_REQUEST
        );

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: err=x%x getting cfg info (1)\n", status));
        goto exit1394Config;
    }

    //
    // Now go thru and allocate what we need to so we can get our info.
    //

    if (packet->Irb->u.GetConfigurationInformation.UnitDirectoryBufferSize) {
        unitDirectory = ExAllocatePool(NonPagedPool, packet->Irb->u.GetConfigurationInformation.UnitDirectoryBufferSize);

        if (!unitDirectory) {

            DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: alloc UnitDir me failed\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit1394Config;
        }

    } else {

        DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: no unit dir, bad dev\n"));
        status = STATUS_BAD_DEVICE_TYPE;
        goto exit1394Config;
    }


    if (packet->Irb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize) {

        unitDependentDirectory = ExAllocatePool(NonPagedPool, packet->Irb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize);

        if (!unitDependentDirectory) {

            DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: alloc UnitDepDir mem failed\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit1394Config;
        }
    }

    if (packet->Irb->u.GetConfigurationInformation.VendorLeafBufferSize) {

        vendorLeaf = ExAllocatePool(NonPagedPool, packet->Irb->u.GetConfigurationInformation.VendorLeafBufferSize);

        if (!vendorLeaf) {

            DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: alloc VendorLeaf mem failed\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit1394Config;
        }

        vendorLeafLength = packet->Irb->u.GetConfigurationInformation.VendorLeafBufferSize;
    }

    if (packet->Irb->u.GetConfigurationInformation.ModelLeafBufferSize) {

        modelLeaf = ExAllocatePool(NonPagedPool, packet->Irb->u.GetConfigurationInformation.ModelLeafBufferSize);

        if (!modelLeaf) {

            DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: alloc ModelLeaf mem failed\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit1394Config;
        }

        modelLeafLength = packet->Irb->u.GetConfigurationInformation.ModelLeafBufferSize;
    }


    //
    // Now resubmit the Irb with the appropriate pointers inside
    //

    packet->Irb->FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;
    packet->Irb->Flags = 0;
    packet->Irb->u.GetConfigurationInformation.ConfigRom = &DeviceExtension->ConfigRom;
    packet->Irb->u.GetConfigurationInformation.UnitDirectory = unitDirectory;
    packet->Irb->u.GetConfigurationInformation.UnitDependentDirectory = unitDependentDirectory;
    packet->Irb->u.GetConfigurationInformation.VendorLeaf = vendorLeaf;
    packet->Irb->u.GetConfigurationInformation.ModelLeaf = modelLeaf;

    status = Sbp2SendRequest(
       (PDEVICE_EXTENSION) DeviceExtension,
       packet,
       SYNC_1394_REQUEST
       );

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: error=x%x getting cfg info (2)\n", status));
        goto exit1394Config;
    }

    //
    // get generation count..
    //

    packet->Irb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
    packet->Irb->Flags = 0;

    status = Sbp2SendRequest(
        (PDEVICE_EXTENSION) DeviceExtension,
        packet,
        SYNC_1394_REQUEST
        );

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: err=x%x getting gen #\n", status));
        goto exit1394Config;
    }

    currentGeneration = packet->Irb->u.GetGenerationCount.GenerationCount;

    cromOffset = packet->Irb->u.GetConfigurationInformation.UnitDirectoryLocation;

    if (!Sbp2Req) {

        //
        // run through the list amd free any model leafs we have seen before
        //

        for (i = 0; i < DeviceExtension->DeviceListSize; i++) {

            devInfo = &DeviceExtension->DeviceList[i];

            if (devInfo->ModelLeaf) {

                ExFreePool(devInfo->ModelLeaf);
                devInfo->ModelLeaf = NULL;
            }
        }

        if (DeviceExtension->VendorLeaf) {

            ExFreePool(DeviceExtension->VendorLeaf);
            DeviceExtension->VendorLeaf = NULL;
        }

        devListSize = 0;

        DeviceExtension->VendorLeaf = vendorLeaf;

        if (vendorLeaf != NULL) {

            DeviceExtension->VendorLeaf->TL_Length = (USHORT) vendorLeafLength;
        }
    }

    //
    // Now dwell deep in the configRom and get Lun number, uniqueId identifiers, etc
    // Since the bus driver returned the unit directory, we can just look at our local buffer
    // for all the info we need. We neeed to find the offsets withtin the unit directory
    //

    directoryLength = packet->Irb->u.GetConfigurationInformation.UnitDirectoryBufferSize >> 2;
    firstDevInfo = &DeviceExtension->DeviceList[0];

    for (i = 1; i < directoryLength; i++) {

        if (Sbp2Req) {

            //
            // look for this particular text leaf..
            //

            if (Sbp2Req->u.RetrieveTextLeaf.fulFlags & SBP2REQ_RETRIEVE_TEXT_LEAF_INDIRECT) {

                if ((*(((PULONG) unitDirectory)+i) & CONFIG_ROM_KEY_MASK) == TEXTUAL_LEAF_INDIRECT_KEY_SIGNATURE) {

                    if ((*(((PULONG) unitDirectory-1)+i) & CONFIG_ROM_KEY_MASK) == Sbp2Req->u.RetrieveTextLeaf.Key) {

                        DEBUGPRINT2(("Sbp2Port: Get1394CfgInfo: matched text leaf, req=x%x\n", Sbp2Req));

                        offset = cromOffset.IA_Destination_Offset.Off_Low + i*sizeof(ULONG) + (ULONG) (bswap(*(((PULONG) unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK)
                                       *sizeof(ULONG));

                        cromOffset.IA_Destination_Offset.Off_Low = offset;

                        DEBUGPRINT2(("Sbp2Port: Get1394CfgInfo: unitDir=x%p, offset=x%x, key=x%x\n", unitDirectory,
                                    cromOffset.IA_Destination_Offset.Off_Low, *(((PULONG) unitDirectory)+i) ));

                        Sbp2ParseTextLeaf(DeviceExtension,unitDirectory,
                                          &cromOffset,
                                          &Sbp2Req->u.RetrieveTextLeaf.Buffer);

                        if (Sbp2Req->u.RetrieveTextLeaf.Buffer) {

                            Sbp2Req->u.RetrieveTextLeaf.ulLength = \
                            (bswap(*(PULONG) Sbp2Req->u.RetrieveTextLeaf.Buffer) >> 16) * sizeof(ULONG);
                            status = STATUS_SUCCESS;

                        } else {

                            status = STATUS_UNSUCCESSFUL;
                        }

                        break;
                    }
                }
            }

            continue;
        }

        devInfo = &DeviceExtension->DeviceList[devListSize];

        switch (*(((PULONG) unitDirectory)+i) & CONFIG_ROM_KEY_MASK) {

        case CSR_OFFSET_KEY_SIGNATURE:

            //
            // Found the command base offset.  This is a quadlet offset from
            // the initial register space.
            //

            firstDevInfo->ManagementAgentBaseReg.BusAddress.Off_Low =
                  (ULONG) (bswap(*(((PULONG) unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK)
                           *sizeof(ULONG)) | INITIAL_REGISTER_SPACE_LO;

            sbp2Device = TRUE;

            break;

        case LUN_CHARACTERISTICS_KEY_SIGNATURE:

            firstDevInfo->UnitCharacteristics.QuadPart =
                  (ULONG) bswap(*(((PULONG)unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK);

            unitDirEntries ++;

            break;

        case CMD_SET_ID_KEY_SIGNATURE:

            firstDevInfo->CmdSetId.QuadPart =
                  (ULONG) bswap(*(((PULONG) unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK);

            unitDirEntries ++;

            break;

        case CMD_SET_SPEC_ID_KEY_SIGNATURE :

            firstDevInfo->CmdSetSpecId.QuadPart =
                  (ULONG) bswap(*(((PULONG) unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK);

            unitDirEntries ++;

            break;

        case FIRMWARE_REVISION_KEY_SIGNATURE:

            if ((bswap(*(((PULONG) unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK) >> 8) == LSI_VENDOR_ID) {

                DEBUGPRINT2(("Sbp2Port: Get1394CfgInfo: found LSI bridge, maxXfer=128kb\n"));
                DeviceExtension->MaxClassTransferSize = (SBP2_MAX_DIRECT_BUFFER_SIZE+1)*2;
            }

            break;

        case LUN_KEY_SIGNATURE:

            devInfo->Lun.QuadPart =
                 (ULONG) bswap(*(((PULONG) unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK);

            if ((devListSize == 0) && modelLeaf) {

                devInfo->ModelLeaf = modelLeaf;
                devInfo->ModelLeaf->TL_Length = (USHORT) modelLeafLength;

            } else {

                devInfo->ModelLeaf = NULL;
            }

            devInfo->VendorLeaf = vendorLeaf;
            devInfo->ConfigRom = &DeviceExtension->ConfigRom;

            devListSize++;

            devInfo->ManagementAgentBaseReg.BusAddress.Off_Low = \
                firstDevInfo->ManagementAgentBaseReg.BusAddress.Off_Low;

            devInfo->CmdSetId.QuadPart = firstDevInfo->CmdSetId.QuadPart;
            devInfo->CmdSetSpecId.QuadPart =
                firstDevInfo->CmdSetSpecId.QuadPart;

            devInfo->UnitCharacteristics.QuadPart = firstDevInfo->UnitCharacteristics.QuadPart;

            unitDirEntries ++;

            break;

        case LU_DIRECTORY_KEY_SIGNATURE:

            //
            // this device has logical unit subdirectories within its unit. Probably
            // has multiple units..
            // calculate offset to that LU dir..
            // If this is the first one, ignore it, we already got through the
            // GetConfiguration call..
            //

            if (firstOne == FALSE) {

                firstOne = TRUE;
                depDirLength = packet->Irb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize >> 2;

                //
                // parse the unit dep dir..we are looking for the LUN entry and the model leaf
                //

                for (j = 0;j < depDirLength; j++) {

                    if ((*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_KEY_MASK) == LUN_KEY_SIGNATURE) {

                        devInfo->Lun.QuadPart =
                             (ULONG) bswap(*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_OFFSET_MASK);

                        devInfo->ConfigRom = &DeviceExtension->ConfigRom;

                        if (devListSize > 0) {

                            devInfo->ModelLeaf = NULL;

                        } else if (modelLeaf){

                            devInfo->ModelLeaf = modelLeaf;
                            devInfo->ModelLeaf->TL_Length = (USHORT) modelLeafLength;
                        }

                        devInfo->VendorLeaf = vendorLeaf;

                        devListSize++;

                        devInfo->ManagementAgentBaseReg.BusAddress.Off_Low =
                            firstDevInfo->ManagementAgentBaseReg.BusAddress.Off_Low;

                        if (devInfo->CmdSetId.QuadPart == 0 ) {

                            devInfo->CmdSetId.QuadPart = firstDevInfo->CmdSetId.QuadPart;
                        }

                        if (devInfo->CmdSetSpecId.QuadPart == 0 ) {

                            devInfo->CmdSetSpecId.QuadPart = firstDevInfo->CmdSetSpecId.QuadPart;
                        }

                        if (devInfo->UnitCharacteristics.QuadPart == 0 ) {

                            devInfo->UnitCharacteristics.QuadPart = firstDevInfo->UnitCharacteristics.QuadPart;
                        }

                        unitDirEntries ++;
                    }

                    switch (*(((PULONG) unitDependentDirectory)+j) &
                                CONFIG_ROM_KEY_MASK) {

                    case CMD_SET_ID_KEY_SIGNATURE:

                        devInfo->CmdSetId.QuadPart =
                              (ULONG) bswap(*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_OFFSET_MASK);

                        unitDirEntries ++;

                        break;

                    case CMD_SET_SPEC_ID_KEY_SIGNATURE:

                        devInfo->CmdSetSpecId.QuadPart =
                              (ULONG) bswap(*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_OFFSET_MASK);

                        unitDirEntries ++;

                        break;

                    case TEXTUAL_LEAF_INDIRECT_KEY_SIGNATURE:

                        if ((*(((PULONG) unitDependentDirectory)+j-1) & CONFIG_ROM_KEY_MASK) == MODEL_ID_KEY_SIGNATURE) {

                            if (devInfo->ModelLeaf == NULL) {

                                //
                                // special case. if the first LU is only present in unit dir, then the second
                                // LU will be the first unit dependent dir , which means we have to parse
                                // its model text
                                //

                                cromOffset1 = packet->Irb->u.GetConfigurationInformation.UnitDependentDirectoryLocation;

                                cromOffset1.IA_Destination_Offset.Off_Low += j*sizeof(ULONG) + (ULONG) (bswap(*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_OFFSET_MASK)
                                               *sizeof(ULONG));

                                Sbp2ParseTextLeaf(DeviceExtension,unitDependentDirectory,
                                                  &cromOffset1,
                                                  &devInfo->ModelLeaf);
                            }
                        }

                        break;

                    default:

                        break;

                    } // switch
                }

            } else {

                //
                // read the crom and retrieve the unit dep dir
                //

                offset = cromOffset.IA_Destination_Offset.Off_Low + i*sizeof(ULONG) + (ULONG) (bswap(*(((PULONG) unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK)
                               *sizeof(ULONG));

                //
                // read LU dir header..
                //

                packet->Irb->u.AsyncRead.Mdl = IoAllocateMdl(unitDependentDirectory,
                                                             depDirLength,
                                                             FALSE,
                                                             FALSE,
                                                             NULL);

                MmBuildMdlForNonPagedPool(packet->Irb->u.AsyncRead.Mdl);

                packet->Irb->FunctionNumber = REQUEST_ASYNC_READ;
                packet->Irb->Flags = 0;
                packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;
                packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low = offset;
                packet->Irb->u.AsyncRead.nNumberOfBytesToRead = sizeof(ULONG);
                packet->Irb->u.AsyncRead.nBlockSize = 0;
                packet->Irb->u.AsyncRead.fulFlags = 0;
                packet->Irb->u.AsyncRead.ulGeneration = currentGeneration;
                packet->Irb->u.AsyncRead.nSpeed = SCODE_100_RATE;

                status = Sbp2SendRequest(
                    (PDEVICE_EXTENSION)DeviceExtension,
                    packet,
                    SYNC_1394_REQUEST
                    );

                if (!NT_SUCCESS(status)) {

                    DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: err=x%x getting cfg info (3)\n", status));

                    IoFreeMdl (packet->Irb->u.AsyncRead.Mdl);
                    goto exit1394Config;
                }

                dirInfoQuad = bswap (*(PULONG) unitDependentDirectory) >> 16;
                depDirLength = dirInfoQuad * sizeof(ULONG);

                IoFreeMdl (packet->Irb->u.AsyncRead.Mdl);

                if (depDirLength > 0x100) {

                    DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: unitDep dir 2 too big, len=x%x\n", depDirLength));
                    goto exit1394Config;
                }

                ExFreePool (unitDependentDirectory);

                unitDependentDirectory = ExAllocatePoolWithTag(NonPagedPool,depDirLength+sizeof(ULONG),'2pbs');

                if (!unitDependentDirectory) {

                    goto exit1394Config;
                }

                packet->Irb->u.AsyncRead.Mdl = IoAllocateMdl(unitDependentDirectory,
                                                             depDirLength+sizeof(ULONG),
                                                             FALSE,
                                                             FALSE,
                                                             NULL);

                MmBuildMdlForNonPagedPool (packet->Irb->u.AsyncRead.Mdl);

                //
                // read the rest of the unit dependent dir, one quadlet at a time...
                // parse as you read..
                //

                j = 1;

                do {

                    packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low = offset+j*sizeof(ULONG);
                    ((PULONG) (((PMDL) (packet->Irb->u.AsyncRead.Mdl))->MappedSystemVa))++;
                    ((PULONG) (((PMDL) (packet->Irb->u.AsyncRead.Mdl))->StartVa))++;

                    status = Sbp2SendRequest(
                        (PDEVICE_EXTENSION)DeviceExtension,
                        packet,
                        SYNC_1394_REQUEST
                        );

                    if (!NT_SUCCESS(status)) {

                        DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: err=x%x getting cfg info (4)\n", status));

                        IoFreeMdl (packet->Irb->u.AsyncRead.Mdl);

                        goto exit1394Config;
                    }

                    if ((*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_KEY_MASK) == LUN_KEY_SIGNATURE) {

                        devInfo->Lun.QuadPart =
                             (ULONG) bswap(*(((PULONG) unitDependentDirectory+j)) & CONFIG_ROM_OFFSET_MASK);

                        devInfo->ModelLeaf = NULL;
                        devInfo->VendorLeaf = vendorLeaf;
                        devInfo->ConfigRom = &DeviceExtension->ConfigRom;

                        devListSize++;

                        devInfo->ManagementAgentBaseReg.BusAddress.Off_Low =
                            firstDevInfo->ManagementAgentBaseReg.BusAddress.Off_Low;

                        if (devInfo->CmdSetId.QuadPart == 0 ) {

                            devInfo->CmdSetId.QuadPart = firstDevInfo->CmdSetId.QuadPart;
                        }

                        if (devInfo->CmdSetSpecId.QuadPart == 0 ) {

                            devInfo->CmdSetSpecId.QuadPart = firstDevInfo->CmdSetSpecId.QuadPart;
                        }

                        if (devInfo->UnitCharacteristics.QuadPart == 0 ) {

                            devInfo->UnitCharacteristics.QuadPart = firstDevInfo->UnitCharacteristics.QuadPart;
                        }

                        unitDirEntries ++;
                    }

                    switch (*(((PULONG) unitDependentDirectory)+j) &
                                CONFIG_ROM_KEY_MASK) {

                    case CMD_SET_ID_KEY_SIGNATURE:

                        devInfo->CmdSetId.QuadPart =
                              (ULONG) bswap(*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_OFFSET_MASK);

                        unitDirEntries ++;

                        break;

                    case CMD_SET_SPEC_ID_KEY_SIGNATURE:

                        devInfo->CmdSetSpecId.QuadPart =
                              (ULONG) bswap(*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_OFFSET_MASK);

                        unitDirEntries ++;

                        break;

                    case TEXTUAL_LEAF_INDIRECT_KEY_SIGNATURE:

                        //
                        // oh man, we run into a textual descriptor..
                        // this means we need to parse a LU model descriptor from this..
                        // make sure the quad behind it is a MODEL_ID...
                        //

                        if ((*(((PULONG) unitDependentDirectory)+j-1) & CONFIG_ROM_KEY_MASK) == MODEL_ID_KEY_SIGNATURE) {

                            cromOffset1.IA_Destination_Offset.Off_Low = offset + j*sizeof(ULONG) + (ULONG) (bswap(*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_OFFSET_MASK)
                                           *sizeof(ULONG));

                            Sbp2ParseTextLeaf(DeviceExtension,unitDependentDirectory,
                                              &cromOffset1,
                                              &devInfo->ModelLeaf);
                        }

                        break;

                    default:

                        break;
                    }

                    j++;

                } while (j <= depDirLength / sizeof(ULONG));

                IoFreeMdl (packet->Irb->u.AsyncRead.Mdl);
            }

            break;

        default:

            break;

        } // switch
    }

    if (!Sbp2Req) {

        if (!sbp2Device || (unitDirEntries < SBP2_MIN_UNIT_DIR_ENTRIES)) {

            DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: bad/non-SBP2 dev, cRom missing unitDir info\n"));

            status = STATUS_BAD_DEVICE_TYPE;
        }
    }

exit1394Config:

    if (packet) {

        DeAllocateIrpAndIrb ((PDEVICE_EXTENSION) DeviceExtension, packet);
    }

    if (unitDirectory) {

        ExFreePool (unitDirectory);
    }

    if (unitDependentDirectory) {

        ExFreePool (unitDependentDirectory);
    }

    if (!Sbp2Req) {

        DeviceExtension->DeviceListSize = devListSize;

        if (!NT_SUCCESS (status)) {

            if (vendorLeaf) {

                ExFreePool (vendorLeaf);
            }

            if (modelLeaf) {

                ExFreePool (modelLeaf);

                if (modelLeaf == DeviceExtension->DeviceList[0].ModelLeaf) {

                    DeviceExtension->DeviceList[0].ModelLeaf = NULL;
                }
            }

            DeviceExtension->VendorLeaf = NULL;
        }

    } else {

        if (vendorLeaf) {

            ExFreePool (vendorLeaf);
        }

        if (modelLeaf) {

            ExFreePool (modelLeaf);
        }
    }

    return status;
}


VOID
Sbp2ParseTextLeaf(
    PFDO_DEVICE_EXTENSION DeviceExtension,
    PVOID UnitDepDir,
    PIO_ADDRESS ModelLeafLocation,
    PVOID *ModelLeaf
    )
{
    PIRBIRP packet = NULL;
    PVOID tModelLeaf;
    PTEXTUAL_LEAF leaf;
    ULONG leafLength,i, currentGeneration;
    ULONG temp;
    NTSTATUS status;


    AllocateIrpAndIrb((PDEVICE_EXTENSION)DeviceExtension,&packet);

    if (!packet) {

        return;
    }

    //
    // get generation count..
    //

    packet->Irb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
    packet->Irb->Flags = 0;

    status = Sbp2SendRequest(
        (PDEVICE_EXTENSION) DeviceExtension,
        packet,
        SYNC_1394_REQUEST
        );

    if (!NT_SUCCESS(status)) {

        DeAllocateIrpAndIrb ((PDEVICE_EXTENSION) DeviceExtension, packet);
        DEBUGPRINT1(("Sbp2Port:Sbp2ParseModelLeaf: Error %x while trying to get generation number\n", status));
        return;
    }

    currentGeneration = packet->Irb->u.GetGenerationCount.GenerationCount;

    tModelLeaf = ExAllocatePoolWithTag(NonPagedPool,32,'2pbs');

    if (!tModelLeaf) {

        DeAllocateIrpAndIrb((PDEVICE_EXTENSION)DeviceExtension,packet);
        return;
    }

    //
    // find out how big the model leaf is
    //

    packet->Irb->u.AsyncRead.Mdl = IoAllocateMdl(tModelLeaf,
                                                 32,
                                                 FALSE,
                                                 FALSE,
                                                 NULL);

    MmBuildMdlForNonPagedPool(packet->Irb->u.AsyncRead.Mdl);

    packet->Irb->FunctionNumber = REQUEST_ASYNC_READ;
    packet->Irb->Flags = 0;
    packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;
    packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low = \
        ModelLeafLocation->IA_Destination_Offset.Off_Low;

    packet->Irb->u.AsyncRead.nNumberOfBytesToRead = sizeof(ULONG);
    packet->Irb->u.AsyncRead.nBlockSize = 0;
    packet->Irb->u.AsyncRead.fulFlags = 0;
    packet->Irb->u.AsyncRead.ulGeneration = currentGeneration;
    packet->Irb->u.AsyncRead.nSpeed = SCODE_100_RATE;

    status = Sbp2SendRequest(
        (PDEVICE_EXTENSION) DeviceExtension,
        packet,
        SYNC_1394_REQUEST
        );

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1(("Sbp2Get1394ConfigInfo: Error %x while trying to get LU dir model LEAF\n", status));

        ExFreePool(tModelLeaf);
        IoFreeMdl(packet->Irb->u.AsyncRead.Mdl);

        DeAllocateIrpAndIrb((PDEVICE_EXTENSION)DeviceExtension,packet);
        return;
    }

    leafLength = (bswap(*(PULONG) tModelLeaf) >> 16) * sizeof(ULONG);
    temp = *((PULONG) tModelLeaf);

    if ((leafLength+sizeof(ULONG)) > 32) {

        //
        // re allocate the mdl to fit the whole leaf
        //

        IoFreeMdl(packet->Irb->u.AsyncRead.Mdl);
        ExFreePool(tModelLeaf);

        tModelLeaf = ExAllocatePoolWithTag(NonPagedPool,leafLength+sizeof(ULONG),'2pbs');

        if (!tModelLeaf) {

            DeAllocateIrpAndIrb((PDEVICE_EXTENSION)DeviceExtension,packet);
            return;
        }


        packet->Irb->u.AsyncRead.Mdl = IoAllocateMdl(tModelLeaf,
                                                     leafLength+sizeof(ULONG),
                                                     FALSE,
                                                     FALSE,
                                                     NULL);

        MmBuildMdlForNonPagedPool(packet->Irb->u.AsyncRead.Mdl);
    }

    //
    // read the entire model leaf...
    //

    i=1;
    *((PULONG)tModelLeaf) = temp;

    do {

        packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low = \
            ModelLeafLocation->IA_Destination_Offset.Off_Low+i*sizeof(ULONG);

        ((PULONG) (((PMDL) (packet->Irb->u.AsyncRead.Mdl))->MappedSystemVa))++;
        ((PULONG) (((PMDL) (packet->Irb->u.AsyncRead.Mdl))->StartVa))++;


        status = Sbp2SendRequest(
            (PDEVICE_EXTENSION) DeviceExtension,
            packet,
            SYNC_1394_REQUEST
            );

        if (!NT_SUCCESS(status)) {

            DEBUGPRINT1(("Sbp2Get1394ConfigInfo: Error %x while trying to get LU dir model LEAF\n", status));

            ExFreePool(tModelLeaf);
            IoFreeMdl(packet->Irb->u.AsyncRead.Mdl);

            DeAllocateIrpAndIrb((PDEVICE_EXTENSION)DeviceExtension,packet);
            return;
        }

        i++;

    } while (i<= leafLength/4);

    leaf = (PTEXTUAL_LEAF) tModelLeaf;
    leaf->TL_Length = (USHORT)leafLength;

    *ModelLeaf = tModelLeaf;

    IoFreeMdl(packet->Irb->u.AsyncRead.Mdl);
    DeAllocateIrpAndIrb((PDEVICE_EXTENSION)DeviceExtension,packet);
}


NTSTATUS
Sbp2UpdateNodeInformation(
    PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Gets node ID and generation information, volatile between bus resets

Arguments:

    DeviceExtension - Pointer to device extension.

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   oldIrql;
    PIRBIRP                 packet = NULL;
    NTSTATUS                status;
    PASYNC_REQUEST_CONTEXT  nextListItem,currentListItem ;


    AllocateIrpAndIrb (DeviceExtension, &packet);

    if (!packet) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Make a call to determine what the generation # is on the bus,
    // followed by a call to find out about ourself (config rom info)
    //

    packet->Irb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
    packet->Irb->Flags = 0;

    status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1((
            "Sbp2Port: UpdateNodeInfo: ext=%p, err=x%x getting gen(2)\n",
            DeviceExtension,
            status
            ));

        goto exitGetNodeInfo;
    }

    KeAcquireSpinLock (&DeviceExtension->ExtensionDataSpinLock, &oldIrql);

    DeviceExtension->CurrentGeneration =
        packet->Irb->u.GetGenerationCount.GenerationCount;

    KeReleaseSpinLock(&DeviceExtension->ExtensionDataSpinLock,oldIrql);

    //
    // Get the initiator id (Sbp2port is the initiator in all 1394
    // transactions)
    //

    packet->Irb->FunctionNumber = REQUEST_GET_ADDR_FROM_DEVICE_OBJECT;
    packet->Irb->u.Get1394AddressFromDeviceObject.fulFlags = USE_LOCAL_NODE;
    packet->Irb->Flags = 0;

    status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1((
            "Sbp2Port: UpdateNodeInfo: ext=%p, err=x%x getting node id\n",
            DeviceExtension,
            status
            ));

        goto exitGetNodeInfo;
    }

    KeAcquireSpinLock (&DeviceExtension->ExtensionDataSpinLock, &oldIrql);

    DeviceExtension->InitiatorAddressId =
        packet->Irb->u.Get1394AddressFromDeviceObject.NodeAddress;

    KeReleaseSpinLock (&DeviceExtension->ExtensionDataSpinLock, oldIrql);

    DEBUGPRINT2((
        "Sbp2Port: UpdateNodeInfo: ext=x%p, gen=%d, initiatorId=x%x\n",
        DeviceExtension,
        DeviceExtension->CurrentGeneration,
        DeviceExtension->InitiatorAddressId
        ));

    //
    // If we have active requests pending, we have to traverse the
    // list and update their addresses...
    //

    KeAcquireSpinLock (&DeviceExtension->OrbListSpinLock, &oldIrql);

    if (!IsListEmpty (&DeviceExtension->PendingOrbList)) {

        nextListItem = RETRIEVE_CONTEXT(DeviceExtension->PendingOrbList.Flink,OrbList);

        do {

            currentListItem = nextListItem;

            //
            // Now update the cmdOrb fields with the new addresses...
            // Since they are stored in BigEndian (awaiting to be fetched)
            // so when we correct their address, this taken into consideration
            //

            // update the data descriptor address

            octbswap (currentListItem->CmdOrb->DataDescriptor);

            currentListItem->CmdOrb->DataDescriptor.BusAddress.NodeId = DeviceExtension->InitiatorAddressId;

            octbswap (currentListItem->CmdOrb->DataDescriptor);

            nextListItem = (PASYNC_REQUEST_CONTEXT) currentListItem->OrbList.Flink;

        } while (currentListItem != RETRIEVE_CONTEXT(DeviceExtension->PendingOrbList.Blink,OrbList));
    }

    KeReleaseSpinLock (&DeviceExtension->OrbListSpinLock, oldIrql);


exitGetNodeInfo:

    DeAllocateIrpAndIrb (DeviceExtension, packet);

    return status;
}


NTSTATUS
Sbp2ManagementTransaction(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG Type
    )
/*++

Routine Description:
    This routine creates and sends down management ORB's. According to the ORB type
    it will send the request synch/asynchronously. After a management ORB completes
    the bus driver will call the SBp2ManagementStatusCallback

Arguments:

    deviceExtension - Sbp2 device extension
    Type - Type of Managament SBP2 transaction

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_OBJECT deviceObject = DeviceExtension->DeviceObject;

    NTSTATUS status;
    KIRQL cIrql;

    PORB_MNG    sbpRequest = DeviceExtension->ManagementOrb;
    PORB_QUERY_LOGIN queryOrb;
    PORB_LOGIN loginOrb;

    LARGE_INTEGER waitValue;
    LONG temp;


    if (TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_REMOVED)) {

        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    RtlZeroMemory (sbpRequest, sizeof (ORB_MNG));

    //
    // Get the 1394 address for our request ORB and the responce ORB's(for login) from the target
    // setup the Type in the status context
    //

    DeviceExtension->GlobalStatusContext.TransactionType = Type;

    switch (Type) {

    case TRANSACTION_LOGIN:

        loginOrb = (PORB_LOGIN) sbpRequest;

        //
        // indicate in our device extension that we are doing a login
        //

        KeAcquireSpinLock(&DeviceExtension->ExtensionDataSpinLock,&cIrql);
        SET_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_LOGIN_IN_PROGRESS);
        KeReleaseSpinLock(&DeviceExtension->ExtensionDataSpinLock, cIrql);

        RtlZeroMemory (DeviceExtension->LoginResponse, sizeof(LOGIN_RESPONSE));

        //
        // Fill in the login ORB, the address of the response buffer
        //

        loginOrb->LoginResponseAddress.BusAddress = DeviceExtension->LoginRespContext.Address.BusAddress;
        loginOrb->LengthInfo.u.HighPart= 0 ; // password length is 0
        loginOrb->LengthInfo.u.LowPart= sizeof(LOGIN_RESPONSE); //set size of response buffer

        //
        // Set the notify bit ot one, Exclusive bit to 0, rq_fmt bit to 0
        // Then set our LUN number
        //

        loginOrb->OrbInfo.QuadPart =0;
        loginOrb->OrbInfo.u.HighPart |= (ORB_NOTIFY_BIT_MASK | ORB_MNG_RQ_FMT_VALUE);

        //
        // If this is an rbc or direct access device then set the exclusive
        // login bit.
        //
        // NOTE: Win2k & Win98SE are checking InquiryData.DeviceType,
        //       but during StartDevice() we are doing a login before we
        //       do an INQUIRY, so this field was always zeroed & we log
        //       in exclusively on those platforms
        //

        switch (DeviceExtension->DeviceInfo->Lun.u.HighPart & 0x001f) {

        case RBC_DEVICE:
        case DIRECT_ACCESS_DEVICE:

             loginOrb->OrbInfo.u.HighPart |= ORB_MNG_EXCLUSIVE_BIT_MASK;
             break;
        }

        loginOrb->OrbInfo.u.LowPart = DeviceExtension->DeviceInfo->Lun.u.LowPart;

        //
        // We don't support passwords yet
        //

#if PASSWORD_SUPPORT

        if (DeviceExtension->Exclusive & EXCLUSIVE_FLAG_SET) {

            loginOrb->Password.u.HighQuad.QuadPart =
                DeviceExtension->DeviceInfo->ConfigRom->CR_Node_UniqueID[1];
            loginOrb->Password.u.LowQuad.QuadPart =
                DeviceExtension->DeviceInfo->ConfigRom->CR_Node_UniqueID[0];

            DEBUGPRINT1(("Sbp2Port: MgmtXact: password=x%x%x, len=x%x\n",
                loginOrb->Password.u.HighQuad.QuadPart,
                loginOrb->Password.u.LowQuad.QuadPart,
                loginOrb->LengthInfo.u.HighPart));

        } else {

            loginOrb->Password.OctletPart = 0;
        }

#else
        loginOrb->Password.OctletPart = 0;
#endif

        //
        // Set the type of the management transaction in the ORB
        //

        loginOrb->OrbInfo.u.HighPart |=0x00FF & Type;

#if PASSWORD_SUPPORT
        octbswap(loginOrb->Password);
#endif
        octbswap(loginOrb->LoginResponseAddress);
        loginOrb->OrbInfo.QuadPart = bswap(loginOrb->OrbInfo.QuadPart);
        loginOrb->LengthInfo.QuadPart = bswap(loginOrb->LengthInfo.QuadPart);

        sbpRequest->StatusBlockAddress.BusAddress = DeviceExtension->GlobalStatusContext.Address.BusAddress;
        octbswap(loginOrb->StatusBlockAddress);

        //
        // write to the Management Agent register, to signal that a management ORB is ready
        // if we are doing this during a reset, it will have to be done asynchronously
        //

        if (!TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_RESET_IN_PROGRESS)) {

            //
            // Synchronous login case. We will wait on an event until our DPC associated with the login status, fires and sets the event
            //

            ASSERT(InterlockedIncrement(&DeviceExtension->ulPendingEvents) == 1);

            KeInitializeEvent(DeviceExtension->ManagementOrbContext.Reserved, NotificationEvent, FALSE);

            DEBUGPRINT2(("Sbp2Port: MgmtXact: waiting for login status\n"));
            status = Sbp2AccessRegister(DeviceExtension,&DeviceExtension->ManagementOrbContext.Address,MANAGEMENT_AGENT_REG | REG_WRITE_SYNC);

            if (!NT_SUCCESS(status)) {

                DEBUGPRINT2(("Sbp2Port: MgmtXact: can't access mgmt reg ext=x%p, FAIL LOGIN\n", DeviceExtension));

                ASSERT(InterlockedDecrement(&DeviceExtension->ulPendingEvents) == 0);
                return status;
            }

            //
            // set the login timeout value, to what we read from the registry (LOGIN_TIMEOUT)
            // divide by 2, to convert to seconds
            //

            temp = max (SBP2_LOGIN_TIMEOUT, (DeviceExtension->DeviceInfo->UnitCharacteristics.u.LowPart >> 9));
            waitValue.QuadPart = -temp * 1000 * 1000 * 10;

            status = KeWaitForSingleObject(DeviceExtension->ManagementOrbContext.Reserved,Executive,KernelMode,FALSE,&waitValue);

            ASSERT(InterlockedDecrement(&DeviceExtension->ulPendingEvents) == 0);

            if (status == STATUS_TIMEOUT) {

                if (TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_LOGIN_IN_PROGRESS)) {

                    DEBUGPRINT1(("Sbp2Port: MgmtXact: login timed out, ext=x%p\n", DeviceExtension));

                    //
                    // In Win2k, etc we would mark the device stopped here &
                    // turn off the login in progress flag. Since this timeout
                    // might be the result of a bus reset, we want to allow
                    // for a retry here.
                    //

                    status = STATUS_UNSUCCESSFUL;

                }  else {

                    status = STATUS_SUCCESS;
                }
            }

            if (!NT_SUCCESS(DeviceExtension->LastTransactionStatus)) {

                status = DeviceExtension->LastTransactionStatus;

            } else if (!DeviceExtension->LoginResponse->Csr_Off_Low.QuadPart) {

                status = STATUS_UNSUCCESSFUL;
            }

            return status;

        } else {

            //
            // Asynchronous login case. Start a timer to track the login..
            //

            // get the Management_Timeout values from the ConfigRom LUN Characteristics entry
            //

            DeviceExtension->DueTime.HighPart = -1;
            DeviceExtension->DueTime.LowPart = -(DeviceExtension->DeviceInfo->UnitCharacteristics.u.LowPart >> 9) * 1000 * 1000 * 10; // divide by 2, to convert to seconds;
            KeSetTimer(&DeviceExtension->DeviceManagementTimer,DeviceExtension->DueTime,&DeviceExtension->DeviceManagementTimeoutDpc);

            status = Sbp2AccessRegister(DeviceExtension,&DeviceExtension->ManagementOrbContext.Address,MANAGEMENT_AGENT_REG | REG_WRITE_ASYNC);

            if (!NT_SUCCESS(status)) {

                DEBUGPRINT2((
                    "Sbp2Port: MgmtXact: can't access mgmt reg ext=x%p, FAIL LOGIN\n",
                    DeviceExtension
                    ));

                return status;
            }

            //
            // for now return pending. the callback will complete this request
            //

            return STATUS_PENDING;
        }

        break;

    case TRANSACTION_QUERY_LOGINS:

        queryOrb = (PORB_QUERY_LOGIN) sbpRequest;

        RtlZeroMemory(
            DeviceExtension->QueryLoginResponse,
            sizeof(QUERY_LOGIN_RESPONSE)
            );

        //
        // Fill in the login ORB, the address of the response buffer
        //

        queryOrb->QueryResponseAddress.BusAddress = DeviceExtension->QueryLoginRespContext.Address.BusAddress;


        queryOrb->LengthInfo.u.HighPart= 0 ; // password length is 0
        queryOrb->LengthInfo.u.LowPart= sizeof(QUERY_LOGIN_RESPONSE); //set size of response buffer

        //
        // Set the notify bit ot one, Exclusive bit to 0, rq_fmt bit to 0
        // Then set our LUN number
        //

        queryOrb->OrbInfo.QuadPart =0;
        queryOrb->OrbInfo.u.HighPart |= (ORB_NOTIFY_BIT_MASK | ORB_MNG_RQ_FMT_VALUE);

        queryOrb->OrbInfo.u.LowPart = DeviceExtension->DeviceInfo->Lun.u.LowPart;

        queryOrb->Reserved.OctletPart = 0;

        //
        // Set the type of the management transaction in the ORB
        //

        queryOrb->OrbInfo.u.HighPart |=0x00FF & Type;

        octbswap(queryOrb->QueryResponseAddress);
        queryOrb->OrbInfo.QuadPart = bswap(queryOrb->OrbInfo.QuadPart);
        queryOrb->LengthInfo.QuadPart = bswap(queryOrb->LengthInfo.QuadPart);

        queryOrb->StatusBlockAddress.BusAddress = DeviceExtension->ManagementOrbStatusContext.Address.BusAddress;
        octbswap(queryOrb->StatusBlockAddress);

        //
        // write to the Management Agent register, to signal that a management ORB is ready
        //

        ASSERT(InterlockedIncrement(&DeviceExtension->ulPendingEvents) == 1);

        waitValue.QuadPart = -8 * 1000 * 1000 * 10;
        KeInitializeEvent(DeviceExtension->ManagementOrbContext.Reserved, NotificationEvent, FALSE);
        status = Sbp2AccessRegister(DeviceExtension,&DeviceExtension->ManagementOrbContext.Address,MANAGEMENT_AGENT_REG | REG_WRITE_SYNC);

        if (!NT_SUCCESS(status)) {

            DEBUGPRINT2((
                "Sbp2Port: MgmtXact: QUERY_LOGIN, can't access mgmt reg, sts=x%x\n",
                status
                ));

            ASSERT(InterlockedDecrement(&DeviceExtension->ulPendingEvents) == 0);
            return status;
        }

        status = KeWaitForSingleObject(DeviceExtension->ManagementOrbContext.Reserved,Executive,KernelMode,FALSE,&waitValue);

        ASSERT(InterlockedDecrement(&DeviceExtension->ulPendingEvents) == 0);

        if (status == STATUS_TIMEOUT) {

            DEBUGPRINT2((
                "Sbp2Port: MgmtXact: QUERY_LOGIN: req timed out, ext=x%p\n",
                DeviceExtension
                ));

            return STATUS_UNSUCCESSFUL;
        }

        return status;

        break;

    case TRANSACTION_RECONNECT:

        DEBUGPRINT2((
            "Sbp2Port: MgmXact: reconnecting to ext=x%p\n",
            DeviceExtension
            ));

    default:

        status = IoAcquireRemoveLock(&DeviceExtension->RemoveLock, NULL);

        if (!NT_SUCCESS(status)) {

            return(status);
        }

        sbpRequest->OrbInfo.QuadPart = 0;
        sbpRequest->OrbInfo.u.HighPart |= (ORB_NOTIFY_BIT_MASK | ORB_MNG_RQ_FMT_VALUE);

        //
        // login ID
        //

        sbpRequest->OrbInfo.u.LowPart = DeviceExtension->LoginResponse->LengthAndLoginId.u.LowPart;

        //
        // Set the type of the management transaction in the ORB
        //

        sbpRequest->OrbInfo.u.HighPart |= 0x00FF & Type;

        //
        // Convert to big endian
        //

        sbpRequest->OrbInfo.QuadPart = bswap (sbpRequest->OrbInfo.QuadPart);

        sbpRequest->StatusBlockAddress.BusAddress = DeviceExtension->ManagementOrbStatusContext.Address.BusAddress;
        octbswap(sbpRequest->StatusBlockAddress);

        if (KeGetCurrentIrql() < DISPATCH_LEVEL) {

            ASSERT(InterlockedIncrement(&DeviceExtension->ulPendingEvents) == 1);

            waitValue.QuadPart = -8 * 1000 * 1000 * 10;

            KeInitializeEvent(DeviceExtension->ManagementOrbContext.Reserved, NotificationEvent, FALSE);

            status = Sbp2AccessRegister(DeviceExtension,&DeviceExtension->ManagementOrbContext.Address,MANAGEMENT_AGENT_REG | REG_WRITE_SYNC);

            if (!NT_SUCCESS(status)) {

                DEBUGPRINT2(("Sbp2Port: MgmtXact: type=%d, can't access mgmt reg, sts=x%x\n",Type,status));
                IoReleaseRemoveLock(&DeviceExtension->RemoveLock, NULL);

                ASSERT(InterlockedDecrement(&DeviceExtension->ulPendingEvents) == 0);
                return status;
            }

            status = KeWaitForSingleObject(DeviceExtension->ManagementOrbContext.Reserved,Executive,KernelMode,FALSE,&waitValue);

            ASSERT(InterlockedDecrement(&DeviceExtension->ulPendingEvents) == 0);

            if (status == STATUS_TIMEOUT) {

                DEBUGPRINT2(("Sbp2Port: MgmtXact: type=%d, ext=x%p, req timeout\n",Type, DeviceExtension));
                IoReleaseRemoveLock(&DeviceExtension->RemoveLock, NULL);
                return STATUS_UNSUCCESSFUL;
            }

        } else {

            status = Sbp2AccessRegister(DeviceExtension,&DeviceExtension->ManagementOrbContext.Address,MANAGEMENT_AGENT_REG | REG_WRITE_ASYNC);
        }

        IoReleaseRemoveLock(&DeviceExtension->RemoveLock, NULL);
        return status;

        break;
    }

    //
    // all MANAGEMENT ORBs except login,query login, are done asynchronously
    //

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return STATUS_PENDING;
}


#if PASSWORD_SUPPORT

NTSTATUS
Sbp2SetPasswordTransaction(
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN ULONG                Type
    )
/*++

Routine Description:
    This routine creates and sends down set password transaction.

Arguments:

    deviceExtension - Sbp2 device extension

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_OBJECT      deviceObject = DeviceExtension->DeviceObject;
    NTSTATUS            status;
    KIRQL               cIrql;

    PORB_SET_PASSWORD   passwordOrb = DeviceExtension->PasswordOrb;

    LARGE_INTEGER       waitValue;
    LONG                temp;


    if (TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_REMOVED)) {

        status = STATUS_DEVICE_DOES_NOT_EXIST;
        goto Exit_Sbp2SetPasswordTransaction;
    }

    RtlZeroMemory(passwordOrb, sizeof(ORB_SET_PASSWORD));

    //
    // Password
    //

    if (Type == SBP2REQ_SET_PASSWORD_EXCLUSIVE) {

        passwordOrb->Password.u.HighQuad.QuadPart =
            DeviceExtension->DeviceInfo->ConfigRom->CR_Node_UniqueID[1];
        passwordOrb->Password.u.LowQuad.QuadPart =
            DeviceExtension->DeviceInfo->ConfigRom->CR_Node_UniqueID[0];

    } else {

        passwordOrb->Password.OctletPart = 0;
    }

    //
    // Reserved
    //

    passwordOrb->Reserved.OctletPart = 0;

    //
    // OrbInfo
    //

    passwordOrb->OrbInfo.QuadPart = 0;

    passwordOrb->OrbInfo.u.HighPart |=
        (ORB_NOTIFY_BIT_MASK | ORB_MNG_RQ_FMT_VALUE);
    passwordOrb->OrbInfo.u.HighPart |=
        0x00FF & TRANSACTION_SET_PASSWORD;

    passwordOrb->OrbInfo.u.LowPart =
        DeviceExtension->LoginResponse->LengthAndLoginId.u.LowPart;

    //
    // LengthInfo
    //

    passwordOrb->LengthInfo.u.HighPart = 0;

    //
    // StatusBlockAddress
    //

    passwordOrb->StatusBlockAddress.BusAddress =
        DeviceExtension->PasswordOrbStatusContext.Address.BusAddress;

    //
    // Bswap everything...
    //

    octbswap (passwordOrb->Password);
    passwordOrb->OrbInfo.QuadPart = bswap (passwordOrb->OrbInfo.QuadPart);
    passwordOrb->LengthInfo.QuadPart = bswap(passwordOrb->LengthInfo.QuadPart);
    octbswap (passwordOrb->StatusBlockAddress);

    //
    // Write to the Management Agent register, to signal that
    // a management ORB is ready
    //

    waitValue.LowPart  = SBP2_SET_PASSWORD_TIMEOUT;
    waitValue.HighPart = -1;

    KeInitializeEvent(
        DeviceExtension->PasswordOrbContext.Reserved,
        NotificationEvent,
        FALSE
        );

    status = Sbp2AccessRegister(
        DeviceExtension,
        &DeviceExtension->PasswordOrbContext.Address,
        MANAGEMENT_AGENT_REG | REG_WRITE_SYNC
        );

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1((
            "Sbp2Port: SetPasswdXact: can't access mgmt reg, sts=x%x\n",
            status
            ));

        goto Exit_Sbp2SetPasswordTransaction;
    }

    status = KeWaitForSingleObject(
        DeviceExtension->PasswordOrbContext.Reserved,
        Executive,
        KernelMode,
        FALSE,
        &waitValue
        );

    if (status == STATUS_TIMEOUT) {

        DEBUGPRINT1((
            "Sbp2Port: SetPasswdXact: req timed out, ext=x%p\n",
            DeviceExtension
            ));

        status = STATUS_UNSUCCESSFUL;

        goto Exit_Sbp2SetPasswordTransaction;
    }

    status = CheckStatusResponseValue(&DeviceExtension->PasswordOrbStatusBlock);

Exit_Sbp2SetPasswordTransaction:

    return(status);
}

#endif

///////////////////////////////////////////////////////////////////////////////
// Callback routines
///////////////////////////////////////////////////////////////////////////////

RCODE
Sbp2GlobalStatusCallback(
    IN PNOTIFICATION_INFO NotificationInfo
    )
/*++

Routine Description:

    Callback routine for writes to our login Status Block. the 1394 driver will call this routine, after
    the target has updated the status in our memory.

Arguments:

    (Check 1394Bus.doc) or 1394.h

Return Value:

    0

--*/
{
    PIRP        requestIrp, irp;
    ULONG       temp, rcode;
    ULONG       currentOrbListDepth, initialOrbListDepth;
    PVOID       *tempPointer;
    PUCHAR      senseBuffer;
    BOOLEAN     cancelledTimer;
    NTSTATUS    status;
    PLIST_ENTRY             entry;
    PDEVICE_OBJECT          deviceObject;
    PDEVICE_EXTENSION       deviceExtension;
    PSTATUS_FIFO_BLOCK      statusBlock;
    PASYNC_REQUEST_CONTEXT  orbContext, nextListItem;

    //
    // NOTE: Uncomment these when enabling ordered execution code below
    //
    // ULONG        completedPrecedingOrbs;
    // LIST_ENTRY   listHead;
    // PLIST_ENTRY  nextEntry;
    //

    if (NotificationInfo->Context != NULL) {

        deviceObject = ((PADDRESS_CONTEXT)NotificationInfo->Context)->DeviceObject;
        deviceExtension = deviceObject->DeviceExtension;

    } else {

        DEBUGPRINT1(("Sbp2Port: GlobalStatusCb: NotifyInfo %p Context NULL!!\n", NotificationInfo));
        return RCODE_RESPONSE_COMPLETE;
    }

    statusBlock = MmGetMdlVirtualAddress (NotificationInfo->Fifo->FifoMdl);

    octbswap (statusBlock->AddressAndStatus);

    status = CheckStatusResponseValue (statusBlock);

    //
    // check if we got a remove before the DPC fired.
    // If we did, dont do anything....
    //

    if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_REMOVED )) {

        DEBUGPRINT1(("Sbp2Port: GlobalStatusCb: dev removed and got status=x%x, State=%x\n",
                    statusBlock,deviceExtension->DeviceFlags));

        ExInterlockedPushEntrySList(&deviceExtension->StatusFifoListHead,
                        (PSINGLE_LIST_ENTRY) &NotificationInfo->Fifo->FifoList,
                        &deviceExtension->StatusFifoLock);

        return RCODE_RESPONSE_COMPLETE;
    }


    if ((statusBlock->AddressAndStatus.BusAddress.Off_Low ==
        deviceExtension->ManagementOrbContext.Address.BusAddress.Off_Low) &&
        (statusBlock->AddressAndStatus.BusAddress.Off_High ==
        deviceExtension->ManagementOrbContext.Address.BusAddress.Off_High)) {

        //
        // Management status callback
        //

        Sbp2LoginCompletion (NotificationInfo, status);

        rcode = RCODE_RESPONSE_COMPLETE;

        goto exitGlobalCallback;
    }


    //
    // Data( Command ORB) status callback
    //

    if (statusBlock->AddressAndStatus.u.HighQuad.u.HighPart &
        STATUS_BLOCK_UNSOLICITED_BIT_MASK) {

        DEBUGPRINT3(("Sbp2Port: GlobalStatusCb: unsolicited recv'd\n"));

        //
        // this is a status unrelated to any pending ORB's, reenable the unsolicited reg
        //

        Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,UNSOLICITED_STATUS_REG | REG_WRITE_ASYNC);

        //
        // intepret the unsolicited status and take appropriate action
        //

        Sbp2HandleUnsolicited(deviceExtension,statusBlock);

        rcode= RCODE_RESPONSE_COMPLETE;
        goto exitGlobalCallback;
    }

    if (deviceExtension->OrbPoolContext.Reserved == NULL) {

        DEBUGPRINT1(("Sbp2Port: GlobalStatusCb: Stopped or Removed and got status %x, State %x.\n",
                    statusBlock, deviceExtension->DeviceFlags));

        ExInterlockedPushEntrySList(&deviceExtension->StatusFifoListHead,
                        (PSINGLE_LIST_ENTRY) &NotificationInfo->Fifo->FifoList,
                        &deviceExtension->StatusFifoLock);

        return RCODE_RESPONSE_COMPLETE;
    }

    //
    // This GOT to be a NORMAL command ORB
    // calculate base address of the ORB, relative to start address of ORB pool
    //

    temp = statusBlock->AddressAndStatus.BusAddress.Off_Low -
           deviceExtension->OrbPoolContext.Address.BusAddress.Off_Low;

    if (temp > (MAX_ORB_LIST_DEPTH * sizeof (ARCP_ORB))) {

        DEBUGPRINT1(("Sbp2Port: GlobalStatusCb: status has invalid addr=x%x\n",temp));
        //ASSERT(temp <= (MAX_ORB_LIST_DEPTH * sizeof (ARCP_ORB)));

        Sbp2CreateRequestErrorLog(deviceExtension->DeviceObject,NULL,STATUS_DEVICE_PROTOCOL_ERROR);

        rcode = RCODE_ADDRESS_ERROR;
        goto exitGlobalCallback;
    }

    //
    // Retrieve the pointer to the context which wraps this ORB.
    // The pointer is stored sizeof(PVOID) bytes behind the ORB's
    // buffer address in host memory.
    //

    tempPointer = (PVOID) (((PUCHAR) deviceExtension->OrbPoolContext.Reserved)
        + temp - FIELD_OFFSET (ARCP_ORB, Orb));

    orbContext = (PASYNC_REQUEST_CONTEXT) *tempPointer;

    if (!orbContext || (orbContext->Tag != SBP2_ASYNC_CONTEXT_TAG)) {

        DEBUGPRINT1(("Sbp2Port: GlobalStatusCb: status has invalid addr(2)=x%x\n",temp));
        //ASSERT(orbContext!=NULL);

        Sbp2CreateRequestErrorLog(deviceExtension->DeviceObject,NULL,STATUS_DEVICE_PROTOCOL_ERROR);

        rcode = RCODE_ADDRESS_ERROR;
        goto exitGlobalCallback;
    }

    DEBUGPRINT4(("Sbp2Port: GlobalStatusCb: ctx=x%p compl\n", orbContext));

    KeAcquireSpinLockAtDpcLevel (&deviceExtension->OrbListSpinLock);

    if (TEST_FLAG (orbContext->Flags, ASYNC_CONTEXT_FLAG_COMPLETED)) {

        //
        // request marked completed before we got the chance to do so. means our lists got hosed or the target
        // finised same request twice..
        //

        KeReleaseSpinLockFromDpcLevel (&deviceExtension->OrbListSpinLock);

        DEBUGPRINT1(("Sbp2Port: GlobalStatusCb: req=x%p already marked compl??\n",orbContext));
        ASSERT(orbContext->Srb == NULL);

        rcode= RCODE_RESPONSE_COMPLETE;
        goto exitGlobalCallback;
    }

    SET_FLAG (orbContext->Flags, ASYNC_CONTEXT_FLAG_COMPLETED);

    requestIrp = (PIRP) orbContext->Srb->OriginalRequest;

#if 1

    //
    // If this is the oldest request in the queue then cancel the timer
    //

    if ((PASYNC_REQUEST_CONTEXT) deviceExtension->PendingOrbList.Flink ==
            orbContext) {

        KeCancelTimer (&orbContext->Timer);
        CLEAR_FLAG (orbContext->Flags,ASYNC_CONTEXT_FLAG_TIMER_STARTED);
        cancelledTimer = TRUE;

        KeReleaseSpinLockFromDpcLevel (&deviceExtension->OrbListSpinLock);

    } else  {

        //
        // Older request(s) still in progress, no timer associated with
        // this request
        //

        cancelledTimer = FALSE;

        KeReleaseSpinLockFromDpcLevel (&deviceExtension->OrbListSpinLock);
    }

#else

    //
    // ISSUE: The following is #if'd out for Windows XP because
    //        it's possible with MP machines & ordered execution
    //        devices for requests to complete in order, yet have
    //        completion notifications show up here out of order due
    //        to multiple DPCs firing. This can cause problems because
    //        by the time we get here on thread #1 thread #2 might
    //        have already completed this request (in the ordered exec
    //        handler below), and the request context object may have
    //        been reallocated for a new request, and it could get
    //        erroneously completed here. (There's currently no way
    //        to associate a request instance with a completion
    //        notification instance.)
    //
    //        This means that we might incur some timeouts if some
    //        vendor chooses to implement an ordered execution device
    //        which will actually complete a request & assume implicit
    //        completion of older requests.  At this time, Oxford Semi
    //        is the only vendor we know of that does ordered execution,
    //        and they guarantee one completion per request.
    //
    // NOTE:  !! When enabling this code make sure to uncomment other
    //        refs (above & below) to the "completedPrecedingOrbs", etc
    //        variables.
    //
    //        DanKn, 21-July-2001
    //

    //
    // If this is the oldest request in the queue then cancel the timer,
    // else check the ordered execution bit in the LUN (0x14) key to see
    // whether we need to complete preceding requests or not
    //

    completedPrecedingOrbs = 0;

    if ((PASYNC_REQUEST_CONTEXT) deviceExtension->PendingOrbList.Flink ==
            orbContext) {

        KeCancelTimer (&orbContext->Timer);
        CLEAR_FLAG (orbContext->Flags,ASYNC_CONTEXT_FLAG_TIMER_STARTED);
        cancelledTimer = TRUE;

        KeReleaseSpinLockFromDpcLevel (&deviceExtension->OrbListSpinLock);

    } else if (!(deviceExtension->DeviceInfo->Lun.QuadPart & 0x00400000)) {

        //
        // Unordered execution device, older request(s) still in progress,
        // no timer associated with this request
        //

        cancelledTimer = FALSE;

        KeReleaseSpinLockFromDpcLevel (&deviceExtension->OrbListSpinLock);

    } else  {

        //
        // Ordered execution device. Per section 4.6 of spec :
        // "A consequence of ordering is that completion status for one
        // task implicitly indicates successful completion status for
        // all tasks that preceded it in the ordered list."
        //

        //
        // Cancel the oldest request's timer if necessary
        //

        nextListItem = RETRIEVE_CONTEXT(
            deviceExtension->PendingOrbList.Flink,
            OrbList
            );

        if (nextListItem->Flags & ASYNC_CONTEXT_FLAG_TIMER_STARTED) {

            KeCancelTimer (&nextListItem->Timer);
            CLEAR_FLAG (nextListItem->Flags, ASYNC_CONTEXT_FLAG_TIMER_STARTED);
            cancelledTimer = TRUE;

            ASSERT (!(orbContext->Flags & ASYNC_CONTEXT_FLAG_COMPLETED));

        } else {

            cancelledTimer = FALSE;
        }

        //
        // Remove preceding, uncompleted entries from the
        // PendingOrbList and put them in a local list
        //

        InitializeListHead (&listHead);

        for(
            entry = deviceExtension->PendingOrbList.Flink;
            entry != (PLIST_ENTRY) &orbContext->OrbList;
            entry = nextEntry
            )
        {
            nextEntry = entry->Flink;

            nextListItem = RETRIEVE_CONTEXT (entry, OrbList);

            if (!(nextListItem->Flags & ASYNC_CONTEXT_FLAG_COMPLETED)) {

                RemoveEntryList (entry);

                InsertTailList (&listHead, entry);
            }
        }

        KeReleaseSpinLockFromDpcLevel (&deviceExtension->OrbListSpinLock);

        //
        // Now complete the entries in the local list
        //

        while (!IsListEmpty (&listHead)) {

            nextListItem = RETRIEVE_CONTEXT (listHead.Flink, OrbList);

            RemoveEntryList (listHead.Flink);

            nextListItem->Srb->SrbStatus = SRB_STATUS_SUCCESS;
            nextListItem->Srb->ScsiStatus = SCSISTAT_GOOD;

            Sbp2_SCSI_RBC_Conversion (nextListItem); // unwind RBC hacks

            irp = (PIRP) nextListItem->Srb->OriginalRequest;

            DEBUGPRINT2((
                "Sbp2Port: GlobalStatusCb: IMPLICIT COMPL arc=x%p\n",
                nextListItem
                ));

            DEBUGPRINT2((
                "Sbp2Port: GlobalStatusCb: ... irp=x%p, cdb=x%x\n",
                irp,
                nextListItem->Srb->Cdb[0]
                ));

            irp->IoStatus.Information = // ISSUE: only set this !=0 on reads?
                nextListItem->Srb->DataTransferLength;

            nextListItem->Srb = NULL;

            FreeAsyncRequestContext (deviceExtension, nextListItem);

            irp->IoStatus.Status = STATUS_SUCCESS;

            IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
            IoCompleteRequest (irp, IO_NO_INCREMENT);

            completedPrecedingOrbs++;
        }
    }

#endif

    //
    // Get sense data if length is larger than 1 (indicates error status).
    //
    // Annex B.2 of SBP2 spec : "When a command completes with GOOD status,
    // only the first two quadlets of the status block shall be stored at
    // the status_FIFO address; the len field shall be 1."
    //

    if (((statusBlock->AddressAndStatus.u.HighQuad.u.HighPart >> 8) & 0x07) > 1) {

        orbContext->Srb->SrbStatus = SRB_STATUS_ERROR;
        orbContext->Srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
        orbContext->Srb->SrbStatus &= ~SRB_STATUS_AUTOSENSE_VALID;

        if (orbContext->Srb->SenseInfoBuffer && !TEST_FLAG(orbContext->Srb->SrbFlags, SRB_FLAGS_DISABLE_AUTOSENSE)) {

            if (TEST_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_SPC_CMD_SET)) {

                if (ConvertSbp2SenseDataToScsi(statusBlock,
                                               orbContext->Srb->SenseInfoBuffer,
                                               orbContext->Srb->SenseInfoBufferLength) ){

                    orbContext->Srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
                }

                senseBuffer = (PUCHAR) orbContext->Srb->SenseInfoBuffer;

                if ((orbContext->Srb->Cdb[0] != SCSIOP_TEST_UNIT_READY) ||
                    (senseBuffer[2] != SCSI_SENSE_NOT_READY) ||
                    (senseBuffer[12] != SCSI_ADSENSE_NO_MEDIA_IN_DEVICE)) {

                    DEBUGPRINT2((
                        "Sbp2Port: GlobalStatusCb: ERROR, ext=x%p, cdb=x%x s/a/q=x%x/%x/%x\n",
                        deviceExtension,
                        orbContext->Srb->Cdb[0],
                        senseBuffer[2],
                        senseBuffer[12],
                        senseBuffer[13]
                        ));
                }

            } else {

                DEBUGPRINT2((
                    "Sbp2Port: GlobalStatusCb: ERROR, ext=x%p, cdb=x%x, cmd set NOT SCSI\n",\
                    deviceExtension,
                    orbContext->Srb->Cdb[0]
                    ));

                if (orbContext->Srb->SenseInfoBuffer) {

                    RtlCopyMemory(orbContext->Srb->SenseInfoBuffer,statusBlock,min(sizeof(STATUS_FIFO_BLOCK),orbContext->Srb->SenseInfoBufferLength));
                }
            }

        } else {

            DEBUGPRINT2(("Sbp2Port: GlobalStatusCb: ext=x%p, cdb=x%x, ERROR no sense buf\n",
                        deviceExtension,
                        orbContext->Srb->Cdb[0]));
        }

    } else if (((statusBlock->AddressAndStatus.u.HighQuad.u.HighPart & 0x3000) == 0x1000) ||
               ((statusBlock->AddressAndStatus.u.HighQuad.u.HighPart & 0x3000) == 0x2000)) {

        //
        // Per section 5.3 of SBP2 spec, values of 1 or 2 in the resp
        // field indicate TRANSPORT FAILURE and ILLEGAL REQUEST,
        // respectively.
        //
        // For now we'll continue to consider a resp value of 3
        // (VENDOR DEPENDENT) a success, like we did in Win2k & WinMe.
        //

        DEBUGPRINT2((
            "Sbp2Port: GlobalStatusCb: ERROR, ext=x%p, cdb=x%x, sts=x%x\n",\
            deviceExtension,
            orbContext->Srb->Cdb[0],
            statusBlock->AddressAndStatus.u.HighQuad.u.HighPart
            ));

        orbContext->Srb->SrbStatus = SRB_STATUS_ERROR;
        orbContext->Srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
        orbContext->Srb->SrbStatus &= ~SRB_STATUS_AUTOSENSE_VALID;

    } else {

        orbContext->Srb->SrbStatus = SRB_STATUS_SUCCESS;
        orbContext->Srb->ScsiStatus = SCSISTAT_GOOD;
    }

    Sbp2_SCSI_RBC_Conversion (orbContext); // unwind RBC hacks

    requestIrp->IoStatus.Information = // ISSUE: only set this !=0 on read ok?
        (orbContext->Srb->SrbStatus == SRB_STATUS_SUCCESS ?
        orbContext->Srb->DataTransferLength : 0);

    Free1394DataMapping (deviceExtension, orbContext);


    //
    // Pull the request out of the list & see if we need to set a timer
    //

    KeAcquireSpinLockAtDpcLevel (&deviceExtension->OrbListSpinLock);

    RemoveEntryList (&orbContext->OrbList);

    if (cancelledTimer) {

        //
        // Make the oldest, non-completed request track the timeout
        // (iff one exists)
        //

        for(
            entry = deviceExtension->PendingOrbList.Flink;
            entry != &deviceExtension->PendingOrbList;
            entry = entry->Flink
            )
        {
            nextListItem = RETRIEVE_CONTEXT (entry, OrbList);

            if (!(nextListItem->Flags & ASYNC_CONTEXT_FLAG_COMPLETED)) {

                deviceExtension->DueTime.QuadPart = ((LONGLONG) orbContext->Srb->TimeOutValue) * (-10*1000*1000);
                SET_FLAG(nextListItem->Flags, ASYNC_CONTEXT_FLAG_TIMER_STARTED);
                KeSetTimer(&nextListItem->Timer, deviceExtension->DueTime, &nextListItem->TimerDpc);
                break;
            }
        }
    }

    orbContext->Srb = NULL;

    //
    // Check if the target transitioned to the dead state because of a failed command
    // If it did, do a reset...
    //

#if 1

    initialOrbListDepth = deviceExtension->OrbListDepth;

#else

    // NOTE: use this path when enabling ordered execution code above

    initialOrbListDepth = deviceExtension->OrbListDepth +
        completedPrecedingOrbs;
#endif

    if (statusBlock->AddressAndStatus.u.HighQuad.u.HighPart & STATUS_BLOCK_DEAD_BIT_MASK) {

        //
        // reset the target fetch agent .
        //

        Sbp2AccessRegister (deviceExtension, &deviceExtension->Reserved, AGENT_RESET_REG | REG_WRITE_ASYNC);

        //
        // in order to wake up the agent we now need to write to ORB_POINTER with the head of lined list
        // of un-processed ORBS.
        //

        FreeAsyncRequestContext (deviceExtension, orbContext);

        if (deviceExtension->NextContextToFree) {

            FreeAsyncRequestContext(
                deviceExtension,
                deviceExtension->NextContextToFree
                );

            deviceExtension->NextContextToFree = NULL;
        }

        if (!IsListEmpty (&deviceExtension->PendingOrbList)) {

            //
            // signal target to restart processing at the head of the list
            //

            orbContext = RETRIEVE_CONTEXT(
                deviceExtension->PendingOrbList.Flink,
                OrbList
                );

            Sbp2AccessRegister(
                deviceExtension,
                &orbContext->CmdOrbAddress,
                ORB_POINTER_REG | REG_WRITE_ASYNC
                );
        }

    } else {

         if (statusBlock->AddressAndStatus.u.HighQuad.u.HighPart & STATUS_BLOCK_ENDOFLIST_BIT_MASK) {

             //
             // At the time this ORB was most recently fetched by the
             // target the next_ORB field was "null",
             //
             // so we can't free this context yet since the next ORB we
             // submit may have to "piggyback" on it (but we can free the
             // previous request, if any, that was in the same situation)
             //

             if (deviceExtension->NextContextToFree) {

                 FreeAsyncRequestContext(
                     deviceExtension,
                     deviceExtension->NextContextToFree
                     );
             }

             deviceExtension->NextContextToFree = orbContext;

             //
             // This was the end of list at the time the device completed
             // it, but it may not be end of list now (in which case we
             // don't want to append to it again).  Check to see if
             // the NextOrbAddress is "null" or not.
             //

             if (orbContext->CmdOrb->NextOrbAddress.OctletPart ==
                     0xFFFFFFFFFFFFFFFF) {

                 deviceExtension->AppendToNextContextToFree = TRUE;

             } else {

                 deviceExtension->AppendToNextContextToFree = FALSE;
             }

         } else {

             //
             // At the time this ORB was most recently fetched by the
             // target the next_ORB field was not "null",
             //
             // so we can safely free this context since target already
             // knows about the next ORB in the list
             //

             FreeAsyncRequestContext (deviceExtension, orbContext);
         }
    }

    currentOrbListDepth = deviceExtension->OrbListDepth;

    KeReleaseSpinLockFromDpcLevel (&deviceExtension->OrbListSpinLock);

    requestIrp->IoStatus.Status = status;

    IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
    IoCompleteRequest (requestIrp, IO_NO_INCREMENT);

    //
    // Only start another packet if the Ext.OrbListDepth was initially
    // maxed and we then freed at least one request context above.
    // In this case the last orb that was placed on the list was
    // not followed (in Sbp2InsertTailList) by a call to StartNextPacket,
    // so we have to do that here to restart the queue.
    //

    if ((initialOrbListDepth == deviceExtension->MaxOrbListDepth) &&
        (initialOrbListDepth > currentOrbListDepth)) {

        Sbp2StartNextPacketByKey(
            deviceObject,
            deviceExtension->CurrentKey
            );
    }


    DEBUGPRINT3(("Sbp2Port: GlobalStatusCb: leaving callback, depth=%d\n",deviceExtension->OrbListDepth));
    rcode = RCODE_RESPONSE_COMPLETE;

exitGlobalCallback:

    //
    // return the status fifo back to the list
    //

    ExInterlockedPushEntrySList(&deviceExtension->StatusFifoListHead,
                                &NotificationInfo->Fifo->FifoList,
                                &deviceExtension->StatusFifoLock);


    return (ULONG) rcode;
}


RCODE
Sbp2ManagementOrbStatusCallback(
    IN PNOTIFICATION_INFO NotificationInfo
    )
/*++

Routine Description:

    Callback routine for writes to our Task Status Block. the 1394 driver will call this routine, after
    the target has updated the status in our memory. A Task function is usually a recovery attempt.

Arguments:

    (Check 1394Bus.doc)

Return Value:

    0

--*/
{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    PADDRESS_CONTEXT context = (PADDRESS_CONTEXT) NotificationInfo->Context;
    NTSTATUS status;


    if (NotificationInfo->Context != NULL ) {

        deviceObject = ((PADDRESS_CONTEXT)NotificationInfo->Context)->DeviceObject;
        deviceExtension = deviceObject->DeviceExtension;

    } else {

        return RCODE_RESPONSE_COMPLETE;
    }

    if (TEST_FLAG(NotificationInfo->fulNotificationOptions, NOTIFY_FLAGS_AFTER_READ)){

        //
        // This shouldn't happen since we set our flags to NOTIFY_AFTER_WRITE
        //

        return RCODE_TYPE_ERROR;
    }

    octbswap(deviceExtension->ManagementOrbStatusBlock.AddressAndStatus);
    deviceExtension->ManagementOrb->OrbInfo.QuadPart =
        bswap(deviceExtension->ManagementOrb->OrbInfo.QuadPart);

    status = CheckStatusResponseValue(&deviceExtension->ManagementOrbStatusBlock);

    switch (deviceExtension->ManagementOrb->OrbInfo.u.HighPart & 0x00FF) {

    case TRANSACTION_RECONNECT:

        //
        // If there was a pending reset, cancel it
        //

        KeAcquireSpinLockAtDpcLevel(&deviceExtension->ExtensionDataSpinLock);

        if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_RECONNECT)) {

            DEBUGPRINT1((
                "Sbp2Port: MgmtOrbStatusCb: RECONNECT, sts=x%x, ext=x%p, fl=x%x\n",
                status,
                deviceExtension,
                deviceExtension->DeviceFlags
                ));

            KeCancelTimer(&deviceExtension->DeviceManagementTimer);

            if (NT_SUCCESS(status)) {

                CLEAR_FLAG(deviceExtension->DeviceFlags,(DEVICE_FLAG_RESET_IN_PROGRESS | DEVICE_FLAG_DEVICE_FAILED | DEVICE_FLAG_RECONNECT | DEVICE_FLAG_STOPPED));

                KeReleaseSpinLockFromDpcLevel(&deviceExtension->ExtensionDataSpinLock);

                KeAcquireSpinLockAtDpcLevel(&deviceExtension->OrbListSpinLock);

                if (TEST_FLAG(
                        deviceExtension->DeviceFlags,
                        DEVICE_FLAG_QUEUE_LOCKED
                        ) &&

                        (deviceExtension->DeferredPowerRequest != NULL)
                        ) {

                    //
                    // A START_STOP_UNIT was caught in the middle of a bus
                    // reset and was deferred until after we reconnected.
                    // Complete here so the class driver never knew anything
                    // happened..
                    //

                    PIRP pIrp = deviceExtension->DeferredPowerRequest;


                    deviceExtension->DeferredPowerRequest = NULL;

                    KeReleaseSpinLockFromDpcLevel(
                        &deviceExtension->OrbListSpinLock
                        );

                    Sbp2StartIo (deviceObject, pIrp);

                } else {

                    KeReleaseSpinLockFromDpcLevel(
                        &deviceExtension->OrbListSpinLock
                        );

                    Sbp2StartNextPacketByKey(
                        deviceExtension->DeviceObject,
                        deviceExtension->CurrentKey
                        );
                }

                KeSetEvent(deviceExtension->ManagementOrbContext.Reserved,IO_NO_INCREMENT,FALSE);

            } else {

                //
                // probably too late, we need to a re-login
                //

                CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_RECONNECT);
                SET_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_LOGIN_IN_PROGRESS);

                KeCancelTimer(&deviceExtension->DeviceManagementTimer);

                KeReleaseSpinLockFromDpcLevel(&deviceExtension->ExtensionDataSpinLock);

                Sbp2UpdateNodeInformation(deviceExtension);

                //
                // see if can access the device
                //

                DEBUGPRINT1((
                    "Sbp2Port: MgmtOrbStatusCb: ...(RECONNECT err) " \
                        "trying re-login\n"
                    ));

                Sbp2ManagementTransaction(deviceExtension, TRANSACTION_LOGIN);
            }

        } else {

            KeReleaseSpinLockFromDpcLevel(&deviceExtension->ExtensionDataSpinLock);
        }

        break;

    case TRANSACTION_QUERY_LOGINS:

        //
        // set the management event, indicating that the request was processed
        //

        DEBUGPRINT1((
            "Sbp2Port: MgmtOrbStatusCb: QUERY_LOGIN, sts=x%x, ext=x%p, fl=x%x\n",
            status,
            deviceExtension,
            deviceExtension->DeviceFlags
            ));

        if (NT_SUCCESS(status)) {

            //
            // check if there somebody logged in..
            //

            deviceExtension->QueryLoginResponse->LengthAndNumLogins.QuadPart =
                bswap(deviceExtension->QueryLoginResponse->LengthAndNumLogins.QuadPart);

            if ((deviceExtension->QueryLoginResponse->LengthAndNumLogins.u.LowPart == 1) &&
                (deviceExtension->QueryLoginResponse->LengthAndNumLogins.u.HighPart > 4)){

                //
                // exclusive login so we have to worry about it...
                //

                deviceExtension->QueryLoginResponse->Elements[0].NodeAndLoginId.QuadPart =
                    bswap(deviceExtension->QueryLoginResponse->Elements[0].NodeAndLoginId.QuadPart);

                //
                // Assume the only initiator logged in is the bios...
                // Log out the bios using it login ID...
                //

                deviceExtension->LoginResponse->LengthAndLoginId.u.LowPart =
                deviceExtension->QueryLoginResponse->Elements[0].NodeAndLoginId.u.LowPart;

                //
                // Dont set the vent, so we stall and the BIOS is implicitly logged out
                // since it cant reconnect..
                //

                DEBUGPRINT1(("\nSbp2Port: MgmtOrbStatusCb: somebody else logged in, stalling so it gets logged out\n"));
            }

        } else {

            KeSetEvent(deviceExtension->ManagementOrbContext.Reserved,IO_NO_INCREMENT,FALSE);
        }

        break;

    case TRANSACTION_LOGIN:

        //
        // Per the Sbp2 spec we'd normally expect all login notifications
        // to show up at Sbp2GlobalStatusCallback.  In practice, however,
        // we see completion notifications showing up here when an
        // async login is submitted after a failed reconnect.
        //

        Sbp2LoginCompletion (NotificationInfo, status);

        DEBUGPRINT1((
            "Sbp2Port: MgmtOrbStatusCb: ...wrong place for login completions!\n"
            ));

        break;

    default:

        DEBUGPRINT1((
            "Sbp2Port: MgmtOrbStatusCb: type=%d, sts=x%x, ext=x%p, fl=x%x\n",
            deviceExtension->ManagementOrb->OrbInfo.u.HighPart & 0x00FF,
            status,
            deviceExtension,
            deviceExtension->DeviceFlags
            ));

        KeSetEvent(deviceExtension->ManagementOrbContext.Reserved,IO_NO_INCREMENT,FALSE);

        break;
    }

    return RCODE_RESPONSE_COMPLETE;
}


#if PASSWORD_SUPPORT

RCODE
Sbp2SetPasswordOrbStatusCallback(
    IN PNOTIFICATION_INFO   NotificationInfo
    )
{
    RCODE               returnCode = RCODE_RESPONSE_COMPLETE;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   deviceExtension;
    PADDRESS_CONTEXT    context = (PADDRESS_CONTEXT) NotificationInfo->Context;
    NTSTATUS            status;


    if (NotificationInfo->Context != NULL ) {

        deviceObject = ((PADDRESS_CONTEXT)NotificationInfo->Context)->
            DeviceObject;

        deviceExtension = deviceObject->DeviceExtension;

    } else {

        return RCODE_RESPONSE_COMPLETE;
    }

    if (TEST_FLAG(
            NotificationInfo->fulNotificationOptions,
            NOTIFY_FLAGS_AFTER_READ
            )){

        //
        // This shouldn't happen since we set our flags to NOTIFY_AFTER_WRITE
        //

        returnCode = RCODE_TYPE_ERROR;
        goto Exit_Sbp2SetPasswordOrbStatusCallback;
    }

    octbswap(deviceExtension->PasswordOrbStatusBlock.AddressAndStatus);
    deviceExtension->PasswordOrb->OrbInfo.QuadPart =
        bswap(deviceExtension->PasswordOrb->OrbInfo.QuadPart);

    status = CheckStatusResponseValue(
        &deviceExtension->PasswordOrbStatusBlock
        );

    if ((deviceExtension->PasswordOrb->OrbInfo.u.HighPart & 0x00FF) ==
            TRANSACTION_SET_PASSWORD) {

        DEBUGPRINT1(("Sbp2Port: TRANSACTION_SET_PASSWORD Callback\n"));

        DEBUGPRINT1((
            "Sbp2Port: PasswdOrbStatusCb: type=%d, sts=x%x, ext=x%p, fl=x%x\n",
            deviceExtension->PasswordOrb->OrbInfo.u.HighPart & 0x00FF,
            status,
            deviceExtension,
            deviceExtension->DeviceFlags
            ));
    }
    else {

        DEBUGPRINT1(("Sbp2Port: PasswdOrbStatusCb: Wrong xact type=x%x\n",
            (deviceExtension->PasswordOrb->OrbInfo.u.HighPart & 0x00FF)));
    }

Exit_Sbp2SetPasswordOrbStatusCallback:

    KeSetEvent(
        deviceExtension->PasswordOrbContext.Reserved,
        IO_NO_INCREMENT,
        FALSE
        );

    return returnCode;
}

#endif

VOID
Sbp2LoginCompletion(
    PNOTIFICATION_INFO  NotificationInfo,
    NTSTATUS            Status
    )
{
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   deviceExtension;


    if (NotificationInfo->Context != NULL ) {

        deviceObject = ((PADDRESS_CONTEXT) NotificationInfo->Context)->
            DeviceObject;

        deviceExtension = deviceObject->DeviceExtension;

    } else {

        return;
    }

    KeCancelTimer (&deviceExtension->DeviceManagementTimer);

    KeAcquireSpinLockAtDpcLevel (&deviceExtension->ExtensionDataSpinLock);

    if (TEST_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_LOGIN_IN_PROGRESS)){

        if (Status != STATUS_SUCCESS) {

            //
            // Login failed... We can't to much else.
            //

            CLEAR_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_RECONNECT | DEVICE_FLAG_LOGIN_IN_PROGRESS)
                );

            SET_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_STOPPED | DEVICE_FLAG_DEVICE_FAILED)
                );

            deviceExtension->LastTransactionStatus = Status;

            KeReleaseSpinLockFromDpcLevel(
                &deviceExtension->ExtensionDataSpinLock
                );

            DEBUGPRINT1((
                "Sbp2Port: LoginCompl: sts=x%x, ext=x%p, fl=x%x\n",
                Status,
                deviceExtension,
                deviceExtension->DeviceFlags
                ));

            deviceExtension->LoginResponse->Csr_Off_Low.QuadPart = 0;

            if (!TEST_FLAG(
                    deviceExtension->DeviceFlags,
                    DEVICE_FLAG_RESET_IN_PROGRESS
                      )) {

                KeSetEvent(
                    deviceExtension->ManagementOrbContext.Reserved,
                    IO_NO_INCREMENT,
                    FALSE
                    );

            } else {

                if (deviceExtension->DeferredPowerRequest) {

                    PIRP    irp = deviceExtension->DeferredPowerRequest;

                    deviceExtension->DeferredPowerRequest = NULL;

                    Sbp2StartIo (deviceObject, irp);

                } else {

                    Sbp2StartNextPacketByKey(
                        deviceObject,
                        deviceExtension->CurrentKey
                        );
                }

                IoInvalidateDeviceState (deviceObject);
            }

            return;
        }

        //
        // Succesful login, read the response buffer (it has our login ID)
        //


        DEBUGPRINT2((
            "Sbp2Port: LoginCompl: success, ext=x%p, fl=x%x\n",
            deviceExtension,
            deviceExtension->DeviceFlags
            ));

        deviceExtension->LastTransactionStatus = Status;

        deviceExtension->LoginResponse->LengthAndLoginId.QuadPart =
            bswap(deviceExtension->LoginResponse->LengthAndLoginId.QuadPart);

        deviceExtension->LoginResponse->Csr_Off_High.QuadPart =
            bswap(deviceExtension->LoginResponse->Csr_Off_High.QuadPart);

        deviceExtension->LoginResponse->Csr_Off_Low.QuadPart =
            bswap(deviceExtension->LoginResponse->Csr_Off_Low.QuadPart);

        //
        // Store the register base for target fetch agents
        //

        deviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_High =
            deviceExtension->LoginResponse->Csr_Off_High.u.LowPart;

        deviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_Low =
            deviceExtension->LoginResponse->Csr_Off_Low.QuadPart;

        //
        // this callback fired becuase the asynchronous login succeeded
        // clear our device flags to indicate the device is operating fine
        //

        CLEAR_FLAG(
            deviceExtension->DeviceFlags,
            (DEVICE_FLAG_LOGIN_IN_PROGRESS | DEVICE_FLAG_STOPPED |
                DEVICE_FLAG_REMOVED | DEVICE_FLAG_DEVICE_FAILED)
            );

        if (!TEST_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_RESET_IN_PROGRESS
                )) {

            KeReleaseSpinLockFromDpcLevel(
                &deviceExtension->ExtensionDataSpinLock
                );

            KeSetEvent(
                deviceExtension->ManagementOrbContext.Reserved,
                IO_NO_INCREMENT,
                FALSE
                );

        } else {

            CLEAR_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_RESET_IN_PROGRESS
                );

            KeReleaseSpinLockFromDpcLevel(
                &deviceExtension->ExtensionDataSpinLock
                );

            if (TEST_FLAG(
                    deviceExtension->DeviceFlags,
                    DEVICE_FLAG_QUEUE_LOCKED
                      )) {

                KeAcquireSpinLockAtDpcLevel(&deviceExtension->OrbListSpinLock);

                if (deviceExtension->DeferredPowerRequest) {

                    //
                    // A request was caught in the middle of a bus reset
                    // and was deferred until after we reconnected.
                    // Complete here so the class driver never knew anything
                    // happened.
                    //

                    PIRP pIrp = deviceExtension->DeferredPowerRequest;

                    deviceExtension->DeferredPowerRequest = NULL;

                    KeReleaseSpinLockFromDpcLevel(
                        &deviceExtension->OrbListSpinLock
                        );

                    Sbp2StartIo (deviceObject, pIrp);

                } else {

                    KeReleaseSpinLockFromDpcLevel(
                        &deviceExtension->OrbListSpinLock
                        );

                    Sbp2StartNextPacketByKey(
                        deviceObject,
                        deviceExtension->CurrentKey
                        );
                }

            } else {

                Sbp2StartNextPacketByKey(
                    deviceObject,
                    deviceExtension->CurrentKey
                    );
            }
        }

        //
        // make retry limit high for busy transactions
        //

        deviceExtension->Reserved = BUSY_TIMEOUT_SETTING;

        Sbp2AccessRegister(
            deviceExtension,
            &deviceExtension->Reserved,
            CORE_BUSY_TIMEOUT_REG | REG_WRITE_ASYNC
            );

    } else {

        KeReleaseSpinLockFromDpcLevel(
            &deviceExtension->ExtensionDataSpinLock
            );
    }
}


RCODE
Sbp2TaskOrbStatusCallback(
    IN PNOTIFICATION_INFO NotificationInfo
    )
/*++

Routine Description:

    Callback routine for writes to our Task Status Block. the 1394 driver will call this routine, after
    the target has updated the status in our memory. A Task function is an ABORT_TASK_SET or TARGET_RESET,
    for this implementation

Arguments:

    NotificationInfo - bus supplied context for this notification

Return Value:

    0

--*/
{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    PADDRESS_CONTEXT context = (PADDRESS_CONTEXT) NotificationInfo->Context;
    NTSTATUS status;


    if (NotificationInfo->Context != NULL ) {

        deviceObject = ((PADDRESS_CONTEXT)NotificationInfo->Context)->DeviceObject;
        deviceExtension = deviceObject->DeviceExtension;

    } else {
        return RCODE_RESPONSE_COMPLETE;
    }

    if (TEST_FLAG(NotificationInfo->fulNotificationOptions, NOTIFY_FLAGS_AFTER_READ)){

        //
        // This shouldn't happen since we set our flags to NOTIFY_AFTER_WRITE
        //

        return RCODE_TYPE_ERROR;

    } else if (NotificationInfo->fulNotificationOptions & NOTIFY_FLAGS_AFTER_WRITE){

        //
        // now cleanup our lists, if the abort task set completed succesfully ( if not rejected)
        //

        if (!TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_RESET_IN_PROGRESS)) {

            DEBUGPRINT1(("Sbp2Port: TaskOrbStatusCb: bogus call, rejected\n"));
            return (ULONG)RCODE_RESPONSE_COMPLETE;
        }

        KeCancelTimer(&deviceExtension->DeviceManagementTimer);

        octbswap(deviceExtension->TaskOrbStatusBlock.AddressAndStatus);
        status = CheckStatusResponseValue(&deviceExtension->TaskOrbStatusBlock);

        if (status!=STATUS_SUCCESS) {

            if (deviceExtension->TaskOrbContext.TransactionType != TRANSACTION_TARGET_RESET) {

                DEBUGPRINT1(("Sbp2Port: TaskOrbStatusCb: ABORT TASK SET func err\n"));

            } else {

                //
                // a target reset didn't complete succesfully. Fatal error...
                //

                DEBUGPRINT1(("Sbp2Port: TaskOrbStatusCb: Target RESET err, try CMD_RESET & relogin\n"));

                Sbp2CreateRequestErrorLog(deviceExtension->DeviceObject,NULL,STATUS_DEVICE_OFF_LINE);
                deviceExtension->Reserved = 0;
                Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,CORE_RESET_REG | REG_WRITE_ASYNC);

                KeAcquireSpinLockAtDpcLevel(&deviceExtension->ExtensionDataSpinLock);
                SET_FLAG(deviceExtension->DeviceFlags,(DEVICE_FLAG_RECONNECT | DEVICE_FLAG_STOPPED));
                KeReleaseSpinLockFromDpcLevel(&deviceExtension->ExtensionDataSpinLock);

                deviceExtension->DueTime.HighPart = -1;
                deviceExtension->DueTime.LowPart = SBP2_RELOGIN_DELAY;
                KeSetTimer(&deviceExtension->DeviceManagementTimer,deviceExtension->DueTime, &deviceExtension->DeviceManagementTimeoutDpc);

                return (ULONG) RCODE_RESPONSE_COMPLETE;
            }
        }

        deviceExtension->Reserved = BUSY_TIMEOUT_SETTING;
        Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,CORE_BUSY_TIMEOUT_REG | REG_WRITE_ASYNC);

        //
        // reset the fetch agent
        //

        Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,AGENT_RESET_REG | REG_WRITE_ASYNC);

        DEBUGPRINT2(("Sbp2Port: TaskOrbStatusCb: TASK func succes\n"));

        KeAcquireSpinLockAtDpcLevel(&deviceExtension->ExtensionDataSpinLock);

        CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_RESET_IN_PROGRESS);

        if (deviceExtension->TaskOrbContext.TransactionType == TRANSACTION_TARGET_RESET) {

            CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_STOPPED);
        }

        //
        // decrease number of possible outstanding requests.
        //

        deviceExtension->MaxOrbListDepth = max(MIN_ORB_LIST_DEPTH,deviceExtension->MaxOrbListDepth/2);

        KeReleaseSpinLockFromDpcLevel(&deviceExtension->ExtensionDataSpinLock);

        CleanupOrbList(deviceExtension,STATUS_REQUEST_ABORTED);

        Sbp2StartNextPacketByKey (deviceExtension->DeviceObject, 0);
    }

    return (ULONG) RCODE_RESPONSE_COMPLETE;
}


VOID
Sbp2HandleUnsolicited(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSTATUS_FIFO_BLOCK StatusFifo
    )
/*++

Routine Description:

    Inteprets the unsolicited status recieved and takes action if necessery
    If the unsolicted requets called for power transition, request a power irp
    ..

Arguments:

    DeviceExtension - Pointer to device extension.

    StatusFifo - fifo send by the device

Return Value:



--*/
{
    UCHAR senseBuffer[SENSE_BUFFER_SIZE];
    POWER_STATE state;
    NTSTATUS status;


    if (TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_SPC_CMD_SET)) {

        switch (DeviceExtension->DeviceInfo->Lun.u.HighPart & 0x001F) {

        case RBC_DEVICE:

            //
            // use RBC spec for intepreting status contents
            // the sense keys tells us what type of status this was
            //

            if (ConvertSbp2SenseDataToScsi(StatusFifo, senseBuffer,sizeof(senseBuffer))) {

                if ((senseBuffer[2] == 0x06) && (senseBuffer[12] == 0x7F)) {

                    switch (senseBuffer[13]) {

                    case RBC_UNSOLICITED_CLASS_ASQ_DEVICE:
                    case RBC_UNSOLICITED_CLASS_ASQ_MEDIA:

                        break;

                    case RBC_UNSOLICITED_CLASS_ASQ_POWER:

                        //
                        // initiate power transtion, per device request
                        //

                        state.DeviceState = PowerDeviceD0;
                        DEBUGPRINT1(("Sbp2Port: HandleUnsolicited: send D irp state=x%x\n ",state));

                        status = PoRequestPowerIrp(
                                     DeviceExtension->DeviceObject,
                                     IRP_MN_SET_POWER,
                                     state,
                                     NULL,
                                     NULL,
                                     NULL);

                        if (!NT_SUCCESS(status)) {

                            //
                            // not good, we cant power up the device..
                            //

                            DEBUGPRINT1(("Sbp2Port: HandleUnsolicited: D irp err=x%x\n ",status));
                        }

                        break;
                    }
                }
            }

            break;
        }
    }
}


NTSTATUS
Sbp2GetControllerInfo(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Find the maximum packet size that can be sent across. If there is
    any error, return the minimum size.

Arguments:

    DeviceExtension - Pointer to device extension.

    IrP - Pointer to Irp. If this is NULL, we have to allocate our own.

    Irb - Pointer to Irb. If this is NULL, we have to allocate our own.

Return Value:

    NTSTATUS

--*/

{
    PIRBIRP                 packet = NULL;
    NTSTATUS                status;
    GET_LOCAL_HOST_INFO7    getLocalHostInfo7;


    AllocateIrpAndIrb (DeviceExtension, &packet);

    if (!packet) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get the max speed between devices so that we can calculate the
    // maximum number of bytes we can send
    //

    packet->Irb->FunctionNumber = REQUEST_GET_SPEED_BETWEEN_DEVICES;
    packet->Irb->Flags = 0;
    packet->Irb->u.GetMaxSpeedBetweenDevices.ulNumberOfDestinations = 0;
    packet->Irb->u.GetMaxSpeedBetweenDevices.fulFlags = USE_LOCAL_NODE;

    status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

    if (!NT_SUCCESS (status)) {

        goto exitFindHostInfo;
    }

    //
    // Calculate the max block size based on the speed
    //

    DeviceExtension->MaxControllerPhySpeed = packet->Irb->u.GetMaxSpeedBetweenDevices.fulSpeed >> 1;

    switch (DeviceExtension->MaxControllerPhySpeed) {

    case SCODE_100_RATE:

        DeviceExtension->OrbWritePayloadMask = (0x00F0 & 0x0070);
        DeviceExtension->OrbReadPayloadMask = (0x00F0 & 0x0070);
        break;

    case SCODE_200_RATE:

        DeviceExtension->OrbWritePayloadMask = (0x00F0 & 0x0080);
        DeviceExtension->OrbReadPayloadMask = (0x00F0 & 0x0080);
        break;

    case SCODE_400_RATE:

        DeviceExtension->OrbWritePayloadMask = (0x00F0 & 0x0090);
        DeviceExtension->OrbReadPayloadMask = (0x00F0 & 0x0090);
        break;
    }

    //
    // find what the host adaptor below us supports...
    // it might support less than the payload for this phy speed
    //

    packet->Irb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
    packet->Irb->Flags = 0;
    packet->Irb->u.GetLocalHostInformation.nLevel = GET_HOST_CAPABILITIES;
    packet->Irb->u.GetLocalHostInformation.Information = &DeviceExtension->HostControllerInformation;

    status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

    if (!NT_SUCCESS(status)) {

        goto exitFindHostInfo;
    }

    switch (DeviceExtension->HostControllerInformation.MaxAsyncWriteRequest) {

    case ASYNC_PAYLOAD_100_RATE:

        DeviceExtension->OrbWritePayloadMask = min((0x00F0 & 0x0070),DeviceExtension->OrbWritePayloadMask);
        break;

    case ASYNC_PAYLOAD_200_RATE:

        DeviceExtension->OrbWritePayloadMask = min((0x00F0 & 0x0080),DeviceExtension->OrbWritePayloadMask);
        break;
    }

    switch (DeviceExtension->HostControllerInformation.MaxAsyncReadRequest) {

    case ASYNC_PAYLOAD_100_RATE:

        DeviceExtension->OrbReadPayloadMask = min((0x00F0 & 0x0070),DeviceExtension->OrbReadPayloadMask);
        break;

    case ASYNC_PAYLOAD_200_RATE:

        DeviceExtension->OrbReadPayloadMask = min((0x00F0 & 0x0080),DeviceExtension->OrbReadPayloadMask);
        break;
    }

    //
    // Get the direct mapping routine from the host adaptor(if it support this)
    // status is not important in this case sinc this is an optional capability
    //

    packet->Irb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
    packet->Irb->Flags = 0;
    packet->Irb->u.GetLocalHostInformation.nLevel = GET_PHYS_ADDR_ROUTINE;
    packet->Irb->u.GetLocalHostInformation.Information = &DeviceExtension->HostRoutineAPI;

    status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

    if (!NT_SUCCESS(status)) {

        //
        // the host controller under us is no supported..
        //

        DEBUGPRINT1(("Sbp2Port: GetCtlrInfo: failed to get phys map rout, fatal\n"));
        goto exitFindHostInfo;
    }

    //
    // find what the host adaptor below us supports...
    // it might support less than the payload for this phy speed
    //

    packet->Irb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
    packet->Irb->Flags = 0;
    packet->Irb->u.GetLocalHostInformation.nLevel = GET_HOST_DMA_CAPABILITIES;
    packet->Irb->u.GetLocalHostInformation.Information = &getLocalHostInfo7;

    status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1(("Sbp2Port: GetCtlrInfo: err getting DMA info, def MaxXfer = 64k\n"));
        DeviceExtension->DeviceInfo->MaxClassTransferSize = SBP2_MAX_DIRECT_BUFFER_SIZE+1;
        status = STATUS_SUCCESS;

    } else {

        DeviceExtension->DeviceInfo->MaxClassTransferSize = (ULONG) min(DeviceExtension->DeviceInfo->MaxClassTransferSize,\
                                                             min(getLocalHostInfo7.MaxDmaBufferSize.QuadPart,\
                                                                SBP2_MAX_TRANSFER_SIZE));

        DEBUGPRINT2(("Sbp2Port: GetCtlrInfo: ctlr maxDma=x%x%08x, maxXfer=x%x\n",
                    getLocalHostInfo7.MaxDmaBufferSize.HighPart,
                    getLocalHostInfo7.MaxDmaBufferSize.LowPart,
                    DeviceExtension->DeviceInfo->MaxClassTransferSize));
    }

exitFindHostInfo:

    DeAllocateIrpAndIrb(DeviceExtension,packet);

    return status;
}


NTSTATUS
Sbp2AccessRegister(
    PDEVICE_EXTENSION DeviceExtension,
    PVOID Data,
    USHORT RegisterAndDirection
    )
/*++

Routine Description:

    Knows the how to access SBP2 and 1394 specific target registers. It wills send requests
    of the appropriate size and of the supported type (READ or WRITE) for the specific register

Arguments:

    DeviceExtension - Pointer to device extension.

    Data - Calue to write to the register

    RegisterAndDirection - BitMask that indicates which register to write and if its a WRITE or a READ

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;

    PIRBIRP packet = NULL;


    if (TEST_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_REMOVED)) {

        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    AllocateIrpAndIrb(DeviceExtension,&packet);

    if (!packet) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // update SBP specific registers at the node
    // We better have all the addressing info before this function is called
    //

    packet->Irb->Flags = 0;

    //
    // check which register we need to whack
    //

    switch (RegisterAndDirection & REG_TYPE_MASK) {

    //
    // write only quadlet sized registers
    //
    case TEST_REG:
    case CORE_BUSY_TIMEOUT_REG:
    case CORE_RESET_REG:
    case UNSOLICITED_STATUS_REG:
    case DOORBELL_REG:
    case AGENT_RESET_REG:

        packet->Irb->FunctionNumber = REQUEST_ASYNC_WRITE;
        packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High =
                        INITIAL_REGISTER_SPACE_HI;

        packet->Irb->u.AsyncWrite.fulFlags = 0;

        switch(RegisterAndDirection & REG_TYPE_MASK) {

        case TEST_REG:

            packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low = INITIAL_REGISTER_SPACE_LO
                                                                                 | TEST_REG_OFFSET;

            *((PULONG)Data) = bswap(*((PULONG)Data));

            break;

        case CORE_BUSY_TIMEOUT_REG:

            packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low = INITIAL_REGISTER_SPACE_LO
                                                                                 | 0x00000210;

            *((PULONG)Data) = bswap(*((PULONG)Data));

            break;

        case CORE_RESET_REG:

            packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low = INITIAL_REGISTER_SPACE_LO
                                                                                 | 0x0000000C;
            break;

        case DOORBELL_REG:

            //
            // we dont care if this suceeds or not, and also we dont want to take an INT hit when this is send
            //

            packet->Irb->u.AsyncWrite.fulFlags |= ASYNC_FLAGS_NO_STATUS;
            packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =
            (DeviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_Low + DOORBELL_REG_OFFSET) | INITIAL_REGISTER_SPACE_LO;
            break;

        case AGENT_RESET_REG:

            packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =
            (DeviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_Low + AGENT_RESET_REG_OFFSET) | INITIAL_REGISTER_SPACE_LO;
            break;

        case UNSOLICITED_STATUS_REG:

            packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =
            (DeviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_Low + UNSOLICITED_STATUS_REG_OFFSET) | INITIAL_REGISTER_SPACE_LO;
            break;
        }

        //
        // for all of the above writes, where the data is not signigficant(ping)
        // we have reserved an mdl so we dont have to allocate each time
        //

        packet->Irb->u.AsyncWrite.Mdl = DeviceExtension->ReservedMdl;

        packet->Irb->u.AsyncWrite.nNumberOfBytesToWrite = sizeof(QUADLET);
        packet->Irb->u.AsyncWrite.nBlockSize = 0;
        packet->Irb->u.AsyncWrite.ulGeneration = DeviceExtension->CurrentGeneration;
        break;

    case MANAGEMENT_AGENT_REG:
    case ORB_POINTER_REG:

        if ((RegisterAndDirection & REG_WRITE_SYNC) || (RegisterAndDirection & REG_WRITE_ASYNC) ){

            //
            // Swap the stuff we want ot write to the register.
            // the caller always passes the octlet in little endian
            //

            packet->Octlet = *(POCTLET)Data;
            octbswap(packet->Octlet);

            packet->Irb->FunctionNumber = REQUEST_ASYNC_WRITE;
            packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High =
                          INITIAL_REGISTER_SPACE_HI;

            if (RegisterAndDirection & ORB_POINTER_REG) {

                packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =
                (DeviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_Low + ORB_POINTER_REG_OFFSET) | INITIAL_REGISTER_SPACE_LO;

            } else {

                packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =
                 DeviceExtension->DeviceInfo->ManagementAgentBaseReg.BusAddress.Off_Low | INITIAL_REGISTER_SPACE_LO;
            }

            packet->Irb->u.AsyncWrite.Mdl = IoAllocateMdl(&packet->Octlet, sizeof(OCTLET),FALSE,FALSE,NULL);

            if (!packet->Irb->u.AsyncWrite.Mdl) {

                DeAllocateIrpAndIrb(DeviceExtension,packet);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            packet->Irb->u.AsyncWrite.nNumberOfBytesToWrite = sizeof(OCTLET);
            packet->Irb->u.AsyncWrite.nBlockSize = 0;
            packet->Irb->u.AsyncWrite.fulFlags = 0;
            packet->Irb->u.AsyncWrite.ulGeneration = DeviceExtension->CurrentGeneration;
            MmBuildMdlForNonPagedPool(packet->Irb->u.AsyncWrite.Mdl);

        } else {

            packet->Irb->FunctionNumber = REQUEST_ASYNC_READ;

            if (RegisterAndDirection & ORB_POINTER_REG) {

                packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low =
                (DeviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_Low + ORB_POINTER_REG_OFFSET);

            } else {

                packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low =
                            DeviceExtension->DeviceInfo->ManagementAgentBaseReg.BusAddress.Off_Low;
            }

            packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High =
                            DeviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_High;

            packet->Irb->u.AsyncRead.Mdl = IoAllocateMdl(Data, sizeof(OCTLET),FALSE,FALSE,NULL);

            if (!packet->Irb->u.AsyncRead.Mdl) {

                DeAllocateIrpAndIrb(DeviceExtension,packet);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            packet->Irb->u.AsyncRead.nNumberOfBytesToRead = sizeof(OCTLET);
            packet->Irb->u.AsyncRead.nBlockSize = 0;
            packet->Irb->u.AsyncRead.fulFlags = 0;
            packet->Irb->u.AsyncRead.ulGeneration = DeviceExtension->CurrentGeneration;
            MmBuildMdlForNonPagedPool(packet->Irb->u.AsyncRead.Mdl);
        }

        break;
    }

    if (RegisterAndDirection & REG_WRITE_ASYNC) {

        status = Sbp2SendRequest (DeviceExtension, packet, ASYNC_1394_REQUEST);

    } else {

        status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

        if (NT_SUCCESS(status)) {

            if (RegisterAndDirection & REG_READ_SYNC) {

                //
                // convert from big -> little endian for read data
                //

                switch (RegisterAndDirection & REG_TYPE_MASK) {

                case ORB_POINTER_REG:
                case MANAGEMENT_AGENT_REG:

                    packet->Octlet = *((POCTLET)Data);
                    octbswap(packet->Octlet);
                    *((POCTLET)Data) = packet->Octlet;
                    break;
                }
            }
        }

        if (packet->Irb->u.AsyncWrite.nNumberOfBytesToWrite == sizeof(OCTLET)) {

            IoFreeMdl(packet->Irb->u.AsyncRead.Mdl);
        }

        DeAllocateIrpAndIrb(DeviceExtension,packet);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\control.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    control.c

Abstract:

    This module contains support routines for the port driver to access 
    the miniport's HwAdapterControl functionality.

Authors:

    Peter Wieland

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "port.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpGetSupportedAdapterControlFunctions)
#endif

VOID
SpGetSupportedAdapterControlFunctions(
    PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine will query the miniport to determine which adapter control 
    types are supported for the specified adapter.  The 
    SupportedAdapterControlBitmap in the adapter extension will be updated with
    the data returned by the miniport.  These flags are used to determine 
    what functionality (for power management and such) the miniport will support
    
Arguments:    

    Adapter - the adapter to query
    
Return Value:

    none
    
--*/        

{
    UCHAR buffer[sizeof(SCSI_SUPPORTED_CONTROL_TYPE_LIST) + 
                 (sizeof(BOOLEAN) * (ScsiAdapterControlMax + 1))];

    PSCSI_SUPPORTED_CONTROL_TYPE_LIST typeList = 
        (PSCSI_SUPPORTED_CONTROL_TYPE_LIST) &buffer;

    SCSI_ADAPTER_CONTROL_STATUS status;

    PAGED_CODE();

    RtlInitializeBitMap(&(Adapter->SupportedControlBitMap), 
                        Adapter->SupportedControlBits,
                        ScsiAdapterControlMax);

    RtlClearAllBits(&(Adapter->SupportedControlBitMap));

    if((Adapter->HwAdapterControl == NULL) || 
       (Adapter->IsPnp == FALSE))  {

        //
        // Adapter control is not supported by the miniport or the miniport 
        // isn't pnp (in which case it's not supported by scsiport) - the 
        // supported array has already been cleared so we can just quit now.
        //
        return;
    }

    RtlZeroMemory(typeList, (sizeof(SCSI_SUPPORTED_CONTROL_TYPE_LIST) + 
                             sizeof(BOOLEAN) * (ScsiAdapterControlMax + 1)));

    typeList->MaxControlType = ScsiAdapterControlMax;

#if DBG
    typeList->SupportedTypeList[ScsiAdapterControlMax] = 0x63;
#endif

    status = Adapter->HwAdapterControl(Adapter->HwDeviceExtension,
                                       ScsiQuerySupportedControlTypes,
                                       typeList);

//    ASSERT(status != ScsiAdapterControlNotSupported);

    if(status == ScsiAdapterControlSuccess) {
        ULONG i;

        ASSERT(typeList->SupportedTypeList[ScsiAdapterControlMax] == 0x63);

        for(i = 0; i < ScsiAdapterControlMax; i++) {
            if(typeList->SupportedTypeList[i] == TRUE) {
                RtlSetBits(&(Adapter->SupportedControlBitMap),
                           i,
                           1);
            }
        }
    }
    return;
}


BOOLEAN
SpIsAdapterControlTypeSupported(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType
    )
{
    return RtlAreBitsSet(&(AdapterExtension->SupportedControlBitMap),
                         ControlType,
                         1);
}


SCSI_ADAPTER_CONTROL_STATUS 
SpCallAdapterControl(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )
{
    ASSERT(TEST_FLAG(AdapterExtension->InterruptData.InterruptFlags, 
                     PD_ADAPTER_REMOVED) == FALSE);

    ASSERT(SpIsAdapterControlTypeSupported(AdapterExtension, ControlType));    

    return AdapterExtension->HwAdapterControl(
                AdapterExtension->HwDeviceExtension,
                ControlType,
                Parameters);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\sbp2port\sbp2port.c ===
/*++


Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    sbp2port.c

Abstract:

    Main module for the SBP-2 port driver

    Author:

    George Chrysanthakopoulos January-1997

Environment:

    Kernel mode

Revision History :

--*/

#include "sbp2port.h"
#include "stdarg.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"


#if DBG

ULONG Sbp2DebugLevel = 0;

#endif

BOOLEAN SystemIsNT;


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NTSTATUS
Sbp2AddDevice(
    PDRIVER_OBJECT  DriverObject,
    PDEVICE_OBJECT  Pdo
    );

NTSTATUS
Sbp2StartDevice(
    IN PDEVICE_OBJECT DeviceObject
);

NTSTATUS
Sbp2CreateDeviceRelations(
    IN PFDO_DEVICE_EXTENSION FdoExtension,
    IN PDEVICE_RELATIONS DeviceRelations
    );

NTSTATUS
Sbp2CreateDevObject(
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           Pdo
    );

NTSTATUS
Sbp2DeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Sbp2CreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Sbp2PnpDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
Sbp2FDOPnpDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
Sbp2GetMultipleIds(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString,
    BOOLEAN HwIds
    );

NTSTATUS
Sbp2GetInstanceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
Sbp2GetDeviceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
Sbp2CreatePdo(
    IN PFDO_DEVICE_EXTENSION FdoExtension,
    IN PDEVICE_INFORMATION DeviceInfo,
    ULONG instanceNum
    );

NTSTATUS
Sbp2StringArrayToMultiString(
    PUNICODE_STRING MultiString,
    PCSTR StringArray[]
    );

NTSTATUS
Sbp2QueryDeviceText(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN DEVICE_TEXT_TYPE TextType,
    IN LCID LocaleId,
    IN OUT PWSTR *DeviceText
    );


NTSTATUS
Sbp2PowerControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
Sbp2SystemControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
Sbp2FdoRequestCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );


VOID
Sbp2Unload(
    IN PDRIVER_OBJECT DriverObject
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, Sbp2AddDevice)
#pragma alloc_text(PAGE, Sbp2StartDevice)
#pragma alloc_text(PAGE, Sbp2CreateDeviceRelations)
#pragma alloc_text(PAGE, Sbp2CreatePdo)
#pragma alloc_text(PAGE, Sbp2QueryDeviceText)
#pragma alloc_text(PAGE, Sbp2StringArrayToMultiString)
#pragma alloc_text(PAGE, Sbp2GetDeviceId)
#pragma alloc_text(PAGE, Sbp2GetInstanceId)
#pragma alloc_text(PAGE, Sbp2GetMultipleIds)
#pragma alloc_text(PAGE, Sbp2CreateDevObject)
#pragma alloc_text(PAGE, Sbp2DeviceControl)
#pragma alloc_text(PAGE, Sbp2SystemControl)
#pragma alloc_text(PAGE, Sbp2CreateClose)

#endif



NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called at system initialization time so we can fill in the basic dispatch points

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS

--*/

{
    //
    // Initialize the Driver Object with driver's entry points
    //

    DEBUGPRINT2(("Sbp2Port: DriverEntry: %s %s\n", __DATE__, __TIME__));

    DriverObject->MajorFunction[IRP_MJ_CREATE] = Sbp2CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = Sbp2CreateClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = Sbp2DeviceControl;

    DriverObject->MajorFunction[IRP_MJ_SCSI] = Sbp2ScsiRequests;

    DriverObject->DriverExtension->AddDevice = Sbp2AddDevice;
    DriverObject->MajorFunction[IRP_MJ_PNP] = Sbp2PnpDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP_POWER] = Sbp2PnpDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_POWER] = Sbp2PowerControl;

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = Sbp2SystemControl;

    DriverObject->DriverStartIo = Sbp2StartIo;
    DriverObject->DriverUnload = Sbp2Unload;

    SystemIsNT = IoIsWdmVersionAvailable ((UCHAR)0x01, (UCHAR)0x10);

    return STATUS_SUCCESS;
}


NTSTATUS
Sbp2AddDevice(
    PDRIVER_OBJECT  DriverObject,
    PDEVICE_OBJECT  Pdo
    )

/*++

Routine Description:

    This is our PNP AddDevice called with the PDO ejected from the bus driver

Arguments:

    Argument1          - Driver Object.
    Argument2          - PDO.


Return Value:

    A valid return code for a DriverEntry routine.

--*/

{
    return (Sbp2CreateDevObject (DriverObject,Pdo));
}


NTSTATUS
Sbp2CreateDevObject(
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           Pdo
    )
/*++

Routine Description:

    This routine creates an object for the physical device specified and
    sets up the deviceExtension.

Arguments:

    DriverObject - Pointer to driver object created by system.

    PhysicalDeviceObject = PDO we should attach to.


Return Value:

    NTSTATUS

--*/
{
    PFDO_DEVICE_EXTENSION deviceExtension;
    NTSTATUS       status;
    PDEVICE_OBJECT deviceObject = NULL;

    UNICODE_STRING uniDeviceName;

    WCHAR buffer[64];
    UNICODE_STRING unicodeDirectoryName;
    HANDLE handle;
    OBJECT_ATTRIBUTES objectAttributes;

    ULONG NextId = 0;

    //
    // This is the sbp2 filter device object and name
    //

    do {

        swprintf (buffer, L"\\Device\\Sbp2Port%x", NextId);

        RtlInitUnicodeString (&uniDeviceName, buffer);

        status = IoCreateDevice(DriverObject,
                                sizeof(FDO_DEVICE_EXTENSION),
                                &uniDeviceName,
                                FILE_DEVICE_BUS_EXTENDER,
                                FILE_DEVICE_SECURE_OPEN,
                                FALSE,
                                &deviceObject);

        NextId++;

    } while (status == STATUS_OBJECT_NAME_COLLISION);

    if (!NT_SUCCESS(status)) {

        return status;
    }


    deviceExtension = deviceObject->DeviceExtension;
    RtlZeroMemory(deviceExtension,sizeof(FDO_DEVICE_EXTENSION));

    if (Pdo != NULL) {

        if ((deviceExtension->LowerDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject,Pdo))==NULL){

            IoDeleteDevice(deviceObject);
            return status;
        }
    }

    deviceExtension->Type = SBP2_FDO;
    deviceExtension->DeviceFlags = 0;
    deviceExtension->DeviceObject = deviceObject;
    deviceExtension->Pdo = Pdo;
    KeInitializeSpinLock(&deviceExtension->DeviceListLock);
    KeInitializeMutex (&deviceExtension->EnableBusResetNotificationMutex, 0);

    //
    // create a directory object for Sbp2 children devices
    //

    swprintf(buffer, L"\\Device\\Sbp2");

    RtlInitUnicodeString(&unicodeDirectoryName, buffer);

    InitializeObjectAttributes(&objectAttributes,
                               &unicodeDirectoryName,
                               OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
                               NULL,
                               NULL);

    status = ZwCreateDirectoryObject(&handle,
                                     DIRECTORY_ALL_ACCESS,
                                     &objectAttributes);


    if (NT_SUCCESS(status)) {

        deviceExtension->Sbp2ObjectDirectory = handle;

    } else {

        //
        // the directory is already created by another instance of this driver..
        //

        status = STATUS_SUCCESS;
    }

    ExInitializeFastMutex(&deviceExtension->ResetMutex);

    IoInitializeRemoveLock( &deviceExtension->RemoveLock,
                            '2pbS',
                            REMLOCK_TIMEOUT,
                            REMLOCK_HIGH_WATERMARK
                            );

#if DBG
    deviceExtension->ulWorkItemCount = 0;
    deviceExtension->ulBusResetMutexCount = 0;
#endif

    deviceObject->Flags |= DO_DIRECT_IO;
    deviceObject->Flags &=~DO_DEVICE_INITIALIZING;

    return status;
}


NTSTATUS
Sbp2CreatePdo(
    IN PFDO_DEVICE_EXTENSION FdoExtension,
    IN PDEVICE_INFORMATION DeviceInfo,
    ULONG InstanceNumber
    )
{
    PDEVICE_EXTENSION pdoExtension;
    DEVICE_TYPE devType;
    WCHAR *buffer;
    UNICODE_STRING uniDeviceName;
    NTSTATUS status;
    ULONG byteSwappedData;

    PAGED_CODE();

    switch (DeviceInfo->CmdSetId.QuadPart) {

    case 0x10483:
    case SCSI_COMMAND_SET_ID:

       switch ((DeviceInfo->Lun.u.HighPart & 0x001F)) {

       case PRINTER_DEVICE:

           devType = FILE_DEVICE_PRINTER;
           break;

       case SCANNER_DEVICE:

           devType = FILE_DEVICE_SCANNER;
           break;

       case READ_ONLY_DIRECT_ACCESS_DEVICE:
       case RBC_DEVICE:
       case DIRECT_ACCESS_DEVICE:
       default:

           devType = FILE_DEVICE_MASS_STORAGE;
           break;
       }

       break;

    default:

        devType = FILE_DEVICE_UNKNOWN;
        break;
    }

    buffer = ExAllocatePool(PagedPool,
                            5 * SBP2_MAX_TEXT_LEAF_LENGTH * sizeof (WCHAR)
                            );

    if (buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (DeviceInfo->VendorLeaf && DeviceInfo->ModelLeaf) {

        ValidateTextLeaf(DeviceInfo->VendorLeaf);
        ValidateTextLeaf(DeviceInfo->ModelLeaf);

        //
        // check if we have unicode...
        //

        byteSwappedData = bswap(*(((PULONG) DeviceInfo->VendorLeaf+1)));

        if (byteSwappedData & 0x80000000) {

            swprintf(buffer,
                     L"\\Device\\Sbp2\\%ws&%ws&%x&%08x_%08x_Instance%02d",
                     &DeviceInfo->VendorLeaf->TL_Data,
                     &DeviceInfo->ModelLeaf->TL_Data,
                     DeviceInfo->Lun.u.LowPart,
                     bswap(FdoExtension->ConfigRom.CR_Node_UniqueID[0]),
                     bswap(FdoExtension->ConfigRom.CR_Node_UniqueID[1]),
                     InstanceNumber);

        } else {

            //
            // ascii text leaf
            //
            // Note that Win9x doesn't seem to like %s args, so we 1st
            // convert them to unicode manually
            //

            mbstowcs(&buffer[3 * SBP2_MAX_TEXT_LEAF_LENGTH],
                     &DeviceInfo->VendorLeaf->TL_Data,
                     strlen (&DeviceInfo->VendorLeaf->TL_Data) + 1);

            mbstowcs(&buffer[4 * SBP2_MAX_TEXT_LEAF_LENGTH],
                     &DeviceInfo->ModelLeaf->TL_Data,
                     strlen (&DeviceInfo->ModelLeaf->TL_Data) + 1);

            swprintf(buffer,
                     L"\\Device\\Sbp2\\%ws&%ws&%x&%08x_%08x_Instance%02d",
                     &buffer[3 * SBP2_MAX_TEXT_LEAF_LENGTH],
                     &buffer[4 * SBP2_MAX_TEXT_LEAF_LENGTH],
                     DeviceInfo->Lun.u.LowPart,
                     bswap(FdoExtension->ConfigRom.CR_Node_UniqueID[0]),
                     bswap(FdoExtension->ConfigRom.CR_Node_UniqueID[1]),
                     InstanceNumber);
        }

    } else {

        swprintf(buffer,
                L"\\Device\\Sbp2\\UNKNOWN_VENDOR&UNKNOWN_MODEL&%x&%08x_%08x_Instance%02d",
                DeviceInfo->Lun.u.LowPart,
                bswap(FdoExtension->ConfigRom.CR_Node_UniqueID[0]),
                bswap(FdoExtension->ConfigRom.CR_Node_UniqueID[1]),
                InstanceNumber);
    }

    RtlInitUnicodeString (&uniDeviceName, buffer);

    //
    // Need to create a device object for this device
    //

    status = IoCreateDevice(
                FdoExtension->DeviceObject->DriverObject,
                sizeof(DEVICE_EXTENSION),
                &uniDeviceName,
                devType,
                0,
                FALSE,
                &DeviceInfo->DeviceObject
                );

    if (!NT_SUCCESS(status)) {

        ExFreePool (buffer);
        return status;
    }

    // only set alignment if it's less than we require
    if (DeviceInfo->DeviceObject->AlignmentRequirement < SBP2_ALIGNMENT_MASK)
        DeviceInfo->DeviceObject->AlignmentRequirement = SBP2_ALIGNMENT_MASK;

    pdoExtension = (PDEVICE_EXTENSION)DeviceInfo->DeviceObject->DeviceExtension;

    RtlZeroMemory(pdoExtension,sizeof(DEVICE_EXTENSION));

    pdoExtension->LowerDeviceObject = FdoExtension->LowerDeviceObject;
    pdoExtension->DeviceObject = DeviceInfo->DeviceObject;
    pdoExtension->Type = SBP2_PDO;
    pdoExtension->DeviceInfo = DeviceInfo;
    pdoExtension->DeviceInfo->MaxClassTransferSize = FdoExtension->MaxClassTransferSize;
    pdoExtension->BusFdo = FdoExtension->DeviceObject;

#if DBG
    pdoExtension->ulPendingEvents = 0;
    pdoExtension->ulInternalEventCount = 0;
#endif

    KeInitializeSpinLock (&pdoExtension->ExtensionDataSpinLock);

    IoInitializeRemoveLock(
        &pdoExtension->RemoveLock,
        '2pbS',
        REMLOCK_TIMEOUT,
        REMLOCK_HIGH_WATERMARK
        );

    switch (DeviceInfo->CmdSetId.QuadPart) {

    case 0x10483:
    case SCSI_COMMAND_SET_ID:

        //
        // intepret device type only for scsi-variant command sets
        //
        // NOTE: sbp2port.h #define's MAX_GENERIC_NAME_LENGTH as 16
        //

        switch ((DeviceInfo->Lun.u.HighPart & 0x001F)) {

        case RBC_DEVICE:
        case DIRECT_ACCESS_DEVICE:

            sprintf(DeviceInfo->GenericName,"%s","GenDisk");
            break;

        case SEQUENTIAL_ACCESS_DEVICE:

            sprintf(DeviceInfo->GenericName,"%s","GenSequential");
            break;

        case PRINTER_DEVICE:

            sprintf(DeviceInfo->GenericName,"%s","GenPrinter");
            break;

        case WRITE_ONCE_READ_MULTIPLE_DEVICE:

            sprintf(DeviceInfo->GenericName,"%s","GenWorm");
            break;

        case READ_ONLY_DIRECT_ACCESS_DEVICE:

            sprintf(DeviceInfo->GenericName,"%s","GenCdRom");
            break;

        case SCANNER_DEVICE:

            sprintf(DeviceInfo->GenericName,"%s","GenScanner");
            break;

        case OPTICAL_DEVICE:

            sprintf(DeviceInfo->GenericName,"%s","GenOptical");
            break;

        case MEDIUM_CHANGER:

            sprintf(DeviceInfo->GenericName,"%s","GenChanger");
            break;

        default:

            sprintf(DeviceInfo->GenericName,"%s","GenSbp2Device");
            break;
        }

        break;

    default:

        sprintf(DeviceInfo->GenericName,"%s","GenSbp2Device");
        break;
    }

    DeviceInfo->DeviceObject->Flags |= DO_DIRECT_IO;

    status = Sbp2PreAllocateLists (pdoExtension);

    if (!NT_SUCCESS(status)) {

        IoDeleteDevice (pdoExtension->DeviceObject);
        DeviceInfo->DeviceObject = NULL;

    } else {

        PWCHAR symlinkBuffer;

        symlinkBuffer = ExAllocatePool(PagedPool,
                                3 * SBP2_MAX_TEXT_LEAF_LENGTH * sizeof (WCHAR)
                                );

        if (symlinkBuffer) {

            swprintf(
                symlinkBuffer,
                L"\\DosDevices\\Sbp2&LUN%x&%08x%08x&Instance%02d",
                DeviceInfo->Lun.u.LowPart,
                bswap(FdoExtension->ConfigRom.CR_Node_UniqueID[0]),
                bswap(FdoExtension->ConfigRom.CR_Node_UniqueID[1]),
                InstanceNumber
                );

            RtlInitUnicodeString (&pdoExtension->UniSymLinkName,symlinkBuffer);

            status = IoCreateUnprotectedSymbolicLink(
                &pdoExtension->UniSymLinkName,
                &uniDeviceName
                );

            if (NT_SUCCESS (status)) {

                DEBUGPRINT2((
                    "Sbp2Port: CreatePdo: symLink=%ws\n",
                    symlinkBuffer
                    ));

            } else {

                DEBUGPRINT1((
                    "\nSbp2Port: CreatePdo: createSymLink err=x%x\n",
                    status
                    ));
            }

        } else {

            DEBUGPRINT1(("\n Sbp2CreatePdo: failed to alloc sym link buf\n"));
        }

        //
        // if sym link fails its not critical
        //

        status = STATUS_SUCCESS;
    }

    ExFreePool (buffer);

    DeviceInfo->DeviceObject->Flags &=~DO_DEVICE_INITIALIZING;
    return status;
}


NTSTATUS
Sbp2StartDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This is our START_DEVICE, called when we get an IPR_MN_START_DEVICE. Initializes the driver and
    retrieves physical device information and 1394 bus information required for accessing the device.

Arguments:

    DeviceObject = Sbp2 driver's device object

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension=DeviceObject->DeviceExtension;
    PFDO_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    ULONG temp;
    BOOLEAN enabledBusResetNotification = FALSE;


    if (deviceExtension->Type == SBP2_PDO) {

#if PASSWORD_SUPPORT

        Sbp2GetExclusiveValue(DeviceObject, &deviceExtension->Exclusive);

#endif

        if (!TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_INITIALIZED)){

            //
            // initialize our device state flags
            //

            deviceExtension->DevicePowerState = PowerDeviceD0;
            deviceExtension->SystemPowerState = PowerSystemWorking;

            deviceExtension->MaxOrbListDepth = MAX_ORB_LIST_DEPTH;
        }

        deviceExtension->DeviceFlags = DEVICE_FLAG_PNP_STOPPED |
            DEVICE_FLAG_STOPPED | DEVICE_FLAG_INITIALIZING;

        //
        // Initiliaze the Timer and timeout DPC used for resets, reconnects and TASK functions
        //

        KeInitializeDpc(
            &deviceExtension->DeviceManagementTimeoutDpc,
            Sbp2DeviceManagementTimeoutDpc,
            deviceExtension
            );

        KeInitializeTimer(&deviceExtension->DeviceManagementTimer);

        KeInitializeSpinLock(&deviceExtension->OrbListSpinLock);
        KeInitializeSpinLock(&deviceExtension->ExtensionDataSpinLock);

        KeInitializeSpinLock(&deviceExtension->StatusFifoLock);
        KeInitializeSpinLock(&deviceExtension->FreeContextLock);
        KeInitializeSpinLock(&deviceExtension->BusRequestLock);

        ASSERT(!deviceExtension->ulPendingEvents);
        ASSERT(!deviceExtension->ulInternalEventCount);

#if DBG
        deviceExtension->ulPendingEvents = 0;
        deviceExtension->ulInternalEventCount = 0;
#endif

        //
        // Initialize our device Extension ORB's, status blocks, Irp and Irb's
        // Also allocate 1394 addresses for extension-held sbp2 ORB's
        //

        status = Sbp2InitializeDeviceExtension(deviceExtension);

        if (!NT_SUCCESS(status)) {

            goto exitStartDevice;
        }

        DEBUGPRINT2(("\nSbp2Port: StartDev: cmd set id=x%x\n", deviceExtension->DeviceInfo->CmdSetId.QuadPart));

        switch (deviceExtension->DeviceInfo->CmdSetId.QuadPart) {

        case 0x0:
        case 0x10483:
        case SCSI_COMMAND_SET_ID:

            SET_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_SPC_CMD_SET);

            DEBUGPRINT2(("Sbp2Port: StartDev: enabling SPC cmd set\n"));

            break;
        }

        //
        // login
        //

        status = Sbp2ManagementTransaction(deviceExtension,TRANSACTION_LOGIN);

        if (!NT_SUCCESS(status)) {

            DEBUGPRINT1(("\nSbp2StartDev: Login failed with %x, retrying\n",status));

            if (status == STATUS_ACCESS_DENIED) {

                //
                // retry the login. By now we should have access since our bus reset forced a logout
                //

                Sbp2ManagementTransaction(deviceExtension,TRANSACTION_QUERY_LOGINS);
            }

            temp = 0;

            do {

                //
                // Give things time (one second) to settle...
                //

                LARGE_INTEGER waitValue;

                ASSERT(InterlockedIncrement(&deviceExtension->ulPendingEvents) == 1);

                KeInitializeEvent(deviceExtension->ManagementOrbContext.Reserved, NotificationEvent, FALSE);

                waitValue.QuadPart = -1 * 1000 * 1000 * 10;

                KeWaitForSingleObject(deviceExtension->ManagementOrbContext.Reserved,Executive,KernelMode,FALSE,&waitValue);

                ASSERT(InterlockedDecrement(&deviceExtension->ulPendingEvents) == 0);

                //
                // all the resident 1394 memory addresses's that we have, are
                // now invalidated... So we need to free them and re-allocate
                // them

                Sbp2CleanDeviceExtension (deviceExtension->DeviceObject,FALSE);

                Sbp2InitializeDeviceExtension(deviceExtension);

                status = Sbp2ManagementTransaction(deviceExtension,TRANSACTION_LOGIN);

                temp ++;

                //
                // Note: We get STATUS_REQUEST_ABORTED rather than
                //       STATUS_INVALID_GENERATION at passive level,
                //       so check for that instead
                //

            } while ((status == STATUS_REQUEST_ABORTED) &&
                     (temp <= 3));

            if (!NT_SUCCESS(status)) {

                goto exitStartDevice;
            }
        }

#if PASSWORD_SUPPORT

        if (deviceExtension->Exclusive & EXCLUSIVE_FLAG_ENABLE) {

            status = Sbp2SetPasswordTransaction(
                deviceExtension,
                SBP2REQ_SET_PASSWORD_EXCLUSIVE
                );

            if (NT_SUCCESS(status)) {

                deviceExtension->Exclusive = EXCLUSIVE_FLAG_SET;

            } else {

                deviceExtension->Exclusive = EXCLUSIVE_FLAG_CLEAR;
            }

            Sbp2SetExclusiveValue(
                deviceExtension->DeviceObject,
                &deviceExtension->Exclusive
                );
        }

#endif

        //
        // We are ready to receive and pass down requests, init the target's
        // fetch agent. The value we write to it is not important
        //

        Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,AGENT_RESET_REG | REG_WRITE_SYNC);

        //
        // enable unsolicited status reg
        //

        Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,UNSOLICITED_STATUS_REG | REG_WRITE_SYNC);

        CLEAR_FLAG(
            deviceExtension->DeviceFlags,
            (DEVICE_FLAG_PNP_STOPPED | DEVICE_FLAG_STOPPED)
            );

        //
        // register for idle detection
        //

        deviceExtension->IdleCounter = PoRegisterDeviceForIdleDetection(DeviceObject,
                                                                        -1,
                                                                        -1,
                                                                        PowerDeviceD3);

        CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_INITIALIZING );
        SET_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_INITIALIZED);

        //
        // OK to register for bus reset notifications now
        //

        if (!Sbp2EnableBusResetNotification (deviceExtension, TRUE)) {

            SET_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED);
            CleanupOrbList (deviceExtension, STATUS_REQUEST_ABORTED);
            Sbp2ManagementTransaction (deviceExtension, TRANSACTION_LOGOUT);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exitStartDevice;
        }

        enabledBusResetNotification = TRUE;


        if (TEST_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_SPC_CMD_SET)) {

            //
            // issue an Inquiry to the target...
            //

            status = Sbp2IssueInternalCommand (deviceExtension,SCSIOP_INQUIRY);

            if (NT_SUCCESS(status)) {

                DEBUGPRINT2((
                    "Sbp2Port: StartDev: cfgRom devType=x%x, inq devType=x%x\n",
                    (deviceExtension->DeviceInfo->Lun.u.HighPart & 0x001F),
                    deviceExtension->InquiryData.DeviceType
                    ));

            } else if ((status == STATUS_DEVICE_DOES_NOT_EXIST) ||
                       (status == STATUS_DEVICE_BUSY)) {

                //
                // In win2k if the inquiry failed we'd just turn off the
                // SPC_CMD_SET flag and trundle on like nothing happened.
                //
                // However, we found some devices would allow logins but
                // nothing else, like a powered-down mactell hd which would
                // allow us to login but fail all other requests.  This
                // really caused problems in win9x because Ntmap would
                // get loaded, but not init'd correctly, and on subsequent
                // re-plugs of any device we'd see trap 14's and the like.
                // So, it really makes alot more sense to just nip this
                // in the bud and fail the start if we get an error back
                // from the inquiry that tells us (per Sbp2ScsiRequests())
                // that the device has been removed or it timed out the 1st
                // inquiry .  DanKn, 7 Apr 2000
                //

                DEBUGPRINT1((
                    "\nSbp2Port: StartDev: ext=x%p, fatal INQUIRY err=x%x, " \
                        "log out\n",
                    deviceExtension,
                    status
                    ));

                Sbp2ManagementTransaction(deviceExtension,TRANSACTION_LOGOUT);
                status = STATUS_IO_DEVICE_ERROR;
                goto exitStartDevice;

            } else {

                CLEAR_FLAG(
                    deviceExtension->DeviceFlags,
                    DEVICE_FLAG_SPC_CMD_SET
                    );

                DEBUGPRINT1((
                    "\nSbp2Port: StartDev: ext=x%p, non-fatal INQUIRY err=x%x\n",
                    deviceExtension,
                    status
                    ));

                status = STATUS_SUCCESS;
            }
        }

        if (deviceExtension->InquiryData.DeviceType != (deviceExtension->DeviceInfo->Lun.u.HighPart & 0x001F)){

            deviceExtension->InquiryData.DeviceType = (deviceExtension->DeviceInfo->Lun.u.HighPart & 0x001F);
            DEBUGPRINT1(("\nSbp2StartDev: DeviceType mismatch, using one in ConfigRom %x\n",
                           (deviceExtension->DeviceInfo->Lun.u.HighPart & 0x001F)));
        }

        //
        // if this is a scanner or a printer we dont need to remain logged on..
        //

        if ((deviceExtension->InquiryData.DeviceType == PRINTER_DEVICE) ||
            (deviceExtension->InquiryData.DeviceType == SCANNER_DEVICE)){

            if (NT_SUCCESS(status)) {

                SET_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED);
                CleanupOrbList(deviceExtension,STATUS_REQUEST_ABORTED);

                Sbp2ManagementTransaction(deviceExtension,TRANSACTION_LOGOUT);
            }

        } else if (deviceExtension->InquiryData.DeviceType == RBC_DEVICE) {

            if (NT_SUCCESS(status)) {

                //
                // retrieve the RBC device mode page
                //

                status = Sbp2IssueInternalCommand(deviceExtension,SCSIOP_MODE_SENSE);

                if (!NT_SUCCESS(status)) {

                    DEBUGPRINT1(("\nSbp2StartDev: Failed to retrieve RBC mode page\n"));
                    goto exitStartDevice;

                }
            }
        }

exitStartDevice:

        if (!NT_SUCCESS(status)) {

            PIO_ERROR_LOG_PACKET errorLogEntry;
            ULONG errorId = __LINE__ ;


            errorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceObject,sizeof(IO_ERROR_LOG_PACKET));

            if(errorLogEntry != NULL) {

                errorLogEntry->ErrorCode = IO_ERR_DRIVER_ERROR;
                errorLogEntry->UniqueErrorValue = errorId;
                errorLogEntry->FinalStatus = status;
                errorLogEntry->DumpDataSize = 0;
                IoWriteErrorLogEntry(errorLogEntry);
            }

            DEBUGPRINT1((
                "Sbp2Port: StartDev: FAILED, status=x%x\n",
                status
                ));

            SET_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_PNP_STOPPED | DEVICE_FLAG_DEVICE_FAILED)
                );

            if (enabledBusResetNotification) {

                Sbp2EnableBusResetNotification (deviceExtension, FALSE);
            }

        } else {

            if (!SystemIsNT) {

                DeviceObject->Flags |= DO_POWER_PAGABLE;

            } else {

                DeviceObject->Flags &= ~DO_POWER_PAGABLE;
            }
        }

    } else if (deviceExtension->Type == SBP2_FDO){

        //
        // Bus driver FDO start device
        // retrieve parameters from the registry, if present
        //

        fdoExtension->MaxClassTransferSize = SBP2_MAX_TRANSFER_SIZE;
        GetRegistryParameters(fdoExtension->LowerDeviceObject,&temp,&fdoExtension->MaxClassTransferSize);
        DEBUGPRINT2(("Sbp2Port: StartDev: maxXferSize=x%x\n", fdoExtension->MaxClassTransferSize ));

        fdoExtension->DevicePowerState = PowerDeviceD0;
        fdoExtension->SystemPowerState = PowerSystemWorking;

        deviceExtension->DeviceFlags=DEVICE_FLAG_INITIALIZED;
        status = STATUS_SUCCESS;

    } else {

        status = STATUS_NO_SUCH_DEVICE;
    }

    return status;
}


NTSTATUS
Sbp2PreAllocateLists(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Initializes all the single linked workhorse lists plus lookasides. Only called from AddDevice or after
    a REMOVE -> START

Arguments:

    DeviceExtension = Sbp2 driver's extension

Return Value:

    NTSTATUS

--*/
{
    ULONG                   cnt ;
    PIRBIRP                 packet;
    NTSTATUS                status;
    PADDRESS_FIFO           statusFifoElement ;
    PREQUEST_CONTEXT        rContext;
    PSTATUS_FIFO_BLOCK      statusFifo;
    PASYNC_REQUEST_CONTEXT  context;


    //
    // initialize all interlocked lists
    //

    SET_FLAG(
        DeviceExtension->DeviceFlags,
        (DEVICE_FLAG_INITIALIZING | DEVICE_FLAG_STOPPED |
            DEVICE_FLAG_PNP_STOPPED)
        );

    InitializeListHead(&DeviceExtension->PendingOrbList);

    ExInitializeSListHead(&DeviceExtension->FreeContextListHead);
    ExInitializeSListHead(&DeviceExtension->BusRequestIrpIrbListHead);
    ExInitializeSListHead(&DeviceExtension->BusRequestContextListHead);
    ExInitializeSListHead(&DeviceExtension->StatusFifoListHead);

    KeInitializeSpinLock(&DeviceExtension->OrbListSpinLock);
    KeInitializeSpinLock(&DeviceExtension->ExtensionDataSpinLock);

    KeInitializeSpinLock(&DeviceExtension->StatusFifoLock);
    KeInitializeSpinLock(&DeviceExtension->FreeContextLock);
    KeInitializeSpinLock(&DeviceExtension->BusRequestLock);


    //
    // alloc the irb/irp and context slists
    //

    for (cnt = 0; cnt < MAX_ORB_LIST_DEPTH; cnt++) {

        packet = ExAllocatePoolWithTag (NonPagedPool,sizeof(IRBIRP),'2pbs');

        if (!packet) {

            goto Sbp2PreAllocateLists_error;
        }

        packet->Irb = ExAllocatePoolWithTag (NonPagedPool,sizeof(IRB),'2pbs');

        if (!packet->Irb) {

            ExFreePool(packet);

            goto Sbp2PreAllocateLists_error;
        }

        packet->Irp = IoAllocateIrp (DeviceExtension->LowerDeviceObject->StackSize,FALSE);

        if (!packet->Irp) {

            ExFreePool(packet->Irb);
            ExFreePool(packet);

            goto Sbp2PreAllocateLists_error;
        }

        ExInterlockedPushEntrySList (&DeviceExtension->BusRequestIrpIrbListHead,
                                     &packet->ListPointer,
                                     &DeviceExtension->BusRequestLock);
    }

    for (cnt = 0; cnt < MAX_ORB_LIST_DEPTH; cnt++) {

        rContext = NULL;
        rContext = ExAllocatePoolWithTag(NonPagedPool,sizeof(REQUEST_CONTEXT),'2pbs');

        if (!rContext) {

            goto Sbp2PreAllocateLists_error;
        }

        ExInterlockedPushEntrySList (&DeviceExtension->BusRequestContextListHead,
                                     &rContext->ListPointer,
                                     &DeviceExtension->BusRequestLock);
    }

    //
    // status FIFO list
    //

    cnt = (sizeof(ADDRESS_FIFO)+sizeof(STATUS_FIFO_BLOCK))*NUM_PREALLOCATED_STATUS_FIFO_ELEMENTS;

    DeviceExtension->StatusFifoBase = \
        (PASYNC_REQUEST_CONTEXT) ExAllocatePoolWithTag(NonPagedPool,cnt,'2pbs');

    if (DeviceExtension->StatusFifoBase == NULL) {

        goto Sbp2PreAllocateLists_error;
    }

    for (cnt = 0; cnt < (NUM_PREALLOCATED_STATUS_FIFO_ELEMENTS - 1); cnt++) {

        statusFifoElement = (PADDRESS_FIFO) ((PUCHAR)DeviceExtension->StatusFifoBase + \
            cnt * (sizeof(ADDRESS_FIFO)+sizeof(STATUS_FIFO_BLOCK)));

        statusFifo = (PSTATUS_FIFO_BLOCK) ((PUCHAR)statusFifoElement + sizeof(ADDRESS_FIFO));

        //
        // make Mdl for this status fifo Element
        //

        statusFifoElement->FifoMdl = IoAllocateMdl(statusFifo,sizeof(STATUS_FIFO_BLOCK),FALSE,FALSE,NULL);

        if (statusFifoElement->FifoMdl == NULL) {

            goto Sbp2PreAllocateLists_error;
        }

        MmBuildMdlForNonPagedPool (statusFifoElement->FifoMdl);

        ExInterlockedPushEntrySList(&DeviceExtension->StatusFifoListHead,
                                    (PSINGLE_LIST_ENTRY) &statusFifoElement->FifoList,
                                    &DeviceExtension->StatusFifoLock);
    }


    //
    // Initialize the async request contexts (including page tables)
    //

    cnt = sizeof (ASYNC_REQUEST_CONTEXT) * MAX_ORB_LIST_DEPTH;

    DeviceExtension->AsyncContextBase = (PASYNC_REQUEST_CONTEXT)
        ExAllocatePoolWithTag (NonPagedPool, cnt, '2pbs');

    if (DeviceExtension->AsyncContextBase == NULL) {

        goto Sbp2PreAllocateLists_error;
    }

    RtlZeroMemory (DeviceExtension->AsyncContextBase, cnt);

    AllocateIrpAndIrb (DeviceExtension, &packet);

    if (!packet) {

        goto Sbp2PreAllocateLists_error;
    }

    for (cnt = 0; cnt < MAX_ORB_LIST_DEPTH; cnt++) {

        context = DeviceExtension->AsyncContextBase + cnt;

        context->Tag = SBP2_ASYNC_CONTEXT_TAG;

        //
        // Initialize the timeout DPC and timer
        //

        KeInitializeDpc(
            &context->TimerDpc,
            Sbp2RequestTimeoutDpc,
            DeviceExtension
            );

        KeInitializeTimer (&context->Timer);


        //
        // Alloc and/or map a page table
        //

        packet->Irb->FunctionNumber = REQUEST_ALLOCATE_ADDRESS_RANGE;

        packet->Irb->u.AllocateAddressRange.nLength = PAGE_SIZE;
        packet->Irb->u.AllocateAddressRange.fulNotificationOptions =
            NOTIFY_FLAGS_NEVER;
        packet->Irb->u.AllocateAddressRange.fulAccessType =
            ACCESS_FLAGS_TYPE_READ;

        packet->Irb->u.AllocateAddressRange.fulFlags =
            ALLOCATE_ADDRESS_FLAGS_USE_COMMON_BUFFER;

        packet->Irb->u.AllocateAddressRange.Callback = NULL;
        packet->Irb->u.AllocateAddressRange.Context = NULL;

        packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_High = 0;
        packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_Low = 0;

        packet->Irb->u.AllocateAddressRange.FifoSListHead = NULL;
        packet->Irb->u.AllocateAddressRange.FifoSpinLock = NULL;

        packet->Irb->u.AllocateAddressRange.AddressesReturned = 0;
        packet->Irb->u.AllocateAddressRange.DeviceExtension = DeviceExtension;

        packet->Irb->u.AllocateAddressRange.Mdl =
            context->PageTableContext.AddressContext.RequestMdl;

        packet->Irb->u.AllocateAddressRange.MaxSegmentSize =
            (SBP2_MAX_DIRECT_BUFFER_SIZE + 1) / 2;

        packet->Irb->u.AllocateAddressRange.p1394AddressRange =(PADDRESS_RANGE)
            &context->PageTableContext.AddressContext.Address;

        status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

        if (!NT_SUCCESS (status)) {

            DeAllocateIrpAndIrb (DeviceExtension, packet);
            goto Sbp2PreAllocateLists_error;
        }


        //
        // Common buffer allocations get an mdl *back* from the
        // bus/port driver, need to retrieve a corresponding VA
        //

        context->PageTableContext.AddressContext.RequestMdl =
            packet->Irb->u.AllocateAddressRange.Mdl;

        context->PageTableContext.PageTable = MmGetMdlVirtualAddress(
            packet->Irb->u.AllocateAddressRange.Mdl
            );

        context->PageTableContext.AddressContext.AddressHandle =
            packet->Irb->u.AllocateAddressRange.hAddressRange;
        context->PageTableContext.AddressContext.Address.BusAddress.NodeId =
            DeviceExtension->InitiatorAddressId;

        context->PageTableContext.MaxPages = SBP2_NUM_PAGE_TABLE_ENTRIES;


        //
        // add this context to the linked list
        //

        ExInterlockedPushEntrySList(
            &DeviceExtension->FreeContextListHead,
            &context->LookasideList,
            &DeviceExtension->FreeContextLock
            );
    }

    DeAllocateIrpAndIrb (DeviceExtension, packet);


    //
    // initialize the mdl used for quadlet requests to the port driver..
    //

    DeviceExtension->ReservedMdl = IoAllocateMdl(
        &DeviceExtension->Reserved,
        sizeof(QUADLET),
        FALSE,
        FALSE,
        NULL
        );

    if (!DeviceExtension->ReservedMdl) {

        goto Sbp2PreAllocateLists_error;
    }

    MmBuildMdlForNonPagedPool (DeviceExtension->ReservedMdl);

    return STATUS_SUCCESS;


Sbp2PreAllocateLists_error:

    Sbp2CleanDeviceExtension (DeviceExtension->DeviceObject, TRUE);

    return STATUS_INSUFFICIENT_RESOURCES;
}


NTSTATUS
Sbp2InitializeDeviceExtension(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Initializes all the data structures in our device extension, allocates appropriate 1394 addresses and workhorse
    Irps. It also creates a FreeList with pre-allocated contexts and command ORBs.

Arguments:

    DeviceExtension = Sbp2 driver's extension

Return Value:

    NTSTATUS

--*/

{
    ULONG                   i;
    KIRQL                   cIrql;
    NTSTATUS                status;
    PDEVICE_OBJECT          deviceObject = DeviceExtension->DeviceObject;
    PASYNC_REQUEST_CONTEXT  context, oldContext;



    if (DeviceExtension->DeviceFlags & DEVICE_FLAG_REMOVED) {

        return STATUS_SUCCESS;
    }

    InitializeListHead(&DeviceExtension->PendingOrbList);

    DeviceExtension->NextContextToFree = NULL;

    DeviceExtension->OrbListDepth = 0;
    DeviceExtension->CurrentKey = 0;

    //
    // Get information volatile between bus resets
    //

    status = Sbp2UpdateNodeInformation (DeviceExtension);

    if (!NT_SUCCESS(status)) {

        goto exitInit;
    }


    //
    // get 1394 data transfer information
    //

    status = Sbp2GetControllerInfo (DeviceExtension);

    if (!NT_SUCCESS(status)) {

        goto exitInit;
    }


    //
    //
    // allocate a status block for the task ORB and a Management ORB
    //

    if (DeviceExtension->TaskOrbStatusContext.AddressHandle == NULL) {

        status = AllocateAddressForStatus(deviceObject,
                                          &DeviceExtension->TaskOrbStatusContext,
                                          TASK_STATUS_BLOCK);

        if (!NT_SUCCESS(status)) {

            goto exitInit;
        }
    }

    if (DeviceExtension->ManagementOrbStatusContext.AddressHandle == NULL) {

        status = AllocateAddressForStatus(deviceObject,
                                      &DeviceExtension->ManagementOrbStatusContext,
                                      MANAGEMENT_STATUS_BLOCK);

        if (!NT_SUCCESS(status)) {

            goto exitInit;
        }
    }

    if (DeviceExtension->GlobalStatusContext.AddressHandle == NULL) {

        //
        // setup the status FIFO list with the bus driver
        //

        status = AllocateAddressForStatus(deviceObject,
                                          &DeviceExtension->GlobalStatusContext,
                                          CMD_ORB_STATUS_BLOCK);
        if (!NT_SUCCESS(status)) {

            goto exitInit;
        }
    }

#if PASSWORD_SUPPORT

    if (DeviceExtension->PasswordOrbStatusContext.AddressHandle == NULL) {

        status = AllocateAddressForStatus( deviceObject,
                                           &DeviceExtension->PasswordOrbStatusContext,
                                           PASSWORD_STATUS_BLOCK
                                           );

        if (!NT_SUCCESS(status)) {

            goto exitInit;
        }
    }

    DeviceExtension->PasswordOrbContext.DeviceObject = deviceObject;

#endif

    //
    // Allocate a dummy,task, management ORBs and a login response ,which are going to be reused through out the drivers life...
    //

    DeviceExtension->TaskOrbContext.DeviceObject = deviceObject;
    DeviceExtension->ManagementOrbContext.DeviceObject = deviceObject;
    DeviceExtension->LoginRespContext.DeviceObject = deviceObject;
    DeviceExtension->QueryLoginRespContext.DeviceObject = deviceObject;

    if (!DeviceExtension->ManagementOrbContext.Reserved) {

        DeviceExtension->ManagementOrbContext.Reserved = ExAllocatePoolWithTag(NonPagedPool,sizeof(KEVENT),'2pbs');
    }

    if (!DeviceExtension->ManagementOrbContext.Reserved) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exitInit;
    }

    KeInitializeEvent(DeviceExtension->ManagementOrbContext.Reserved,SynchronizationEvent, FALSE);

#if PASSWORD_SUPPORT

    // kevent for password orb context

    DeviceExtension->PasswordOrbContext.DeviceObject = deviceObject;

    if (!DeviceExtension->PasswordOrbContext.Reserved) {

        DeviceExtension->PasswordOrbContext.Reserved = ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(KEVENT),
            '2pbs'
            );
    }

    if (!DeviceExtension->PasswordOrbContext.Reserved) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exitInit;
    }

    KeInitializeEvent(
        DeviceExtension->PasswordOrbContext.Reserved,
        SynchronizationEvent,
        FALSE
        );

#endif

    if (DeviceExtension->CommonBufferContext.AddressHandle == NULL) {

        status = AllocateSingle1394Address(
            deviceObject,
            NULL,
            sizeof (*DeviceExtension->CommonBuffer),
            ACCESS_FLAGS_TYPE_READ | ACCESS_FLAGS_TYPE_WRITE,
            &DeviceExtension->CommonBufferContext
            );

        if (!NT_SUCCESS(status)) {

            goto exitInit;
        }

        (PVOID) DeviceExtension->CommonBuffer =
            DeviceExtension->CommonBufferContext.Reserved;


        DeviceExtension->TaskOrb = &DeviceExtension->CommonBuffer->TaskOrb;

        DeviceExtension->TaskOrbContext.Address.BusAddress =
            DeviceExtension->CommonBufferContext.Address.BusAddress;


        DeviceExtension->ManagementOrb =
            &DeviceExtension->CommonBuffer->ManagementOrb;

        DeviceExtension->ManagementOrbContext.Address.BusAddress =
            DeviceExtension->CommonBufferContext.Address.BusAddress;

        DeviceExtension->ManagementOrbContext.Address.BusAddress.Off_Low +=
            (ULONG) ((PUCHAR) DeviceExtension->ManagementOrb -
                (PUCHAR) DeviceExtension->CommonBuffer);


        DeviceExtension->LoginResponse =
            &DeviceExtension->CommonBuffer->LoginResponse;

        DeviceExtension->LoginRespContext.Address.BusAddress =
            DeviceExtension->CommonBufferContext.Address.BusAddress;

        DeviceExtension->LoginRespContext.Address.BusAddress.Off_Low +=
            (ULONG) ((PUCHAR) DeviceExtension->LoginResponse -
                (PUCHAR) DeviceExtension->CommonBuffer);


        DeviceExtension->QueryLoginResponse =
            &DeviceExtension->CommonBuffer->QueryLoginResponse;

        DeviceExtension->QueryLoginRespContext.Address.BusAddress =
            DeviceExtension->CommonBufferContext.Address.BusAddress;

        DeviceExtension->QueryLoginRespContext.Address.BusAddress.Off_Low +=
            (ULONG) ((PUCHAR) DeviceExtension->QueryLoginResponse -
                (PUCHAR) DeviceExtension->CommonBuffer);


#if PASSWORD_SUPPORT

        DeviceExtension->PasswordOrb =
            &DeviceExtension->CommonBuffer->PasswordOrb;

        DeviceExtension->PasswordOrbContext.Address.BusAddress =
            DeviceExtension->CommonBufferContext.Address.BusAddress;

        DeviceExtension->PasswordOrbContext.Address.BusAddress.Off_Low +=
            (ULONG) ((PUCHAR) DeviceExtension->PasswordOrb -
                (PUCHAR) DeviceExtension->CommonBuffer);

#endif

        DeviceExtension->OrbPoolContext.Reserved =
            DeviceExtension->CommonBuffer->CmdOrbs;

        DeviceExtension->OrbPoolContext.Address.BusAddress =
            DeviceExtension->CommonBufferContext.Address.BusAddress;

        DeviceExtension->OrbPoolContext.Address.BusAddress.Off_Low +=
            (ULONG) ((PUCHAR) DeviceExtension->OrbPoolContext.Reserved -
                (PUCHAR) DeviceExtension->CommonBuffer);


        KeAcquireSpinLock (&DeviceExtension->OrbListSpinLock, &cIrql);

        //
        // Initialize our pool of contexts
        //

        for (i = 0, context = NULL; i < MAX_ORB_LIST_DEPTH; i++) {

            //
            // Mark this unused context as completed so if we had to
            // free our freelist now (because we got a remove) we wouldn't
            // try to complete its request
            //

            oldContext = context;

            context = (PVOID) ExInterlockedPopEntrySList (&DeviceExtension->FreeContextListHead,
                                                          &DeviceExtension->FreeContextLock);

            context = RETRIEVE_CONTEXT (context,LookasideList);

            context->Flags |= ASYNC_CONTEXT_FLAG_COMPLETED;

            //
            // Create a linked list so we push all the entries later
            //

            context->OrbList.Blink = (PLIST_ENTRY) oldContext;

            //
            // Each command ORB gets a small piece of our continuous pool
            // mapped into the 1394 memory space.  The sizeof(PVOID) bytes
            // before the cmdorb buffer are the pointer to its context.
            //

            context->CmdOrb = &DeviceExtension->CommonBuffer->CmdOrbs[i].Orb;

            DeviceExtension->CommonBuffer->CmdOrbs[i].AsyncReqCtx = context;

            context->CmdOrbAddress.BusAddress.Off_Low = \
                DeviceExtension->OrbPoolContext.Address.BusAddress.Off_Low +
                (i * sizeof (ARCP_ORB)) + FIELD_OFFSET (ARCP_ORB, Orb);

            context->CmdOrbAddress.BusAddress.Off_High = \
                DeviceExtension->OrbPoolContext.Address.BusAddress.Off_High;

            context->CmdOrbAddress.BusAddress.NodeId = \
                DeviceExtension->InitiatorAddressId;
        }

        //
        // re-create the free list
        //

        while (context) {

            oldContext = context;

            ExInterlockedPushEntrySList(&DeviceExtension->FreeContextListHead,
                                        &context->LookasideList,
                                        &DeviceExtension->FreeContextLock);

            context = (PASYNC_REQUEST_CONTEXT) oldContext->OrbList.Blink;

            oldContext->OrbList.Blink = NULL;
        }


        KeReleaseSpinLock (&DeviceExtension->OrbListSpinLock,cIrql);
    }

    //
    // Update the NodeId portion of the page table addr for each
    // ASYNC_REQUEST_CONTEXT and for the login/queryLogin responses
    //

    for (i = 0; i < MAX_ORB_LIST_DEPTH; i++) {

        context = DeviceExtension->AsyncContextBase + i;

        context->PageTableContext.AddressContext.Address.BusAddress.NodeId =
            DeviceExtension->InitiatorAddressId;
    }

    DeviceExtension->LoginRespContext.Address.BusAddress.NodeId =
        DeviceExtension->InitiatorAddressId;

    DeviceExtension->QueryLoginRespContext.Address.BusAddress.NodeId =
        DeviceExtension->InitiatorAddressId;


    //
    // Finally, allocate a dummy addr that we can easily free & realloc
    // to re-enable phyical addr filters after bus resets
    //

    if (DeviceExtension->DummyContext.AddressHandle == NULL) {

            status = AllocateSingle1394Address(
                deviceObject,
                &DeviceExtension->Dummy,
                sizeof(DeviceExtension->Dummy),
                ACCESS_FLAGS_TYPE_READ | ACCESS_FLAGS_TYPE_WRITE,
                &DeviceExtension->DummyContext
                );

        if (!NT_SUCCESS(status)) {

            goto exitInit;
        }
    }

    //
    // Done
    //

    DEBUGPRINT2(("Sbp2Port: InitDevExt: ext=x%p\n", DeviceExtension));

exitInit:

    return status;
}


BOOLEAN
Sbp2CleanDeviceExtension(
    IN PDEVICE_OBJECT DeviceObject,
    BOOLEAN FreeLists
    )
/*++

Routine Description:

    Called when we get a remove, so it will free all used pool and all the resident Irps.
    It wil also free our FreeList of contexts and any complete any pending IO requests

Arguments:

    DeviceExtension = Sbp2 driver's extension
    FreeLists - TRUE means we cleanup EVERYTHING including our lookaside lists

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PFDO_DEVICE_EXTENSION fdoExtension = (PFDO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    KIRQL cIrql;
    PREQUEST_CONTEXT rContext;
    PADDRESS_FIFO statusFifoElement;
    ULONG i;
    BOOLEAN valid = FALSE;
    PIRBIRP packet;

    //
    // there are two types of cleanups. One for the PDO and one for the FDO(alot simpler)
    //

    if (deviceExtension->Type == SBP2_PDO) {

        //
        // make sure that this PDO is something in our list and that we have NOT deleted
        // it already....
        //

        fdoExtension = (PFDO_DEVICE_EXTENSION) deviceExtension->BusFdo->DeviceExtension;

        for (i = 0; i < fdoExtension->DeviceListSize; i++) {

            if (fdoExtension->DeviceList[i].DeviceObject == DeviceObject) {

                valid = TRUE;
            }
        }

        if (!valid) {

            return FALSE;
        }

        if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_INITIALIZED) ){

            //
            // stop the timer for any pending management requests
            //

            KeCancelTimer (&deviceExtension->DeviceManagementTimer);

            //
            // We have a list of requests pending, clean it up
            // The reset/logout has automatically made the target to discard any requests
            //

            CleanupOrbList (deviceExtension, STATUS_REQUEST_ABORTED);
        }

        //
        // after a bus reset we must reallocate at least one physical address to allow
        // the ohci driver to re-enable the physical address filters
        //

        if (deviceExtension->DummyContext.AddressHandle != NULL) {

            FreeAddressRange (deviceExtension,&deviceExtension->DummyContext);
        }

        if (FreeLists){

            if (TEST_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_INITIALIZED) ||
                TEST_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_INITIALIZING)){

                FreeAddressRange(deviceExtension,&deviceExtension->TaskOrbStatusContext);
                FreeAddressRange(deviceExtension,&deviceExtension->GlobalStatusContext);
#if PASSWORD_SUPPORT
                FreeAddressRange(deviceExtension,&deviceExtension->PasswordOrbStatusContext);
#endif
                FreeAddressRange(deviceExtension,&deviceExtension->ManagementOrbStatusContext);

                if (deviceExtension->PowerDeferredIrp) {

                    deviceExtension->PowerDeferredIrp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
                    IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
                    IoCompleteRequest (deviceExtension->PowerDeferredIrp, IO_NO_INCREMENT);
                    deviceExtension->PowerDeferredIrp = NULL;
                }

                if (deviceExtension->ManagementOrbContext.Reserved) {

                    ExFreePool(deviceExtension->ManagementOrbContext.Reserved);
                    deviceExtension->ManagementOrbContext.Reserved = NULL;
                }

#if PASSWORD_SUPPORT
                if (deviceExtension->PasswordOrbContext.Reserved) {

                    ExFreePool(deviceExtension->PasswordOrbContext.Reserved);
                    deviceExtension->PasswordOrbContext.Reserved = NULL;
                }
#endif
                if (deviceExtension->DeferredPowerRequest) {

                    deviceExtension->DeferredPowerRequest->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
                    IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
                    IoCompleteRequest(deviceExtension->DeferredPowerRequest, IO_NO_INCREMENT);
                    deviceExtension->DeferredPowerRequest = NULL;
                }

                if (deviceExtension->UniSymLinkName.Buffer) {

                    IoDeleteSymbolicLink(&deviceExtension->UniSymLinkName);
                    RtlFreeUnicodeString(&deviceExtension->UniSymLinkName);
                    deviceExtension->UniSymLinkName.Buffer = NULL;
                }

                //
                // before we go any further, check if the device is physically removed
                //

                if (!TEST_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_REMOVED)) {

                    DEBUGPRINT2(("Sbp2Port: Cleanup: ext=x%p, not freeing ALL wkg sets, dev present\n", deviceExtension));
                    return TRUE;

                } else {

                    DEBUGPRINT2(("Sbp2Port: Cleanup: ext=x%p, freeing ALL wkg sets\n", deviceExtension));
                }

                CLEAR_FLAG(deviceExtension->DeviceFlags, (DEVICE_FLAG_INITIALIZED | DEVICE_FLAG_INITIALIZING));

                //
                // OK to free common buffer if device is going away
                //

                FreeAddressRange(deviceExtension,&deviceExtension->CommonBufferContext);

                deviceExtension->OrbPoolContext.Reserved = NULL;

                //
                // Free all the page tables & async context buffer
                //

                if (deviceExtension->AsyncContextBase != NULL) {

                    for (i = 0; i < MAX_ORB_LIST_DEPTH; i++) {

                        PASYNC_REQUEST_CONTEXT context;


                        context = deviceExtension->AsyncContextBase + i;

                        if (context->PageTableContext.PageTable != NULL) {

                            //
                            // Common buffer, we didn't alloc the mdl,
                            // so zero the field to prevent our free'ing it
                            //

                            context->PageTableContext.AddressContext.
                                RequestMdl = NULL;

                            FreeAddressRange(
                                deviceExtension,
                                &context->PageTableContext.AddressContext
                                );
                        }
                    }

                    ExFreePool (deviceExtension->AsyncContextBase);
                    deviceExtension->AsyncContextBase = NULL;
                }

                //
                // free pool for status fifo list
                //

                if (deviceExtension->StatusFifoBase !=NULL ) {

                    statusFifoElement = (PVOID) ExInterlockedPopEntrySList (&deviceExtension->StatusFifoListHead,
                                                                  &deviceExtension->StatusFifoLock);
                    while (statusFifoElement){

                        DEBUGPRINT3(("Sbp2Port: Cleanup: freeing statusFifo=x%p, fifoBase=x%p\n",
                                    statusFifoElement,deviceExtension->StatusFifoBase));

                        IoFreeMdl (statusFifoElement->FifoMdl);
                        statusFifoElement = (PVOID) ExInterlockedPopEntrySList (&deviceExtension->StatusFifoListHead,
                                                                  &deviceExtension->StatusFifoLock);
                    };

                    ExFreePool (deviceExtension->StatusFifoBase);
                    deviceExtension->StatusFifoBase = NULL;
                }

                //
                // free the irb/irp and context slists
                //

                packet = (PIRBIRP) ExInterlockedPopEntrySList (&deviceExtension->BusRequestIrpIrbListHead,
                                                               &deviceExtension->BusRequestLock);
                while (packet) {

                    ExFreePool(packet->Irb);

                    if (packet->Irp->Type == IO_TYPE_IRP) {

                        IoFreeIrp(packet->Irp);
                    }

                    ExFreePool(packet);

                    packet = (PIRBIRP) ExInterlockedPopEntrySList (&deviceExtension->BusRequestIrpIrbListHead,
                                                                   &deviceExtension->BusRequestLock);
                };


                rContext = (PREQUEST_CONTEXT) ExInterlockedPopEntrySList (&deviceExtension->BusRequestContextListHead,
                                                                          &deviceExtension->BusRequestLock);

                while (rContext) {

                    ExFreePool (rContext);
                    rContext = (PREQUEST_CONTEXT) ExInterlockedPopEntrySList (&deviceExtension->BusRequestContextListHead,
                                                                              &deviceExtension->BusRequestLock);
                };

                if (deviceExtension->ReservedMdl) {

                    IoFreeMdl (deviceExtension->ReservedMdl);
                    deviceExtension->ReservedMdl = NULL;
                }

                //
                // free the model leaf
                //

                if (deviceExtension->DeviceInfo->ModelLeaf) {

                    ExFreePool (deviceExtension->DeviceInfo->ModelLeaf);
                    deviceExtension->DeviceInfo->ModelLeaf = NULL;
                }
            }
        }

    } else {

        fdoExtension = (PFDO_DEVICE_EXTENSION) deviceExtension;

        if (fdoExtension->Sbp2ObjectDirectory != NULL) {

            ZwMakeTemporaryObject (fdoExtension->Sbp2ObjectDirectory);
            ZwClose (fdoExtension->Sbp2ObjectDirectory);
            fdoExtension->Sbp2ObjectDirectory = NULL;
        }

        if (fdoExtension->VendorLeaf) {

            ExFreePool (fdoExtension->VendorLeaf);
            fdoExtension->VendorLeaf = NULL;
        }

        if (TEST_FLAG(fdoExtension->DeviceFlags,DEVICE_FLAG_REMOVED)) {

            return FALSE;

        } else {

            SET_FLAG (fdoExtension->DeviceFlags, DEVICE_FLAG_REMOVED);
        }

        if (fdoExtension->DeviceListSize != 0) {

            //
            // Disable bus reset notifications
            //

            AllocateIrpAndIrb ((PDEVICE_EXTENSION) fdoExtension, &packet);

            if (packet) {

                packet->Irb->FunctionNumber = REQUEST_BUS_RESET_NOTIFICATION;
                packet->Irb->Flags = 0;
                packet->Irb->u.BusResetNotification.fulFlags =
                    DEREGISTER_NOTIFICATION_ROUTINE;

                Sbp2SendRequest(
                    (PDEVICE_EXTENSION) fdoExtension,
                    packet,
                    SYNC_1394_REQUEST
                    );

                DeAllocateIrpAndIrb ((PDEVICE_EXTENSION) fdoExtension, packet);
            }
        }

        //
        // Clean up any remaining PDO's
        //

        KeAcquireSpinLock (&fdoExtension->DeviceListLock,&cIrql);

        for (; fdoExtension->DeviceListSize > 0; fdoExtension->DeviceListSize--) {

            i = fdoExtension->DeviceListSize - 1;

            if (fdoExtension->DeviceList[i].DeviceObject) {

                deviceExtension =
                    fdoExtension->DeviceList[i].DeviceObject->DeviceExtension;

                SET_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_REMOVED);

                DeviceObject = fdoExtension->DeviceList[i].DeviceObject;

                KeReleaseSpinLock (&fdoExtension->DeviceListLock, cIrql);

                if (Sbp2CleanDeviceExtension (DeviceObject, TRUE)) {

                    //
                    // Acquire the pdo's remove lock, start the queue
                    // cleanup, and and wait for io to complete.  Then
                    // delete the device & continue.
                    //

                    IoAcquireRemoveLock (&deviceExtension->RemoveLock, NULL);

                    KeRaiseIrql (DISPATCH_LEVEL, &cIrql);

                    Sbp2StartNextPacketByKey (DeviceObject, 0);

                    KeLowerIrql (cIrql);

                    DEBUGPRINT2((
                        "Sbp2Port: CleanDevExt: walking fdo, wait for " \
                            "io compl pdo=x%p...\n",
                        DeviceObject
                        ));

                    IoReleaseRemoveLockAndWait(
                        &deviceExtension->RemoveLock,
                        NULL
                        );

                    deviceExtension->Type = SBP2_PDO_DELETED;

                    KeCancelTimer(&deviceExtension->DeviceManagementTimer);

                    IoDeleteDevice (DeviceObject);

                    DEBUGPRINT2((
                        "Sbp2Port: CleanDevExt: ............ io compl," \
                            " deleted pdo=x%p\n",
                        DeviceObject
                        ));

                    KeAcquireSpinLock (&fdoExtension->DeviceListLock, &cIrql);

                    fdoExtension->DeviceList[i].DeviceObject = NULL;

                } else {

                    KeAcquireSpinLock (&fdoExtension->DeviceListLock, &cIrql);
                }
            }

            if (fdoExtension->DeviceList[i].ModelLeaf) {

                ExFreePool (fdoExtension->DeviceList[i].ModelLeaf);
                fdoExtension->DeviceList[i].ModelLeaf = NULL;
            }
        }

        KeReleaseSpinLock (&fdoExtension->DeviceListLock, cIrql);
    }

    return TRUE;
}


VOID
Sbp2Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Does nothing really...

Arguments:

    DriverObject - the driver being unloaded

Return Value:

    none

--*/
{
    DEBUGPRINT1(("Sbp2Port: unloading\n\n"));

    return;
}


VOID
Sbp2DeviceManagementTimeoutDpc(
    IN PKDPC Dpc,
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    ULONG                   i;
    PDEVICE_EXTENSION       pdoExtension;
    PFDO_DEVICE_EXTENSION   fdoExtension;


    if (Dpc != &DeviceExtension->DeviceManagementTimeoutDpc) {

        return;
    }

    if (TEST_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_REMOVED)) {

        return;
    }

    if (TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_RECONNECT)) {

        //
        // The flag indicates that a bus reset occured, and a reconnect never happened...
        // OR that the device is realy hose so we reset it and we need to re-login
        //

        DEBUGPRINT1((
            "Sbp2Port: RECONNECT timeout, Ext=x%p, Flags=x%x, doing re-login\n",
            DeviceExtension,
            DeviceExtension->DeviceFlags
            ));

        //
        // all the resident 1394 memory addresses's that we have, are
        // now invalidated... So we need to free them and re-allocate
        // them

        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->ExtensionDataSpinLock);
        CLEAR_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_RECONNECT);
        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->ExtensionDataSpinLock);

        //
        // If device is marked STOPPED then a target reset was
        // done and that affected all LUNs (spec sect 10.4.4).
        // So if this is a multilun device try logins on each
        // pdo as appropriate.
        //

        fdoExtension = (PFDO_DEVICE_EXTENSION)
            DeviceExtension->BusFdo->DeviceExtension;

        if ((fdoExtension->DeviceListSize > 1)  &&

            TEST_FLAG (DeviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED)) {

            for (i = 0; i < fdoExtension->DeviceListSize; i++) {

                pdoExtension = (PDEVICE_EXTENSION)
                    fdoExtension->DeviceList[i].DeviceObject->DeviceExtension;

                if (pdoExtension->DeviceObject ==
                        DeviceExtension->DeviceObject) {

                    // No need to update node info since no bus reset done

                    Sbp2ManagementTransaction(
                        pdoExtension,
                        TRANSACTION_LOGIN
                        );

                    continue;
                }

                KeAcquireSpinLockAtDpcLevel(
                    &pdoExtension->ExtensionDataSpinLock
                    );

                if (TEST_FLAG(
                        pdoExtension->DeviceFlags,
                        DEVICE_FLAG_INITIALIZED
                        )  &&

                    !TEST_FLAG(
                        pdoExtension->DeviceFlags,
                        DEVICE_FLAG_STOPPED | DEVICE_FLAG_RESET_IN_PROGRESS |
                        DEVICE_FLAG_REMOVED | DEVICE_FLAG_LOGIN_IN_PROGRESS |
                        DEVICE_FLAG_RECONNECT | DEVICE_FLAG_DEVICE_FAILED |
                        DEVICE_FLAG_SURPRISE_REMOVED
                        )) {

                    SET_FLAG(
                        pdoExtension->DeviceFlags,
                        (DEVICE_FLAG_STOPPED | DEVICE_FLAG_RESET_IN_PROGRESS)
                        );

                    KeReleaseSpinLockFromDpcLevel(
                        &pdoExtension->ExtensionDataSpinLock
                        );

                    CleanupOrbList (pdoExtension, STATUS_REQUEST_ABORTED);

                    // No need to update node info since no bus reset done

                    Sbp2ManagementTransaction(
                        pdoExtension,
                        TRANSACTION_LOGIN
                        );

                } else {

                    KeReleaseSpinLockFromDpcLevel(
                        &pdoExtension->ExtensionDataSpinLock
                        );
                }
            }

        } else {

            Sbp2UpdateNodeInformation (DeviceExtension);
            Sbp2ManagementTransaction (DeviceExtension, TRANSACTION_LOGIN);
        }

        return ;
    }


    if (TEST_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_LOGIN_IN_PROGRESS)) {

        ULONG flags;


        //
        // the asynchronous login attempt timed out. This is bad news and means the
        // device is not responding
        //

        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->ExtensionDataSpinLock);

        flags = DeviceExtension->DeviceFlags;

        CLEAR_FLAG(DeviceExtension->DeviceFlags,(DEVICE_FLAG_LOGIN_IN_PROGRESS | DEVICE_FLAG_RESET_IN_PROGRESS));
        SET_FLAG(DeviceExtension->DeviceFlags, (DEVICE_FLAG_STOPPED | DEVICE_FLAG_DEVICE_FAILED));

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->ExtensionDataSpinLock);

        //
        // check if we had a power irp deferred.. If we did call startio to abort it..
        //

        if (DeviceExtension->DeferredPowerRequest) {

            Sbp2StartIo(DeviceExtension->DeviceObject,DeviceExtension->DeferredPowerRequest);
            DeviceExtension->DeferredPowerRequest = NULL;
        }

        DEBUGPRINT1((
            "Sbp2Port: LOGIN timeout, Ext=x%p, Flags=x%x, device stopped\n",
            DeviceExtension,
            flags
            ));

        Sbp2StartNextPacketByKey (DeviceExtension->DeviceObject, 0);

        IoInvalidateDeviceState(DeviceExtension->DeviceObject);
        return;
    }


    if (TEST_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_RESET_IN_PROGRESS)) {

        //
        // the reset attempt has timed out
        //

        DEBUGPRINT1((
            "Sbp2Port: RESET timeout, Ext=x%p, Flags=x%x, ",
            DeviceExtension,
            DeviceExtension->DeviceFlags
            ));

        if (!TEST_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED)) {

            //
            // Second level of recovery, do a TARGET_RESET task function
            //

            DEBUGPRINT1(("doing target reset\n"));

            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->ExtensionDataSpinLock);

            SET_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED);
            DeviceExtension->MaxOrbListDepth = max(MIN_ORB_LIST_DEPTH,DeviceExtension->MaxOrbListDepth/2);

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->ExtensionDataSpinLock);

            CleanupOrbList(DeviceExtension,STATUS_REQUEST_ABORTED);

            //
            // we are close to timing out a reset, try a hard reset
            //

            Sbp2Reset (DeviceExtension->DeviceObject, TRUE);
            return;

        } else {

            //
            // Third level of recovery. Do a hardware node reset
            //

            DEBUGPRINT1(("doing CMD_RESET and relogin.\n"));

            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->ExtensionDataSpinLock);

            DeviceExtension->Reserved = 0;
            SET_FLAG(DeviceExtension->DeviceFlags, (DEVICE_FLAG_RESET_IN_PROGRESS | DEVICE_FLAG_RECONNECT | DEVICE_FLAG_STOPPED));

            DeviceExtension->DueTime.HighPart = -1;
            DeviceExtension->DueTime.LowPart = SBP2_RELOGIN_DELAY;
            KeSetTimer(&DeviceExtension->DeviceManagementTimer,DeviceExtension->DueTime, &DeviceExtension->DeviceManagementTimeoutDpc);

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->ExtensionDataSpinLock);
            Sbp2AccessRegister(DeviceExtension,&DeviceExtension->Reserved,CORE_RESET_REG | REG_WRITE_ASYNC);

            return;
        }
    }
}


VOID
Sbp2RequestTimeoutDpc(
    IN PKDPC Dpc,
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Our Device object
    Context - DeviceExtension

Return Value:
    NTSTATUS

--*/
{
    PIRP requestIrp = NULL;
    PASYNC_REQUEST_CONTEXT current = NULL;
    PASYNC_REQUEST_CONTEXT next = NULL;

#if DBG

    ULONG xferLen;
    UCHAR cdb[6];

#endif

    //
    // return if device is stopped, but since reset can occur while device is stopped
    // thats why this check is ater the reset timing code
    //

    if (IsListEmpty (&DeviceExtension->PendingOrbList)) {

        return ;
    }

    //
    // search the linked list of contexts, to see which guy timed out
    //

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->OrbListSpinLock);

    next = RETRIEVE_CONTEXT(DeviceExtension->PendingOrbList.Flink,OrbList);

    do {

        current = next;
        if ((&current->TimerDpc == Dpc) && (current->Flags & ASYNC_CONTEXT_FLAG_TIMER_STARTED)) {

            if (TEST_FLAG(current->Flags,ASYNC_CONTEXT_FLAG_COMPLETED)) {

                DEBUGPRINT1(("Sbp2Port: ReqTimeoutDpc: timeout, but req already compl!!\n" ));
                KeReleaseSpinLockFromDpcLevel(&DeviceExtension->OrbListSpinLock);
                return;
            }

            //
            // this is the timed out request
            // do an abort Task Set
            //

            CLEAR_FLAG(current->Flags,ASYNC_CONTEXT_FLAG_TIMER_STARTED);

            KeCancelTimer(&current->Timer);

#if DBG
            xferLen = current->Srb->DataTransferLength;
            cdb[0] = current->Srb->Cdb[0];
            cdb[1] = current->Srb->Cdb[1];
            cdb[2] = current->Srb->Cdb[2];
            cdb[3] = current->Srb->Cdb[3];
            cdb[4] = current->Srb->Cdb[4];
            cdb[5] = current->Srb->Cdb[5];
#endif

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->OrbListSpinLock);

            Sbp2CreateRequestErrorLog(DeviceExtension->DeviceObject,current,STATUS_TIMEOUT);

            if (!TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_RESET_IN_PROGRESS)){

                DEBUGPRINT1((
                    "Sbp2Port: ReqTimeoutDpc: cdb=x%02x %02x %02x %02x %02x " \
                        "%02x, len=x%x\n",
                    cdb[0],
                    cdb[1],
                    cdb[2],
                    cdb[3],
                    cdb[4],
                    cdb[5],
                    xferLen
                    ));

                Sbp2Reset (DeviceExtension->DeviceObject, FALSE);
            }

            return;
        }

        next = (PASYNC_REQUEST_CONTEXT) current->OrbList.Flink;

    } while ( current != RETRIEVE_CONTEXT(DeviceExtension->PendingOrbList.Blink,OrbList));

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->OrbListSpinLock);

    return;
}


VOID
Sbp2Reset(
    PDEVICE_OBJECT DeviceObject,
    BOOLEAN HardReset
    )
/*++

Routine Description:

    Used to implement SBP2 high level recovery mechanisms. It will issue an ABORT_TASK_SET if HardReset == FALSE
    otherswise it will issue a RESET_TARGET. Its all done asynchronously and out timer DPC will track the requests
    to check if they timed out...

Arguments:

    DeviceObject= Sbp2 driver's device object
    HardReset = Type of recovery to perform, TRUE is a target reset, FALSE is an abort task set

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    KIRQL oldIrql;
    NTSTATUS status;
#if DBG
    ULONG generation;
#endif


    if ((deviceExtension->DeviceFlags & DEVICE_FLAG_REMOVED) ||
        (deviceExtension->DeviceFlags & DEVICE_FLAG_RECONNECT)) {

        return;
    }

    if (HardReset == TRUE) {

        DEBUGPRINT2(("Sbp2Port: Reset: ext=x%p, do target reset\n", deviceExtension ));

        //
        // Do a target reset
        //

        KeAcquireSpinLock (&deviceExtension->ExtensionDataSpinLock,&oldIrql);

        deviceExtension->TaskOrbContext.TransactionType = TRANSACTION_TARGET_RESET;
        deviceExtension->TaskOrb->OrbInfo.QuadPart = 0;
        deviceExtension->TaskOrb->OrbInfo.u.HighPart |= ORB_NOTIFY_BIT_MASK;
        deviceExtension->TaskOrb->OrbInfo.u.HighPart |= 0x00FF & TRANSACTION_TARGET_RESET;

        deviceExtension->TaskOrb->OrbInfo.u.LowPart =
            deviceExtension->LoginResponse->LengthAndLoginId.u.LowPart; // LOGIN ID

        deviceExtension->TaskOrb->StatusBlockAddress.BusAddress =
            deviceExtension->TaskOrbStatusContext.Address.BusAddress;

        //
        // endian conversion
        //

        octbswap (deviceExtension->TaskOrb->StatusBlockAddress);

        deviceExtension->TaskOrb->OrbInfo.QuadPart =
            bswap(deviceExtension->TaskOrb->OrbInfo.QuadPart);

        //
        // send the task ORB , mark start of reset/abort
        //

        deviceExtension->DeviceFlags |= DEVICE_FLAG_RESET_IN_PROGRESS;

        //
        // now set the timer to track this request
        //

        deviceExtension->DueTime.HighPart = -1;
        deviceExtension->DueTime.LowPart = SBP2_HARD_RESET_TIMEOUT;
        KeSetTimer(&deviceExtension->DeviceManagementTimer,deviceExtension->DueTime,&deviceExtension->DeviceManagementTimeoutDpc);

        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,oldIrql);

        status = Sbp2AccessRegister(deviceExtension, &deviceExtension->TaskOrbContext.Address, MANAGEMENT_AGENT_REG | REG_WRITE_ASYNC);

        if (status == STATUS_INVALID_GENERATION) {

            KeCancelTimer(&deviceExtension->DeviceManagementTimer);

#if DBG
            //
            // Check to see if perhaps we didn't get the reset
            // notification we were expecting
            //

            generation = deviceExtension->CurrentGeneration;

            status = Sbp2UpdateNodeInformation (deviceExtension);

            DEBUGPRINT1((
                "Sbp2Port: Reset:  target reset error, sts=x%x, extGen=x%x, " \
                    "curGen=x%x\n",
                status,
                generation,
                deviceExtension->CurrentGeneration
                ));
#endif
            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&oldIrql);

            SET_FLAG(deviceExtension->DeviceFlags, (DEVICE_FLAG_STOPPED | DEVICE_FLAG_DEVICE_FAILED));

            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,oldIrql);

            //
            // check if we had a power irp deferred.. If we did call startio to abort it..
            //

            if (deviceExtension->DeferredPowerRequest) {

                Sbp2StartIo(deviceExtension->DeviceObject,deviceExtension->DeferredPowerRequest);
                deviceExtension->DeferredPowerRequest = NULL;
            }

            Sbp2StartNextPacketByKey (deviceExtension->DeviceObject, 0);

            return;
        }

    } else {

        DEBUGPRINT2(("Sbp2Port: Reset: ext=x%p, do abort task set\n", deviceExtension ));

        //
        // Do an abort task set
        //

        KeAcquireSpinLock (&deviceExtension->ExtensionDataSpinLock,&oldIrql);

        deviceExtension->TaskOrbContext.TransactionType = TRANSACTION_ABORT_TASK_SET;
        deviceExtension->TaskOrb->OrbInfo.QuadPart = 0;
        deviceExtension->TaskOrb->OrbInfo.u.HighPart |= ORB_NOTIFY_BIT_MASK;
        deviceExtension->TaskOrb->OrbInfo.u.HighPart |= 0x00FF & TRANSACTION_ABORT_TASK_SET;

        deviceExtension->TaskOrb->OrbInfo.u.LowPart =
            deviceExtension->LoginResponse->LengthAndLoginId.u.LowPart; // LOGIN ID

        deviceExtension->TaskOrb->StatusBlockAddress.BusAddress =
            deviceExtension->TaskOrbStatusContext.Address.BusAddress;

        //
        // endian conversion
        //

        octbswap (deviceExtension->TaskOrb->StatusBlockAddress);

        deviceExtension->TaskOrb->OrbInfo.QuadPart =
            bswap (deviceExtension->TaskOrb->OrbInfo.QuadPart);

        //
        // send the task ORB , mark start of reset/abort
        //

        deviceExtension->DeviceFlags |= DEVICE_FLAG_RESET_IN_PROGRESS;

        //
        // now set the timer to track this request
        //

        deviceExtension->DueTime.HighPart = -1;
        deviceExtension->DueTime.LowPart = SBP2_RESET_TIMEOUT;
        KeSetTimer(&deviceExtension->DeviceManagementTimer,deviceExtension->DueTime,&deviceExtension->DeviceManagementTimeoutDpc);

        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,oldIrql);

        Sbp2AccessRegister(deviceExtension, &deviceExtension->TaskOrbContext.Address, MANAGEMENT_AGENT_REG | REG_WRITE_ASYNC);
    }
}


NTSTATUS
Sbp2DeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the device control dispatcher.

Arguments:

    DeviceObject
    Irp

Return Value:


    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    if (deviceExtension->Type == SBP2_PDO) {

        switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_STORAGE_QUERY_PROPERTY: {
            //
            // Validate the query
            //

            PSTORAGE_PROPERTY_QUERY query = Irp->AssociatedIrp.SystemBuffer;

            if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
               sizeof(STORAGE_PROPERTY_QUERY)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            status = Sbp2QueryProperty(DeviceObject, Irp);


            break;
        }
        case IOCTL_SCSI_PASS_THROUGH:
        case IOCTL_SCSI_PASS_THROUGH_DIRECT:

            status = Sbp2SendPassThrough(deviceExtension, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;

        case IOCTL_SBP2_REQUEST:

            status = Sbp2HandleApiRequest(deviceExtension, Irp);

            break;

        default:

            DEBUGPRINT3(("Sbp2Port: Sbp2DeviceControl: Irp Not Handled.\n" ));
            status = STATUS_NOT_SUPPORTED;
            Irp->IoStatus.Status =status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);

            break;
        }

    } else {

        status = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Status =status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
    }

    return status;
}


NTSTATUS
Sbp2HandleApiRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSBP2_REQUEST sbp2Req;
    NTSTATUS status;


    status = IoAcquireRemoveLock (&DeviceExtension->RemoveLock, NULL);

    if (!NT_SUCCESS (status)) {

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        return status;
    }

    if (Irp->RequestorMode == KernelMode) {

        sbp2Req = irpStack->Parameters.Others.Argument1;

    } else { // UserMode

        sbp2Req = Irp->AssociatedIrp.SystemBuffer;
    }

    if (sbp2Req == NULL) {

        DEBUGPRINT1(("Sbp2Port: HandleApiReq: Invalid sbp2Req!"));
        status = STATUS_INVALID_PARAMETER;
        goto Exit_Sbp2HandleApiRequest;
    }

    status = STATUS_NOT_IMPLEMENTED;

    switch (sbp2Req->RequestNumber) {

    case SBP2_REQUEST_RETRIEVE_TEXT_LEAFS:

        //
        // Only allow kernel-mode requests of this type, since the
        // RetrieveTextLeaf definition currently has us passing
        // back a buf alloc'd via ExAllocPool - not something we
        // want to hand back to user-mode.
        //

        if (Irp->RequestorMode == KernelMode) {

            status = Sbp2Get1394ConfigInfo(
                (PFDO_DEVICE_EXTENSION)
                    DeviceExtension->BusFdo->DeviceExtension,
                sbp2Req
                );
        }

        break;

    case SBP2_REQUEST_ACCESS_TRANSPORT_SETTINGS:

        switch (sbp2Req->u.AccessTransportSettings.Parameter) {

        case SBP2REQ_ACCESS_SETTINGS_QUEUE_SIZE:

            if (sbp2Req->Flags & SBP2REQ_FLAG_RETRIEVE_VALUE) {

                sbp2Req->u.AccessTransportSettings.Value =
                    DeviceExtension->MaxOrbListDepth;

            } else if (sbp2Req->Flags & SBP2REQ_FLAG_MODIFY_VALUE) {

                DeviceExtension->MaxOrbListDepth = min(
                    MAX_ORB_LIST_DEPTH,
                    sbp2Req->u.AccessTransportSettings.Value
                    );

                DeviceExtension->MaxOrbListDepth = max(
                    MIN_ORB_LIST_DEPTH,
                    sbp2Req->u.AccessTransportSettings.Value
                    );

                sbp2Req->u.AccessTransportSettings.Value =
                    DeviceExtension->MaxOrbListDepth;
            }

            status = STATUS_SUCCESS;

            break;
        }

        break;

#if PASSWORD_SUPPORT

    case SBP2_REQUEST_SET_PASSWORD:

        if (sbp2Req->u.SetPassword.fulFlags == SBP2REQ_SET_PASSWORD_CLEAR) {

            DEBUGPRINT1(("Sbp2Port: Setting Password to Clear\n"));

            status = Sbp2SetPasswordTransaction(
                DeviceExtension,
                SBP2REQ_SET_PASSWORD_CLEAR
                );

            if (NT_SUCCESS(status)) {

                DeviceExtension->Exclusive = EXCLUSIVE_FLAG_CLEAR;
            }

        } else if (sbp2Req->u.SetPassword.fulFlags ==
                        SBP2REQ_SET_PASSWORD_EXCLUSIVE) {

            DEBUGPRINT1 (("Sbp2Port: HandleApiReq: set passwd to excl\n"));

            status = Sbp2SetPasswordTransaction(
                DeviceExtension,
                SBP2REQ_SET_PASSWORD_EXCLUSIVE
                );

            if (NT_SUCCESS(status)) {

                DeviceExtension->Exclusive = EXCLUSIVE_FLAG_SET;
            }

        } else {

            DEBUGPRINT1((
                "Sbp2Port: HandleApiReq: set passwd, inval fl=x%x\n",
                sbp2Req->u.SetPassword.fulFlags
                ));

            status = STATUS_INVALID_PARAMETER;
            goto Exit_Sbp2HandleApiRequest;
        }

        Sbp2SetExclusiveValue(
             DeviceExtension->DeviceObject,
             &DeviceExtension->Exclusive
             );

        DEBUGPRINT1((
            "Sbp2Port: HandleApiReq: set passwd sts=x%x\n",
            status
            ));

        break;

#endif

    default:

        status = STATUS_INVALID_PARAMETER;
        break;
    }

Exit_Sbp2HandleApiRequest:

    Irp->IoStatus.Status = status;
    IoReleaseRemoveLock (&DeviceExtension->RemoveLock, NULL);
    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return status;
}


NTSTATUS
Sbp2CreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    create and close routine.  This is called by the I/O system
    when the device is opened or closed. The sbp2 driver will do login and logout on
    create/close respectively

Arguments:

    DeviceObject - Pointer to device object for this miniport

    Irp - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;


    if (deviceExtension->Type == SBP2_PDO) {

        if ((deviceExtension->InquiryData.DeviceType == PRINTER_DEVICE) ||
            (deviceExtension->InquiryData.DeviceType == SCANNER_DEVICE)){

            if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_INITIALIZING)) {

                status = IoAcquireRemoveLock(
                    &deviceExtension->RemoveLock,
                    NULL
                    );

                if (!NT_SUCCESS (status)) {

                    goto Sbp2CreateClose_CompleteReq;
                }

                switch (irpStack->MajorFunction) {

                case IRP_MJ_CREATE:

                    DEBUGPRINT2(("Sbp2Port: Sbp2CreateClose: OPEN_REQUEST, handle cound %d.\n", deviceExtension->HandleCount));

                    if (deviceExtension->DeviceFlags & DEVICE_FLAG_STOPPED) {

                        //
                        // do a login.
                        //

                        DEBUGPRINT2(("Sbp2Port: Sbp2CreateClose: LOGIN.\n" ));
                        status = Sbp2ManagementTransaction(deviceExtension,TRANSACTION_LOGIN);

                        if (status == STATUS_SUCCESS) {

                            //
                            // make retry limit high for busy transactions
                            //

                            deviceExtension->Reserved = BUSY_TIMEOUT_SETTING;
                            Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,CORE_BUSY_TIMEOUT_REG | REG_WRITE_SYNC);

                            //
                            // We are ready to receive and pass down requests, init the target's
                            // fetch agent.
                            //

                            Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,AGENT_RESET_REG | REG_WRITE_ASYNC);

                            deviceExtension->DeviceFlags &= ~DEVICE_FLAG_STOPPED;

                            InterlockedIncrement(&deviceExtension->HandleCount);
                        }

                    } else {

                        InterlockedIncrement(&deviceExtension->HandleCount);
                    }

                    break;

                case IRP_MJ_CLOSE:

                    if (deviceExtension->HandleCount) {

                        InterlockedDecrement(&deviceExtension->HandleCount);
                    }

                    DEBUGPRINT2(("Sbp2Port: Sbp2CreateClose: CLOSE_REQUEST, handle cound %d.\n", deviceExtension->HandleCount));

                    if (!(deviceExtension->DeviceFlags & (DEVICE_FLAG_REMOVED | DEVICE_FLAG_STOPPED)) &&
                        !deviceExtension->HandleCount) {

                        //
                        // Logout
                        //

                        DEBUGPRINT2(("Sbp2Port: Sbp2CreateClose: LOGIN OUT.\n" ));

                        deviceExtension->DeviceFlags |= DEVICE_FLAG_STOPPED;

                        Sbp2ManagementTransaction(deviceExtension,TRANSACTION_LOGOUT);

                        CleanupOrbList(deviceExtension,STATUS_REQUEST_ABORTED);
                    }

                    break;
                }

                IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
            }
        } // device type check

    } else if (deviceExtension->Type != SBP2_FDO) {

        status = STATUS_NO_SUCH_DEVICE;
    }

Sbp2CreateClose_CompleteReq:

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, 0);
    return status;
}


NTSTATUS
Sbp2PnpDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    This routine handles the PNP requests (primarily for PDO's)

Arguments:

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

   NTSTATUS

--*/
{
    KIRQL                   cIrql;
    PULONG                  count;
    NTSTATUS                status;
    UNICODE_STRING          unicodeIdString;
    PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;
    PDEVICE_RELATIONS       deviceRelations;
    PIO_STACK_LOCATION      irpStack = IoGetCurrentIrpStackLocation (Irp);
    PDEVICE_CAPABILITIES    deviceCapabilities;
    PFDO_DEVICE_EXTENSION   fdoExtension;

#if DBG

    const char * minorFuncs[] =
    {
        "START_DEV,           ",
        "QUERY_REMOVE_DEV,    ",
        "REMOVE_DEV,          ",
        "CANCEL_REMOVE_DEV,   ",
        "STOP_DEV,            ",
        "QUERY_STOP_DEV,      ",
        "CANCEL_STOP_DEV,     ",
        "QUERY_DEV_RELATIONS, ",
        "QUERY_INTERFACE,     ",
        "QUERY_CAPABILITIES,  ",
        "QUERY_RESOURCES,     ",
        "QUERY_RESOURCE_REQS, ",
        "QUERY_DEV_TEXT,      ",
        "FILTER_RESOURCE_REQS,",
        "??,                  ",    // 0xd (14)
        "READ_CFG,            ",
        "WRITE_CFG,           ",
        "EJECT,               ",
        "SET_LOCK,            ",
        "QUERY_ID,            ",
        "QUERY_PNP_DEV_STATE, ",
        "QUERY_BUS_INFO,      ",
        "DEV_USAGE_NOTIF,     ",
        "SURPRISE_REMOVAL,    ",
        "QUERY_LEG_BUS_INFO,  "     // 0x18
    };

    DEBUGPRINT2((
        "Sbp2Port: Pnp: [x%02x] %s %sdoX=x%p, fl=x%x\n",
        irpStack->MinorFunction,
        (irpStack->MinorFunction <= 0x18 ?
            minorFuncs[irpStack->MinorFunction] : minorFuncs[14]),
        (deviceExtension->Type == SBP2_PDO ? "p" :
            (deviceExtension->Type == SBP2_FDO ? "f" : "???")),
        deviceExtension,
        deviceExtension->DeviceFlags
        ));

#endif

    //
    // We may receive an IRP_MN_BUS_RESET before our AddDevice
    // has completed. Check to make sure our DeviceObject is
    // initialized before we allow processing of PNP Irps.
    //
    if (DeviceObject->Flags & DO_DEVICE_INITIALIZING) {

        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_NO_SUCH_DEVICE);
    }

    switch (deviceExtension->Type) {

    case SBP2_PDO:

        break;

    case SBP2_FDO:

        return Sbp2FDOPnpDeviceControl (DeviceObject, Irp);

    default:

        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, NULL);

    if (!NT_SUCCESS (status)) {

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
        return status;
    }

    switch (irpStack->MinorFunction) {

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        DEBUGPRINT3((
            "Sbp2Port: Pnp: ... Type = %x\n",
            irpStack->Parameters.QueryDeviceRelations.Type
            ));

        //
        // Fill in the DeviceRelations array with this PDO,
        // reference it, and return.
        //

        if (irpStack->Parameters.QueryDeviceRelations.Type !=
                TargetDeviceRelation) {

            status = Irp->IoStatus.Status;

            break;
        }

        if (Irp->IoStatus.Information) {

            deviceRelations = (PDEVICE_RELATIONS)Irp->IoStatus.Information;

        } else {

            deviceRelations = ExAllocatePool(
                PagedPool,
                sizeof (*deviceRelations)
                );

            if (!deviceRelations) {

                Irp->IoStatus.Status = status = STATUS_INSUFFICIENT_RESOURCES;
                Irp->IoStatus.Information = 0;

                break;
            }

            deviceRelations->Count = 0;
        }

        deviceRelations->Objects[deviceRelations->Count] = DeviceObject;
        deviceRelations->Count++;

        ObReferenceObject (DeviceObject);

        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

        break;

    case IRP_MN_QUERY_DEVICE_TEXT:

        Irp->IoStatus.Status = Sbp2QueryDeviceText(
            deviceExtension,
            irpStack->Parameters.QueryDeviceText.DeviceTextType,
            irpStack->Parameters.QueryDeviceText.LocaleId,
            (PWSTR *) &Irp->IoStatus.Information
            );

        status = Irp->IoStatus.Status;

        break;

    case IRP_MN_QUERY_ID:

        //
        // We've been asked for the id of one of the physical device objects
        //

        RtlInitUnicodeString (&unicodeIdString, NULL);

        switch (irpStack->Parameters.QueryId.IdType) {

        case BusQueryDeviceID:

            status = Sbp2GetDeviceId (DeviceObject, &unicodeIdString);
            break;

        case BusQueryInstanceID:

            status = Sbp2GetInstanceId (DeviceObject, &unicodeIdString);
            break;

        case BusQueryHardwareIDs:

            status = Sbp2GetMultipleIds (DeviceObject, &unicodeIdString, TRUE);
            break;

        case BusQueryCompatibleIDs:

            status = Sbp2GetMultipleIds (DeviceObject, &unicodeIdString,FALSE);
            break;

        default:

            status = STATUS_NOT_SUPPORTED;
            break;
        }

        Irp->IoStatus.Status = status;

        if(NT_SUCCESS(status)) {

            Irp->IoStatus.Information = (ULONG_PTR) unicodeIdString.Buffer;

        } else {

            Irp->IoStatus.Information = (ULONG_PTR) NULL;
        }

        break;

    case IRP_MN_QUERY_CAPABILITIES:

        deviceCapabilities =
            irpStack->Parameters.DeviceCapabilities.Capabilities;

        //
        // Settings consistent across all 1394 devices
        //

        deviceCapabilities->Removable = TRUE;
        deviceCapabilities->UniqueID = TRUE;
        deviceCapabilities->SilentInstall = TRUE;

        //
        // Settings for different types of devices.  We are very
        // familar with SCSI-variant devices and can make some
        // good choices here, but for other devices we'll leave
        // these choices up to the higher-level driver(s).
        //

        switch (deviceExtension->DeviceInfo->CmdSetId.QuadPart) {

        case 0x10483:
        case SCSI_COMMAND_SET_ID:

            switch ((deviceExtension->DeviceInfo->Lun.u.HighPart & 0x001F)) {

            case PRINTER_DEVICE:
            case SCANNER_DEVICE:

                deviceCapabilities->RawDeviceOK = FALSE;
                deviceCapabilities->SurpriseRemovalOK = TRUE;
                break;

            default:

                deviceCapabilities->RawDeviceOK = TRUE;
                break;
            }

            break;

        default:

            break;
        }

        deviceCapabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;
        deviceCapabilities->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
        deviceCapabilities->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
        deviceCapabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
        deviceCapabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
        deviceCapabilities->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

        deviceCapabilities->SystemWake = PowerSystemUnspecified;
        deviceCapabilities->DeviceWake = PowerDeviceUnspecified;
        deviceCapabilities->D1Latency  = 1 * (1000 * 10);     // 1 sec
        deviceCapabilities->D2Latency  = 1 * (1000 * 10);     // 1
        deviceCapabilities->D3Latency  = 1 * (1000 * 10);     // 1

        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;

        break;

    case IRP_MN_START_DEVICE:

        status = Sbp2StartDevice (DeviceObject);

        Irp->IoStatus.Status = status;

        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:

        status = Irp->IoStatus.Status = STATUS_SUCCESS;

        break;

    case IRP_MN_STOP_DEVICE:

        //
        // Disable bus reset notifications
        //

        Sbp2EnableBusResetNotification (deviceExtension, FALSE);


        //
        // disable idle detection
        //

        PoRegisterDeviceForIdleDetection (DeviceObject, 0L, 0L, PowerDeviceD3);

        //
        // Cleanup
        //

        KeAcquireSpinLock (&deviceExtension->ExtensionDataSpinLock, &cIrql);

        if (!TEST_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED)) {

            SET_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_PNP_STOPPED | DEVICE_FLAG_STOPPED)
                );

            KeReleaseSpinLock (&deviceExtension->ExtensionDataSpinLock, cIrql);

            fdoExtension = (PFDO_DEVICE_EXTENSION)
                deviceExtension->BusFdo->DeviceExtension;

            ASSERT(!fdoExtension->ulWorkItemCount);

            ExAcquireFastMutex(&fdoExtension->ResetMutex);
            Sbp2ManagementTransaction (deviceExtension,TRANSACTION_LOGOUT);
            ExReleaseFastMutex(&fdoExtension->ResetMutex);

            Sbp2CleanDeviceExtension (DeviceObject,FALSE);

        } else {

            SET_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_PNP_STOPPED);

            KeReleaseSpinLock (&deviceExtension->ExtensionDataSpinLock, cIrql);
        }

        Irp->IoStatus.Status = status = STATUS_SUCCESS;

        ASSERT(!deviceExtension->ulPendingEvents);
        ASSERT(!deviceExtension->ulInternalEventCount);
        break;

    case IRP_MN_BUS_RESET:

        //
        // Start of a PHY reset. We will re-connect asynchronously to the
        // target when our callback is called, so this is ignored..
        //
        // After a bus reset is complete, the bus driver should call our
        // BusResetNotification callback. When it does, we will attempt
        // to reconnect. If the reconnect completion status callback,
        // never fires, it means the following things:
        //
        // 1) The device never completed the RECONNECT, or
        // 2) The device completed the reconnect but because our
        //    controlller was BUSY or hosed we didnt get it
        //
        // If 1 or 2 happens, the timeout DPC queued in our bus reset
        // notification, should fire and attempt a relogin...
        //

        Irp->IoStatus.Status = status = STATUS_SUCCESS;

        break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:

        if (TEST_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_REMOVED | DEVICE_FLAG_DEVICE_FAILED)
                ) &&

            !TEST_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_RESET_IN_PROGRESS
                )){

            //
            // Set DEVICE_FLAG_REPORTED_FAILED so the SURPRISE_REMOVE
            // handler knows it didn't get called because of physical
            // hardware removal
            //

            KeAcquireSpinLock (&deviceExtension->ExtensionDataSpinLock,&cIrql);

            SET_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_REPORTED_FAILED
                );

            KeReleaseSpinLock (&deviceExtension->ExtensionDataSpinLock, cIrql);

            //
            // indicate our device is disabled due to a failure..
            //

            Irp->IoStatus.Information |= PNP_DEVICE_FAILED;

            DEBUGPRINT2((
                "Sbp2Port: Pnp: QUERY_DEVICE_STATE, device FAILED!!!\n"
                ));
        }

        status = Irp->IoStatus.Status = STATUS_SUCCESS;

        break;

    case IRP_MN_DEVICE_USAGE_NOTIFICATION:

        switch (irpStack->Parameters.UsageNotification.Type) {

        case DeviceUsageTypeDumpFile:

            count = &deviceExtension->CrashDumpCount;
            break;

        case DeviceUsageTypePaging:

            count = &deviceExtension->PagingPathCount;
            break;

        case DeviceUsageTypeHibernation:

            count = &deviceExtension->HibernateCount;
            break;

        default:

            count = NULL;
            break;
        }

        if (count) {

            IoAdjustPagingPathCount(
                count,
                irpStack->Parameters.UsageNotification.InPath
                );
        }

        status = Irp->IoStatus.Status = STATUS_SUCCESS;

        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        if (deviceExtension->PagingPathCount ||
            deviceExtension->HibernateCount  ||
            deviceExtension->CrashDumpCount) {

            status = Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;

        } else {

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            SET_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_REMOVE_PENDING);
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);
            status = Irp->IoStatus.Status = STATUS_SUCCESS;
        }

        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_REMOVE_PENDING);
        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        status = Irp->IoStatus.Status = STATUS_SUCCESS;

        break;

    case IRP_MN_REMOVE_DEVICE:

        status = STATUS_SUCCESS;

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);

        SET_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_PNP_STOPPED);

        if (TEST_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_SURPRISE_REMOVED
                )) {

            //
            // We already cleaned up in SURPRISE_REMOVAL handler.
            // Empty out the queue, wait for io to complete, then
            // delete the device, complete the request, & return.
            //

            KeReleaseSpinLock(
                &deviceExtension->ExtensionDataSpinLock,
                cIrql
                );

            KeRaiseIrql (DISPATCH_LEVEL, &cIrql);

            Sbp2StartNextPacketByKey (DeviceObject, 0);

            KeLowerIrql (cIrql);

            DEBUGPRINT2((
                "Sbp2Port: Pnp: wait for io compl pdo=x%p...\n",
                DeviceObject
                ));

            IoReleaseRemoveLockAndWait (&deviceExtension->RemoveLock, NULL);

            deviceExtension->Type = SBP2_PDO_DELETED;

            KeCancelTimer(&deviceExtension->DeviceManagementTimer);

            IoDeleteDevice (DeviceObject);

            DEBUGPRINT2((
                "Sbp2Port: Pnp: ......... deleted pdo=x%p\n", DeviceObject
                ));

            Irp->IoStatus.Status = status;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);

            return status;
        }

        if (TEST_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_REMOVE_PENDING
                )) {

            KeReleaseSpinLock (&deviceExtension->ExtensionDataSpinLock, cIrql);

            //
            // If device is initialized & MgmtOrbCtx event is still around
            // then do a log out
            //

            if (TEST_FLAG(
                    deviceExtension->DeviceFlags,
                    DEVICE_FLAG_INITIALIZED
                    ) &&

                deviceExtension->ManagementOrbContext.Reserved) {

                DEBUGPRINT1((
                    "Sbp2Port: Pnp: LOG OUT, since QUERY preceded RMV\n"
                    ));

                fdoExtension = (PFDO_DEVICE_EXTENSION)
                    deviceExtension->BusFdo->DeviceExtension;

                ExAcquireFastMutex(&fdoExtension->ResetMutex);
                Sbp2ManagementTransaction(deviceExtension,TRANSACTION_LOGOUT);
                ExReleaseFastMutex(&fdoExtension->ResetMutex);
            }

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);

            CLEAR_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_REMOVE_PENDING
                );

            SET_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED);

        } else if (!TEST_FLAG(
                        deviceExtension->DeviceFlags,
                        (DEVICE_FLAG_REMOVED | DEVICE_FLAG_DEVICE_FAILED)
                        )){

            //
            // If no query has preceded and NO SUPRISE_REMOVAL has preceded
            // this means we are running under win98, where physical device
            // removals are only indicated by only MN_REMOVES being sent,
            // with no QUERY_REMOVE prior to the remove.
            //

            if (deviceExtension->DeviceFlags ==
                    (DEVICE_FLAG_INITIALIZING | DEVICE_FLAG_STOPPED)  &&
                !SystemIsNT) {

                DEBUGPRINT1((
                    "Sbp2Port: Pnp: 9x REMOVE, don't delete dev\n"
                    ));

                deviceExtension->DeviceFlags =
                    DEVICE_FLAG_UNSTARTED_AND_REMOVED;

            } else {

                SET_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_REMOVED);

                CLEAR_FLAG(
                    deviceExtension->DeviceFlags,
                    DEVICE_FLAG_RESET_IN_PROGRESS | DEVICE_FLAG_RECONNECT |
                        DEVICE_FLAG_LOGIN_IN_PROGRESS
                    );

                DEBUGPRINT1((
                    "Sbp2Port: Pnp: Suprise removal, since QUERY " \
                        "did not precede REMOVE.\n"
                    ));
            }
        }

        CLEAR_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_CLAIMED);

        KeReleaseSpinLock (&deviceExtension->ExtensionDataSpinLock, cIrql);

        if (!Sbp2CleanDeviceExtension (DeviceObject, TRUE)) {

            DEBUGPRINT1(("Sbp2Port: Pnp: Double remove\n"));
        }

        //
        // In all cases other than surprise removals, pdo's will get
        // deleted by the fdo remove handler
        //

        Irp->IoStatus.Status = status;

        break;

    case IRP_MN_SURPRISE_REMOVAL: {

        //
        // If device was reported failed (due to async login failure &
        // IoInvalidateDeviceState) then just set REMOVED & PNP_STOPPED
        // flags and clean up the device extension - we don't want to
        // delete the pdo at this point.
        //
        // Otherwise, assume physical device removal occured, in which
        // case we need to do our own cleanup & teardown right here
        // because the dev stack will start disintegrating.
        //
        // ISSUE: Per AdriaO, another case where we can get a
        //        SURPRISE_REMOVAL is if a START fails *after* a STOP
        //        - at any point in this pdo's stack!  Not sure how to
        //        tell whether or not this is the case if it's not
        //        SBP2PORT that failed the START, so leaving that case
        //        as is for now.  DanKn, 04-Jun-2001
        //

        BOOLEAN reportedMissing;

        KeAcquireSpinLock (&deviceExtension->ExtensionDataSpinLock, &cIrql);

        if (TEST_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_REPORTED_FAILED
                )) {

            SET_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_REMOVED | DEVICE_FLAG_PNP_STOPPED)
                );

            reportedMissing = FALSE;

        } else {

            SET_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_REMOVED | DEVICE_FLAG_SURPRISE_REMOVED |
                    DEVICE_FLAG_PNP_STOPPED)
                );

            reportedMissing = TRUE;
        }

        CLEAR_FLAG(
            deviceExtension->DeviceFlags,
            (DEVICE_FLAG_RESET_IN_PROGRESS | DEVICE_FLAG_RECONNECT |
                DEVICE_FLAG_LOGIN_IN_PROGRESS | DEVICE_FLAG_REPORTED_FAILED)
            );

        KeReleaseSpinLock (&deviceExtension->ExtensionDataSpinLock, cIrql);

        Sbp2CleanDeviceExtension (DeviceObject, TRUE);

        if (reportedMissing) {

            Sbp2HandleRemove (DeviceObject);
        }

        Irp->IoStatus.Status = STATUS_SUCCESS;

        break;
    }
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

        //
        // PnP walks up the device tree looking for the FILE_CHAR flags,
        // and stops when it finds a node marked Removable. Since our pdo's
        // are marked Removable, PnP won't make it to a BUS1394 PDO, so we
        // need to propagate the FILE_CHAR flags here.
        //

        fdoExtension = (PFDO_DEVICE_EXTENSION)
            deviceExtension->BusFdo->DeviceExtension;

        DeviceObject->Characteristics |=
            (FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK &
            fdoExtension->Pdo->Characteristics);

        status = Irp->IoStatus.Status;

        break;

    default:

        status = Irp->IoStatus.Status;

        break;
    }

    //
    // This is the bottom of the stack, complete the request
    //

    IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
Sbp2FDOPnpDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    This routine handles the PNP requests for FDO's

Arguments:

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

   NTSTATUS

--*/
{
    KEVENT                  event;
    NTSTATUS                status;
    PDEVICE_RELATIONS       deviceRelations;
    PIO_STACK_LOCATION      irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_CAPABILITIES    deviceCapabilities;
    PFDO_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock(&fdoExtension->RemoveLock, NULL);

    if (!NT_SUCCESS(status)) {

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
        return status;
    }

    switch (irpStack->MinorFunction) {

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        DEBUGPRINT3((
            "Sbp2Port: Pnp: ... Type = %x\n",
            irpStack->Parameters.QueryDeviceRelations.Type
            ));

        if (irpStack->Parameters.QueryDeviceRelations.Type != BusRelations) {

            break;
        }

        deviceRelations = ExAllocatePool(
            PagedPool,
            sizeof (*deviceRelations) +
                (SBP2_MAX_LUNS_PER_NODE * sizeof (PDEVICE_OBJECT))
            );

        if (!deviceRelations) {

            DEBUGPRINT1 (("Sbp2Port: Pnp: devRels alloc failed!!\n"));

            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;

            IoCompleteRequest (Irp, IO_NO_INCREMENT);
            return (STATUS_INSUFFICIENT_RESOURCES);
        }

        status = Sbp2CreateDeviceRelations (fdoExtension, deviceRelations);
        Irp->IoStatus.Status = status;

        if (NT_SUCCESS(status)) {

            Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

        } else {

            Irp->IoStatus.Information = 0;

            IoCompleteRequest (Irp, IO_NO_INCREMENT);
            return status;
        }

        break;

    case IRP_MN_QUERY_CAPABILITIES:

        deviceCapabilities =
            irpStack->Parameters.DeviceCapabilities.Capabilities;

        deviceCapabilities->SurpriseRemovalOK = TRUE;

        break;

    case IRP_MN_START_DEVICE:

        KeInitializeEvent (&event, SynchronizationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine(
            Irp,
            Sbp2FdoRequestCompletionRoutine,
            (PVOID) &event,
            TRUE,
            TRUE,
            TRUE
            );

        status = IoCallDriver (fdoExtension->LowerDeviceObject, Irp);

        if(!NT_SUCCESS(Irp->IoStatus.Status) && (status != STATUS_PENDING)) {

            status = Irp->IoStatus.Status;

        } else {

            KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

            status = Sbp2StartDevice (DeviceObject);
        }

        IoReleaseRemoveLock(&fdoExtension->RemoveLock, NULL);

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

        return status;

    case IRP_MN_REMOVE_DEVICE:

        KeInitializeEvent (&event, SynchronizationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
            Irp,
            Sbp2FdoRequestCompletionRoutine,
            (PVOID) &event,
            TRUE,
            TRUE,
            TRUE
            );

        status = IoCallDriver (fdoExtension->LowerDeviceObject, Irp);

        if (!NT_SUCCESS (Irp->IoStatus.Status) && status != STATUS_PENDING) {

            status = Irp->IoStatus.Status;

        } else {

            KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

            //
            // do FDO cleanup..
            //

            IoReleaseRemoveLockAndWait(&fdoExtension->RemoveLock, NULL);

            if (Sbp2CleanDeviceExtension (DeviceObject, TRUE)) {

                ASSERT(!fdoExtension->ulBusResetMutexCount);
                ASSERT(!fdoExtension->ulWorkItemCount);

                IoDetachDevice (fdoExtension->LowerDeviceObject);
                IoDeleteDevice (DeviceObject);
            }

            status = STATUS_SUCCESS;
        }

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);

        return status;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:

        Irp->IoStatus.Information |= PNP_DEVICE_DONT_DISPLAY_IN_UI;

        break;

    default:

        break;
    }

    IoReleaseRemoveLock(&fdoExtension->RemoveLock, NULL);

    //
    // Pass the irp down the stack
    //

    IoCopyCurrentIrpStackLocationToNext (Irp);

    status = IoCallDriver (fdoExtension->LowerDeviceObject, Irp);

    return status;
}


VOID
Sbp2HandleRemove(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PFDO_DEVICE_EXTENSION fdoExtension;
    KIRQL cIrql;
    ULONG i,j;
    PIRBIRP packet;


    fdoExtension = (PFDO_DEVICE_EXTENSION) deviceExtension->BusFdo->DeviceExtension;

    if (!TEST_FLAG (deviceExtension->DeviceFlags,DEVICE_FLAG_REMOVED)) {

        return;
    }

    //
    // now we need to remove ourselves from the DeviceList, the sbp2 FDO keeps of its
    // children...
    // then we re-condense the list..
    //

    KeAcquireSpinLock (&fdoExtension->DeviceListLock,&cIrql);

    if (fdoExtension->DeviceListSize > 1) {

        DEBUGPRINT1(("\'Sbp2Cleanup, condensing PDO list\n"));

        for (i = 0; i < fdoExtension->DeviceListSize; i++) {

            if (fdoExtension->DeviceList[i].DeviceObject == DeviceObject) {

                //
                // free the model descriptor only if its not the same as the FDOs
                // this only happens in the multi-lu case
                //

                if (fdoExtension->DeviceList[i].ModelLeaf) {

                    ExFreePool(fdoExtension->DeviceList[i].ModelLeaf);
                    fdoExtension->DeviceList[i].ModelLeaf = NULL;
                }

                //
                // we found our place in the list. Remove us and re-condense the list
                //

                for (j = i; j < fdoExtension->DeviceListSize; j++) {

                    if ((j + 1) < fdoExtension->DeviceListSize) {

                        fdoExtension->DeviceList[j] = fdoExtension->DeviceList[j+1];

                        //
                        // Change the (pdo)DevExt->DeviceInfo to point at
                        // the next postion in the device list
                        //

                        deviceExtension = fdoExtension->DeviceList[j].
                            DeviceObject->DeviceExtension;

                        deviceExtension->DeviceInfo =
                            &fdoExtension->DeviceList[j];
                    }
                }

                fdoExtension->DeviceListSize--;
            }
        }

    } else {

        if (fdoExtension->DeviceList[0].DeviceObject == DeviceObject) {

            if (fdoExtension->DeviceList[0].ModelLeaf) {

                ExFreePool(fdoExtension->DeviceList[0].ModelLeaf);
                fdoExtension->DeviceList[0].ModelLeaf = NULL;
            }
        }

        fdoExtension->DeviceList[0].DeviceObject = NULL;
        fdoExtension->DeviceListSize = 0;

        CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_INITIALIZED);
    }

    if (fdoExtension->DeviceListSize == 0) {

        //
        // all our children have been deleted, set our FDO to be inactive
        // so it can not re create  PDOs qhen it receives a QDR.
        // The reaosn is that if our PDOS are all removed, we dont support
        // dynamic changes ot the crom, which would then warrant us being
        //  able to eject PDOs again.
        //

        SET_FLAG(fdoExtension->DeviceFlags, DEVICE_FLAG_STOPPED);

        KeReleaseSpinLock (&fdoExtension->DeviceListLock, cIrql);

        //
        // Disable bus reset notifications
        //

        AllocateIrpAndIrb ((PDEVICE_EXTENSION) fdoExtension, &packet);

        if (packet) {

            packet->Irb->FunctionNumber = REQUEST_BUS_RESET_NOTIFICATION;
            packet->Irb->Flags = 0;
            packet->Irb->u.BusResetNotification.fulFlags = DEREGISTER_NOTIFICATION_ROUTINE;

            Sbp2SendRequest(
                (PDEVICE_EXTENSION) fdoExtension,
                packet,
                SYNC_1394_REQUEST
                );

            DeAllocateIrpAndIrb((PDEVICE_EXTENSION)fdoExtension,packet);
        }

        fdoExtension->NumPDOsStarted = 0;

    } else {

        KeReleaseSpinLock (&fdoExtension->DeviceListLock, cIrql);
    }
}


NTSTATUS
Sbp2FdoRequestCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

{
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
Sbp2CreateDeviceRelations(
    IN PFDO_DEVICE_EXTENSION FdoExtension,
    IN PDEVICE_RELATIONS DeviceRelations
    )
{
    ULONG i;
    NTSTATUS status;
    ULONG instanceNum;

    PAGED_CODE();

    //
    // LUNS are static in the Config Rom. so if our DeviceListSize >0, that objetc
    // has been seen before
    //

    DeviceRelations->Count = 0;

    status = Sbp2Get1394ConfigInfo (FdoExtension, NULL);

    if (!NT_SUCCESS(status)) {

        ExFreePool (DeviceRelations);
        return status;
    }

    if (TEST_FLAG (FdoExtension->DeviceFlags,DEVICE_FLAG_STOPPED)) {

        ExFreePool(DeviceRelations);
        return STATUS_UNSUCCESSFUL;
    }

    for (i = 0; i < FdoExtension->DeviceListSize; i++) {

        if (!FdoExtension->DeviceList[i].DeviceObject) {

            instanceNum = 0;

            do {

                status = Sbp2CreatePdo (FdoExtension,&FdoExtension->DeviceList[i],instanceNum++);

            } while (status == STATUS_OBJECT_NAME_COLLISION);

            if (!NT_SUCCESS(status)) {

                DEBUGPRINT1(("\'Sbp2CreateDeviceRelations, Failed to create PDO \n"));

                ExFreePool (DeviceRelations);
                return status;
            }

            DeviceRelations->Objects[DeviceRelations->Count] = FdoExtension->DeviceList[i].DeviceObject;
            DeviceRelations->Count++;
            ObReferenceObject (FdoExtension->DeviceList[i].DeviceObject);

        } else {

            //
            // On NT we always add existing pdo's to the dev relations list.
            //
            // On 9x, we only add pdo's to the list whose DevFlags field
            // is non-zero. If we see a pdo with a zero DevFlags field
            // then that means it was never started (likely for lack of
            // a driver), and we don't want to re-indicate it to the caller.
            // The pdo will eventually get deleted when cleaning up the fdo.
            //

            if (!SystemIsNT) {

                PDEVICE_EXTENSION   pdoExtension;


                pdoExtension = (PDEVICE_EXTENSION)
                    FdoExtension->DeviceList[i].DeviceObject->DeviceExtension;

                if (pdoExtension->DeviceFlags &
                        DEVICE_FLAG_UNSTARTED_AND_REMOVED) {

                    ASSERT(pdoExtension->DeviceFlags == DEVICE_FLAG_UNSTARTED_AND_REMOVED);

                    DEBUGPRINT2((
                        "Sbp2Port: CreateDevRelations: excluding ext=x%x\n",
                        pdoExtension
                        ));

                    continue;
                }
            }

            DeviceRelations->Objects[DeviceRelations->Count] =
                FdoExtension->DeviceList[i].DeviceObject;
            DeviceRelations->Count++;
            ObReferenceObject (FdoExtension->DeviceList[i].DeviceObject);
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
Sbp2QueryDeviceText(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN DEVICE_TEXT_TYPE TextType,
    IN LCID LocaleId,
    IN OUT PWSTR *DeviceText
    )
{
    UCHAR ansiBuffer[256];
    ANSI_STRING ansiText;
    ULONG byteSwappedData;

    UNICODE_STRING unicodeText;

    NTSTATUS status;

    PAGED_CODE();


    RtlInitUnicodeString(&unicodeText, NULL);

    if (TextType == DeviceTextDescription) {

        RtlZeroMemory(ansiBuffer, sizeof(ansiBuffer));

        if (DeviceExtension->DeviceInfo->VendorLeaf && DeviceExtension->DeviceInfo->ModelLeaf) {

            byteSwappedData = bswap(*(((PULONG) DeviceExtension->DeviceInfo->VendorLeaf+1)));

            if (byteSwappedData & 0x80000000) {

                sprintf(ansiBuffer, "%ws %ws IEEE 1394 SBP2 Device",
                        &DeviceExtension->DeviceInfo->VendorLeaf->TL_Data,
                        &DeviceExtension->DeviceInfo->ModelLeaf->TL_Data);

            } else {

                sprintf(ansiBuffer, "%s %s IEEE 1394 SBP2 Device",
                        &DeviceExtension->DeviceInfo->VendorLeaf->TL_Data,
                        &DeviceExtension->DeviceInfo->ModelLeaf->TL_Data);
            }

        } else {

            sprintf(ansiBuffer, "UNKNOWN VENDOR AND MODEL IEEE 1394 SBP2 Device");
        }

    } else if (TextType == DeviceTextLocationInformation) {

        sprintf(ansiBuffer, "LUN %d",
                DeviceExtension->DeviceInfo->Lun.u.LowPart);

    } else {

        return STATUS_NOT_SUPPORTED;
    }

    RtlInitAnsiString(&ansiText, ansiBuffer);

    status = RtlAnsiStringToUnicodeString (&unicodeText, &ansiText, TRUE);

    *DeviceText = unicodeText.Buffer;

    return status;
}


//
// code below ported from scsiport
//


NTSTATUS
Sbp2GetDeviceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    )
/*++

Routine Description:

    This routine will allocate space for and fill in a device id string for
    the specified Pdo.  This string is generated from the protocol type (sbp2) and
    the type of the device.

Arguments:

    Pdo - a pointer to the physical device object being queried

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension = Pdo->DeviceExtension;

    UCHAR buffer[1024];
    PUCHAR rawIdString = buffer;
    ANSI_STRING ansiIdString;

    ULONG byteSwappedData;

    PAGED_CODE();


    ASSERT(UnicodeString != NULL);

    if (deviceExtension->DeviceInfo->VendorLeaf && deviceExtension->DeviceInfo->ModelLeaf) {

        byteSwappedData = bswap(*(((PULONG) deviceExtension->DeviceInfo->VendorLeaf+1)));

        if (byteSwappedData & 0x80000000) {

            RtlZeroMemory(buffer, sizeof(buffer));

            sprintf(rawIdString,
                    "SBP2\\%ws&%ws&LUN%x",
                    &deviceExtension->DeviceInfo->VendorLeaf->TL_Data,
                    &deviceExtension->DeviceInfo->ModelLeaf->TL_Data,
                    (deviceExtension->DeviceInfo->Lun.u.LowPart));

            rawIdString += strlen(rawIdString);

            ASSERT(*rawIdString == '\0');

            RtlInitAnsiString(&ansiIdString, buffer);

            DEBUGPRINT2(("Sbp2Port: GetDevId: pdo=x%p, id=%Z\n",
                        Pdo, &ansiIdString));

            return RtlAnsiStringToUnicodeString(UnicodeString, &ansiIdString, TRUE);

        } else {

            RtlZeroMemory(buffer, sizeof(buffer));

            sprintf(rawIdString,
                    "SBP2\\%s&%s&LUN%x",
                    &deviceExtension->DeviceInfo->VendorLeaf->TL_Data,
                    &deviceExtension->DeviceInfo->ModelLeaf->TL_Data,
                    (deviceExtension->DeviceInfo->Lun.u.LowPart));

            rawIdString += strlen(rawIdString);

            ASSERT(*rawIdString == '\0');

            RtlInitAnsiString(&ansiIdString, buffer);

            DEBUGPRINT2(("Sbp2Port: GetDevId: pdo=x%p id=%Z\n",
                        Pdo, &ansiIdString));

            return RtlAnsiStringToUnicodeString(UnicodeString, &ansiIdString, TRUE);
        }

    } else {

        RtlZeroMemory(buffer, sizeof(buffer));

        sprintf(rawIdString,
                "SBP2\\UNKNOWN VENDOR&UNKNOWN MODEL&LUN%x",
                (deviceExtension->DeviceInfo->Lun.u.LowPart));

        rawIdString += strlen(rawIdString);

        ASSERT(*rawIdString == '\0');

        RtlInitAnsiString(&ansiIdString, buffer);

        DEBUGPRINT2(("Sbp2Port: GetDevId: pdo=x%p id=%Z\n",
                    Pdo, &ansiIdString));

        return RtlAnsiStringToUnicodeString(UnicodeString, &ansiIdString, TRUE);
    }
}


NTSTATUS
Sbp2GetInstanceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    )
/*++

Routine Description:

    This routine will allocate space for and fill in an instance id string for
    the specified Pdo.  This string will be generated either from the device
    type + serial number of the device (if it has a serial number) or from
    the address of the device.

Arguments:

    Pdo - a pointer to the physical device object being queried

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension = Pdo->DeviceExtension;

    UCHAR idStringBuffer[64];
    ANSI_STRING ansiIdString;

    PAGED_CODE();


    ASSERT(UnicodeString != NULL);

    sprintf(idStringBuffer,
            "%08x%08x",
            bswap(deviceExtension->DeviceInfo->ConfigRom->CR_Node_UniqueID[0]),
            bswap(deviceExtension->DeviceInfo->ConfigRom->CR_Node_UniqueID[1])
            );

    RtlInitAnsiString(&ansiIdString, idStringBuffer);

    DEBUGPRINT2(("Sbp2Port: GetInstId: pdo=x%p id=%Z\n",
                Pdo, &ansiIdString));

    return RtlAnsiStringToUnicodeString(UnicodeString, &ansiIdString, TRUE);
}


#define MAX_STRING_SIZE 512


NTSTATUS
Sbp2GetMultipleIds(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString,
    BOOLEAN HwIds
    )
/*++

Routine Description:

    This routine will allocate space for and fill in a compatible id multi
    string for the specified Pdo.  This string is generated using the protocol and
    device types for the device

Arguments:

    Pdo - a pointer to the physical device object being queried

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension = Pdo->DeviceExtension;
    NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;
    ULONG byteSwappedData;

    PSTR stringBuffer[6];


    PAGED_CODE();


    stringBuffer[0] = ExAllocatePoolWithTag (PagedPool,MAX_STRING_SIZE,'2pbs');

    if (stringBuffer[0] == NULL) {

        return status;
    }

    if (!HwIds) {

        //
        // Compat ID's, return the following string :
        //
        // 1. SBP2\<CmdSetSpecId,base10>&<CmdSetId,base10>&<Lun,base10>
        //

        sprintf(stringBuffer[0],
                "SBP2\\%d&%d&%d",
                deviceExtension->DeviceInfo->CmdSetSpecId.QuadPart,
                deviceExtension->DeviceInfo->CmdSetId.QuadPart,
                (ULONG) (deviceExtension->DeviceInfo->Lun.u.HighPart & 0x001F));

        stringBuffer[1] = NULL;

        status = Sbp2StringArrayToMultiString (UnicodeString, stringBuffer);

        goto FreeString0;
    }

    stringBuffer[1] = ExAllocatePoolWithTag (PagedPool,MAX_STRING_SIZE,'2pbs');

    if (stringBuffer[1] == NULL) {

        goto FreeString0;
    }

    stringBuffer[2] = ExAllocatePoolWithTag (PagedPool,MAX_STRING_SIZE,'2pbs');

    if (stringBuffer[2] == NULL) {

        goto FreeString1;
    }

    stringBuffer[3] = ExAllocatePoolWithTag (PagedPool,MAX_STRING_SIZE,'2pbs');

    if (stringBuffer[3] == NULL) {

        goto FreeString2;
    }

    stringBuffer[4] = ExAllocatePoolWithTag (PagedPool,MAX_STRING_SIZE,'2pbs');

    if (stringBuffer[4] == NULL) {

        goto FreeString3;
    }

    stringBuffer[5] = NULL;


    //
    // Hardware ID's, return the folowing strings
    //
    // 1. SBP2\<Vendor>&<Model>&CmdSetId<number,base16>&Gen<dev type, ie. Disk>
    // 2. SBP2\<Vendor>&<Model>&CmdSetId<number,base16>
    // 3. SBP2\<Vendor>&<Model>&LUN<number,base16>
    // 4. SBP2\Gen<dev type, i.e. Disk>
    // 5. Gen<dev type, i.e Disk>
    //

    if (deviceExtension->DeviceInfo->VendorLeaf && deviceExtension->DeviceInfo->ModelLeaf) {

        byteSwappedData = bswap(*(((PULONG) deviceExtension->DeviceInfo->VendorLeaf+1)));

        if (byteSwappedData & 0x80000000) {

            //
            // strings are already in unicode..
            //

            sprintf(stringBuffer[0],
                    "SBP2\\%ws&%ws&CmdSetId%x&%s",
                    &deviceExtension->DeviceInfo->VendorLeaf->TL_Data,
                    &deviceExtension->DeviceInfo->ModelLeaf->TL_Data,
                    deviceExtension->DeviceInfo->CmdSetId.QuadPart,
                    deviceExtension->DeviceInfo->GenericName);

            sprintf(stringBuffer[1],
                    "SBP2\\%ws&%ws&CmdSetId%x",
                    &deviceExtension->DeviceInfo->VendorLeaf->TL_Data,
                    &deviceExtension->DeviceInfo->ModelLeaf->TL_Data,
                    deviceExtension->DeviceInfo->CmdSetId.QuadPart);

            sprintf(stringBuffer[2],
                    "SBP2\\%ws&%ws&LUN%x",
                    &deviceExtension->DeviceInfo->VendorLeaf->TL_Data,
                    &deviceExtension->DeviceInfo->ModelLeaf->TL_Data,
                    deviceExtension->DeviceInfo->Lun.u.LowPart);

        } else {

            sprintf(stringBuffer[0],
                    "SBP2\\%s&%s&CmdSetId%x&%s",
                    &deviceExtension->DeviceInfo->VendorLeaf->TL_Data,
                    &deviceExtension->DeviceInfo->ModelLeaf->TL_Data,
                    deviceExtension->DeviceInfo->CmdSetId.QuadPart,
                    deviceExtension->DeviceInfo->GenericName);

            sprintf(stringBuffer[1],
                    "SBP2\\%s&%s&CmdSetId%x",
                    &deviceExtension->DeviceInfo->VendorLeaf->TL_Data,
                    &deviceExtension->DeviceInfo->ModelLeaf->TL_Data,
                    deviceExtension->DeviceInfo->CmdSetId.QuadPart);

            sprintf(stringBuffer[2],
                    "SBP2\\%s&%s&LUN%x",
                    &deviceExtension->DeviceInfo->VendorLeaf->TL_Data,
                    &deviceExtension->DeviceInfo->ModelLeaf->TL_Data,
                    deviceExtension->DeviceInfo->Lun.u.LowPart);
        }

    } else {

        sprintf(stringBuffer[0],
                "SBP2\\UNKNOWN VENDOR&UNKNOWN MODEL&CmdSetId%x&%s",
                deviceExtension->DeviceInfo->CmdSetId.QuadPart,
                deviceExtension->DeviceInfo->GenericName);

        sprintf(stringBuffer[1],
                "SBP2\\UNKNOWN VENDOR&UNKNOWN MODEL&CmdSetId%x",
                deviceExtension->DeviceInfo->CmdSetId.QuadPart);

        sprintf(stringBuffer[2],
                "SBP2\\UNKNOWN VENDOR&UNKNOWN MODEL&LUN%x",
                deviceExtension->DeviceInfo->Lun.u.LowPart);
    }

    sprintf(stringBuffer[3],
            "SBP2\\%s",
            deviceExtension->DeviceInfo->GenericName);

    sprintf(stringBuffer[4],
            "%s",
            deviceExtension->DeviceInfo->GenericName);

    status = Sbp2StringArrayToMultiString (UnicodeString, stringBuffer);


    ExFreePool (stringBuffer[4]);

FreeString3:

    ExFreePool (stringBuffer[3]);

FreeString2:

    ExFreePool (stringBuffer[2]);

FreeString1:

    ExFreePool (stringBuffer[1]);

FreeString0:

    ExFreePool (stringBuffer[0]);

    return status;
}


NTSTATUS
Sbp2StringArrayToMultiString(
    PUNICODE_STRING MultiString,
    PCSTR StringArray[]
    )
/*++

Routine Description:

    This routine will take a null terminated array of ascii strings and merge
    them together into a unicode multi-string block.

    This routine allocates memory for the string buffer - is the caller's
    responsibility to free it.

Arguments:

    MultiString - a UNICODE_STRING structure into which the multi string will
                  be built.

    StringArray - a NULL terminated list of narrow strings which will be combined
                  together.  This list may not be empty.

Return Value:

    status

--*/
{
    ANSI_STRING ansiEntry;
    UNICODE_STRING unicodeEntry;
    UCHAR i;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Make sure we aren't going to leak any memory
    //

    ASSERT(MultiString->Buffer == NULL);

    RtlInitUnicodeString(MultiString, NULL);

    for (i = 0; StringArray[i] != NULL; i++) {

        RtlInitAnsiString(&ansiEntry, StringArray[i]);

        MultiString->Length += (USHORT) RtlAnsiStringToUnicodeSize(&ansiEntry);
    }

    ASSERT(MultiString->Length != 0);

    MultiString->MaximumLength = MultiString->Length + sizeof(UNICODE_NULL);

    MultiString->Buffer = ExAllocatePoolWithTag(PagedPool,
                                                MultiString->MaximumLength,
                                                '2pbs');

    if(MultiString->Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(MultiString->Buffer, MultiString->MaximumLength);

    unicodeEntry = *MultiString;

    for (i = 0; StringArray[i] != NULL; i++) {

        RtlInitAnsiString(&ansiEntry, StringArray[i]);

        status = RtlAnsiStringToUnicodeString(
                    &unicodeEntry,
                    &ansiEntry,
                    FALSE);

        //
        // Push the buffer location up and reduce the maximum count
        //

        ((PSTR) unicodeEntry.Buffer) += unicodeEntry.Length + sizeof(WCHAR);
        unicodeEntry.MaximumLength -= unicodeEntry.Length + sizeof(WCHAR);
    };

    return STATUS_SUCCESS;
}


NTSTATUS
Sbp2SystemControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    This routine handles only the WMI related requests. It mostly passes everything down

Arguments:

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

   NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;


    if (deviceExtension->Type == SBP2_FDO) {

        DEBUGPRINT2(("Sbp2Port: WmiCtl: irp=x%p not handled, passing it down\n", Irp));

        IoCopyCurrentIrpStackLocationToNext(Irp);
        return (IoCallDriver(deviceExtension->LowerDeviceObject, Irp));

    } else {

        status = Irp->IoStatus.Status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }
}

/* ******************************* POWER MANAGEMENT ********************************/


NTSTATUS
Sbp2PowerControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine receives the various Power messages

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PFDO_DEVICE_EXTENSION   fdoExtension;
    PIO_STACK_LOCATION irpStack;
    PIO_COMPLETION_ROUTINE complRoutine;
    KIRQL cIrql;
    NTSTATUS status;
    POWER_STATE State;
    UCHAR minorFunction;


    irpStack = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);

    DEBUGPRINT2((
        "Sbp2Port: Power: %sExt=x%p, irp=x%p, minor=x%x\n",
        (deviceExtension->Type == SBP2_FDO ? "fdo" : "pdo"),
        deviceExtension,
        Irp,
        irpStack->MinorFunction
        ));

    switch (deviceExtension->Type) {

    case SBP2_PDO:

        status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, NULL);

        if (!NT_SUCCESS (status)) {

            DEBUGPRINT2((
                "Sbp2Port: Power:   pdoExt=x%p REMOVED!\n",
                deviceExtension
                ));

            Irp->IoStatus.Status = status;
            PoStartNextPowerIrp (Irp);
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
            return status;
        }

        switch ((minorFunction = irpStack->MinorFunction)) {

        case IRP_MN_SET_POWER:

            DEBUGPRINT2(("Sbp2Port: Power:   Type = %d, State = %d\n",
                irpStack->Parameters.Power.Type,irpStack->Parameters.Power.State.DeviceState));

            State = irpStack->Parameters.Power.State;

            if (irpStack->Parameters.Power.Type == SystemPowerState) {

                BOOLEAN sendDIrp = FALSE;


                //
                // make up a device state to correspond to a system state
                //

                DEBUGPRINT2(("Sbp2Port: Power:   sys power chg from %x to %x\n",deviceExtension->SystemPowerState,State));

                status = STATUS_SUCCESS;

                KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);

                if (State.SystemState >= PowerSystemShutdown) {

                    //
                    // dont do anything for shutdown
                    //

                    DEBUGPRINT2(("Sbp2Port: Power:   sys shutdown, ignoring\n"));
                    deviceExtension->SystemPowerState = State.SystemState;

                } else if ((deviceExtension->SystemPowerState == PowerSystemWorking) &&
                    (State.SystemState != PowerSystemWorking)){

                    deviceExtension->SystemPowerState = State.SystemState;

                    if (deviceExtension->DevicePowerState != PowerDeviceD3) {

                        //
                        // Powering down
                        //

                        State.DeviceState = PowerDeviceD3;
                        sendDIrp = TRUE;
                    }

                } else if (State.SystemState == PowerSystemWorking) {

                    deviceExtension->SystemPowerState = State.SystemState;

                    if (deviceExtension->DevicePowerState != PowerDeviceD0) {

                        //
                        // Powering up - check for an absent fdo
                        //

                        fdoExtension =
                            deviceExtension->BusFdo->DeviceExtension;

                        if (TEST_FLAG(
                                fdoExtension->DeviceFlags,
                                DEVICE_FLAG_ABSENT_ON_POWER_UP
                                )) {

                            SET_FLAG(
                                deviceExtension->DeviceFlags,
                                DEVICE_FLAG_ABSENT_ON_POWER_UP
                                );

                            DEBUGPRINT1((
                                "Sbp2Port: Power:   dev absent, failing\n"
                                ));

                            status = STATUS_NO_SUCH_DEVICE;

                        } else {

                            State.DeviceState = PowerDeviceD0;
                            sendDIrp = TRUE;
                        }
                    }
                }

                KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

                if (sendDIrp) {

                    DEBUGPRINT2((
                        "Sbp2Port: Power:   ext=x%p send D irp for state %d\n",
                        deviceExtension,
                        State
                        ));

                    IoMarkIrpPending (Irp);

                    status = PoRequestPowerIrp(
                            DeviceObject,
                            IRP_MN_SET_POWER,
                            State,
                            Sbp2PdoDIrpCompletion,
                            Irp,
                            NULL);

                    if (NT_SUCCESS (status)) {

                        return STATUS_PENDING;
                    }

                    irpStack->Control &= ~SL_PENDING_RETURNED;

                    DEBUGPRINT1((
                        "Sbp2Port: Power: ext=x%p PoReqPowerIrp err=x%x\n",
                        deviceExtension,
                        status
                        ));
                }

                Irp->IoStatus.Status = status;
                PoStartNextPowerIrp (Irp);
                IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
                IoCompleteRequest(Irp,IO_NO_INCREMENT);
                return status;

            } else {

                DEBUGPRINT2(("Sbp2Port: Power:   dev power chg from %x to %x\n",deviceExtension->DevicePowerState,State));
                KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
                deviceExtension->DevicePowerState = State.DeviceState;
                KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);
            }

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_WAIT_WAKE:
        case IRP_MN_POWER_SEQUENCE:
        case IRP_MN_QUERY_POWER:

            status = STATUS_SUCCESS;
            break;

        default:

            status = Irp->IoStatus.Status;
            break;
        }

        Irp->IoStatus.Status = status;
        PoStartNextPowerIrp (Irp);
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

        if ((minorFunction == IRP_MN_SET_POWER) &&
            (State.DeviceState == PowerDeviceD0)) {

            //
            // restart our queue if we had to queue something while powering up
            //
            // ISSUE: This may be bad - there is already some logic in
            //        SBP2SCSI.C to restart the queue on power up, i.e.
            //        the UNLOCK_QUEUE handler. For now i am at least
            //        limiting this to SET_POWER irps when state is D0
            //        DanKn 02-Jun-2001
            //

            KeRaiseIrql (DISPATCH_LEVEL, &cIrql);

            Sbp2StartNextPacketByKey(
                DeviceObject,
                deviceExtension->CurrentKey
                );

            KeLowerIrql (cIrql);
        }

        IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);

        return (status);

    case SBP2_FDO:

        fdoExtension = (PFDO_DEVICE_EXTENSION) deviceExtension;

        complRoutine = NULL;

        if (irpStack->MinorFunction == IRP_MN_SET_POWER) {

            DEBUGPRINT2((
                "Sbp2Port: Power:   Type = %d, State = %d\n",
                irpStack->Parameters.Power.Type,
                irpStack->Parameters.Power.State.DeviceState
                ));

            if (irpStack->Parameters.Power.Type == SystemPowerState) {

                State = irpStack->Parameters.Power.State;

                DEBUGPRINT2((
                    "Sbp2Port: Power:   sys power chg from %x to %x\n",
                    fdoExtension->SystemPowerState,
                    State
                    ));

                if (State.SystemState >= PowerSystemShutdown) {

                    //
                    // Shutdown  (setting state here, the assumption being
                    // that we're shutting down regardless of the
                    // completion status of this request)
                    //

                    fdoExtension->SystemPowerState = State.SystemState;

                } else if ((fdoExtension->SystemPowerState ==
                                PowerSystemWorking) &&

                           (State.SystemState != PowerSystemWorking)) {

                    //
                    // Power down.  If DevPowerState != D3 then send
                    // a D irp first (when that completes successfully
                    // we'll continue with the S irp), else just
                    // set the completion routine so we can update
                    // the system state field in our extension on
                    // successful completion of this S irp.
                    //

                    if (fdoExtension->DevicePowerState != PowerDeviceD3) {

                        //
                        // Power down, send a D irp first
                        //

                        IoMarkIrpPending (Irp);

                        fdoExtension->SystemPowerIrp = Irp;

                        State.DeviceState = PowerDeviceD3;

                        DEBUGPRINT2((
                            "Sbp2Port: Power:   ext=x%p sending D irp for state %x\n",
                            deviceExtension,
                            State
                            ));

                        status = PoRequestPowerIrp(
                            fdoExtension->Pdo,
                            IRP_MN_SET_POWER,
                            State,
                            Sbp2FdoDIrpCompletion,
                            fdoExtension,
                            NULL
                            );

                        if (!NT_SUCCESS (status)) {

                            DEBUGPRINT1((
                                "Sbp2Port: Power: ext=x%p PoReqPowerIrp err=x%x\n",
                                fdoExtension,
                                status
                                ));

                            irpStack->Control &= ~SL_PENDING_RETURNED;
                            Irp->IoStatus.Status = status;
                            PoStartNextPowerIrp (Irp);
                            IoCompleteRequest (Irp,IO_NO_INCREMENT);
                        }

                        return status;

                    } else {

                        complRoutine = Sbp2FdoSIrpCompletion;
                    }

                } else if (State.SystemState == PowerSystemWorking) {

                    //
                    // Power up.  Set the completion routine so we
                    // follow up with a D irp or update the system
                    // state field in our extension on successful
                    // completion of this S irp.
                    //

                    complRoutine = Sbp2FdoSIrpCompletion;
                }
            }
        }

        PoStartNextPowerIrp (Irp);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        if (complRoutine) {

            IoSetCompletionRoutine(
                Irp,
                Sbp2FdoSIrpCompletion,
                NULL,
                TRUE,
                TRUE,
                TRUE
                );
        }

        return (PoCallDriver (deviceExtension->LowerDeviceObject, Irp));

    default:

        break;
    }

    Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
    PoStartNextPowerIrp (Irp);
    IoCompleteRequest (Irp,IO_NO_INCREMENT);
    return STATUS_NO_SUCH_DEVICE;
}


VOID
Sbp2PdoDIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP SIrp,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    ASSERT(deviceExtension->Type == SBP2_PDO);

    if (SIrp) {

        PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation (SIrp);
        SYSTEM_POWER_STATE state = irpStack->Parameters.Power.State.SystemState;

        DEBUGPRINT1((
            "Sbp2Port: PdoDIrpCompl: ext=x%p, sIrp=x%p, state=%d, status=x%x\n",
            deviceExtension,
            SIrp,
            PowerState.DeviceState,
            IoStatus->Status
            ));

        SIrp->IoStatus.Status = STATUS_SUCCESS;

        PoStartNextPowerIrp (SIrp);
        IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
        IoCompleteRequest (SIrp, IO_NO_INCREMENT);
    }
}


NTSTATUS
Sbp2FdoSIrpCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Unused
    )
{
    KIRQL                   cIrql;
    NTSTATUS                status = Irp->IoStatus.Status;
    POWER_STATE             state;
    PIO_STACK_LOCATION      irpStack = IoGetCurrentIrpStackLocation (Irp);
    PFDO_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;


    state = irpStack->Parameters.Power.State;

    DEBUGPRINT1((
        "Sbp2Port: FdoSIrpCompl: fdoExt=x%p, status=x%x, state=%d\n",
        fdoExtension,
        status,
        state
        ));

    if (!NT_SUCCESS (status)) {

        if ((status == STATUS_NO_SUCH_DEVICE)  &&
            (state.SystemState == PowerSystemWorking)) {

            //
            // Controller (i.e. pc card) was ejected while powered down
            //

            SET_FLAG(
                fdoExtension->DeviceFlags,
                DEVICE_FLAG_ABSENT_ON_POWER_UP
                );
        }

        PoStartNextPowerIrp (Irp);
        return STATUS_SUCCESS;
    }

    //
    // If we're completing a power up S irp then see if we have
    // to follow up with a power up D irp
    //

    if ((state.SystemState == PowerSystemWorking)  &&
        (fdoExtension->DevicePowerState != PowerDeviceD0)) {

        fdoExtension->SystemPowerIrp = Irp;

        state.DeviceState = PowerDeviceD0;

        DEBUGPRINT1(("Sbp2Port: FdoSIrpCompl: sending D irp...\n"));

        status = PoRequestPowerIrp(
            fdoExtension->Pdo,
            IRP_MN_SET_POWER,
            state,
            Sbp2FdoDIrpCompletion,
            fdoExtension,
            NULL
            );

        if (!NT_SUCCESS (status)) {

            DEBUGPRINT1((
                "Sbp2Port: FdoSIrpCompl: ERROR! fdoExt=x%p, D irp sts=x%x\n",
                fdoExtension,
                status
                ));

            Irp->IoStatus.Status = status;
            PoStartNextPowerIrp (Irp);
            return status;
        }

        return STATUS_MORE_PROCESSING_REQUIRED;
    }


    //
    // Update appropriate XxxPowerState extension fields
    //

    if ((fdoExtension->SystemPowerState == PowerSystemWorking)  &&
        (state.SystemState != PowerSystemWorking)) {

        //
        // Power down (might not have sent a D irp but it doesn't
        // hurt to overwrite the DevicePowerState field anyway)
        //

        fdoExtension->SystemPowerState = state.SystemState;
        fdoExtension->DevicePowerState = PowerDeviceD3;

    } else if (state.SystemState == PowerSystemWorking) {

        //
        // Power up
        //

        fdoExtension->SystemPowerState = PowerSystemWorking;
    }

    PoStartNextPowerIrp (Irp);

    return STATUS_SUCCESS;
}


VOID
Sbp2FdoDIrpCompletion(
    IN PDEVICE_OBJECT           TargetDeviceObject,
    IN UCHAR                    MinorFunction,
    IN POWER_STATE              PowerState,
    IN PFDO_DEVICE_EXTENSION    FdoExtension,
    IN PIO_STATUS_BLOCK         IoStatus
    )
{
    PIRP    sIrp = FdoExtension->SystemPowerIrp;


    DEBUGPRINT1((
        "Sbp2Port: FdoDIrpCompl: ext=x%p, status=x%x\n",
        FdoExtension,
        IoStatus->Status
        ));

    FdoExtension->SystemPowerIrp = NULL;

    if (NT_SUCCESS (IoStatus->Status)) {

        if (PowerState.DeviceState == PowerDeviceD0) {

            //
            // Power up, update the XxxPowerState extension fields &
            // complete the s irp
            //

            FdoExtension->SystemPowerState = PowerSystemWorking;
            FdoExtension->DevicePowerState = PowerDeviceD0;

        } else {

            //
            // Power down, forward the s irp
            //

            PoStartNextPowerIrp (sIrp);
            IoCopyCurrentIrpStackLocationToNext (sIrp);
            PoCallDriver (FdoExtension->LowerDeviceObject, sIrp);

            return;
        }

    } else {

        //
        // Propagate the error to the S irp & complete it
        //

        DEBUGPRINT1((
            "Sbp2Port: FdoDIrpCompl: ERROR! fdoExt=x%p, D irp status=x%x\n",
            FdoExtension,
            IoStatus->Status
            ));

        sIrp->IoStatus.Status = IoStatus->Status;
    }

    PoStartNextPowerIrp (sIrp);
    IoCompleteRequest (sIrp, IO_NO_INCREMENT);
}


BOOLEAN
Sbp2EnableBusResetNotification(
    PDEVICE_EXTENSION   DeviceExtension,
    BOOLEAN             Enable
    )
/*++

Routine Description:

    This routine serializes the enabling/disabling of the bus reset
    notification routine for a set of related PDOs (1 or more).
    Enables bus reset notifications for the first device to start, and
    disables bus reset notifications when the last started device stops.

Arguments:

    DeviceObject - Supplies a pointer to the device extension for this request.

    StartDevice - Whether we are processing a START_DEVICE or (implicitly)
                  a STOP_DEVICE request.

Return Value:

   BOOLEAN - yay or nay

--*/
{
    BOOLEAN                 result = TRUE;
    PIRBIRP                 packet;
    LARGE_INTEGER           waitValue;
    PFDO_DEVICE_EXTENSION   fdoExtension;


    fdoExtension = DeviceExtension->BusFdo->DeviceExtension;

    ASSERT(InterlockedIncrement(&fdoExtension->ulBusResetMutexCount) == 1);

    waitValue.QuadPart = -3 * 1000 * 1000 * 10; // 3 seconds

    KeWaitForSingleObject(
        &fdoExtension->EnableBusResetNotificationMutex,
        Executive,
        KernelMode,
        FALSE,
        &waitValue
        );

    ASSERT(InterlockedDecrement(&fdoExtension->ulBusResetMutexCount) == 0);

    if (Enable) {

        fdoExtension->NumPDOsStarted++;

        if (fdoExtension->NumPDOsStarted > 1) {

            goto releaseMutex;
        }

    } else {

        fdoExtension->NumPDOsStarted--;

        if (fdoExtension->NumPDOsStarted > 0) {

            goto releaseMutex;
        }
    }

    AllocateIrpAndIrb (DeviceExtension, &packet);

    if (packet) {

        packet->Irb->FunctionNumber = REQUEST_BUS_RESET_NOTIFICATION;
        packet->Irb->Flags = 0;

        if (Enable) {

            packet->Irb->u.BusResetNotification.fulFlags =
                REGISTER_NOTIFICATION_ROUTINE;
            packet->Irb->u.BusResetNotification.ResetRoutine =
                (PBUS_BUS_RESET_NOTIFICATION) Sbp2BusResetNotification;
            packet->Irb->u.BusResetNotification.ResetContext =
                fdoExtension;

        } else {

            packet->Irb->u.BusResetNotification.fulFlags =
                DEREGISTER_NOTIFICATION_ROUTINE;
        }

        Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

        DeAllocateIrpAndIrb (DeviceExtension,packet);

    } else {

        if (Enable) {

            fdoExtension->NumPDOsStarted--;
        }

        result = FALSE;
    }

releaseMutex:

    KeReleaseMutex (&fdoExtension->EnableBusResetNotificationMutex, FALSE);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\enable.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    power.c

Abstract:

    This module contains the routines for port driver power support

Authors:

    Peter Wieland

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "port.h"

#define __FILE_ID__ 'enab'

typedef struct _REINIT_CONTEXT {
    IN PADAPTER_EXTENSION Adapter;
    IN BOOLEAN UseAdapterControl;
    OUT NTSTATUS Status;
} REINIT_CONTEXT, *PREINIT_CONTEXT;

NTSTATUS
SpReinitializeAdapter(
    IN PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpReinitializeAdapterSynchronized(
    IN PREINIT_CONTEXT Context
    );

NTSTATUS
SpShutdownAdapter(
    IN PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpShutdownAdapterSynchronized(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpEnableDisableCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


NTSTATUS
SpEnableDisableAdapter(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine will synchronously enable or disable the specified adapter.
    It should be called from the adapter's StartIo routine when a power
    irp is processed for the controller.

    When the adapter is disabled the state of the adapter will be saved and
    the miniport will be shut-down.  When the adapter is re-enabled the
    miniport will be reinitialized.

Arguments:

    Adapter - the adapter to be [en|dis]abled.
    Enable - whether to enable or disable the adapter.

Return Value:

    status of the adapter enable/disable action.

--*/

{
    ULONG count;
    KIRQL oldIrql;

    NTSTATUS status = STATUS_SUCCESS;

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

    DebugPrint((1, "SpEnableDisableAdapter: Adapter %#p %s\n",
                Adapter, Enable ? "enable":"disable"));

    if(Enable) {
        count = --Adapter->DisableCount;

        DebugPrint((1, "SpEnableDisableAdapter: DisableCount is %d\n",
                       count));

        if(count == 0) {

            //
            // Re-initialize the adapter.
            //

            status = SpReinitializeAdapter(Adapter);
        }

    } else {

        count = Adapter->DisableCount++;

        DebugPrint((1, "SpEnableDisableAdapter: DisableCount was %d\n",
                    count));

        if(count == 0) {

            //
            // Shut-down the adapter.
            //

            status = SpShutdownAdapter(Adapter);
        }
    }

    KeLowerIrql(oldIrql);
    return status;
}


NTSTATUS
SpEnableDisableLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN Enable,
    IN PSP_ENABLE_DISABLE_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine will enable the specified logical unit.  An unlock queue
    request will be issued to the logical unit - if the lock count drops
    to zero then the device will be re-enabled and i/o processing can be
    restarted.

    If STATUS_PENDING is returned then the completion routine will be run
    when the unlock has been processed.  The routine will be called with
    the status of the unlock request (note that STATUS_SUCCESS does not
    necessarily indicate that the device is ready for use - just that the
    lock count has been decremented) and the specified context.

Arguments:

    LogicalUnit - the logical unit to be enabled.

    Enable - whether the routine should enable or disable the logical unit

    CompletionRoutine - the completion routine to be run when the unlock
                        request has succeeded.

    Context - arbitrary context value/pointer which will be passed into the
              enable completion routine.

Return Value:

    STATUS_PENDING if the request to send an unlock succeeds and the
                   completion routine will be called.

    error if the attempt to send the irp fails.  In this case the completion
          routine will not be called.

--*/

{
    USHORT srbSize;
    USHORT size;

    PIRP irp;
    PSCSI_REQUEST_BLOCK srb;
    PIO_STACK_LOCATION nextStack;

    NTSTATUS status;

    DebugPrint((4, "SpEnableDisableLun: Lun %#p %s context %#p\n",
                LogicalUnit, Enable ? "enable":"disable", Context));

    srbSize = sizeof(SCSI_REQUEST_BLOCK);
    srbSize += sizeof(ULONG) - 1;
    srbSize &= ~(sizeof(ULONG) - 1);

    size = srbSize + IoSizeOfIrp(LogicalUnit->DeviceObject->StackSize + 1);

    srb = SpAllocatePool(NonPagedPool,
                         size,
                         SCSIPORT_TAG_ENABLE,
                         LogicalUnit->DeviceObject->DriverObject);

    if(srb == NULL) {

        //
        // Already failed.  Call the completion routine will the failure status
        // and let it clean up the request.
        //

        DebugPrint((1, "SpEnableDisableLogicalUnit: failed to allocate SRB\n"));

        if(CompletionRoutine != NULL) {
            CompletionRoutine(LogicalUnit->DeviceObject,
                              STATUS_INSUFFICIENT_RESOURCES,
                              Context);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp = (PIRP) (srb + 1);

    IoInitializeIrp(irp,
                    (USHORT) (size - srbSize),
                    (CCHAR)(LogicalUnit->DeviceObject->StackSize + 1));

    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->Parameters.Others.Argument1 = LogicalUnit->DeviceObject;
    nextStack->Parameters.Others.Argument2 = CompletionRoutine;
    nextStack->Parameters.Others.Argument3 = Context;
    nextStack->Parameters.Others.Argument4 = 0;     // retry count

    IoSetNextIrpStackLocation(irp);

    IoSetCompletionRoutine(irp,
                           SpEnableDisableCompletionRoutine,
                           srb,
                           TRUE,
                           TRUE,
                           TRUE);

    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_SCSI;
    nextStack->MinorFunction = 1;

    nextStack->Parameters.Scsi.Srb = srb;

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->OriginalRequest = irp;

    srb->SrbFlags = SRB_FLAGS_BYPASS_LOCKED_QUEUE;

    srb->Function = Enable ? SRB_FUNCTION_UNLOCK_QUEUE :
                             SRB_FUNCTION_LOCK_QUEUE;

    status = IoCallDriver(LogicalUnit->DeviceObject, irp);

    return status;
}


NTSTATUS
SpEnableDisableCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    PIO_STACK_LOCATION irpStack;
    PSP_ENABLE_DISABLE_COMPLETION_ROUTINE routine;
    PVOID context;
    NTSTATUS status;

    DebugPrint((4, "SpEnableDisableCompletionRoutine: irp %#p completed "
                   "with status %#08lx\n",
                Irp, Irp->IoStatus.Status));

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    routine = irpStack->Parameters.Others.Argument2;
    context = irpStack->Parameters.Others.Argument3;

    DeviceObject = irpStack->Parameters.Others.Argument1;

    status = Irp->IoStatus.Status;

    //
    // Free the srb which will also release the irp.
    //

    ExFreePool(Srb);

    if(routine != NULL) {
        routine(DeviceObject, status, context);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SpReinitializeAdapter(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine will allow the miniport to restore any state or configuration
    information and then to restart it's adapter.  Adapter interrupts will
    be re-enabled at the return of this routine and scsiport may begin issuing
    new requests to the miniport.

Arguments:

    Adapter - the adapter to be re-initialized.

Return Value:

    status

--*/

{
    ULONG oldDebug;

    KIRQL oldIrql;

    ULONG result;
    BOOLEAN again;

    BOOLEAN useAdapterControl;

    NTSTATUS status;

    UCHAR string[] = {'W', 'A', 'K', 'E', 'U', 'P', '\0'};

    //
    // Give the miniport a chance to restore it's bus-data to a state which
    // allows the miniport to operate.
    //

    if(SpIsAdapterControlTypeSupported(Adapter, ScsiRestartAdapter) == TRUE) {
        DebugPrint((1, "SpReinitializeAdapter: using AdapterControl\n"));
        useAdapterControl = TRUE;
    } else {
        DebugPrint((1, "SpReinitializeAdapter: using init routines\n"));
        useAdapterControl = FALSE;
    }

    oldIrql = KeRaiseIrqlToDpcLevel();

    KeAcquireSpinLockAtDpcLevel(&(Adapter->SpinLock));

    //
    // Since we may be reinitializing the miniport at DISPATCH_LEVEL we need
    // to set the miniport reinitializing flag for some of the SCSIPORT api's
    // to modify their behavior.
    //

    SET_FLAG(Adapter->Flags, PD_MINIPORT_REINITIALIZING);

    result = SP_RETURN_FOUND;

    if(useAdapterControl == FALSE) {

        result = Adapter->HwFindAdapter(Adapter->HwDeviceExtension,
                                        NULL,
                                        NULL,
                                        string,
                                        Adapter->PortConfig,
                                        &again);
    } else if(SpIsAdapterControlTypeSupported(Adapter,
                                             ScsiSetRunningConfig) == TRUE) {
        SCSI_ADAPTER_CONTROL_STATUS b;

        b = SpCallAdapterControl(Adapter, ScsiSetRunningConfig, NULL);

        ASSERT(b == ScsiAdapterControlSuccess);

    }

    if(result == SP_RETURN_FOUND) {

        REINIT_CONTEXT context;

        context.Adapter = Adapter;
        context.UseAdapterControl = useAdapterControl;

        Adapter->SynchronizeExecution(Adapter->InterruptObject,
                                      SpReinitializeAdapterSynchronized,
                                      &context);

        status = context.Status;
    } else {
        status = STATUS_DRIVER_INTERNAL_ERROR;
    }

    if(NT_SUCCESS(status)) {

        //
        // We had better be ready for another request by now.
        //

        ScsiPortNotification(NextRequest,
                             Adapter->HwDeviceExtension);

        if (Adapter->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

            //
            // Request a completion DPC so that we clear out any existing
            // attempts to do things like reset the bus.
            //

            SpRequestCompletionDpc(Adapter->DeviceObject);
        }
    }

    KeReleaseSpinLockFromDpcLevel(&(Adapter->SpinLock));

    ASSERT(NT_SUCCESS(status));

    KeLowerIrql(oldIrql);

    return status;
}


BOOLEAN
SpReinitializeAdapterSynchronized(
    IN PREINIT_CONTEXT Context
    )
{
    PADAPTER_EXTENSION adapter = Context->Adapter;
    BOOLEAN result;

    DebugPrint((1, "SpReinitializeAdapterSynchronized: calling "
                   "HwFindAdapter\n"));

    if(Context->UseAdapterControl) {
        SCSI_ADAPTER_CONTROL_TYPE status;

        status = SpCallAdapterControl(adapter, ScsiRestartAdapter, NULL);
        result = (status == ScsiAdapterControlSuccess);

    } else {
        result = adapter->HwInitialize(adapter->HwDeviceExtension);
    }

    if(result == TRUE) {
        Context->Status = STATUS_SUCCESS;
    } else {
        Context->Status = STATUS_ADAPTER_HARDWARE_ERROR;
    }

    DebugPrint((1, "SpReinitializeAdapterSynchronized: enabling interrupts\n"));

    adapter->InterruptData.InterruptFlags &= ~PD_DISABLE_INTERRUPTS;

    CLEAR_FLAG(adapter->Flags, PD_MINIPORT_REINITIALIZING);
    CLEAR_FLAG(adapter->Flags, PD_UNCACHED_EXTENSION_RETURNED);

    return TRUE;
}


NTSTATUS
SpShutdownAdapter(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine will shutdown the miniport and save away any state information
    necessary to restart it.  Adapter interrupts will be disabled at the
    return of this routine - scsiport will not issue any new requests to the
    miniport until it has been reinitialized.

Arguments:

    Adapter - the adapter to be shut down.

Return Value:

    status

--*/

{
    //
    // Acquire the adapter spinlock and set state to indicate that a 
    // shutdown is in progress.  This will prevent us from starting
    // operations that shouldn't be started while shutting down.
    //

    KeAcquireSpinLockAtDpcLevel(&Adapter->SpinLock);
    SET_FLAG(Adapter->Flags, PD_SHUTDOWN_IN_PROGRESS);
    KeReleaseSpinLockFromDpcLevel(&Adapter->SpinLock);

    //
    // Cancel the miniport timer so that we don't call into it after we've 
    // shut down.
    //

    KeCancelTimer(&(Adapter->MiniPortTimer));

    //
    // Currently we don't give the miniport any chance to save any sort of
    // state information.  We just stop any i/o going into it and then do
    // a shutdown.
    //

    Adapter->SynchronizeExecution(Adapter->InterruptObject,
                                  SpShutdownAdapterSynchronized,
                                  Adapter);

    if(SpIsAdapterControlTypeSupported(Adapter, ScsiSetBootConfig))  {

        //
        // Allow the miniport a chance to reset its PCI bus data before we
        // power it off.
        //

        SpCallAdapterControl(Adapter, ScsiSetBootConfig, NULL);
    }

    return STATUS_SUCCESS;
}


BOOLEAN
SpShutdownAdapterSynchronized(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine performs the ISR synchronized part of shutting down the
    miniport.  This includes disabling the interrupt and request a shutdown
    of the miniport.

Arguments:

    Adapter - the adapter to shut down.

Return Value:

    TRUE

--*/

{
    SpCallAdapterControl(Adapter, ScsiStopAdapter, NULL);
    DebugPrint((1, "SpShutdownAdapterSynchronized: Disabling interrupts\n"));
    Adapter->InterruptData.InterruptFlags |= PD_DISABLE_INTERRUPTS;
    CLEAR_FLAG(Adapter->Flags, PD_SHUTDOWN_IN_PROGRESS);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\enum.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    enum.c

Abstract:

    This module contains device enumeration code for the scsi port driver

Authors:

    Peter Wieland

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "port.h"

#define __FILE_ID__ 'enum'

ULONG EnumDebug = 2;

#if DBG
static const char *__file__ = __FILE__;
#endif

#define MINIMUM_BUS_SCAN_INTERVAL ((ULONGLONG) (30 * SECONDS))

ULONG BreakOnTarget = (ULONG) -1;
ULONG BreakOnScan = TRUE;

ULONG BreakOnMissingLun = FALSE;

typedef struct {
    UCHAR LunListLength[4]; // sizeof LunSize * 8
    UCHAR Reserved[4];
    UCHAR Luns[16][8];
} SP_DEFAULT_LUN_LIST;

SP_DEFAULT_LUN_LIST ScsiPortDefaultLunList = {
    {0, 0, 0, sizeof(ScsiPortDefaultLunList.Luns)}, // LunListLength
    {0, 0, 0, 0},                                   // Reserved
    {{ 0, 0, 0, 0, 0, 0, 0, 0},                     // Luns
     { 0, 1, 0, 0, 0, 0, 0, 0},
     { 0, 2, 0, 0, 0, 0, 0, 0},
     { 0, 3, 0, 0, 0, 0, 0, 0},
     { 0, 4, 0, 0, 0, 0, 0, 0},
     { 0, 5, 0, 0, 0, 0, 0, 0},
     { 0, 6, 0, 0, 0, 0, 0, 0},
     { 0, 7, 0, 0, 0, 0, 0, 0}}};

NTSTATUS
SpInquireLogicalUnit(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN BOOLEAN ExposeDisconnectedLuns,
    IN OPTIONAL PLOGICAL_UNIT_EXTENSION RescanLun,
    OUT PLOGICAL_UNIT_EXTENSION *LogicalUnit,
    OUT PBOOLEAN CheckNextLun
    );

VOID
SpSignalEnumerationCompletion (
    IN PADAPTER_EXTENSION Adapter,
    IN PSP_ENUMERATION_REQUEST Request,
    IN NTSTATUS Status
    );

BOOLEAN
SpRemoveLogicalUnitFromBinSynchronized(
    IN PVOID ServiceContext                 // PLOGICAL_UNIT_EXTENSION
    );

BOOLEAN
SpAddLogicalUnitToBinSynchronized(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnitExtension
    );

ULONG
SpCountLogicalUnits(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
IssueReportLuns(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    OUT PLUN_LIST *LunList
    );

PLUN_LIST
AdjustReportLuns(
    IN PDRIVER_OBJECT DriverObject,
    IN PLUN_LIST RawList
    );

VOID
SpScanAdapter(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpScanBus(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN BOOLEAN ExposeDisconnectedLuns,
    IN PLOGICAL_UNIT_EXTENSION RescanLun
    );

NTSTATUS
SpScanTarget(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN BOOLEAN ExposeDisconnectedLuns,
    IN PLOGICAL_UNIT_EXTENSION RescanLun
    );

NTSTATUS
IssueInquiry(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN EnableVitalProductData,
    IN UCHAR PageCode,
    OUT PVOID InquiryData,
    OUT PUCHAR BytesReturned
    );

VOID
SpSetVerificationMarks(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId
    );

VOID
SpClearVerificationMark(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

VOID
SpPurgeTarget(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId
    );

NTSTATUS
SpCloneAndSwapLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PINQUIRYDATA InquiryData,
    IN ULONG InquiryDataSize,
    OUT PLOGICAL_UNIT_EXTENSION *NewLun
    );

VOID
SpSetLogicalUnitAddress(
    IN PLOGICAL_UNIT_EXTENSION RescanLun,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    );

VOID
SpClearLogicalUnitAddress(
    IN PLOGICAL_UNIT_EXTENSION RescanLun
    );

NTSTATUS
SpPrepareLogicalUnitForReuse(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

NTSTATUS
SpCreateLogicalUnit(
    IN PADAPTER_EXTENSION Adapter,
    IN OPTIONAL UCHAR PathId,
    IN OPTIONAL UCHAR TargetId,
    IN OPTIONAL UCHAR Lun,
    IN BOOLEAN Temporary,
    IN BOOLEAN Scsi1,
    OUT PLOGICAL_UNIT_EXTENSION *NewLun
    );

NTSTATUS
SpSendSrbSynchronous(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OPTIONAL PIRP Irp,
    IN OPTIONAL PMDL Mdl,
    IN PVOID DataBuffer,
    IN ULONG TransferLength,
    IN PVOID SenseInfoBuffer,
    IN UCHAR SenseInfoBufferLength,
    OUT PULONG BytesReturned
    );

BOOLEAN
SpGetDeviceIdentifiers(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN NewDevice
    );

BOOLEAN
FASTCALL
SpCompareInquiryData(
    IN PUCHAR InquiryData1,
    IN PUCHAR InquiryData2
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpEnumerateAdapterSynchronous)
#pragma alloc_text(PAGE, SpEnumerateAdapterAsynchronous)
#pragma alloc_text(PAGE, SpSignalEnumerationCompletion)
#pragma alloc_text(PAGE, SpEnumerationWorker)

#pragma alloc_text(PAGE, SpScanAdapter)
#pragma alloc_text(PAGE, SpScanBus)
#pragma alloc_text(PAGE, SpScanTarget)

#pragma alloc_text(PAGE, SpCompareInquiryData)
#pragma alloc_text(PAGE, SpInquireLogicalUnit)
#pragma alloc_text(PAGE, SpExtractDeviceRelations)

#pragma alloc_text(PAGELOCK, SpCountLogicalUnits)
#pragma alloc_text(PAGELOCK, GetNextLuRequestWithoutLock)
#pragma alloc_text(PAGELOCK, IssueReportLuns)

#pragma alloc_text(PAGELOCK, SpSetVerificationMarks)
#pragma alloc_text(PAGELOCK, SpPurgeTarget)

#pragma alloc_text(PAGE, SpClearVerificationMark)

#pragma alloc_text(PAGE, SpGetInquiryData)
#pragma alloc_text(PAGE, IssueInquiry)

#pragma alloc_text(PAGE, AdjustReportLuns)

#pragma alloc_text(PAGE, SpCreateLogicalUnit)
#pragma alloc_text(PAGE, SpCloneAndSwapLogicalUnit)
#pragma alloc_text(PAGE, SpSetLogicalUnitAddress)
#pragma alloc_text(PAGE, SpClearLogicalUnitAddress)
#pragma alloc_text(PAGE, SpPrepareLogicalUnitForReuse)

#pragma alloc_text(PAGE, SpSendSrbSynchronous)
#pragma alloc_text(PAGE, SpGetDeviceIdentifiers)

LONG SpPAGELOCKLockCount = 0;
#endif


NTSTATUS
SpExtractDeviceRelations(
    PADAPTER_EXTENSION Adapter,
    DEVICE_RELATION_TYPE RelationType,
    PDEVICE_RELATIONS *DeviceRelations
    )

/*++

Routine Description:

    This routine will allocate a device relations structure and fill in the
    count and object array with referenced object pointers

Arguments:

    Adapter - the adapter to extract relations from.

    RelationType - what type of relationship is being retrieved

    DeviceRelations - a place to store the relationships

--*/

{
    PDEVICE_OBJECT fdo = Adapter->DeviceObject;
    ULONG count = 0;

    ULONG relationsSize;
    PDEVICE_RELATIONS deviceRelations = NULL;

    UCHAR bus, target, lun;
    PLOGICAL_UNIT_EXTENSION luExtension;

    ULONG i;

    NTSTATUS status;

    PAGED_CODE();

    status = KeWaitForMutexObject(
                &(Adapter->EnumerationDeviceMutex),
                Executive,
                KernelMode,
                FALSE,
                NULL);

    if(status == STATUS_USER_APC) {
        status = STATUS_REQUEST_ABORTED;
    }

    if(!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Find out how many devices there are
    //

    for(bus = 0; bus < Adapter->NumberOfBuses; bus++) {
        for(target = 0; target < Adapter->MaximumTargetIds; target++) {
            for(lun = 0; lun < SCSI_MAXIMUM_LUNS_PER_TARGET; lun++) {

                luExtension = GetLogicalUnitExtension(
                                Adapter,
                                bus,
                                target,
                                lun,
                                FALSE,
                                TRUE);

                if(luExtension == NULL) {
                    continue;
                }

                //
                // Temporary luns only exist while the bus scanning code is
                // holding the device lock.  we've got it now so we should
                // never find one.
                //

                ASSERT(luExtension->IsTemporary == FALSE);

                if(luExtension->IsMissing) {
                    continue;
                }

                if(luExtension->IsVisible == FALSE) {
                    continue;
                }

                if(luExtension->CommonExtension.IsRemoved >= REMOVE_COMPLETE) {
                    ASSERT(FALSE);
                    continue;
                }

                count++;
            }
        }
    }

    //
    // Allocate the structure
    //

    relationsSize = sizeof(DEVICE_RELATIONS) + (count * sizeof(PDEVICE_OBJECT));

    deviceRelations = SpAllocatePool(PagedPool,
                                     relationsSize,
                                     SCSIPORT_TAG_DEVICE_RELATIONS,
                                     fdo->DriverObject);

    if(deviceRelations == NULL) {

        DebugPrint((1, "SpExtractDeviceRelations: unable to allocate "
                       "%d bytes for device relations\n", relationsSize));

        KeReleaseMutex(&(Adapter->EnumerationDeviceMutex), FALSE);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(deviceRelations, relationsSize);

    i = 0;

    for(bus = 0; bus < Adapter->NumberOfBuses; bus++) {
        for(target = 0; target < Adapter->MaximumTargetIds; target++) {
            for(lun = 0; lun < SCSI_MAXIMUM_LUNS_PER_TARGET; lun++) {

                luExtension = GetLogicalUnitExtension(
                                Adapter,
                                bus,
                                target,
                                lun,
                                FALSE,
                                TRUE);

                if(luExtension == NULL) {

                    continue;

                }

                //
                // Temporary luns only exist while the bus scanning code is
                // holding the device lock.  we've got it now so we should
                // never find one.
                //

                ASSERT(luExtension->IsTemporary == FALSE);

                if(luExtension->IsMissing) {

                    DebugPrint((1, "SpExtractDeviceRelations: logical unit "
                                   "(%d,%d,%d) is missing and will not be "
                                   "returned\n",
                                bus, target, lun));

                    luExtension->IsEnumerated = FALSE;
                    continue;

                } else if(luExtension->CommonExtension.IsRemoved >= REMOVE_COMPLETE) {

                    ASSERT(FALSE);
                    luExtension->IsEnumerated = FALSE;
                    continue;

                } else if(luExtension->IsVisible == FALSE) {
                    luExtension->IsEnumerated = FALSE;
                    continue;
                }

                status = ObReferenceObjectByPointer(
                            luExtension->CommonExtension.DeviceObject,
                            0,
                            NULL,
                            KernelMode);

                if(!NT_SUCCESS(status)) {

                    DebugPrint((1, "SpFdoExtractDeviceRelations: status %#08lx "
                                   "while referenceing object %#p\n",
                                   status,
                                   deviceRelations->Objects[i]));
                    continue;
                }

                deviceRelations->Objects[i] =
                    luExtension->CommonExtension.DeviceObject;

                i++;
                luExtension->IsEnumerated = TRUE;
            }
        }
    }

    deviceRelations->Count = i;
    *DeviceRelations = deviceRelations;

    KeReleaseMutex(&(Adapter->EnumerationDeviceMutex), FALSE);

    return STATUS_SUCCESS;
}


NTSTATUS
IssueReportLuns(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    OUT PLUN_LIST *LunList
    )

/*++

Routine Description:

    Build IRP, SRB and CDB for SCSI REPORT LUNS command.

Arguments:

    LogicalUnit - address of target's device object extension.
    LunList - address of buffer for LUN_LIST information.

Return Value:

    NTSTATUS

--*/

{
    PMDL mdl;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    SCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    KEVENT event;
    KIRQL currentIrql;
    PLUN_LIST lunListDataBuffer;
    PSENSE_DATA senseInfoBuffer = NULL;
    NTSTATUS status;
    ULONG retryCount = 0;
    ULONG lunListSize;
    ULONG i;

    PAGED_CODE();

#if 0
    if ((LogicalUnit->InquiryData.Versions & 7) < 3) {

        //
        // make sure the device supports scsi3 commands
        // without this check, we may hang some scsi2 devices
        //

        return STATUS_INVALID_DEVICE_REQUEST;
    }
#endif

    //
    // start with the minilun of 16 byte for the lun list
    //
    lunListSize = 16;

    status = STATUS_INVALID_DEVICE_REQUEST;

    senseInfoBuffer = LogicalUnit->AdapterExtension->InquirySenseBuffer;
    irp = LogicalUnit->AdapterExtension->InquiryIrp;
    mdl = NULL;

    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE);

    //
    // This is a two pass operation - for the first pass we just try to figure
    // out how large the list should be.  On the second pass we'll actually
    // reallocate the buffer and try to get the entire lun list.
    //
    // NOTE - we may want to set an arbitrary limit here so we don't soak up all 
    // of non-paged pool when some device hands us back a buffer filled 
    // with 0xff.
    //

    for (i=0; i<2; i++) {

        //
        // Allocate a cache aligned LUN_LIST structure.
        //

        lunListDataBuffer = SpAllocatePool(
                                NonPagedPoolCacheAligned,
                                lunListSize,
                                SCSIPORT_TAG_REPORT_LUNS,
                                LogicalUnit->DeviceObject->DriverObject);

        if (lunListDataBuffer == NULL) {

            DebugPrint((1,"IssueReportLuns: Can't allocate report luns data buffer\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        mdl = SpAllocateMdl(lunListDataBuffer,
                            lunListSize,
                            FALSE,
                            FALSE,
                            NULL,
                            LogicalUnit->DeviceObject->DriverObject);

        if(mdl == NULL) {
            DebugPrint((1,"IssueReportLuns: Can't allocate data buffer MDL\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;

        }

        MmBuildMdlForNonPagedPool(mdl);

        //
        // number of retry
        //
        retryCount = 3;
        while (retryCount--) {

            //
            // Build IRP for this request.
            //

            IoInitializeIrp(irp,
                            IoSizeOfIrp(INQUIRY_STACK_LOCATIONS),
                            INQUIRY_STACK_LOCATIONS);

            irp->MdlAddress = mdl;

            irpStack = IoGetNextIrpStackLocation(irp);

            //
            // Fill in SRB fields.
            //

            RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

            //
            // Mark the minor function to indicate that this is an internal scsiport
            // request and that the start state of the device can be ignored.
            //

            irpStack->MajorFunction = IRP_MJ_SCSI;
            irpStack->MinorFunction = 1;

            irpStack->Parameters.Scsi.Srb = &srb;

            IoSetCompletionRoutine(irp,
                                   SpSignalCompletion,
                                   &event,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            srb.PathId = LogicalUnit->PathId;
            srb.TargetId = LogicalUnit->TargetId;
            srb.Lun = LogicalUnit->Lun;

            srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
            srb.Length = sizeof(SCSI_REQUEST_BLOCK);

            //
            // Set flags to disable synchronous negociation.
            //

            srb.SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

            srb.SrbStatus = srb.ScsiStatus = 0;

            srb.NextSrb = 0;

            srb.OriginalRequest = irp;

            //
            // Set timeout to 2 seconds.
            //

            srb.TimeOutValue = 4;

            srb.CdbLength = 12;

            //
            // Enable auto request sense.
            //

            srb.SenseInfoBuffer = senseInfoBuffer;
            srb.SenseInfoBufferLength = SENSE_BUFFER_SIZE;

            srb.DataBuffer = MmGetMdlVirtualAddress(irp->MdlAddress);
            srb.DataTransferLength = lunListSize;

            cdb = (PCDB)srb.Cdb;

            //
            // Set CDB operation code.
            //

            cdb->REPORT_LUNS.OperationCode = SCSIOP_REPORT_LUNS;
            cdb->REPORT_LUNS.AllocationLength[0] = (UCHAR) ((lunListSize >> 24) & 0xff);
            cdb->REPORT_LUNS.AllocationLength[1] = (UCHAR) ((lunListSize >> 16) & 0xff);
            cdb->REPORT_LUNS.AllocationLength[2] = (UCHAR) ((lunListSize >>  8) & 0xff);
            cdb->REPORT_LUNS.AllocationLength[3] = (UCHAR) ((lunListSize >>  0) & 0xff);

            //
            // Call port driver to handle this request.
            //

            status = IoCallDriver(LogicalUnit->DeviceObject, irp);

            //
            // Wait for request to complete.
            //

            KeWaitForSingleObject(&event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            status = irp->IoStatus.Status;

            if (SRB_STATUS(srb.SrbStatus) != SRB_STATUS_SUCCESS) {

                DebugPrint((2,"IssueReportLuns: failed SRB status %x\n",
                    srb.SrbStatus));

                //
                // Unfreeze queue if necessary
                //

                if (srb.SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

                    DebugPrint((3, "IssueInquiry: Unfreeze Queue TID %d\n",
                        srb.TargetId));

                    LogicalUnit->LuFlags &= ~LU_QUEUE_FROZEN;

                    KeAcquireSpinLock(
                        &(LogicalUnit->AdapterExtension->SpinLock),
                        &currentIrql);

                    GetNextLuRequest(LogicalUnit);
                    KeLowerIrql(currentIrql);
                }

                if ((srb.SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
                     senseInfoBuffer->SenseKey == SCSI_SENSE_ILLEGAL_REQUEST){

                     //
                     // A sense key of illegal request was recieved.  This indicates
                     // that the logical unit number of not valid but there is a
                     // target device out there.
                     //

                     status = STATUS_INVALID_DEVICE_REQUEST;
                     break;

                } else if ((SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SELECTION_TIMEOUT) ||
                           (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_NO_DEVICE)) {

                    //
                    // If the selection times out then give up
                    //
                    status = STATUS_NO_SUCH_DEVICE;
                    break;
                }

                //
                // retry...
                //

            } else {

                status = STATUS_SUCCESS;
                break;
            }
        }

        IoFreeMdl(mdl);

        if (NT_SUCCESS(status)) {

            ULONG listLength;

            listLength  = lunListDataBuffer->LunListLength[3] <<  0;
            listLength |= lunListDataBuffer->LunListLength[2] <<  8;
            listLength |= lunListDataBuffer->LunListLength[1] << 16;
            listLength |= lunListDataBuffer->LunListLength[0] << 24;

            if (lunListSize < (listLength + sizeof (LUN_LIST))) {

                lunListSize = listLength + sizeof (LUN_LIST);

                //
                // try report lun with a bigger buffer
                //

                ExFreePool(lunListDataBuffer);
                lunListDataBuffer = NULL;
                status = STATUS_INVALID_DEVICE_REQUEST;

            } else {

                //
                // lun list is good
                //
                break;
            }
        }
    }

    //
    // Return the lun list
    //

    if(NT_SUCCESS(status)) {

        //
        // AdjustReportLuns returns lunListDataBuffer if it cannot allocate
        // a new list.
        //

        *LunList = AdjustReportLuns(LogicalUnit->DeviceObject->DriverObject, 
                                    lunListDataBuffer);

        //
        // Only delete lunListDataBuffer if we didn't return it from 
        // AdjustReportLuns.
        //

        ASSERT(*LunList != NULL);
        ASSERT(lunListDataBuffer != NULL);
        if (*LunList != lunListDataBuffer) {
            ExFreePool(lunListDataBuffer);
        }
    } else {
        *LunList = NULL;
        if (lunListDataBuffer) {
            ExFreePool(lunListDataBuffer);
        }
    }

    return status;

} // end IssueReportLuns()



VOID
GetNextLuRequestWithoutLock(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    KIRQL oldIrql;

    PAGED_CODE();
    ASSERT(SpPAGELOCKLockCount != 0);
    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
    KeAcquireSpinLockAtDpcLevel(&(LogicalUnit->AdapterExtension->SpinLock));
    GetNextLuRequest(LogicalUnit);
    KeLowerIrql(oldIrql);
    PAGED_CODE();
    return;
}


ULONG
SpCountLogicalUnits(
    IN PADAPTER_EXTENSION Adapter
    )
{
    ULONG numberOfLus = 0;
    PLOGICAL_UNIT_EXTENSION luExtension;
    KIRQL oldIrql;

    ULONG bin;

#ifdef ALLOC_PRAGMA
    PVOID sectionHandle;
#endif
    //
    // Code is paged until locked down.
    //

    PAGED_CODE();

    //
    // Lock this routine down before grabbing the spinlock.
    //

#ifdef ALLOC_PRAGMA
    sectionHandle = MmLockPagableCodeSection(SpCountLogicalUnits);
#endif

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

    for(bin = 0; bin < NUMBER_LOGICAL_UNIT_BINS; bin++) {

        KeAcquireSpinLockAtDpcLevel(&(Adapter->LogicalUnitList[bin].Lock));

        for(luExtension = Adapter->LogicalUnitList[bin].List;
            luExtension != NULL;
            luExtension = luExtension->NextLogicalUnit) {

            if(luExtension->IsMissing == FALSE) {
                numberOfLus++;
            }
        }

        KeReleaseSpinLockFromDpcLevel(&(Adapter->LogicalUnitList[bin].Lock));
    }

    KeLowerIrql(oldIrql);

#ifdef ALLOC_PRAGMA
    MmUnlockPagableImageSection(sectionHandle);
#endif

    return numberOfLus;
}


NTSTATUS
SpGetInquiryData(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PIRP Irp
    )

/*++

Routine Description:

    This functions copies the inquiry data to the system buffer.  The data
    is translate from the port driver's internal format to the user mode
    format.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    Irp - Supplies a pointer to the Irp which made the original request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/

{
    PUCHAR bufferStart;
    PIO_STACK_LOCATION irpStack;

    UCHAR bin;
    PLOGICAL_UNIT_EXTENSION luExtension;
    PSCSI_ADAPTER_BUS_INFO  adapterInfo;
    PSCSI_INQUIRY_DATA inquiryData;
    ULONG inquiryDataSize;
    ULONG length;
    PLOGICAL_UNIT_INFO lunInfo;
    ULONG numberOfBuses;
    ULONG numberOfLus;
    ULONG j;
    UCHAR pathId;
    UCHAR targetId;
    UCHAR lun;

    NTSTATUS status;

    PAGED_CODE();

    ASSERT_FDO(DeviceExtension->CommonExtension.DeviceObject);

    status = KeWaitForMutexObject(&(DeviceExtension->EnumerationDeviceMutex),
                                  UserRequest,
                                  UserMode,
                                  FALSE,
                                  NULL);

    if(status == STATUS_USER_APC) {
        status = STATUS_REQUEST_ABORTED;
    }

    if(!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        return status;
    }

    DebugPrint((3,"SpGetInquiryData: Enter routine\n"));

    //
    // Get a pointer to the control block.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    bufferStart = Irp->AssociatedIrp.SystemBuffer;

    //
    // Determine the number of SCSI buses and logical units.
    //

    numberOfBuses = DeviceExtension->NumberOfBuses;
    numberOfLus = 0;

    numberOfLus = SpCountLogicalUnits(DeviceExtension);

    //
    // Caculate the size of the logical unit structure and round it to a word
    // alignment.
    //

    inquiryDataSize = ((sizeof(SCSI_INQUIRY_DATA) - 1 + INQUIRYDATABUFFERSIZE +
        sizeof(ULONG) - 1) & ~(sizeof(ULONG) - 1));

    // Based on the number of buses and logical unit, determine the minimum
    // buffer length to hold all of the data.
    //

    length = sizeof(SCSI_ADAPTER_BUS_INFO) +
        (numberOfBuses - 1) * sizeof(SCSI_BUS_DATA);
    length += inquiryDataSize * numberOfLus;

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < length) {

        Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        KeReleaseMutex(&(DeviceExtension->EnumerationDeviceMutex), FALSE);
        return(STATUS_BUFFER_TOO_SMALL);
    }

    //
    // Set the information field.
    //

    Irp->IoStatus.Information = length;

    //
    // Fill in the bus information.
    //

    adapterInfo = (PSCSI_ADAPTER_BUS_INFO) bufferStart;

    adapterInfo->NumberOfBuses = (UCHAR) numberOfBuses;
    inquiryData = (PSCSI_INQUIRY_DATA)(bufferStart +
                                       sizeof(SCSI_ADAPTER_BUS_INFO) +
                                       ((numberOfBuses - 1) *
                                        sizeof(SCSI_BUS_DATA)));

    for (pathId = 0; pathId < numberOfBuses; pathId++) {

        PSCSI_BUS_DATA busData;

        busData = &adapterInfo->BusData[pathId];
        busData->InitiatorBusId = DeviceExtension->PortConfig->InitiatorBusId[pathId];
        busData->NumberOfLogicalUnits = 0;
        busData->InquiryDataOffset = (ULONG)((PUCHAR) inquiryData - bufferStart);

        for(targetId = 0;
            targetId < DeviceExtension->MaximumTargetIds;
            targetId++) {
            for(lun = 0;
                lun < SCSI_MAXIMUM_LUNS_PER_TARGET;
                lun++) {

                PLOGICAL_UNIT_EXTENSION luExtension;

                luExtension = GetLogicalUnitExtension(DeviceExtension,
                                                      pathId,
                                                      targetId,
                                                      lun,
                                                      Irp,
                                                      TRUE);

                if(luExtension == NULL) {
                    continue;
                }


                if((luExtension->IsMissing) ||
                   (luExtension->CommonExtension.IsRemoved)) {

                    SpReleaseRemoveLock(
                        luExtension->CommonExtension.DeviceObject,
                        Irp);

                    continue;
                }

                busData->NumberOfLogicalUnits++;

                DebugPrint((1, "InquiryData for (%d, %d, %d) - ",
                               pathId,
                               targetId,
                               lun));
                DebugPrint((1, "%d units found\n", busData->NumberOfLogicalUnits));

                inquiryData->PathId = pathId;
                inquiryData->TargetId = targetId;
                inquiryData->Lun = lun;
                inquiryData->DeviceClaimed = luExtension->IsClaimed;
                inquiryData->InquiryDataLength = INQUIRYDATABUFFERSIZE;
                inquiryData->NextInquiryDataOffset = (ULONG)((PUCHAR) inquiryData + inquiryDataSize - bufferStart);

                RtlCopyMemory(inquiryData->InquiryData,
                              &(luExtension->InquiryData),
                              INQUIRYDATABUFFERSIZE);

                inquiryData = (PSCSI_INQUIRY_DATA) ((PUCHAR) inquiryData + inquiryDataSize);

                SpReleaseRemoveLock(luExtension->CommonExtension.DeviceObject,
                                    Irp);
            }
        }

        if(busData->NumberOfLogicalUnits == 0) {
            busData->InquiryDataOffset = 0;
        } else {
            ((PSCSI_INQUIRY_DATA) ((PCHAR) inquiryData - inquiryDataSize))->NextInquiryDataOffset = 0;
        }

    }

    Irp->IoStatus.Status = STATUS_SUCCESS;

    KeReleaseMutex(&(DeviceExtension->EnumerationDeviceMutex), FALSE);
    return(STATUS_SUCCESS);
}


VOID
SpAddLogicalUnitToBin (
    IN PADAPTER_EXTENSION AdapterExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnitExtension
    )

/*++

Routine Description:

    This routine will synchronize with any interrupt or miniport routines and
    add the specified logical unit to the appropriate logical unit list.
    The logical unit must not already be in the list.

    This routine acquires the bin spinlock and calls the SynchronizeExecution
    routine.  It cannot be called when the bin spinlock is held or from a
    miniport API.

Arguments:

    AdapterExtension - the adapter to add this logical unit to.

    LogicalUnitExtension - the logical unit to be added.

Return Value:

    none

--*/

{
    UCHAR hash = ADDRESS_TO_HASH(LogicalUnitExtension->PathId,
                                 LogicalUnitExtension->TargetId,
                                 LogicalUnitExtension->Lun);

    PLOGICAL_UNIT_BIN bin = &AdapterExtension->LogicalUnitList[hash];

    PLOGICAL_UNIT_EXTENSION lun;

    KIRQL oldIrql;

    KeAcquireSpinLock(&AdapterExtension->SpinLock, &oldIrql);
    KeAcquireSpinLockAtDpcLevel(&bin->Lock);

    //
    // Run through the list quickly and make sure this lun isn't already there
    //

    lun = bin->List;

    while(lun != NULL) {

        if(lun == LogicalUnitExtension) {
            break;
        }
        lun = lun->NextLogicalUnit;
    }

    ASSERTMSG("Logical Unit already in list: ", lun == NULL);

    ASSERTMSG("Logical Unit not properly initialized: ",
              (LogicalUnitExtension->AdapterExtension == AdapterExtension));

    ASSERTMSG("Logical Unit is already on a list: ",
              LogicalUnitExtension->NextLogicalUnit == NULL);

    LogicalUnitExtension->NextLogicalUnit = bin->List;

    bin->List = LogicalUnitExtension;

    KeReleaseSpinLockFromDpcLevel(&bin->Lock);
    KeReleaseSpinLock(&AdapterExtension->SpinLock, oldIrql);
    return;
}


VOID
SpRemoveLogicalUnitFromBin (
    IN PADAPTER_EXTENSION AdapterExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnitExtension
    )

/*++

Routine Description:

    This routine will synchronize with any interrupt or miniport routines and
    remove the specified logical unit from the appropriate logical unit list.
    The logical unit MUST be in the logical unit list.

    This routine acquires the bin spinlock and calls the SynchronizeExecution
    routine.  It cannot be called when the bin spinlock is held or from
    a miniport exported routine.

Arguments:

    AdapterExtension - The adapter from which to remove this logical unit

    LogicalUnitExtension - the logical unit to be removed

Return Value:

    none

--*/

{
    KIRQL oldIrql;
    PLOGICAL_UNIT_BIN bin =
        &AdapterExtension->LogicalUnitList[ADDRESS_TO_HASH(
                                                LogicalUnitExtension->PathId,
                                                LogicalUnitExtension->TargetId,
                                                LogicalUnitExtension->Lun)];

    KeAcquireSpinLock(&AdapterExtension->SpinLock, &oldIrql);
    KeAcquireSpinLockAtDpcLevel(&bin->Lock);

    AdapterExtension->SynchronizeExecution(
        AdapterExtension->InterruptObject,
        SpRemoveLogicalUnitFromBinSynchronized,
        LogicalUnitExtension
        );

    KeReleaseSpinLockFromDpcLevel(&bin->Lock);
    KeReleaseSpinLock(&AdapterExtension->SpinLock, oldIrql);

    if(LogicalUnitExtension->IsMismatched) {
        DebugPrint((1, "SpRemoveLogicalUnitFromBin: Signalling for rescan "
                       "after removal of mismatched lun %#p\n",
                    LogicalUnitExtension));
        IoInvalidateDeviceRelations(AdapterExtension->LowerPdo,
                                    BusRelations);
    }
}


BOOLEAN
SpRemoveLogicalUnitFromBinSynchronized(
    IN PVOID ServiceContext
    )

{
    PLOGICAL_UNIT_EXTENSION logicalUnitExtension =
        (PLOGICAL_UNIT_EXTENSION) ServiceContext;
    PADAPTER_EXTENSION adapterExtension =
        logicalUnitExtension->AdapterExtension;

    UCHAR hash = ADDRESS_TO_HASH(
                    logicalUnitExtension->PathId,
                    logicalUnitExtension->TargetId,
                    logicalUnitExtension->Lun);

    PLOGICAL_UNIT_BIN  bin;

    PLOGICAL_UNIT_EXTENSION *lun;

    ASSERT(hash < NUMBER_LOGICAL_UNIT_BINS);

    adapterExtension->CachedLogicalUnit = NULL;

    bin = &adapterExtension->LogicalUnitList[hash];

    lun = &bin->List;

    while(*lun != NULL) {

        if(*lun == logicalUnitExtension) {

            //
            // Found a match - unlink it from the list.
            //

            *lun = logicalUnitExtension->NextLogicalUnit;
            logicalUnitExtension->NextLogicalUnit = NULL;
            return TRUE;
        }

        lun = &((*lun)->NextLogicalUnit);
    }

    return TRUE;
}


PLUN_LIST
AdjustReportLuns(
    IN PDRIVER_OBJECT DriverObject,
    IN PLUN_LIST RawList
    )
{
    ULONG newLength;
    ULONG numberOfEntries;
    ULONG maxLun = 8;

    PLUN_LIST newList;

    //
    // Derive the length of the list and the number of entries currently in
    // the list.
    //

    newLength  = RawList->LunListLength[3] <<  0;
    newLength |= RawList->LunListLength[2] <<  8;
    newLength |= RawList->LunListLength[1] << 16;
    newLength |= RawList->LunListLength[0] << 24;

    numberOfEntries = newLength / sizeof (RawList->Lun[0]);

    newLength += sizeof(LUN_LIST);
    newLength += maxLun * sizeof(RawList->Lun[0]);

    //
    // Allocate a list with "maxLun" extra entries in it.  This might waste
    // some space if we have duplicates but it's easy.
    //
    //
    // ALLOCATION
    //


    newList = SpAllocatePool(NonPagedPool,
                             newLength,
                             SCSIPORT_TAG_REPORT_LUNS,
                             DriverObject);

    if(newList == NULL){

        newList = RawList;
    } else {

        UCHAR lunNumber;
        ULONG entry;
        ULONG newEntryCount = 0;

        RtlZeroMemory(newList, newLength);

        //
        // First make a fake entry for each of the luns from 0 to maxLun - 1
        //

        for(lunNumber = 0; lunNumber < maxLun; lunNumber++) {
            newList->Lun[lunNumber][1] = lunNumber;
            newEntryCount++;
        };

        //
        // Now iterate through the entries in the remaining list.  For each
        // one copy it over iff it's not already a lun 0 -> (maxLun - 1)
        //

        for(entry = 0; entry < numberOfEntries; entry++) {
            USHORT l;

            l = (RawList->Lun[entry][0] << 8);
            l |= RawList->Lun[entry][1];
            l &= 0x3fff;

            if(l >= maxLun) {
                RtlCopyMemory(&(newList->Lun[lunNumber]),
                              &(RawList->Lun[entry]),
                              sizeof(newList->Lun[0]));
                lunNumber++;
                newEntryCount++;
            }
        }

        //
        // Copy over the reserved bytes for the cases where they aren't all
        // that reserved.
        //

        RtlCopyMemory(newList->Reserved,
                      RawList->Reserved,
                      sizeof(RawList->Reserved));

        //
        // Subtract out the number of duplicate entries we found.
        //

        newLength = newEntryCount * sizeof(RawList->Lun[0]);

        newList->LunListLength[0] = (UCHAR) ((newLength >> 24) & 0xff);
        newList->LunListLength[1] = (UCHAR) ((newLength >> 16) & 0xff);
        newList->LunListLength[2] = (UCHAR) ((newLength >> 8) & 0xff);
        newList->LunListLength[3] = (UCHAR) ((newLength >> 0) & 0xff);
    }

    return newList;
}

VOID
SpCompleteEnumRequest(
    IN PADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine completes our handling of an asynchronous bus scan.  If the
    supplied IRP has been completed successfully, we pass it down to the 
    driver below.  If the IRP was failed, we complete the request here.

Arguments:

    Adapter - The adapter we're scanning.

    Irp     - The IRP that prompted this asynchronous bus scan true then a 
              scan will be done even if one has happend within the minimum 
              bus scan delta time.

Return Value:

    none.

--*/
{
    ULONG tempLock;
    
    //
    // Acquire a temporary remove lock so we can release the lock acquired
    // on behalf of the IRP.
    //

    SpAcquireRemoveLock(Adapter->DeviceObject, &tempLock);

    //
    // Release the IRP's remove lock because holding it across completion
    // could trip up our remove tracking code since it is based on the
    // IRP address which can be recycled.
    //

    SpReleaseRemoveLock(Adapter->DeviceObject, Irp);

    //
    // Call down or complete the IRP, depending on the request's completion 
    // status.
    //

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoCallDriver(Adapter->CommonExtension.LowerDeviceObject, Irp);

    } else {

        SpCompleteRequest(Adapter->DeviceObject, 
                          Irp, 
                          NULL, 
                          IO_NO_INCREMENT);

    }

    //
    // Release the temporary lock.
    //

    SpReleaseRemoveLock(Adapter->DeviceObject, &tempLock);
}

NTSTATUS
SpEnumerateAdapterSynchronous(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Force
    )
/*++

Routine Description:

    This routine will call SpEnumerateAdapterAsynchronous and wait for it to
    complete.

Arguments:

    Adapter - the adapter we're scanning.

    Force - if true then a scan will be done even if one has happend within
            the minimum bus scan delta time.

Return Value:

    none.

--*/
{
    SP_ENUMERATION_REQUEST request;
    KEVENT event;

    NTSTATUS status;

    RtlZeroMemory(&request, sizeof(SP_ENUMERATION_REQUEST));

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    request.CompletionRoutine = SpSignalEnumerationCompletion;
    request.Context = &event;
    request.CompletionStatus = &status;
    request.Synchronous = TRUE;

    SpEnumerateAdapterAsynchronous(Adapter, &request, Force);

    KeWaitForSingleObject(&(event),
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    return status;
}

VOID
SpEnumerateAdapterAsynchronous(
    IN PADAPTER_EXTENSION Adapter,
    IN PSP_ENUMERATION_REQUEST Request,
    IN BOOLEAN Force
    )

/*++
Routine Description:

    This routine will queue a bus scan and return.  When the scan completes the
    worker thread will run the callback in the Request passed in by the caller.

Details:

    If the force flag (or the ForceNextBusScan flag in the adapter) is set or
    the minimum interval between bus scans has passed then this routine will
    queue this enumeration request to the work list and, if necessary, start
    a new worker thread to process them.

    Otherwise it will attempt to acquire the EnumerationDeviceMutex in order to
    run the completion routine.  If this is not available then it will also
    queue the work item and start the thread if necessary.

Arguments:

    Adapter - the adapter to be scanned.

    Request - the request to be processed when the scan is complete.  The
              completion routine in this request may free the request structure.

    Force - hint as to whether or not we should honor the minimum bus scan
            interval.

Return Value:

    none

--*/

{
    ULONG forceNext;
    LONGLONG rescanInterval;

    PAGED_CODE();

    ASSERT(Request->CompletionRoutine != NULL);
    ASSERT(Request->NextRequest == NULL);

    ExAcquireFastMutex(&(Adapter->EnumerationWorklistMutex));

    //
    // Swap out the ForceNextBusScan value for FALSE.
    //

    forceNext = InterlockedExchange(&(Adapter->ForceNextBusScan), FALSE);

    //
    // Force the bus scan to happen either way.
    //

    Force = (Force || forceNext || Adapter->EnumerationRunning) ? TRUE : FALSE;

    //
    // Calculate the time between bus enumerations.
    //

    if(Force == FALSE) {
        LARGE_INTEGER currentSystemTime;
        LONGLONG lastTime;

        KeQuerySystemTime(&currentSystemTime);

        lastTime = Adapter->LastBusScanTime.QuadPart;

        rescanInterval = currentSystemTime.QuadPart - lastTime;
    }

    //
    // If we're required to do the bus scan then queue this request and
    // schedule a work item to run in (if necessary).
    //

    if((Force == TRUE) || (rescanInterval > MINIMUM_BUS_SCAN_INTERVAL)) {

        //
        // Grab the remove lock for this device so we know it (and the
        // associated code) can't be removed.
        //

        SpAcquireRemoveLock(Adapter->DeviceObject, Request);

        //
        // Queue the entry to the work list.
        //

        Request->NextRequest = Adapter->EnumerationWorkList;
        Adapter->EnumerationWorkList = Request;

        if(Adapter->EnumerationRunning == FALSE) {

            //
            // Start a new worker thread to run the enumeration.
            //

            Adapter->EnumerationRunning = TRUE;

            ExQueueWorkItem(&(Adapter->EnumerationWorkItem), DelayedWorkQueue);
        }

        ExReleaseFastMutex(&(Adapter->EnumerationWorklistMutex));

    } else {

        NTSTATUS status;
        PIRP irp = NULL;

        //
        // We're going to try and satisfy this request immediately.
        // If there is currently an enumeration running then we'll try to
        // acquire the EnumerationDeviceMutex.  If that fails we'll just
        // queue the request for the worker to complete.  If the worker is
        // not running then we just acquire the mutex and process the request.
        //

        ASSERT(Adapter->EnumerationRunning == FALSE);

        ExReleaseFastMutex(&(Adapter->EnumerationWorklistMutex));

        status = KeWaitForMutexObject(&(Adapter->EnumerationDeviceMutex),
                                      UserRequest,
                                      UserMode,
                                      FALSE,
                                      NULL);

        //
        // If this is an async request, save the IRP so we can complete
        // it after we've filled in the completion information.  We can't
        // touch the request after we return from our completion callback.
        //

        if (Request->Synchronous == FALSE) {
            irp = (PIRP) Request->Context;
        }

        //
        // Either we got the mutex (STATUS_SUCCESS) or the thread is being
        // terminated (STATUS_USER_APC - since we're not alertable a
        // user-mode APC can't be run except in certain special cases).
        //
        // Either way the completion routine will do the correct thing.
        //

        Request->CompletionRoutine(Adapter, Request, status);
        KeReleaseMutex(&(Adapter->EnumerationDeviceMutex), FALSE);

        //
        // If this is an async request, complete the IRP or pass it down
        // depending on the status.
        //

        if (irp != NULL) {
            SpCompleteEnumRequest(Adapter, irp);
        }
    }

    return;
}


VOID
SpSignalEnumerationCompletion(
    IN PADAPTER_EXTENSION Adapter,
    IN PSP_ENUMERATION_REQUEST Request,
    IN NTSTATUS Status
    )
{
    if(ARGUMENT_PRESENT(Request->CompletionStatus)) {
        *(Request->CompletionStatus) = Status;
    }

    KeSetEvent((PKEVENT) Request->Context, IO_NO_INCREMENT, FALSE);

    return;
}


VOID
SpEnumerationWorker(
    IN PADAPTER_EXTENSION Adapter
    )
{
    NTSTATUS status;
    PSP_ENUMERATION_REQUEST request;
    PKTHREAD thread;
    PIRP currentIrp;
    PLIST_ENTRY currentEntry;
    LIST_ENTRY completedListHead;

    PAGED_CODE();

    ASSERT_FDO(Adapter->DeviceObject);

    ASSERT(Adapter->EnumerationRunning == TRUE);

    //
    // Initialize the list of completed IRPs.
    //

    InitializeListHead(&completedListHead);

    Adapter->EnumerationWorkThread = KeGetCurrentThread();

    //
    // Grab the device mutex and enumerate the bus.
    //

    KeWaitForMutexObject(&(Adapter->EnumerationDeviceMutex),
                         UserRequest,
                         UserMode,
                         FALSE,
                         NULL);

    SpScanAdapter(Adapter);

    //
    // Drop the device mutex & grab the WorkList mutex.
    //

    KeReleaseMutex(&(Adapter->EnumerationDeviceMutex), FALSE);
    ExAcquireFastMutex(&(Adapter->EnumerationWorklistMutex));

    //
    // Update the time of this bus scan.
    //

    KeQuerySystemTime(&(Adapter->LastBusScanTime));

    //
    // Grab a temporary remove lock.  Use the address of the work item as a
    // cheap way of ensuring that we haven't requeued the work item while the
    // thread is still running.
    //

    SpAcquireRemoveLock(Adapter->DeviceObject, &(Adapter->EnumerationWorkItem));

    //
    // Run through the list of enumeration requests.  For each one:
    //  * remove it from the work list.
    //  * save the irp if it's an async request
    //  * call its completion routine
    //

    for(request = Adapter->EnumerationWorkList;
        request != NULL;
        request = Adapter->EnumerationWorkList) {

        //
        // Remove this entry from the list.  Clear the next request pointer
        // as a bugcatcher.
        //

        Adapter->EnumerationWorkList = request->NextRequest;
        request->NextRequest = NULL;

        //
        // If this is an asynchronous request, add the IRP to the completed list.
        //

        if (request->Synchronous == FALSE) {
            currentIrp = (PIRP)request->Context;
            InsertTailList(&completedListHead, &currentIrp->Tail.Overlay.ListEntry);
        }

        //
        // Release the remove lock we acquired on behalf of the request object
        // before we call the completion routine.  The temporary lock we
        // acquired above protects us.
        //

        SpReleaseRemoveLock(Adapter->DeviceObject, request);

        //
        // Call our completion callback routine.
        //

        request->CompletionRoutine(Adapter, request, STATUS_SUCCESS);
        request = NULL;
    }

    //
    // Indicate that the work item is no longer running.
    //

    Adapter->EnumerationRunning = FALSE;
    Adapter->EnumerationWorkThread = NULL;

    //
    // Release the lock.
    //

    ExReleaseFastMutex(&(Adapter->EnumerationWorklistMutex));

    //
    // For asynchronous bus scans, we must wait until we've released the fast
    // mutex to complete the IRPs.  Doing so while holding the fast mutex
    // completes the IRP at APC_LEVEL and this opens the door to filter
    // drivers completion routines calling one of our dispatch routines at
    // elevated IRQL.  This is a problem because some of these dispatch
    // routines process requests synchronously by blocking the thread and
    // waiting for the IO Manager to set an event upon request completion.
    // The problem is that the IO Manager, for synchronous operations,
    // schedules an APC for the original thread in order to set the event
    // and do buffer copying in the caller's thread context.  This of course
    // deadlocks because the waiting thread is already at APC_LEVEL.
    //
    // By releasing the mutex first, we drop the thread's IRQL back to
    // PASSIVE_LEVEL and the problem is solved.
    //
    // The completion callback set the IRP's status and information fields;
    // all we have to do is either forward the IRP down the stack if the
    // status indicates success or complete it if the request failed.
    //

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    while (IsListEmpty(&completedListHead) == FALSE) {

        //
        // Get the next entry from the list.
        //

        currentEntry = RemoveHeadList(&completedListHead);

        //
        // Extract a pointer to the IRP.
        //
        
        currentIrp = CONTAINING_RECORD(currentEntry,
                                       IRP,
                                       Tail.Overlay.ListEntry);

        //
        // Complete the IRP.
        //

        SpCompleteEnumRequest(Adapter, currentIrp);
    }

    //
    // Release the temporary remove lock we acquired above.
    //

    SpReleaseRemoveLock(Adapter->DeviceObject, &(Adapter->EnumerationWorkItem));

    return;
}


VOID
SpScanAdapter(
    IN PADAPTER_EXTENSION Adapter
    )

/*++

Routine Description:

    This routine scans all of the busses on an adapter.  It locks down the
    necessary memory pages, checks the registry to see if we should be
    exposing disconnected luns, powers up the controller (if needed) and
    then scans each bus for devices.

    This routine is very much non-reenterant and should not be called outside
    of the enumeration mutex (ie. outside of an enumeration request).

Arguments:

    Adapter - a pointer to the adapter being enumerated.

Return Value:

    none

--*/

{
    PDEVICE_OBJECT deviceObject = Adapter->DeviceObject;

    UCHAR i;

    BOOLEAN exposeDisconnectedLuns = FALSE;

    PLOGICAL_UNIT_EXTENSION rescanLun;

#ifdef ALLOC_PRAGMA
    PVOID sectionHandle;
#endif

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    DebugPrint((EnumDebug, "SpScanAdapter: Beginning scan of adapter %#p\n", Adapter));

    //
    // Try to allocate a logical unit to use for probeing new bus addresses.
    // Assume that it's going to be a SCSI-2 device.
    //

    status = SpCreateLogicalUnit(Adapter, 
                                 0xff, 
                                 0xff, 
                                 0xff, 
                                 TRUE, 
                                 FALSE, 
                                 &rescanLun);

    if(!NT_SUCCESS(status)) {
        return;
    }

    //
    // Lock down the PAGELOCK section - we'll need it in order to call
    // IssueInquiry.
    //

#ifdef ALLOC_PRAGMA
    sectionHandle = MmLockPagableCodeSection(GetNextLuRequestWithoutLock);
    InterlockedIncrement(&SpPAGELOCKLockCount);
#endif

    //
    // Check to see if we should be exposing disconnected LUNs.
    //

    for(i = 0; i < 3; i++) {

        PWCHAR locations[] = {
            L"Scsiport",
            SCSIPORT_CONTROL_KEY,
            DISK_SERVICE_KEY
        };

        UNICODE_STRING unicodeString;
        OBJECT_ATTRIBUTES objectAttributes;
        HANDLE instanceHandle = NULL;
        HANDLE handle;
        PKEY_VALUE_FULL_INFORMATION key = NULL;

        if(i == 0) {
            status = IoOpenDeviceRegistryKey(Adapter->LowerPdo,
                                             PLUGPLAY_REGKEY_DEVICE,
                                             KEY_READ,
                                             &instanceHandle);

            if(!NT_SUCCESS(status)) {
                DebugPrint((2, "SpScanAdapter: Error %#08lx opening device registry key\n", status));
                continue;
            }
        }

        RtlInitUnicodeString(&unicodeString, locations[i]);

        InitializeObjectAttributes(
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            instanceHandle,
            NULL);

        status = ZwOpenKey(&handle,
                           KEY_READ,
                           &objectAttributes);

        if(!NT_SUCCESS(status)) {
            DebugPrint((2, "SpScanAdapter: Error %#08lx opening %wZ key\n", status, &unicodeString));
            if(instanceHandle != NULL) {
                ZwClose(instanceHandle);
                instanceHandle = NULL;
            }
            continue;
        }

        status = SpGetRegistryValue(deviceObject->DriverObject,
                                    handle,
                                    L"ScanDisconnectedDevices",
                                    &key);

        ZwClose(handle);
        if(instanceHandle != NULL) {
            ZwClose(instanceHandle);
            instanceHandle = NULL;
        }

        if(NT_SUCCESS(status)) {
            if(key->Type == REG_DWORD) {
                PULONG value;
                value = (PULONG) ((PUCHAR) key + key->DataOffset);
                if(*value) {
                    exposeDisconnectedLuns = TRUE;
                }
            }
            ExFreePool(key);
            break;
        } else {
            DebugPrint((2, "SpScanAdapter: Error %#08lx opening %wZ\\ScanDisconnectedDevices value\n", status, &unicodeString));
        }
    }

    //
    // We need to be powered up in order to do a bus enumeration - make
    // sure that we are.  This is because we create new PDO's and new
    // PDO's are assumed to be at D0.
    //

    status = SpRequestValidAdapterPowerStateSynchronous(Adapter);

    if(NT_SUCCESS(status)) {
        UCHAR pathId;

        for (pathId = 0; pathId < Adapter->NumberOfBuses; pathId++) {
            status = SpScanBus(Adapter, pathId, exposeDisconnectedLuns, rescanLun);

            if(!NT_SUCCESS(status)) {
                break;
            }
        }
    }

#ifdef ALLOC_PRAGMA
    InterlockedDecrement(&SpPAGELOCKLockCount);
    MmUnlockPagableImageSection(sectionHandle);
#endif

    SpDeleteLogicalUnit(rescanLun);
    ASSERT(Adapter->RescanLun == NULL);

    return;
}


NTSTATUS
SpScanBus(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN BOOLEAN ExposeDisconnectedLuns,
    IN PLOGICAL_UNIT_EXTENSION RescanLun
    )
{
    UCHAR targetIndex;
    NTSTATUS status = STATUS_SUCCESS;

    DebugPrint((EnumDebug, "SpScanBus: Beginning scan of bus %x\n", PathId));

    for(targetIndex = 0; targetIndex < Adapter->MaximumTargetIds; targetIndex++) {

        UCHAR targetId;

        if(Adapter->Capabilities.AdapterScansDown) {
            targetId = Adapter->MaximumTargetIds - targetIndex - 1;
        } else {
            targetId = targetIndex;
        }

        DebugPrint((EnumDebug, "SpScanBus: targetIndex = %x -> targetId = %x\n",
                    targetIndex, targetId));

        ASSERT(targetId != 255);
        ASSERT(Adapter->PortConfig);

        if(targetId == Adapter->PortConfig->InitiatorBusId[PathId]) {
            DebugPrint((EnumDebug, "SpScanBus:   Target ID matches initiator ID - skipping\n"));
            continue;
        }

        //
        // Mark all of the logical units as needing verification.  At the
        // end of scanning the target and LUNs which still need to be verified
        // will be purged (marked as missing).
        //

        SpSetVerificationMarks(Adapter, PathId, targetId);
        RescanLun->NeedsVerification = TRUE;

        status = SpScanTarget(Adapter,
                              PathId,
                              targetId,
                              ExposeDisconnectedLuns,
                              RescanLun);

        SpPurgeTarget(Adapter, PathId, targetId);

        if(!NT_SUCCESS(status)) {
            break;
        }
    }

    return status;
}


NTSTATUS
SpScanTarget(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN BOOLEAN ExposeDisconnectedLuns,
    IN PLOGICAL_UNIT_EXTENSION RescanLun
    )
{
    BOOLEAN sparseLun = FALSE;

    PLOGICAL_UNIT_EXTENSION lunZero;
    BOOLEAN checkNextLun;

    BOOLEAN scsi1 = FALSE;

    PLUN_LIST lunList = NULL;
    BOOLEAN saveLunList = FALSE;
    ULONG numLunsReported;

    UCHAR maxLuCount;
    ULONG lunIndex;

    NTSTATUS resetStatus;
    NTSTATUS status;

    DebugPrint((EnumDebug, "SpScanTarget:   Beginning scan of target %x\n", TargetId));

    //
    // Use the SCSI-2 dispatch table when checking LUN 0.
    //

    ASSERT(RescanLun->CommonExtension.MajorFunction == DeviceMajorFunctionTable);

    //
    // Issue an inquiry to LUN 0.
    //

    status = SpInquireLogicalUnit(Adapter,
                                  PathId,
                                  TargetId,
                                  (UCHAR) 0,
                                  TRUE,
                                  RescanLun,
                                  &lunZero,
                                  &checkNextLun);

    //
    // reset the rescan lun so that we can safely use it again.  If this fails
    // we still continue as far as possible with this target, but we return the
    // reset status to the caller so it can abort its scan.
    //

    resetStatus = SpPrepareLogicalUnitForReuse(RescanLun);

    if(!NT_SUCCESS(resetStatus)) {
        RescanLun = NULL;
    }

    if(!NT_SUCCESS(status)) {

        //
        // There is no device present at LUN 0.  Skip to the next target.
        // Even if sparse luns is enabled there MUST be a LUN 0 for us to
        // continue scanning the target.
        //

        DebugPrint((EnumDebug, "SpScanTarget:    Lun 0 not found - terminating scan "
                       "(status %#08lx)\n", status));

        return resetStatus;
    }

    //
    // Indicate that lun 0 does not require verification.
    //

    SpClearVerificationMark(lunZero);

    //
    // Check for the special case of only having one LUN on this target.
    //

    if(lunZero->SpecialFlags.OneLun) {

        DebugPrint((EnumDebug, "SpScanTarget:    Target (%x,%x,*) is listed as having "
                       "only one lun\n", PathId, TargetId));
        return resetStatus;
    }

    //
    // Set the rescan LUN to use whatever lun zero uses for a dispatch table.
    // 

    RescanLun->CommonExtension.MajorFunction = 
        lunZero->CommonExtension.MajorFunction;

    //
    // Determine if we should be handling sparse LUNs on this target.
    //

    sparseLun = TEST(lunZero->SpecialFlags.SparseLun);

    if(sparseLun) {
        DebugPrint((EnumDebug, "SpScanTarget:    Target (%x,%x,*) will be checked for "
                       "sparse luns\n", PathId, TargetId));
    }

    //
    // Issue a report luns command to the device if it supports it.
    // If it doesn't support it then use the default LUN list.
    //

    if((lunZero->InquiryData.HiSupport || lunZero->SpecialFlags.LargeLuns)) {

        DebugPrint((EnumDebug, "SpScanTarget:    Target (%x,%x,*) may support REPORT_LUNS\n", PathId, TargetId));

        //
        // Indicate that we should indeed save the lun list.  If it turns out
        // that we're unable to retrieve one to be saved then we will
        // clear the flag below.
        //

        saveLunList = TRUE;

        status = IssueReportLuns(lunZero, &lunList);

        //
        // If the request fails for some reason then try to use the lun list
        // which was saved for this target (in the extension of logical unit
        // zero).  If that hasn't been set either then we'll use the default
        // one down below.
        //

        if(!NT_SUCCESS(status)) {
            DebugPrint((EnumDebug, "SpScanTarget:    Target (%x,%x,*) returned  %#08lx to REPORT_LUNS command - using old list\n", PathId, TargetId, status));
            lunList = lunZero->TargetLunList;
        }

        //
        // If we can now or have in the past gotten a report luns list from the
        // device then enable sparse lun scanning.  In this case we also assume
        // that up to 255 luns can be supported on this target.
        //

        if(lunList != NULL) {
            sparseLun = TRUE;
            DebugPrint((EnumDebug, "SpScanTarget:    Target (%x,%x,*) will be checked for "
                           "sparse luns(2)\n", PathId, TargetId));
        }
    }

    //
    // if we still don't have a lun list then use the "default" one.  In that
    // event don't save it.
    //

    if(lunList == NULL) {
        DebugPrint((EnumDebug, "SpScanTarget:    Target (%x,%x,*) will use default lun list\n", PathId, TargetId));
        lunList = (PLUN_LIST) &(ScsiPortDefaultLunList);
        saveLunList = FALSE;
    }

    numLunsReported  = lunList->LunListLength[3] <<  0;
    numLunsReported |= lunList->LunListLength[2] <<  8;
    numLunsReported |= lunList->LunListLength[1] << 16;
    numLunsReported |= lunList->LunListLength[0] << 24;
    numLunsReported /= sizeof (lunList->Lun[0]);

    DebugPrint((EnumDebug, "SpScanTarget:    Target (%x,%x,*) has reported %d luns\n", PathId, TargetId, numLunsReported));

    //
    // Walk through each entry in the LUN list.  Stop when we run out of entries
    // or the logical unit number is > MaximumNumberOfLogicalUnits (the lun
    // list is assumed to be sorted in increasing order).  For each entry,
    // issue an inquiry.  If the inquiry succeeds then clear the verification
    // mark.
    //

    for(lunIndex = 0; lunIndex < numLunsReported; lunIndex++) {
        PULONGLONG largeLun;
        USHORT lun;
        PLOGICAL_UNIT_EXTENSION logicalUnit;

        NTSTATUS resetStatus;

        largeLun = (PULONGLONG) (lunList->Lun[lunIndex]);

        lun  = lunList->Lun[lunIndex][1] << 0;
        lun |= lunList->Lun[lunIndex][0] << 8;
        lun &= 0x3fff;

        //
        // If the target reports a lun 0 just skip it.
        //

        DebugPrint((EnumDebug, "SpScanTarget:     Checking lun %I64lx (%x): ",  *largeLun, lun));

        if(lun == 0) {
            DebugPrint((EnumDebug, "Skipping LUN 0\n"));
            continue;
        }

        //
        // If the target reports a lun outside the range the driver can support
        // then skip it.
        //

        if(lun >= Adapter->PortConfig->MaximumNumberOfLogicalUnits) {
            DebugPrint((EnumDebug, "Skipping LUN out of range (> %x)\n", 
                        Adapter->PortConfig->MaximumNumberOfLogicalUnits));
            continue;
        }

        //
        // Issue an inquiry to each logical unit in the system.
        //

        status = SpInquireLogicalUnit(Adapter,
                                      PathId,
                                      TargetId,
                                      (UCHAR) lun,
                                      ExposeDisconnectedLuns,
                                      RescanLun,
                                      &logicalUnit,
                                      &checkNextLun);

        if(RescanLun != NULL) {
            resetStatus = SpPrepareLogicalUnitForReuse(RescanLun);

            if(!NT_SUCCESS(resetStatus)) {
                RescanLun = NULL;
            }
        }

        if(NT_SUCCESS(status)) {

            DebugPrint((EnumDebug, "Inquiry succeeded\n"));
            SpClearVerificationMark(logicalUnit);

        } else {

            DebugPrint((EnumDebug, "inquiry returned %#08lx.", status));

            if((sparseLun == FALSE)&&(checkNextLun == FALSE)) {
                DebugPrint((EnumDebug, "Aborting\n"));
                break;
            } else {
                DebugPrint((EnumDebug, " - checking next (%c%c)\n",
                            sparseLun ? 's' : ' ',
                            checkNextLun ? 'c' : ' '));
            }
        }
    }

    //
    // If we're supposed to save the lun list then replace the one in lun0
    // with this one.
    //

    if(saveLunList) {

        DebugPrint((EnumDebug, "SpScanTarget:   Saving LUN list %#08lx\n", lunList));
        ASSERT(lunZero->TargetLunList != (PLUN_LIST) &(ScsiPortDefaultLunList));
        if(lunZero->TargetLunList != NULL && lunZero->TargetLunList != lunList) {
            DebugPrint((EnumDebug, "SpScanTarget:   Freeing old LUN list %#08lx\n", lunZero->TargetLunList));
            ExFreePool(lunZero->TargetLunList);
        }

        lunZero->TargetLunList = lunList;

    } else {
        ASSERT(lunList == (PLUN_LIST) &(ScsiPortDefaultLunList));
    }

    //
    // reset the rescan LUN to use the scsi 2 dispatch table.
    //

    RescanLun->CommonExtension.MajorFunction = DeviceMajorFunctionTable;

    return resetStatus;
}


VOID
SpSetVerificationMarks(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId
    )
{
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    KIRQL oldIrql;

    ULONG bin;

    //
    // Code is paged until locked down.
    //

    PAGED_CODE();
    ASSERT(SpPAGELOCKLockCount != 0);

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

    for(bin = 0; bin < NUMBER_LOGICAL_UNIT_BINS; bin++) {

        KeAcquireSpinLockAtDpcLevel(&(Adapter->LogicalUnitList[bin].Lock));

        for(logicalUnit = Adapter->LogicalUnitList[bin].List;
            logicalUnit != NULL;
            logicalUnit = logicalUnit->NextLogicalUnit) {

            ASSERT(logicalUnit->IsTemporary == FALSE);

            if((logicalUnit->PathId == PathId) &&
               (logicalUnit->TargetId == TargetId)) {

                logicalUnit->NeedsVerification = TRUE;
            }
        }

        KeReleaseSpinLockFromDpcLevel(&(Adapter->LogicalUnitList[bin].Lock));
    }

    KeLowerIrql(oldIrql);

    return;
}


VOID
SpClearVerificationMark(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    PAGED_CODE();

    ASSERT(LogicalUnit->IsTemporary == FALSE);
    ASSERT(LogicalUnit->NeedsVerification == TRUE);
    LogicalUnit->NeedsVerification = FALSE;
    return;
}


VOID
SpPurgeTarget(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId
    )
{
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    KIRQL oldIrql;

    ULONG bin;

    //
    // Code is paged until locked down.
    //

    PAGED_CODE();
    ASSERT(SpPAGELOCKLockCount != 0);

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

    for(bin = 0; bin < NUMBER_LOGICAL_UNIT_BINS; bin++) {

        KeAcquireSpinLockAtDpcLevel(&(Adapter->LogicalUnitList[bin].Lock));

        for(logicalUnit = Adapter->LogicalUnitList[bin].List;
            logicalUnit != NULL;
            logicalUnit = logicalUnit->NextLogicalUnit) {

            ASSERT(logicalUnit->IsTemporary == FALSE);

            if((logicalUnit->PathId == PathId) &&
               (logicalUnit->TargetId == TargetId) &&
               (logicalUnit->NeedsVerification == TRUE)) {


                //
                // This device was not found to be present during our bus scan.
                //

                DebugPrint((EnumDebug, "SpPurgeTarget:   Lun (%x,%x,%x) is still marked and will be made missing\n", logicalUnit->PathId, logicalUnit->TargetId, logicalUnit->Lun));
                logicalUnit->IsMissing = TRUE;
            }
        }

        KeReleaseSpinLockFromDpcLevel(&(Adapter->LogicalUnitList[bin].Lock));
    }

    KeLowerIrql(oldIrql);

    return;
}


NTSTATUS
SpCreateLogicalUnit(
    IN PADAPTER_EXTENSION Adapter,
    IN OPTIONAL UCHAR PathId,
    IN OPTIONAL UCHAR TargetId,
    IN OPTIONAL UCHAR Lun,
    IN BOOLEAN Temporary,
    IN BOOLEAN Scsi1,
    OUT PLOGICAL_UNIT_EXTENSION *NewLun
    )

/*++

Routine Description:

    This routine will create a physical device object for the specified device

Arguments:

    Adapter - the parent adapter for this new lun

    PathId, TargetId, Lun - the address of this lun.  Not used if Temporary is
                            TRUE (see below).

    Temporary - indicates whether this device is real (FALSE) or simply for
                the purposes of scanning the bus (TRUE).  If TRUE then the
                address info is ignored and this lun is NOT inserted into the
                logical unit list.

    Scsi1 - indicates that this LUN is a scsi1 lun and needs to use the 
            dispatch routines which stick the LUN number into the CDB itself.               

    NewLun - a location to store the pointer to the new lun

Return Value:

    status

--*/

{
    PIRP senseIrp;

    PDEVICE_OBJECT pdo = NULL;
    PLOGICAL_UNIT_EXTENSION logicalUnitExtension;

    WCHAR wideDeviceName[64];
    UNICODE_STRING unicodeDeviceName;

    PVOID hwExtension = NULL;

    PVOID serialNumberBuffer = NULL;
    PVOID idBuffer = NULL;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Attempt to allocate all the persistent resources we need before we
    // try to create the device object itself.
    //

    //
    // Allocate a request sense irp.
    //

    senseIrp = SpAllocateIrp(1, FALSE, Adapter->DeviceObject->DriverObject);

    if(senseIrp == NULL) {
        DebugPrint((0, "SpCreateLogicalUnit: Could not allocate request sense "
                       "irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build the name for the device
    //

    if(Temporary == FALSE) {

        swprintf(wideDeviceName,
                 L"%wsPort%xPath%xTarget%xLun%x",
                 Adapter->DeviceName,
                 Adapter->PortNumber,
                 PathId,
                 TargetId,
                 Lun);
    } else {
        swprintf(wideDeviceName,
                 L"%wsPort%xRescan",
                 Adapter->DeviceName,
                 Adapter->PortNumber);

        PathId = 0xff;
        TargetId = 0xff;
        Lun = 0xff;

        ASSERT(Adapter->RescanLun == NULL);
    }

    RtlInitUnicodeString(&unicodeDeviceName, wideDeviceName);

    //
    // Round the size of the Hardware logical extension to the size of a
    // PVOID and add it to the port driver's logical extension.
    //

    if(Adapter->HwLogicalUnitExtensionSize != 0) {
        hwExtension = SpAllocatePool(
                          NonPagedPoolCacheAligned,
                          Adapter->HwLogicalUnitExtensionSize,
                          SCSIPORT_TAG_LUN_EXT,
                          Adapter->DeviceObject->DriverObject);

        if(hwExtension == NULL) {
            
            *NewLun = NULL;
            IoFreeIrp(senseIrp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(hwExtension,
                      Adapter->HwLogicalUnitExtensionSize);
    }

    //
    // If this is a temporary lun then allocate a large buffer to store the
    // identify data.
    //

    if(Temporary) {
        serialNumberBuffer = SpAllocatePool(
                                PagedPool,
                                VPD_MAX_BUFFER_SIZE,
                                SCSIPORT_TAG_TEMP_ID_BUFFER,
                                Adapter->DeviceObject->DriverObject);

        if(serialNumberBuffer == NULL) {

            if (hwExtension != NULL) {
                ExFreePool(hwExtension);
            }
            IoFreeIrp(senseIrp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        idBuffer = SpAllocatePool(PagedPool,
                                  VPD_MAX_BUFFER_SIZE,
                                  SCSIPORT_TAG_TEMP_ID_BUFFER,
                                  Adapter->DeviceObject->DriverObject);

        if(idBuffer == NULL) {

            if (hwExtension != NULL) {
                ExFreePool(hwExtension);
            }
            IoFreeIrp(senseIrp);
            ExFreePool(serialNumberBuffer);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(serialNumberBuffer, VPD_MAX_BUFFER_SIZE);
        RtlZeroMemory(idBuffer, VPD_MAX_BUFFER_SIZE);
    }

    //
    // Create a physical device object
    //

    status = IoCreateDevice(
                Adapter->DeviceObject->DriverObject,
                sizeof(LOGICAL_UNIT_EXTENSION),
                &unicodeDeviceName,
                FILE_DEVICE_MASS_STORAGE,
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                &pdo
                );

    if(NT_SUCCESS(status)) {

        PCOMMON_EXTENSION commonExtension;
        UCHAR i;
        ULONG bin;

        UCHAR rawDeviceName[64];
        ANSI_STRING ansiDeviceName;

        //
        // Set the device object's stack size
        //

        //
        // We need one stack location for the PDO to do lock tracking and
        // one stack location to issue scsi request to the FDO.
        //

        pdo->StackSize = 1;

        pdo->Flags |= DO_BUS_ENUMERATED_DEVICE;

        pdo->Flags |= DO_DIRECT_IO;

        pdo->AlignmentRequirement = Adapter->DeviceObject->AlignmentRequirement;

        //
        // Initialize the device extension for the root device
        //

        commonExtension = pdo->DeviceExtension;
        logicalUnitExtension = pdo->DeviceExtension;

        RtlZeroMemory(logicalUnitExtension, sizeof(LOGICAL_UNIT_EXTENSION));

        commonExtension->DeviceObject = pdo;
        commonExtension->IsPdo = TRUE;
        commonExtension->LowerDeviceObject = Adapter->DeviceObject;

        if(Scsi1) {
            commonExtension->MajorFunction = Scsi1DeviceMajorFunctionTable;
        } else {
            commonExtension->MajorFunction = DeviceMajorFunctionTable;
        }

        commonExtension->WmiInitialized            = FALSE;
        commonExtension->WmiMiniPortSupport        =
            Adapter->CommonExtension.WmiMiniPortSupport;

        commonExtension->WmiScsiPortRegInfoBuf     = NULL;
        commonExtension->WmiScsiPortRegInfoBufSize = 0;

        //
        // Initialize value to zero.  It will be incremented once pnp is aware
        // of its existance.
        //

        commonExtension->RemoveLock = 0;
#if DBG
        KeInitializeSpinLock(&commonExtension->RemoveTrackingSpinlock);
        commonExtension->RemoveTrackingList = NULL;

        ExInitializeNPagedLookasideList(
            &(commonExtension->RemoveTrackingLookasideList),
            NULL,
            NULL,
            0,
            sizeof(REMOVE_TRACKING_BLOCK),
            SCSIPORT_TAG_LOCK_TRACKING,
            64);

        commonExtension->RemoveTrackingLookasideListInitialized = TRUE;
#else
        commonExtension->RemoveTrackingSpinlock = (ULONG) -1L;
        commonExtension->RemoveTrackingList = (PVOID) -1L;
#endif

        commonExtension->CurrentPnpState = 0xff;
        commonExtension->PreviousPnpState = 0xff;

        //
        // Initialize the remove lock event.
        //

        KeInitializeEvent(
            &(logicalUnitExtension->CommonExtension.RemoveEvent),
            SynchronizationEvent,
            FALSE);

        logicalUnitExtension->PortNumber = Adapter->PortNumber;

        logicalUnitExtension->PathId = 0xff;
        logicalUnitExtension->TargetId = 0xff;
        logicalUnitExtension->Lun = 0xff;

        logicalUnitExtension->HwLogicalUnitExtension = hwExtension;

        logicalUnitExtension->AdapterExtension = Adapter;

        //
        // Give the caller the benefit of the doubt.
        //

        logicalUnitExtension->IsMissing = FALSE;

        //
        // The device cannot have been enumerated yet.
        //

        logicalUnitExtension->IsEnumerated = FALSE;

        //
        // Set timer counters to -1 to inidicate that there are no outstanding
        // requests.
        //

        logicalUnitExtension->RequestTimeoutCounter = -1;

        //
        // Initialize the maximum queue depth size.
        //

        logicalUnitExtension->MaxQueueDepth = 0xFF;

        //
        // Initialize the request list.
        //

        InitializeListHead(&logicalUnitExtension->RequestList);

        //
        // Initialize the push/pop list of SRB_DATA blocks for use with bypass
        // requests.
        //

        KeInitializeSpinLock(&(logicalUnitExtension->BypassSrbDataSpinLock));
        ExInitializeSListHead(&(logicalUnitExtension->BypassSrbDataList));
        for(i = 0; i < NUMBER_BYPASS_SRB_DATA_BLOCKS; i++) {
            ExInterlockedPushEntrySList(
                &(logicalUnitExtension->BypassSrbDataList),
                &(logicalUnitExtension->BypassSrbDataBlocks[i].Reserved),
                &(logicalUnitExtension->BypassSrbDataSpinLock));
        }

        //
        // Assume devices are powered on by default.
        //

        commonExtension->CurrentDeviceState = PowerDeviceD0;
        commonExtension->DesiredDeviceState = PowerDeviceUnspecified;

        //
        // Assume that we're being initialized in a working system.
        //

        commonExtension->CurrentSystemState = PowerSystemWorking;

        //
        // Setup the request sense resources.
        //

        logicalUnitExtension->RequestSenseIrp = senseIrp;

        //
        // If this is temporary record that fact in the logical unit extension
        // and save a pointer in the adapter (cleared when the LUN is
        // destroyed).  If it's real then stick it into the logical unit list.
        //

        logicalUnitExtension->IsTemporary = Temporary;

        //
        // Initialize

        RtlInitAnsiString(&(logicalUnitExtension->SerialNumber), serialNumberBuffer);

        if(serialNumberBuffer != NULL) {
            logicalUnitExtension->SerialNumber.MaximumLength = VPD_MAX_BUFFER_SIZE;
        }

        logicalUnitExtension->DeviceIdentifierPage = idBuffer;

        //
        // I guess this is as ready to be opened as it ever will be.
        //

        pdo->Flags &= ~DO_DEVICE_INITIALIZING;

        //
        // Initialize the lock & unlock request queue.
        //

        KeInitializeDeviceQueue(&(logicalUnitExtension->LockRequestQueue));
        logicalUnitExtension->CurrentLockRequest = NULL;

    } else {

        DebugPrint((1, "ScsiBusCreatePdo: Error %#08lx creating device object\n",
                       status));

        logicalUnitExtension = NULL;

        if(hwExtension != NULL) {
            ExFreePool(hwExtension);
        }
        IoFreeIrp(senseIrp);

        ExFreePool(serialNumberBuffer);
        ExFreePool(idBuffer);
    }

    *NewLun = logicalUnitExtension;

    return status;
}


VOID
SpSetLogicalUnitAddress(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )
{
    UCHAR i;
    ULONG bin;

    ASSERT_PDO(LogicalUnit->DeviceObject);

    ASSERT(LogicalUnit->PathId == 0xff);
    ASSERT(LogicalUnit->TargetId == 0xff);
    ASSERT(LogicalUnit->Lun == 0xff);

    LogicalUnit->PathId = PathId;
    LogicalUnit->TargetId = TargetId;
    LogicalUnit->Lun = Lun;

    SpAddLogicalUnitToBin(LogicalUnit->AdapterExtension, LogicalUnit);

    return;
}


VOID
SpClearLogicalUnitAddress(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    ASSERT_PDO(LogicalUnit->DeviceObject);
    ASSERT(LogicalUnit->IsTemporary == TRUE);

    SpRemoveLogicalUnitFromBin(LogicalUnit->AdapterExtension, LogicalUnit);

    LogicalUnit->PathId = 0xff;
    LogicalUnit->TargetId = 0xff;
    LogicalUnit->Lun = 0xff;

    return;
}


NTSTATUS
SpCloneAndSwapLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION TemplateLun,
    IN PINQUIRYDATA InquiryData,
    IN ULONG InquiryDataSize,
    OUT PLOGICAL_UNIT_EXTENSION *NewLun
    )
/*++

Routine Description:

    This routine will create a new logical unit object with the properties of
    TemplateLun.  The supplied inquiry data will be assigned to the new
    logical unit.  Finally the new logical unit will be swapped for
    TemplateLun in the adapter's logical unit list.

    TemplateLun must be a temporary logical unit which has been assigned an
    address and is present in the logical unit lists.

    Regardless of whether this function succeeds, the TemplateLun will be
    removed from the logical unit list (effectively swapped with nothing).

Arguments:

    TemplateLun - the logical unit to be cloned

    InquiryData, InquiryDataSize - the inquiry data to be used for the new
                                   logical unit

    NewLun - a location to store the pointer to the new logical unit.

Return Value:

    STATUS_SUCCESS indicates that a new lun has been created and swapped in
                   the logical unit list.

    error status indicates that the new logical unit could not be created for
    some reason.

--*/
{
    PADAPTER_EXTENSION adapter = TemplateLun->AdapterExtension;
    PSCSIPORT_DRIVER_EXTENSION driverExtension = 
                                IoGetDriverObjectExtension(
                                    adapter->DeviceObject->DriverObject,
                                    ScsiPortInitialize);

    UCHAR pathId, targetId, lun;

    PVOID serialNumber = NULL;
    USHORT serialNumberLength = 0;

    PVOID identifier = NULL;
    ULONG identifierLength = 0;

    PLOGICAL_UNIT_EXTENSION newLun;

    BOOLEAN scsi1;

    NTSTATUS status;

    ASSERT_PDO(TemplateLun->DeviceObject);
    ASSERT(TemplateLun->IsTemporary);

    *NewLun = NULL;

#if DBG
    newLun = GetLogicalUnitExtension(adapter,
                                     TemplateLun->PathId,
                                     TemplateLun->TargetId,
                                     TemplateLun->Lun,
                                     NULL,
                                     TRUE);
    ASSERT(newLun == TemplateLun);
#endif

    //
    // Wait for any outstanding i/o on the template lun to complete.
    //

    SpReleaseRemoveLock(TemplateLun->DeviceObject, SpInquireLogicalUnit);
    SpWaitForRemoveLock(TemplateLun->DeviceObject, SP_BASE_REMOVE_LOCK);

    //
    // Save the address away and then remove the template object from the
    // logical unit list.
    //

    pathId = TemplateLun->PathId;
    targetId = TemplateLun->TargetId;
    lun = TemplateLun->Lun;

    SpClearLogicalUnitAddress(TemplateLun);

    //
    // Before creating a named object, preallocate any resources we'll need
    // that SpCreateLogicalUnit doesn't provide.
    //

    if(TemplateLun->SerialNumber.Length != 0) {
        serialNumberLength = (TemplateLun->SerialNumber.Length +
                              sizeof(UNICODE_NULL));

        serialNumber = SpAllocatePool(PagedPool,
                                      serialNumberLength,
                                      SCSIPORT_TAG_ID_BUFFER,
                                      TemplateLun->DeviceObject->DriverObject);

        if(serialNumber == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if(TemplateLun->DeviceIdentifierPageLength != 0) {

        identifier = SpAllocatePool(
                        PagedPool,
                        TemplateLun->DeviceIdentifierPageLength,
                        SCSIPORT_TAG_ID_BUFFER,
                        TemplateLun->DeviceObject->DriverObject);

        if(identifier == NULL) {

            if(serialNumber != NULL) {
                ExFreePool(serialNumber);
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // If the lun is scsi-1 or if the magic registry flag was set then use the 
    // scsi 1 dispatch table for this device.
    //

    if((driverExtension->BusType == BusTypeScsi) && 
       ((InquiryData->ANSIVersion == 0) || 
        (InquiryData->ANSIVersion == 1) ||
        (TemplateLun->SpecialFlags.SetLunInCdb))) {
        scsi1 = TRUE;
    } else {
        scsi1 = FALSE;
    }

    //
    // Now create a new logical unit with the same address.
    //

    status = SpCreateLogicalUnit(adapter,
                                 pathId,
                                 targetId,
                                 lun,
                                 FALSE,
                                 scsi1,
                                 &newLun);

    if(!NT_SUCCESS(status)) {
        if(serialNumber != NULL) {
            ExFreePool(serialNumber);
        }
        if(identifier) {
            ExFreePool(identifier);
        }
        return status;
    }

    //
    // Copy the important information from the template logical unit over to
    // the new one.  Zero out the original so that we know to reallocate one
    // later.
    //

    newLun->HwLogicalUnitExtension = TemplateLun->HwLogicalUnitExtension;

    TemplateLun->HwLogicalUnitExtension = NULL;

    newLun->LuFlags = TemplateLun->LuFlags;
    newLun->IsVisible = TemplateLun->IsVisible;
    newLun->TargetLunList = TemplateLun->TargetLunList;
    newLun->SpecialFlags = TemplateLun->SpecialFlags;

    newLun->NeedsVerification = TemplateLun->NeedsVerification;

    newLun->CommonExtension.SrbFlags = TemplateLun->CommonExtension.SrbFlags;

    //
    // Copy over any characteristics flags which were set during enumeration.
    //

    newLun->DeviceObject->Characteristics |=
        (TemplateLun->DeviceObject->Characteristics & FILE_REMOVABLE_MEDIA);

    //
    // Copy the list of supported vital product data pages.
    //

    newLun->DeviceIdentifierPageSupported = TemplateLun->DeviceIdentifierPageSupported;
    newLun->SerialNumberPageSupported = TemplateLun->SerialNumberPageSupported;

    //
    // If this device reports a serial number in it's vital product data then
    // copy it in to the new lun.
    //

    if(serialNumber != NULL) {
        newLun->SerialNumber.Length = TemplateLun->SerialNumber.Length;
        newLun->SerialNumber.MaximumLength = serialNumberLength;
        newLun->SerialNumber.Buffer = serialNumber;
        RtlCopyMemory(newLun->SerialNumber.Buffer,
                      TemplateLun->SerialNumber.Buffer,
                      serialNumberLength);
    }

    //
    // If this has a device identifier page then copy it over two.
    //

    if(identifier != NULL) {
        newLun->DeviceIdentifierPage = identifier;
        newLun->DeviceIdentifierPageLength =
            TemplateLun->DeviceIdentifierPageLength;

        RtlCopyMemory(newLun->DeviceIdentifierPage,
                      TemplateLun->DeviceIdentifierPage,
                      newLun->DeviceIdentifierPageLength);
    }

    //
    // Copy the inquiry data over.
    //

    ASSERT(InquiryDataSize <= sizeof(INQUIRYDATA));
    RtlCopyMemory(&(newLun->InquiryData), InquiryData, InquiryDataSize);

    //
    // Acquire the appropriate remove locks on the new logical unit.
    //

    SpAcquireRemoveLock(newLun->DeviceObject, SP_BASE_REMOVE_LOCK);
    SpAcquireRemoveLock(newLun->DeviceObject, SpInquireLogicalUnit);

    //
    // Now insert this new lun into the logical unit list.
    //

    SpSetLogicalUnitAddress(newLun, pathId, targetId, lun);

    *NewLun = newLun;

    return status;
}


NTSTATUS
SpPrepareLogicalUnitForReuse(
    PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    PADAPTER_EXTENSION adapter = LogicalUnit->AdapterExtension;
    PCOMMON_EXTENSION commonExtension = &(LogicalUnit->CommonExtension);

    PVOID hwExtension = NULL;

    NTSTATUS status;

    ASSERT_PDO(LogicalUnit->DeviceObject);

    ASSERT(LogicalUnit->CommonExtension.WmiInitialized == FALSE);
    ASSERT(LogicalUnit->CommonExtension.WmiScsiPortRegInfoBuf == NULL);
    ASSERT(LogicalUnit->CommonExtension.WmiScsiPortRegInfoBufSize == 0);

    //
    // Clear the remove lock event.
    //

    ASSERT(LogicalUnit->CommonExtension.RemoveLock == 0);

    //
    // Initialize the remove lock event.
    //

    KeClearEvent(&(LogicalUnit->CommonExtension.RemoveEvent));

    LogicalUnit->PathId = 0xff;
    LogicalUnit->TargetId = 0xff;
    LogicalUnit->Lun = 0xff;

    //
    // Round the size of the Hardware logical extension to the size of a
    // PVOID and add it to the port driver's logical extension.
    //

    if((LogicalUnit->HwLogicalUnitExtension == NULL) &&
       (adapter->HwLogicalUnitExtensionSize != 0)) {
        hwExtension = SpAllocatePool(NonPagedPoolCacheAligned,
                                     adapter->HwLogicalUnitExtensionSize,
                                     SCSIPORT_TAG_LUN_EXT,
                                     LogicalUnit->DeviceObject->DriverObject);

        if(hwExtension == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        LogicalUnit->HwLogicalUnitExtension = hwExtension;
    }

    if(LogicalUnit->HwLogicalUnitExtension != NULL) {
        RtlZeroMemory(LogicalUnit->HwLogicalUnitExtension,
                      adapter->HwLogicalUnitExtensionSize);
    }

    LogicalUnit->IsMissing = FALSE;
    LogicalUnit->IsVisible = FALSE;

    ASSERT(LogicalUnit->IsEnumerated == FALSE);

    //
    // Device has no longer been removed.
    //

    LogicalUnit->CommonExtension.IsRemoved = NO_REMOVE;

    //
    // Clear cached infomation about the device identifier(s).
    //

    LogicalUnit->DeviceIdentifierPageSupported = FALSE;
    LogicalUnit->SerialNumberPageSupported = FALSE;

    RtlZeroMemory(LogicalUnit->SerialNumber.Buffer,
                  LogicalUnit->SerialNumber.MaximumLength);
    LogicalUnit->SerialNumber.Length = 0;

    return STATUS_SUCCESS;
}


BOOLEAN
FASTCALL
SpCompareInquiryData(
    IN PUCHAR InquiryData1,
    IN PUCHAR InquiryData2
    )

/*++

Routine Description:

    This routine compares two sets of inquiry data for equality.

Arguments:

    InquiryData1 - Supplies a pointer to the first inquiry data to compare.

    InquiryData2 - Supplies a pointer to the second inquiry data to compare.

Return Value:

    TRUE if the supplied inquiry data sets match, else FALSE.

--*/

{
    BOOLEAN match;
    UCHAR save1; 
    UCHAR save2;

    PAGED_CODE();

    if (((PINQUIRYDATA)InquiryData1)->ANSIVersion == 3) {

        //
        // SCSI3 Specific:
        // Save bytes 6 and 7.  These bytes contain vendor specific bits which
        // we're going to exclude from the comparison by just setting them equal 
        // to the corresponding bits in InquiryData2.  We'll restore them after 
        // the comparison.
        //

        save1 = InquiryData1[6];
        save2 = InquiryData1[7];

        //
        // Force the vendor specific bits in InquiryData1 to match the
        // corresponsing bits in InquiryData2.
        //

        InquiryData1[6] &= ~0x20;
        InquiryData1[7] &= ~0x01;
        InquiryData1[6] |= (InquiryData2[6] & 0x20);
        InquiryData1[7] |= (InquiryData2[7] & 0x01);
    }
    
    //
    // Compare the entire inquiry data blob.
    //

    match = RtlEqualMemory((((PUCHAR) InquiryData1) + 1), 
                           (((PUCHAR) InquiryData2) + 1), 
                           (INQUIRYDATABUFFERSIZE - 1));

    if (((PINQUIRYDATA)InquiryData1)->ANSIVersion == 3) {

        //
        // SCSI3 Specific:
        // Restore bytes 6 and 7 to their original state.
        //

        InquiryData1[6] = save1;
        InquiryData1[7] = save2;
    }

    return match;
}

NTSTATUS
SpInquireLogicalUnit(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN BOOLEAN ExposeDisconnectedLuns,
    IN OPTIONAL PLOGICAL_UNIT_EXTENSION RescanLun,
    OUT PLOGICAL_UNIT_EXTENSION *LogicalUnit,
    OUT PBOOLEAN CheckNextLun
    )

/*++

Routine Description:

    This routine will issue an inquiry to the logical unit at the specified
    address.  If there is not already a device object allocated for that
    logical unit, it will create one.  If it turns out the device does not
    exist, the logical unit can be destroyed before returning.

    If the logical unit exists, this routine will clear the PD_RESCAN_ACTIVE
    flag in the LuFlags to indicate that the unit is safe.

    If it does not respond, the IsMissing flag will be set to indicate that the
    unit should not be reported during enumeration.  If the IsRemoved flag has
    already been set on the logical unit extension, the device object will be
    destroyed.  Otherwise the device object will not be destroyed until a
    remove can be issued.

Arguments:

    Adapter - the adapter which this device would exist on

    PathId, TargetId, Lun - the address of the lun to inquire.

    ExposeDisconnectedLuns - indicates whether luns with a qualifier of
                             disconnected should be instantiated.

    RescanLun - a pointer to the logical unit extension to be used when
                checking logical unit numbers which do not currently have an
                extension associated with them.

    LogicalUnit - the logical unit created for this address - valid if
                  success is returned.

    CheckNextLun - indicates whether the caller should check the next
                   address for a logical unit.

Return Value:

    STATUS_NO_SUCH_DEVICE if the device does not exist.

    STATUS_SUCCESS if the device does exist.

    error description otherwise.

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit;

    INQUIRYDATA inquiryData;

    BOOLEAN newDevice = FALSE;
    BOOLEAN deviceMismatch = FALSE;

    UCHAR bytesReturned;

    NTSTATUS status;

    *LogicalUnit = NULL;
    *CheckNextLun = TRUE;

    PAGED_CODE();

    ASSERT(TargetId != BreakOnTarget);

    //
    // Find or create the device object for this address.  if it exists we'll
    // grab a temporary lock (using SpInquireLogicalUnit as a tag).
    //

    logicalUnit = GetLogicalUnitExtension(Adapter,
                                          PathId,
                                          TargetId,
                                          Lun,
                                          SpInquireLogicalUnit,
                                          TRUE);

    if(logicalUnit == NULL) {

        if(!ARGUMENT_PRESENT(RescanLun)) {

            //
            // No RescanLun was provided (generally means we're low on memory).
            // Don't scan this logical unit.
            //

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ASSERT(RescanLun->IsTemporary == TRUE);

        //
        // Acquire the temporary lock for the rescan lun.  We also grab the
        // base lock here.
        //

        SpAcquireRemoveLock(RescanLun->DeviceObject, SP_BASE_REMOVE_LOCK);
        SpAcquireRemoveLock(RescanLun->DeviceObject, SpInquireLogicalUnit);

        //
        // Set the address of the RescanLun appropriately - this operation
        // will make the logical unit available for our use.
        //

        SpSetLogicalUnitAddress(RescanLun, PathId, TargetId, Lun);

        logicalUnit = RescanLun;
        newDevice = TRUE;

    } else {
        ASSERT(logicalUnit->IsTemporary == FALSE);

        if(logicalUnit->IsMissing) {

            DebugPrint((1, "SpInquireLogicalUnit: logical unit @ (%d,%d,%d) "
                           "(%#p) is marked as missing and will not be "
                           "rescanned\n",
                           PathId, TargetId, Lun,
                           logicalUnit->DeviceObject));

            SpReleaseRemoveLock(logicalUnit->DeviceObject, SpInquireLogicalUnit);

            return STATUS_DEVICE_DOES_NOT_EXIST;
        }
    }

    //
    // Issue an inquiry to the potential logical unit.
    //

    DebugPrint((2, "SpInquireTarget: Try %s device @ Bus %d, Target %d, "
                   "Lun %d\n",
                   (newDevice ? "new" : "existing"),
                   PathId,
                   TargetId,
                   Lun));

    status = IssueInquiry(logicalUnit, FALSE, 0, &inquiryData, &bytesReturned);

    //
    // If the inquiry succeeds then check the data returned to determine if
    // there's a device there we should expose.
    //

    if(NT_SUCCESS(status)) {

        UCHAR qualifier;
        BOOLEAN present = FALSE;

        //
        // Check in the registry for special device flags for this lun.
        // If this is disconnected then set the qualifier to be 0 so that we
        // use the normal hardware ids instead of the "disconnected" ones.
        //

        qualifier = inquiryData.DeviceTypeQualifier;

        SpCheckSpecialDeviceFlags(logicalUnit, &(inquiryData));

        //
        // The inquiry was successful.  Determine whether a device is present.
        //

        switch(qualifier) {
            case DEVICE_QUALIFIER_ACTIVE: {

                //
                // Active devices are always present.
                //

                present = TRUE;
                break;
            }

            case DEVICE_QUALIFIER_NOT_ACTIVE: {

                if (Lun == 0) { 
                    //
                    // If we're using REPORT_LUNS commands for LUN 0 of a target
                    // then we should always indicate that LUN 0 is present.
                    //

                    if ((inquiryData.HiSupport == TRUE) ||
                        (logicalUnit->SpecialFlags.LargeLuns == TRUE)) {
                        present = TRUE;
                    }
                } else {
                    //
                    // Expose inactive luns only if the caller has requested that
                    // we do so.
                    //

                    present = ExposeDisconnectedLuns;
                }
                
                break;
            }

            case DEVICE_QUALIFIER_NOT_SUPPORTED: {
                present = FALSE;
                break;
            }

            default: {
                present = TRUE;
                break;
            }
        };

        if(present == FALSE) {

            //
            // setup an error value so we'll clean up the logical unit.
            // No need to do any more processing in this case.
            //

            status =  STATUS_NO_SUCH_DEVICE;

        } else if(newDevice == FALSE) {

            //
            // Verify that the inquiry data hasn't changed since the last time
            // we did a rescan.  Ignore the device type qualifier in this
            // check.
            //

            deviceMismatch = FALSE;

            if(inquiryData.DeviceType != logicalUnit->InquiryData.DeviceType) {

                DebugPrint((1, "SpInquireTarget: Found different type of "
                               "device @ (%d,%d,%d)\n",
                            PathId,
                            TargetId,
                            Lun));

                deviceMismatch = TRUE;
                status = STATUS_NO_SUCH_DEVICE;

            } else if(inquiryData.DeviceTypeQualifier !=
                      logicalUnit->InquiryData.DeviceTypeQualifier) {

                //
                // The device qualifiers don't match.  This isn't necessarily
                // a device mismatch if the existing device just went offline.
                // lower down we'll check the remaining inquiry data to
                // ensure that the LUN hasn't changed.
                //

                DebugPrint((1, "SpInquireLogicalUnit: Device @ (%d,%d,%d) type "
                               "qualifier was %d is now %d\n",
                            PathId,
                            TargetId,
                            Lun,
                            logicalUnit->InquiryData.DeviceTypeQualifier,
                            inquiryData.DeviceTypeQualifier
                            ));

                //
                // If the device was offline but no longer is then we
                // treat this as a device mismatch.  If the device has gone
                // offline then we pretend it's the same device.
                //
                // the goal is to provide PNP with a new device object when
                // bringing a device online, but to reuse the same device
                // object when bringing the device offline.
                //

                if(logicalUnit->InquiryData.DeviceTypeQualifier ==
                   DEVICE_QUALIFIER_NOT_ACTIVE) {

                    DebugPrint((1, "SpInquireLogicalUnit: device mismatch\n"));
                    deviceMismatch = TRUE;
                    status = STATUS_NO_SUCH_DEVICE;

                } else {

                    DebugPrint((1, "SpInquireLogicalUnit: device went offline\n"));
                    deviceMismatch = FALSE;
                    status = STATUS_SUCCESS;
                }
            }

            if (deviceMismatch == FALSE) {

                //
                // Ok, the device type and qualifier are compatible.  Now we
                // need to compare all applicable parts of the inquiry
                // data with the data we already have on the device at this
                // address to see if the device that answered this time is the
                // same one we found last time.
                //

                BOOLEAN same = SpCompareInquiryData(
                                   (PUCHAR)&(inquiryData),
                                   (PUCHAR)&(logicalUnit->InquiryData));

                if (same == FALSE) {

                    //
                    // Despite the fact that the device type & qualifier are
                    // compatible, a mismatch still occurred.
                    //

                    deviceMismatch = TRUE;
                    status = STATUS_NO_SUCH_DEVICE;

                    DebugPrint((1, "SpInquireLogicalUnit: Device @ (%d,%d,%d) has "
                                   "changed\n",
                                PathId,
                                TargetId,
                                Lun));
                } else {

                    //
                    // The device that answered is the same one we found
                    // earlier.  Depending on the SCSI version of the device, 
                    // we might need to update the vendor specific portions of
                    // the existing inquiry data for this device.
                    //
                    
                    if (inquiryData.ANSIVersion == 3) {

                        //
                        // For SCSI 3 devices, bytes 6 and 7 contain vendor
                        // specific bits that may differ between bus scans.
                        // Update these bytes of the existing inquiry data.
                        // 

                        ((PUCHAR)&(logicalUnit->InquiryData))[6] = 
                            ((PUCHAR)&(inquiryData))[6];
                        ((PUCHAR)&(logicalUnit->InquiryData))[7] = 
                            ((PUCHAR)&(inquiryData))[7];
                    }
                }
            }

        } else {

            DebugPrint((1, "SpInquireTarget: Found new %sDevice at address "
                           "(%d,%d,%d)\n",
                           (inquiryData.RemovableMedia ? "Removable " : ""),
                           PathId,
                           TargetId,
                           Lun));


        }

        if(NT_SUCCESS(status) && (deviceMismatch == FALSE)) {

            deviceMismatch = SpGetDeviceIdentifiers(logicalUnit, newDevice);

            if(deviceMismatch == FALSE) {
                ASSERT(newDevice);
                status = STATUS_NO_SUCH_DEVICE;
            }
        }

    } else {
        *CheckNextLun = FALSE;
    }

    if(!NT_SUCCESS(status)) {

        //
        // Nothing was found at this address. If it's a new lun which hasn't
        // been enumerated yet then just destroy it here.  If, however, it
        // has been enumerated we have to mark it as missing and wait for
        // PNP to learn that it's gone and ask us to remove it.  Then we can
        // destroy it.
        //
        // If we were just using the RescanLun to check this address then do
        // nothing - the rescan lun will be reset down below.
        //

        logicalUnit->IsMissing = TRUE;

        if(newDevice) {

            //
            // Release the temporary lock.  the base one will be released at
            // the end of this routine.
            //

            SpReleaseRemoveLock(logicalUnit->DeviceObject,
                                SpInquireLogicalUnit);
            logicalUnit = NULL;

        } else if (logicalUnit->IsEnumerated == FALSE) {

            //
            // It's safe to destroy this device object ourself since it's not
            // a device PNP is aware of.  However we may have outstanding i/o
            // due to pass-through requests or legacy class driver so we need
            // to properly wait for all i/o to complete.
            //

            logicalUnit->CommonExtension.CurrentPnpState =
                IRP_MN_REMOVE_DEVICE;

            SpReleaseRemoveLock(logicalUnit->DeviceObject, SpInquireLogicalUnit);

            //
            // Mark this device temporarily as visible so that
            // SpRemoveLogicalUnit will do the right thing.  Since the rescan
            // active bit is set the enumeration code won't return this device.
            //

            logicalUnit->IsVisible = TRUE;

            ASSERT(logicalUnit->IsEnumerated == FALSE);
            ASSERT(logicalUnit->IsMissing == TRUE);
            ASSERT(logicalUnit->IsVisible == TRUE);

            SpRemoveLogicalUnit(logicalUnit, IRP_MN_REMOVE_DEVICE);

            if(deviceMismatch) {

                //
                // Call this routine again.  This is the only recursion and
                // since we've deleted the device object there should be no
                // cause for a mismatch there.
                //

                status = SpInquireLogicalUnit(Adapter,
                                         PathId,
                                         TargetId,
                                         Lun,
                                         ExposeDisconnectedLuns,
                                         RescanLun,
                                         LogicalUnit,
                                         CheckNextLun);
            }

            return status;

        } else {

            //
            // CODEWORK - freeze and flush the queue.  This way we don't need
            // to deal with handling get next request calls
            //

            //
            // Mark the device as being mismatched so that it's destruction
            // will cause us to rescan the bus (and pickup the new device).
            //

            if(deviceMismatch) {
                logicalUnit->IsMismatched = TRUE;
            }
        }

    } else {

        logicalUnit->IsMissing = FALSE;

        if(newDevice) {

            status = SpCloneAndSwapLogicalUnit(logicalUnit,
                                               &(inquiryData),
                                               bytesReturned,
                                               &logicalUnit);

            if(!NT_SUCCESS(status)) {
                logicalUnit = NULL;
            }

            ASSERT(logicalUnit != RescanLun);

            //
            // Clear the new device flag so we don't attempt to clear the
            // address of the RescanLun down below.
            //

            newDevice = FALSE;

        } else {

            //
            // Update the state of the device and the device map entry if
            // necessary.
            //

            if(logicalUnit->InquiryData.DeviceTypeQualifier !=
               inquiryData.DeviceTypeQualifier) {

                logicalUnit->InquiryData.DeviceTypeQualifier =
                    inquiryData.DeviceTypeQualifier;

                SpUpdateLogicalUnitDeviceMapEntry(logicalUnit);
            }
        }

        if(logicalUnit != NULL) {

            if(logicalUnit->InquiryData.DeviceTypeQualifier ==
               DEVICE_QUALIFIER_NOT_ACTIVE) {
                logicalUnit->IsVisible = FALSE;

                //
                // Scsiport won't create a device-map entry for this device since
                // it's never been exposed to PNP (and definately won't be now).
                // Create one here.  If the init-device routine tries to generate
                // one later on down the road it will deal with this case just fine.
                //

                SpBuildDeviceMapEntry(&(logicalUnit->CommonExtension));
            } else {
                logicalUnit->IsVisible = TRUE;
            }

            if(inquiryData.RemovableMedia) {
                SET_FLAG(logicalUnit->DeviceObject->Characteristics,
                         FILE_REMOVABLE_MEDIA);
            }

            ASSERT(logicalUnit->IsTemporary != TRUE);
        }

        *LogicalUnit = logicalUnit;
    }

    //
    // If this was a new device then clean up the RescanLun.
    //

    if(newDevice) {
        SpWaitForRemoveLock(RescanLun->DeviceObject, SP_BASE_REMOVE_LOCK);
        SpClearLogicalUnitAddress(RescanLun);
    }

    if(logicalUnit) {
        ASSERT(logicalUnit != RescanLun);
        SpReleaseRemoveLock(logicalUnit->DeviceObject, SpInquireLogicalUnit);
    }

    return status;
}


NTSTATUS
SpSendSrbSynchronous(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OPTIONAL PIRP Irp,
    IN OPTIONAL PMDL Mdl,
    IN PVOID DataBuffer,
    IN ULONG TransferLength,
    IN OPTIONAL PVOID SenseInfoBuffer,
    IN OPTIONAL UCHAR SenseInfoBufferLength,
    OUT PULONG BytesReturned
    )
{
    KEVENT event;

    BOOLEAN irpAllocated = FALSE;
    BOOLEAN mdlAllocated = FALSE;

    PIO_STACK_LOCATION irpStack;

    PSENSE_DATA senseInfo = SenseInfoBuffer;

    ULONG retryCount = 0;

    NTSTATUS status;

    PAGED_CODE();

SendSrbSynchronousRetry:

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // If the caller provided an IRP we'll use it - if not we allocate one
    // here.
    //

    if(!ARGUMENT_PRESENT(Irp)) {

        Irp = SpAllocateIrp(LogicalUnit->DeviceObject->StackSize, 
                            FALSE, 
                            LogicalUnit->DeviceObject->DriverObject);

        if(Irp == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        irpAllocated = TRUE;
    }

    if(ARGUMENT_PRESENT(DataBuffer)) {
        ASSERT(TransferLength != 0);

        if(!ARGUMENT_PRESENT(Mdl)) {

            Mdl = SpAllocateMdl(DataBuffer,
                                TransferLength,
                                FALSE,
                                FALSE,
                                NULL,
                                LogicalUnit->DeviceObject->DriverObject);

            if(Mdl == NULL) {
                IoFreeIrp(Irp);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            MmBuildMdlForNonPagedPool(Mdl);
        }

        Irp->MdlAddress = Mdl;
    } else {
        ASSERT(TransferLength == 0);
        ASSERT(!ARGUMENT_PRESENT(Mdl));
    }

    irpStack = IoGetNextIrpStackLocation(Irp);

    //
    // Mark the minor function to indicate that this is an internal scsiport
    // request and that the start state of the device can be ignored.
    //

    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->MinorFunction = 1;

    irpStack->Parameters.Scsi.Srb = Srb;

    Srb->SrbStatus = Srb->ScsiStatus = 0;

    Srb->OriginalRequest = Irp;

    //
    // Enable auto request sense.
    //

    if(ARGUMENT_PRESENT(SenseInfoBuffer)) {
        Srb->SenseInfoBuffer = SenseInfoBuffer;
        Srb->SenseInfoBufferLength = SenseInfoBufferLength;
    } else {
        Srb->SenseInfoBuffer = NULL;
        Srb->SenseInfoBufferLength = 0;
        SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DISABLE_AUTOSENSE);
    }

    if(ARGUMENT_PRESENT(Mdl)) {
        Srb->DataBuffer = MmGetMdlVirtualAddress(Mdl);
        Srb->DataTransferLength = TransferLength;
    } else {
        Srb->DataBuffer = NULL;
        Srb->DataTransferLength = 0;
    }

    //
    // Call port driver to handle this request.
    //

    IoSetCompletionRoutine(Irp,
                           SpSignalCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    KeEnterCriticalRegion();

    status = IoCallDriver(LogicalUnit->DeviceObject, Irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    status = Irp->IoStatus.Status;

    *BytesReturned = (ULONG) Irp->IoStatus.Information;

    if(Srb->SrbStatus == SRB_STATUS_PENDING) {

        //
        // Request was never even issued to the controller.
        //

        ASSERT(!NT_SUCCESS(status));

    } else if (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        DebugPrint((2,"SpSendSrbSynchronous: Command failed SRB status %x\n",
                    Srb->SrbStatus));

        //
        // Unfreeze queue if necessary
        //

        if (Srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

            DebugPrint((3, "SpSendSrbSynchronous: Unfreeze Queue TID %d\n",
                Srb->TargetId));

            LogicalUnit->LuFlags &= ~LU_QUEUE_FROZEN;

            GetNextLuRequestWithoutLock(LogicalUnit);
        }

        //
        // NOTE: if INQUIRY fails with a data underrun,
        //      indicate success and let the class drivers
        //      determine whether the inquiry information
        //      is useful.
        //

        if (SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

            //
            // Copy INQUIRY buffer to LUNINFO.
            //

            DebugPrint((1,"SpSendSrbSynchronous: Data underrun at TID %d\n",
                        LogicalUnit->TargetId));

            status = STATUS_SUCCESS;

        } else if ((Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
                   (senseInfo->SenseKey == SCSI_SENSE_ILLEGAL_REQUEST)) {

             //
             // A sense key of illegal request was recieved.  This indicates
             // that the logical unit number of not valid but there is a
             // target device out there.
             //

             status = STATUS_INVALID_DEVICE_REQUEST;

        } else {
            //
            // If the selection did not time out then retry the request.
            //

            if ((SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SELECTION_TIMEOUT) &&
                (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_NO_DEVICE) &&
                (retryCount++ < INQUIRY_RETRY_COUNT)) {

                DebugPrint((2,"SpSendSrbSynchronous: Retry %d\n", retryCount));
                KeLeaveCriticalRegion();
                goto SendSrbSynchronousRetry;
            }

            status = SpTranslateScsiStatus(Srb);
        }

    } else {

        status = STATUS_SUCCESS;
    }

    KeLeaveCriticalRegion();

    return status;
}

NTSTATUS
IssueInquiry(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN EnableVitalProductData,
    IN UCHAR PageCode,
    OUT PVOID InquiryData,
    OUT PUCHAR BytesReturned
    )

/*++

Routine Description:

    Build IRP, SRB and CDB for SCSI INQUIRY command.

    This routine MUST be called while holding the enumeration lock.

Arguments:

    LogicalUnit - address of the logical unit extension

    EnableVitalProductData - indicates whether the EVPD bit should be set in 
                             the inquiry data causing the LUN to return product
                             data pages (specified by page code below) rather
                             than the standard inquiry data.

    PageCode - which VPD page to retrieve

    InquiryData - the location to store the inquiry data for the LUN.

    BytesReturned - the number of bytes of inquiry data returned.


Return Value:

    NTSTATUS

--*/

{
    PIRP irp;
    SCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    PVOID dataBuffer;
    PSENSE_DATA senseInfoBuffer;

    UCHAR allocationLength;
    ULONG bytesReturned;

    NTSTATUS status;

    PAGED_CODE();

    dataBuffer = LogicalUnit->AdapterExtension->InquiryBuffer;
    senseInfoBuffer = LogicalUnit->AdapterExtension->InquirySenseBuffer;

    ASSERT(dataBuffer != NULL);
    ASSERT(senseInfoBuffer != NULL);

    irp = LogicalUnit->AdapterExtension->InquiryIrp;

    IoInitializeIrp(irp,
                    IoSizeOfIrp(INQUIRY_STACK_LOCATIONS),
                    INQUIRY_STACK_LOCATIONS);

    //
    // Fill in SRB fields.
    //

    RtlZeroMemory(dataBuffer, SP_INQUIRY_BUFFER_SIZE);
    RtlZeroMemory(senseInfoBuffer, SENSE_BUFFER_SIZE);
    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb.Length = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set flags to disable synchronous negociation.
    //

    srb.SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Set timeout to 2 seconds.
    //

    srb.TimeOutValue = 4;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY3.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    if(EnableVitalProductData) {
        allocationLength = VPD_MAX_BUFFER_SIZE;
    } else {
        allocationLength = INQUIRYDATABUFFERSIZE;
    }

    cdb->CDB6INQUIRY3.AllocationLength = allocationLength;

    cdb->CDB6INQUIRY3.EnableVitalProductData = TEST(EnableVitalProductData);

    if(EnableVitalProductData == FALSE) {
        ASSERT(PageCode == 0);
    }

    cdb->CDB6INQUIRY3.PageCode = PageCode;

    status = SpSendSrbSynchronous(LogicalUnit,
                                  &srb,
                                  irp,
                                  LogicalUnit->AdapterExtension->InquiryMdl,
                                  dataBuffer,
                                  allocationLength,
                                  senseInfoBuffer,
                                  SENSE_BUFFER_SIZE,
                                  &bytesReturned
                                  );

    ASSERT(bytesReturned <= allocationLength);

    //
    // Return the inquiry data for the device if the call was successful.
    // Otherwise cleanup.
    //

    if(NT_SUCCESS(status)) {

        //
        // If the caller passed in the inquiry buffer then don't bother to copy
        // the data.
        //

        if(InquiryData != dataBuffer) {
            RtlCopyMemory(InquiryData, dataBuffer, bytesReturned);
        }
        *BytesReturned = (UCHAR) bytesReturned;
    } else if(BreakOnMissingLun) {
       ASSERT(LogicalUnit->IsTemporary == TRUE);
    }
    return status;
}


BOOLEAN
SpGetDeviceIdentifiers(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN NewDevice
    )
/*++

Routine Description:

    This routine retreives the device identifiers supported by the logical
    unit in question and compares them to the ones (if any) which are currently
    saved in the LogicalUnit extension.  If they do not match this routine
    will return false to indicate a device mismatch.

    As a side effect this routine will save the serial numbers for new devices
    in the logical unit extension, as well as a list of the supported vital
    product data pages.

Arguments:

    LogicalUnit - the logical unit being prodded.

    NewDevice - whether this device has been prodded before or not.  If it has
                not been then the list of supported EVPD pages will need to be
                retreived.

Return Value:

    TRUE if the data retrieved matches the data which was stored in the
         logical unit extension (TRUE is always returned for a new device).

    FALSE otherwise.
--*/
{
    PVOID buffer = LogicalUnit->AdapterExtension->InquiryBuffer;

    UCHAR bytesReturned;

    NTSTATUS status;

    PAGED_CODE();

    //
    // If this is a new device then get the list of supported VPD pages and
    // process it.
    //

    if(NewDevice) {
        PVPD_SUPPORTED_PAGES_PAGE supportedPages = buffer;
        UCHAR i;

        ASSERT(LogicalUnit->DeviceIdentifierPageSupported == FALSE);
        ASSERT(LogicalUnit->SerialNumberPageSupported == FALSE);

        //
        // If this device is a known non-compliant device that does not support
        // VPD 0x00 but does support VPDs 0x80 and/or 0x83, bypass the INQUIRY
        // and just indicate that the LU does support the other VPDs based on
        // the special flags.
        //

        if (LogicalUnit->SpecialFlags.NonStandardVPD == 0) {

            status = IssueInquiry(LogicalUnit,
                                  TRUE,
                                  VPD_SUPPORTED_PAGES,
                                  buffer,
                                  &bytesReturned);

            if(!NT_SUCCESS(status)) {
                return TRUE;
            }

            if(bytesReturned < sizeof(VPD_SUPPORTED_PAGES_PAGE)) {
                
                //
                // If the device didn't return enough data to include any pages
                // then we're done.
                //
                
                return TRUE;
            }

            for(i = 0; i < supportedPages->PageLength; i++) {
                switch(supportedPages->SupportedPageList[i]) {
                   case VPD_SERIAL_NUMBER: {
                       LogicalUnit->SerialNumberPageSupported = TRUE;
                       break;
                   }
                   case VPD_DEVICE_IDENTIFIERS: {
                       LogicalUnit->DeviceIdentifierPageSupported = TRUE;
                       break;
                   }
                   default: {
                       break;
                   }
                }
            }

        } else {

            ULONG vpdFlags = LogicalUnit->SpecialFlags.NonStandardVPD;

            //
            // This is one of the devices that does not support VPD 0x00 but
            // does support one or more of the other VPD pages.
            //

            LogicalUnit->SerialNumberPageSupported = 
                (vpdFlags & NON_STANDARD_VPD_SUPPORTS_PAGE80) ? TRUE : FALSE;
            
            LogicalUnit->DeviceIdentifierPageSupported = 
                (vpdFlags & NON_STANDARD_VPD_SUPPORTS_PAGE83) ? TRUE : FALSE;
        }
    }

    //
    // If this device supports the serial number page then retrieve it,
    // convert it into an ansi string, and compare it to the one previously
    // retreived (if there was a previous attempt).
    //

    if(LogicalUnit->SerialNumberPageSupported) {
        PVPD_SERIAL_NUMBER_PAGE serialNumberPage = buffer;
        ANSI_STRING serialNumber;

        status = IssueInquiry(LogicalUnit,
                              TRUE,
                              VPD_SERIAL_NUMBER,
                              serialNumberPage,
                              &bytesReturned);

        if(!NT_SUCCESS(status)) {

            DebugPrint((0, "SpGetDeviceIdentifiers: Error %#08lx retreiving "
                           "serial number page from lun %#p\n",
                        status, LogicalUnit));

            //
            // We can't get the serial number - give this device the benefit
            // of the doubt.
            //

            return TRUE;
        }

        //
        // Fix for bug #143313:
        // On rare occasions, junk appears to get copied into the serial
        // number buffer.  This causes us problems because the junk is 
        // interpreted as part of the serial number.  When we compare the
        // string containing junk to a previously acquired serial number, the
        // comparison fails.  In an effort to fix, I'll zero out all bytes
        // in the buffer following the actual serial number.  This will only
        // work if the PageSize reported by the device does NOT include the
        // junk bytes.
        //

        RtlZeroMemory(
            serialNumberPage->SerialNumber + serialNumberPage->PageLength,
            SP_INQUIRY_BUFFER_SIZE - 4 - serialNumberPage->PageLength);

        //
        // If this is a device known to return binary SN data, convert the
        // returned bytes to ascii.  
        //
        // Note: It is assumed that the SN data is numeric.  Any bytes that 
        // cannot be converted to an ASCII hex number, are left alone.
        //

        if (LogicalUnit->SpecialFlags.BinarySN != 0) {
            int i;
            PUCHAR p = serialNumberPage->SerialNumber;
            for (i = 0; i < serialNumberPage->PageLength; i++) {
                if (*p < 0xa) {
                    *p += '0';
                } else if (*p < 0x10) {
                    *p += 'A';
                } else {
                    ASSERT(FALSE && "Data out of range");
                }
                p++;
            }
        }

        //
        // Create a string using the serial number.  The buffer was zeroed
        // before transfer (and is one character longer than the max buffer
        // which can be returned) so the string is null terminated.
        //

        RtlInitAnsiString(&(serialNumber), serialNumberPage->SerialNumber);
        
        if(NewDevice) {

            //
            // A new device will always have a large buffer into which we can
            // copy the string.  The clone & swap process will take care of
            // moving this into a smaller sized buffer.
            //

            ASSERT(LogicalUnit->SerialNumber.MaximumLength != 0);
            ASSERT(LogicalUnit->SerialNumber.Buffer != NULL);

            RtlCopyString(&(LogicalUnit->SerialNumber), &serialNumber);

        } else if(LogicalUnit->SerialNumber.Buffer == NULL &&
                  serialNumber.Length != 0) {

            //
            // ISSUE-2000-25-02-peterwie
            // We didn't previously have a serial number.  Since the device
            // claimed that it supported one it's likely we got an error back
            // when we tried to retreive it.  Since we didn't get back one
            // now it was a transient error (ie. not likely to be a violation
            // of the spec).  Should we assign the serial number to the device
            // here?  Or should we have failed to instantiate a device with
            // a serial number we couldn't retreive?
            //

            ASSERT(FALSE);

        } else if(RtlEqualString(&serialNumber,
                                 &(LogicalUnit->SerialNumber),
                                 FALSE) == FALSE) {
            DebugPrint((1, "SpInquireLogicalUnit: serial number mismatch\n"));
            return FALSE;
        }
    }

    //
    // If this device supports the device identifiers page then read it out.
    // We don't use this page to check for mismatches at the moment, so we
    // just read it out of the device if this is a new device.
    //

    if((NewDevice == TRUE) && (LogicalUnit->DeviceIdentifierPageSupported)) {

        status = IssueInquiry(LogicalUnit,
                              TRUE,
                              VPD_DEVICE_IDENTIFIERS,
                              buffer,
                              &bytesReturned);

        if(NT_SUCCESS(status)) {

            //
            // Copy the page into the buffer allocated in the template logical
            // unit.  The clone & swap process will take care of moving this
            // into an appropriately sized buffer in the new lun.
            //

            ASSERT(LogicalUnit->DeviceIdentifierPage != NULL);

            RtlCopyMemory(LogicalUnit->DeviceIdentifierPage,
                          buffer,
                          bytesReturned);
            LogicalUnit->DeviceIdentifierPageLength = bytesReturned;
        } else {
            DebugPrint((1, "SpGetDeviceIdentifiers: Error %#08lx retreiving "
                           "serial number page from lun %#p\n",
                        status, LogicalUnit));
            LogicalUnit->DeviceIdentifierPageLength = 0;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\lock.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    lock.c

Abstract:

    This is the NT SCSI port driver.

Authors:

    Peter Wieland

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#define KEEP_COMPLETE_REQUEST

#if DBG
static const char *__file__ = __FILE__;
#endif

#include "port.h"

LONG LockHighWatermark = 0;
LONG LockLowWatermark = 0;
LONG MaxLockedMinutes = 5;

VOID
FASTCALL
SpFreeSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    );

VOID
FASTCALL
SpFreeBypassSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    );


#if DBG
ULONG
FASTCALL
SpAcquireRemoveLockEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag,
    IN PCSTR File,
    IN ULONG Line
    )

/*++

Routine Description:

    This routine is called to acquire the remove lock on the device object.
    While the lock is held, the caller can assume that no pending pnp REMOVE
    requests will be completed.

    The lock should be acquired immediately upon entering a dispatch routine.
    It should also be acquired before creating any new reference to the
    device object if there's a chance of releasing the reference before the
    new one is done.

    This routine will return TRUE if the lock was successfully acquired or
    FALSE if it cannot be because the device object has already been removed.

Arguments:

    DeviceObject - the device object to lock

    Tag - Used for tracking lock allocation and release.  If an irp is
          specified when acquiring the lock then the same Tag must be
          used to release the lock before the Tag is completed.

Return Value:

    The value of the IsRemoved flag in the device extension.  If this is
    non-zero then the device object has received a Remove irp and non-cleanup
    IRP's should fail.

    If the value is REMOVE_COMPLETE, the caller should not even release the
    lock.

--*/

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    LONG lockValue;

#if DBG
    PREMOVE_TRACKING_BLOCK *removeTrackingList =
        &((PREMOVE_TRACKING_BLOCK) commonExtension->RemoveTrackingList);

    PREMOVE_TRACKING_BLOCK trackingBlock;
#endif

    //
    // Grab the remove lock
    //

    lockValue = InterlockedIncrement(&commonExtension->RemoveLock);

    DebugPrint((4, "SpAcquireRemoveLock: Acquired for Object %#p & irp "
                   "%#p - count is %d\n",
                DeviceObject,
                Tag,
                lockValue));

    ASSERTMSG("SpAcquireRemoveLock - lock value was negative : ",
              (lockValue > 0));

    ASSERTMSG("RemoveLock increased to meet LockHighWatermark",
              ((LockHighWatermark == 0) ||
               (lockValue != LockHighWatermark)));

#if DBG

    if(commonExtension->IsRemoved != REMOVE_COMPLETE) {

        trackingBlock = ExAllocateFromNPagedLookasideList(
                            &(commonExtension->RemoveTrackingLookasideList));

        if(trackingBlock == NULL) {
            KIRQL oldIrql;

            KeAcquireSpinLock(&commonExtension->RemoveTrackingSpinlock,
                              &oldIrql);
            commonExtension->RemoveTrackingUntrackedCount++;
            DebugPrint((1, ">>>>SpAcquireRemoveLock: Cannot track Tag %#p - "
                           "currently %d untracked requests\n",
                        Tag,
                        commonExtension->RemoveTrackingUntrackedCount));
            KeReleaseSpinLock(&commonExtension->RemoveTrackingSpinlock,
                              oldIrql);
        } else {

            KIRQL oldIrql;

            trackingBlock->Tag = Tag;

            trackingBlock->File = File;
            trackingBlock->Line = Line;

            KeQueryTickCount((&trackingBlock->TimeLocked));

            KeAcquireSpinLock(&commonExtension->RemoveTrackingSpinlock,
                              &oldIrql);

            while(*removeTrackingList != NULL) {

                if((*removeTrackingList)->Tag > Tag) {
                    break;
                }

                if((*removeTrackingList)->Tag == Tag) {

                    DebugPrint((0, ">>>>SpAcquireRemoveLock - already tracking "
                                   "Tag %#p\n", Tag));
                    DebugPrint((0, ">>>>SpAcquireRemoveLock - acquired in "
                                   "file %s on line %d\n",
                                    (*removeTrackingList)->File,
                                    (*removeTrackingList)->Line));
                    ASSERT(FALSE);
                }

                removeTrackingList = &((*removeTrackingList)->NextBlock);
            }

            trackingBlock->NextBlock = *removeTrackingList;
            *removeTrackingList = trackingBlock;

            KeReleaseSpinLock(&commonExtension->RemoveTrackingSpinlock,
                              oldIrql);

        }
    }

#endif
    return (commonExtension->IsRemoved);
}
#endif


VOID
FASTCALL
SpReleaseRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PIRP Tag
    )

/*++

Routine Description:

    This routine is called to release the remove lock on the device object.  It
    must be called when finished using a previously locked reference to the
    device object.  If an Tag was specified when acquiring the lock then the
    same Tag must be specified when releasing the lock.

    When the lock count reduces to zero, this routine will signal the waiting
    remove Tag to delete the device object.  As a result the DeviceObject
    pointer should not be used again once the lock has been released.

Arguments:

    DeviceObject - the device object to lock

    Tag - The irp (if any) specified when acquiring the lock.  This is used
          for lock tracking purposes

Return Value:

    none

--*/

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    LONG lockValue;

#if DBG
    PREMOVE_TRACKING_BLOCK *listEntry =
        &((PREMOVE_TRACKING_BLOCK) commonExtension->RemoveTrackingList);

    BOOLEAN found = FALSE;

    LONGLONG maxCount;

    KIRQL oldIrql;

    if(commonExtension->IsRemoved == REMOVE_COMPLETE) {
        return;
    }

    //
    // Check the tick count and make sure this thing hasn't been locked
    // for more than MaxLockedMinutes.
    //

    maxCount = KeQueryTimeIncrement() * 10;     // microseconds
    maxCount *= 1000;                           // milliseconds
    maxCount *= 1000;                           // seconds
    maxCount *= 60;                             // minutes
    maxCount *= MaxLockedMinutes;

    DebugPrint((4, "SpReleaseRemoveLock: maxCount = %0I64x\n", maxCount));

    KeAcquireSpinLock(&commonExtension->RemoveTrackingSpinlock,
                      &oldIrql);

    while(*listEntry != NULL) {

        PREMOVE_TRACKING_BLOCK block;
        LARGE_INTEGER difference;

        block = *listEntry;

        KeQueryTickCount((&difference));

        difference.QuadPart -= block->TimeLocked.QuadPart;

        DebugPrint((4, "SpReleaseRemoveLock: Object %#p (tag %#p) locked "
                       "for %I64d ticks\n", DeviceObject, block->Tag, difference.QuadPart));

        if(difference.QuadPart >= maxCount) {

            DebugPrint((0, ">>>>SpReleaseRemoveLock: Object %#p (tag %#p) locked "
                           "for %I64d ticks - TOO LONG\n", DeviceObject, block->Tag, difference.QuadPart));
            DebugPrint((0, ">>>>SpReleaseRemoveLock: Lock acquired in file "
                           "%s on line %d\n", block->File, block->Line));
            ASSERT(FALSE);
        }

        if((found == FALSE) && ((*listEntry)->Tag == Tag)) {

            *listEntry = block->NextBlock;
            ExFreeToNPagedLookasideList(
                &(commonExtension->RemoveTrackingLookasideList),
                block);
            found = TRUE;

        } else {

            listEntry = &((*listEntry)->NextBlock);

        }
    }

    if(!found) {

        if(commonExtension->RemoveTrackingUntrackedCount == 0) {
            DebugPrint((0, ">>>>SpReleaseRemoveLock: Couldn't find Tag %#p "
                           "in the lock tracking list\n",
                        Tag));
            ASSERT(FALSE);
        } else {

            DebugPrint((1, ">>>>SpReleaseRemoveLock: Couldn't find Tag %#p "
                           "in the lock tracking list - may be one of the "
                           "%d untracked requests still outstanding\n",
                        Tag,
                        commonExtension->RemoveTrackingUntrackedCount));

            commonExtension->RemoveTrackingUntrackedCount--;
            ASSERT(commonExtension->RemoveTrackingUntrackedCount >= 0);
        }
    }

    KeReleaseSpinLock(&commonExtension->RemoveTrackingSpinlock, oldIrql);

#endif

    lockValue = InterlockedDecrement(&commonExtension->RemoveLock);

    DebugPrint((4, "SpReleaseRemoveLock: Released for Object %#p & irp "
                   "%#p - count is %d\n",
                DeviceObject,
                Tag,
                lockValue));

    ASSERT(lockValue >= 0);

    ASSERTMSG("RemoveLock decreased to meet LockLowWatermark",
              ((LockLowWatermark == 0) || !(lockValue == LockLowWatermark)));

    if(lockValue == 0) {

        ASSERT(commonExtension->IsRemoved);

        //
        // The device needs to be removed.  Signal the remove event
        // that it's safe to go ahead.
        //

        DebugPrint((3, "SpReleaseRemoveLock: Release for object %#p & "
                       "irp %#p caused lock to go to zero\n",
                    DeviceObject,
                    Tag));

        KeSetEvent(&commonExtension->RemoveEvent,
                   IO_NO_INCREMENT,
                   FALSE);

    }
    return;
}


VOID
FASTCALL
SpCompleteRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OPTIONAL PSRB_DATA SrbData,
    IN CCHAR PriorityBoost
    )

/*++

Routine Description:

    This routine is a wrapper around IoCompleteRequest.  It is used primarily
    for debugging purposes.  The routine will assert if the Irp being completed
    is still holding the release lock.

Arguments:


Return Value:

    none

--*/

{

    PADAPTER_EXTENSION adapterExtension = DeviceObject->DeviceExtension;
#if DBG
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PREMOVE_TRACKING_BLOCK *listEntry =
        &((PREMOVE_TRACKING_BLOCK) commonExtension->RemoveTrackingList);

    KIRQL oldIrql;

    KeAcquireSpinLock(&commonExtension->RemoveTrackingSpinlock,
                      &oldIrql);

    while(*listEntry != NULL) {

        if((*listEntry)->Tag == Irp) {
            break;
        }

        listEntry = &((*listEntry)->NextBlock);
    }

    if(*listEntry != NULL) {

        DebugPrint((0, ">>>>SpCompleteRequest: Irp %#p completed while "
                       "still holding the remove lock\n",
                    Irp));
        DebugPrint((0, ">>>>SpReleaseRemoveLock: Lock acquired in file "
                       "%s on line %d\n", (*listEntry)->File, (*listEntry)->Line));
        ASSERT(FALSE);
    }

    KeReleaseSpinLock(&commonExtension->RemoveTrackingSpinlock, oldIrql);

    if(ARGUMENT_PRESENT(SrbData)) {
        PLOGICAL_UNIT_EXTENSION logicalUnit;

        ASSERT_SRB_DATA(SrbData);
        ASSERT(SrbData->ScatterGatherList == NULL);

        ASSERT_SRB_DATA(SrbData);
        ASSERT(SrbData->CurrentIrp == Irp);

        logicalUnit = SrbData->LogicalUnit;

        ASSERT(logicalUnit != NULL);
        ASSERT(logicalUnit->CurrentUntaggedRequest != SrbData);
        ASSERT_PDO(logicalUnit->CommonExtension.DeviceObject);

        ASSERT(SrbData->RemappedMdl == NULL);
    }

#endif

    //
    // If the caller specified an SRB_DATA structure for the completion then
    // we will free it to the lookaside list, fix the OriginalIrp value in the
    // srb and release the queue-tag value assigned to the device.
    //

    if(ARGUMENT_PRESENT(SrbData)) {
        PLOGICAL_UNIT_EXTENSION logicalUnit;

        logicalUnit = SrbData->LogicalUnit;

        ASSERTMSG("Attempt to complete blocked request: ",
                  ((logicalUnit->ActiveFailedRequest != SrbData) &&
                   (logicalUnit->BlockedFailedRequest != SrbData)));

        if((SrbData->CurrentSrb->Function == SRB_FUNCTION_LOCK_QUEUE) ||
           (SrbData->CurrentSrb->Function == SRB_FUNCTION_UNLOCK_QUEUE)) {
            ASSERT(logicalUnit->CurrentLockRequest == SrbData);
            SpStartLockRequest(logicalUnit, NULL);
        }

        SrbData->CurrentSrb->OriginalRequest = SrbData->CurrentIrp;
        SrbData->CurrentIrp = NULL;
        SrbData->CurrentSrb = NULL;

        ASSERT(SrbData->FreeRoutine != NULL);
        ASSERT((SrbData->FreeRoutine == SpFreeSrbData) ||
               (SrbData->FreeRoutine == SpFreeBypassSrbData));

        SrbData->FreeRoutine(logicalUnit->AdapterExtension, SrbData);
        SpReleaseRemoveLock(logicalUnit->CommonExtension.DeviceObject, Irp);
    }

    IoCompleteRequest(Irp, PriorityBoost);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\init.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    port.c

Abstract:

    This is the NT SCSI port driver.  This file contains the initialization
    code.

Authors:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include "port.h"

#define __FILE_ID__ 'init'

#if DBG
static const char *__file__ = __FILE__;
#endif

//
// Instantiate GUIDs for this module
//
#include <initguid.h>
#include <devguid.h>
#include <ntddstor.h>
#include <wdmguid.h>

ULONG ScsiPortLegacyAdapterDetection = FALSE;
PVOID ScsiDirectory = NULL;

//
// Global list of adapter device objects.  This is used to maintain a tag
// value for all the adapters.  This tag is used as a lookup key by the
// lookaside list allocators in order to find the device object.
//

KSPIN_LOCK ScsiGlobalAdapterListSpinLock;
PDEVICE_OBJECT *ScsiGlobalAdapterList = (PVOID) -1;
ULONG ScsiGlobalAdapterListElements = 0;

//
// Indicates that the system can handle 64 bit physical addresses.
//

ULONG Sp64BitPhysicalAddresses = FALSE;

//
// Debugging switches.
//

ULONG SpRemapBuffersByDefault = FALSE;

VOID
SpCreateScsiDirectory(
    VOID
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

ULONG
SpGetBusData(
    IN PADAPTER_EXTENSION Adapter,
    IN PDEVICE_OBJECT Pdo OPTIONAL,
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

NTSTATUS
SpAllocateDriverExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT PSCSIPORT_DRIVER_EXTENSION *DriverExtension
    );

ULONG
SpQueryPnpInterfaceFlags(
    IN PSCSIPORT_DRIVER_EXTENSION DriverExtension,
    IN INTERFACE_TYPE InterfaceType
    );

NTSTATUS
SpInitializeSrbDataLookasideList(
    IN PDEVICE_OBJECT AdapterObject
    );

VOID
SpInitializeRequestSenseParams(
    IN PADAPTER_EXTENSION AdapterExtension
    );

VOID
SpInitializePerformanceParams(
    IN PADAPTER_EXTENSION AdapterExtension
    );

VOID
SpInitializePowerParams(
    IN PADAPTER_EXTENSION AdapterExtension
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ScsiPortInitialize)
#pragma alloc_text(PAGE, SpAllocateDriverExtension)

#pragma alloc_text(PAGE, SpGetCommonBuffer)
#pragma alloc_text(PAGE, SpInitializeConfiguration)
#pragma alloc_text(PAGE, SpBuildResourceList)
#pragma alloc_text(PAGE, SpParseDevice)
#pragma alloc_text(PAGE, GetPciConfiguration)
#pragma alloc_text(PAGE, SpBuildConfiguration)

#pragma alloc_text(PAGE, SpQueryPnpInterfaceFlags)
#pragma alloc_text(PAGE, SpConfigurationCallout)

#pragma alloc_text(PAGE, SpReportNewAdapter)
#pragma alloc_text(PAGE, SpCreateAdapter)
#pragma alloc_text(PAGE, SpInitializeAdapterExtension)
#pragma alloc_text(PAGE, ScsiPortInitLegacyAdapter)
#pragma alloc_text(PAGE, SpAllocateAdapterResources)
#pragma alloc_text(PAGE, SpOpenDeviceKey)
#pragma alloc_text(PAGE, SpOpenParametersKey)
#pragma alloc_text(PAGE, SpInitializeRequestSenseParams)
#pragma alloc_text(PAGE, SpInitializePerformanceParams)
#pragma alloc_text(PAGE, SpInitializePowerParams)

#pragma alloc_text(PAGE, SpGetRegistryValue)

#pragma alloc_text(PAGELOCK, SpInitializeSrbDataLookasideList)

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, SpCreateScsiDirectory)

#endif


ULONG
ScsiPortInitialize(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext OPTIONAL
    )

/*++

Routine Description:

    This routine initializes the port driver.

Arguments:

    Argument1 - Pointer to driver object created by system
    HwInitializationData - Miniport initialization structure
    HwContext - Value passed to miniport driver's config routine

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    PDRIVER_OBJECT    driverObject = Argument1;
    PSCSIPORT_DRIVER_EXTENSION driverExtension;

    PUNICODE_STRING   registryPath = (PUNICODE_STRING) Argument2;

    ULONG pnpInterfaceFlags;

    NTSTATUS status;

    PAGED_CODE();
    
    //
    // If the global adapter list pointer is negative one then we need to do
    // our global initialization.  This includes creating the scsi directory
    // and initializing the spinlock for protecting the global adapter list.
    //

    if(((LONG_PTR)ScsiGlobalAdapterList) == -1) {

        ScsiGlobalAdapterList = NULL;
        ScsiGlobalAdapterListElements = 0;

        KeInitializeSpinLock(&ScsiGlobalAdapterListSpinLock);

        ScsiPortInitializeDispatchTables();

        SpCreateScsiDirectory();

        status = SpInitializeGuidInterfaceMapping(driverObject);

        if(!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Create the SCSI device map in the registry.
        //

        SpInitDeviceMap();

        //
        // Determine if the system can do 64-bit physical addresses.
        //

        Sp64BitPhysicalAddresses = SpDetermine64BitSupport();
    }

    //
    // Check that the length of this structure is equal to or less than
    // what the port driver expects it to be. This is effectively a
    // version check.
    //

    if (HwInitializationData->HwInitializationDataSize > sizeof(HW_INITIALIZATION_DATA)) {

        DebugPrint((0,"ScsiPortInitialize: Miniport driver wrong version\n"));
        return (ULONG) STATUS_REVISION_MISMATCH;
    }

    //
    // Check that each required entry is not NULL.
    //

    if ((!HwInitializationData->HwInitialize) ||
        (!HwInitializationData->HwFindAdapter) ||
        (!HwInitializationData->HwStartIo) ||
        (!HwInitializationData->HwResetBus)) {

        DebugPrint((0,
            "ScsiPortInitialize: Miniport driver missing required entry\n"));

        return (ULONG) STATUS_REVISION_MISMATCH;
    }

    //
    // Try to allocate a driver extension
    //

    driverExtension = IoGetDriverObjectExtension(driverObject,
                                                 ScsiPortInitialize);

    if (driverExtension == NULL) {

        //
        // None exists for this key so we need to initialize the new one
        //

        status = SpAllocateDriverExtension(driverObject,
                                           registryPath,
                                           &driverExtension);

        if(!NT_SUCCESS(status)) {

            //
            // Something else went wrong - we cannot continue.
            //

            DebugPrint((0, "ScsiPortInitialize: Error %#08lx allocating driver "
                           "extension - cannot continue\n", status));

            return status;
        }

    }

    //
    // Set up the device driver entry points.
    //

    driverObject->DriverStartIo = ScsiPortStartIo;

    driverObject->MajorFunction[IRP_MJ_SCSI] = ScsiPortGlobalDispatch;
    driverObject->MajorFunction[IRP_MJ_CREATE] = ScsiPortGlobalDispatch;
    driverObject->MajorFunction[IRP_MJ_CLOSE] = ScsiPortGlobalDispatch;
    driverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ScsiPortGlobalDispatch;
    driverObject->MajorFunction[IRP_MJ_PNP] = ScsiPortGlobalDispatch;
    driverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = ScsiPortGlobalDispatch;
    driverObject->MajorFunction[IRP_MJ_POWER] = ScsiPortGlobalDispatch;

    //
    // Set up the device driver's pnp-power routine, add routine and unload
    // routine
    //

    driverObject->DriverExtension->AddDevice = ScsiPortAddDevice;
    driverObject->DriverUnload = ScsiPortUnload;

    //
    // Find out if this interface type is safe for this adapter
    //

    pnpInterfaceFlags = SpQueryPnpInterfaceFlags(
                            driverExtension,
                            HwInitializationData->AdapterInterfaceType);

    //
    // Special handling for the "Internal" interface type
    //

    if(HwInitializationData->AdapterInterfaceType == Internal) {

        if (TEST_FLAG(pnpInterfaceFlags, SP_PNP_IS_SAFE) == SP_PNP_NOT_SAFE) {
            return STATUS_NO_SUCH_DEVICE;
        }
    }

    //
    // If there's a chance this interface can handle pnp then store away
    // the interface information.
    //

    if(TEST_FLAG(pnpInterfaceFlags, SP_PNP_IS_SAFE)) {

        PSP_INIT_CHAIN_ENTRY entry = NULL;
        PSP_INIT_CHAIN_ENTRY *nextEntry = &(driverExtension->InitChain);

        //
        // Run to the end of the chain and make sure we don't have any information
        // about this interface type already
        //

        while(*nextEntry != NULL) {

            if((*nextEntry)->InitData.AdapterInterfaceType ==
               HwInitializationData->AdapterInterfaceType) {

                //
                // We already have enough information about this interface type
                //

                return STATUS_SUCCESS;
            }

            nextEntry = &((*nextEntry)->NextEntry);

        }

        //
        // Allocate an init chain entry to store the config information away in
        //

        entry = SpAllocatePool(NonPagedPool,
                               sizeof(SP_INIT_CHAIN_ENTRY),
                               SCSIPORT_TAG_INIT_CHAIN,
                               driverObject);

        if(entry == NULL) {
            
            DebugPrint((1, "ScsiPortInitialize: couldn't allocate chain entry\n"));

            return (ULONG) STATUS_INSUFFICIENT_RESOURCES;

        }

        RtlCopyMemory(&(entry->InitData),
                      HwInitializationData,
                      sizeof(HW_INITIALIZATION_DATA));

        //
        // Stick this entry onto the end of the chain
        //

        entry->NextEntry = NULL;
        *nextEntry = entry;
    }

    //
    // There are two possible reasons we might be doing this in legacy
    // mode.  If it's an internal bus type we always detect.  Otherwise, if
    // the interface isn't safe for pnp we'll use the legacy path.  Or if
    // the registry indicates we should do detection for this miniport AND
    // the pnp interface flags indicate that this bus may not be enumerable
    // we'll hit the legacy path.
    //

#if !defined(NO_LEGACY_DRIVERS)

    if((TEST_FLAG(pnpInterfaceFlags, SP_PNP_IS_SAFE) == FALSE) ||
       (driverExtension->LegacyAdapterDetection &&
        TEST_FLAG(pnpInterfaceFlags, SP_PNP_NON_ENUMERABLE))) {

        //
        // If we're supposed to detect this device then just call directly into
        // SpInitLegacyAdapter to find what we can find
        //

        DebugPrint((1, "ScsiPortInitialize: flags = %#08lx & LegacyAdapterDetection = %d\n",
                    pnpInterfaceFlags, driverExtension->LegacyAdapterDetection));

        DebugPrint((1, "ScsiPortInitialize: Doing Legacy Adapter detection\n"));

        status = ScsiPortInitLegacyAdapter(driverExtension,
                                           HwInitializationData,
                                           HwContext);

    }

#endif // NO_LEGACY_DRIVERS

    //
    // Always return success if there's an interface which can handle pnp,
    // even if the detection fails.
    //

    if(driverExtension->SafeInterfaceCount != 0) {
        status = STATUS_SUCCESS;
    }

    return status;
}


PVOID
ScsiPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    SCSI_PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    BOOLEAN InIoSpace
    )

/*++

Routine Description:

    This routine maps an IO address to system address space.
    Use ScsiPortFreeDeviceBase to unmap address.

Arguments:

    HwDeviceExtension - used to find port device extension.
    BusType - what type of bus - eisa, mca, isa
    SystemIoBusNumber - which IO bus (for machines with multiple buses).
    IoAddress - base device address to be mapped.
    NumberOfBytes - number of bytes for which address is valid.
    InIoSpace - indicates an IO address.

Return Value:

    Mapped address.

--*/

{
    PADAPTER_EXTENSION adapter = GET_FDO_EXTENSION(HwDeviceExtension);
    BOOLEAN isReinit;
    PHYSICAL_ADDRESS cardAddress;
    ULONG addressSpace = InIoSpace;
    PVOID mappedAddress = NULL;
    PMAPPED_ADDRESS newMappedAddress;
    BOOLEAN b = FALSE;

    isReinit = (TEST_FLAG(adapter->Flags, PD_MINIPORT_REINITIALIZING) ==
                PD_MINIPORT_REINITIALIZING);

    //
    // If a set of resources was provided to the miniport for this adapter then
    // get the translation out of the resource lists provided.
    //

    if(!adapter->IsMiniportDetected) {

        CM_PARTIAL_RESOURCE_DESCRIPTOR translation;

        b = SpFindAddressTranslation(adapter,
                                     BusType,
                                     SystemIoBusNumber,
                                     IoAddress,
                                     NumberOfBytes,
                                     InIoSpace,
                                     &translation);

        if(b) {

            cardAddress = translation.u.Generic.Start;
            addressSpace = (translation.Type == CmResourceTypePort) ? 1 : 0;
        } else {

            DebugPrint((1, "ScsiPortGetDeviceBase: SpFindAddressTranslation failed. %s Address = %lx\n",
            InIoSpace ? "I/O" : "Memory", IoAddress.LowPart));

        }
    }

    if((isReinit == FALSE) && (b == FALSE)) {

        //
        // This isn't a reinitialization.  Either the miniport is not pnp
        // or it asked for something that it wasn't assigned.  Unfortunately
        // we need to deal with both cases for the time being.
        //

        b = HalTranslateBusAddress(
                BusType,
                SystemIoBusNumber,
                IoAddress,
                &addressSpace,
                &cardAddress
                );
    }

    if (b == FALSE) {

        //
        // Still no translated address.  Error
        //

        DebugPrint((1, "ScsiPortGetDeviceBase: Translate bus address "
                       "failed. %s Address = %lx\n",
        InIoSpace ? "I/O" : "Memory", IoAddress.LowPart));
        return NULL;
    }

    //
    // Map the device base address into the virtual address space
    // if the address is in memory space.
    //

    if ((isReinit == FALSE) && (addressSpace == FALSE)) {

        //
        // We're not reinitializing and we need to map the address space.
        // Use MM to do the mapping.
        //

        newMappedAddress = SpAllocateAddressMapping(adapter);

        if(newMappedAddress == NULL) {
            DebugPrint((0, "ScsiPortGetDeviceBase: could not find free block "
                           "to track address mapping - returning NULL\n"));
            return NULL;
        }

        mappedAddress = MmMapIoSpace(cardAddress,
                                     NumberOfBytes,
                                     FALSE);

        //
        // Store mapped address, bytes count, etc.
        //

        newMappedAddress->MappedAddress = mappedAddress;
        newMappedAddress->NumberOfBytes = NumberOfBytes;
        newMappedAddress->IoAddress = IoAddress;
        newMappedAddress->BusNumber = SystemIoBusNumber;

    } else if ((isReinit == TRUE) && (addressSpace == FALSE)) {

        ULONG i;

        //
        // This is a reinitialization - we should already have the mapping
        // for the address saved away in our list.
        //

        newMappedAddress = SpFindMappedAddress(adapter,
                                               IoAddress,
                                               NumberOfBytes,
                                               SystemIoBusNumber);

        if(newMappedAddress != NULL) {
            mappedAddress = newMappedAddress->MappedAddress;
            return mappedAddress;
        }

        //
        // We should always find the mapped address here if the miniport
        // is behaving itself.
        //

        KeBugCheckEx(PORT_DRIVER_INTERNAL,
                     0,
                     0,
                     0,
                     0);

    } else {

        mappedAddress = (PVOID)(ULONG_PTR)cardAddress.QuadPart;
    }

    return mappedAddress;

} // end ScsiPortGetDeviceBase()


VOID
ScsiPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )

/*++

Routine Description:

    This routine unmaps an IO address that has been previously mapped
    to system address space using ScsiPortGetDeviceBase().

Arguments:

    HwDeviceExtension - used to find port device extension.
    MappedAddress - address to unmap.
    NumberOfBytes - number of bytes mapped.
    InIoSpace - address is in IO space.

Return Value:

    None

--*/

{
    PADAPTER_EXTENSION adapter;
    ULONG i;
    PMAPPED_ADDRESS nextMappedAddress;
    PMAPPED_ADDRESS lastMappedAddress;

    adapter = GET_FDO_EXTENSION(HwDeviceExtension);
    SpFreeMappedAddress(adapter, MappedAddress);
    return;

} // end ScsiPortFreeDeviceBase()


PVOID
ScsiPortGetUncachedExtension(
    IN PVOID HwDeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN ULONG NumberOfBytes
    )
/*++

Routine Description:

    This function allocates a common buffer to be used as the uncached device
    extension for the miniport driver.  This function will also allocate any
    required SRB extensions.  The DmaAdapter is allocated if it has not been
    allocated previously.

Arguments:

    DeviceExtension - Supplies a pointer to the miniports device extension.

    ConfigInfo - Supplies a pointer to the partially initialized configuraiton
        information.  This is used to get an DMA adapter object.

    NumberOfBytes - Supplies the size of the extension which needs to be
        allocated

Return Value:

    A pointer to the uncached device extension or NULL if the extension could
    not be allocated or was previously allocated.

--*/

{
    PADAPTER_EXTENSION adapter = GET_FDO_EXTENSION(HwDeviceExtension);
    DEVICE_DESCRIPTION deviceDescription;
    ULONG numberOfMapRegisters;
    NTSTATUS status;
    PVOID SrbExtensionBuffer;

    //
    // If the miniport is being reinitialized then just return the current
    // uncached extension (if any).
    //

    if (TEST_FLAG(adapter->Flags, PD_MINIPORT_REINITIALIZING)) {
        DebugPrint((1, "ScsiPortGetUncachedExtension - miniport is "
                       "reinitializing returning %#p\n",
                    adapter->NonCachedExtension));
        if(TEST_FLAG(adapter->Flags, PD_UNCACHED_EXTENSION_RETURNED)) {

            //
            // The miniport asked for it's uncached extension once during
            // reinitialization - simulate the behavior on the original second
            // call and return NULL.
            //

            return NULL;
        } else {

            //
            // The miniport only gets one non-cached extension - keep track
            // of the fact that we returned it and don't give them a pointer
            // to it again.  This flag is cleared once the initialization
            // is complete.
            //

            SET_FLAG(adapter->Flags, PD_UNCACHED_EXTENSION_RETURNED);
            return(adapter->NonCachedExtension);
        }
    }

    //
    // Make sure that a common buffer has not already been allocated.
    //

    SrbExtensionBuffer = SpGetSrbExtensionBuffer(adapter);
    if (SrbExtensionBuffer != NULL) {
        return(NULL);
    }

    //
    // If there no adapter object then try and get one.
    //

    if (adapter->DmaAdapterObject == NULL) {

        RtlZeroMemory(&deviceDescription, sizeof(DEVICE_DESCRIPTION));

        deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
        deviceDescription.DmaChannel = ConfigInfo->DmaChannel;
        deviceDescription.InterfaceType = ConfigInfo->AdapterInterfaceType;
        deviceDescription.DmaWidth = ConfigInfo->DmaWidth;
        deviceDescription.DmaSpeed = ConfigInfo->DmaSpeed;
        deviceDescription.ScatterGather = ConfigInfo->ScatterGather;
        deviceDescription.Master = ConfigInfo->Master;
        deviceDescription.DmaPort = ConfigInfo->DmaPort;
        deviceDescription.Dma32BitAddresses = ConfigInfo->Dma32BitAddresses;

        adapter->Dma32BitAddresses = ConfigInfo->Dma32BitAddresses;

        //
        // If the miniport puts anything in here other than 0x80 then we
        // assume it wants to support 64-bit addresses.
        //

        DebugPrint((1, "ScsiPortGetUncachedExtension: Dma64BitAddresses = "
                       "%#0x\n",
                    ConfigInfo->Dma64BitAddresses));

        adapter->RemapBuffers = (BOOLEAN) (SpRemapBuffersByDefault != 0);

        if((ConfigInfo->Dma64BitAddresses & ~SCSI_DMA64_SYSTEM_SUPPORTED) != 0){
            DebugPrint((1, "ScsiPortGetUncachedExtension: will request "
                           "64-bit PA's\n"));
            deviceDescription.Dma64BitAddresses = TRUE;
            adapter->Dma64BitAddresses = TRUE;
        } else if(Sp64BitPhysicalAddresses == TRUE) {
            DebugPrint((1, "ScsiPortGetUncachedExtension: Will remap buffers for adapter %#p\n", adapter));
            adapter->RemapBuffers = TRUE;
        }

        deviceDescription.BusNumber = ConfigInfo->SystemIoBusNumber;
        deviceDescription.AutoInitialize = FALSE;

        //
        // If we get here then it's unlikely that the adapter is doing
        // slave mode DMA - if it were it wouldn't need a shared memory segment
        // to share with it's controller (because it's unlikely it could use it)
        //

        deviceDescription.DemandMode = FALSE;
        deviceDescription.MaximumLength = ConfigInfo->MaximumTransferLength;

        adapter->DmaAdapterObject = IoGetDmaAdapter(adapter->LowerPdo,
                                                    &deviceDescription,
                                                    &numberOfMapRegisters
                                                    );

        //
        // If an adapter could not be allocated then return NULL.
        //

        if (adapter->DmaAdapterObject == NULL) {
            return(NULL);

        }

        //
        // Determine the number of page breaks allowed.
        //

        if (numberOfMapRegisters > ConfigInfo->NumberOfPhysicalBreaks &&
            ConfigInfo->NumberOfPhysicalBreaks != 0) {

            adapter->Capabilities.MaximumPhysicalPages =
                ConfigInfo->NumberOfPhysicalBreaks;
        } else {

            adapter->Capabilities.MaximumPhysicalPages =
                numberOfMapRegisters;
        }
    }

    //
    // Set auto request sense in device extension.
    //

    adapter->AutoRequestSense = ConfigInfo->AutoRequestSense;

    //
    // Initialize power parameters.
    //

    SpInitializePowerParams(adapter);

    //
    // Initialize configurable performance parameters.
    //

    SpInitializePerformanceParams(adapter);

    //
    // Initialize configurable request sense parameters.
    //

    SpInitializeRequestSenseParams(adapter);

    //
    // Update SrbExtensionSize, if necessary. The miniport's FindAdapter routine
    // has the opportunity to adjust it after being called, depending upon
    // it's Scatter/Gather List requirements.
    //

    if (adapter->SrbExtensionSize != ConfigInfo->SrbExtensionSize) {
        adapter->SrbExtensionSize = ConfigInfo->SrbExtensionSize;
    }

    //
    // If the adapter supports AutoRequestSense or needs SRB extensions
    // then an SRB list needs to be allocated.
    //

    if (adapter->SrbExtensionSize != 0  ||
        ConfigInfo->AutoRequestSense) {

        adapter->AllocateSrbExtension = TRUE;
    }

    //
    // Allocate the common buffer.
    //

    status = SpGetCommonBuffer( adapter, NumberOfBytes);

    if (!NT_SUCCESS(status)) {
        return(NULL);
    }

    return(adapter->NonCachedExtension);
}

NTSTATUS
SpGetCommonBuffer(
    PADAPTER_EXTENSION DeviceExtension,
    ULONG NonCachedExtensionSize
    )
/*++

Routine Description:

    This routine determines the required size of the common buffer.  Allocates
    the common buffer and finally sets up the srb extension list.  This routine
    expects that the adapter object has already been allocated.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension.

    NonCachedExtensionSize - Supplies the size of the noncached device
        extension for the miniport driver.

Return Value:

    Returns the status of the allocate operation.

--*/

{
    PVOID buffer;
    ULONG length;
    ULONG blockSize;
    PVOID *srbExtension;
    ULONG uncachedExtAlignment = 0;

    PAGED_CODE();

    //
    // Round the uncached extension up to a page boundary so the srb 
    // extensions following it begin page aligned.
    //

    if (NonCachedExtensionSize != 0) {
        uncachedExtAlignment = DeviceExtension->UncachedExtAlignment;
        NonCachedExtensionSize = ROUND_UP_COUNT(NonCachedExtensionSize, 
                                                PAGE_SIZE);
        DeviceExtension->NonCachedExtensionSize = NonCachedExtensionSize;
    }

    //
    // If verifier is enabled and configured to allocate common buffer space in
    // separate blocks, call out to the verifier routine to do the allocation.
    //

    if (SpVerifyingCommonBuffer(DeviceExtension)) {
        return SpGetCommonBufferVrfy(DeviceExtension,NonCachedExtensionSize);
    }

    //
    // Calculate the size of the entire common buffer block.
    //

    length = SpGetCommonBufferSize(DeviceExtension, 
                                   NonCachedExtensionSize,
                                   &blockSize);

    //
    // If the adapter has an alignment requirement for its uncached extension,
    // round the size of the entire common buffer up to the required boundary.
    //

    if (uncachedExtAlignment != 0 && NonCachedExtensionSize != 0) {
        length = ROUND_UP_COUNT(length, uncachedExtAlignment);
    }

    //
    // Allocate the common buffer.
    //

    if (DeviceExtension->DmaAdapterObject == NULL) {

        //
        // Since there is no adapter just allocate from non-paged pool.
        //

        buffer = SpAllocatePool(NonPagedPool,
                                length,
                                SCSIPORT_TAG_COMMON_BUFFER,
                                DeviceExtension->DeviceObject->DriverObject);

    } else {

        //
        // If the controller can do 64-bit addresses or if the adapter has 
        // alignment requirements for its uncached extension, then we need to
        // specifically force the uncached extension area below the 4GB mark
        // and force it to be aligned on the appropriate boundary.
        //

        if( ((Sp64BitPhysicalAddresses) && 
             (DeviceExtension->Dma64BitAddresses == TRUE)) ||
            (uncachedExtAlignment != 0)) {

            PHYSICAL_ADDRESS boundary;

            if (uncachedExtAlignment != 0) {
                boundary.QuadPart = length;
            } else {
                boundary.HighPart = 1;
                boundary.LowPart = 0;
            }

            //
            // We'll get page aligned memory out of this which is probably 
            // better than the requirements of the adapter.
            //

            buffer = MmAllocateContiguousMemorySpecifyCache(
                        length,
                        (DeviceExtension->MinimumCommonBufferBase),
                        (DeviceExtension->MaximumCommonBufferBase),
                        boundary,
                        MmCached);

            if(buffer != NULL) {
                DeviceExtension->PhysicalCommonBuffer =
                    MmGetPhysicalAddress(buffer);
            }

            DeviceExtension->UncachedExtensionIsCommonBuffer = FALSE;

        } else {

            buffer = AllocateCommonBuffer(
                        DeviceExtension->DmaAdapterObject,
                        length,
                        &DeviceExtension->PhysicalCommonBuffer,
                        FALSE );

            DeviceExtension->UncachedExtensionIsCommonBuffer = TRUE;

        }
    }

    DebugPrint((1, "SpGetCommonBuffer: buffer:%p PhysicalCommonBuffer:%p\n", 
                buffer, DeviceExtension->PhysicalCommonBuffer));

    if (buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Clear the common buffer.
    //

    RtlZeroMemory(buffer, length);

    //
    // Save the size of the common buffer.
    //

    DeviceExtension->CommonBufferSize = length;

    //
    // Set the Srb Extension to the start of the buffer.  This address
    // is used to deallocate the common buffer, so it must be
    // set whether the device is using an Srb Extension or not.
    //

    DeviceExtension->SrbExtensionBuffer = buffer;

    //
    // Initialize the noncached extension.
    //

    if (NonCachedExtensionSize != 0) {
        DeviceExtension->NonCachedExtension = buffer;
    } else {
        DeviceExtension->NonCachedExtension = NULL;
    }

    //
    // Initialize the SRB extension list.
    //

    if (DeviceExtension->AllocateSrbExtension) {

        ULONG i = 0;

        //
        // Subtract the length of the non-cached extension from the common
        // buffer block.
        //

        length -= DeviceExtension->NonCachedExtensionSize;

        //
        // Initialize the SRB extension list.
        //

        srbExtension = 
           (PVOID*)((PUCHAR)buffer + DeviceExtension->NonCachedExtensionSize);
        DeviceExtension->SrbExtensionListHeader = srbExtension;

        while (length >= blockSize * 2) {

            *srbExtension = (PVOID *)((PCHAR) srbExtension + blockSize);
            srbExtension = *srbExtension;

            length -= blockSize;
            i++;
        }

        DebugPrint((1, "SpGetCommonBuffer: %d entries put onto "
                       "SrbExtension list\n", i));

        DeviceExtension->NumberOfRequests = i;
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Temporary entry point needed to initialize the scsi port driver.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

Return Value:

   STATUS_SUCCESS

--*/

{
    //
    // NOTE: This routine should not be needed ! DriverEntry is defined
    // in the miniport driver.
    //

    UNREFERENCED_PARAMETER(DriverObject);

    return STATUS_SUCCESS;

} // end DriverEntry()


NTSTATUS
SpInitializeConfiguration(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PUNICODE_STRING RegistryPath,
    IN PHW_INITIALIZATION_DATA HwInitData,
    IN PCONFIGURATION_CONTEXT Context
    )
/*++

Routine Description:

    This routine initializes the port configuration information structure.
    Any necessary information is extracted from the registery.

Arguments:

    DeviceExtension - Supplies the device extension.

    HwInitData - Supplies the initial miniport data.

    Context - Supplies the context data used access calls.

Return Value:

    NTSTATUS - Success if requested bus type exists and additional
               configuration information is available.

--*/

{
    ULONG j;
    NTSTATUS status;
    UNICODE_STRING unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    PCONFIGURATION_INFORMATION configurationInformation;

    HANDLE deviceKey;
    HANDLE generalKey;

    BOOLEAN found;
    ANSI_STRING  ansiString;
    CCHAR deviceBuffer[16];
    CCHAR nodeBuffer[SP_REG_BUFFER_SIZE];

    //
    // If this is the initial call then zero the information and set
    // the structure to the uninitialized values.
    //

    RtlZeroMemory(&Context->PortConfig, sizeof(PORT_CONFIGURATION_INFORMATION));

    ASSERT(Context->AccessRanges != NULL);

    RtlZeroMemory(
        Context->AccessRanges,
        HwInitData->NumberOfAccessRanges * sizeof(ACCESS_RANGE)
        );

    Context->PortConfig.Length = sizeof(PORT_CONFIGURATION_INFORMATION);
    Context->PortConfig.AdapterInterfaceType = HwInitData->AdapterInterfaceType;
    Context->PortConfig.InterruptMode = Latched;
    Context->PortConfig.MaximumTransferLength = SP_UNINITIALIZED_VALUE;
    Context->PortConfig.DmaChannel = SP_UNINITIALIZED_VALUE;
    Context->PortConfig.DmaPort = SP_UNINITIALIZED_VALUE;
    Context->PortConfig.NumberOfAccessRanges = HwInitData->NumberOfAccessRanges;
    Context->PortConfig.MaximumNumberOfTargets = 8;
    Context->PortConfig.MaximumNumberOfLogicalUnits = SCSI_MAXIMUM_LOGICAL_UNITS;
    Context->PortConfig.WmiDataProvider = FALSE;

    //
    // If the system indicates it can do 64-bit physical addressing then tell
    // the miniport it's an option.
    //

    if(Sp64BitPhysicalAddresses == TRUE) {
        Context->PortConfig.Dma64BitAddresses = SCSI_DMA64_SYSTEM_SUPPORTED;
    } else {
        Context->PortConfig.Dma64BitAddresses = 0;
    }

    //
    // Save away the some of the attributes.
    //

    Context->PortConfig.NeedPhysicalAddresses = HwInitData->NeedPhysicalAddresses;
    Context->PortConfig.MapBuffers = HwInitData->MapBuffers;
    Context->PortConfig.AutoRequestSense = HwInitData->AutoRequestSense;
    Context->PortConfig.ReceiveEvent = HwInitData->ReceiveEvent;
    Context->PortConfig.TaggedQueuing = HwInitData->TaggedQueuing;
    Context->PortConfig.MultipleRequestPerLu = HwInitData->MultipleRequestPerLu;

    //
    // Indicate the current AT disk usage.
    //

    configurationInformation = IoGetConfigurationInformation();

    Context->PortConfig.AtdiskPrimaryClaimed = configurationInformation->AtDiskPrimaryAddressClaimed;
    Context->PortConfig.AtdiskSecondaryClaimed = configurationInformation->AtDiskSecondaryAddressClaimed;

    for (j = 0; j < 8; j++) {
        Context->PortConfig.InitiatorBusId[j] = (UCHAR)SP_UNINITIALIZED_VALUE;
    }

    Context->PortConfig.NumberOfPhysicalBreaks = SP_DEFAULT_PHYSICAL_BREAK_VALUE;

    //
    // Clear some of the context information.
    //

    Context->DisableTaggedQueueing = FALSE;
    Context->DisableMultipleLu = FALSE;

    //
    // Record the system bus number.
    //

    Context->PortConfig.SystemIoBusNumber = Context->BusNumber;

    //
    // Initialize the adapter number on the context.
    //

    Context->AdapterNumber = DeviceExtension->AdapterNumber - 1;
    ASSERT((LONG)Context->AdapterNumber > -1);

    //
    // Check for device parameters.
    //

    if (Context->Parameter) {
        ExFreePool(Context->Parameter);
        Context->Parameter = NULL;
    }

    generalKey = SpOpenDeviceKey(RegistryPath, -1);

    //
    // First parse the device information.
    //

    if (generalKey != NULL) {
        SpParseDevice(DeviceExtension, generalKey, Context, nodeBuffer);
        ZwClose(generalKey);
    }

    //
    // Next parse the specific device information so that it can override the
    // general device information. This node is not used if the last adapter
    // was not found.
    //

    deviceKey = SpOpenDeviceKey(RegistryPath, Context->AdapterNumber);

    if (deviceKey != NULL) {
        SpParseDevice(DeviceExtension, deviceKey, Context, nodeBuffer);
        ZwClose(deviceKey);
    }

    //
    // Determine if the requested bus type is on this system.
    //

    if(HwInitData->AdapterInterfaceType != PNPBus) {
    
        found = FALSE;
    
        if(HwInitData->AdapterInterfaceType != MicroChannel) {
    
            status = IoQueryDeviceDescription(&HwInitData->AdapterInterfaceType,
                                              &Context->BusNumber,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL,
                                              SpConfigurationCallout,
                                              &found);
        }
    
        //
        // If the request failed, then assume this type of bus is not here.
        //
    
        if (!found) {
    
            INTERFACE_TYPE interfaceType = Eisa;
    
            if (HwInitData->AdapterInterfaceType == Isa) {
    
                //
                // Check for an Eisa bus.
                //
    
                status = IoQueryDeviceDescription(&interfaceType,
                                                  &Context->BusNumber,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  SpConfigurationCallout,
                                                  &found);
    
                //
                // If the request failed, then assume this type of bus is not here.
                //
    
                if (found) {
                    return(STATUS_SUCCESS);
                } else {
                    return(STATUS_DEVICE_DOES_NOT_EXIST);
                }
    
            } else {
                return(STATUS_DEVICE_DOES_NOT_EXIST);
            }
    
        } else {
            return(STATUS_SUCCESS);
        }
    } else {
        return STATUS_SUCCESS;
    }
}

PCM_RESOURCE_LIST
SpBuildResourceList(
    PADAPTER_EXTENSION DeviceExtension,
    PPORT_CONFIGURATION_INFORMATION ConfigInfo
    )
/*++

Routine Description:

    Creates a resource list which is used to query or report resource usage
    in the system

Arguments:

    DeviceExtension - Pointer to the port's deviceExtension.

    ConfigInfo - Pointer to the information structure filled out by the
        miniport findAdapter routine.

Return Value:

    Returns a pointer to a filled up resource list, or 0 if the call failed.

Note:

    Memory is allocated by the routine for the resourcelist. It must be
    freed up by the caller by calling ExFreePool();

--*/
{
    PCM_RESOURCE_LIST resourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resourceDescriptor;
    PCONFIGURATION_INFORMATION configurationInformation;
    PACCESS_RANGE accessRange;
    ULONG listLength = 0;
    ULONG hasInterrupt;
    ULONG i;
    BOOLEAN hasDma;

    PAGED_CODE();

    //
    // Indicate the current AT disk usage.
    //

    configurationInformation = IoGetConfigurationInformation();

    if (ConfigInfo->AtdiskPrimaryClaimed) {
        configurationInformation->AtDiskPrimaryAddressClaimed = TRUE;
    }

    if (ConfigInfo->AtdiskSecondaryClaimed) {
        configurationInformation->AtDiskSecondaryAddressClaimed = TRUE;
    }

    //
    // Determine if adapter uses DMA. Only report the DMA channel if a
    // channel number is used.
    //

    if (ConfigInfo->DmaChannel != SP_UNINITIALIZED_VALUE ||
        ConfigInfo->DmaPort != SP_UNINITIALIZED_VALUE) {

       hasDma = TRUE;
       listLength++;

    } else {

        hasDma = FALSE;
    }

    DeviceExtension->HasInterrupt = FALSE;

    if (DeviceExtension->HwInterrupt == NULL ||
        (ConfigInfo->BusInterruptLevel == 0 &&
        ConfigInfo->BusInterruptVector == 0)) {

        hasInterrupt = 0;

    } else {

        hasInterrupt = 1;
        listLength++;
    }

    //
    // Detemine whether the second interrupt is used.
    //

    if (DeviceExtension->HwInterrupt != NULL &&
        (ConfigInfo->BusInterruptLevel2 != 0 ||
        ConfigInfo->BusInterruptVector2 != 0)) {

        hasInterrupt++;
        listLength++;
    }

    if(hasInterrupt) {
        DeviceExtension->HasInterrupt = TRUE;
    }

    //
    // Determine the number of access ranges used.
    //

    accessRange = &((*(ConfigInfo->AccessRanges))[0]);
    for (i = 0; i < ConfigInfo->NumberOfAccessRanges; i++) {

        if (accessRange->RangeLength != 0) {
            listLength++;
        }

        accessRange++;
    }

    resourceList = (PCM_RESOURCE_LIST)
        SpAllocatePool(PagedPool,
                       (sizeof(CM_RESOURCE_LIST) + 
                        ((listLength - 1) * 
                         sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR))),
                       SCSIPORT_TAG_RESOURCE_LIST,
                       DeviceExtension->DeviceObject->DriverObject);

    //
    // Return NULL if the structure could not be allocated.
    // Otherwise, fill it out.
    //

    if (!resourceList) {

        return NULL;

    } else {

        //
        // Clear the resource list.
        //

        RtlZeroMemory(
            resourceList,
            sizeof(CM_RESOURCE_LIST) + (listLength - 1)
            * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
            );

        //
        // Initialize the various fields.
        //

        resourceList->Count = 1;
        resourceList->List[0].InterfaceType = ConfigInfo->AdapterInterfaceType;
        resourceList->List[0].BusNumber = ConfigInfo->SystemIoBusNumber;
        resourceList->List[0].PartialResourceList.Count = listLength;
        resourceDescriptor =
            resourceList->List[0].PartialResourceList.PartialDescriptors;

        //
        // For each entry in the access range, fill in an entry in the
        // resource list
        //

        for (i = 0; i < ConfigInfo->NumberOfAccessRanges; i++) {

            accessRange = &((*(ConfigInfo->AccessRanges))[i]);

            if  (accessRange->RangeLength == 0) {

                //
                // Skip the empty ranges.
                //

                continue;
            }

            if (accessRange->RangeInMemory) {
                resourceDescriptor->Type = CmResourceTypeMemory;
                resourceDescriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
            } else {
                resourceDescriptor->Type = CmResourceTypePort;
                resourceDescriptor->Flags = CM_RESOURCE_PORT_IO;

                if(ConfigInfo->AdapterInterfaceType == Eisa) {
                    resourceDescriptor->Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
                }
            }

            resourceDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;

            resourceDescriptor->u.Memory.Start = accessRange->RangeStart;
            resourceDescriptor->u.Memory.Length = accessRange->RangeLength;


            resourceDescriptor++;
        }

        //
        // Fill in the entry for the interrupt if it was present.
        //

        if (hasInterrupt) {

            resourceDescriptor->Type = CmResourceTypeInterrupt;

            if (ConfigInfo->AdapterInterfaceType == MicroChannel ||
                ConfigInfo->InterruptMode == LevelSensitive) {
               resourceDescriptor->ShareDisposition = CmResourceShareShared;
               resourceDescriptor->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
            } else {
               resourceDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
               resourceDescriptor->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
            }

            resourceDescriptor->u.Interrupt.Level =
                        ConfigInfo->BusInterruptLevel;
            resourceDescriptor->u.Interrupt.Vector =
                        ConfigInfo->BusInterruptVector;
            resourceDescriptor->u.Interrupt.Affinity = 0;

            resourceDescriptor++;
            --hasInterrupt;
        }

        if (hasInterrupt) {

            resourceDescriptor->Type = CmResourceTypeInterrupt;

            if (ConfigInfo->AdapterInterfaceType == MicroChannel ||
                ConfigInfo->InterruptMode2 == LevelSensitive) {
               resourceDescriptor->ShareDisposition = CmResourceShareShared;
               resourceDescriptor->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
            } else {
               resourceDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
               resourceDescriptor->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
            }

            resourceDescriptor->u.Interrupt.Level =
                        ConfigInfo->BusInterruptLevel2;
            resourceDescriptor->u.Interrupt.Vector =
                        ConfigInfo->BusInterruptVector2;
            resourceDescriptor->u.Interrupt.Affinity = 0;

            resourceDescriptor++;
        }

        if (hasDma) {

            //
            // Fill out DMA information;
            //

            resourceDescriptor->Type = CmResourceTypeDma;
            resourceDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
            resourceDescriptor->u.Dma.Channel = ConfigInfo->DmaChannel;
            resourceDescriptor->u.Dma.Port = ConfigInfo->DmaPort;
            resourceDescriptor->Flags = 0;

            //
            // Set the initialized values to zero.
            //

            if (ConfigInfo->DmaChannel == SP_UNINITIALIZED_VALUE) {
                resourceDescriptor->u.Dma.Channel = 0;
            }

            if (ConfigInfo->DmaPort == SP_UNINITIALIZED_VALUE) {
                resourceDescriptor->u.Dma.Port = 0;
            }
        }

        return resourceList;
    }

} // end SpBuildResourceList()


VOID
SpParseDevice(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN HANDLE Key,
    IN PCONFIGURATION_CONTEXT Context,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine parses a device key node and updates the configuration
    information.

Arguments:

    DeviceExtension - Supplies the device extension.

    Key - Supplies an open key to the device node.

    ConfigInfo - Supplies the configuration information to be
        initialized.

    Context - Supplies the configuration context.

    Buffer - Supplies a scratch buffer for temporary data storage.

Return Value:

    None

--*/

{
    PKEY_VALUE_FULL_INFORMATION     keyValueInformation;
    NTSTATUS                        status = STATUS_SUCCESS;
    PCM_FULL_RESOURCE_DESCRIPTOR    resource;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;
    PCM_SCSI_DEVICE_DATA            scsiData;
    UNICODE_STRING                  unicodeString;
    ANSI_STRING                     ansiString;
    ULONG                           length;
    ULONG                           index = 0;
    ULONG                           rangeCount = 0;
    ULONG                           count;

    PAGED_CODE();

    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

    //
    // Look at each of the values in the device node.
    //

    while(TRUE){

        status = ZwEnumerateValueKey(
            Key,
            index,
            KeyValueFullInformation,
            Buffer,
            SP_REG_BUFFER_SIZE,
            &length
            );


        if (!NT_SUCCESS(status)) {
#if DBG
            if (status != STATUS_NO_MORE_ENTRIES) {
                DebugPrint((1, "SpParseDevice: ZwEnumerateValueKey failed. Status: %lx", status));
            }
#endif
            return;
        }

        //
        // Update the index for the next time around the loop.
        //

        index++;

        //
        // Check that the length is reasonable.
        //

        if (keyValueInformation->Type == REG_DWORD &&
            keyValueInformation->DataLength != sizeof(ULONG)) {
            continue;
        }

        //
        // Check for a maximum lu number.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"MaximumLogicalUnit",
            keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->Type != REG_DWORD) {

                DebugPrint((1, "SpParseDevice:  Bad data type for MaximumLogicalUnit.\n"));
                continue;
            }

            DeviceExtension->MaxLuCount = *((PUCHAR)
                (Buffer + keyValueInformation->DataOffset));
            DebugPrint((1, "SpParseDevice:  MaximumLogicalUnit = %d found.\n",
                DeviceExtension->MaxLuCount));

            //
            // If the value is out of bounds, then reset it.
            //

            if (DeviceExtension->MaxLuCount > SCSI_MAXIMUM_LOGICAL_UNITS) {
                DeviceExtension->MaxLuCount = SCSI_MAXIMUM_LOGICAL_UNITS;
            }
        }

        if (_wcsnicmp(keyValueInformation->Name, L"InitiatorTargetId",
            keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->Type != REG_DWORD) {

                DebugPrint((1, "SpParseDevice:  Bad data type for InitiatorTargetId.\n"));
                continue;
            }

            Context->PortConfig.InitiatorBusId[0] = *((PUCHAR)
                (Buffer + keyValueInformation->DataOffset));
            DebugPrint((1, "SpParseDevice:  InitiatorTargetId = %d found.\n",
                Context->PortConfig.InitiatorBusId[0]));

            //
            // If the value is out of bounds, then reset it.
            //

            if (Context->PortConfig.InitiatorBusId[0] > Context->PortConfig.MaximumNumberOfTargets - 1) {
                Context->PortConfig.InitiatorBusId[0] = (UCHAR)SP_UNINITIALIZED_VALUE;
            }
        }

        if (_wcsnicmp(keyValueInformation->Name, L"ScsiDebug",
            keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->Type != REG_DWORD) {

                DebugPrint((1, "SpParseDevice:  Bad data type for ScsiDebug.\n"));
                continue;
            }
#if DBG
            ScsiDebug = *((PULONG) (Buffer + keyValueInformation->DataOffset));
#endif
        }

        if (_wcsnicmp(keyValueInformation->Name, L"BreakPointOnEntry",
            keyValueInformation->NameLength/2) == 0) {

            DebugPrint((0, "SpParseDevice: Break point requested on entry.\n"));
            DbgBreakPoint();
        }

        //
        // Check for disabled synchonous tranfers.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"DisableSynchronousTransfers",
            keyValueInformation->NameLength/2) == 0) {

            DeviceExtension->CommonExtension.SrbFlags |= SRB_FLAGS_DISABLE_SYNCH_TRANSFER;
            DebugPrint((1, "SpParseDevice: Disabling synchonous transfers\n"));
        }

        //
        // Check for disabled disconnects.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"DisableDisconnects",
            keyValueInformation->NameLength/2) == 0) {

            DeviceExtension->CommonExtension.SrbFlags |= SRB_FLAGS_DISABLE_DISCONNECT;
            DebugPrint((1, "SpParseDevice: Disabling disconnects\n"));
        }

        //
        // Check for disabled tagged queuing.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"DisableTaggedQueuing",
            keyValueInformation->NameLength/2) == 0) {

            Context->DisableTaggedQueueing = TRUE;
            DebugPrint((1, "SpParseDevice: Disabling tagged queueing\n"));
        }

        //
        // Check for disabled multiple requests per logical unit.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"DisableMultipleRequests",
            keyValueInformation->NameLength/2) == 0) {

            Context->DisableMultipleLu = TRUE;
            DebugPrint((1, "SpParseDevice: Disabling multiple requests\n"));
        }

        //
        // Check for the minimum & maximum physical addresses that this 
        // controller can use for it's uncached extension.  If none is provided 
        // assume it must be in the first 4GB of memory.
        //

        if(_wcsnicmp(keyValueInformation->Name, L"MinimumUCXAddress",
                     keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->Type == REG_BINARY) {
                DeviceExtension->MinimumCommonBufferBase.QuadPart = 
                    *((PULONGLONG) (Buffer + keyValueInformation->DataOffset));
            }
        }

        if(_wcsnicmp(keyValueInformation->Name, L"MaximumUCXAddress",
                     keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->Type == REG_BINARY) {
                DeviceExtension->MaximumCommonBufferBase.QuadPart = 
                    *((PULONGLONG) (Buffer + keyValueInformation->DataOffset));
            }
        }

        if(DeviceExtension->MaximumCommonBufferBase.QuadPart == 0) {
            DeviceExtension->MaximumCommonBufferBase.LowPart = 0xffffffff;
            DeviceExtension->MaximumCommonBufferBase.HighPart = 0x0;
        }

        //
        // Make sure that the minimum and maximum parameters are valid.
        // If there's not at least one valid page between them then reset 
        // the minimum to zero.
        //

        if(DeviceExtension->MinimumCommonBufferBase.QuadPart >= 
           (DeviceExtension->MaximumCommonBufferBase.QuadPart - PAGE_SIZE)) {
            DebugPrint((0, "SpParseDevice: MinimumUCXAddress %I64x is invalid\n",
                        DeviceExtension->MinimumCommonBufferBase.QuadPart));
            DeviceExtension->MinimumCommonBufferBase.QuadPart = 0;
        }

        //
        // Check for driver parameters tranfers.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"DriverParameters",
            keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->DataLength == 0) {
                continue;
            }

            //
            // Free any previous driver parameters.
            //

            if (Context->Parameter != NULL) {
                ExFreePool(Context->Parameter);
            }

            Context->Parameter =
                SpAllocatePool(NonPagedPool,
                               keyValueInformation->DataLength,
                               SCSIPORT_TAG_MINIPORT_PARAM,
                               DeviceExtension->DeviceObject->DriverObject);

            if (Context->Parameter != NULL) {

                if (keyValueInformation->Type != REG_SZ) {

                    //
                    // This is some random information just copy it.
                    //

                    RtlCopyMemory(
                        Context->Parameter,
                        (PCCHAR) keyValueInformation + keyValueInformation->DataOffset,
                        keyValueInformation->DataLength
                        );

                } else {

                    //
                    // This is a unicode string. Convert it to a ANSI string.
                    // Initialize the strings.
                    //

                    unicodeString.Buffer = (PWSTR) ((PCCHAR) keyValueInformation +
                        keyValueInformation->DataOffset);
                    unicodeString.Length = (USHORT) keyValueInformation->DataLength;
                    unicodeString.MaximumLength = (USHORT) keyValueInformation->DataLength;

                    ansiString.Buffer = (PCHAR) Context->Parameter;
                    ansiString.Length = 0;
                    ansiString.MaximumLength = (USHORT) keyValueInformation->DataLength;

                    status = RtlUnicodeStringToAnsiString(
                        &ansiString,
                        &unicodeString,
                        FALSE
                        );

                    if (!NT_SUCCESS(status)) {

                        //
                        // Free the context.
                        //

                        ExFreePool(Context->Parameter);
                        Context->Parameter = NULL;
                    }

                }
            }

            DebugPrint((1, "SpParseDevice: Found driver parameter.\n"));
        }

        //
        // See if an entry for Maximum Scatter-Gather List has been
        // set.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"MaximumSGList",
            keyValueInformation->NameLength/2) == 0) {

            ULONG maxBreaks, minBreaks;

            if (keyValueInformation->Type != REG_DWORD) {

                DebugPrint((1, "SpParseDevice:  Bad data type for MaximumSGList.\n"));
                continue;
            }

            Context->PortConfig.NumberOfPhysicalBreaks = *((PUCHAR)(Buffer + keyValueInformation->DataOffset));
            DebugPrint((1, "SpParseDevice:  MaximumSGList = %d found.\n",
                        Context->PortConfig.NumberOfPhysicalBreaks));

            //
            // If the value is out of bounds, then reset it.
            //

            if ((Context->PortConfig.MapBuffers) && (!Context->PortConfig.Master)) {
                maxBreaks = SP_UNINITIALIZED_VALUE;
                minBreaks = SCSI_MINIMUM_PHYSICAL_BREAKS;
            } else {
                maxBreaks = SCSI_MAXIMUM_PHYSICAL_BREAKS;
                minBreaks = SCSI_MINIMUM_PHYSICAL_BREAKS;
            }

            if (Context->PortConfig.NumberOfPhysicalBreaks > maxBreaks) {
                Context->PortConfig.NumberOfPhysicalBreaks = maxBreaks;
            } else if (Context->PortConfig.NumberOfPhysicalBreaks < minBreaks) {
                Context->PortConfig.NumberOfPhysicalBreaks = minBreaks;
            }

        }

        //
        // See if an entry for Number of request has been set.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"NumberOfRequests",
            keyValueInformation->NameLength/2) == 0) {

            ULONG value;

            if (keyValueInformation->Type != REG_DWORD) {

                DebugPrint((1, "SpParseDevice:  Bad data type for NumberOfRequests.\n"));
                continue;
            }

            value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

            //
            // If the value is out of bounds, then reset it.
            //

            if (value < MINIMUM_SRB_EXTENSIONS) {
                DeviceExtension->NumberOfRequests = MINIMUM_SRB_EXTENSIONS;
            } else if (value > MAXIMUM_SRB_EXTENSIONS) {
                DeviceExtension->NumberOfRequests = MAXIMUM_SRB_EXTENSIONS;
            } else {
                DeviceExtension->NumberOfRequests = value;
            }

            DebugPrint((1, "SpParseDevice:  Number Of Requests = %d found.\n",
                        DeviceExtension->NumberOfRequests));
        }

        //
        // Check for resource list.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"ResourceList",
                keyValueInformation->NameLength/2) == 0 ||
            _wcsnicmp(keyValueInformation->Name, L"Configuration Data",
                keyValueInformation->NameLength/2) == 0 ) {

            if (keyValueInformation->Type != REG_FULL_RESOURCE_DESCRIPTOR ||
                keyValueInformation->DataLength < sizeof(REG_FULL_RESOURCE_DESCRIPTOR)) {

                DebugPrint((1, "SpParseDevice:  Bad data type for ResourceList.\n"));
                continue;
            } else {
                DebugPrint((1, "SpParseDevice:  ResourceList found!\n"));
            }

            resource = (PCM_FULL_RESOURCE_DESCRIPTOR)
                (Buffer + keyValueInformation->DataOffset);

            //
            // Set the bus number equal to the bus number for the
            // resouce.  Note the context value is also set to the
            // new bus number.
            //

            Context->BusNumber = resource->BusNumber;
            Context->PortConfig.SystemIoBusNumber = resource->BusNumber;

            //
            // Walk the resource list and update the configuration.
            //

            for (count = 0; count < resource->PartialResourceList.Count; count++) {
                descriptor = &resource->PartialResourceList.PartialDescriptors[count];

                //
                // Verify size is ok.
                //

                if ((ULONG)((PCHAR) (descriptor + 1) - (PCHAR) resource) >
                    keyValueInformation->DataLength) {

                    DebugPrint((1, "SpParseDevice: Resource data too small.\n"));
                    break;
                }

                //
                // Switch on descriptor type;
                //

                switch (descriptor->Type) {
                case CmResourceTypePort:

                    if (rangeCount >= Context->PortConfig.NumberOfAccessRanges) {
                        DebugPrint((1, "SpParseDevice: Too many access ranges.\n"));
                        continue;
                    }

                    Context->AccessRanges[rangeCount].RangeStart =
                        descriptor->u.Port.Start;
                    Context->AccessRanges[rangeCount].RangeLength =
                        descriptor->u.Port.Length;
                    Context->AccessRanges[rangeCount].RangeInMemory = FALSE;
                    rangeCount++;

                    break;

                case CmResourceTypeMemory:

                    if (rangeCount >= Context->PortConfig.NumberOfAccessRanges) {
                        DebugPrint((1, "SpParseDevice: Too many access ranges.\n"));
                        continue;
                    }

                    Context->AccessRanges[rangeCount].RangeStart =
                        descriptor->u.Memory.Start;

                    Context->AccessRanges[rangeCount].RangeLength =
                        descriptor->u.Memory.Length;
                    Context->AccessRanges[rangeCount].RangeInMemory = TRUE;
                    rangeCount++;

                    break;

                case CmResourceTypeInterrupt:

                    Context->PortConfig.BusInterruptVector =
                        descriptor->u.Interrupt.Vector;
                    Context->PortConfig.BusInterruptLevel =
                        descriptor->u.Interrupt.Level;
                    break;

                case CmResourceTypeDma:

                    Context->PortConfig.DmaChannel = descriptor->u.Dma.Channel;
                    Context->PortConfig.DmaPort = descriptor->u.Dma.Port;
                    break;

                case CmResourceTypeDeviceSpecific:

                    if (descriptor->u.DeviceSpecificData.DataSize <
                        sizeof(CM_SCSI_DEVICE_DATA) ||
                        (PCHAR) (descriptor + 1) - (PCHAR) resource +
                        descriptor->u.DeviceSpecificData.DataSize >
                        keyValueInformation->DataLength) {

                        DebugPrint((1, "SpParseDevice: Device specific resource data too small.\n"));
                        break;

                    }

                    //
                    // The actual data follows the descriptor.
                    //

                    scsiData = (PCM_SCSI_DEVICE_DATA) (descriptor+1);
                    Context->PortConfig.InitiatorBusId[0] = scsiData->HostIdentifier;
                    break;

                }
            }
        }

        //
        // See if an entry for uncached extension alignment has been set.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"UncachedExtAlignment", 
                      keyValueInformation->NameLength/2) == 0) {

            ULONG value;

            if (keyValueInformation->Type != REG_DWORD) {
                DebugPrint((1, "SpParseDevice:  Bad data type for "
                            "UncachedExtAlignment.\n"));
                continue;
            }

            value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

            //
            // Specified alignment must be 3 to 16, which equates to 8-byte and
            // 64k-byte alignment, respectively.
            //

            if (value > 16) {
                value = 16;
            } else if (value < 3) {
                value = 3;
            }

	    DeviceExtension->UncachedExtAlignment = 1 << value;

            DebugPrint((1, "SpParseDevice:  Uncached ext alignment = %d.\n",
                        DeviceExtension->UncachedExtAlignment));
        } // UncachedExtAlignment
    }
}

NTSTATUS
SpConfigurationCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )

/*++

Routine Description:

    This routine indicate that the requested perpherial data was found.

Arguments:

    Context - Supplies a pointer to boolean which is set to TURE when this
        routine is call.

    The remaining arguments are unsed.

Return Value:

    Returns success.

--*/

{
    PAGED_CODE();
    *(PBOOLEAN) Context = TRUE;
    return(STATUS_SUCCESS);
}


NTSTATUS
SpGetRegistryValue(
    IN PDRIVER_OBJECT DriverObject,
    IN HANDLE Handle,
    IN PWSTR KeyString,
    OUT PKEY_VALUE_FULL_INFORMATION *KeyInformation
    )

/*++

Routine Description:

    This routine retrieve's any data associated with a registry key.
    The key is queried with a zero-length buffer to get it's actual size
    then a buffer is allocated and the actual query takes place.
    It is the responsibility of the caller to free the buffer.

Arguments:

    Handle - Supplies the key handle whose value is to be queried

    KeyString - Supplies the null-terminated Unicode name of the value.

    KeyInformation - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    PAGED_CODE();

    RtlInitUnicodeString(&unicodeString, KeyString);

    //
    // Query with a zero-length buffer, to get the size needed.
    //

    status = ZwQueryValueKey( Handle,
                              &unicodeString,
                              KeyValueFullInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength);

    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        *KeyInformation = NULL;
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = SpAllocatePool(NonPagedPool,
                                keyValueLength,
                                SCSIPORT_TAG_REGISTRY,
                                DriverObject);
    if(!infoBuffer) {
        *KeyInformation = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey( Handle,
                              &unicodeString,
                              KeyValueFullInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength);

    if(!NT_SUCCESS(status)) {
        ExFreePool(infoBuffer);
        *KeyInformation = NULL;
        return status;
    }

    *KeyInformation = infoBuffer;
    return STATUS_SUCCESS;
}


VOID
SpBuildConfiguration(
    IN PADAPTER_EXTENSION    AdapterExtension,
    IN PHW_INITIALIZATION_DATA         HwInitializationData,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInformation
    )

/*++

Routine Description:

    Given a full resource description, fill in the port configuration
    information.

Arguments:

    HwInitializationData - to know maximum resources for device.
    ControllerData - the CM_FULL_RESOURCE list for this configuration
    ConfigInformation - the config info structure to be filled in

Return Value:

    None

--*/

{
    ULONG             rangeNumber;
    ULONG             index;
    PACCESS_RANGE     accessRange;

    PCM_FULL_RESOURCE_DESCRIPTOR resourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialData;

    PAGED_CODE();

    rangeNumber = 0;

    ASSERT(!AdapterExtension->IsMiniportDetected);
    ASSERT(AdapterExtension->AllocatedResources);

    resourceList = AdapterExtension->AllocatedResources->List;

    for (index = 0; index < resourceList->PartialResourceList.Count; index++) {
        partialData = &resourceList->PartialResourceList.PartialDescriptors[index];

        switch (partialData->Type) {
        case CmResourceTypePort:

           //
           // Verify range count does not exceed what the
           // miniport indicated.
           //

           if (HwInitializationData->NumberOfAccessRanges > rangeNumber) {

                //
                // Get next access range.
                //

                accessRange =
                          &((*(ConfigInformation->AccessRanges))[rangeNumber]);

                accessRange->RangeStart = partialData->u.Port.Start;
                accessRange->RangeLength = partialData->u.Port.Length;

                accessRange->RangeInMemory = FALSE;
                rangeNumber++;
            }
            break;

        case CmResourceTypeInterrupt:
            ConfigInformation->BusInterruptLevel = partialData->u.Interrupt.Level;
            ConfigInformation->BusInterruptVector = partialData->u.Interrupt.Vector;

            //
            // Check interrupt mode.
            //

            if (partialData->Flags == CM_RESOURCE_INTERRUPT_LATCHED) {
                ConfigInformation->InterruptMode = Latched;
            } else if (partialData->Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {
                ConfigInformation->InterruptMode = LevelSensitive;
            }

            AdapterExtension->HasInterrupt = TRUE;
            break;

        case CmResourceTypeMemory:

            //
            // Verify range count does not exceed what the
            // miniport indicated.
            //

            if (HwInitializationData->NumberOfAccessRanges > rangeNumber) {

                 //
                 // Get next access range.
                 //

                 accessRange =
                          &((*(ConfigInformation->AccessRanges))[rangeNumber]);

                 accessRange->RangeStart = partialData->u.Memory.Start;
                 accessRange->RangeLength = partialData->u.Memory.Length;

                 accessRange->RangeInMemory = TRUE;
                 rangeNumber++;
            }
            break;

        case CmResourceTypeDma:
            ConfigInformation->DmaChannel = partialData->u.Dma.Channel;
            ConfigInformation->DmaPort = partialData->u.Dma.Port;
            break;
        }
    }
}

#if !defined(NO_LEGACY_DRIVERS)

BOOLEAN
GetPciConfiguration(
    IN PDRIVER_OBJECT          DriverObject,
    IN OUT PDEVICE_OBJECT      DeviceObject,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID                   RegistryPath,
    IN ULONG                   BusNumber,
    IN OUT PPCI_SLOT_NUMBER    SlotNumber
    )

/*++

Routine Description:

    Walk PCI slot information looking for Vendor and Product ID matches.
    Get slot information for matches and register with hal for the resources.

Arguments:

    DriverObject - Miniport driver object.
    DeviceObject - Represents this adapter.
    HwInitializationData - Miniport description.
    RegistryPath - Service key path.
    BusNumber - PCI bus number for this search.
    SlotNumber - Starting slot number for this search.

Return Value:

    TRUE if card found. Slot and function numbers will return values that
    should be used to continue the search for additional cards, when a card
    is found.

--*/

{
    PADAPTER_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    ULONG               rangeNumber = 0;
    ULONG               pciBuffer;
    ULONG               slotNumber;
    ULONG               functionNumber;
    ULONG               status;
    PCI_SLOT_NUMBER     slotData;
    PPCI_COMMON_CONFIG  pciData;
    UNICODE_STRING      unicodeString;
    UCHAR               vendorString[5];
    UCHAR               deviceString[5];

    PAGED_CODE();

    pciData = (PPCI_COMMON_CONFIG)&pciBuffer;

    //
    //
    // typedef struct _PCI_SLOT_NUMBER {
    //     union {
    //         struct {
    //             ULONG   DeviceNumber:5;
    //             ULONG   FunctionNumber:3;
    //             ULONG   Reserved:24;
    //         } bits;
    //         ULONG   AsULONG;
    //     } u;
    // } PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;
    //

    slotData.u.AsULONG = 0;

    //
    // Look at each device.
    //

    for (slotNumber = (*SlotNumber).u.bits.DeviceNumber;
         slotNumber < 32;
         slotNumber++) {

        slotData.u.bits.DeviceNumber = slotNumber;

        //
        // Look at each function.
        //

        for (functionNumber= (*SlotNumber).u.bits.FunctionNumber;
             functionNumber < 8;
             functionNumber++) {

            slotData.u.bits.FunctionNumber = functionNumber;

            //
            // Make sure that the function number loop restarts at function
            // zero, not what was passed in.  If we find an adapter we'll
            // reset this value to contain the next function number to
            // be tested.
            //

            (*SlotNumber).u.bits.FunctionNumber = 0;

            if (!HalGetBusData(PCIConfiguration,
                               BusNumber,
                               slotData.u.AsULONG,
                               pciData,
                               sizeof(ULONG))) {

                //
                // Out of PCI data.
                //

                return FALSE;
            }

            if (pciData->VendorID == PCI_INVALID_VENDORID) {

                //
                // No PCI device, or no more functions on device
                // move to next PCI device.
                //

                break;
            }

            //
            // Translate hex ids to strings.
            //

            sprintf(vendorString, "%04x", pciData->VendorID);
            sprintf(deviceString, "%04x", pciData->DeviceID);

            DebugPrint((1,
                       "GetPciConfiguration: Bus %x Slot %x Function %x Vendor %s Product %s\n",
                       BusNumber,
                       slotNumber,
                       functionNumber,
                       vendorString,
                       deviceString));

            //
            // Compare strings.
            //

            if (_strnicmp(vendorString,
                        HwInitializationData->VendorId,
                        HwInitializationData->VendorIdLength) ||
                _strnicmp(deviceString,
                        HwInitializationData->DeviceId,
                        HwInitializationData->DeviceIdLength)) {

                //
                // Not our PCI device. Try next device/function
                //

                continue;
            }

            //
            // This is the miniport drivers slot. Allocate the
            // resources.
            //

            RtlInitUnicodeString(&unicodeString, L"ScsiAdapter");
            status = HalAssignSlotResources(
                        RegistryPath,
                        &unicodeString,
                        DriverObject,
                        DeviceObject,
                        PCIBus,
                        BusNumber,
                        slotData.u.AsULONG,
                        &(fdoExtension->AllocatedResources));

            if (!NT_SUCCESS(status)) {

                //
                // ToDo: Log this error.
                //

                DebugPrint((0, "SCSIPORT - GetPciConfiguration:  Resources for "
                               "bus %d slot %d could not be retrieved [%#08lx]\n",
                               BusNumber,
                               slotData.u.AsULONG,
                               status));

                break;
            }

            //
            // Record PCI slot number for miniport.
            //

            slotData.u.bits.FunctionNumber++;

            *SlotNumber = slotData;

            //
            // Translate the resources
            //

            status = SpTranslateResources(DriverObject,
                                          fdoExtension->AllocatedResources,
                                          &(fdoExtension->TranslatedResources));

            return TRUE;

        }   // next PCI function

    }   // next PCI slot

    return FALSE;

} // GetPciConfiguration()
#endif // NO_LEGACY_DRIVERS


ULONG
ScsiPortSetBusDataByOffset(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns writes bus data to a specific offset within a slot.

Arguments:

    DeviceExtension - State information for a particular adapter.

    BusDataType - Supplies the type of bus.

    SystemIoBusNumber - Indicates which system IO bus.

    SlotNumber - Indicates which slot.

    Buffer - Supplies the data to write.

    Offset - Byte offset to begin the write.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Number of bytes written.

--*/

{

    PADAPTER_EXTENSION fdoExtension =
        GET_FDO_EXTENSION(DeviceExtension);

    if(!fdoExtension->IsInVirtualSlot) {

#if defined(NO_LEGACY_DRIVERS)

        DebugPrint((1,"ScsiPortSetBusDataByOffset: !fdoExtension->"
                    "IsInVirtualSlot, not supported for 64-bits.\n"));

        return STATUS_INVALID_PARAMETER;

#else

        return(HalSetBusDataByOffset(BusDataType,
                                     SystemIoBusNumber,
                                     SlotNumber,
                                     Buffer,
                                     Offset,
                                     Length));

#endif // NO_LEGACY_DRIVERS

    } else {

        ASSERT(fdoExtension->LowerBusInterfaceStandardRetrieved == TRUE);

        return fdoExtension->LowerBusInterfaceStandard.SetBusData(
                    fdoExtension->LowerBusInterfaceStandard.Context,
                    BusDataType,
                    Buffer,
                    Offset,
                    Length);
    }

} // end ScsiPortSetBusDataByOffset()


VOID
SpCreateScsiDirectory(
    VOID
    )

{
    UNICODE_STRING unicodeDirectoryName;
    OBJECT_ATTRIBUTES objectAttributes;

    HANDLE directory;

    NTSTATUS status;

    PAGED_CODE();

    RtlInitUnicodeString(
        &unicodeDirectoryName,
        L"\\Device\\Scsi");

    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeDirectoryName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL);

    status = ZwCreateDirectoryObject(&directory,
                                     DIRECTORY_ALL_ACCESS,
                                     &objectAttributes);

    if(NT_SUCCESS(status)) {

        ObReferenceObjectByHandle(directory,
                                  FILE_READ_ATTRIBUTES,
                                  NULL,
                                  KernelMode,
                                  &ScsiDirectory,
                                  NULL);
        ZwClose(directory);

    }
    return;
}


NTSTATUS
SpReportNewAdapter(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine will report an adapter discovered while sniffing through the
    system to plug and play in order to get an add device call for it

    This is done by:

        * calling IoReportDetectedDevice to inform PnP about the new device
        * storing the returned PDO pointer into the device extension as the
          lower device object so we can match PDO to FDO when the add device
          rolls around

Arguments:

    DeviceObject - a pointer to the device object that was "found"

Return Value:

    status

--*/

{
    PDRIVER_OBJECT driverObject = DeviceObject->DriverObject;
    PADAPTER_EXTENSION functionalExtension = DeviceObject->DeviceExtension;
    PPORT_CONFIGURATION_INFORMATION configInfo =
        functionalExtension->PortConfig;
    PDEVICE_OBJECT pdo = NULL;

    BOOLEAN resourceAssigned;

    NTSTATUS status;

    PAGED_CODE();

    ASSERT(functionalExtension->AllocatedResources != NULL);
    ASSERT(functionalExtension->IsPnp == FALSE);

    if(functionalExtension->IsMiniportDetected) {

        //
        // We haven't claimed the resources yet and we need pnp to give them
        // to us the next time around.
        //

        resourceAssigned = FALSE;
    } else {

        //
        // The port driver located this device using the HAL to scan all
        // appropriate bus slots.  It's already claimed those resources and
        // on the next boot we'll hopefully have a duplicate PDO to use
        // for the device.  Don't let pnp grab the resources on our behalf.
        //

        resourceAssigned = TRUE;
    }

    status = IoReportDetectedDevice(driverObject,
                                    configInfo->AdapterInterfaceType,
                                    configInfo->SystemIoBusNumber,
                                    configInfo->SlotNumber,
                                    functionalExtension->AllocatedResources,
                                    NULL,
                                    resourceAssigned,
                                    &pdo);

    //
    // If we got a PDO then setup information about slot and bus numbers in
    // the devnode in the registry.  These may not be valid but we assume that
    // if the miniport asks for slot info then it's on a bus that supports it.
    //

    if(NT_SUCCESS(status)) {

        HANDLE instanceHandle;
        NTSTATUS writeStatus;

        writeStatus = SpWriteNumericInstanceValue(
                            pdo,
                            L"BusNumber",
                            configInfo->SystemIoBusNumber);

        status = min(writeStatus, status);

        writeStatus = SpWriteNumericInstanceValue(
                            pdo,
                            L"SlotNumber",
                            configInfo->SlotNumber);

        status = min(writeStatus, status);

        writeStatus = SpWriteNumericInstanceValue(
                            pdo,
                            L"LegacyInterfaceType",
                            configInfo->AdapterInterfaceType);

        status = min(writeStatus, status);
    }

    if(NT_SUCCESS(status)) {

        PDEVICE_OBJECT newStack;

        newStack = IoAttachDeviceToDeviceStack( DeviceObject, pdo);

        functionalExtension->CommonExtension.LowerDeviceObject = newStack;
        functionalExtension->LowerPdo = pdo;

        if(newStack == NULL) {
            status = STATUS_UNSUCCESSFUL;
        } else {
            status = STATUS_SUCCESS;
        }
    }
    return status;
}

NTSTATUS
SpCreateAdapter(
    IN PDRIVER_OBJECT DriverObject,
    OUT PDEVICE_OBJECT *Fdo
    )

/*++

Routine Description:

    This routine will allocate a new functional device object for an adapter.
    It will allocate the device and fill in the common and functional device
    extension fields which can be setup without any information about the
    adapter this device object is for.

    This routine will increment the global ScsiPortCount

Arguments:

    DriverObject - a pointer to the driver object for this device

    Fdo - a location to store the FDO pointer if the routine is successful

Return Value:

    status

--*/

{
    PSCSIPORT_DRIVER_EXTENSION driverExtension;

    LONG adapterNumber;
    ULONG i, j;

    PUNICODE_STRING registryPath;
    WCHAR wideBuffer[128];
    ULONG serviceNameIndex = 0;
    ULONG serviceNameChars;

    WCHAR wideDeviceName[64];
    UNICODE_STRING unicodeDeviceName;

    PWCHAR savedDeviceName = NULL;

    PADAPTER_EXTENSION fdoExtension;
    PCOMMON_EXTENSION commonExtension;

    NTSTATUS status;

    PAGED_CODE();

    driverExtension = IoGetDriverObjectExtension(DriverObject,
                                                 ScsiPortInitialize);

    adapterNumber = InterlockedIncrement(&driverExtension->AdapterCount);

    RtlZeroMemory(wideBuffer, sizeof(wideBuffer));

    registryPath = &(driverExtension->RegistryPath);

    for(i = 0; i < (registryPath->Length / sizeof(WCHAR)); i++) {

        if(registryPath->Buffer[i] == UNICODE_NULL) {
            i--;
            break;
        }

        if((registryPath->Buffer[i] == L'\\') ||
           (registryPath->Buffer[i] == L'/')) {
            serviceNameIndex = i+1;
        }
    }

    serviceNameChars = (i - serviceNameIndex) + 1;

    DebugPrint((2, "SpCreateAdapter: Registry buffer %#p\n", registryPath));
    DebugPrint((2, "SpCreateAdapter: Starting offset %d chars\n",
                serviceNameIndex));
    DebugPrint((2, "SpCreateAdapter: Ending offset %d chars\n", i));
    DebugPrint((2, "SpCreateAdapter: %d chars or %d bytes will be copied\n",
                serviceNameChars, (serviceNameChars * sizeof(WCHAR))));

    DebugPrint((2, "SpCreateAdapter: Name is \""));

    for(j = 0; j < serviceNameChars; j++) {
        DebugPrint((2, "%wc", registryPath->Buffer[serviceNameIndex + j]));
    }
    DebugPrint((2, "\"\n"));

    RtlCopyMemory(wideBuffer,
                  &(registryPath->Buffer[serviceNameIndex]),
                  serviceNameChars * sizeof(WCHAR));

    swprintf(wideDeviceName,
             L"\\Device\\Scsi\\%ws%d",
             wideBuffer,
             adapterNumber);

    RtlInitUnicodeString(&unicodeDeviceName, wideDeviceName);

    DebugPrint((1, "SpCreateFdo: Device object name is %wZ\n",
                &unicodeDeviceName));

    status = IoCreateDevice(
                DriverObject,
                ADAPTER_EXTENSION_SIZE + unicodeDeviceName.MaximumLength,
                &unicodeDeviceName,
                FILE_DEVICE_CONTROLLER,
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                Fdo);

    ASSERTMSG("Name isn't unique: ", status != STATUS_OBJECT_NAME_COLLISION);

    if(!NT_SUCCESS(status)) {

        DebugPrint((1, "ScsiPortAddDevice: couldn't allocate new FDO "
                       "[%#08lx]\n", status));

        return status;
    }

    fdoExtension = (*Fdo)->DeviceExtension;
    commonExtension = &(fdoExtension->CommonExtension);

    RtlZeroMemory(fdoExtension, ADAPTER_EXTENSION_SIZE);

    commonExtension->DeviceObject = *Fdo;
    commonExtension->IsPdo = FALSE;

    commonExtension->MajorFunction = AdapterMajorFunctionTable;

    commonExtension->WmiInitialized            = FALSE;
    commonExtension->WmiMiniPortSupport        = FALSE;
    commonExtension->WmiScsiPortRegInfoBuf     = NULL;
    commonExtension->WmiScsiPortRegInfoBufSize = 0;

    commonExtension->CurrentPnpState = 0xff;
    commonExtension->PreviousPnpState = 0xff;

    commonExtension->CurrentDeviceState = PowerDeviceD0;
    commonExtension->DesiredDeviceState = PowerDeviceUnspecified;
    commonExtension->CurrentSystemState = PowerSystemWorking;

    KeInitializeEvent(&commonExtension->RemoveEvent,
                      SynchronizationEvent,
                      FALSE);

    //
    // Initialize remove lock to zero.  It will be incremented once pnp is aware
    // of its existance.
    //

    commonExtension->RemoveLock = 0;

#if DBG
    KeInitializeSpinLock(&commonExtension->RemoveTrackingSpinlock);
    commonExtension->RemoveTrackingList = NULL;

    ExInitializeNPagedLookasideList(
        &(commonExtension->RemoveTrackingLookasideList),
        NULL,
        NULL,
        0,
        sizeof(REMOVE_TRACKING_BLOCK),
        SCSIPORT_TAG_LOCK_TRACKING,
        64);

    commonExtension->RemoveTrackingLookasideListInitialized = TRUE;
#else
    commonExtension->RemoveTrackingSpinlock = (ULONG) -1L;
    commonExtension->RemoveTrackingList = (PVOID) -1L;
#endif


    SpAcquireRemoveLock(*Fdo, *Fdo);

    //
    // Initialize the logical unit list locks.
    //

    for(i = 0; i < NUMBER_LOGICAL_UNIT_BINS; i++) {
        KeInitializeSpinLock(&fdoExtension->LogicalUnitList[i].Lock);
    }

    //
    // Don't set port number until the device has been started.
    //

    fdoExtension->PortNumber = (ULONG) -1;
    fdoExtension->AdapterNumber = adapterNumber;

    //
    // Copy the device name for later use.
    //

    fdoExtension->DeviceName = (PWSTR) (fdoExtension + 1);
    RtlCopyMemory(fdoExtension->DeviceName,
                  unicodeDeviceName.Buffer,
                  unicodeDeviceName.MaximumLength);

    //
    // Initialize the enumeration synchronization event.
    //

    KeInitializeMutex(&(fdoExtension->EnumerationDeviceMutex), 0);
    ExInitializeFastMutex(&(fdoExtension->EnumerationWorklistMutex));

    ExInitializeWorkItem(&(fdoExtension->EnumerationWorkItem),
                         SpEnumerationWorker,
                         fdoExtension);

    //
    // Initialize the power up mutex.
    //

    ExInitializeFastMutex(&(fdoExtension->PowerMutex));

    //
    // Set uncached extension limits to valid values.
    //

    fdoExtension->MaximumCommonBufferBase.HighPart = 0;
    fdoExtension->MaximumCommonBufferBase.LowPart = 0xffffffff;

    (*Fdo)->Flags |= DO_DIRECT_IO;
    (*Fdo)->Flags &= ~DO_DEVICE_INITIALIZING;

    // fdoExtension->CommonExtension.IsInitialized = TRUE;

    return status;
}


VOID
SpInitializeAdapterExtension(
    IN PADAPTER_EXTENSION FdoExtension,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN OUT PHW_DEVICE_EXTENSION HwDeviceExtension OPTIONAL
    )

/*++

Routine Description:

    This routine will setup the miniport entry points and initialize values
    in the port driver device extension.  It will also setup the pointers
    to the HwDeviceExtension if supplied

Arguments:

    FdoExtension - the fdo extension being initialized

    HwInitializationData - the init data we are using to initalize the fdo
                           extension

    HwDeviceExtension - the miniport's private extension

Return Value:

    none

--*/

{
    PSCSIPORT_DRIVER_EXTENSION DrvExt;

    PAGED_CODE();

    FdoExtension->HwFindAdapter = HwInitializationData->HwFindAdapter;
    FdoExtension->HwInitialize = HwInitializationData->HwInitialize;
    FdoExtension->HwStartIo = HwInitializationData->HwStartIo;
    FdoExtension->HwInterrupt = HwInitializationData->HwInterrupt;
    FdoExtension->HwResetBus = HwInitializationData->HwResetBus;
    FdoExtension->HwDmaStarted = HwInitializationData->HwDmaStarted;
    FdoExtension->HwLogicalUnitExtensionSize =
        HwInitializationData->SpecificLuExtensionSize;

    FdoExtension->HwAdapterControl = NULL;

    if(HwInitializationData->HwInitializationDataSize >=
       (FIELD_OFFSET(HW_INITIALIZATION_DATA, HwAdapterControl) +
        sizeof(PHW_ADAPTER_CONTROL)))  {

        //
        // This miniport knows about the stop adapter routine.  Store the
        // pointer away.
        //

        FdoExtension->HwAdapterControl = HwInitializationData->HwAdapterControl;
    }

    //
    // If scsiport's verifier is configured, initialize the verifier extension.
    //

    DrvExt = IoGetDriverObjectExtension(
                 FdoExtension->DeviceObject->DriverObject,
                 ScsiPortInitialize);
    if (DrvExt != NULL && DrvExt->Verifying == 1) {
        SpDoVerifierInit(FdoExtension, HwInitializationData);
    }

    //
    // Check if the miniport driver requires any noncached memory.
    // SRB extensions will come from this memory.  Round the size
    // a multiple of quadwords
    //

    FdoExtension->SrbExtensionSize =
        (HwInitializationData->SrbExtensionSize + sizeof(LONGLONG) - 1) &
        ~(sizeof(LONGLONG) - 1);

    //
    // Initialize the maximum lu count
    //

    FdoExtension->MaxLuCount = SCSI_MAXIMUM_LOGICAL_UNITS;

    FdoExtension->NumberOfRequests = MINIMUM_SRB_EXTENSIONS;

    if(ARGUMENT_PRESENT(HwDeviceExtension)) {
        HwDeviceExtension->FdoExtension = FdoExtension;
        FdoExtension->HwDeviceExtension = HwDeviceExtension->HwDeviceExtension;
    }

#if defined(FORWARD_PROGRESS)
    //
    // Initialize the reserved pages which we use to ensure that forward progress
    // can be made in low-memory conditions.
    //

    FdoExtension->ReservedPages = MmAllocateMappingAddress(
                                      SP_RESERVED_PAGES * PAGE_SIZE, 
                                      SCSIPORT_TAG_MAPPING_LIST);

    //
    // Allocate a spare MDL for use in low memory conditions.  Note that we 
    // pass NULL as the VirtualAddress.  We do this because we're reinitialize
    // the MDL everytime we use it with the appropriate VA and size.
    // 
 
    FdoExtension->ReservedMdl = IoAllocateMdl(NULL,
                                              SP_RESERVED_PAGES * PAGE_SIZE,
                                              FALSE,
                                              FALSE,
                                              NULL);
                                              
#endif

    return;
}

#if !defined(NO_LEGACY_DRIVERS)

NTSTATUS
ScsiPortInitLegacyAdapter(
    IN PSCSIPORT_DRIVER_EXTENSION DriverExtension,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext
    )

/*++

Routine Description:

    This routine will locate the adapters attached to a given bus type and
    then report them (and their necessary resources) to the pnp system to
    be initialized later.

    If adapters are found, this routine will pre-initialize their device
    extensions and place them into one of the init chains for use during
    Add/Start device routines.

Arguments:

    DriverExtension - a pointer to the driver extension for this miniport

    HwInitializationData - the init data that the miniport handed to
                           ScsiPortInitialize

Return Value:

    status

--*/

{
    CONFIGURATION_CONTEXT configurationContext;

    PPORT_CONFIGURATION_INFORMATION configInfo = NULL;

    PUNICODE_STRING registryPath = &(DriverExtension->RegistryPath);

    PHW_DEVICE_EXTENSION hwDeviceExtension = NULL;

    PDEVICE_OBJECT fdo;
    PADAPTER_EXTENSION fdoExtension;

    BOOLEAN callAgain = FALSE;
    BOOLEAN isPci = FALSE;

    PCI_SLOT_NUMBER slotNumber;

    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;

    PCM_RESOURCE_LIST resourceList;

    ULONG uniqueId;

    BOOLEAN attached = FALSE;

    NTSTATUS returnStatus = STATUS_DEVICE_DOES_NOT_EXIST;
    NTSTATUS status;

    PAGED_CODE();

    slotNumber.u.AsULONG = 0;

    RtlZeroMemory(&configurationContext, sizeof(configurationContext));

    if(HwInitializationData->NumberOfAccessRanges != 0) {

        configurationContext.AccessRanges =
            SpAllocatePool(PagedPool,
                           (HwInitializationData->NumberOfAccessRanges *
                            sizeof(ACCESS_RANGE)),
                           SCSIPORT_TAG_ACCESS_RANGE,
                           DriverExtension->DriverObject);

        if(configurationContext.AccessRanges == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Keep calling the miniport's find adapter routine until the miniport
    // indicates it is doen and there is no more configuration information.
    // The loop is terminated when the SpInitializeConfiguration routine
    // inidcates ther eis no more configuration information or an error occurs.
    //

    do {

        ULONG hwDeviceExtensionSize = HwInitializationData->DeviceExtensionSize +
                                      sizeof(HW_DEVICE_EXTENSION);

        attached = FALSE;


        fdo = NULL;
        fdoExtension = NULL;

        //
        // Allocate the HwDeviceExtension first - it's easier to deallocate :)
        //

        hwDeviceExtension = SpAllocatePool(NonPagedPool,
                                           hwDeviceExtensionSize,
                                           SCSIPORT_TAG_DEV_EXT,
                                           DriverExtension->DriverObject);


        if(hwDeviceExtension == NULL) {
            DebugPrint((1, "SpInitLegacyAdapter: Could not allocate "
                           "HwDeviceExtension\n"));
            RtlFreeUnicodeString(&unicodeString);
            fdoExtension = NULL;
            uniqueId = __LINE__;
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlZeroMemory(hwDeviceExtension, hwDeviceExtensionSize);

        status = SpCreateAdapter(DriverExtension->DriverObject,
                                 &fdo);

        if(!NT_SUCCESS(status)) {
            DebugPrint((1, "SpInitLegacyAdapter: Could not allocate "
                           "fdo [%#08lx]\n", status));
            RtlFreeUnicodeString(&unicodeString);
            ExFreePool(hwDeviceExtension);
            uniqueId = __LINE__;
            break;
        }

        fdoExtension = fdo->DeviceExtension;

        fdoExtension->IsMiniportDetected = TRUE;

        //
        // Setup device extension pointers
        //

        SpInitializeAdapterExtension(fdoExtension,
                                     HwInitializationData,
                                     hwDeviceExtension);

        hwDeviceExtension = NULL;

        fdoExtension->CommonExtension.IsInitialized = TRUE;

NewConfiguration:

        //
        // initialize the miniport config info buffer
        //

        status = SpInitializeConfiguration(
                    fdoExtension,
                    &DriverExtension->RegistryPath,
                    HwInitializationData,
                    &configurationContext);


        if(!NT_SUCCESS(status)) {

            uniqueId = __LINE__;
            break;
        }

        //
        // Allocate a config-info structure and access ranges for the
        // miniport drivers to use
        //

        configInfo = SpAllocatePool(
                        NonPagedPool,
                        ((sizeof(PORT_CONFIGURATION_INFORMATION) +
                          (HwInitializationData->NumberOfAccessRanges *
                           sizeof(ACCESS_RANGE)) + 7) & ~7),
                        SCSIPORT_TAG_ACCESS_RANGE,
                        DriverExtension->DriverObject);

        if(configInfo == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            uniqueId = __LINE__;
            break;
        }

        fdoExtension->PortConfig = configInfo;

        //
        // Copy the current structure to the writable copy
        //

        RtlCopyMemory(configInfo,
                      &configurationContext.PortConfig,
                      sizeof(PORT_CONFIGURATION_INFORMATION));

        //
        // Copy the SrbExtensionSize from device extension to ConfigInfo.
        // A check will be made later to determine if the miniport updated
        // this value
        //

        configInfo->SrbExtensionSize = fdoExtension->SrbExtensionSize;
        configInfo->SpecificLuExtensionSize = fdoExtension->HwLogicalUnitExtensionSize;

        //
        // initialize the access range array
        //

        if(HwInitializationData->NumberOfAccessRanges != 0) {

            configInfo->AccessRanges = (PVOID) (configInfo + 1);

            //
            // Quadword align this
            //

            (ULONG_PTR) (configInfo->AccessRanges) += 7;
            (ULONG_PTR) (configInfo->AccessRanges) &= ~7;

            RtlCopyMemory(configInfo->AccessRanges,
                          configurationContext.AccessRanges,
                          (HwInitializationData->NumberOfAccessRanges *
                           sizeof(ACCESS_RANGE)));
        }

        ASSERT(HwInitializationData->AdapterInterfaceType != Internal);

        //
        // If PCI bus initialize configuration information with
        // slot information.
        //

        if(HwInitializationData->AdapterInterfaceType == PCIBus &&
           HwInitializationData->VendorIdLength > 0 &&
           HwInitializationData->DeviceIdLength > 0 &&
           HwInitializationData->DeviceId &&
           HwInitializationData->VendorId) {

            PCI_SLOT_NUMBER tmp;

            isPci = TRUE;

            configInfo->BusInterruptLevel = 0;
            if(!GetPciConfiguration(DriverExtension->DriverObject,
                                    fdo,
                                    HwInitializationData,
                                    registryPath,
                                    configurationContext.BusNumber,
                                    &slotNumber)) {


                //
                // Adapter not found.  Continue search with next bus
                //

                configurationContext.BusNumber++;
                slotNumber.u.AsULONG = 0;
                fdoExtension->PortConfig = NULL;
                ExFreePool(configInfo);
                callAgain = FALSE;
                goto NewConfiguration;

            }

            fdoExtension->IsMiniportDetected = FALSE;

            //
            // GetPciConfiguration increments the function number when it
            // finds something.  We need to be looking at the previous
            // function number.
            //

            tmp.u.AsULONG = slotNumber.u.AsULONG;
            tmp.u.bits.FunctionNumber--;
            configInfo->SlotNumber = tmp.u.AsULONG;

            SpBuildConfiguration(fdoExtension,
                                 HwInitializationData,
                                 configInfo);

            if(!configInfo->BusInterruptLevel) {

                //
                // No interrupt was assigned - skip this slot and call
                // again
                //

                fdoExtension->PortConfig = NULL;
                ExFreePool(configInfo);
                goto NewConfiguration;
            }

        }

        //
        // Get the miniport configuration inofmraiton
        //

        callAgain = FALSE;

        status = SpCallHwFindAdapter(fdo,
                                     HwInitializationData,
                                     HwContext,
                                     &configurationContext,
                                     configInfo,
                                     &callAgain);


        if(NT_SUCCESS(status)) {

            status = SpAllocateAdapterResources(fdo);

            if(NT_SUCCESS(status)) {
                status = SpCallHwInitialize(fdo);
            }

            attached = TRUE;

        } else if (status == STATUS_DEVICE_DOES_NOT_EXIST) {

            PCM_RESOURCE_LIST emptyResources = NULL;

            configurationContext.BusNumber++;
            fdoExtension->PortConfig = NULL;
            ExFreePool(configInfo);
            callAgain = FALSE;

            //
            // Release the resources we've allocated for this device object
            // if it's a PCI system.
            //

            IoAssignResources(registryPath,
                              NULL,
                              DriverExtension->DriverObject,
                              fdo,
                              NULL,
                              &emptyResources);

            if(emptyResources != NULL) {
                ExFreePool(emptyResources);
            }

            goto NewConfiguration;
        }

        if(NT_SUCCESS(status)) {

            //
            // Try to start the adapter
            //

            status = ScsiPortStartAdapter(fdo);

            if(NT_SUCCESS(status)) {
                fdoExtension->CommonExtension.CurrentPnpState =
                    IRP_MN_START_DEVICE;
            }
        }

        if(!NT_SUCCESS(returnStatus)) {

            //
            // if no devices were found then just return the current status
            //

            returnStatus = status;

        }

        if(!NT_SUCCESS(status)) {
            break;
        }

        SpEnumerateAdapterSynchronous(fdoExtension, TRUE);

        //
        // update the local adapter count
        //

        configurationContext.AdapterNumber++;

        //
        // Bump the bus number if miniport inidicated that it should not be
        // called again on this bus.
        //

        if(!callAgain) {
            configurationContext.BusNumber++;
        }

        //
        // Set the return status to STATUS_SUCCESS to indicate that one HBA
        // was found.
        //

        returnStatus = STATUS_SUCCESS;

    } while(TRUE);

    if(!NT_SUCCESS(status)) {

        //
        // If the device existed but some other error occurred then log it.
        //

        if(status != STATUS_DEVICE_DOES_NOT_EXIST) {

            PIO_ERROR_LOG_PACKET errorLogEntry;

            //
            // An error occured - log it.
            //

            errorLogEntry = (PIO_ERROR_LOG_PACKET)
                                IoAllocateErrorLogEntry(
                                    fdo,
                                    sizeof(IO_ERROR_LOG_PACKET));

            if(errorLogEntry != NULL) {
                errorLogEntry->ErrorCode = IO_ERR_DRIVER_ERROR;
                errorLogEntry->UniqueErrorValue = uniqueId;
                errorLogEntry->FinalStatus = status;
                errorLogEntry->DumpDataSize = 0;
                IoWriteErrorLogEntry(errorLogEntry);
            }
        }

        if(attached) {

            //
            // Tell PNP that this device should be destroyed.
            //

            fdoExtension->DeviceState = PNP_DEVICE_DISABLED | PNP_DEVICE_FAILED;
            fdoExtension->CommonExtension.CurrentPnpState = IRP_MN_REMOVE_DEVICE;
            IoInvalidateDeviceState(fdoExtension->LowerPdo);

        } else {

            //
            // If the HwDeviceExtension hasn't been deleted or assigned to the
            // adapter yet then delete it.
            //

            if(hwDeviceExtension != NULL) {
                ExFreePool(hwDeviceExtension);
            }

            //
            // Clean up the last device object which is not used.
            //

            if (fdoExtension != NULL) {
                fdoExtension->CommonExtension.IsRemoved = REMOVE_PENDING;
                fdoExtension->CommonExtension.CurrentPnpState = IRP_MN_REMOVE_DEVICE;
                SpReleaseRemoveLock(fdoExtension->DeviceObject,
                                    fdoExtension->DeviceObject);
                SpDestroyAdapter(fdoExtension, FALSE);
            }

            //
            // Delete it.
            //

            IoDeleteDevice(fdo);

        }

        if (configurationContext.AccessRanges != NULL) {
            ExFreePool(configurationContext.AccessRanges);
        }

        if (configurationContext.Parameter != NULL) {
            ExFreePool(configurationContext.Parameter);
        }

    }

    return returnStatus;
}
#endif // NO_LEGACY_DRIVERS


NTSTATUS
SpCallHwFindAdapter(
    IN PDEVICE_OBJECT Fdo,
    IN PHW_INITIALIZATION_DATA HwInitData,
    IN PVOID HwContext OPTIONAL,
    IN OUT PCONFIGURATION_CONTEXT ConfigurationContext,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN CallAgain
    )

/*++

Routine Description:

    This routine will issue a call to the miniport's find adapter routine

Arguments:

    Fdo - the fdo for the adapter being found.  This fdo must have already
          had it's device extension initialized and a HwDeviceExtension
          allocated

    HwInitData - a pointer to the HwINitializationData block passed in by the
                 miniport

    HwContext - the context information passed into ScsiPortInitialize by
                the miniport if it's still available

    ConfigurationContext - A configuration context structure which contains
                           state information during a device detection

    ConfigInfo - the config info structure for the miniport's resources

    CallAgain - a boolean flag indicating whether the miniport said to call it
                again for this interface type

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION adapter = Fdo->DeviceExtension;
    PSCSIPORT_DRIVER_EXTENSION
        driverExtension = IoGetDriverObjectExtension(Fdo->DriverObject,
                                                     ScsiPortInitialize);

    NTSTATUS status;

    PCM_RESOURCE_LIST resourceList;

    *CallAgain = FALSE;

    //
    // Preallocate space for 20 address mappings.  This should be enough
    // to handle any miniport.  We'll shrink down the allocation and
    // setup the appropriate "next" pointers once the adapter has been
    // initialized.
    //

    SpPreallocateAddressMapping(adapter, 20);

    status = adapter->HwFindAdapter(adapter->HwDeviceExtension,
                                       HwContext,
                                       NULL,
                                       ConfigurationContext->Parameter,
                                       ConfigInfo,
                                       CallAgain);

    if(adapter->InterruptData.InterruptFlags & PD_LOG_ERROR) {

        adapter->InterruptData.InterruptFlags &=
            ~(PD_LOG_ERROR | PD_NOTIFICATION_REQUIRED);

        LogErrorEntry(adapter, &(adapter->InterruptData.LogEntry));
    }

    //
    // Free the pointer to the bus data at map register base.  This was
    // allocated by ScsiPortGetBusData
    //

    if(adapter->MapRegisterBase) {

        ExFreePool(adapter->MapRegisterBase);
        adapter->MapRegisterBase = NULL;
    }

    //
    // If the device/driver doesn't support bus mastering then it cannot run
    // on a system with 64-bit addresses.
    //

    if((status == SP_RETURN_FOUND) &&
       (ConfigInfo->Master == FALSE) &&
       (Sp64BitPhysicalAddresses == TRUE)) {

        DebugPrint((0, "SpCallHwFindAdapter: Driver does not support bus "
                       "mastering for adapter %#08lx - this type of adapter is "
                       "not supported on systems with 64-bit physical "
                       "addresses\n", adapter));
        return STATUS_NOT_SUPPORTED;
    }

    //
    // If no device was found then return an error
    //

    if(status != SP_RETURN_FOUND) {

        DebugPrint((1, "SpFindAdapter: miniport find adapter routine reported "
                       "an error %d\n", status));

        switch(status) {

            case SP_RETURN_NOT_FOUND: {

                //
                // The driver could not find any devices on this bus.
                // Try the next bus.
                //

                *CallAgain = FALSE;
                return STATUS_DEVICE_DOES_NOT_EXIST;
            }

            case SP_RETURN_BAD_CONFIG: {
                return STATUS_INVALID_PARAMETER;
            }

            case SP_RETURN_ERROR: {
                return STATUS_ADAPTER_HARDWARE_ERROR;
            }

            default: {
                return STATUS_INTERNAL_ERROR;
            }
        }

        return status;

    } else {
        status = STATUS_SUCCESS;
    }

    //
    // Cleanup the mapped address list.
    //

    SpPurgeFreeMappedAddressList(adapter);

    DebugPrint((1, "SpFindAdapter: SCSI Adapter ID is %d\n",
                   ConfigInfo->InitiatorBusId[0]));

    //
    // Check the resource requirements against the registry.  This will
    // check for conflicts and store the information if none were found.
    //

    if(!adapter->IsPnp) {

        UNICODE_STRING unicodeString;
        BOOLEAN conflict;
        PCM_RESOURCE_LIST resourceList;

        RtlInitUnicodeString(&unicodeString, L"ScsiAdapter");

        adapter->AllocatedResources =
            SpBuildResourceList(adapter, ConfigInfo);

        status = SpReportNewAdapter(Fdo);

        if(!NT_SUCCESS(status)) {

            return status;
        }
    }

    //
    // Update SrbExtensionSize and SpecificLuExtensionSize, if necessary.
    // If the common buffer has already been allocated, this has already
    // been done
    //

    if(!adapter->NonCachedExtension &&
       (ConfigInfo->SrbExtensionSize != adapter->SrbExtensionSize)) {

        adapter->SrbExtensionSize =
            (ConfigInfo->SrbExtensionSize + sizeof(LONGLONG)) &
             ~(sizeof(LONGLONG) - 1);

    }

    if(ConfigInfo->SpecificLuExtensionSize !=
       adapter->HwLogicalUnitExtensionSize) {

        adapter->HwLogicalUnitExtensionSize =
            ConfigInfo->SpecificLuExtensionSize;
    }

    //
    // Get maximum target IDs.
    //

    if(ConfigInfo->MaximumNumberOfTargets > SCSI_MAXIMUM_TARGETS_PER_BUS) {
        adapter->MaximumTargetIds = SCSI_MAXIMUM_TARGETS_PER_BUS;
    } else {
        adapter->MaximumTargetIds = ConfigInfo->MaximumNumberOfTargets;
    }

    //
    // Get number of SCSI buses.
    //

    adapter->NumberOfBuses = ConfigInfo->NumberOfBuses;

    //
    // Remember if the adapter caches data.
    //

    adapter->CachesData = ConfigInfo->CachesData;

    //
    // Save away some of the attributes.
    //

    adapter->ReceiveEvent = ConfigInfo->ReceiveEvent;
    adapter->TaggedQueuing = ConfigInfo->TaggedQueuing;
    adapter->MultipleRequestPerLu = ConfigInfo->MultipleRequestPerLu;
    adapter->CommonExtension.WmiMiniPortSupport = ConfigInfo->WmiDataProvider;

    //
    // Clear those options which have been disabled in the registry.
    //

    if(ConfigurationContext->DisableMultipleLu) {
        adapter->MultipleRequestPerLu =
            ConfigInfo->MultipleRequestPerLu = FALSE;
    }

    if(ConfigurationContext->DisableTaggedQueueing) {
        adapter->TaggedQueuing =
            ConfigInfo->TaggedQueuing = 
            ConfigInfo->MultipleRequestPerLu = FALSE;
    }

    //
    // If the adapter supports tagged queuing or multiple requests per logical
    // unit, SRB data needs to be allocated.
    //

    if (adapter->TaggedQueuing || adapter->MultipleRequestPerLu) {
        adapter->SupportsMultipleRequests = TRUE;
    } else {
        adapter->SupportsMultipleRequests = FALSE;
    }

    return status;
}


NTSTATUS
SpAllocateAdapterResources(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will allocate and initialize any necessary resources for the
    adapter.  It handles one time initialization of the srb data blocks,
    srb extensions, etc...

Arguments:

    Fdo - a pointer to the functional device object being initialized

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PIO_SCSI_CAPABILITIES capabilities;
    PPORT_CONFIGURATION_INFORMATION configInfo =
        fdoExtension->PortConfig;

    NTSTATUS status = STATUS_SUCCESS;
    PVOID SrbExtensionBuffer;

    PAGED_CODE();

    //
    // Initialize the capabilities pointer
    //

    capabilities = &fdoExtension->Capabilities;

    //
    // Set indicator as to whether adapter needs kernel mapped buffers
    //

    fdoExtension->MapBuffers = configInfo->MapBuffers;
    capabilities->AdapterUsesPio = configInfo->MapBuffers;

    //
    // Determine if a DMA Adapter must be allocated
    //

    if((fdoExtension->DmaAdapterObject == NULL) &&
       (configInfo->Master ||
        configInfo->DmaChannel != SP_UNINITIALIZED_VALUE)) {

        DEVICE_DESCRIPTION deviceDescription;
        ULONG numberOfMapRegisters;

        //
        // Get the adapter object for this card
        //

        RtlZeroMemory(&deviceDescription, sizeof(deviceDescription));

        deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;

        deviceDescription.DmaChannel = configInfo->DmaChannel;
        deviceDescription.InterfaceType = configInfo->AdapterInterfaceType;
        deviceDescription.BusNumber = configInfo->SystemIoBusNumber;
        deviceDescription.DmaWidth = configInfo->DmaWidth;
        deviceDescription.DmaSpeed = configInfo->DmaSpeed;
        deviceDescription.ScatterGather = configInfo->ScatterGather;
        deviceDescription.Master = configInfo->Master;
        deviceDescription.DmaPort = configInfo->DmaPort;
        deviceDescription.Dma32BitAddresses = configInfo->Dma32BitAddresses;
        deviceDescription.AutoInitialize = FALSE;
        deviceDescription.DemandMode = configInfo->DemandMode;
        deviceDescription.MaximumLength = configInfo->MaximumTransferLength;

        fdoExtension->Dma32BitAddresses = configInfo->Dma32BitAddresses;

        //
        // If the miniport puts anything in here other than 0x80 then we
        // assume it wants to support 64-bit addresses.
        //

        DebugPrint((1, "SpAllocateAdapterResources: Dma64BitAddresses = "
                       "%#0x\n",
                    configInfo->Dma64BitAddresses));

        fdoExtension->RemapBuffers = (BOOLEAN) (SpRemapBuffersByDefault != 0);

        if((configInfo->Dma64BitAddresses & ~SCSI_DMA64_SYSTEM_SUPPORTED) != 0){
            DebugPrint((1, "SpAllocateAdapterResources: will request "
                           "64-bit PA's\n"));
            deviceDescription.Dma64BitAddresses = TRUE;
            fdoExtension->Dma64BitAddresses = TRUE;
        } else if(Sp64BitPhysicalAddresses == TRUE) {
            DebugPrint((1, "SpAllocateAdapterResources: Will remap buffers for adapter %#p\n", fdoExtension));
            fdoExtension->RemapBuffers = TRUE;
        }

        fdoExtension->DmaAdapterObject = IoGetDmaAdapter(fdoExtension->LowerPdo,
                                                         &deviceDescription,
                                                         &numberOfMapRegisters);

        ASSERT(fdoExtension->DmaAdapterObject);

        //
        // Set maximum number of page breaks
        //

        if(numberOfMapRegisters > configInfo->NumberOfPhysicalBreaks) {
            capabilities->MaximumPhysicalPages =
                configInfo->NumberOfPhysicalBreaks;
        } else {
            capabilities->MaximumPhysicalPages = numberOfMapRegisters;
        }
    }

    status = SpAllocateTagBitMap(fdoExtension);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Initialize power parameters.
    //

    SpInitializePowerParams(fdoExtension);

    //
    // Initialize tunable per-adapter performance parameters.
    //

    SpInitializePerformanceParams(fdoExtension);

    //
    // Allocate memory for the noncached extension if it has not already
    // been allocated.  If the adapter supports AutoRequestSense or
    // needs SRB extensions then an SRB list needs to be allocated.
    //

    SrbExtensionBuffer = SpGetSrbExtensionBuffer(fdoExtension);
    if(((fdoExtension->SrbExtensionSize != 0) || (configInfo->AutoRequestSense)) &&
       (SrbExtensionBuffer == NULL))  {

        //
        // Initialize configurable request sense parameters.
        //

        SpInitializeRequestSenseParams(fdoExtension);

        //
        // Capture the auto request sense flag when the common buffer is
        // allocated.
        //

        fdoExtension->AutoRequestSense = configInfo->AutoRequestSense;

        fdoExtension->AllocateSrbExtension = TRUE;

        status = SpGetCommonBuffer(fdoExtension, 0);

        if(!NT_SUCCESS(status)) {
            return status;
        }
    }

    status = SpInitializeSrbDataLookasideList(Fdo);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Initialize the emergency SRB_DATA structures.
    //

    fdoExtension->EmergencySrbData = SpAllocateSrbData(fdoExtension, NULL);

    if(fdoExtension->EmergencySrbData == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If we are re-initializing a stopped adapter, we must not wipe out any 
    // existing blocked requests.
    //

    if (fdoExtension->SrbDataBlockedRequests.Flink == NULL &&
        fdoExtension->SrbDataBlockedRequests.Blink == NULL) {
        InitializeListHead(&fdoExtension->SrbDataBlockedRequests);
    }

    KeInitializeSpinLock(&fdoExtension->EmergencySrbDataSpinLock);

    //
    // Initialize the pointer to the enumeration request block.
    //

    fdoExtension->PnpEnumRequestPtr = &(fdoExtension->PnpEnumerationRequest);

#ifndef USE_DMA_MACROS
    //
    // Create the scatter gather lookaside list.  This list contains
    // medium sized SG lists.
    //

    fdoExtension->LargeScatterGatherListSize = SP_LARGE_PHYSICAL_BREAK_VALUE;

    ExInitializeNPagedLookasideList(
        &fdoExtension->MediumScatterGatherLookasideList,
        NULL,
        NULL,
        0L,
        (sizeof(SRB_SCATTER_GATHER) *
         (fdoExtension->LargeScatterGatherListSize - 1)),
        SCSIPORT_TAG_MEDIUM_SG_ENTRY,
        (USHORT) fdoExtension->NumberOfRequests);

    fdoExtension->MediumScatterGatherListInitialized = TRUE;
#endif

    //
    // Allocate buffers needed for bus scans.
    //

    fdoExtension->InquiryBuffer = SpAllocatePool(
                                    NonPagedPoolCacheAligned,
                                    SP_INQUIRY_BUFFER_SIZE,
                                    SCSIPORT_TAG_INQUIRY,
                                    Fdo->DriverObject);

    if(fdoExtension->InquiryBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    fdoExtension->InquirySenseBuffer = 
        SpAllocatePool(
            NonPagedPoolCacheAligned,
            SENSE_BUFFER_SIZE + fdoExtension->AdditionalSenseBytes,
            SCSIPORT_TAG_INQUIRY,
            Fdo->DriverObject);

    if(fdoExtension->InquirySenseBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Preallocate an irp for inquiries.  Since this is only used for scsi
    // operations we should only need one stack location.
    //

    fdoExtension->InquiryIrp = SpAllocateIrp(INQUIRY_STACK_LOCATIONS, FALSE, Fdo->DriverObject);

    if(fdoExtension->InquiryIrp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build an MDL for the inquiry buffer.
    //

    fdoExtension->InquiryMdl = SpAllocateMdl(fdoExtension->InquiryBuffer,
                                             INQUIRYDATABUFFERSIZE,
                                             FALSE,
                                             FALSE,
                                             NULL,
                                             Fdo->DriverObject);

    if(fdoExtension->InquiryMdl == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    MmBuildMdlForNonPagedPool(fdoExtension->InquiryMdl);

    //
    // Initialize the capabilities structure.
    //

    capabilities->Length = sizeof(IO_SCSI_CAPABILITIES);
    capabilities->MaximumTransferLength = configInfo->MaximumTransferLength;

    if(configInfo->ReceiveEvent) {
        capabilities->SupportedAsynchronousEvents |=
            SRBEV_SCSI_ASYNC_NOTIFICATION;
    }

    capabilities->TaggedQueuing = fdoExtension->TaggedQueuing;
    capabilities->AdapterScansDown = configInfo->AdapterScansDown;

    //
    // Update the device object alignment if necessary.
    //

    if(configInfo->AlignmentMask > Fdo->AlignmentRequirement) {
        Fdo->AlignmentRequirement = configInfo->AlignmentMask;
    }

    capabilities->AlignmentMask = Fdo->AlignmentRequirement;

    //
    // Make sure maximum number of pages is set to a reasonable value.
    // This occurs for miniports with no Dma adapter.
    //

    if(capabilities->MaximumPhysicalPages == 0) {

        capabilities->MaximumPhysicalPages =
            BYTES_TO_PAGES(capabilities->MaximumTransferLength);

        //
        // Honor any limit requested by the miniport
        //

        if(configInfo->NumberOfPhysicalBreaks < capabilities->MaximumPhysicalPages) {
            capabilities->MaximumPhysicalPages =
                configInfo->NumberOfPhysicalBreaks;
        }

    }

    return status;
}


NTSTATUS
SpCallHwInitialize(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will initialize the specified adapter, connect the interrupts,
    and initialize any necessary resources

Arguments:

    Fdo - a pointer to the functional device object being initialized

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION fdoExtension = Fdo->DeviceExtension;

    PPORT_CONFIGURATION_INFORMATION configInfo =
        fdoExtension->PortConfig;

    KIRQL irql;
    NTSTATUS status;

    //
    // Allocate spin lock for critical sections.
    //

    KeInitializeSpinLock(&fdoExtension->SpinLock);

    //
    // Initialize DPC routine.
    //

    IoInitializeDpcRequest(fdoExtension->CommonExtension.DeviceObject,
                           ScsiPortCompletionDpc);

    //
    // Initialize the port timeout counter.
    //

    fdoExtension->PortTimeoutCounter = PD_TIMER_STOPPED;

    //
    // Initialize the device object timer only if it doesn't already exist
    // (there's no way to delete a timer without deleting the device so if
    // we are stopped and restarted then the timer stays around.  Reinitializing
    // it could cause the timer list to go circular)
    //

    if(Fdo->Timer == NULL) {
        IoInitializeTimer(Fdo, ScsiPortTickHandler, NULL);
    }

    //
    // Initialize miniport timer and timer DPC
    //

    KeInitializeTimer(&fdoExtension->MiniPortTimer);

    KeInitializeDpc(&fdoExtension->MiniPortTimerDpc,
                    SpMiniPortTimerDpc,
                    Fdo);

    KeInitializeSpinLock(&fdoExtension->InterruptSpinLock);

    if((fdoExtension->HwInterrupt == NULL) ||
       (fdoExtension->HasInterrupt == FALSE)) {

        //
        // There is no interrupt so use the dummy routine.
        //

        fdoExtension->SynchronizeExecution = SpSynchronizeExecution;
        fdoExtension->InterruptObject = (PVOID) fdoExtension;

        DebugPrint((1, "ScsiPortInitialize: Adapter has no interrupt.\n"));

    } else {

        KIRQL syncIrql = 0;
        KIRQL irql = 0, irql2 = 0;
        ULONG vector = 0, vector2 = 0;
        KAFFINITY affinity = 0, affinity2 = 0;
        BOOLEAN interruptSharable = FALSE;
        BOOLEAN secondInterrupt = FALSE;

        DebugPrint((1, "ScsiPortInitialize: Interrupt Info for adapter %#p\n", Fdo));

        DebugPrint((1, "ScsiPortInitialize: AdapterInterfaceType = %d\n", configInfo->AdapterInterfaceType));
        DebugPrint((1, "ScsiPortInitialize: BusInterruptLevel = %d\n", configInfo->BusInterruptLevel));
        DebugPrint((1, "ScsiPortInitialize: BusInterruptVector = %d\n", configInfo->BusInterruptVector));
        DebugPrint((1, "ScsiPortInitialize: BusInterruptLevel2 = %d\n", configInfo->BusInterruptLevel2));
        DebugPrint((1, "ScsiPortInitialize: BusInterruptVector2 = %d\n", configInfo->BusInterruptVector2));

        //
        // Determine if 2 interrupt sync. is needed.
        //

        if(fdoExtension->HwInterrupt != NULL &&
           (configInfo->BusInterruptLevel != 0 ||
            configInfo->BusInterruptVector != 0) &&
           (configInfo->BusInterruptLevel2 != 0 ||
            configInfo->BusInterruptVector2 != 0)) {

            secondInterrupt = TRUE;
        }

        //
        // Save the interrupt level.
        //

        fdoExtension->InterruptLevel = configInfo->BusInterruptLevel;

        //
        // Set up for a real interrupt.
        //

        fdoExtension->SynchronizeExecution = KeSynchronizeExecution;

        //
        // Call HAL to get system interrupt parameters for the first
        // interrupt.
        //

        if(fdoExtension->IsMiniportDetected) {

#if defined(NO_LEGACY_DRIVERS)

            DbgPrint("SpCallHwInitialize:  fdoExtension->IsMiniportDetected "
                     "not supported for 64 bits!\n");
#else

            vector = HalGetInterruptVector(
                        configInfo->AdapterInterfaceType,
                        configInfo->SystemIoBusNumber,
                        configInfo->BusInterruptLevel,
                        configInfo->BusInterruptVector,
                        &irql,
                        &affinity);

            if(secondInterrupt) {

                //
                // Spin lock to sync. multiple IRQ's (PCI IDE).
                //

                KeInitializeSpinLock(&fdoExtension->MultipleIrqSpinLock);

                //
                // Call HAL to get system interrupt parameters for the
                // second interrupt.
                //

                vector2 = HalGetInterruptVector(
                            configInfo->AdapterInterfaceType,
                            configInfo->SystemIoBusNumber,
                            configInfo->BusInterruptLevel2,
                            configInfo->BusInterruptVector2,
                            &irql2,
                            &affinity2);
            }

            ASSERT(affinity != 0);

            if(configInfo->AdapterInterfaceType == MicroChannel ||
               configInfo->InterruptMode == LevelSensitive) {
               interruptSharable = TRUE;
            }

#endif // NO_LEGACY_DRIVERS

        } else {

            ULONG i, j;

            ASSERT(secondInterrupt == FALSE);

            for(i = 0; i < fdoExtension->TranslatedResources->Count; i++) {

                for(j = 0;
                    j < fdoExtension->TranslatedResources->List[i].PartialResourceList.Count;
                    j++) {

                    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor =
                        &fdoExtension->TranslatedResources->List[i].PartialResourceList.PartialDescriptors[j];

                    if(descriptor->Type == CmResourceTypeInterrupt) {

                        vector = descriptor->u.Interrupt.Vector;
                        affinity = descriptor->u.Interrupt.Affinity;
                        irql = (KIRQL) descriptor->u.Interrupt.Level;

                        if(descriptor->ShareDisposition == CmResourceShareShared) {
                            interruptSharable = TRUE;
                        }

                        break;
                    }
                }
            }
        }

        syncIrql = (irql > irql2) ? irql : irql2;

        DebugPrint((1, "SpInitializeAdapter: vector = %d\n", vector));
        DebugPrint((1, "SpInitializeAdapter: irql = %d\n", irql));
        DebugPrint((1, "SpInitializeAdapter: affinity = %#08lx\n", affinity));

        status = IoConnectInterrupt(
                    &fdoExtension->InterruptObject,
                    (PKSERVICE_ROUTINE) ScsiPortInterrupt,
                    Fdo,
                    (secondInterrupt ?
                        (&fdoExtension->MultipleIrqSpinLock) : NULL),
                    vector,
                    irql,
                    syncIrql,
                    configInfo->InterruptMode,
                    interruptSharable,
                    affinity,
                    FALSE);

        if(!NT_SUCCESS(status)) {

            DebugPrint((1, "SpInitializeAdapter: Can't connect "
                           "interrupt %d\n", vector));
            fdoExtension->InterruptObject = NULL;
            return status;
        }

        if(secondInterrupt) {

            DebugPrint((1, "SpInitializeAdapter: SCSI adapter second IRQ is %d\n",
                           configInfo->BusInterruptLevel2));

            DebugPrint((1, "SpInitializeAdapter: vector = %d\n", vector));
            DebugPrint((1, "SpInitializeAdapter: irql = %d\n", irql));
            DebugPrint((1, "SpInitializeAdapter: affinity = %#08lx\n", affinity));

            status = IoConnectInterrupt(
                        &fdoExtension->InterruptObject2,
                        (PKSERVICE_ROUTINE) ScsiPortInterrupt,
                        Fdo,
                        &fdoExtension->MultipleIrqSpinLock,
                        vector2,
                        irql2,
                        syncIrql,
                        configInfo->InterruptMode2,
                        interruptSharable,
                        affinity2,
                        FALSE);

            if(!NT_SUCCESS(status)) {

                //
                // If we needed both interrupts, we will continue but not
                // claim any of the resources for the second one
                //

                DebugPrint((1, "SpInitializeAdapter: Can't connect "
                               "second interrupt %d\n", vector2));
                fdoExtension->InterruptObject2 = NULL;

                configInfo->BusInterruptVector2 = 0;
                configInfo->BusInterruptLevel2 = 0;
            }
        }
    }

    //
    // Record first access range if it exists.
    //

    if(configInfo->NumberOfAccessRanges != 0) {
        fdoExtension->IoAddress =
            ((*(configInfo->AccessRanges))[0]).RangeStart.LowPart;

        DebugPrint((1, "SpInitializeAdapter: IO Base address %x\n",
                       fdoExtension->IoAddress));
    }

    //
    // Indicate that a disconnect allowed command running.  This bit is
    // normally on.
    //

    fdoExtension->Flags |= PD_DISCONNECT_RUNNING;

    //
    // Initialize the request count to -1.  This count is biased by -1 so
    // that a value of zero indicates the adapter must be allocated
    //

    fdoExtension->ActiveRequestCount = -1;

    //
    // Indiciate if a scatter/gather list needs to be built.
    //

    if(fdoExtension->DmaAdapterObject != NULL &&
       configInfo->Master &&
       configInfo->NeedPhysicalAddresses) {
        fdoExtension->MasterWithAdapter = TRUE;
    } else {
        fdoExtension->MasterWithAdapter = FALSE;
    }

    //
    // Call the hardware dependant driver to do it's initialization.
    // This routine must be called at DISPATCH_LEVEL.
    //

    KeRaiseIrql(DISPATCH_LEVEL, &irql);

    if(!fdoExtension->SynchronizeExecution(fdoExtension->InterruptObject,
                                           fdoExtension->HwInitialize,
                                           fdoExtension->HwDeviceExtension)) {

        DebugPrint((1, "SpInitializeAdapter: initialization failed\n"));
        KeLowerIrql(irql);
        return STATUS_ADAPTER_HARDWARE_ERROR;
    }

    //
    // Check for miniport work requests.  Note this is an unsynchronized
    // test on the bit that can be set by the interrupt routine;  However,
    // the worst that can happen is that the completion DPC checks for work
    // twice.
    //

    if(fdoExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

        //
        // Call the completion DPC directly.  It must be called at dispatch
        // level.
        //

        SpRequestCompletionDpc(Fdo);
    }

    KeLowerIrql(irql);

    return STATUS_SUCCESS;
}


HANDLE
SpOpenDeviceKey(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG DeviceNumber
    )

/*++

Routine Description:

    This routine will open the services keys for the miniport and put handles
    to them into the configuration context structure.

Arguments:

    RegistryPath - a pointer to the service key name for this miniport

    DeviceNumber - which device too search for under the service key.  -1
                   indicates that the default device key should be opened.

Return Value:

    status

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;

    WCHAR buffer[64];
    UNICODE_STRING unicodeString;

    HANDLE serviceKey;
    HANDLE deviceKey = NULL;

    NTSTATUS status;

    PAGED_CODE();

    serviceKey = SpOpenParametersKey(RegistryPath);

    if(serviceKey != NULL) {

        //
        // Check for a Device Node.  The device node applies to every device
        //

        if(DeviceNumber == (ULONG) -1) {
            swprintf(buffer, L"Device");
        } else {
            swprintf(buffer, L"Device%d", DeviceNumber);
        }

        RtlInitUnicodeString(&unicodeString, buffer);

        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   serviceKey,
                                   (PSECURITY_DESCRIPTOR) NULL);

        //
        // It doesn't matter if this call fails or not.  If it fails, then there
        // is no default device node.  If it works then the handle will be set.
        //

        ZwOpenKey(&deviceKey,
                  KEY_READ,
                  &objectAttributes);

        ZwClose(serviceKey);
    }

    return deviceKey;
}

HANDLE
SpOpenParametersKey(
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine will open the services keys for the miniport and put handles
    to them into the configuration context structure.

Arguments:

    RegistryPath - a pointer to the service key name for this miniport

Return Value:

    status

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;

    UNICODE_STRING unicodeString;

    HANDLE serviceKey;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Open the service node
    //

    InitializeObjectAttributes(&objectAttributes,
                               RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&serviceKey, KEY_READ, &objectAttributes);

    if(!NT_SUCCESS(status)) {

        DebugPrint((1, "SpOpenParameterKey: cannot open service key node for "
                       "driver.  Name: %wZ Status: %08lx\n",
                       RegistryPath, status));
    }

    //
    // Try to open the parameters key.  If it exists then replace the service
    // key with the new key.  This allows the device nodes to be placed
    // under DriverName\Parameters\Device or DriverName\Device
    //

    if(serviceKey != NULL) {

        HANDLE parametersKey;

        //
        // Check for a device node.  The device node applies to every device
        //

        RtlInitUnicodeString(&unicodeString, L"Parameters");

        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   serviceKey,
                                   (PSECURITY_DESCRIPTOR) NULL);

        //
        // Attempt to open the parameters key
        //

        status = ZwOpenKey(&parametersKey,
                           KEY_READ,
                           &objectAttributes);

        if(NT_SUCCESS(status)) {

            //
            // There is a Parameters key.  Use that instead of the service
            // node key.  Close the service node and set the new value
            //

            ZwClose(serviceKey);
            serviceKey = parametersKey;
        }
    }

    return serviceKey;
}


ULONG
SpQueryPnpInterfaceFlags(
    IN PSCSIPORT_DRIVER_EXTENSION DriverExtension,
    IN INTERFACE_TYPE InterfaceType
    )

/*++

Routine Description:

    This routine will look up the interface type in the PnpInterface value
    in the service's parameters key.  If the interface is found in this binary
    value the routine will return TRUE.  If the interface type is not there or
    if any errors occur reading the data, this routine will return FALSE.

Arguments:

    ConfigurationContext - a pointer to the configuration context for this
                           miniport

    InterfaceType - the interface type we are searching for

Return Value:

    TRUE if the interface type is in the safe list

    FALSE if the interface type is not in the safe list or if the value cannot
    be found

--*/

{
    ULONG i;

    PAGED_CODE();

    for(i = 0; i < DriverExtension->PnpInterfaceCount; i++) {

        if(DriverExtension->PnpInterface[i].InterfaceType == InterfaceType) {

            DebugPrint((2, "SpQueryPnpInterfaceFlags: interface %d has flags "
                           "%#08lx\n",
                        InterfaceType,
                        DriverExtension->PnpInterface[i].Flags));

            return DriverExtension->PnpInterface[i].Flags;
        }

    }

    DebugPrint((2, "SpQueryPnpInterfaceFlags: No interface flags for %d\n",
                InterfaceType));
    return SP_PNP_NOT_SAFE;
}


ULONG
ScsiPortGetBusData(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the bus data for an adapter slot or CMOS address.

Arguments:

    BusDataType - Supplies the type of bus.

    BusNumber - Indicates which bus.

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/

{
    PADAPTER_EXTENSION fdoExtension = GET_FDO_EXTENSION(DeviceExtension);
    PDEVICE_OBJECT lowerDevice = NULL;
    CM_EISA_SLOT_INFORMATION slotInformation;

    //
    // If this is in a virtualized slot then setup the lower device object
    // pointer to go to the PDO
    //

    if(fdoExtension->IsInVirtualSlot) {

        //
        // Make sure the bus and slot number are correct
        //

        if(SlotNumber != fdoExtension->VirtualSlotNumber.u.AsULONG) {
            ASSERT(BusDataType == PCIConfiguration);
            return 2;
        }

        lowerDevice = fdoExtension->CommonExtension.LowerDeviceObject;
    }

    //
    // If the length is nonzero, retrieve the requested data.
    //

    if (Length != 0) {

        return SpGetBusData(fdoExtension,
                            lowerDevice,
                            BusDataType,
                            SystemIoBusNumber,
                            SlotNumber,
                            Buffer,
                            Length);
    }

    //
    // Free any previously allocated data.
    //

    if (fdoExtension->MapRegisterBase != NULL) {
        ExFreePool(fdoExtension->MapRegisterBase);
        fdoExtension->MapRegisterBase = NULL;
    }

    if (BusDataType == EisaConfiguration) {

        //
        // Determine the length to allocate based on the number of functions
        // for the slot.
        //

        Length = SpGetBusData( fdoExtension,
                               lowerDevice,
                               BusDataType,
                               SystemIoBusNumber,
                               SlotNumber,
                               &slotInformation,
                               sizeof(CM_EISA_SLOT_INFORMATION));


        if (Length < sizeof(CM_EISA_SLOT_INFORMATION)) {

            //
            // The data is messed up since this should never occur
            //

            return 0;
        }

        //
        // Calculate the required length based on the number of functions.
        //

        Length = sizeof(CM_EISA_SLOT_INFORMATION) +
            (sizeof(CM_EISA_FUNCTION_INFORMATION) * slotInformation.NumberFunctions);

    } else if (BusDataType == PCIConfiguration) {

        //
        // Read only the header.
        //

        Length = PCI_COMMON_HDR_LENGTH;

    } else {

        Length = PAGE_SIZE;
    }

    fdoExtension->MapRegisterBase = 
        SpAllocatePool(NonPagedPool,
                       Length,
                       SCSIPORT_TAG_BUS_DATA,
                       fdoExtension->DeviceObject->DriverObject);

    ASSERT_FDO(fdoExtension->DeviceObject);
    if (fdoExtension->MapRegisterBase == NULL) {
        return 0;
    }

    //
    // Return the pointer to the miniport driver.
    //

    *((PVOID *)Buffer) = fdoExtension->MapRegisterBase;

    return SpGetBusData(fdoExtension,
                        lowerDevice,
                        BusDataType,
                        SystemIoBusNumber,
                        SlotNumber,
                        fdoExtension->MapRegisterBase,
                        Length);

}


ULONG
SpGetBusData(
    IN PADAPTER_EXTENSION Adapter,
    IN PDEVICE_OBJECT Pdo OPTIONAL,
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine will retrieve bus data from the specified slot and bus number
    or from the supplied physical device object.  If bus and slot number are
    supplied it will tranlate into a call to HalGetBusData.

    If a PDO is supplied instead this will issue an IRP_MN_READ_CONFIG to the
    lower level driver.

    This routine allocates memory and waits for irp completion - it should not
    be called above passive level.

Arguments:

    Pdo - if this is non-NULL then it should be a pointer to the top of the
          device object stack for the PDO representing this adapter

    BusNumber - if PDO is NULL then this should be the bus number the adapter
                sits on - zero otherwise

    SlotNumber - if PDO is NULL then this is the number of the slot the
                 adapter is installed into - zero otherwise

    Buffer - location to store the returned data

    Length - size of above

Return Value:

    status

--*/

{

    //
    // if the user didn't specify a PDO to query then just throw this request
    // to the HAL
    //

    if(Pdo == NULL) {

#if defined(NO_LEGACY_DRIVERS)

        DebugPrint((1,"SpGetBusData: NULL PDO, not supported for 64-bits.\n"));
        return STATUS_INVALID_PARAMETER;

#else

        return HalGetBusData(BusDataType,
                             BusNumber,
                             SlotNumber,
                             Buffer,
                             Length);

#endif // NO_LEGACY_DRIVERS

    } else {

        ASSERT(Adapter->LowerBusInterfaceStandardRetrieved == TRUE);

        return Adapter->LowerBusInterfaceStandard.GetBusData(
                    Adapter->LowerBusInterfaceStandard.Context,
                    BusDataType,
                    Buffer,
                    0L,
                    Length);
    }
}


NTSTATUS
SpInitializeSrbDataLookasideList(
    IN PDEVICE_OBJECT AdapterObject
    )
{
    KIRQL oldIrql;
    ULONG adapterTag;
    PDEVICE_OBJECT *newAdapterList;
    PDEVICE_OBJECT *oldAdapterList = NULL;

    NTSTATUS status = STATUS_SUCCESS;

#ifdef ALLOC_PRAGMA
    PVOID sectionHandle = MmLockPagableCodeSection(
                            SpInitializeSrbDataLookasideList);
    InterlockedIncrement(&SpPAGELOCKLockCount);
#endif

    //
    // Add our device object to the global adapter list.  This will require
    // increasing the size of the list.
    //

    KeAcquireSpinLock(&ScsiGlobalAdapterListSpinLock, &oldIrql);

    try {
        adapterTag = ScsiGlobalAdapterListElements;

        newAdapterList = SpAllocatePool(
                            NonPagedPool,
                            (sizeof(PDEVICE_OBJECT) * (adapterTag + 1)),
                            SCSIPORT_TAG_GLOBAL,
                            AdapterObject->DriverObject);

        if(newAdapterList == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        ScsiGlobalAdapterListElements += 1;

        if(ScsiGlobalAdapterList != NULL) {
            RtlCopyMemory(newAdapterList,
                          ScsiGlobalAdapterList,
                          (sizeof(PDEVICE_OBJECT) * adapterTag));

        }

        newAdapterList[adapterTag] = AdapterObject;

        oldAdapterList = ScsiGlobalAdapterList;
        ScsiGlobalAdapterList = newAdapterList;

        if(oldAdapterList != NULL) {
            ExFreePool(oldAdapterList);
        }

    } finally {
        KeReleaseSpinLock(&ScsiGlobalAdapterListSpinLock, oldIrql);
    }

#ifdef ALLOC_PRAGMA
    MmUnlockPagableImageSection(sectionHandle);
    InterlockedDecrement(&SpPAGELOCKLockCount);
#endif

    if(NT_SUCCESS(status)) {

        PADAPTER_EXTENSION adapterExtension = AdapterObject->DeviceExtension;

        //
        // Create the lookaside list for SRB_DATA blobs.  Make sure there's
        // enough space for a small scatter gather list allocated in the
        // structure as well.
        //

        ExInitializeNPagedLookasideList(
            &adapterExtension->SrbDataLookasideList,
            (PALLOCATE_FUNCTION) SpAllocateSrbDataBackend,
            (PFREE_FUNCTION) SpFreeSrbDataBackend,
            0L,
            sizeof(SRB_DATA),
            adapterTag,
            SRB_LIST_DEPTH);

        adapterExtension->SrbDataListInitialized = TRUE;
    }

    return status;
}

#define SP_KEY_VALUE_BUFFER_SIZE  255


NTSTATUS
SpAllocateDriverExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT PSCSIPORT_DRIVER_EXTENSION *DriverExtension
    )

/*++

Routine Description:

    This routine will determine the proper size for the scsiport driver
    extension (based on the number of PnpInterface flags recorded in the
    services key)

--*/

{
    PSCSIPORT_DRIVER_EXTENSION driverExtension = NULL;

    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;

    HANDLE serviceKey = NULL;
    HANDLE parametersKey = NULL;
    HANDLE interfaceKey = NULL;

    STORAGE_BUS_TYPE busType;

    ULONG passes;

    NTSTATUS status;

    PAGED_CODE();

    *DriverExtension = NULL;

    DebugPrint((1, "SpAllocateDriverExtension: Allocating extension for "
                   "driver %wZ\n", &DriverObject->DriverName));

    try {

        //
        // Try to open the services key first
        //

        InitializeObjectAttributes(
            &objectAttributes,
            RegistryPath,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

        status = ZwOpenKey(&serviceKey, KEY_READ, &objectAttributes);

        if(!NT_SUCCESS(status)) {

            DebugPrint((1, "SpAllocateDriverExtension: Unable to open registry "
                           "key %wZ [%#08lx]\n",
                           RegistryPath,
                           status));
            leave;
        }


        //
        // Open the parameters key
        //

        RtlInitUnicodeString(&unicodeString, L"Parameters");

        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   serviceKey,
                                   NULL);

        status = ZwOpenKey(&parametersKey, KEY_READ, &objectAttributes);

        if(!NT_SUCCESS(status)) {

            DebugPrint((1, "SpAllocateDriverExtension: Unable to open "
                           "parameters key of %wZ [%#08lx]\n",
                           RegistryPath,
                           status));
            leave;

        }

        //
        // Try to determine the bus type for this driver.
        //

        RtlInitUnicodeString(&(unicodeString), L"BusType");

        {
            ULONG tmp;
            status = SpReadNumericValue(parametersKey,
                                        NULL,
                                        &unicodeString,
                                        &tmp);
            busType = (STORAGE_BUS_TYPE) tmp;
        }


        if(NT_SUCCESS(status)) {
            switch(busType) {
                case BusTypeScsi:
                case BusTypeAtapi:
                case BusTypeAta:
                case BusTypeSsa:
                case BusTypeFibre:
                case BusTypeRAID: {
                    DebugPrint((1, "SpAllocateDriverExtension: Bus type set to %d\n", busType));
                    break;
                }
                default: {
                    busType = BusTypeScsi;
                    break;
                }
            }
        } else {
            busType = BusTypeScsi;
        }


        //
        // got that one - now open the pnpinterface key.
        //

        RtlInitUnicodeString(&unicodeString, L"PnpInterface");

        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   parametersKey,
                                   NULL);

        status = ZwOpenKey(&interfaceKey, KEY_READ, &objectAttributes);

        if(!NT_SUCCESS(status)) {

            DebugPrint((1, "SpAllocateDriverExtension: Unable to open "
                           "PnpInterface key of %wZ [%#08lx]\n",
                           &RegistryPath,
                           status));
            leave;

        }

        //
        // Now that we have the pnpinterface key open we enumerate the entries in
        // two steps.  The first is to count up the number of entries.  We then
        // allocate an appropriately sized driver object extension, zero it out,
        // and copy the values into the PnpInterface section at the end.
        //

        for(passes = 0; passes < 2; passes++) {

            ULONG count;

            status = STATUS_SUCCESS;

            for(count = 0; TRUE; count++) {

                UCHAR buffer[SP_KEY_VALUE_BUFFER_SIZE];

                PKEY_VALUE_FULL_INFORMATION keyValue =
                    (PKEY_VALUE_FULL_INFORMATION) buffer;

                ULONG resultLength;

                ASSERTMSG("ScsiPort configuration error - possibly too many "
                          "count entries: ",
                          count != MaximumInterfaceType);

                RtlZeroMemory(buffer, sizeof(UCHAR) * SP_KEY_VALUE_BUFFER_SIZE);

                status = ZwEnumerateValueKey(
                            interfaceKey,
                            count,
                            (passes == 0) ? KeyValueBasicInformation :
                                            KeyValueFullInformation,
                            keyValue,
                            sizeof(buffer),
                            &resultLength);

                if(status == STATUS_NO_MORE_ENTRIES) {

                    status = STATUS_SUCCESS;
                    break;

                } else if(!NT_SUCCESS(status)) {

                    DebugPrint((1, "SpAllocateDriverExtension: Fatal error %#08lx "
                                   "enumerating PnpInterface key under %wZ.",
                                status,
                                RegistryPath));

                    leave;
                }

                if(passes == 1) {

                    PSCSIPORT_INTERFACE_TYPE_DATA interface =
                        &(driverExtension->PnpInterface[count]);
                    UNICODE_STRING unicodeString;
                    ULONG t;

                    ASSERTMSG("ScsiPort internal error - too many pnpinterface "
                              "entries on second pass: ",
                              count <= driverExtension->PnpInterfaceCount);

                    //
                    // First turn the name of the entry into a numerical value
                    // so we can match it to an interface type.
                    //

                    RtlInitUnicodeString(&unicodeString, keyValue->Name);

                    if((keyValue->Type != REG_DWORD) &&
                       (keyValue->Type != REG_NONE)) {

                        DbgPrint("SpAllocateDriverExtension: Fatal error parsing "
                                 "PnpInterface under %wZ - entry %wZ is not "
                                 "a REG_DWORD or REG_NONE entry (%d instead)\n",
                                 status,
                                 RegistryPath,
                                 &unicodeString);

                        status = STATUS_DEVICE_CONFIGURATION_ERROR;
                        leave;
                    }

                    status = RtlUnicodeStringToInteger(
                                &unicodeString,
                                0L,
                                &t);

                    if(!NT_SUCCESS(status)) {

                        DbgPrint("SpAllocateDriverExtension: Fatal error %#08lx "
                                 "parsing PnpInterface under %wZ - entry %wZ is "
                                 "not a valid interface type name\n",
                                 status,
                                 RegistryPath,
                                 &unicodeString);

                        leave;
                    }

                    if(t > MaximumInterfaceType) {

                        DbgPrint("SpAllocateDriverExtension: Fatal error "
                                 "parsing PnpInterface under %wZ - entry %wZ is "
                                 "> MaximumInterfaceType (%d)\n",
                                 status,
                                 RegistryPath,
                                 &unicodeString);

                        interface->InterfaceType = InterfaceTypeUndefined;
                        status = STATUS_DEVICE_CONFIGURATION_ERROR;
                        leave;
                    }

                    interface->InterfaceType = (INTERFACE_TYPE) t;

                    if(keyValue->Type == REG_NONE) {

                        interface->Flags = 0L;

                    } else {

                        interface->Flags = *(((PUCHAR) keyValue) +
                                             keyValue->DataOffset);

                        if(interface->Flags & SP_PNP_IS_SAFE) {
                            ASSERT(driverExtension != NULL);
                            driverExtension->SafeInterfaceCount++;
                        }

                        switch(interface->InterfaceType) {
                            case PCIBus: {
                                SET_FLAG(interface->Flags,
                                         SP_PNP_NEEDS_LOCATION);
                                SET_FLAG(interface->Flags,
                                         SP_PNP_INTERRUPT_REQUIRED);

                                CLEAR_FLAG(interface->Flags,
                                           SP_PNP_NON_ENUMERABLE);
                                break;
                            }

                            case Internal:
                            case PNPISABus:
                            case PNPBus:
                            case PCMCIABus: {

                                //
                                // These buses don't ever do detection.
                                //

                                CLEAR_FLAG(interface->Flags,
                                           SP_PNP_NON_ENUMERABLE);
                                break;
                            }

                            default: {

                                //
                                // The other bus types will always do detection
                                // if given the chance.
                                //

                                if(!TEST_FLAG(interface->Flags,
                                              SP_PNP_NO_LEGACY_DETECTION)) {
                                    SET_FLAG(interface->Flags,
                                             SP_PNP_NON_ENUMERABLE);
                                }

                                break;
                            }
                        }
                    }

                    DebugPrint((1, "SpAllocateDriverExtension: Interface %d has "
                                   "flags %#08lx\n",
                                interface->InterfaceType,
                                interface->Flags));

                }
            }

            if(passes == 0) {

                ULONG extensionSize;

                //
                // We know how much extra space we need so go ahead and allocate
                // the extension.
                //

                DebugPrint((2, "SpAllocateDriverExtension: Driver has %d interface "
                               "entries\n",
                            count));

                extensionSize = sizeof(SCSIPORT_DRIVER_EXTENSION) +
                                (sizeof(SCSIPORT_INTERFACE_TYPE_DATA) * count);

                DebugPrint((2, "SpAllocateDriverExtension: Driver extension will "
                               "be %d bytes\n",
                            extensionSize));

                status = IoAllocateDriverObjectExtension(DriverObject,
                                                         ScsiPortInitialize,
                                                         extensionSize,
                                                         &driverExtension);

                if(!NT_SUCCESS(status)) {
                    DebugPrint((1, "SpAllocateDriverExtension: Fatal error %#08lx "
                                   "allocating driver extension\n", status));
                    leave;
                }

                RtlZeroMemory(driverExtension, extensionSize);

                driverExtension->PnpInterfaceCount = count;
            }
        }

        ASSERTMSG("ScsiPortAllocateDriverExtension internal error: left first "
                  "section with non-success status: ",
                  NT_SUCCESS(status));

    } finally {

        //
        // If the driver extension has not been allocated then go ahead and
        // do that here.
        //

        if(driverExtension == NULL) {

            DebugPrint((1, "SpAllocateDriverExtension: Driver has 0 interface "
                           "entries\n"));

            DebugPrint((2, "SpAllocateDriverExtension: Driver extension will "
                           "be %d bytes\n",
                        sizeof(SCSIPORT_DRIVER_EXTENSION)));

            status = IoAllocateDriverObjectExtension(DriverObject,
                                                     ScsiPortInitialize,
                                                     sizeof(SCSIPORT_DRIVER_EXTENSION),
                                                     &driverExtension);

            if(!NT_SUCCESS(status)) {
                DebugPrint((1, "SpAllocateDriverExtension: Fatal error %#08lx "
                               "allocating driver extension\n", status));

                goto Finally_Cleanup;
            }

            RtlZeroMemory(driverExtension, sizeof(SCSIPORT_DRIVER_EXTENSION));

        } else {

            driverExtension->BusType = busType;

        }

        status = STATUS_SUCCESS;
Finally_Cleanup:;
    }

    if (status != STATUS_SUCCESS)
        goto Cleanup;

    //
    // initialize the remaining fields in the driver object extension.
    //

    driverExtension->ReserveAllocFailureLogEntry = SpAllocateErrorLogEntry(DriverObject);

    driverExtension->UnusedPage = NULL;

    driverExtension->UnusedPageMdl = NULL;

    driverExtension->InvalidPage = NULL;

    driverExtension->DriverObject = DriverObject;

    driverExtension->RegistryPath = *RegistryPath;

    driverExtension->RegistryPath.MaximumLength += sizeof(WCHAR);

    driverExtension->RegistryPath.Buffer =
        SpAllocatePool(PagedPool,
                       driverExtension->RegistryPath.MaximumLength,
                       SCSIPORT_TAG_REGISTRY,
                       DriverObject);

    if(driverExtension->RegistryPath.Buffer == NULL) {

        DebugPrint((1, "SpAllocateDriverExtension: Fatal error "
                       "allocating copy of registry path\n"));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyUnicodeString(&(driverExtension->RegistryPath),
                         RegistryPath);

    //
    // Now get the values of the LegacyAdapterDetection flags.
    //

    //
    // Set it to a good default value in case we error out getting the flags
    //

    if(ScsiPortLegacyAdapterDetection) {

        //
        // Global flag breaks scissors
        //

        driverExtension->LegacyAdapterDetection = TRUE;

    } else {

        if(parametersKey != NULL) {

            UNICODE_STRING valueName;
            UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
            PKEY_VALUE_PARTIAL_INFORMATION keyValueInformation =
                (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
            ULONG length;

            RtlInitUnicodeString(&valueName, L"LegacyAdapterDetection");

            status = ZwQueryValueKey(parametersKey,
                                     &valueName,
                                     KeyValuePartialInformation,
                                     keyValueInformation,
                                     sizeof(buffer),
                                     &length);

            if(NT_SUCCESS(status) &&
               (length >= sizeof(KEY_VALUE_PARTIAL_INFORMATION)) &&
               (keyValueInformation->Type == REG_DWORD)) {

                ULONG data = *((PULONG) keyValueInformation->Data);

                driverExtension->LegacyAdapterDetection = (data == 1);

                //
                // Rewrite a zero in to the value.
                //

                data = 0;

                status = ZwSetValueKey(parametersKey,
                                       &valueName,
                                       keyValueInformation->TitleIndex,
                                       REG_DWORD,
                                       &data,
                                       sizeof(data));

                if(!NT_SUCCESS(status)) {
                    DebugPrint((1, "SpAllocateDriverExtension: Error %#08lx "
                                   "setting LegacyAdapterDetection value to "
                                   "zero\n", status));
                    status = STATUS_SUCCESS;
                }

            } else {
                driverExtension->LegacyAdapterDetection = FALSE;
            }
        }

        if(driverExtension->LegacyAdapterDetection == FALSE) {

            UNICODE_STRING unicodeKeyName;
            UNICODE_STRING unicodeClassGuid;

            HANDLE controlClassKey = NULL;
            HANDLE scsiAdapterKey = NULL;

            RtlInitUnicodeString(&unicodeClassGuid, NULL);

            //
            // Miniport doesn't want to do detection.  Check to see if the
            // global port driver flag has been switched on.
            //

            RtlInitUnicodeString(
                &unicodeString,
                L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class");

            RtlZeroMemory(&objectAttributes, sizeof(OBJECT_ATTRIBUTES));

            InitializeObjectAttributes(
                &objectAttributes,
                &unicodeString,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            try {

                status = ZwOpenKey(&controlClassKey,
                                   KEY_READ,
                                   &objectAttributes);

                if(!NT_SUCCESS(status)) {

                    DebugPrint((1, "SpAllocateDriverExtension: Error %#08lx "
                                   "opening key %wZ\n",
                                status,
                                &unicodeString));

                    leave;
                }

                //
                // Now open up the GUID key for our device.
                //

                status = RtlStringFromGUID(&GUID_DEVCLASS_SCSIADAPTER,
                                           &unicodeClassGuid);

                if(!NT_SUCCESS(status)) {

                    DebugPrint((1, "SpAllocateDriverExtension: Error %#08lx "
                                   "converting GUID to unicode string\n",
                                status));
                    leave;
                }

                RtlZeroMemory(&objectAttributes, sizeof(OBJECT_ATTRIBUTES));
                InitializeObjectAttributes(&objectAttributes,
                                           &unicodeClassGuid,
                                           OBJ_CASE_INSENSITIVE,
                                           controlClassKey,
                                           NULL);

                status = ZwOpenKey(&scsiAdapterKey,
                                   KEY_READ,
                                   &objectAttributes);

                if(!NT_SUCCESS(status)) {

                    DebugPrint((1, "SpAllocateDriverExtension: Error %#08lx "
                                   "opening class key %wZ\n",
                                status,
                                &unicodeClassGuid));

                    leave;

                } else {

                    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                                 sizeof(ULONG)];
                    PKEY_VALUE_PARTIAL_INFORMATION keyInfo =
                        (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
                    ULONG infoLength;

                    RtlInitUnicodeString(&unicodeString,
                                         L"LegacyAdapterDetection");

                    status = ZwQueryValueKey(scsiAdapterKey,
                                             &unicodeString,
                                             KeyValuePartialInformation,
                                             keyInfo,
                                             sizeof(buffer),
                                             &infoLength);

                    if(!NT_SUCCESS(status)) {

                        DebugPrint((2, "SpAllocateDriverExtension: Error "
                                       "%#08lx reading key %wZ\n",
                                    status,
                                    &unicodeString));

                        status = STATUS_SUCCESS;
                        leave;
                    }

                    if(*((PULONG) keyInfo->Data) == 0) {
                        driverExtension->LegacyAdapterDetection = FALSE;
                    } else {
                        driverExtension->LegacyAdapterDetection = TRUE;
                    }
                }

            } finally {

                if(controlClassKey != NULL) {
                    ZwClose(controlClassKey);
                }

                if(scsiAdapterKey != NULL) {
                    ZwClose(scsiAdapterKey);
                }

                RtlFreeUnicodeString(&unicodeClassGuid);

            }
        }

        status = STATUS_SUCCESS;
    }

Cleanup:

    //
    // If we got out of everything above and didn't allocate a driver
    // extension then

    if(serviceKey) {
        ZwClose(serviceKey);
    }

    if(parametersKey) {
        ZwClose(parametersKey);
    }

    if(interfaceKey) {
        ZwClose(interfaceKey);
    }

    if(NT_SUCCESS(status)) {
        *DriverExtension = driverExtension;
    }

    return status;
}

extern ULONG ScsiPortVerifierInitialized;

NTSTATUS DllInitialize(
    IN PUNICODE_STRING RegistryPath
    )
{
    HANDLE VerifierKey;
    UNICODE_STRING Name;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    ULONG ResultLength;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;

    //
    // Check the verification level first; someone may have poked the value
    // from the debugger to prevent us from doing any verifier initialization.
    //

    if (SpVrfyLevel == SP_VRFY_NONE) {
        return STATUS_SUCCESS;
    }

    //
    // Read the global verification level from the registry.  If the value is
    // not present or if the value indicates 'no verification', we don't want
    // to do any verifier initialization at all.
    //

    RtlInitUnicodeString(&Name, SCSIPORT_CONTROL_KEY SCSIPORT_VERIFIER_KEY);

    InitializeObjectAttributes(&ObjectAttributes,
                               &Name,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&VerifierKey, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS(Status)) {

        RtlInitUnicodeString(&Name, L"VerifyLevel");
        Status = ZwQueryValueKey(VerifierKey,
                                 &Name,
                                 KeyValuePartialInformation,
                                 ValueInfo,
                                 sizeof(buffer),
                                 &ResultLength);

        if (NT_SUCCESS(Status)) {

            if (ValueInfo->Type == REG_DWORD) {

                if (ResultLength >= sizeof(ULONG)) {

                    SpVrfyLevel |= ((PULONG)(ValueInfo->Data))[0];

                    if (SpVrfyLevel != SP_VRFY_NONE &&
                        ScsiPortVerifierInitialized == 0) {

                        //
                        // Ok, we found a verifier level and it did not tell us
                        // not to verify.  Go ahead and initialize scsiport's
                        // verifier.
                        //

                        if (SpVerifierInitialization()) {
                            ScsiPortVerifierInitialized = 1;
                        }
                    }
                }
            }
        }

        ZwClose(VerifierKey);
    }

    return STATUS_SUCCESS;
}
VOID
SpInitializePowerParams(
    IN PADAPTER_EXTENSION AdapterExtension
    )

/*++

Routine Description:

    This routine initializes per-adapter power parameters.

Arguments:

    Adapter - Points to an adapter extension.

Return Value:

Notes:

--*/

{
    NTSTATUS status;
    ULONG needsShutdown;

    PAGED_CODE();

    //
    // If this is not a pnp device, don't attempt to read registry info.
    //

    if (AdapterExtension->IsPnp == FALSE) {
        AdapterExtension->NeedsShutdown = FALSE;
        return;
    }

    status = SpReadNumericInstanceValue(AdapterExtension->LowerPdo,
                                        L"NeedsSystemShutdownNotification",
                                        &needsShutdown);

    if (!NT_SUCCESS(status)) {
        AdapterExtension->NeedsShutdown = 0;
    } else {
        AdapterExtension->NeedsShutdown = (needsShutdown == 0) ? FALSE : TRUE; 
    }
}

VOID
SpInitializePerformanceParams(
    IN PADAPTER_EXTENSION AdapterExtension
    )

/*++

Routine Description:

    This routine initializes per-adapter tunable performance parameters.

Arguments:

    Adapter - Points to an adapter extension.

Return Value:

Notes:

--*/

{
    NTSTATUS status;
    ULONG remainInReducedMaxQueueState;

    PAGED_CODE();

    //
    // If this isn't a pnp device, don't attempt to get parameters.
    //

    if (AdapterExtension->IsPnp == FALSE) {
        AdapterExtension->RemainInReducedMaxQueueState = 0xffffffff;
        return;
    }

    status = SpReadNumericInstanceValue(AdapterExtension->LowerPdo,
                                        L"RemainInReducedMaxQueueState",
                                        &remainInReducedMaxQueueState);

    if (!NT_SUCCESS(status)) {
        AdapterExtension->RemainInReducedMaxQueueState = 0xffffffff;
    } else {
        AdapterExtension->RemainInReducedMaxQueueState = remainInReducedMaxQueueState;
    }
}

VOID
SpInitializeRequestSenseParams(
    IN PADAPTER_EXTENSION AdapterExtension
    )

/*++

Routine Description:

    This routine returns the number of additonal sense bytes supported
    by the specified adapter.  By default, an adapter will support
    zero additional sense bytes.  The default is overridden by
    specifying an alternative via the registry.

Arguments:

    Adapter - Points to an adapter extension.

Return Value:

Notes:

--*/

{
    NTSTATUS status;
    ULONG TotalSenseDataBytes;
    ULONG RequestSenseTimeout;

    PAGED_CODE();

    //
    // If this isn't a pnp device, don't attempt to determine
    // if it supports additional sense data.
    //

    if (AdapterExtension->IsPnp == FALSE) {
        AdapterExtension->AdditionalSenseBytes = 0;
        AdapterExtension->RequestSenseTimeout = 2;
        return;
    }

    status = SpReadNumericInstanceValue(AdapterExtension->LowerPdo,
                                        L"TotalSenseDataBytes",
                                        &TotalSenseDataBytes);
    if (!NT_SUCCESS(status)) {

        //
        // Value is absent.  No additional sense bytes.
        //

        AdapterExtension->AdditionalSenseBytes = 0;

    } else {

        //
        // The acceptable range of values is [18..255].
        //

        if (TotalSenseDataBytes <= SENSE_BUFFER_SIZE) {
            AdapterExtension->AdditionalSenseBytes = 0;
        } else if (TotalSenseDataBytes >= MAX_SENSE_BUFFER_SIZE) {
            AdapterExtension->AdditionalSenseBytes = MAX_ADDITIONAL_SENSE_BYTES;
        } else {

            //
            // The value in the registry is valid.  The number of additional
            // sense bytes is TotalSize - StandardSize.
            //

            AdapterExtension->AdditionalSenseBytes =
                (UCHAR)(TotalSenseDataBytes - SENSE_BUFFER_SIZE);
        }
    }

    status = SpReadNumericInstanceValue(AdapterExtension->LowerPdo,
                                        L"RequestSenseTimeout",
                                        &RequestSenseTimeout);
    if (!NT_SUCCESS(status)) {

        //
        // Value is absent.  Use the default request sense timeout of 2 seconds.
        //

        AdapterExtension->RequestSenseTimeout = 2;

    } else {

        AdapterExtension->RequestSenseTimeout = (UCHAR) RequestSenseTimeout;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\dispatch.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1998

Module Name:

    pnp.c

Abstract:

    This is the NT SCSI port driver.  This file contains the self-contained plug
    and play code.

Authors:

    Peter Wieland

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include "port.h"

#if DBG
static const char *__file__ = __FILE__;
#endif

PDRIVER_DISPATCH AdapterMajorFunctionTable[IRP_MJ_MAXIMUM_FUNCTION + 1];
PDRIVER_DISPATCH DeviceMajorFunctionTable[IRP_MJ_MAXIMUM_FUNCTION + 1];
PDRIVER_DISPATCH Scsi1DeviceMajorFunctionTable[IRP_MJ_MAXIMUM_FUNCTION + 1];

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ScsiPortInitializeDispatchTables)
#endif

NTSTATUS
ScsiPortDispatchUnimplemented(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
//
// Routines start
//


VOID
ScsiPortInitializeDispatchTables(
    VOID
    )

{
    ULONG i;

    //
    // Initialize the PDO dispatch table
    //

    for(i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DeviceMajorFunctionTable[i] = ScsiPortDispatchUnimplemented;
    }

    DeviceMajorFunctionTable[IRP_MJ_DEVICE_CONTROL] = ScsiPortPdoDeviceControl;
    Scsi1DeviceMajorFunctionTable[IRP_MJ_DEVICE_CONTROL] = ScsiPortPdoDeviceControl;
    
    DeviceMajorFunctionTable[IRP_MJ_SCSI] = ScsiPortPdoScsi;
    Scsi1DeviceMajorFunctionTable[IRP_MJ_SCSI] = ScsiPortScsi1PdoScsi;
    
    DeviceMajorFunctionTable[IRP_MJ_PNP] = ScsiPortPdoPnp;
    Scsi1DeviceMajorFunctionTable[IRP_MJ_PNP] = ScsiPortPdoPnp;
    
    DeviceMajorFunctionTable[IRP_MJ_CREATE] = ScsiPortPdoCreateClose;
    Scsi1DeviceMajorFunctionTable[IRP_MJ_CREATE] = ScsiPortPdoCreateClose;
    
    DeviceMajorFunctionTable[IRP_MJ_CLOSE] = ScsiPortPdoCreateClose;
    Scsi1DeviceMajorFunctionTable[IRP_MJ_CLOSE] = ScsiPortPdoCreateClose;
    
    DeviceMajorFunctionTable[IRP_MJ_SYSTEM_CONTROL] = ScsiPortSystemControlIrp;
    Scsi1DeviceMajorFunctionTable[IRP_MJ_SYSTEM_CONTROL] = ScsiPortSystemControlIrp;
    
    DeviceMajorFunctionTable[IRP_MJ_POWER] = ScsiPortDispatchPower;
    Scsi1DeviceMajorFunctionTable[IRP_MJ_POWER] = ScsiPortDispatchPower;

    //
    // Initialize the adapter dispatch table
    //

    for(i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        AdapterMajorFunctionTable[i] = ScsiPortDispatchUnimplemented;
    }

    AdapterMajorFunctionTable[IRP_MJ_DEVICE_CONTROL] = ScsiPortFdoDeviceControl;
    AdapterMajorFunctionTable[IRP_MJ_SCSI] = ScsiPortFdoDispatch;
    AdapterMajorFunctionTable[IRP_MJ_PNP] = ScsiPortFdoPnp;
    AdapterMajorFunctionTable[IRP_MJ_CREATE] = ScsiPortFdoCreateClose;
    AdapterMajorFunctionTable[IRP_MJ_CLOSE] = ScsiPortFdoCreateClose;
    AdapterMajorFunctionTable[IRP_MJ_SYSTEM_CONTROL] = ScsiPortSystemControlIrp;
    AdapterMajorFunctionTable[IRP_MJ_POWER] = ScsiPortDispatchPower;

    return;
}


NTSTATUS
ScsiPortGlobalDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    return (commonExtension->MajorFunction[irpStack->MajorFunction])(DeviceObject, Irp);

}

NTSTATUS
ScsiPortDispatchUnimplemented(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PCOMMON_EXTENSION commonExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG isRemoved;

    isRemoved = SpAcquireRemoveLock(DeviceObject, Irp);
    if(isRemoved) {
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        SpReleaseRemoveLock(DeviceObject, Irp);
        SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    commonExtension = DeviceObject->DeviceExtension;

    DebugPrint((1, "ScsiPortDispatchUnimplemented: request %#p\n", Irp));
    DebugPrint((1, "/t/tFunction Code (%d, %d)\n",
                   irpStack->MajorFunction,
                   irpStack->MinorFunction));
    DebugPrint((1, "/t/tFor %s %#p\n",
                   (commonExtension->IsPdo ? "PDO" : "FDO"),
                   DeviceObject));

    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

    SpReleaseRemoveLock(DeviceObject, Irp);
    SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);

    return STATUS_INVALID_DEVICE_REQUEST;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\map.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    map.c

Abstract:

    This module contains routines for maintaining the SCSI device map in the
    registry.

Authors:

    Peter Wieland

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "port.h"

#define __FILE_ID__ 'map '

HANDLE ScsiDeviceMapKey = (HANDLE) -1;

VOID
SpDeleteLogicalUnitDeviceMapEntry(
    PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

VOID
SpDeleteAdapterDeviceMap(
    PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpBuildAdapterDeviceMap(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpBuildLogicalUnitDeviceMapEntry(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

NTSTATUS
SpCreateNumericKey(
    IN HANDLE Root,
    IN ULONG Name,
    IN PWSTR Prefix,
    IN BOOLEAN Create,
    OUT PHANDLE NewKey,
    OUT PULONG Disposition
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, SpInitDeviceMap)

#pragma alloc_text(PAGE, SpBuildDeviceMapEntry)
#pragma alloc_text(PAGE, SpBuildAdapterDeviceMap)
#pragma alloc_text(PAGE, SpBuildLogicalUnitDeviceMapEntry)

#pragma alloc_text(PAGE, SpDeleteLogicalUnitDeviceMapEntry)
#pragma alloc_text(PAGE, SpDeleteAdapterDeviceMap)

#pragma alloc_text(PAGE, SpUpdateLogicalUnitDeviceMapEntry)

#pragma alloc_text(PAGE, SpCreateNumericKey)
#endif


NTSTATUS
SpInitDeviceMap(
    VOID
    )

/*++

Routine Description:

Arguments:

Return Value:

    status

--*/

{
    UNICODE_STRING name;

    OBJECT_ATTRIBUTES objectAttributes;

    HANDLE mapKey;

    ULONG disposition;

    ULONG i;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Open the SCSI key in the device map.
    //

    RtlInitUnicodeString(&name,
                         L"\\Registry\\Machine\\Hardware\\DeviceMap\\Scsi");

    InitializeObjectAttributes(&objectAttributes,
                               &name,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    //
    // Create or open the key.
    //

    status = ZwCreateKey(&mapKey,
                         KEY_READ | KEY_WRITE,
                         &objectAttributes,
                         0,
                         (PUNICODE_STRING) NULL,
                         REG_OPTION_VOLATILE,
                         &disposition);

    if(NT_SUCCESS(status)) {
        ScsiDeviceMapKey = mapKey;
    } else {
        ScsiDeviceMapKey = NULL;
    }

    return status;
}


NTSTATUS
SpBuildDeviceMapEntry(
    IN PCOMMON_EXTENSION CommonExtension
    )

/*++

Routine Description:

    This routine will make an entry for the specified adapter or logical
    unit in the SCSI device map in the registry.  This table is maintained for
    debugging and legacy use.

    A handle to the device map key for this device will be stored in the
    common device extension.  This handle should only be used within the
    context of a system thread.

Arguments:

    Extension - the object we are adding to the device map.

Return Value:

    status

--*/

{
    PAGED_CODE();

    if(CommonExtension->IsPdo) {
        return SpBuildLogicalUnitDeviceMapEntry((PLOGICAL_UNIT_EXTENSION) CommonExtension);
    } else {
        return SpBuildAdapterDeviceMap((PADAPTER_EXTENSION) CommonExtension);
    }
}


NTSTATUS
SpBuildLogicalUnitDeviceMapEntry(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    PADAPTER_EXTENSION adapter = LogicalUnit->AdapterExtension;

    HANDLE busKey;

    PCWSTR typeString;
    ANSI_STRING ansiString;

    UNICODE_STRING name;
    UNICODE_STRING unicodeString;

    ULONG disposition;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(LogicalUnit->IsTemporary == FALSE);

    DebugPrint((1, "SpBuildDeviceMapEntry: Building map entry for lun %p\n",
                   LogicalUnit));

    if(adapter->BusDeviceMapKeys == NULL) {

        //
        // We don't have keys built for the buses yet.  Bail out.
        //

        return STATUS_UNSUCCESSFUL;
    }

    //
    // If we already have a target or LUN key for this device then we're done.
    //

    if((LogicalUnit->TargetDeviceMapKey != NULL) &&
       (LogicalUnit->LunDeviceMapKey != NULL)) {

        return STATUS_SUCCESS;
    }

    busKey = adapter->BusDeviceMapKeys[LogicalUnit->PathId].BusKey;

    //
    // Create a key for the target
    //

    status = SpCreateNumericKey(busKey,
                                LogicalUnit->TargetId,
                                L"Target Id ",
                                TRUE,
                                &(LogicalUnit->TargetDeviceMapKey),
                                &disposition);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Create the LUN entry
    //

    status = SpCreateNumericKey(LogicalUnit->TargetDeviceMapKey,
                                LogicalUnit->Lun,
                                L"Logical Unit Id ",
                                TRUE,
                                &(LogicalUnit->LunDeviceMapKey),
                                &disposition);

    if(!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Create the identifier value
    //

    RtlInitUnicodeString(&name, L"Identifier");

    //
    // Get the identifier from the inquiry data
    //

    ansiString.MaximumLength = 28;
    ansiString.Length = 28;
    ansiString.Buffer = LogicalUnit->InquiryData.VendorId;

    status = RtlAnsiStringToUnicodeString(&unicodeString,
                                          &ansiString,
                                          TRUE);

    if(NT_SUCCESS(status)) {

        status = ZwSetValueKey(LogicalUnit->LunDeviceMapKey,
                               &name,
                               0,
                               REG_SZ,
                               unicodeString.Buffer,
                               unicodeString.Length + sizeof(WCHAR));

        RtlFreeUnicodeString(&unicodeString);
    }

    //
    // Determine the peripheral type
    //

    typeString =
        SpGetDeviceTypeInfo(LogicalUnit->InquiryData.DeviceType)->DeviceMapString;

    //
    // Set type value.
    //

    RtlInitUnicodeString(&name, L"Type");

    status = ZwSetValueKey(LogicalUnit->LunDeviceMapKey,
                           &name,
                           0,
                           REG_SZ,
                           (PVOID) typeString,
                           (wcslen(typeString) + 1) * sizeof(WCHAR));

    //
    // Write the inquiry data into the device map for debugging purposes
    //

    RtlInitUnicodeString(&name, L"InquiryData");

    status = ZwSetValueKey(LogicalUnit->LunDeviceMapKey,
                           &name,
                           0,
                           REG_BINARY,
                           &(LogicalUnit->InquiryData),
                           INQUIRYDATABUFFERSIZE);

    //
    // Convert the serial number into unicode and write it out to the
    // registry.
    //

    //
    // Get the identifier from the inquiry data
    //

    if(LogicalUnit->SerialNumber.Length != 0) {
        RtlInitUnicodeString(&name, L"SerialNumber");

        status = RtlAnsiStringToUnicodeString(
                    &unicodeString,
                    &(LogicalUnit->SerialNumber),
                    TRUE);

        if(NT_SUCCESS(status)) {

            status = ZwSetValueKey(LogicalUnit->LunDeviceMapKey,
                                   &name,
                                   0,
                                   REG_SZ,
                                   unicodeString.Buffer,
                                   unicodeString.Length + sizeof(WCHAR));

            RtlFreeUnicodeString(&unicodeString);
        }
    }

    //
    // If the device identifier page exists then write it out to the registry
    //

    if(LogicalUnit->DeviceIdentifierPage != NULL) {
        RtlInitUnicodeString(&name, L"DeviceIdentifierPage");

        status = ZwSetValueKey(LogicalUnit->LunDeviceMapKey,
                               &name,
                               0,
                               REG_BINARY,
                               LogicalUnit->DeviceIdentifierPage,
                               LogicalUnit->DeviceIdentifierPageLength);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SpBuildAdapterDeviceMap(
    IN PADAPTER_EXTENSION Adapter
    )
{
    PSCSIPORT_DRIVER_EXTENSION driverExtension;
    HANDLE mapKey;

    UNICODE_STRING name;

    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    ULONG i;

    NTSTATUS status;

    PUNICODE_STRING servicePath;

    ULONG busNumber;

    PAGED_CODE();

    //
    // Grab the handle to the SCSI device map out of the driver extension.
    //

    driverExtension = IoGetDriverObjectExtension(
                            Adapter->DeviceObject->DriverObject,
                            ScsiPortInitialize);

    ASSERT(driverExtension != NULL);

    mapKey = ScsiDeviceMapKey;

    if(mapKey == NULL) {

        //
        // For some reason we were unable to create the root of the device map
        // during scsiport initialization.
        //

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Create a key beneath this for the port device
    //

    status = SpCreateNumericKey(mapKey,
                                Adapter->PortNumber,
                                L"Scsi Port ",
                                TRUE,
                                &(Adapter->PortDeviceMapKey),
                                &disposition);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Indicate if it's a PCCARD
    //

    if(RtlEqualMemory(&GUID_BUS_TYPE_PCMCIA,
                      &(Adapter->BusTypeGuid),
                      sizeof(GUID))) {

        RtlInitUnicodeString(&name, L"PCCARD");

        i = 1;

        status = ZwSetValueKey(Adapter->PortDeviceMapKey,
                               &name,
                               0,
                               REG_DWORD,
                               &i,
                               sizeof(ULONG));
    }

    //
    // Set the interrupt value
    //

    if(Adapter->InterruptLevel) {
        RtlInitUnicodeString(&name, L"Interrupt");

        i = Adapter->InterruptLevel;

        status = ZwSetValueKey(Adapter->PortDeviceMapKey,
                               &name,
                               0,
                               REG_DWORD,
                               &i,
                               sizeof(ULONG));
    }

    //
    // Set the base I/O address value
    //

    if(Adapter->IoAddress) {

        RtlInitUnicodeString(&name, L"IOAddress");

        i = Adapter->IoAddress;

        status = ZwSetValueKey(Adapter->PortDeviceMapKey,
                               &name,
                               0,
                               REG_DWORD,
                               &i,
                               sizeof(ULONG));

    }

    if(Adapter->Dma64BitAddresses) {
        RtlInitUnicodeString(&name, L"Dma64BitAddresses");
        i = 0x1;
        status = ZwSetValueKey(Adapter->PortDeviceMapKey,
                               &name,
                               0,
                               REG_DWORD,
                               &i,
                               sizeof(ULONG));
    }

    servicePath = &driverExtension->RegistryPath;

    ASSERT(servicePath != NULL);

    //
    // Add identifier value.  This value is equal to the name of the driver
    // in the service key.  Note the service key name is not NULL terminated
    //

    {
        PWSTR start;
        WCHAR buffer[32];

        RtlInitUnicodeString(&name, L"Driver");

        //
        // Get the name of the driver from the service key name.
        //

        start = (PWSTR) ((PCHAR) servicePath->Buffer + servicePath->Length);

        start--;

        while(*start != L'\\' && start > servicePath->Buffer) {
            start--;
        }

        if(*start == L'\\') {
            start++;

            for(i = 0; i < 31; i++) {
                buffer[i] = *start++;

                if(start >= (servicePath->Buffer +
                             (servicePath->Length / sizeof(WCHAR)))) {
                    break;
                }
            }

            i++;

            buffer[i] = L'\0';

            status = ZwSetValueKey(Adapter->PortDeviceMapKey,
                                   &name,
                                   0,
                                   REG_SZ,
                                   buffer,
                                   (i + 1) * sizeof(WCHAR));

        }
    }

    //
    // Allocate storage for all the bus handles.
    //

    Adapter->BusDeviceMapKeys = SpAllocatePool(
                                    PagedPool,
                                    (sizeof(DEVICE_MAP_HANDLES) *
                                     Adapter->NumberOfBuses),
                                    SCSIPORT_TAG_DEVICE_MAP,
                                    Adapter->DeviceObject->DriverObject);

    if(Adapter->BusDeviceMapKeys == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(Adapter->BusDeviceMapKeys,
                  (sizeof(DEVICE_MAP_HANDLES) * Adapter->NumberOfBuses));

    //
    // Create a key for each bus.  In each bus key create an empty key
    // the initiator.
    //

    for(busNumber = 0;
        busNumber < Adapter->NumberOfBuses;
        busNumber++) {

        PDEVICE_MAP_HANDLES busKeys;

        HANDLE busKey;
        HANDLE targetKey;

        busKeys = &(Adapter->BusDeviceMapKeys[busNumber]);

        //
        // Create a key entry for the bus.
        //

        status = SpCreateNumericKey(
                    Adapter->PortDeviceMapKey,
                    busNumber,
                    L"Scsi Bus ",
                    TRUE,
                    &(busKeys->BusKey),
                    &disposition);

        if(!NT_SUCCESS(status)) {
            continue;
        }

        //
        // Now create a key for the initiator.
        //

        i = Adapter->PortConfig->InitiatorBusId[busNumber];

        status = SpCreateNumericKey(busKeys->BusKey,
                                    i,
                                    L"Initiator Id ",
                                    TRUE,
                                    &(busKeys->InitiatorKey),
                                    &disposition);

        if(!NT_SUCCESS(status)) {
            continue;
        }
    }

    return STATUS_SUCCESS;
}


VOID
SpDeleteDeviceMapEntry(
    IN PCOMMON_EXTENSION CommonExtension
    )
{
    if(CommonExtension->IsPdo) {
        SpDeleteLogicalUnitDeviceMapEntry((PLOGICAL_UNIT_EXTENSION) CommonExtension);
    } else {
        SpDeleteAdapterDeviceMap((PADAPTER_EXTENSION) CommonExtension);
    }
    return;
}


VOID
SpDeleteLogicalUnitDeviceMapEntry(
    PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    if(LogicalUnit->LunDeviceMapKey != NULL) {
        ASSERT(LogicalUnit->IsTemporary == FALSE);

        ZwDeleteKey(LogicalUnit->LunDeviceMapKey);
        ZwClose(LogicalUnit->LunDeviceMapKey);
        LogicalUnit->LunDeviceMapKey = NULL;
    }

    if(LogicalUnit->TargetDeviceMapKey != NULL) {
        ASSERT(LogicalUnit->IsTemporary == FALSE);

        ZwDeleteKey(LogicalUnit->TargetDeviceMapKey);
        ZwClose(LogicalUnit->TargetDeviceMapKey);
        LogicalUnit->TargetDeviceMapKey = NULL;
    }

    return;
}


VOID
SpDeleteAdapterDeviceMap(
    PADAPTER_EXTENSION Adapter
    )
{

    if(Adapter->BusDeviceMapKeys != NULL) {

        ULONG busNumber;

        //
        // for each bus on the adapter.
        //

        for(busNumber = 0; busNumber < Adapter->NumberOfBuses; busNumber++) {

            PDEVICE_MAP_HANDLES busKeys;

            busKeys = &(Adapter->BusDeviceMapKeys[busNumber]);

            //
            // Attempt to delete the key for the initiator if it was created.
            //

            if(busKeys->InitiatorKey != NULL) {
                ZwDeleteKey(busKeys->InitiatorKey);
                ZwClose(busKeys->InitiatorKey);
            }

            //
            // Attempt to delete the key for the bus if it was created.
            //

            if(busKeys->BusKey != NULL) {
                ZwDeleteKey(busKeys->BusKey);
                ZwClose(busKeys->BusKey);
            }
        }

        ExFreePool(Adapter->BusDeviceMapKeys);
        Adapter->BusDeviceMapKeys = NULL;
    }

    //
    // Attempt to delete the key for the adapter if it was created.
    //

    if(Adapter->PortDeviceMapKey != NULL) {
        ZwDeleteKey(Adapter->PortDeviceMapKey);
        ZwClose(Adapter->PortDeviceMapKey);
        Adapter->PortDeviceMapKey = NULL;
    }

    return;
}


NTSTATUS
SpCreateNumericKey(
    IN HANDLE Root,
    IN ULONG Name,
    IN PWSTR Prefix,
    IN BOOLEAN Create,
    OUT PHANDLE NewKey,
    OUT PULONG Disposition
    )

/*++

Routine Description:

    This function creates a registry key.  The name of the key is a string
    version of numeric value passed in.

Arguments:

    RootKey - Supplies a handle to the key where the new key should be inserted.

    Name - Supplies the numeric value to name the key.

    Prefix - Supplies a prefix name to add to name.

    Create - if TRUE the key will be created if it does not already exist.

    NewKey - Returns the handle for the new key.

    Disposition - the disposition value set by ZwCreateKey.

Return Value:

   Returns the status of the operation.

--*/

{
    UNICODE_STRING string;
    UNICODE_STRING stringNum;
    OBJECT_ATTRIBUTES objectAttributes;
    WCHAR bufferNum[16];
    WCHAR buffer[64];
    NTSTATUS status;

    PAGED_CODE();

    //
    // Copy the Prefix into a string.
    //

    string.Length = 0;
    string.MaximumLength=64;
    string.Buffer = buffer;

    RtlInitUnicodeString(&stringNum, Prefix);

    RtlCopyUnicodeString(&string, &stringNum);

    //
    // Create a port number key entry.
    //

    stringNum.Length = 0;
    stringNum.MaximumLength = 16;
    stringNum.Buffer = bufferNum;

    status = RtlIntegerToUnicodeString(Name, 10, &stringNum);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Append the prefix and the numeric name.
    //

    RtlAppendUnicodeStringToString(&string, &stringNum);

    InitializeObjectAttributes( &objectAttributes,
                                &string,
                                OBJ_CASE_INSENSITIVE,
                                Root,
                                (PSECURITY_DESCRIPTOR) NULL );

    if(Create) {
        status = ZwCreateKey(NewKey,
                            KEY_READ | KEY_WRITE,
                            &objectAttributes,
                            0,
                            (PUNICODE_STRING) NULL,
                            REG_OPTION_VOLATILE,
                            Disposition );
    } else {

        status = ZwOpenKey(NewKey,
                           KEY_READ | KEY_WRITE,
                           &objectAttributes);

        *Disposition = REG_OPENED_EXISTING_KEY;
    }

    return(status);
}


NTSTATUS
SpUpdateLogicalUnitDeviceMapEntry(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    UNICODE_STRING name;

    PAGED_CODE();

    if((LogicalUnit->TargetDeviceMapKey == NULL) ||
       (LogicalUnit->LunDeviceMapKey == NULL)) {

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Write the inquiry data into the device map for debugging purposes
    //

    RtlInitUnicodeString(&name, L"InquiryData");

    ZwSetValueKey(LogicalUnit->LunDeviceMapKey,
                  &name,
                  0,
                  REG_BINARY,
                  &(LogicalUnit->InquiryData),
                  INQUIRYDATABUFFERSIZE);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\internal.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    internal.c

Abstract:

    This is the NT SCSI port driver.  This file contains the internal
    code.

Authors:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include "port.h"
#include "wmilib.h"

#define __FILE_ID__ 'intr'

#if DBG
static const char *__file__ = __FILE__;
#endif

#if DBG
ULONG ScsiCheckInterrupts = 1;

// These counters keep track of succesfull (and failed) calls to
// IoWMIWriteEvent in the ScsiPortCompletionDpc function
LONG ScsiPortWmiWriteCalls = 0;
LONG ScsiPortWmiWriteCallsFailed = 0;

#else
ULONG ScsiCheckInterrupts = 0;
#endif

#if DBG
ULONG ScsiSimulateNoVaCounter = 0;
ULONG ScsiSimulateNoVaInterval = 0;
ULONG ScsiSimulateNoVaBreak = TRUE;

PVOID
SpGetSystemAddressForMdlSafe(
    IN PMDL Mdl,
    IN MM_PAGE_PRIORITY Priority
    )
{
    ScsiSimulateNoVaCounter++;

    if((ScsiSimulateNoVaInterval != 0) &&
       (Priority != HighPagePriority) &&
       ((ScsiSimulateNoVaCounter % ScsiSimulateNoVaInterval) == 0)) {
        if(TEST_FLAG(Mdl->MdlFlags, (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL))) {
            DbgPrint("SpGetSystemAddressForMdlSafe - not failing since MDL %#08p is already mapped\n", Mdl);
            return Mdl->MappedSystemVa;
        } else {
            DbgPrint("SpGetSystemAddressForMdlSafe - failing this MDL mapping (%#08p %x %x)\n", Mdl, ScsiSimulateNoVaInterval, ScsiSimulateNoVaCounter);
            ASSERT(ScsiSimulateNoVaBreak == FALSE);
            return NULL;
        }
    }
    return MmGetSystemAddressForMdlSafe(Mdl, Priority);
}
#else
#define SpGetSystemAddressForMdlSafe MmGetSystemAddressForMdlSafe
#endif

//
// module-local type declarations
//

typedef struct _REROUTE_CONTEXT {
    PIRP OriginalIrp;
    PLOGICAL_UNIT_EXTENSION LogicalUnit;
} REROUTE_CONTEXT, *PREROUTE_CONTEXT;

typedef struct _SP_ENUMERATION_CONTEXT {
    KEVENT Event;
    PIO_WORKITEM WorkItem;
    NTSTATUS Status;
} SP_ENUMERATION_CONTEXT, *PSP_ENUMERATION_CONTEXT;

//
// Prototypes
//

VOID
SpEnumerateAdapterWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSP_ENUMERATION_CONTEXT Context
    );

NTSTATUS
SpSendMiniPortIoctl(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    );

NTSTATUS
SpSendPassThrough (
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    );

#ifdef USE_DMA_MACROS
VOID
SpReceiveScatterGather(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PVOID Context
    );
#else
IO_ALLOCATION_ACTION
SpBuildScatterGather(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );
#endif

NTSTATUS
SpSendResetCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PRESET_COMPLETION_CONTEXT Context
    );

NTSTATUS
SpSendReset(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP RequestIrp
    );

NTSTATUS
SpRerouteLegacyRequest(
    IN PDEVICE_OBJECT AdapterObject,
    IN PIRP Irp
    );

NTSTATUS
SpFlushReleaseQueue(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN Flush
    );

VOID
SpLogInterruptFailure(
    IN PADAPTER_EXTENSION Adapter
    );

VOID
SpDelayedWmiRegistrationControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context);

VOID
SpCompletionDpcProcessWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PINTERRUPT_DATA savedInterruptData
    );

NTSTATUS
IssueRequestSenseCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

VOID
SpSendRequestSenseIrp(
    IN PADAPTER_EXTENSION Adapter,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    );

NTSTATUS
SpFireSenseDataEvent(
    PSCSI_REQUEST_BLOCK Srb, 
    PDEVICE_OBJECT DeviceObject
    );
#if defined(FORWARD_PROGRESS)
PMDL
SpPrepareReservedMdlForUse(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData,
    IN PSCSI_REQUEST_BLOCK srb,
    IN ULONG ScatterListLength
    );

PVOID
SpMapLockedPagesWithReservedMapping(
    IN PADAPTER_EXTENSION Adapter,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PSRB_DATA SrbData,
    IN PMDL Mdl
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ScsiPortFdoDeviceControl)
#pragma alloc_text(PAGE, SpSendMiniPortIoctl)
#pragma alloc_text(PAGE, SpSendPassThrough)
#pragma alloc_text(PAGE, ScsiPortFdoCreateClose)
#pragma alloc_text(PAGE, SpSendReset)
#pragma alloc_text(PAGE, SpEnumerateAdapterWorker)

#pragma alloc_text(PAGELOCK, SpClaimLogicalUnit)
#endif

//
// Routines start
//


NTSTATUS
ScsiPortFdoDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - Address of device object.
    Irp - Address of I/O request packet.

Return Value:

    Status.

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    PSRB_DATA srbData;

    PKDEVICE_QUEUE_ENTRY packet;
    PIRP nextIrp;
    PIRP listIrp;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    NTSTATUS status;
    KIRQL currentIrql;

    ULONG isRemoved;

    //
    // If an SRB_DATA block has been setup then use it.
    //

    if(srb->OriginalRequest == Irp) {
        srbData = NULL;
    } else {
        srbData = srb->OriginalRequest;
    }

    isRemoved = SpAcquireRemoveLock(DeviceObject, Irp);

    if(isRemoved && !IS_CLEANUP_REQUEST(irpStack)) {

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;

        SpReleaseRemoveLock(DeviceObject, Irp);

        SpCompleteRequest(DeviceObject,
                          Irp,
                          srbData,
                          IO_NO_INCREMENT);

        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // If the adapter is configured to handle power-down requests during 
    // shutdown, it is possible for it to be powered off and for the PDOs 
    // to be powered up.  We will fail requests when this condition arises.
    //
    // This should only occur at shutdown.
    //

    if (deviceExtension->CommonExtension.CurrentSystemState > PowerSystemHibernate &&
        deviceExtension->CommonExtension.CurrentDeviceState != PowerDeviceD0) {       

        //
        // This should only occur if the adapter is configured to receive
        // power-down requests at shutdown.
        //

        ASSERT(deviceExtension->NeedsShutdown == TRUE);

        //
        // Lock and unlock commands don't require power and will work
        // regardless of the current power state.
        //

        if ((srb->Function != SRB_FUNCTION_UNLOCK_QUEUE &&
             srb->Function != SRB_FUNCTION_LOCK_QUEUE)) {

            Irp->IoStatus.Status = STATUS_POWER_STATE_INVALID;
            SpReleaseRemoveLock(DeviceObject, Irp);
            SpCompleteRequest(DeviceObject, Irp, srbData, IO_NO_INCREMENT);
            return STATUS_POWER_STATE_INVALID;
        }
    }

    //
    // If there's no SRB_DATA block for this request yet then we need to
    // allocate one.
    //

    if(srbData == NULL) {
        logicalUnit = GetLogicalUnitExtension(deviceExtension,
                                              srb->PathId,
                                              srb->TargetId,
                                              srb->Lun,
                                              FALSE,
                                              TRUE);

        if(logicalUnit == NULL) {
            DebugPrint((1, "ScsiPortFdoDispatch: Bad logical unit address.\n"));

            //
            // Fail the request. Set status in Irp and complete it.
            //

            srb->SrbStatus = SRB_STATUS_NO_DEVICE;
            Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
            SpReleaseRemoveLock(DeviceObject, Irp);

            SpCompleteRequest(DeviceObject, Irp, srbData, IO_NO_INCREMENT);
            return STATUS_NO_SUCH_DEVICE;
        }

        if((srb->Function == SRB_FUNCTION_IO_CONTROL) ||
           (srb->Function == SRB_FUNCTION_EXECUTE_SCSI) ||
           (srb->Function == SRB_FUNCTION_RELEASE_QUEUE) ||
           (srb->Function == SRB_FUNCTION_FLUSH_QUEUE)) {

            //
            // These are the only two types of requests which should
            // be able to get here without an SRB_DATA block.  Any
            // other will need to be rerouted.
            //

            return SpRerouteLegacyRequest(DeviceObject, Irp);
        }

    } else {

        ASSERT_SRB_DATA(srbData);
        ASSERT(srbData->CurrentIrp == Irp);

        logicalUnit = srbData->LogicalUnit;

        ASSERT(logicalUnit != NULL);
    }

    switch (srb->Function) {


        case SRB_FUNCTION_SHUTDOWN:
        case SRB_FUNCTION_FLUSH: {

            //
            // Do not send shutdown requests unless the adapter
            // supports caching.
            //

            if (!deviceExtension->CachesData) {
                Irp->IoStatus.Status = STATUS_SUCCESS;
                srb->SrbStatus = SRB_STATUS_SUCCESS;

                SpReleaseRemoveLock(DeviceObject, Irp);
                SpCompleteRequest(DeviceObject, Irp, srbData, IO_NO_INCREMENT);
                return STATUS_SUCCESS;
            }

            DebugPrint((2, "ScsiPortFdoDispatch: Sending flush or shutdown "
                           "request.\n"));

            goto ScsiPortFdoDispatchRunCommand;
        }

        case SRB_FUNCTION_LOCK_QUEUE:
        case SRB_FUNCTION_UNLOCK_QUEUE:
        case SRB_FUNCTION_IO_CONTROL:
        case SRB_FUNCTION_EXECUTE_SCSI:
        case SRB_FUNCTION_WMI: {

ScsiPortFdoDispatchRunCommand:

            //
            // Mark Irp status pending.
            //

            IoMarkIrpPending(Irp);

            if(SpSrbIsBypassRequest(srb, logicalUnit->LuFlags)) {

                //
                // Call start io directly.  This will by-pass the
                // frozen queue.
                //

                DebugPrint((2,
                    "ScsiPortFdoDispatch: Bypass frozen queue, IRP %#p\n",
                    Irp));

                srbData->TickCount = deviceExtension->TickCount;
                IoStartPacket(DeviceObject, Irp, (PULONG)NULL, NULL);

            } else {

                //
                // Queue the packet normally.
                //

                KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);

#if DBG
                // ASSERT(srb->Function != SRB_FUNCTION_UNLOCK_QUEUE);

                if (SpIsQueuePaused(logicalUnit)) {
                    DebugPrint((1,"ScsiPortFdoDispatch: Irp %#p put in "
                                  "frozen queue %#p!\n", Irp, logicalUnit));
                }

                // ASSERT((srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE) == 0);
#endif

                //
                // Set the tick count so we know how long this request has
                // been queued.
                //

                srbData->TickCount = deviceExtension->TickCount;

                if (!KeInsertByKeyDeviceQueue(
                        &logicalUnit->DeviceObject->DeviceQueue,
                        &Irp->Tail.Overlay.DeviceQueueEntry,
                        srb->QueueSortKey)) {

                    //
                    // Clear the retry count.
                    //

                    logicalUnit->RetryCount = 0;

                    //
                    // Queue is empty; start request.
                    //

#if DBG
                    if(SpIsQueuePaused(logicalUnit)) {
                        DebugPrint((1, "ScsiPortFdoDispatch: Queue was empty - "
                                       "issuing request anyway\n"));
                    }
#endif
                    IoStartPacket(DeviceObject, Irp, (PULONG)NULL, NULL);
                }

                KeLowerIrql(currentIrql);
            }

            return STATUS_PENDING;
        }

        case SRB_FUNCTION_RELEASE_QUEUE:
        case SRB_FUNCTION_FLUSH_QUEUE: {

            status = SpFlushReleaseQueue(
                        logicalUnit,
                        (BOOLEAN) (srb->Function == SRB_FUNCTION_FLUSH_QUEUE));

            ASSERT(NT_SUCCESS(status));

            if(NT_SUCCESS(status)) {
                srb->SrbStatus = SRB_STATUS_SUCCESS;
            } else {
                srb->SrbStatus = SRB_STATUS_ERROR;
            }

            break;
        }

        case SRB_FUNCTION_RESET_BUS: {

            RESET_CONTEXT resetContext;

            //
            // Acquire the spinlock to protect the flags structure and the saved
            // interrupt context.
            //

            KeAcquireSpinLock(&deviceExtension->SpinLock, &currentIrql);

            resetContext.DeviceExtension = deviceExtension;
            resetContext.PathId = srb->PathId;

            if (!deviceExtension->SynchronizeExecution(deviceExtension->InterruptObject,
                                                       SpResetBusSynchronized,
                                                       &resetContext)) {

                DebugPrint((1,"ScsiPortFdoDispatch: Reset failed\n"));
                srb->SrbStatus = SRB_STATUS_PHASE_SEQUENCE_FAILURE;
                status = STATUS_IO_DEVICE_ERROR;

            } else {

                SpLogResetError(deviceExtension,
                                srb,
                                ('R'<<24) | 256);

                srb->SrbStatus = SRB_STATUS_SUCCESS;
                status = STATUS_SUCCESS;
            }

            KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);

            break;
        }

        case SRB_FUNCTION_ABORT_COMMAND: {

            DebugPrint((3, "ScsiPortFdoDispatch: SCSI Abort or Reset command\n"));

            //
            // Mark Irp status pending.
            //

            IoMarkIrpPending(Irp);

            //
            // Don't queue these requests in the logical unit
            // queue, rather queue them to the adapter queue.
            //

            KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);

            IoStartPacket(DeviceObject, Irp, (PULONG)NULL, NULL);

            KeLowerIrql(currentIrql);

            return STATUS_PENDING;

            break;
        }

        case SRB_FUNCTION_ATTACH_DEVICE:
        case SRB_FUNCTION_CLAIM_DEVICE:
        case SRB_FUNCTION_RELEASE_DEVICE: {

            SpAcquireRemoveLock(logicalUnit->CommonExtension.DeviceObject,
                                (PVOID) ((ULONG_PTR) Irp + 2));

            status = SpClaimLogicalUnit(deviceExtension, logicalUnit, Irp, TRUE);

            SpReleaseRemoveLock(logicalUnit->CommonExtension.DeviceObject,
                                (PVOID) ((ULONG_PTR) Irp + 2));

            break;
        }

        default: {

            //
            // Found unsupported SRB function.
            //

            DebugPrint((1,"ScsiPortFdoDispatch: Unsupported function, SRB %p\n",
                srb));

            srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    }

    //
    // Set status in Irp.
    //

    Irp->IoStatus.Status = status;

    //
    // Complete request at raised IRQ.
    //

    SpReleaseRemoveLock(DeviceObject, Irp);
    SpCompleteRequest(DeviceObject, Irp, srbData, IO_NO_INCREMENT);

    return status;

} // end ScsiPortFdoDispatch()


NTSTATUS
ScsiPortFdoCreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    I/O system disk create routine.  This is called by the I/O system
    when the device is opened.

    If the fdo has not been started yet, this routine will try to start it.
    If the fdo cannot be started successfully this routine will return an error.

Arguments:

    DriverObject - Pointer to driver object created by system.
    Irp - IRP involved.

Return Value:

    NT Status

--*/

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    NTSTATUS status = STATUS_SUCCESS;

    ULONG isRemoved;

    PAGED_CODE();

    isRemoved = SpAcquireRemoveLock(DeviceObject, Irp);

    //
    // Check to see if the adapter's been started first.
    //

    if(irpStack->MajorFunction == IRP_MJ_CREATE) {

        if(isRemoved != NO_REMOVE) {
            status = STATUS_DEVICE_DOES_NOT_EXIST;
        } else if(commonExtension->CurrentPnpState != IRP_MN_START_DEVICE) {
            status = STATUS_DEVICE_NOT_READY;
        }
    }

    Irp->IoStatus.Status = status;

    SpReleaseRemoveLock(DeviceObject, Irp);
    SpCompleteRequest(DeviceObject, Irp, NULL, IO_DISK_INCREMENT);
    return status;

} // end ScsiPortCreateClose()


VOID
ScsiPortStartIo (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - Supplies pointer to Adapter device object.
    Irp - Supplies a pointer to an IRP.

Return Value:

    Nothing.

--*/

{
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    PSCSI_REQUEST_BLOCK srb;
    PSRB_DATA srbData;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    LONG interlockResult;
    NTSTATUS status;
    BOOLEAN taggedRequest;

    DebugPrint((3,"ScsiPortStartIo: Enter routine\n"));

    if(irpStack->MajorFunction != IRP_MJ_SCSI) {

        //
        // Special processing.
        //

        if(irpStack->MajorFunction == IRP_MJ_POWER) {
            ScsiPortProcessAdapterPower(DeviceObject, Irp);
        } else {

            ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);
            ASSERT(Irp->IoStatus.Information != (ULONG_PTR) NULL);

            //
            // The start-io routine is blocked now - signal the PNP code
            // so it can continue its processing.
            //

            KeSetEvent((PKEVENT) Irp->IoStatus.Information,
                       IO_NO_INCREMENT,
                       FALSE);
        }
        return;
    }

    srb = irpStack->Parameters.Scsi.Srb;
    srbData = srb->OriginalRequest;

    ASSERT_SRB_DATA(srbData);

    //
    // Start the srb status out as pending.  If the srb is successful by the
    // end of this routine then it will be completed and the next request
    // will be fetched rather than issuing it to the miniport.
    //

    srb->SrbStatus = SRB_STATUS_PENDING;

    //
    // Clear the SCSI status if this is a scsi request.
    //

    if(srb->Function == SRB_FUNCTION_EXECUTE_SCSI) {
        srb->ScsiStatus = SCSISTAT_GOOD;
    }

    //
    // Get logical unit extension.  The logical unit should have already been
    // locked with this IRP so we don't need to acquire it here.
    //

    logicalUnit = srbData->LogicalUnit;

    ASSERT(logicalUnit != NULL);

    //
    // We're already holding the remove lock so just check the is removed flag
    // to see if we should continue.
    //

    if((deviceExtension->CommonExtension.IsRemoved) &&
       (SpSrbIsBypassRequest(srb, logicalUnit->LuFlags))) {

        SpAcquireRemoveLock(DeviceObject, ScsiPortStartIo);
        SpReleaseRemoveLock(DeviceObject, Irp);
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        srb->SrbStatus = SRB_STATUS_NO_DEVICE;

        SpCompleteRequest(DeviceObject, Irp, srbData, IO_DISK_INCREMENT);

        SpStartNextPacket(DeviceObject, FALSE);
        SpReleaseRemoveLock(DeviceObject, ScsiPortStartIo);
        return;
    }

    //
    // Check to see if there's a reason this shouldn't have made it into the
    // startio routine.  if there is then requeue the request.  This is a
    // stopgap measure to fix some cases where the miniport entices scsiport
    // into inserting multiple requests for a logical unit into the adapter
    // queue at one time.
    //
    // The one exception to this case is with bypass requests since there
    // may be a request pending for a power-up or queue-thaw condition.  In
    // these cases we will let the command run.
    //
    // We can do a check for LU_PENDING_LU_REQUEST synchronously since the
    // only routines which set it are part of the startio process.  If we
    // think it's set then we need to acquire the port spinlock and verify
    //

    if(TEST_FLAG(logicalUnit->LuFlags, LU_PENDING_LU_REQUEST)) {

        KeAcquireSpinLockAtDpcLevel(&(deviceExtension->SpinLock));

        if(TEST_FLAG(logicalUnit->LuFlags, LU_PENDING_LU_REQUEST) &&
           !SpSrbIsBypassRequest(srb, logicalUnit->LuFlags)) {

            BOOLEAN t;

            //
            // Since there's an outstanding command the queue should be
            // busy.  However we've found that there are some times where it
            // isn't (with adapters which ask for more requests before
            // dispatching the ones they have).  Here if it's not busy we
            // can force the request in anyway since we know that something
            // is still outstanding and thus will take the next request out
            // of the queue.
            //

            t = KeInsertByKeyDeviceQueue(
                    &logicalUnit->DeviceObject->DeviceQueue,
                    &Irp->Tail.Overlay.DeviceQueueEntry,
                    srb->QueueSortKey);

            if(t == FALSE) {
                KeInsertByKeyDeviceQueue(
                    &logicalUnit->DeviceObject->DeviceQueue,
                    &Irp->Tail.Overlay.DeviceQueueEntry,
                    srb->QueueSortKey);
            }

            //
            // Now set the lun's current key to the value we just inserted
            // so that it's the next one to get pulled out.
            //

            logicalUnit->CurrentKey = srb->QueueSortKey;

            KeReleaseSpinLockFromDpcLevel(&(deviceExtension->SpinLock));

            IoStartNextPacket(deviceExtension->DeviceObject, FALSE);

            return;
        }

        //
        // False alarm.
        //

        KeReleaseSpinLockFromDpcLevel(&(deviceExtension->SpinLock));

    }

    //
    // Set the default flags in the SRB.
    //

    srb->SrbFlags |= deviceExtension->CommonExtension.SrbFlags;

    //
    // If we're not in a valid power state for the request then block the
    // i/o and request that PO put us in such a state.
    //

    status = SpRequestValidPowerState(deviceExtension, logicalUnit, srb);

    if(status == STATUS_PENDING) {

        SpStartNextPacket(DeviceObject, FALSE);
        return;

    }

    if(srb->SrbFlags & SRB_FLAGS_BYPASS_LOCKED_QUEUE) {
        DebugPrint((1, "ScsiPortStartIo: Handling power bypass IRP %#p\n",
                    Irp));
    }

    ASSERT(Irp == DeviceObject->CurrentIrp);

    if (deviceExtension->AllocateSrbExtension ||
        deviceExtension->SupportsMultipleRequests) {

        BOOLEAN StartNextPacket = FALSE;

        //
        // Allocate the special extensions or SRB data structure.
        // If NULL is returned then this request cannot be excuted at this
        // time so just return.  This occurs when one the the data structures
        // could not be allocated or when unqueued request could not be
        // started because of actived queued requests.
        //
        //

        if(SpAllocateSrbExtension(deviceExtension,
                                  logicalUnit,
                                  srb,
                                  &StartNextPacket,
                                  &taggedRequest) == FALSE) {

            //
            // If the request could not be started on the logical unit,
            // then call SpStartNextPacket.  Note that this may cause this
            // to be entered recursively; however, no resources have been
            // allocated, it is a tail recursion and the depth is limited by
            // the number of requests in the device queue.
            //

            if (StartNextPacket == TRUE) {
                SpStartNextPacket(DeviceObject, FALSE);
            }
            return;
        } 

    } else {

        //
        // No special resources are required.
        //

        taggedRequest = FALSE;
        srb->SrbExtension = NULL;
    }

    //
    // Assign a queuetag to the srb
    //

    if (taggedRequest == TRUE) {

        //
        // If we get an SRB with an invalid QueueAction, fix it up here
        // to prevent problems.
        //

        if (!(srb->QueueAction == SRB_SIMPLE_TAG_REQUEST ||
              srb->QueueAction == SRB_HEAD_OF_QUEUE_TAG_REQUEST ||
              srb->QueueAction == SRB_ORDERED_QUEUE_TAG_REQUEST)) {

            DebugPrint((1,"ScsiPortStartIo: Invalid QueueAction (%02x) "
                        "SRB:%p irp:%p\n", srb->QueueAction, srb, Irp));

            srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;
        }

        srb->QueueTag = (UCHAR)srbData->QueueTag;

    } else {

        srb->QueueTag = SP_UNTAGGED;

    }

    //
    // Save the original SRB values away so that we can restore them
    // later if it becomes necessary to retry the request.
    //

    srbData->OriginalDataTransferLength = srb->DataTransferLength;

    //
    // Update the sequence number for this request if there is not already one
    // assigned.
    //

    if (!srbData->SequenceNumber) {

        //
        // Assign a sequence number to the request and store it in the logical
        // unit.
        //

        srbData->SequenceNumber = deviceExtension->SequenceNumber++;

    }

    //
    // If this is not an ABORT request the set the current srb.
    // NOTE: Lock should be held here!
    //

    if (srb->Function == SRB_FUNCTION_ABORT_COMMAND) {

        //
        // Only abort requests can be started when there is a current request
        // active.
        //

        ASSERT(logicalUnit->AbortSrb == NULL);
        logicalUnit->AbortSrb = srb;

    } else if((srb->Function == SRB_FUNCTION_LOCK_QUEUE) ||
              (srb->Function == SRB_FUNCTION_UNLOCK_QUEUE)) {

        BOOLEAN lock = (srb->Function == SRB_FUNCTION_LOCK_QUEUE);
        ULONG lockCount;

        //
        // Process power requests
        //

        DebugPrint((1, "ScsiPortStartIo: Power %s request %#p in "
                       "start-io routine\n",
                    lock ? "lock" : "unlock",
                    Irp));

        KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

        if(lock) {
            lockCount = InterlockedIncrement(&(logicalUnit->QueueLockCount));
            SET_FLAG(logicalUnit->LuFlags, LU_QUEUE_LOCKED);
        } else {
            if(TEST_FLAG(logicalUnit->LuFlags, LU_QUEUE_LOCKED)) {
                ASSERT(logicalUnit->QueueLockCount != 0);
                lockCount = InterlockedDecrement(&(logicalUnit->QueueLockCount));
                if(lockCount == 0) {
                    CLEAR_FLAG(logicalUnit->LuFlags, LU_QUEUE_LOCKED);
                }
            }
        }

        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        srb->SrbStatus = SRB_STATUS_SUCCESS;

    }

    //
    // Flush the data buffer if necessary.
    //

    if (srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) {

        //
        // Save the current data buffer away in the srb data.  We will always
        // restore it afterwards - partially because the miniport might change
        // it and partially because scsiport might.  The tape drivers appear
        // to expect the same data buffer pointer back.
        //

        srbData->OriginalDataBuffer = srb->DataBuffer;

        //
        // Assuming that srb's data buffer uses the mdl's VA as a base address,
        // calculate the offset from the base.  This offset will be used to
        // calculate VAs from derived system addresses.
        //

        srbData->DataOffset =
            (ULONG_PTR) ((ULONG_PTR) srb->DataBuffer -
                         (ULONG_PTR) MmGetMdlVirtualAddress(Irp->MdlAddress));

        if (deviceExtension->DmaAdapterObject) {

            BOOLEAN dataIn;

            //
            // If the buffer is not mapped then the I/O buffer must be flushed.
            //

            dataIn = (srb->SrbFlags & SRB_FLAGS_DATA_IN) ? TRUE : FALSE;

            KeFlushIoBuffers(Irp->MdlAddress, dataIn, TRUE);
        }

        //
        // Determine if this adapter needs map registers
        //

        if (deviceExtension->MasterWithAdapter) {

            //
            // Calculate the number of map registers needed for this transfer.
            //

            srbData->NumberOfMapRegisters = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                    srb->DataBuffer,
                    srb->DataTransferLength
                    );

            ASSERT(srb->DataTransferLength != 0);

            //
            // Allocate the adapter channel with sufficient map registers
            // for the transfer.
            //

#ifdef USE_DMA_MACROS
            status = GetScatterGatherList(
                deviceExtension->DmaAdapterObject,
                deviceExtension->DeviceObject,
                Irp->MdlAddress,
                srb->DataBuffer,
                srb->DataTransferLength,
                SpReceiveScatterGather,
                srbData,
                (BOOLEAN) (srb->SrbFlags & SRB_FLAGS_DATA_OUT ? TRUE : FALSE) );

#else
            status = AllocateAdapterChannel(
                deviceExtension->DmaAdapterObject,
                deviceExtension->DeviceObject,
                srbData->NumberOfMapRegisters,
                SpBuildScatterGather,
                srbData);
#endif

            if (!NT_SUCCESS(status)) {

                DebugPrint((1, "ScsiPortStartIo: IoAllocateAdapterChannel "
                               "failed(%x)\n",
                            status));

                srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
                srb->ScsiStatus = 0xff;
                srbData->InternalStatus = status;
                goto ScsiPortStartIoFailedRequest;
            }

            //
            // The execution routine called by IoAllocateChannel will do the
            // rest of the work so just return.
            //

            return;

        } else if ((deviceExtension->MapBuffers == TRUE) ||
                   (IS_MAPPED_SRB(srb) == TRUE)) {

            //
            // Determine if the adapter needs mapped memory.
            //

            if (Irp->MdlAddress) {

                PVOID systemAddress;

                //
                // Get the mapped system address and calculate offset into MDL.
                // At the moment don't allow KernelMode requests to fail since
                // not all scsiport's internally sent requests are correctly
                // marked as coming from non-paged pool.
                //

                systemAddress = SpGetSystemAddressForMdlSafe(
                                    Irp->MdlAddress,
                                    ((Irp->RequestorMode == KernelMode) ?
                                     HighPagePriority :
                                     NormalPagePriority));

#if defined(FORWARD_PROGRESS)
                if (systemAddress == NULL && deviceExtension->ReservedPages != NULL) {            

                    //
                    // The system could not map the pages necessary to complete this
                    // request.  We need to ensure forward progress, so we'll try to
                    // use the reserve pages we allocated at initialization time.
                    //

                    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);
            
                    systemAddress = SpMapLockedPagesWithReservedMapping(
                                        deviceExtension,
                                        srb,
                                        srbData,
                                        Irp->MdlAddress);
                    
                    if (systemAddress == (PVOID)-1) {

                        DebugPrint((1, "ScsiPortStartIo: reserved pages in use - pending DevExt:%p srb:%p\n", 
                                    deviceExtension, srb));

                        //
                        // The spare pages are already in use.  At this point, this
                        // request is still the current IRP on the adapter device
                        // object, so let's pend it until the spare comes available.
                        //

                        ASSERT(Irp == DeviceObject->CurrentIrp);
                        SET_FLAG(deviceExtension->Flags, PD_PENDING_DEVICE_REQUEST);

                        //
                        // If we allocated an SRB extension for this request, free
                        // it now.  I do this because when the request gets restarted
                        // we'll try to allocate the SRB extension again and without
                        // adding more state, there isn't a safe way to check if the 
                        // extension has already been allocated.  Besides, it makes
                        // sense to make the extension available for some other
                        // request since it also is a limited resource.
                        //

                        if (srb->SrbExtension != NULL) {
                            SpFreeSrbExtension(deviceExtension, srb->SrbExtension);
                        }

                        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
                        return;
                    }

                    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
                }
#endif

                if(systemAddress != NULL) {

                    //
                    // Since we mapped the original MDL rather we have to
                    // compensate for the data buffer offset.
                    //

                    srb->DataBuffer =
                        (PVOID) ((ULONG_PTR) systemAddress +
                                 (ULONG_PTR) srbData->DataOffset);
                } else {
                    DebugPrint((1, "ScsiPortStartIo: Couldn't get system "
                                   "VA for irp %#08p\n", Irp));

                    srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
                    srb->ScsiStatus = 0xff;
                    srbData->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

                    goto ScsiPortStartIoFailedRequest;
                }
            }
        }
    }

    //
    // Increment the active request count.  If the is zero,
    // the adapter object needs to be allocated.
    // Note that at this point a slave device is assumed since master with
    // adapter has already been checked.
    //

    interlockResult =
        InterlockedIncrement(&deviceExtension->ActiveRequestCount);

    if (interlockResult == 0 &&
        srb->SrbStatus == SRB_STATUS_PENDING &&
        !deviceExtension->MasterWithAdapter &&
        deviceExtension->DmaAdapterObject != NULL) {

        //
        // Allocate the AdapterObject.  The number of registers is equal to the
        // maximum transfer length supported by the adapter + 1.  This insures
        // that there will always be a sufficient number of registers.
        //

        AllocateAdapterChannel(
            deviceExtension->DmaAdapterObject,
            DeviceObject,
            deviceExtension->Capabilities.MaximumPhysicalPages,
            ScsiPortAllocationRoutine,
            logicalUnit
            );

        //
        // The execution routine called by IoAllocateChannel will do the
        // rest of the work so just return.
        //

        return;

    }

ScsiPortStartIoFailedRequest:

    //
    // Acquire the spinlock to protect the various structures.
    // SpStartIoSynchronized must be called with the spinlock held.
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

    deviceExtension->SynchronizeExecution(
        deviceExtension->InterruptObject,
        SpStartIoSynchronized,
        DeviceObject
        );

    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

    return;

} // end ScsiPortStartIO()

BOOLEAN
ScsiPortInterrupt(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:


Arguments:

    Interrupt

    Device Object

Return Value:

    Returns TRUE if interrupt expected.

--*/

{
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PINTERRUPT_DATA interruptData = &(deviceExtension->InterruptData);
    BOOLEAN returnValue;

    UNREFERENCED_PARAMETER(Interrupt);

    //
    // If interrupts have been disabled then this should not be our interrupt,
    // so just return.
    //

    if (TEST_FLAG(interruptData->InterruptFlags,
                  (PD_DISABLE_INTERRUPTS | PD_ADAPTER_REMOVED))) {
#if DGB
        static int interruptCount;

        interruptCount++;
        ASSERT(interruptCount < 1000);
#endif

        return(FALSE);
    }

    returnValue =
        deviceExtension->HwInterrupt(deviceExtension->HwDeviceExtension);

    if(returnValue) {
        deviceExtension->WatchdogInterruptCount = 1;
    }

    //
    // Check to see if a DPC needs to be queued.
    //

    if (TEST_FLAG(interruptData->InterruptFlags, PD_NOTIFICATION_REQUIRED)) {

        SpRequestCompletionDpc(DeviceObject);

    }

    return(returnValue);

} // end ScsiPortInterrupt()


VOID
ScsiPortCompletionDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

    Dpc
    DeviceObject
    Irp - not used
    Context - not used

Return Value:

    None.

--*/

{
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    INTERRUPT_CONTEXT interruptContext;
    INTERRUPT_DATA savedInterruptData;
    BOOLEAN callStartIo;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSRB_DATA srbData;
    LONG interlockResult;
    LARGE_INTEGER timeValue;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(Context);

    do {

        //
        // Acquire the spinlock to protect flush adapter buffers
        // information.
        //

        KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

        //
        // Get the interrupt state.  This copies the interrupt
        // state to the saved state where it can be processed.
        // It also clears the interrupt flags.
        //

        interruptContext.DeviceExtension = deviceExtension;
        interruptContext.SavedInterruptData = &savedInterruptData;

        if (!deviceExtension->SynchronizeExecution(
            deviceExtension->InterruptObject,
            SpGetInterruptState,
            &interruptContext)) {

            KeReleaseSpinLockFromDpcLevel(
                &deviceExtension->SpinLock);

            //
            // There wasn't anything to do that time.  Test the
            // DPC flags and try again
            //

            continue;
        }

        if(savedInterruptData.InterruptFlags &
           (PD_FLUSH_ADAPTER_BUFFERS |
            PD_MAP_TRANSFER |
            PD_TIMER_CALL_REQUEST |
            PD_WMI_REQUEST |
            PD_BUS_CHANGE_DETECTED |
            PD_INTERRUPT_FAILURE)) {

            //
            // Check for a flush DMA adapter object request.
            //

            if (savedInterruptData.InterruptFlags &
                PD_FLUSH_ADAPTER_BUFFERS) {

                if(Sp64BitPhysicalAddresses) {
                    KeBugCheckEx(PORT_DRIVER_INTERNAL,
                                 3,
                                 STATUS_NOT_SUPPORTED,
                                 (ULONG_PTR) deviceExtension->HwDeviceExtension,
                                 (ULONG_PTR) deviceExtension->DeviceObject->DriverObject);
                }

                //
                // Call IoFlushAdapterBuffers using the parameters
                // saved from the last IoMapTransfer call.
                //

                FlushAdapterBuffers(
                    deviceExtension->DmaAdapterObject,
                    deviceExtension->FlushAdapterParameters.SrbData->CurrentIrp->MdlAddress,
                    deviceExtension->MapRegisterBase,
                    deviceExtension->FlushAdapterParameters.LogicalAddress,
                    deviceExtension->FlushAdapterParameters.Length,
                    (BOOLEAN)(deviceExtension->FlushAdapterParameters.SrbFlags
                        & SRB_FLAGS_DATA_OUT ? TRUE : FALSE));
            }

            //
            // Check for an IoMapTransfer DMA request.  Don't do
            // anything if the adapter's been removed in the time
            // since it requested this service.
            //

            if (TEST_FLAG(savedInterruptData.InterruptFlags, PD_MAP_TRANSFER) &&
                !TEST_FLAG(savedInterruptData.InterruptFlags, PD_ADAPTER_REMOVED)) {

                PADAPTER_TRANSFER mapTransfer;
                ULONG_PTR address;
                PMDL mdl;

                if(Sp64BitPhysicalAddresses) {
                    KeBugCheckEx(PORT_DRIVER_INTERNAL,
                                 4,
                                 STATUS_NOT_SUPPORTED,
                                 (ULONG_PTR) deviceExtension->HwDeviceExtension,
                                 (ULONG_PTR) deviceExtension->DeviceObject->DriverObject);
                }

                mapTransfer = &savedInterruptData.MapTransferParameters;
                srbData = mapTransfer->SrbData;

                ASSERT_SRB_DATA(srbData);

                mdl = srbData->CurrentIrp->MdlAddress;

                //
                // Adjust the logical address.  This is necessary because the
                // address in the srb may be a mapped system address rather
                // than the virtual address for the MDL.
                //

                address = (ULONG_PTR) mapTransfer->LogicalAddress;
                address -= (ULONG_PTR) srbData->DataOffset;
                address += (ULONG_PTR) MmGetMdlVirtualAddress(mdl);

                mapTransfer->LogicalAddress = (PCHAR) address;

                //
                // Call IoMapTransfer using the parameters saved from the
                // interrupt level.
                //

                MapTransfer(
                    deviceExtension->DmaAdapterObject,
                    mdl,
                    deviceExtension->MapRegisterBase,
                    mapTransfer->LogicalAddress,
                    &mapTransfer->Length,
                    (BOOLEAN)(mapTransfer->SrbFlags & SRB_FLAGS_DATA_OUT ?
                        TRUE : FALSE));

                //
                // Save the paramters for IoFlushAdapterBuffers.
                //

                deviceExtension->FlushAdapterParameters =
                    savedInterruptData.MapTransferParameters;

                //
                // If necessary notify the miniport driver that the DMA has been
                // started.
                //

                if (deviceExtension->HwDmaStarted) {
                    deviceExtension->SynchronizeExecution(
                        deviceExtension->InterruptObject,
                        (PKSYNCHRONIZE_ROUTINE) deviceExtension->HwDmaStarted,
                        deviceExtension->HwDeviceExtension);
                }

                //
                // Check for miniport work requests. Note this is an unsynchonized
                // test on a bit that can be set by the interrupt routine; however,
                // the worst that can happen is that the completion DPC checks for work
                // twice.
                //

                if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

                    //
                    // Mark that there's more work to be processed so that we
                    // restart the DPC rather than exiting it.
                    //

                    InterlockedExchange(&(deviceExtension->DpcFlags),
                                        (PD_DPC_RUNNING | PD_NOTIFICATION_REQUIRED));
                }

            }

            //
            // Check for timer requests.
            // If the adapter is being removed then don't do anything.
            //

            if ((savedInterruptData.InterruptFlags & PD_TIMER_CALL_REQUEST) &&
                (!TEST_FLAG(savedInterruptData.InterruptFlags, PD_ADAPTER_REMOVED))) {

                //
                // The miniport wants a timer request. Save the timer parameters.
                //

                if (SpVerifierActive(deviceExtension)) {
                    deviceExtension->VerifierExtension->RealHwTimerRequest = 
                       savedInterruptData.HwTimerRequest;
                    deviceExtension->HwTimerRequest = SpHwTimerRequestVrfy;
                } else {
                    deviceExtension->HwTimerRequest = savedInterruptData.HwTimerRequest;
                }

                //
                // If the requested timer value is zero, then cancel the timer.
                //

                if (savedInterruptData.MiniportTimerValue == 0) {

                    KeCancelTimer(&deviceExtension->MiniPortTimer);

                } else {

                    //
                    // We don't set the timer if we're in the process of shutting down.
                    //
                    
                    if (!TEST_FLAG(deviceExtension->Flags, PD_SHUTDOWN_IN_PROGRESS)) {

                        //
                        // Convert the timer value from mircoseconds to a negative 100
                        // nanoseconds.
                        //

                        timeValue.QuadPart = Int32x32To64(
                                                 savedInterruptData.MiniportTimerValue,
                                                 -10);

                        //
                        // Set the timer.
                        //

                        KeSetTimer(&deviceExtension->MiniPortTimer,
                                   timeValue,
                                   &deviceExtension->MiniPortTimerDpc);

                    }
                }
            }

            //
            // Check for WMI requests from the miniport.
            //

            if (savedInterruptData.InterruptFlags & PD_WMI_REQUEST) {

                SpCompletionDpcProcessWmi(
                    DeviceObject,
                    &savedInterruptData);

            } // wmi request exists from miniport

            if(TEST_FLAG(savedInterruptData.InterruptFlags,
                         PD_BUS_CHANGE_DETECTED)) {

                //
                // Request device enumeration.
                // Force the next bus scan to happen.
                //

                deviceExtension->ForceNextBusScan = TRUE;

                IoInvalidateDeviceRelations(deviceExtension->LowerPdo,
                                            BusRelations);
            }

            if(TEST_FLAG(savedInterruptData.InterruptFlags,
                         PD_INTERRUPT_FAILURE)) {
                SpLogInterruptFailure(deviceExtension);
            }
        }

        //
        // Verify that the ready for next request is ok.
        //

        if (savedInterruptData.InterruptFlags & PD_READY_FOR_NEXT_REQUEST) {

            //
            // If the device busy bit is not set, then this is a duplicate request.
            // If a no disconnect request is executing, then don't call start I/O.
            // This can occur when the miniport does a NextRequest followed by
            // a NextLuRequest.
            //

            if ((deviceExtension->Flags & (PD_DEVICE_IS_BUSY | PD_DISCONNECT_RUNNING))
                == (PD_DEVICE_IS_BUSY | PD_DISCONNECT_RUNNING)) {

                //
                // Clear the device busy flag.  This flag is set by
                // SpStartIoSynchonized.
                //

                deviceExtension->Flags &= ~PD_DEVICE_IS_BUSY;

                if (!(savedInterruptData.InterruptFlags & PD_RESET_HOLD)) {

                    //
                    // The miniport is ready for the next request and there is
                    // not a pending reset hold, so clear the port timer.
                    //

                    deviceExtension->PortTimeoutCounter = PD_TIMER_STOPPED;
                }

            } else {

                //
                // If a no disconnect request is executing, then clear the
                // busy flag.  When the disconnect request completes an
                // SpStartNextPacket will be done.
                //

                deviceExtension->Flags &= ~PD_DEVICE_IS_BUSY;

                //
                // Clear the ready for next request flag.
                //

                savedInterruptData.InterruptFlags &= ~PD_READY_FOR_NEXT_REQUEST;
            }
        }

        //
        // Check for any reported resets.
        //

        if (savedInterruptData.InterruptFlags & PD_RESET_REPORTED) {

            //
            // Start the hold timer.
            //

            deviceExtension->PortTimeoutCounter = PD_TIMER_RESET_HOLD_TIME;
        }

        if (savedInterruptData.ReadyLogicalUnit != NULL) {

            PLOGICAL_UNIT_EXTENSION tmpLogicalUnit;
            //
            // Process the ready logical units.
            //

            for(logicalUnit = savedInterruptData.ReadyLogicalUnit;
                logicalUnit != NULL;
                (tmpLogicalUnit = logicalUnit,
                 logicalUnit = tmpLogicalUnit->ReadyLogicalUnit,
                 tmpLogicalUnit->ReadyLogicalUnit = NULL)) {

                //
                // Get the next request for this logical unit.
                // Note this will release the device spin lock.
                //

                GetNextLuRequest(logicalUnit);

                //
                // Reacquire the device spinlock.
                //

                KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);
            }
        }

        //
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        //
        // Check for a ready for next packet.
        //

        if (savedInterruptData.InterruptFlags & PD_READY_FOR_NEXT_REQUEST) {

            //
            // Start the next request.
            //

            SpStartNextPacket(deviceExtension->DeviceObject, FALSE);
        }

        //
        // Check for an error log requests.
        //

        if (savedInterruptData.InterruptFlags & PD_LOG_ERROR) {

            //
            // Process the request.
            //

            LogErrorEntry(deviceExtension,
                          &savedInterruptData.LogEntry);
        }

        //
        // Process any completed requests.  The list has already been cut free
        // and the pointer is never tested except here, so there's no reason to
        // waste cycles unlinking them from the list.  The pointers will be
        // overwritten later.
        //

        callStartIo = FALSE;

        while (savedInterruptData.CompletedRequests != NULL) {

            //
            // Remove the request from the linked-list.
            //

            srbData = savedInterruptData.CompletedRequests;

            ASSERT_SRB_DATA(srbData);
            savedInterruptData.CompletedRequests = srbData->CompletedRequests;
            srbData->CompletedRequests = NULL;

            SpProcessCompletedRequest(deviceExtension,
                                      srbData,
                                      &callStartIo);
        }

        if(callStartIo) {
            ASSERT(DeviceObject->CurrentIrp != NULL);
        }

        //
        // Process any completed abort requests.
        //

        while (savedInterruptData.CompletedAbort != NULL) {

            ASSERT(FALSE);

            logicalUnit = savedInterruptData.CompletedAbort;

            //
            // Remove request from the completed abort list.
            //

            savedInterruptData.CompletedAbort = logicalUnit->CompletedAbort;

            //
            // Acquire the spinlock to protect the flags structure,
            // and the free of the srb extension.
            //

            KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

            //
            // Free SrbExtension to the free list if necessary.
            //

            if (logicalUnit->AbortSrb->SrbExtension) {

                if (SpVerifyingCommonBuffer(deviceExtension)) {

                    SpInsertSrbExtension(deviceExtension,
                                         logicalUnit->AbortSrb->SrbExtension);

                } else { 

                    *((PVOID *) logicalUnit->AbortSrb->SrbExtension) =
                       deviceExtension->SrbExtensionListHeader;

                    deviceExtension->SrbExtensionListHeader =
                       logicalUnit->AbortSrb->SrbExtension;

                }                
            }

            //
            // Note the timer which was started for the abort request is not
            // stopped by the get interrupt routine.  Rather the timer is stopped.
            // when the aborted request completes.
            //

            Irp = logicalUnit->AbortSrb->OriginalRequest;

            //
            // Set IRP status. Class drivers will reset IRP status based
            // on request sense if error.
            //

            if (SRB_STATUS(logicalUnit->AbortSrb->SrbStatus) == SRB_STATUS_SUCCESS) {
                Irp->IoStatus.Status = STATUS_SUCCESS;
            } else {
                Irp->IoStatus.Status = SpTranslateScsiStatus(logicalUnit->AbortSrb);
            }

            Irp->IoStatus.Information = 0;

            //
            // Clear the abort request pointer.
            //

            logicalUnit->AbortSrb = NULL;

            KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

            //
            // Decrement the number of active requests.  If the count is negative,
            // and this is a slave with an adapter then free the adapter object and
            // map registers.
            //

            interlockResult = InterlockedDecrement(&deviceExtension->ActiveRequestCount);

            if ( interlockResult < 0 &&
                !deviceExtension->PortConfig->Master &&
                deviceExtension->DmaAdapterObject != NULL ) {

                //
                // Clear the map register base for safety.
                //

                deviceExtension->MapRegisterBase = NULL;

                FreeAdapterChannel(deviceExtension->DmaAdapterObject);

            }

            SpReleaseRemoveLock(DeviceObject, Irp);
            SpCompleteRequest(DeviceObject, Irp, srbData, IO_DISK_INCREMENT);
        }

        //
        // Call the start I/O routine if necessary.
        //

        if (callStartIo) {
            ASSERT(DeviceObject->CurrentIrp != NULL);
            ScsiPortStartIo(DeviceObject, DeviceObject->CurrentIrp);
        }

        //
        // After all of the requested operations have been done check to see
        // if an enable interrupts call request needs to be done.
        //

        if (TEST_FLAG(savedInterruptData.InterruptFlags, PD_ENABLE_CALL_REQUEST) &&
            !TEST_FLAG(savedInterruptData.InterruptFlags, PD_ADAPTER_REMOVED)) {

            //
            // Acquire the spinlock so nothing else starts.
            //

            KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

            deviceExtension->HwRequestInterrupt(deviceExtension->HwDeviceExtension);

            ASSERT(deviceExtension->Flags & PD_DISABLE_CALL_REQUEST);

            //
            // Check to see if interrupts should be enabled again.
            //

            if (deviceExtension->Flags & PD_DISABLE_CALL_REQUEST) {

                //
                // Clear the flag.
                //

                deviceExtension->Flags &= ~PD_DISABLE_CALL_REQUEST;

                //
                // Synchronize with the interrupt routine.
                //

                deviceExtension->SynchronizeExecution(
                    deviceExtension->InterruptObject,
                    SpEnableInterruptSynchronized,
                    deviceExtension
                    );
            }

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
        }

    } while(((InterlockedCompareExchange(
                        &(deviceExtension->DpcFlags),
                        0L,
                        PD_DPC_RUNNING)) &
             PD_NOTIFICATION_REQUIRED) == PD_NOTIFICATION_REQUIRED);

    return;

} // end ScsiPortCompletionDpc()


BOOLEAN
SpFakeInterrupt(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;

    return ScsiPortInterrupt(adapter->InterruptObject, DeviceObject);
}


VOID
ScsiPortTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/

{
    PADAPTER_EXTENSION deviceExtension =
        (PADAPTER_EXTENSION) DeviceObject->DeviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PIRP irp;
    ULONG target;

    UNREFERENCED_PARAMETER(Context);

    //
    // Acquire the spinlock to protect the flags structure.
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

    //
    // Increment the tick count.  This is the only code which will change
    // the count and we're inside a spinlock when we do it so we don't need
    // an interlocked operation.
    //

    deviceExtension->TickCount++;

    //
    // Check whether we need to repopulate the WMI_REQUEST_ITEM
    // free list
    //

    if ((deviceExtension->CommonExtension.WmiInitialized) &&
        (deviceExtension->CommonExtension.WmiMiniPortSupport)) {

        while (deviceExtension->WmiFreeMiniPortRequestCount <
               deviceExtension->WmiFreeMiniPortRequestWatermark) {

            // Add one to the free list
            if (!NT_SUCCESS(
               SpWmiPushFreeRequestItem(deviceExtension))) {

               //
               // We failed to add, most likely a memory
               // problem, so just stop trying for now
               //

               break;
            }
        }
    }

    //
    // Check for port timeouts.
    //

    if (deviceExtension->PortTimeoutCounter > 0) {

        BOOLEAN timeout = FALSE;


        if (--deviceExtension->PortTimeoutCounter == 0) {

            //
            // Process the port timeout.
            //

            if (deviceExtension->SynchronizeExecution(
                                    deviceExtension->InterruptObject,
                                    SpTimeoutSynchronized,
                                    DeviceObject)){

                //
                // Log error if SpTimeoutSynchonized indicates this was an error
                // timeout.
                //

                if (deviceExtension->CommonExtension.DeviceObject->CurrentIrp) {
                    SpLogTimeoutError(
                        deviceExtension,
                        DeviceObject->CurrentIrp,
                        256);
                }
            }

            timeout = TRUE;
        }

        //
        // If a port timeout has been done then skip the rest of the
        // processing.
        //

        if(timeout) {
            KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
            return;
        }
    }

    //
    // Scan each of the logical units.  If it has an active request then
    // decrement the timeout value and process a timeout if it is zero.
    //

    for (target = 0; target < NUMBER_LOGICAL_UNIT_BINS; target++) {

        PLOGICAL_UNIT_BIN bin;

        bin = &deviceExtension->LogicalUnitList[target];

RestartTimeoutLoop:

        KeAcquireSpinLockAtDpcLevel(&bin->Lock);
        logicalUnit = bin->List;
        while (logicalUnit != NULL) {

            //
            // Check for busy requests.
            //

            if (logicalUnit->LuFlags & LU_LOGICAL_UNIT_IS_BUSY) {

                //
                // If a request sense is needed or the queue is
                // frozen, defer processing this busy request until
                // that special processing has completed. This prevents
                // a random busy request from being started when a REQUEST
                // SENSE needs to be sent.
                //
                // Exception: If the srb is flagged BYPASS_LOCKED_QUEUE, then
                // go ahead and retry it

                PSRB_DATA srbData;
                srbData = logicalUnit->BusyRequest;
                ASSERT_SRB_DATA(srbData);

                if(!(logicalUnit->LuFlags & LU_NEED_REQUEST_SENSE) &&
                   ((!SpIsQueuePaused(logicalUnit)) ||
                    (TEST_FLAG(srbData->CurrentSrb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE)))) {


                    DebugPrint((1,"ScsiPortTickHandler: Retrying busy status "
                                  "request\n"));

                    //
                    // If there is a pending request, requeue it before we
                    // retry the busy request.  Otherwise, the busy request
                    // will itself get requeued in ScsiPortStartIo because
                    // there is a pending request and if nothing else
                    // remains active, scsiport will stall.
                    //

                    if (logicalUnit->LuFlags & LU_PENDING_LU_REQUEST) {
                        BOOLEAN t;
                        PSRB_DATA pendingRqst;

                        DebugPrint((0, "ScsiPortTickHandler: Requeing pending "
                                    "request %p before starting busy request %p\n",
                                    logicalUnit->PendingRequest,
                                    logicalUnit->BusyRequest->CurrentSrb));

                        CLEAR_FLAG(logicalUnit->LuFlags,
                            LU_PENDING_LU_REQUEST | LU_LOGICAL_UNIT_IS_ACTIVE);

                        pendingRqst = logicalUnit->PendingRequest;
                        logicalUnit->PendingRequest = NULL;

                        t = KeInsertByKeyDeviceQueue(
                                &logicalUnit->DeviceObject->DeviceQueue,
                                &pendingRqst->CurrentIrp->Tail.Overlay.DeviceQueueEntry,
                                pendingRqst->CurrentSrb->QueueSortKey);

                        if (t == FALSE) {
                            KeInsertByKeyDeviceQueue(
                                &logicalUnit->DeviceObject->DeviceQueue,
                                &pendingRqst->CurrentIrp->Tail.Overlay.DeviceQueueEntry,
                                pendingRqst->CurrentSrb->QueueSortKey);
                        }
                    }                    

                    //
                    // Clear the busy flag and retry the request. Release the
                    // spinlock while the call to IoStartPacket is made.
                    //

                    logicalUnit->LuFlags &= ~(LU_LOGICAL_UNIT_IS_BUSY |
                                              LU_QUEUE_IS_FULL);

                    //
                    // Clear the busy request.
                    //

                    logicalUnit->BusyRequest = NULL;

                    KeReleaseSpinLockFromDpcLevel(&bin->Lock);
                    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

                    srbData->TickCount = deviceExtension->TickCount;
                    IoStartPacket(DeviceObject,
                                  srbData->CurrentIrp,
                                  (PULONG)NULL,
                                  NULL);

                    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

                    goto RestartTimeoutLoop;
                }

            } else if (logicalUnit->RequestTimeoutCounter == 0) {

                RESET_CONTEXT resetContext;

                //
                // Request timed out.
                //

                logicalUnit->RequestTimeoutCounter = PD_TIMER_STOPPED;

                DebugPrint((1,"ScsiPortTickHandler: Request timed out lun:%p\n", logicalUnit));

                resetContext.DeviceExtension = deviceExtension;
                resetContext.PathId = logicalUnit->PathId;

                //
                // Release the bin spinlock before doing a reset.  There are
                // outstanding requests so the device object shouldn't go away.
                //

                KeReleaseSpinLockFromDpcLevel(&bin->Lock);

                if (!deviceExtension->SynchronizeExecution(
                        deviceExtension->InterruptObject,
                        SpResetBusSynchronized,
                        &resetContext)) {

                    DebugPrint((1,"ScsiPortTickHandler: Reset failed\n"));

                } else {

                    //
                    // Log the reset.
                    //

                    SpLogResetError(
                        deviceExtension,
                        (logicalUnit->CurrentUntaggedRequest ?
                            logicalUnit->CurrentUntaggedRequest->CurrentSrb :
                            NULL),
                        ('P'<<24) | 257);
                }

                //
                // List may no longer be valid - restart running the bin.
                //

                goto RestartTimeoutLoop;

            } else if (logicalUnit->RequestTimeoutCounter > 0) {

                //
                // Decrement timeout count.
                //

                logicalUnit->RequestTimeoutCounter--;

            } else if (LU_OPERATING_IN_DEGRADED_STATE(logicalUnit->LuFlags)) {

                //
                // The LU is operating in a degraded performance state.  Update
                // state and restore to full power if conditions permit.
                //

                if (TEST_FLAG(logicalUnit->LuFlags, LU_PERF_MAXQDEPTH_REDUCED)) {

                    //
                    // The LU's maximum queue depth has been reduced because one
                    // or more requests failed with QUEUE FULL status.  If the
                    // adapter is configured to recover from this state it's
                    // RemainInReducedMaxQueueState will be some value other
                    // than the default 0xffffffff.  In this case, we increment
                    // the number of ticks the LU has been in this state and
                    // recover when we've reached the specified period.
                    //

                    if (deviceExtension->RemainInReducedMaxQueueState != 0xffffffff &&
                        ++logicalUnit->TicksInReducedMaxQueueDepthState >=
                        deviceExtension->RemainInReducedMaxQueueState) {

                        CLEAR_FLAG(logicalUnit->LuFlags, LU_PERF_MAXQDEPTH_REDUCED);
                        logicalUnit->MaxQueueDepth = 0xff;

                    }
                }
            }

            logicalUnit = logicalUnit->NextLogicalUnit;
        }

        KeReleaseSpinLockFromDpcLevel(&bin->Lock);
    }

    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

    //
    // Check to see if there are any requests waiting for memory to free up.
    //

    do {
        PLIST_ENTRY entry;
        PIRP request;
        PSRB_DATA srbData;
        BOOLEAN listIsEmpty;

        //
        // Grab the spinlock long enough to pull a request off the queue.
        // The spinlock needs to be released when we're allocating
        // memory.
        //

        KeAcquireSpinLockAtDpcLevel(
            &deviceExtension->EmergencySrbDataSpinLock);

        if(IsListEmpty(&deviceExtension->SrbDataBlockedRequests)) {
            entry = NULL;
        } else {
            entry = RemoveHeadList(&(deviceExtension->SrbDataBlockedRequests));
        }

        KeReleaseSpinLockFromDpcLevel(
            &deviceExtension->EmergencySrbDataSpinLock);

        if(entry == NULL) {
            break;
        }

        request = CONTAINING_RECORD(
                    entry,
                    IRP,
                    Tail.Overlay.DeviceQueueEntry);

        ASSERT(request->Type == IO_TYPE_IRP);

        //
        // See if we can get an SRB_DATA for this request.  This will
        // requeue the request if there's still not enough free memory.
        //

        srbData = SpAllocateSrbData(deviceExtension,
                                    request);

        if(srbData != NULL) {

            PLOGICAL_UNIT_EXTENSION luExtension;
            PIO_STACK_LOCATION currentIrpStack;
            PSCSI_REQUEST_BLOCK srb;

            currentIrpStack = IoGetCurrentIrpStackLocation(request);
            srb = currentIrpStack->Parameters.Scsi.Srb;
            luExtension = currentIrpStack->DeviceObject->DeviceExtension;

            ASSERT_PDO(currentIrpStack->DeviceObject);

            srbData->CurrentIrp = request;
            srbData->CurrentSrb = srb;
            srbData->LogicalUnit = luExtension;

            srb->OriginalRequest = srbData;

            SpDispatchRequest(currentIrpStack->DeviceObject->DeviceExtension,
                              request);

#if TEST_LISTS
            InterlockedIncrement64(
                &deviceExtension->SrbDataServicedFromTickHandlerCount);
#endif

        } else {
            break;
        }

    } while(TRUE);

    return;

} // end ScsiPortTickHandler()

NTSTATUS
ScsiPortFdoDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the device control dispatcher.

Arguments:

    DeviceObject
    Irp

Return Value:


    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    UCHAR scsiBus;
    NTSTATUS status;

    ULONG isRemoved;

    PAGED_CODE();

    isRemoved = SpAcquireRemoveLock(DeviceObject, Irp);

    if(isRemoved) {
        SpReleaseRemoveLock(DeviceObject, Irp);

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;

        SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);

        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Set the adapter into a valid power state.
    //

    status = SpRequestValidAdapterPowerStateSynchronous(deviceExtension);

    if(!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        SpReleaseRemoveLock(DeviceObject, Irp);
        SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);
        return status;
    }

    //
    // Initialize the information field.
    //

    Irp->IoStatus.Information = 0;

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

        //
        // Get adapter properites.
        //

        case IOCTL_STORAGE_QUERY_PROPERTY: {

            PSTORAGE_PROPERTY_QUERY query = Irp->AssociatedIrp.SystemBuffer;

            if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
               sizeof(STORAGE_PROPERTY_QUERY)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // This routine will release the lock and complete the irp.
            //

            status = ScsiPortQueryProperty(DeviceObject, Irp);
            return status;
            break;
        }

        //
        // Get adapter capabilities.
        //

        case IOCTL_SCSI_GET_CAPABILITIES: {

            //
            // If the output buffer is equal to the size of the a PVOID then just
            // return a pointer to the buffer.
            //

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength
                == sizeof(PVOID)) {

                *((PVOID *)Irp->AssociatedIrp.SystemBuffer)
                    = &deviceExtension->Capabilities;

                Irp->IoStatus.Information = sizeof(PVOID);
                status = STATUS_SUCCESS;
                break;

            }

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength
                < sizeof(IO_SCSI_CAPABILITIES)) {

                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer,
                          &deviceExtension->Capabilities,
                          sizeof(IO_SCSI_CAPABILITIES));

            Irp->IoStatus.Information = sizeof(IO_SCSI_CAPABILITIES);
            status = STATUS_SUCCESS;
            break;
        }

        case IOCTL_SCSI_PASS_THROUGH:
        case IOCTL_SCSI_PASS_THROUGH_DIRECT: {

            status = SpSendPassThrough(deviceExtension, Irp);
            break;
        }

        case IOCTL_SCSI_MINIPORT: {

            status = SpSendMiniPortIoctl( deviceExtension, Irp);
            break;
        }

        case IOCTL_SCSI_GET_INQUIRY_DATA: {

            //
            // Return the inquiry data.
            //

            status = SpGetInquiryData(deviceExtension, Irp);
            break;

        case IOCTL_SCSI_RESCAN_BUS:

            status = SpEnumerateAdapterSynchronous(deviceExtension, FALSE);
            IoInvalidateDeviceRelations(deviceExtension->LowerPdo, BusRelations);

            break;
        }

        case IOCTL_SCSI_GET_DUMP_POINTERS: {

            PPORT_CONFIGURATION_INFORMATION portConfigCopy;

            //
            // Get parameters for crash dump driver.
            //

            if (Irp->RequestorMode != KernelMode) {

                status = STATUS_ACCESS_DENIED;

            } else if (irpStack->Parameters.DeviceIoControl.OutputBufferLength
                       < sizeof(DUMP_POINTERS)) {
                status = STATUS_BUFFER_TOO_SMALL;

            } else {

                PDUMP_POINTERS dumpPointers =
                    (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;

                RtlZeroMemory (dumpPointers, sizeof(DUMP_POINTERS));
                dumpPointers->AdapterObject = (PVOID)
                    deviceExtension->DmaAdapterObject;
                dumpPointers->MappedRegisterBase =
                    &deviceExtension->MappedAddressList;

                portConfigCopy = SpAllocatePool(
                                    NonPagedPool,
                                    sizeof(PORT_CONFIGURATION_INFORMATION),
                                    SCSIPORT_TAG_PORT_CONFIG,
                                    DeviceObject->DriverObject);

                if(portConfigCopy == NULL) {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                RtlCopyMemory(portConfigCopy,
                              deviceExtension->PortConfig,
                              sizeof(PORT_CONFIGURATION_INFORMATION));

                if(deviceExtension->IsInVirtualSlot) {

                    portConfigCopy->SlotNumber =
                        deviceExtension->RealSlotNumber;

                    portConfigCopy->SystemIoBusNumber =
                        deviceExtension->RealBusNumber;

                }

                dumpPointers->DumpData = portConfigCopy;

                dumpPointers->CommonBufferVa = 
                   deviceExtension->SrbExtensionBuffer;
                dumpPointers->CommonBufferPa =
                    deviceExtension->PhysicalCommonBuffer;

                dumpPointers->CommonBufferSize = 
                    SpGetCommonBufferSize(
                        deviceExtension,
                        deviceExtension->NonCachedExtensionSize,
                        NULL);

                dumpPointers->AllocateCommonBuffers = TRUE;

                status = STATUS_SUCCESS;
                Irp->IoStatus.Information = sizeof(DUMP_POINTERS);
            }

            break;
        }

        case IOCTL_STORAGE_RESET_BUS:
        case OBSOLETE_IOCTL_STORAGE_RESET_BUS:
        case IOCTL_STORAGE_BREAK_RESERVATION:   {

            if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
               sizeof(STORAGE_BUS_RESET_REQUEST)) {

                status = STATUS_INVALID_PARAMETER;

            } else {

                //
                // Send an asynchronous srb through to ourself to handle this
                // reset then return.  SpSendReset will take care of completing
                // the request when it's done
                //

                IoMarkIrpPending(Irp);

                status = SpSendReset(DeviceObject, Irp);

                if(!NT_SUCCESS(status)) {
                    DebugPrint((1, "IOCTL_STORAGE_BUS_RESET - error %#08lx "
                                   "from SpSendReset\n",
                                   status));
                }
                return STATUS_PENDING;
            }

            break;
        }

        default: {

            DebugPrint((1,
                       "ScsiPortDeviceControl: Unsupported IOCTL (%x)\n",
                       irpStack->Parameters.DeviceIoControl.IoControlCode));

            status = STATUS_INVALID_DEVICE_REQUEST;

            break;
        }

    } // end switch

    //
    // Set status in Irp.
    //

    Irp->IoStatus.Status = status;

    SpReleaseRemoveLock(DeviceObject, Irp);
    SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);
    return status;

} // end ScsiPortDeviceControl()


BOOLEAN
SpStartIoSynchronized (
    PVOID ServiceContext
    )

/*++

Routine Description:

    This routine calls the dependent driver start io routine.
    It also starts the request timer for the logical unit if necesary and
    inserts the SRB data structure in to the requset list.

Arguments:

    ServiceContext - Supplies the pointer to the device object.

Return Value:

    Returns the value returned by the dependent start I/O routine.

Notes:

    The port driver spinlock must be held when this routine is called.  Holding
    this lock will keep any logical unit bins from being changed as well.

--*/

{
    PDEVICE_OBJECT deviceObject = ServiceContext;
    PADAPTER_EXTENSION deviceExtension =  deviceObject->DeviceExtension;
    PINTERRUPT_DATA interruptData = &(deviceExtension->InterruptData);
    PIO_STACK_LOCATION irpStack;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK srb;
    PSRB_DATA srbData;
    BOOLEAN returnValue;

    DebugPrint((3, "ScsiPortStartIoSynchronized: Enter routine\n"));

    irpStack = IoGetCurrentIrpStackLocation(deviceObject->CurrentIrp);
    srb = irpStack->Parameters.Scsi.Srb;
    srbData = srb->OriginalRequest;

    ASSERT_SRB_DATA(srbData);

    //
    // Get the logical unit extension.
    //

    logicalUnit = srbData->LogicalUnit;

    //
    // Cache the logical unit for complete request calls.
    //

    deviceExtension->CachedLogicalUnit = logicalUnit;

    //
    // Check for a reset hold.  If one is in progress then flag it and return.
    // The timer will reset the current request.  This check should be made
    // before anything else is done.
    //

    if(TEST_FLAG(interruptData->InterruptFlags, PD_ADAPTER_REMOVED)) {

        srb->SrbStatus = SRB_STATUS_NO_HBA;
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE |
                                SRB_FLAGS_BYPASS_FROZEN_QUEUE);

    } else if(TEST_FLAG(interruptData->InterruptFlags, PD_RESET_HOLD)) {
        SET_FLAG(interruptData->InterruptFlags, PD_HELD_REQUEST);
        return(TRUE);
    }

    //
    // Set the device busy flag to indicate it is ok to start the next request.
    //

    deviceExtension->Flags |= PD_DEVICE_IS_BUSY;

    if (srb->SrbFlags & SRB_FLAGS_DISABLE_DISCONNECT) {

        //
        // This request does not allow disconnects. Remember that so
        // no more requests are started until this one completes.
        //

        deviceExtension->Flags &= ~PD_DISCONNECT_RUNNING;
    }

    logicalUnit->QueueCount++;

    //
    // Indicate that there maybe more requests queued, if this is not a bypass
    // request.
    //

    if(!TEST_FLAG(srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE)) {

        logicalUnit->LuFlags |= LU_LOGICAL_UNIT_IS_ACTIVE;

    } else {

        ASSERT(srb->Function != SRB_FUNCTION_ABORT_COMMAND);

        //
        // Any untagged request that bypasses the queue
        // clears the need request sense flag.
        //

        if(SpSrbIsBypassRequest(srb, logicalUnit->LuFlags)) {
            logicalUnit->LuFlags &= ~LU_NEED_REQUEST_SENSE;
        }

        //
        // Set the timeout value in the logical unit.
        //

        logicalUnit->RequestTimeoutCounter = srb->TimeOutValue;
    }

    //
    // Mark the Srb as active.
    //

    srb->SrbFlags |= SRB_FLAGS_IS_ACTIVE;

    //
    // Save away the tick count when we made this active.
    //

    srbData->TickCount = deviceExtension->TickCount;

    //
    // If this request is tagged, insert it into the logical unit
    // request list.  Note that bypass requsts are never never placed on
    // the request list.  In particular ABORT requests which may have
    // a queue tag specified are not placed on the queue.
    //

    if (srb->QueueTag != SP_UNTAGGED) {

        InsertTailList(&logicalUnit->RequestList,
                       &srbData->RequestList);

    } else {

        logicalUnit->CurrentUntaggedRequest = srbData;
    }

    //
    // if the status in the SRB is still pending then we should go ahead and
    // issue this request to to the miniport.  Some error conditions and
    // power requests will mark the srb as successful and then send it through
    // here to clean up and start subsequent requests.  If the status isn't
    // pending then request completion.
    //

    if(srb->SrbStatus != SRB_STATUS_PENDING) {

        DebugPrint((1, "SpStartIoSynchronized: Completeing successful srb "
                       "%#p before miniport\n", srb));

        ScsiPortNotification(RequestComplete,
                             deviceExtension->HwDeviceExtension,
                             srb);

        ScsiPortNotification(NextRequest,
                             deviceExtension->HwDeviceExtension);

        returnValue = srb->SrbStatus;

    } else {

        //
        // Start the port timer.  This ensures that the miniport asks for
        // the next request in a resonable amount of time.
        //

        deviceExtension->PortTimeoutCounter = srb->TimeOutValue;

        //
        // Start the logical unit timer if it is not currently running.
        //

        if (logicalUnit->RequestTimeoutCounter == PD_TIMER_STOPPED) {

            //
            // Set request timeout value from Srb SCSI extension in Irp.
            //

            logicalUnit->RequestTimeoutCounter = srb->TimeOutValue;
        }

        returnValue = deviceExtension->HwStartIo(
                                        deviceExtension->HwDeviceExtension,
                                        srb);
    }

    //
    // Check for miniport work requests.
    //

    if (TEST_FLAG(interruptData->InterruptFlags, PD_NOTIFICATION_REQUIRED)) {

        SpRequestCompletionDpc(deviceObject);
    }

    return returnValue;

} // end SpStartIoSynchronized()


BOOLEAN
SpTimeoutSynchronized (
    PVOID ServiceContext
    )

/*++

Routine Description:

    This routine handles a port timeout.  There are two reason these can occur
    either because of a reset hold or a time out waiting for a read for next
    request notification.  If a reset hold completes, then any held request
    must be started.  If a timeout occurs, then the bus must be reset.

Arguments:

    ServiceContext - Supplies the pointer to the device object.

Return Value:

    TRUE - If a timeout error should be logged.

Notes:

    The port driver spinlock must be held when this routine is called.

--*/

{
    PDEVICE_OBJECT deviceObject = ServiceContext;
    PADAPTER_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    PINTERRUPT_DATA interruptData = &(deviceExtension->InterruptData);
    BOOLEAN result;

    DebugPrint((3, "SpTimeoutSynchronized: Enter routine\n"));

    //
    // Make sure the timer is stopped.
    //

    deviceExtension->PortTimeoutCounter = PD_TIMER_STOPPED;

    //
    // Check for a reset hold.  If one is in progress then clear it and check
    // for a pending held request
    //

    if (TEST_FLAG(interruptData->InterruptFlags, PD_RESET_HOLD)) {

        CLEAR_FLAG(interruptData->InterruptFlags, PD_RESET_HOLD);

        //
        // If verifier is enabled, make sure the miniport has completed all
        // outstanding requests in the reset hold period.
        //

        if (SpVerifierActive(deviceExtension)) {
            SpEnsureAllRequestsAreComplete(deviceExtension);
        }

        if (TEST_FLAG(interruptData->InterruptFlags, PD_HELD_REQUEST)) {

            //
            // Clear the held request flag and restart the request.
            //

            CLEAR_FLAG(interruptData->InterruptFlags, PD_HELD_REQUEST);
            SpStartIoSynchronized(ServiceContext);
        }

        result = FALSE;

    } else {

        RESET_CONTEXT resetContext;
        BOOLEAN interrupt;
        ULONG interruptCount;

        resetContext.DeviceExtension = deviceExtension;

        //
        // Make a call into the miniport's interrupt routine.  If it says that
        // there's an interrupt pending then break in.
        //

        ASSERT(!TEST_FLAG(interruptData->InterruptFlags,
                          PD_DISABLE_INTERRUPTS));

        if (!TEST_FLAG(interruptData->InterruptFlags, PD_ADAPTER_REMOVED)) {

            interruptCount = deviceExtension->WatchdogInterruptCount;
            deviceExtension->WatchdogInterruptCount = 0;

            if((interruptCount == 0) &&
               (deviceExtension->HwInterrupt != NULL)) {

                interrupt = deviceExtension->HwInterrupt(
                                deviceExtension->HwDeviceExtension);

                if(interrupt) {

                    DbgPrint("SpTimeoutSynchronized: Adapter %#p had interrupt "
                             "pending - the system may not be delivering "
                             "interrupts from this adapter\n",
                             deviceObject);

                    if(ScsiCheckInterrupts) {
                        DbgBreakPoint();
                    }

                    SET_FLAG(interruptData->InterruptFlags,
                             PD_INTERRUPT_FAILURE | PD_NOTIFICATION_REQUIRED);
                    SpRequestCompletionDpc(deviceObject);
                }
            }
        }

        //
        // Miniport is hung and not accepting new requests. So reset the
        // bus to clear things up.
        //

        DebugPrint((1, "SpTimeoutSynchronized: Next request timed out. "
                       "Resetting bus\n"));

        for(resetContext.PathId = 0;
            resetContext.PathId < deviceExtension->NumberOfBuses;
            resetContext.PathId++) {

            result = SpResetBusSynchronized(&resetContext);
        }
    }

    return(result);

} // end SpTimeoutSynchronized()

BOOLEAN
SpEnableInterruptSynchronized (
    PVOID ServiceContext
    )

/*++

Routine Description:

    This routine calls the miniport request routine with interrupts disabled.
    This is used by the miniport driver to enable interrupts on the adapter.
    This routine clears the disable interrupt flag which prevents the
    miniport interrupt routine from being called.

Arguments:

    ServiceContext - Supplies the pointer to the device extension.

Return Value:

    TRUE - Always.

Notes:

    The port driver spinlock must be held when this routine is called.

--*/

{
    PADAPTER_EXTENSION deviceExtension =  ServiceContext;
    PINTERRUPT_DATA interruptData = &(deviceExtension->InterruptData);

    //
    // Clear the interrupt disable flag.
    //

    CLEAR_FLAG(interruptData->InterruptFlags, PD_DISABLE_INTERRUPTS);

    if(TEST_FLAG(interruptData->InterruptFlags, PD_ADAPTER_REMOVED)) {
        return FALSE;
    }

    //
    // Call the miniport routine.
    //

    deviceExtension->HwRequestInterrupt(deviceExtension->HwDeviceExtension);

    if(TEST_FLAG(interruptData->InterruptFlags, PD_NOTIFICATION_REQUIRED)) {

        SpRequestCompletionDpc(deviceExtension->CommonExtension.DeviceObject);

    }

    return(TRUE);

} // end SpEnableInterruptSynchronized()

VOID
IssueRequestSense(
    IN PADAPTER_EXTENSION Adapter,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    )

/*++

Routine Description:

    This routine creates a REQUEST SENSE request and uses IoCallDriver to
    renter the driver.  The completion routine cleans up the data structures
    and processes the logical unit queue according to the flags.

    A pointer to failing SRB is stored at the end of the request sense
    Srb, so that the completion routine can find it.

    This routine must be called holding the remove lock.

Arguments:

    DeviceExension - Supplies a pointer to the device extension for this
        SCSI port.

    FailingSrb - Supplies a pointer to the request that the request sense
        is being done for.

Return Value:

    None.

--*/

{
    PSRB_DATA srbData;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    BOOLEAN blocked;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    DebugPrint((3,"IssueRequestSense: Enter routine\n"));

    //
    // Find the logical unit for this request and see if there's already a
    // request sense in progress.
    //

    srbData = FailingSrb->OriginalRequest;

    ASSERT_SRB_DATA(srbData);

    logicalUnit = srbData->LogicalUnit;

    KeAcquireSpinLockAtDpcLevel(&(logicalUnit->AdapterExtension->SpinLock));

    //
    // If we already have an active failed request then block this one -
    // the completion routine will issue a new request sense irp when this
    // one is run.
    //

    if(logicalUnit->ActiveFailedRequest == srbData) {
        blocked = FALSE;
    } else if(logicalUnit->BlockedFailedRequest == srbData) {
        blocked = TRUE;
    } else {
        DbgPrint("Scsiport: unexpected request sense for srb %#08lx\n", FailingSrb);
        ASSERT(FALSE);
    }

    KeReleaseSpinLockFromDpcLevel(&(logicalUnit->AdapterExtension->SpinLock));

    if(blocked == FALSE) {
        SpSendRequestSenseIrp(Adapter,
                              logicalUnit,
                              FailingSrb);
    }

    return;

} // end IssueRequestSense()


VOID
SpSendRequestSenseIrp(
    IN PADAPTER_EXTENSION Adapter,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    )

/*++

Routine Description:

    This routine creates a REQUEST SENSE request and uses IoCallDriver to
    renter the driver.  The completion routine cleans up the data structures
    and processes the logical unit queue according to the flags.

    This routine must be called holding the remove lock.  The caller must also
    ensure that no other failed request is using the preallocated resources in
    the LogicalUnit extension.

Arguments:

    Adapter - Supplies a pointer to the device extension for this SCSI port.

    LogicalUnit - Supplies a pointer to logical unit on which the CA condition
                  exists.  This extension contains the resources used to send
                  the REQUEST_SENSE irp.

    FailingSrb - the request which failed.  the sense info buffer, address
                 info and flags are pulled out of this request.

Return Value:

    None.

--*/

{
    PIRP irp;
    PSCSI_REQUEST_BLOCK srb;
    PMDL mdl;

    PIO_STACK_LOCATION irpStack;
    PCDB cdb;
    PVOID *pointer;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    DebugPrint((3,"SpSendRequestSenseIrp: Enter routine\n"));

    //
    // Check if we are being asked to try to allocate a sense buffer of 
    // the correct size for the adapter.  If the allocation fails, just 
    // use the one passed down to us.  The driver that supplied the buffer 
    // is responsible for freeing the one we allocate.
    //

    if (FailingSrb->SrbFlags & SRB_FLAGS_PORT_DRIVER_ALLOCSENSE) {

        ULONG BufferSize;
        PSENSE_DATA SenseBuffer;
        UCHAR SenseBufferLength;
        
        SenseBufferLength = sizeof(SENSE_DATA) 
                            + Adapter->AdditionalSenseBytes;

        //
        // Include space for the scsi port number in the buffer,
        // aligned on a 4-byte boundary.  In checked builds, a signature
        // will precede the port number.
        //

        BufferSize = (SenseBufferLength + 3) & ~3;
        BufferSize = SenseBufferLength + sizeof(ULONG64);
        
        SenseBuffer = SpAllocatePool(NonPagedPoolCacheAligned,
                                     BufferSize,
                                     SCSIPORT_TAG_SENSE_BUFFER,
                                     Adapter->DeviceObject->DriverObject);

        if (SenseBuffer != NULL) {
        
            PULONG PortNumber;

            //
            // Set a flag in the SRB to indicate that we have allocated
            // a new sense buffer and that the class driver must free
            // it.
            //

            SET_FLAG(FailingSrb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER);

            //
            // Set a flag in the SRB the indicates we are storing the
            // scsi port number at the end of the sense buffer.
            //

            SET_FLAG(FailingSrb->SrbFlags, SRB_FLAGS_PORT_DRIVER_SENSEHASPORT);

            //
            // Copy the port number in the buffer.
            //

            PortNumber = (PULONG)((PUCHAR)SenseBuffer + SenseBufferLength);
            PortNumber = (PULONG)(((ULONG_PTR)PortNumber + 3) & ~3);
            *PortNumber = Adapter->PortNumber;

            FailingSrb->SenseInfoBuffer = SenseBuffer;
            FailingSrb->SenseInfoBufferLength = SenseBufferLength;
        }
    }

    irp = LogicalUnit->RequestSenseIrp;
    srb = &(LogicalUnit->RequestSenseSrb);
    mdl = &(LogicalUnit->RequestSenseMdl);

    IoInitializeIrp(irp, IoSizeOfIrp(1), 1);

    MmInitializeMdl(mdl,
                    FailingSrb->SenseInfoBuffer,
                    FailingSrb->SenseInfoBufferLength);

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // The sense buffer had better be from non-pagable kernel memory.
    //

    MmBuildMdlForNonPagedPool(mdl);

    irp->MdlAddress = mdl;

    IoSetCompletionRoutine(irp,
                           IssueRequestSenseCompletion,
                           LogicalUnit,
                           TRUE,
                           TRUE,
                           TRUE);

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->MinorFunction = 1;

    //
    // Build the REQUEST SENSE CDB.
    //

    srb->CdbLength = 6;
    cdb = (PCDB)srb->Cdb;

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
    cdb->CDB6INQUIRY.LogicalUnitNumber = 0;
    cdb->CDB6INQUIRY.Reserved1 = 0;
    cdb->CDB6INQUIRY.PageCode = 0;
    cdb->CDB6INQUIRY.IReserved = 0;
    cdb->CDB6INQUIRY.AllocationLength = FailingSrb->SenseInfoBufferLength;
    cdb->CDB6INQUIRY.Control = 0;

    //
    // Save SRB address in next stack for port driver.
    //

    irpStack->Parameters.Scsi.Srb = srb;

    //
    // Set up IRP Address.
    //

    srb->OriginalRequest = irp;

    //
    // Set up SCSI bus address.
    //

    srb->TargetId = LogicalUnit->TargetId;
    srb->Lun = LogicalUnit->Lun;
    srb->PathId = LogicalUnit->PathId;

    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->Length = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set timeout value.  Default is 2 seconds, but it's configurable.
    //

    srb->TimeOutValue = Adapter->RequestSenseTimeout;

    //
    // Disable auto request sense.
    //

    srb->SenseInfoBufferLength = 0;

    //
    // Sense buffer is in stack.
    //

    srb->SenseInfoBuffer = NULL;

    //
    // Set read and bypass frozen queue bits in flags.
    //

    //
    // Set SRB flags to indicate the logical unit queue should be by
    // passed and that no queue processing should be done when the request
    // completes.  Also disable disconnect and synchronous data
    // transfer if necessary.
    //

    srb->SrbFlags = SRB_FLAGS_DATA_IN |
                    SRB_FLAGS_BYPASS_FROZEN_QUEUE |
                    SRB_FLAGS_DISABLE_DISCONNECT;


    if(TEST_FLAG(FailingSrb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE)) {
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE);
    }

    if (TEST_FLAG(FailingSrb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE)) {
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE);
    }

    if (TEST_FLAG(FailingSrb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER)) {
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
    }

    srb->DataBuffer = FailingSrb->SenseInfoBuffer;

    //
    // Set the transfer length.
    //

    srb->DataTransferLength = FailingSrb->SenseInfoBufferLength;

    //
    // Zero out status.
    //

    srb->ScsiStatus = srb->SrbStatus = 0;

    srb->NextSrb = 0;

    IoCallDriver(LogicalUnit->DeviceObject, irp);

    return;

} // end SpSendRequestSenseIrp()


NTSTATUS
IssueRequestSenseCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PLOGICAL_UNIT_EXTENSION LogicalUnit
    )

/*++

Routine Description:

Arguments:

    Device object
    IRP
    Context - pointer to SRB

Return Value:

    NTSTATUS

--*/

{
    PSCSI_REQUEST_BLOCK srb = &(LogicalUnit->RequestSenseSrb);
    PSRB_DATA failingSrbData = LogicalUnit->ActiveFailedRequest;
    PSCSI_REQUEST_BLOCK failingSrb;
    PIRP failingIrp;
    PDEVICE_OBJECT deviceObject;
    KIRQL oldIrql;
    BOOLEAN needRequestSense;

    UNREFERENCED_PARAMETER(DeviceObject);

    DebugPrint((3,"IssueRequestSenseCompletion: Enter routine\n"));

    //
    // Request sense completed. If successful or data over/underrun
    // get the failing SRB and indicate that the sense information
    // is valid. The class driver will check for underrun and determine
    // if there is enough sense information to be useful.
    //

    //
    // Get a pointer to failing Irp and Srb.
    //

    ASSERT_SRB_DATA(failingSrbData);
    failingSrb = failingSrbData->CurrentSrb;
    failingIrp = failingSrbData->CurrentIrp;
    deviceObject = LogicalUnit->AdapterExtension->DeviceObject;

    if(failingIrp->PendingReturned) {
        IoMarkIrpPending(failingIrp);
    }

    ASSERT(Irp->IoStatus.Status != STATUS_INSUFFICIENT_RESOURCES);

    if ((SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS) ||
        (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN)) {

        //
        // Report sense buffer is valid.
        //

        failingSrb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;

        //
        // Copy bytes transferred to failing SRB
        // request sense length field to communicate
        // to the class drivers the number of valid
        // sense bytes.
        //

        failingSrb->SenseInfoBufferLength = (UCHAR) srb->DataTransferLength;

        //
        // If WMI Sense Data events are enabled for this adapter, fire
        // the event.
        //

        if (LogicalUnit->AdapterExtension->EnableSenseDataEvent) {

            NTSTATUS status;

            status = SpFireSenseDataEvent(failingSrb, deviceObject);
            if (status != STATUS_SUCCESS) {

                DebugPrint((1, "Failed to send SenseData WMI event (%08X)\n", status));

            }                
        }
    }

    //
    // If the failing SRB had the no queue freeze flag set then unfreeze the
    // queue.
    //

    if(TEST_FLAG(failingSrb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE) &&
       TEST_FLAG(failingSrb->SrbStatus, SRB_STATUS_QUEUE_FROZEN)) {

        //
        // Now release the queue.
        //

        SpFlushReleaseQueue(LogicalUnit, FALSE);
        CLEAR_FLAG(failingSrb->SrbStatus, SRB_STATUS_QUEUE_FROZEN);
    }

    //
    // Clear the active request.  Promote the blocked request (if any) and
    // send out a new request sense if necessary.
    //

    KeAcquireSpinLock(&(LogicalUnit->AdapterExtension->SpinLock), &oldIrql);

    LogicalUnit->ActiveFailedRequest = LogicalUnit->BlockedFailedRequest;
    LogicalUnit->BlockedFailedRequest = NULL;
    needRequestSense = (LogicalUnit->ActiveFailedRequest != NULL);

    KeReleaseSpinLock(&(LogicalUnit->AdapterExtension->SpinLock), oldIrql);

    //
    // Complete the failing request.
    //

    SpReleaseRemoveLock(deviceObject, failingIrp);
    SpCompleteRequest(deviceObject,
                      failingIrp,
                      failingSrbData,
                      IO_DISK_INCREMENT);

    //
    // Reinitialize all the data structures.
    //

    MmPrepareMdlForReuse(&(LogicalUnit->RequestSenseMdl));

    //
    // Since we promoted the blocked request up we can test the active
    // request pointer without holding the spinlock.  Once that's been written
    // in there no one can modify it unless they're completing a request
    // sense irp and we've got the only one right here.
    //

    if(needRequestSense) {

        SpSendRequestSenseIrp(LogicalUnit->AdapterExtension,
                              LogicalUnit,
                              LogicalUnit->ActiveFailedRequest->CurrentSrb);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;

} // ScsiPortInternalCompletion()

#if DBG
VOID
SpDetectCycleInCompletedRequestList(
    IN PINTERRUPT_CONTEXT InterruptContext
    )
{
    PSRB_DATA s1, s2;

    DebugPrint((0, "SpDetectCycleInCompletedRequestList: context %p\n", 
                InterruptContext));

    //
    // Initialize two pointers to the head of the list.
    //

    s1 = s2 = InterruptContext->SavedInterruptData->CompletedRequests;

    //
    // We know the list is not empty so there is no need to check for that 
    // case.  The scan will end when either the end of the list is found or 
    // both pointers point to the same item.
    //

    for (;;) {

        //
        // Update the pointers.
        //

        s1 = s1->CompletedRequests;
        s2 = s2->CompletedRequests;
        if (s2 != NULL) {
            s2 = s2->CompletedRequests;
        }

        //
        // If we've found the end of the list, we're done.
        //

        if (s2 == NULL) {
            break;
        }

        //
        // If both pointers point to the same item, we've found a cycle.
        //

        if (s1 == s2) {
            KeBugCheckEx(PORT_DRIVER_INTERNAL,
                         5,
                         STATUS_INTERNAL_ERROR,
                         (ULONG_PTR) InterruptContext,
                         (ULONG_PTR) 0);
        }
    }
}
#endif


BOOLEAN
SpGetInterruptState(
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This routine saves the InterruptFlags, MapTransferParameters and
    CompletedRequests fields and clears the InterruptFlags.

    This routine also removes the request from the logical unit queue if it is
    tag.  Finally the request time is updated.

Arguments:

    ServiceContext - Supplies a pointer to the interrupt context which contains
        pointers to the interrupt data and where to save it.

Return Value:

    Returns TURE if there is new work and FALSE otherwise.

Notes:

    Called via KeSynchronizeExecution with the port device extension spinlock
    held.

--*/
{
    PINTERRUPT_CONTEXT      interruptContext = ServiceContext;
    ULONG                   limit = 0;
    PADAPTER_EXTENSION       deviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK     srb;
    PSRB_DATA               srbData;
    PSRB_DATA               nextSrbData;
    BOOLEAN                 isTimed;

    deviceExtension = interruptContext->DeviceExtension;

    //
    // Check for pending work.
    //

    if (!(deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED)) {

        //
        // We scheduled a DPC (turned on the PD_NOTIFICATION_REQUIRED bit in
        // the adapter extension's DpcFlags) while the DPC routine was
        // running.  Clear the bit before returning to prevent the completion
        // DPC routine from spinning forever.  The only bit we leave set is
        // PD_DPC_RUNNING.
        //

        deviceExtension->DpcFlags &= PD_DPC_RUNNING;

        return(FALSE);
    }

    //
    // Move the interrupt state to save area.
    //

    *interruptContext->SavedInterruptData = deviceExtension->InterruptData;

    //
    // Clear the interrupt state.
    //

    deviceExtension->InterruptData.InterruptFlags &= PD_INTERRUPT_FLAG_MASK;
    deviceExtension->InterruptData.CompletedRequests = NULL;
    deviceExtension->InterruptData.ReadyLogicalUnit = NULL;
    deviceExtension->InterruptData.CompletedAbort = NULL;
    deviceExtension->InterruptData.WmiMiniPortRequests = NULL;

    //
    // Clear the notification required bit in the DPC flags.
    //

    {
        ULONG oldDpcFlags = 0;

        //
        // If we've been called then the DPC is obviously running.
        //

        oldDpcFlags = (ULONG) InterlockedExchange(&(deviceExtension->DpcFlags),
                                                  PD_DPC_RUNNING);

        //
        // If we got this far then these two flags must have been set.
        //

        ASSERT(oldDpcFlags == (PD_NOTIFICATION_REQUIRED | PD_DPC_RUNNING));
    }

    srbData = interruptContext->SavedInterruptData->CompletedRequests;

    while (srbData != NULL) {

#if DBG
        BOOLEAN alreadyChecked = FALSE;

        //
        // Look for a cycle in the completed request list.  Only need to check 
        // once because the list is static for the duration of this routine.
        //

        if (limit++ > (ULONG)deviceExtension->ActiveRequestCount &&
            alreadyChecked == FALSE) {

            alreadyChecked = TRUE;

            SpDetectCycleInCompletedRequestList(interruptContext);
        }
#endif // DBG

        ASSERT(srbData->CurrentSrb != NULL);

        //
        // Get a pointer to the SRB and the logical unit extension.
        //

        srb = srbData->CurrentSrb;

        ASSERT(!TEST_FLAG(srb->SrbFlags, SRB_FLAGS_IS_ACTIVE));

        logicalUnit = srbData->LogicalUnit;

#if DBG
        {
            PLOGICAL_UNIT_EXTENSION tmp;

            tmp = GetLogicalUnitExtension(
                    (PADAPTER_EXTENSION) deviceExtension,
                    srb->PathId,
                    srb->TargetId,
                    srb->Lun,
                    FALSE,
                    FALSE);

            ASSERT(logicalUnit == srbData->LogicalUnit);
        }
#endif

        //
        // If the request did not succeed, then check for the special cases.
        //

        if (srb->SrbStatus != SRB_STATUS_SUCCESS) {

            //
            // If this request failed and a REQUEST SENSE command needs to
            // be done, then set a flag to indicate this and prevent other
            // commands from being started.
            //

            if (NEED_REQUEST_SENSE(srb)) {

                if (logicalUnit->LuFlags & LU_NEED_REQUEST_SENSE) {

                    //
                    // This implies that requests have completed with a
                    // status of check condition before a REQUEST SENSE
                    // command could be performed.  This should never occur.
                    // Convert the request to another code so that only one
                    // auto request sense is issued.
                    //

                    srb->ScsiStatus = 0;
                    srb->SrbStatus = SRB_STATUS_REQUEST_SENSE_FAILED;

                } else {

                    //
                    // Indicate that an auto request sense needs to be done.
                    //

                    logicalUnit->LuFlags |= LU_NEED_REQUEST_SENSE;

                    //
                    // Save a pointer to the failed request away somewhere.
                    // Caller is holding the port spinlock which is used to
                    // protect these pointers.
                    //

                    ASSERTMSG("Scsiport has more than two failed requests: ",
                              ((logicalUnit->ActiveFailedRequest == NULL) ||
                               (logicalUnit->BlockedFailedRequest == NULL)));

                    ASSERTMSG("Scsiport has blocked but no active failed request: ",
                              (((logicalUnit->ActiveFailedRequest == NULL) &&
                                (logicalUnit->BlockedFailedRequest == NULL)) ||
                               (logicalUnit->ActiveFailedRequest != NULL)));

                    if(logicalUnit->ActiveFailedRequest == NULL) {
                        logicalUnit->ActiveFailedRequest = srbData;
                    } else {
                        logicalUnit->BlockedFailedRequest = srbData;
                    }
                }
            }

            //
            // Check for a QUEUE FULL status.
            //

            if (srb->ScsiStatus == SCSISTAT_QUEUE_FULL) {

                //
                // Set the queue full flag in the logical unit to prevent
                // any new requests from being started.
                //

                logicalUnit->LuFlags |= LU_QUEUE_IS_FULL;

                //
                // Assert to catch queue full condition when there are
                // no requests.
                //

                ASSERT(logicalUnit->QueueCount);

                //
                // Update the maximum queue depth.
                //

                if (logicalUnit->QueueCount < logicalUnit->MaxQueueDepth &&
                    logicalUnit->QueueCount > 2) {

                    //
                    // Set a bit to indicate that we are operating below full
                    // power.  The tick handler will increment a counter every
                    // second we're in this state until which we reach a
                    // tunable value that restores us to full power.
                    //

                    logicalUnit->LuFlags |= LU_PERF_MAXQDEPTH_REDUCED;

                    logicalUnit->MaxQueueDepth = logicalUnit->QueueCount - 1;

                    DebugPrint((1, "SpGetInterruptState: New queue depth %d.\n",
                                logicalUnit->MaxQueueDepth));
                }

                //
                // Reset the number of ticks the LU has been in a reduced
                // performance state due to QUEUE FULL conditions.  This has the
                // effect of keeping us in this state.
                //

                logicalUnit->TicksInReducedMaxQueueDepthState = 0;
                
            }
        }

        //
        // If this is an unqueued request or a request at the head of the queue,
        // then the requset timer count must be updated.
        // Note that the spinlock is held at this time.
        //

        if (srb->QueueTag == SP_UNTAGGED) {

            isTimed = TRUE;

        } else {

            if (logicalUnit->RequestList.Flink == &srbData->RequestList) {

                isTimed = TRUE;

            } else {

                isTimed = FALSE;

            }

            //
            // Remove the SRB data structure from the queue.
            //

            RemoveEntryList(&srbData->RequestList);
        }

        if (isTimed) {

            //
            // The request timeout count needs to be updated.  If the request
            // list is empty then the timer should be stopped.
            //

            if (IsListEmpty(&logicalUnit->RequestList)) {

                logicalUnit->RequestTimeoutCounter = PD_TIMER_STOPPED;

            } else {

                //
                // Start timing the srb at the head of the list.
                //

                nextSrbData = CONTAINING_RECORD(
                    logicalUnit->RequestList.Flink,
                    SRB_DATA,
                    RequestList);

                 srb = nextSrbData->CurrentSrb;
                 logicalUnit->RequestTimeoutCounter = srb->TimeOutValue;
            }
        }

        srbData = srbData->CompletedRequests;
    }

    return(TRUE);
}

#if DBG

PLOGICAL_UNIT_EXTENSION
GetLogicalUnitExtensionEx(
    PADAPTER_EXTENSION deviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    PVOID LockTag,
    BOOLEAN AcquireBinLock,
    PCSTR File,
    ULONG Line
    )

/*++

Routine Description:

    Walk logical unit extension list looking for
    extension with matching target id.

Arguments:

    deviceExtension
    TargetId

Return Value:

    Requested logical unit extension if found,
    else NULL.

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit;

    PLOGICAL_UNIT_BIN bin;
    PLOGICAL_UNIT_EXTENSION foundMatch = NULL;

    KIRQL oldIrql;

    if (TargetId >= deviceExtension->MaximumTargetIds) {
        return NULL;
    }

    bin =
        &deviceExtension->LogicalUnitList[ADDRESS_TO_HASH(PathId,
                                                          TargetId,
                                                          Lun)];

    if(AcquireBinLock) {
        KeAcquireSpinLock(&bin->Lock, &oldIrql);
    }

    logicalUnit = bin->List;

    while (logicalUnit != NULL) {

        if ((logicalUnit->TargetId == TargetId) &&
            (logicalUnit->PathId == PathId) &&
            (logicalUnit->Lun == Lun)) {

            if(foundMatch != NULL) {

                DebugPrint((0, "GetLogicalUnitExtension: Found duplicate for "
                               "(%d,%d,%d) in list: %#08lx %s & %#08lx %s\n",
                               PathId, TargetId, Lun,
                               foundMatch, (foundMatch->IsMissing) ? "missing" : "",
                               logicalUnit, (logicalUnit->IsMissing) ? "missing" : ""));
                ASSERTMSG("Duplicate found in lun list - this is bad\n", FALSE);
            }

            foundMatch = logicalUnit;
        }

        logicalUnit = logicalUnit->NextLogicalUnit;
    }

    if((ARGUMENT_PRESENT(LockTag)) && (foundMatch != NULL)) {

        SpAcquireRemoveLockEx(foundMatch->CommonExtension.DeviceObject,
                              LockTag,
                              File,
                              Line);
    }

    if(AcquireBinLock) {
        KeReleaseSpinLock(&bin->Lock, oldIrql);
    }
    return foundMatch;

} // end GetLogicalUnitExtension()
#else

PLOGICAL_UNIT_EXTENSION
GetLogicalUnitExtension(
    PADAPTER_EXTENSION deviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    PVOID LockTag,
    BOOLEAN AcquireBinLock
    )
{
    PLOGICAL_UNIT_BIN bin;
    PLOGICAL_UNIT_EXTENSION logicalUnit;

    KIRQL oldIrql;

    if (TargetId >= deviceExtension->MaximumTargetIds) {
        return NULL;
    }

    bin = &deviceExtension->LogicalUnitList[ADDRESS_TO_HASH(PathId,
                                                           TargetId,
                                                           Lun)];

    if(AcquireBinLock) {
        KeAcquireSpinLock(&bin->Lock, &oldIrql);
    }

    logicalUnit = bin->List;

    while (logicalUnit != NULL) {

        if ((logicalUnit->TargetId == TargetId) &&
            (logicalUnit->PathId == PathId) &&
            (logicalUnit->Lun == Lun)) {

            if(ARGUMENT_PRESENT(LockTag)) {

                SpAcquireRemoveLock(logicalUnit->CommonExtension.DeviceObject,
                                    LockTag);
            }

            if(AcquireBinLock) {
                KeReleaseSpinLock(&bin->Lock, oldIrql);
            }
            return logicalUnit;
        }

        logicalUnit = logicalUnit->NextLogicalUnit;
    }

    //
    // Logical unit extension not found.
    //

    if(AcquireBinLock) {
        KeReleaseSpinLock(&bin->Lock, oldIrql);
    }

    return NULL;
}
#endif


IO_ALLOCATION_ACTION
ScsiPortAllocationRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is called by IoAllocateAdapterChannel when sufficent resources
    are available to the driver.  This routine saves the MapRegisterBase in the
    device object and starts the currently pending request.

Arguments:

    DeviceObject - Pointer to the device object to which the adapter is being
        allocated.

    Irp - Unused.

    MapRegisterBase - Supplied by the Io subsystem for use in IoMapTransfer.

    Context - Supplies a pointer to the logical unit structure for the next
        current request.


Return Value:

    KeepObject - Indicates the adapter and mapregisters should remain allocated
        after return.

--*/

{
    KIRQL currentIrql;
    PADAPTER_EXTENSION deviceExtension;
    IO_ALLOCATION_ACTION action;

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Initialize the return value.
    //

    action = deviceExtension->PortConfig->Master ?
       DeallocateObjectKeepRegisters : KeepObject;

    //
    // Acquire the spinlock to protect the various structures.
    //

    KeAcquireSpinLock(&deviceExtension->SpinLock, &currentIrql);

    //
    // Save the map register base.
    //

    if (deviceExtension->PortConfig->Master) {

        //
        // Note: ScsiPort considers this device a slave even though it really may 
        //       be a master. I won't go into why this is, but if it is really a 
        //       master, we must free the map registers after the request 
        //       completes, so we'll save the map register base and the number of 
        //       map registers in the per-request SRB_DATA structure.

        PIO_STACK_LOCATION irpStack;
        PSCSI_REQUEST_BLOCK srb;
        PSRB_DATA srbData;

        irpStack = IoGetCurrentIrpStackLocation(DeviceObject->CurrentIrp);
        srb = irpStack->Parameters.Scsi.Srb;
        srbData = srb->OriginalRequest;

        ASSERT_SRB_DATA(srbData);        

        srbData->MapRegisterBase = MapRegisterBase;
        srbData->NumberOfMapRegisters = deviceExtension->Capabilities.MaximumPhysicalPages;

    } else {

        deviceExtension->MapRegisterBase = MapRegisterBase;

    }

    deviceExtension->SynchronizeExecution(
        deviceExtension->InterruptObject,
        SpStartIoSynchronized,
        DeviceObject
        );

    KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);

    return action;
}

#ifdef USE_DMA_MACROS
VOID
SpReceiveScatterGather(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is called by the I/O system when an adapter object and map
    registers have been allocated.  This routine then builds a scatter/gather
    list for use by the miniport driver.  Next it sets the timeout and
    the current Irp for the logical unit.  Finally it calls the miniport
    StartIo routine.  Once that routines complete, this routine will return
    requesting that the adapter be freed and but the registers remain allocated.
    The registers will be freed the request completes.

Arguments:

    DeviceObject - Supplies a pointer to the port driver device object.

    Irp - Supplies a pointer to the current Irp.

    MapRegisterBase - Supplies a context pointer to be used with calls the
        adapter object routines.

    Context - Supplies a pointer to the SRB_DATA structure.

Return Value:

    Returns DeallocateObjectKeepRegisters so that the adapter object can be
        used by other logical units.

--*/

{
    KIRQL               currentIrql;
    PSCSI_REQUEST_BLOCK srb;
    PSRB_DATA           srbData         = Context;
    PADAPTER_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

    srb = srbData->CurrentSrb;

    //
    // Save the MapRegisterBase for later use to deallocate the map registers.
    //

    srbData->MapRegisterBase = ScatterGather;
    srbData->ScatterGatherList = ScatterGather->Elements;

    //
    // See if we need to map or remap the buffer.
    //

    if((deviceExtension->MapBuffers == TRUE) ||
       (IS_MAPPED_SRB(srb) == TRUE)) {

        PMDL mdl = Irp->MdlAddress;

        PVOID systemAddress;
        BOOLEAN remap = FALSE;
        
tryRemapping:
        if(deviceExtension->RemapBuffers || remap == TRUE) {

            //
            // Build an MDL for the actual data area being used for this
            // request.  We're using the data buffer address in the srb
            // as the base, not the one in the original MDL so we don't
            // need to compensate for the DataOffset originally calculated.
            //

            mdl = SpBuildMdlForMappedTransfer(
                    DeviceObject,
                    deviceExtension->DmaAdapterObject,
                    srbData->CurrentIrp->MdlAddress,
                    srb->DataBuffer,
                    srb->DataTransferLength,
                    srbData->ScatterGatherList,
                    ScatterGather->NumberOfElements
                    );

#if defined(FORWARD_PROGRESS)
            if (mdl == NULL && deviceExtension->ReservedMdl != NULL) {
                
                //
                // We could not allocate a new MDL for the request and there is
                // a spare one on the adapter extension.  Let's try to use the 
                // spare.
                //

                KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

                mdl = SpPrepareReservedMdlForUse(deviceExtension,
                                                 srbData,
                                                 srb,
                                                 ScatterGather->NumberOfElements);

                if (mdl == (PMDL)-1) {

                    DebugPrint((1, "SpReceiveScatterGather: reserve mdl in use - pending DevExt:%p srb:%p\n",
                                deviceExtension, srb));

                    //
                    // The spare MDL is already in use.  At this point, this
                    // request is still the current IRP on the adapter device
                    // object, so let's pend it until the spare comes available.
                    //

                    ASSERT(Irp == DeviceObject->CurrentIrp);
                    SET_FLAG(deviceExtension->Flags, PD_PENDING_DEVICE_REQUEST);

                    //
                    // If we allocated an SRB extension for this request, free
                    // it now.  I do this because when the request gets restarted
                    // we'll try to allocate the SRB extension again and without
                    // adding more state, there isn't a safe way to check if the 
                    // extension has already been allocated.  Besides, it makes
                    // sense to make the extension available for some other
                    // request since it also is a limited resource.
                    //

                    if (srb->SrbExtension != NULL) {
                        SpFreeSrbExtension(deviceExtension, srb->SrbExtension);
                    }

            //
            // Free the map registers.
            //

                    PutScatterGatherList(
                        deviceExtension->DmaAdapterObject,
                        srbData->MapRegisterBase,
                        (BOOLEAN)(srb->SrbFlags & SRB_FLAGS_DATA_IN ? FALSE : TRUE));
                    srbData->ScatterGatherList = NULL;

                    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
                    return;
                }

                KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
            }
#endif
            srbData->RemappedMdl = mdl;
        } else {
            srbData->RemappedMdl = NULL;
        }

        if(mdl == NULL) {

            srbData->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;
            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->ScsiStatus = 0xff;
            goto DoneMapping;
        }

        //
        // Get the mapped system address and calculate offset into MDL.
        // At the moment don't allow KernelMode requests to fail since
        // not all scsiport's internally sent requests are correctly
        // marked as comming from non-paged pool.
        //

        if(srbData->RemappedMdl == NULL) {

            //
            // We're using the original data address for the MDL here - we
            // need to compensate for the data offset.
            //

            systemAddress = SpGetSystemAddressForMdlSafe(
                                mdl,
                                ((Irp->RequestorMode == KernelMode) ?
                                 HighPagePriority : NormalPagePriority));

            //
            // If we could not map the entire MDL, check if we are trying to map
            // more than we need.  We do this when class splits the request
            // because each IRP class sends down points to the orignal MDL
            // that describes the entire buffer. The DataBuffer and TransferLength
            // fields of the SRB, however, do represent the current portion of the 
            // buffer. So we try remapping using the info in the SRB.
            //
            
            if (systemAddress == NULL) {
                if (remap == FALSE) {
                    ULONG mdlByteCount = MmGetMdlByteCount(mdl);
                    if (mdlByteCount > srb->DataTransferLength) {
                        remap = TRUE;
                        goto tryRemapping;
                    }
                }
            }
        } else {
            systemAddress = MmMapLockedPagesSpecifyCache(
                                mdl,
                                KernelMode,
                                MmCached,
                                NULL,
                                FALSE,
                                ((Irp->RequestorMode == KernelMode) ?
                                 HighPagePriority :
                                 NormalPagePriority));
        }

#if defined(FORWARD_PROGRESS)
        if (systemAddress == NULL && deviceExtension->ReservedPages != NULL) {            

            //
            // The system could not map the pages necessary to complete this
            // request.  We need to ensure forward progress, so we'll try to
            // use the reserve pages we allocated at initialization time.
            //

            KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);
            
            systemAddress = SpMapLockedPagesWithReservedMapping(
                                deviceExtension,
                                srb,
                                srbData,
                                mdl);

            if (systemAddress == (PVOID)-1) {

                DebugPrint((1, "SpReceiveScatterGather: reserve range in use - pending DevExt:%p srb:%p\n",
                            deviceExtension, srb));

                //
                // The spare pages are already in use.  At this point, this
                // request is still the current IRP on the adapter device
                // object, so let's pend it until the spare comes available.
                //

                ASSERT(Irp == DeviceObject->CurrentIrp);
                SET_FLAG(deviceExtension->Flags, PD_PENDING_DEVICE_REQUEST);

                //
                // If we allocated an SRB extension for this request, free
                // it now.  I do this because when the request gets restarted
                // we'll try to allocate the SRB extension again and without
                // adding more state, there isn't a safe way to check if the 
                // extension has already been allocated.  Besides, it makes
                // sense to make the extension available for some other
                // request since it also is a limited resource.
                //

                if (srb->SrbExtension != NULL) {
                    SpFreeSrbExtension(deviceExtension, srb->SrbExtension);
                }

                //
                // Free the map registers.
                //

                PutScatterGatherList(
                    deviceExtension->DmaAdapterObject,
                    srbData->MapRegisterBase,
                    (BOOLEAN)(srb->SrbFlags & SRB_FLAGS_DATA_IN ? FALSE : TRUE));
                srbData->ScatterGatherList = NULL;
        
                //
                // If we have a remapping MDL, either one we allocated or
                // the reserve, free it.
                //

                if (srbData->RemappedMdl != NULL) {
                    if (TEST_FLAG(srbData->Flags, SRB_DATA_RESERVED_MDL)) {
                        CLEAR_FLAG(srbData->Flags, SRB_DATA_RESERVED_MDL);
                        CLEAR_FLAG(deviceExtension->Flags, PD_RESERVED_MDL_IN_USE);
                    } else {
                        IoFreeMdl(srbData->RemappedMdl);
                    }
                    srbData->RemappedMdl = NULL;
                }

                KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
                return;
                
            }

            KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        }
#endif

        if(systemAddress != NULL) {
            srb->DataBuffer = systemAddress;

            if(srbData->RemappedMdl == NULL) {
                //
                // If we didn't remap the MDL then this system address is
                // based on the original MDL's base address.  Account for the
                // offset of the srb's original data buffer pointer.
                //
                (PUCHAR) srb->DataBuffer += srbData->DataOffset;
            }
        } else {
            DebugPrint((1, "SpReceiveScatterGather: Couldn't get system "
                           "VA for irp 0x%08p\n", Irp));

            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->ScsiStatus = 0xff;
            srbData->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

            //
            // Free the remapped MDL here - this will keep the completion code
            // from trying to unmap memory we never mapped.
            //

            if(srbData->RemappedMdl) {
                IoFreeMdl(srbData->RemappedMdl);
                srbData->RemappedMdl = NULL;
            }
        }
    } else {
        srbData->RemappedMdl = NULL;
    }

DoneMapping:

    //
    // Update the active request count.
    //

    InterlockedIncrement( &deviceExtension->ActiveRequestCount );

    //
    // Acquire the spinlock to protect the various structures.
    //

    KeAcquireSpinLock(&deviceExtension->SpinLock, &currentIrql);

    deviceExtension->SynchronizeExecution(
        deviceExtension->InterruptObject,
        SpStartIoSynchronized,
        DeviceObject
        );

    KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);

}

#else


IO_ALLOCATION_ACTION
SpBuildScatterGather(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is called by the I/O system when an adapter object and map
    registers have been allocated.  This routine then builds a scatter/gather
    list for use by the miniport driver.  Next it sets the timeout and
    the current Irp for the logical unit.  Finally it calls the miniport
    StartIo routine.  Once that routines complete, this routine will return
    requesting that the adapter be freed and but the registers remain allocated.
    The registers will be freed the request completes.

Arguments:

    DeviceObject - Supplies a pointer to the port driver device object.

    Irp - Supplies a pointer to the current Irp.

    MapRegisterBase - Supplies a context pointer to be used with calls the
        adapter object routines.

    Context - Supplies a pointer to the SRB_DATA structure.

Return Value:

    Returns DeallocateObjectKeepRegisters so that the adapter object can be
        used by other logical units.

--*/

{
    BOOLEAN             writeToDevice;
    PSCSI_REQUEST_BLOCK srb;
    PSRB_SCATTER_GATHER scatterList;
    ULONG               scatterListLength = 0;
    PCCHAR              dataVirtualAddress;
    ULONG               totalLength;
    PSRB_DATA           srbData         = Context;
    PADAPTER_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    ULONG               scatterGatherType;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(srbData->CurrentIrp == Irp);

    srb = srbData->CurrentSrb;

    //
    // Determine if scatter/gather list must come from pool.
    //

    ASSERT(srbData->ScatterGatherList == NULL);

    if (srbData->NumberOfMapRegisters <= SP_SMALL_PHYSICAL_BREAK_VALUE) {

        //
        // Use the builtin scatter gather list.
        //

#if DBG
        RtlFillMemory(srbData->SmallScatterGatherList,
                      sizeof(srbData->SmallScatterGatherList),
                      'P');
#endif

        srbData->ScatterGatherList = srbData->SmallScatterGatherList;

        //
        // Indicate the scatter gather list doesn't need to be freed.
        //

        scatterGatherType = SRB_DATA_SMALL_SG_LIST;

    } else if (srbData->NumberOfMapRegisters >= SP_LARGE_PHYSICAL_BREAK_VALUE) {

        //
        // Allocate scatter/gather list from pool.
        //

        srbData->ScatterGatherList = SpAllocatePool(
                                        NonPagedPool,
                                        (srbData->NumberOfMapRegisters * 
                                         sizeof(SRB_SCATTER_GATHER)),
                                        SCSIPORT_TAG_LARGE_SG_ENTRY,
                                        DeviceObject->DriverObject);

#if DBG
        if(srbData->ScatterGatherList != NULL) {
            RtlFillMemory(srbData->ScatterGatherList,
                          sizeof(SRB_SCATTER_GATHER) * srbData->NumberOfMapRegisters,
                          'P');
        }
#endif

        //
        // Indicate scatter gather list came from pool.
        //

        scatterGatherType = SRB_DATA_LARGE_SG_LIST;

    } else {

        //
        // Grab a scatter gather list off the lookaside list.
        //

        srbData->ScatterGatherList =
            ExAllocateFromNPagedLookasideList(
                &deviceExtension->MediumScatterGatherLookasideList);

#if DBG
        if(srbData->ScatterGatherList != NULL) {
            RtlFillMemory(srbData->ScatterGatherList,
                          sizeof(SRB_SCATTER_GATHER) * (SP_LARGE_PHYSICAL_BREAK_VALUE - 1),
                          'P');
        }
#endif

        //
        // Indicate scatter gather list came from lookaside list.
        //

        scatterGatherType = SRB_DATA_MEDIUM_SG_LIST;
    }

    if (srbData->ScatterGatherList != NULL) {

        //
        // Record what type of scatter gather list we're using.
        //

        srbData->Flags |= scatterGatherType;

    #if TEST_LISTS

        {
            ULONG size = srbData->NumberOfMapRegisters;
            deviceExtension->ScatterGatherAllocationCount++;

            switch(scatterGatherType) {
                case SRB_DATA_LARGE_SG_LIST: {

                    deviceExtension->LargeAllocationCount++;
                    deviceExtension->LargeAllocationSize += size;
                    break;
                }

                case SRB_DATA_SMALL_SG_LIST: {
                    deviceExtension->SmallAllocationCount++;
                    deviceExtension->SmallAllocationSize += size;
                    break;
                }

                case SRB_DATA_MEDIUM_SG_LIST: {
                    deviceExtension->MediumAllocationSize += size;
                    break;
                }
            }

        }
    #endif

        scatterList = srbData->ScatterGatherList;
        totalLength = 0;

        //
        // Determine the virtual address of the buffer for the Io map transfers
        // based on the original MDL and the data offset for the SRB.
        //

        dataVirtualAddress = (PCHAR) MmGetMdlVirtualAddress(Irp->MdlAddress);
        dataVirtualAddress += srbData->DataOffset;

        ASSERT(srb->DataBuffer == dataVirtualAddress);

        //
        // Save the MapRegisterBase for later use to deallocate the map registers.
        //

        srbData->MapRegisterBase = MapRegisterBase;

        //
        // Build the scatter/gather list by looping throught the transfer calling
        // I/O map transfer.
        //

        if ((srb->SrbFlags & SRB_FLAGS_DATA_OUT) || 
            (srb->Function == SRB_FUNCTION_IO_CONTROL)) {
            writeToDevice = TRUE;
        } else {
            writeToDevice = FALSE;
        }

        while (totalLength < srb->DataTransferLength) {

            //
            // Request that the rest of the transfer be mapped.
            //

            scatterList->Length = srb->DataTransferLength - totalLength;

            //
            // Since we are a master call I/O map transfer with a NULL adapter.
            //

            scatterList->Address = MapTransfer(deviceExtension->DmaAdapterObject,
                                               Irp->MdlAddress,
                                               MapRegisterBase,
                                               (PCCHAR) dataVirtualAddress + totalLength,
                                               &scatterList->Length,
                                               writeToDevice);

            totalLength += scatterList->Length;
            scatterList++;
            scatterListLength++;
        }
    } else {
        srbData->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;
        srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        srb->ScsiStatus = 0xff;
        goto DoneMapping;
    }

    if((deviceExtension->MapBuffers == TRUE) ||
       (IS_MAPPED_SRB(srb) == TRUE)) {

        PMDL mdl = Irp->MdlAddress;

        PVOID systemAddress;
        BOOLEAN remap = FALSE;

tryRemapping:
        if(deviceExtension->RemapBuffers || remap == TRUE) {

            //
            // Build an MDL for the actual data area being used for this
            // request.  We're using the data buffer address in the srb
            // as the base, not the one in the original MDL so we don't
            // need to compensate for the DataOffset originally calculated.
            //

            mdl = SpBuildMdlForMappedTransfer(
                    DeviceObject,
                    deviceExtension->DmaAdapterObject,
                    srbData->CurrentIrp->MdlAddress,
                    srb->DataBuffer,
                    srb->DataTransferLength,
                    srbData->ScatterGatherList,
                    scatterListLength);

#if defined(FORWARD_PROGRESS)
            if (mdl == NULL && deviceExtension->ReservedMdl != NULL) {
                
                //
                // We could not allocate a new MDL for the request and there is
                // a spare one on the adapter extension.  Let's try to use the 
                // spare.
                //

                KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

                mdl = SpPrepareReservedMdlForUse(deviceExtension,
                                                 srbData,
                                                 srb,
                                                 scatterListLength);

                if (mdl == (PMDL)-1) {

                    DebugPrint((1, "SpBuildScatterGather: reserve MDL in use - pending DevExt:%p srb:%p\n",
                                deviceExtension, srb));

                    //
                    // The spare MDL is already in use.  At this point, this
                    // request is still the current IRP on the adapter device
                    // object, so let's pend it until the spare comes available.
                    //

                    ASSERT(Irp == DeviceObject->CurrentIrp);
                    SET_FLAG(deviceExtension->Flags, PD_PENDING_DEVICE_REQUEST);

                    //
                    // If we allocated an SRB extension for this request, free
                    // it now.  I do this because when the request gets restarted
                    // we'll try to allocate the SRB extension again and without
                    // adding more state, there isn't a safe way to check if the 
                    // extension has already been allocated.  Besides, it makes
                    // sense to make the extension available for some other
                    // request since it also is a limited resource.
                    //

                    if (srb->SrbExtension != NULL) {
                        SpFreeSrbExtension(deviceExtension, srb->SrbExtension);
                    }

                    //
                    // Free the SG list so another request can use it while we're
                    // pending.
                    //

                    if (srbData->ScatterGatherList != NULL) {
                        SpFreeSGList(deviceExtension, srbData);
                    }

                    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
                    return(DeallocateObjectKeepRegisters);
                }

                KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
            }
#endif
            srbData->RemappedMdl = mdl;
        } else {
            srbData->RemappedMdl = NULL;
        }

        if(mdl == NULL) {
            srbData->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;
            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->ScsiStatus = 0xff;
            goto DoneMapping;
        }

        //
        // Get the mapped system address and calculate offset into MDL.
        // At the moment don't allow KernelMode requests to fail since
        // not all scsiport's internally sent requests are correctly
        // marked as comming from non-paged pool.
        //

        if(srbData->RemappedMdl == NULL) {

            //
            // We're using the original data address for the MDL here - we
            // need to compensate for the data offset.
            //

            systemAddress = SpGetSystemAddressForMdlSafe(
                                mdl,
                                ((Irp->RequestorMode == KernelMode) ?
                                 HighPagePriority : NormalPagePriority));

            //
            // If we could not map the entire MDL, check if we are trying to map
            // more than we need.  We do this when class splits the request
            // because each IRP class sends down points to the orignal MDL
            // that describes the entire buffer. The DataBuffer and TransferLength
            // fields of the SRB, however, do represent the current portion of the 
            // buffer. So we try remapping using the info in the SRB.
            //

            if (systemAddress == NULL) {
                if (remap == FALSE) {
                    ULONG mdlByteCount = MmGetMdlByteCount(mdl);
                    if (mdlByteCount > srb->DataTransferLength) {
                        remap = TRUE;
                        goto tryRemapping;
                    }
                }
            }
        } else {
            systemAddress = MmMapLockedPagesSpecifyCache(
                                mdl,
                                KernelMode,
                                MmCached,
                                NULL,
                                FALSE,
                                ((Irp->RequestorMode == KernelMode) ?
                                 HighPagePriority :
                                 NormalPagePriority));
        }

#if defined(FORWARD_PROGRESS)
        if (systemAddress == NULL && deviceExtension->ReservedPages != NULL) {            

            //
            // The system could not map the pages necessary to complete this
            // request.  We need to ensure forward progress, so we'll try to
            // use the reserve pages we allocated at initialization time.
            //

            KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);
            
            systemAddress = SpMapLockedPagesWithReservedMapping(
                                deviceExtension,
                                srb,
                                srbData,
                                mdl);

            if (systemAddress == (PVOID)-1) {

                DebugPrint((1, "SpBuildScatterGather: reserve range in use - pending DevExt:%p srb:%p\n",
                            deviceExtension, srb));

                //
                // The spare pages are already in use.  At this point, this
                // request is still the current IRP on the adapter device
                // object, so let's pend it until the spare comes available.
                //

                ASSERT(Irp == DeviceObject->CurrentIrp);
                SET_FLAG(deviceExtension->Flags, PD_PENDING_DEVICE_REQUEST);

                //
                // If we allocated an SRB extension for this request, free
                // it now.  I do this because when the request gets restarted
                // we'll try to allocate the SRB extension again and without
                // adding more state, there isn't a safe way to check if the 
                // extension has already been allocated.  Besides, it makes
                // sense to make the extension available for some other
                // request since it also is a limited resource.
                //

                if (srb->SrbExtension != NULL) {
                    SpFreeSrbExtension(deviceExtension, srb->SrbExtension);
                }

                //
                // Free the SG list so another request can use it while we're
                // pending.
                //

                if (srbData->ScatterGatherList != NULL) {
                    SpFreeSGList(deviceExtension, srbData);
                }

                //
                // If we have a remapping MDL, either one we allocated or
                // the reserve, free it.
                //

                if (srbData->RemappedMdl != NULL) {
                    if (TEST_FLAG(srbData->Flags, SRB_DATA_RESERVED_MDL)) {
                        CLEAR_FLAG(srbData->Flags, SRB_DATA_RESERVED_MDL);
                        CLEAR_FLAG(deviceExtension->Flags, PD_RESERVED_MDL_IN_USE);
                    } else {
                        IoFreeMdl(srbData->RemappedMdl);
                    }
                    srbData->RemappedMdl = NULL;
                }

                KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
                return(DeallocateObjectKeepRegisters);
                
            }

            KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        }
#endif

        if(systemAddress != NULL) {
            srb->DataBuffer = systemAddress;

            if(srbData->RemappedMdl == NULL) {
                //
                // If we didn't remap the MDL then this system address is
                // based on the original MDL's base address.  Account for the
                // offset of the srb's original data buffer pointer.
                //
                (PUCHAR) srb->DataBuffer += srbData->DataOffset;
            }
        } else {
            DebugPrint((1, "SpBuildScatterGather: Couldn't get system "
                        "VA for irp 0x%08p\n", Irp));

            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->ScsiStatus = 0xff;
            srbData->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

            //
            // Free the remapped MDL here - this will keep the completion code
            // from trying to unmap memory we never mapped.
            //

            if(srbData->RemappedMdl) {
                IoFreeMdl(srbData->RemappedMdl);
                srbData->RemappedMdl = NULL;
            }
        }
    } else {
        srbData->RemappedMdl = NULL;
    }

DoneMapping:

    //
    // Update the active request count.
    //

    InterlockedIncrement( &deviceExtension->ActiveRequestCount );

    //
    // Acquire the spinlock to protect the various structures.
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

    deviceExtension->SynchronizeExecution(
        deviceExtension->InterruptObject,
        SpStartIoSynchronized,
        DeviceObject
        );

    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

    return(DeallocateObjectKeepRegisters);
}
#endif

VOID
LogErrorEntry(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PERROR_LOG_ENTRY LogEntry
    )
/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.

    LogEntry - Supplies a pointer to the scsi port log entry.

Return Value:

    None.

--*/
{
    PIO_ERROR_LOG_PACKET errorLogEntry;

#define ERRLOG_DATA_ENTRIES 4

    errorLogEntry = (PIO_ERROR_LOG_PACKET)
        IoAllocateErrorLogEntry(
            DeviceExtension->CommonExtension.DeviceObject,
            (sizeof(IO_ERROR_LOG_PACKET) +
             (ERRLOG_DATA_ENTRIES * sizeof(ULONG))));

    if (errorLogEntry != NULL) {

        //
        // Translate the miniport error code into the NT I\O driver.
        //

        switch (LogEntry->ErrorCode) {
        case SP_BUS_PARITY_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_PARITY;
            break;

        case SP_UNEXPECTED_DISCONNECT:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_INVALID_RESELECTION:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_BUS_TIME_OUT:
            errorLogEntry->ErrorCode = IO_ERR_TIMEOUT;
            break;

        case SP_PROTOCOL_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_INTERNAL_ADAPTER_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_IRQ_NOT_RESPONDING:
            errorLogEntry->ErrorCode = IO_ERR_INCORRECT_IRQL;
            break;

        case SP_BAD_FW_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_BAD_FIRMWARE;
            break;

        case SP_BAD_FW_WARNING:
            errorLogEntry->ErrorCode = IO_WRN_BAD_FIRMWARE;
            break;

        default:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        }

        errorLogEntry->SequenceNumber = LogEntry->SequenceNumber;
        errorLogEntry->MajorFunctionCode = IRP_MJ_SCSI;
        errorLogEntry->RetryCount = (UCHAR) LogEntry->ErrorLogRetryCount;
        errorLogEntry->UniqueErrorValue = LogEntry->UniqueId;
        errorLogEntry->FinalStatus = STATUS_SUCCESS;
        errorLogEntry->DumpDataSize = ERRLOG_DATA_ENTRIES * sizeof(ULONG);
        errorLogEntry->DumpData[0] = LogEntry->PathId;
        errorLogEntry->DumpData[1] = LogEntry->TargetId;
        errorLogEntry->DumpData[2] = LogEntry->Lun;
        errorLogEntry->DumpData[3] = LogEntry->ErrorCode;
        IoWriteErrorLogEntry(errorLogEntry);

#undef ERRLOG_DATA_ENTRIES

    }

#if SCSIDBG_ENABLED
    {
    PCHAR errorCodeString;

    switch (LogEntry->ErrorCode) {
    case SP_BUS_PARITY_ERROR:
        errorCodeString = "SCSI bus partity error";
        break;

    case SP_UNEXPECTED_DISCONNECT:
        errorCodeString = "Unexpected disconnect";
        break;

    case SP_INVALID_RESELECTION:
        errorCodeString = "Invalid reselection";
        break;

    case SP_BUS_TIME_OUT:
        errorCodeString = "SCSI bus time out";
        break;

    case SP_PROTOCOL_ERROR:
        errorCodeString = "SCSI protocol error";
        break;

    case SP_INTERNAL_ADAPTER_ERROR:
        errorCodeString = "Internal adapter error";
        break;

    default:
        errorCodeString = "Unknown error code";
        break;

    }

    DebugPrint((1,"LogErrorEntry: Logging SCSI error packet. ErrorCode = %s.\n",
        errorCodeString
        ));
    DebugPrint((1,
        "PathId = %2x, TargetId = %2x, Lun = %2x, UniqueId = %x.\n",
        LogEntry->PathId,
        LogEntry->TargetId,
        LogEntry->Lun,
        LogEntry->UniqueId
        ));
    }
#endif
}

VOID
FASTCALL
GetNextLuRequest(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
/*++

Routine Description:

    This routine get the next request for the specified logical unit.  It does
    the necessary initialization to the logical unit structure and submitts the
    request to the device queue.  The DeviceExtension SpinLock must be held
    when this function called.  It is released by this function.

Arguments:

    LogicalUnit - Supplies a pointer to the logical unit extension to get the
        next request from.

Return Value:

     None.

--*/

{
    PADAPTER_EXTENSION DeviceExtension = LogicalUnit->AdapterExtension;
    PKDEVICE_QUEUE_ENTRY packet;
    PIO_STACK_LOCATION   irpStack;
    PSCSI_REQUEST_BLOCK  srb;
    PIRP                 nextIrp;

    //
    // If the active flag is not set, then the queue is not busy or there is
    // a request being processed and the next request should not be started..
    //

    if (!(LogicalUnit->LuFlags & LU_LOGICAL_UNIT_IS_ACTIVE) ||
         (LogicalUnit->QueueCount >= LogicalUnit->MaxQueueDepth)) {

        //
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        return;
    }

    //
    // Check for pending requests, queue full or busy requests.  Pending
    // requests occur when untagged request is started and there are active
    // queued requests. Busy requests occur when the target returns a BUSY
    // or QUEUE FULL status. Busy requests are started by the timer code.
    // Also if the need request sense flag is set, it indicates that
    // an error status was detected on the logical unit.  No new requests
    // should be started until this flag is cleared.  This flag is cleared
    // by an untagged command that by-passes the LU queue i.e.
    //
    // The busy flag and the need request sense flag have the effect of
    // forcing the queue of outstanding requests to drain after an error or
    // until a busy request gets started.
    //

    if (TEST_FLAG(LogicalUnit->LuFlags, (LU_QUEUE_FROZEN |
                                         LU_QUEUE_LOCKED))) {

#if DBG
         DebugPrint((1, "ScsiPort: GetNextLuRequest: Ignoring a get next lu "
                        "call for %#p - \n", LogicalUnit));

         if(TEST_FLAG(LogicalUnit->LuFlags, LU_QUEUE_FROZEN)) {
             DebugPrint((1, "\tQueue is frozen\n"));
         }

         if(TEST_FLAG(LogicalUnit->LuFlags, LU_QUEUE_LOCKED)) {
             DebugPrint((1, "\tQueue is locked\n"));
         }
 #endif

         //
         // Note the active flag is not cleared.  So the next request
         // will be processed when the other requests have completed.
         // Release the spinlock
         //

         KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
         return;
     }

     if (TEST_FLAG(LogicalUnit->LuFlags, LU_PENDING_LU_REQUEST |
                                         LU_LOGICAL_UNIT_IS_BUSY |
                                         LU_QUEUE_IS_FULL |
                                         LU_NEED_REQUEST_SENSE)) {

         //
         // If the request queue is now empty, then the pending request can
         // be started.
         //

         if (IsListEmpty(&LogicalUnit->RequestList) &&
             !TEST_FLAG(LogicalUnit->LuFlags, LU_LOGICAL_UNIT_IS_BUSY |
                                              LU_QUEUE_IS_FULL |
                                              LU_NEED_REQUEST_SENSE)) {
             PSRB_DATA nextSrbData;

             ASSERT(LogicalUnit->CurrentUntaggedRequest == NULL);

             //
             // Clear the pending bit and active flag, release the spinlock,
             // and start the pending request.
             //

             CLEAR_FLAG(LogicalUnit->LuFlags, LU_PENDING_LU_REQUEST |
                                              LU_LOGICAL_UNIT_IS_ACTIVE);

             nextSrbData = LogicalUnit->PendingRequest;
             LogicalUnit->PendingRequest = NULL;
             LogicalUnit->RetryCount = 0;

             //
             // Release the spinlock.
             //

             KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

             nextSrbData->TickCount = DeviceExtension->TickCount;
             IoStartPacket(DeviceExtension->CommonExtension.DeviceObject,
                           nextSrbData->CurrentIrp,
                           (PULONG)NULL,
                           NULL);

             return;

         } else {

             DebugPrint((1, "ScsiPort: GetNextLuRequest:  Ignoring a get next "
                            "lu call.\n"));

             //
             // Note the active flag is not cleared. So the next request
             // will be processed when the other requests have completed.
             // Release the spinlock.
             //

             KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
             return;

         }
     }

     //
     // Clear the active flag.  If there is another request, the flag will be
     // set again when the request is passed to the miniport.
     //

     CLEAR_FLAG(LogicalUnit->LuFlags, LU_LOGICAL_UNIT_IS_ACTIVE);
     LogicalUnit->RetryCount = 0;

     //
     // Remove the packet from the logical unit device queue.  We must use the 
     // IfBusy varient here to work around the trivial case where the queue is
     // not actually busy.
     //
     // If a request is returned with scsi BUSY, the device queue busy flag may 
     // have already been cleared by the miniport requests a get next lu request 
     // in the dispatch routine.  In this case, when the busy request is 
     // reissued, SpStartIoSynchronized will set the LU_ACTIVE flag assuming 
     // this request came out of the queue.  Unfortunately it did not and get 
     // next lu request will foolishly come down here looking for an active 
     // queue and assert on a checked build unless we use the IfBusy varient
     //

     packet = KeRemoveByKeyDeviceQueueIfBusy(
                 &LogicalUnit->CommonExtension.DeviceObject->DeviceQueue,
                 LogicalUnit->CurrentKey);

     if (packet != NULL) {
         PSRB_DATA srbData;

         nextIrp = CONTAINING_RECORD(packet, IRP, Tail.Overlay.DeviceQueueEntry);

         //
         // Set the new current key.
         //

         irpStack = IoGetCurrentIrpStackLocation(nextIrp);
         srb = (PSCSI_REQUEST_BLOCK)irpStack->Parameters.Others.Argument1;
         srbData = (PSRB_DATA) srb->OriginalRequest;

         ASSERT_SRB_DATA(srbData);

         //
         // Hack to work-around the starvation led to by numerous requests
         // touching the same sector.
         //

         LogicalUnit->CurrentKey = srb->QueueSortKey + 1;

         //
         // Release the spinlock.
         //

         KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

         srbData->TickCount = DeviceExtension->TickCount;
         IoStartPacket(DeviceExtension->DeviceObject,
                       nextIrp,
                       NULL,
                       NULL);

     } else {

         //
         // Release the spinlock.
         //

         KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

     }

 } // end GetNextLuRequest()
 
 VOID
 SpLogTimeoutError(
     IN PADAPTER_EXTENSION DeviceExtension,
     IN PIRP Irp,
     IN ULONG UniqueId
     )
 /*++

 Routine Description:

     This function logs an error when a request times out.

 Arguments:

     DeviceExtension - Supplies a pointer to the port device extension.

     Irp - Supplies a pointer to the request which timedout.

     UniqueId - Supplies the UniqueId for this error.

 Return Value:

     None.

 Notes:

     The port device extension spinlock should be held when this routine is
     called.

 --*/

 {
     PIO_ERROR_LOG_PACKET errorLogEntry;
     PIO_STACK_LOCATION   irpStack;
     PSRB_DATA            srbData;
     PSCSI_REQUEST_BLOCK  srb;

     irpStack = IoGetCurrentIrpStackLocation(Irp);
     srb = (PSCSI_REQUEST_BLOCK)irpStack->Parameters.Others.Argument1;
     srbData = srb->OriginalRequest;

     ASSERT_SRB_DATA(srbData);

     if (!srbData) {
         return;
     }

 #define ERRLOG_DATA_ENTRIES 4

     errorLogEntry = (PIO_ERROR_LOG_PACKET)
         IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                 (sizeof(IO_ERROR_LOG_PACKET) +
                                  (ERRLOG_DATA_ENTRIES * sizeof(ULONG))));

     if (errorLogEntry != NULL) {
         errorLogEntry->ErrorCode = IO_ERR_TIMEOUT;
         errorLogEntry->SequenceNumber = srbData->SequenceNumber;
         errorLogEntry->MajorFunctionCode = irpStack->MajorFunction;
         errorLogEntry->RetryCount = (UCHAR) srbData->ErrorLogRetryCount;
         errorLogEntry->UniqueErrorValue = UniqueId;
         errorLogEntry->FinalStatus = STATUS_SUCCESS;
         errorLogEntry->DumpDataSize = ERRLOG_DATA_ENTRIES * sizeof(ULONG);
         errorLogEntry->DumpData[0] = srb->PathId;
         errorLogEntry->DumpData[1] = srb->TargetId;
         errorLogEntry->DumpData[2] = srb->Lun;
         errorLogEntry->DumpData[3] = SP_REQUEST_TIMEOUT;

 #undef ERRLOG_DATA_ENTRIES

         IoWriteErrorLogEntry(errorLogEntry);
     }
 }
 
 VOID
 SpLogResetError(
     IN PADAPTER_EXTENSION DeviceExtension,
     IN PSCSI_REQUEST_BLOCK  Srb,
     IN ULONG UniqueId
     )
 /*++

 Routine Description:

     This function logs an error when the bus is reset.

 Arguments:

     DeviceExtension - Supplies a pointer to the port device extension.

     Srb - Supplies a pointer to the request which timed-out.

     UniqueId - Supplies the UniqueId for this error.

 Return Value:

     None.

 Notes:

     The port device extension spinlock should be held when this routine is
     called.

 --*/

 {
     PIO_ERROR_LOG_PACKET errorLogEntry;
     PIO_STACK_LOCATION   irpStack;
     PIRP                 irp;
     PSRB_DATA            srbData;
     ULONG                sequenceNumber = 0;
     UCHAR                function       = 0,
                          pathId         = 0,
                          targetId       = 0,
                          lun            = 0,
                          retryCount     = 0;

     if (Srb) {

         srbData = Srb->OriginalRequest;

         ASSERT(srbData != NULL);
         ASSERT_SRB_DATA(srbData);

         irp = srbData->CurrentIrp;

         if (irp) {
             irpStack = IoGetCurrentIrpStackLocation(irp);
             function = irpStack->MajorFunction;
         }

         pathId         = Srb->PathId;
         targetId       = Srb->TargetId;
         lun            = Srb->Lun;
         retryCount     = (UCHAR) srbData->ErrorLogRetryCount;
         sequenceNumber = srbData->SequenceNumber;


     }

 #define ERRLOG_DATA_ENTRIES 4

     errorLogEntry = (PIO_ERROR_LOG_PACKET)
         IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                 (sizeof(IO_ERROR_LOG_PACKET) +
                                  (ERRLOG_DATA_ENTRIES * sizeof(ULONG))));

     if (errorLogEntry != NULL) {
         errorLogEntry->ErrorCode         = IO_ERR_TIMEOUT;
         errorLogEntry->SequenceNumber    = sequenceNumber;
         errorLogEntry->MajorFunctionCode = function;
         errorLogEntry->RetryCount        = retryCount;
         errorLogEntry->UniqueErrorValue  = UniqueId;
         errorLogEntry->FinalStatus       = STATUS_SUCCESS;
         errorLogEntry->DumpDataSize      = ERRLOG_DATA_ENTRIES * sizeof(ULONG);
         errorLogEntry->DumpData[0]       = pathId;
         errorLogEntry->DumpData[1]       = targetId;
         errorLogEntry->DumpData[2]       = lun;
         errorLogEntry->DumpData[3]       = SP_REQUEST_TIMEOUT;

         IoWriteErrorLogEntry(errorLogEntry);
     }
 #undef ERRLOG_DATA_ENTRIES
 }

 
 BOOLEAN
 SpResetBusSynchronized (
     PVOID ServiceContext
     )
 /*++

 Routine Description:

     This function resets the bus and sets up the port timer so the reset hold
     flag is clean when necessary.

 Arguments:

     ServiceContext - Supplies a pointer to the reset context which includes a
         pointer to the device extension and the pathid to be reset.

 Return Value:

     TRUE - if the reset succeeds.

 --*/

 {
     PRESET_CONTEXT resetContext = ServiceContext;
     PADAPTER_EXTENSION deviceExtension;

     BOOLEAN result;

     deviceExtension = resetContext->DeviceExtension;

     if(TEST_FLAG(deviceExtension->InterruptData.InterruptFlags,
                  PD_ADAPTER_REMOVED)) {
         return FALSE;
     }

     result = deviceExtension->HwResetBus(deviceExtension->HwDeviceExtension,
                                          resetContext->PathId);

     //
     // Set the reset hold flag and start the counter.
     //

     deviceExtension->InterruptData.InterruptFlags |= PD_RESET_HOLD;
     deviceExtension->PortTimeoutCounter = PD_TIMER_RESET_HOLD_TIME;

     //
     // Check for miniport work requests.
     //

     if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

         //
         // Queue a DPC.
         //

         SpRequestCompletionDpc(deviceExtension->CommonExtension.DeviceObject);
     }

     return(result);
 }
 
 VOID
 SpProcessCompletedRequest(
     IN PADAPTER_EXTENSION DeviceExtension,
     IN PSRB_DATA SrbData,
     OUT PBOOLEAN CallStartIo
     )
 /*++
 Routine Description:

     This routine processes a request which has completed.  It completes any
     pending transfers, releases the adapter objects and map registers when
     necessary.  It deallocates any resources allocated for the request.
     It processes the return status, by requeueing busy request, requesting
     sense information or logging an error.

 Arguments:

     DeviceExtension - Supplies a pointer to the device extension for the
         adapter data.

     SrbData - Supplies a pointer to the SRB data block to be completed.

     CallStartIo - This value is set if the start I/O routine needs to be
         called.

 Return Value:

     None.

 --*/

 {

     PLOGICAL_UNIT_EXTENSION  logicalUnit;
     PSCSI_REQUEST_BLOCK      srb;
     PIO_ERROR_LOG_PACKET     errorLogEntry;
     ULONG                    sequenceNumber;
     LONG                     interlockResult;
     PIRP                     irp;
     PDEVICE_OBJECT           deviceObject = DeviceExtension->DeviceObject;
     NTSTATUS                 internalStatus = SrbData->InternalStatus;

     ASSERT_SRB_DATA(SrbData);

     srb = SrbData->CurrentSrb;
     irp = SrbData->CurrentIrp;
     logicalUnit = SrbData->LogicalUnit;

     //
     // If miniport needs mapped system addresses, the the
     // data buffer address in the SRB must be restored to
     // original unmapped virtual address. Ensure that this request requires
     // a data transfer.
     //

     if (TEST_FLAG(srb->SrbFlags, SRB_FLAGS_UNSPECIFIED_DIRECTION)) {

         //
         // Restore the data buffer pointer to the original value.
         //

         srb->DataBuffer = SrbData->OriginalDataBuffer;

         //
         // If we map every transfer then obviously we need to flush now.
         // However the only way we know that we've forced a mapping for a
         // particular command (like we will for INQUIRY & REQUEST_SENSE ... see
         // IS_MAPPED_SRB) is to see if there's a RemappedMdl.
         //
         // NOTE: this will not figure out if a miniport which did not
         // orignally request mapped buffers needs to have the caches flushed
         // unless we're remapping buffers (so a 32-bit driver on a 32-bit
         // system will not get through here when completing an INQUIRY command).
         // This should be okay - most drivers which need INQUIRYs mapped do so
         // because they write to the memory normally, not because they're using
         // PIO to get the data from machine registers.
         //

         if ((DeviceExtension->MapBuffers) || (SrbData->RemappedMdl)) {
             if (irp->MdlAddress) {

                 //
                 // If an IRP is for a transfer larger than a miniport driver
                 // can handle, the request is broken up into multiple smaller
                 // requests. Each request uses the same MDL and the data
                 // buffer address field in the SRB may not be at the
                 // beginning of the memory described by the MDL.
                 //

                 //
                 // Since this driver driver did programmaged I/O then the buffer
                 // needs to flushed if this an data-in transfer.
                 //

                 if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

                     KeFlushIoBuffers(irp->MdlAddress,
                                      TRUE,
                                      FALSE);
                 }
             }

             //
             // If this request has a remapped buffer then unmap it and release
             // the remapped MDL.
             //

             if(SrbData->RemappedMdl) {
                 PVOID remappedAddress;

                 ASSERT(TEST_FLAG(SrbData->RemappedMdl->MdlFlags,
                                  MDL_MAPPED_TO_SYSTEM_VA));

#if defined(FORWARD_PROGRESS)
                 if (TEST_FLAG(SrbData->Flags, SRB_DATA_RESERVED_PAGES)) {

                     DebugPrint((1, "SpProcessCompletedRequest: unmapping remapped buffer from reserved range DevExt:%p srb:%p\n",
                                 DeviceExtension, srb));

                     //
                     // This request is using the adapter's reserved PTE range
                     // to map the MDL's pages.  Unmap the pages and release
                     // our claim on the reserve range.
                     //

                     KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

                     ASSERT(TEST_FLAG(DeviceExtension->Flags, PD_RESERVED_PAGES_IN_USE));
                     MmUnmapReservedMapping(DeviceExtension->ReservedPages,
                                            SCSIPORT_TAG_MAPPING_LIST,
                                            SrbData->RemappedMdl);

                     CLEAR_FLAG(DeviceExtension->Flags, PD_RESERVED_PAGES_IN_USE);
                     KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                     CLEAR_FLAG(SrbData->Flags, SRB_DATA_RESERVED_PAGES);

                 } else {

                     remappedAddress = 
                         SpGetSystemAddressForMdlSafe(
                             SrbData->RemappedMdl,
                             ((irp->RequestorMode == KernelMode) ?
                              HighPagePriority : NormalPagePriority));
                     if (remappedAddress != NULL) {
                         MmUnmapLockedPages(remappedAddress, 
                                            SrbData->RemappedMdl);
                     }

                 }

                 //
                 // Check if the request is using the adapter's reserved MDL.
                 // If it is, we don't free it.
                 //

                 if (TEST_FLAG(SrbData->Flags, SRB_DATA_RESERVED_MDL)) {

                     DebugPrint((1, "SpProcessCompletedRequest: releasing reserved MDL DevExt:%p srb:%p\n",
                                 DeviceExtension, srb));

                     //
                     // This request is using the adapter's reserved MDL.
                     // Release our claim on it now so another request can
                     // use it.
                     //

                     KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
                     ASSERT(TEST_FLAG(DeviceExtension->Flags, PD_RESERVED_MDL_IN_USE));
                     CLEAR_FLAG(DeviceExtension->Flags, PD_RESERVED_MDL_IN_USE);
                     KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                     CLEAR_FLAG(SrbData->Flags, SRB_DATA_RESERVED_MDL);

                 } else {

                     IoFreeMdl(SrbData->RemappedMdl);

                 }
#else
                 remappedAddress = 
                     SpGetSystemAddressForMdl(
                         SrbData->RemappedMdl,
                         ((irp->RequestorMode == KernelMode) ?
                          HightPagePriority : NormalPagePriority));
                 if (remappedAddress != NULL) {
                     MmUnmapLockedPages(remappedAddress, SrbData->RemappedMdl);
                 }
                 IoFreeMdl(SrbData->RemappedMdl);
#endif
                 SrbData->RemappedMdl = NULL;
             }
         }
     }

     //
     // Flush the adapter buffers if necessary.
     //

     if (SrbData->MapRegisterBase) {

         PCHAR dataVirtualAddress;

         //
         // We're using the base address of the original MDL - compensate
         // for the offset of the srb's data buffer.
         //
         // Note: For master devices that scsiport considers slaves, we
         //       store the map register base in the SRB_DATA independent of
         //       whether the request is actually an IO request.  So we must
         //       check if there is a valid MDL.
         //

         dataVirtualAddress = (PCHAR) ((irp->MdlAddress != NULL) ? 
             MmGetMdlVirtualAddress(irp->MdlAddress) : NULL);
         dataVirtualAddress += SrbData->DataOffset;

 #ifdef USE_DMA_MACROS
         PutScatterGatherList(
             DeviceExtension->DmaAdapterObject,
             SrbData->MapRegisterBase,
             (BOOLEAN)(srb->SrbFlags & SRB_FLAGS_DATA_IN ? FALSE : TRUE));

         SrbData->ScatterGatherList = NULL;
 #else
         if (DeviceExtension->MasterWithAdapter == FALSE &&
             irp->MdlAddress == NULL) {
             
             //
             // To scsiport, this is a slave device.  Since there is no MDL, 
             // don't try to flush the buffer.
             //

             NOTHING;

         } else {

             //
             // Since we are a master call I/O flush adapter buffers with a NULL
             // adapter.
             //
             
             FlushAdapterBuffers(DeviceExtension->DmaAdapterObject,
                                 irp->MdlAddress,
                                 SrbData->MapRegisterBase,
                                 dataVirtualAddress,
                                 srb->DataTransferLength,
                                 (BOOLEAN)(srb->SrbFlags & SRB_FLAGS_DATA_IN ? FALSE : TRUE));
         }

         //
         // Free the map registers.
         //

         FreeMapRegisters(DeviceExtension->DmaAdapterObject,
                          SrbData->MapRegisterBase,
                          SrbData->NumberOfMapRegisters);

 #endif
         //
         // Clear the MapRegisterBase.
         //

         SrbData->MapRegisterBase = NULL; 
     }

     //
     // Clear the current untagged request if this one is it.
     //
         
     if(SrbData == logicalUnit->CurrentUntaggedRequest) {
         ASSERT(SrbData->CurrentSrb->QueueTag == SP_UNTAGGED);
         logicalUnit->CurrentUntaggedRequest = NULL;
     }

#if defined(FORWARD_PROGRESS)
     //
     // If we used the adapter's reserved range on this request, we need to
     // unmap the pages and start the next request if the miniport is ready
     // for it.
     //
         
     if (TEST_FLAG(SrbData->Flags, SRB_DATA_RESERVED_PAGES)) {
             
         DebugPrint((1, "SpProcessCompletedRequest: unmapping reserved range DevExt:%p SRB:%p\n", 
                     DeviceExtension, srb));

         KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
             
         //
         // The reserved pages should be in use.
         //
             
         ASSERT(TEST_FLAG(DeviceExtension->Flags, PD_RESERVED_PAGES_IN_USE));

         //
         // Unmap the reserved pages.
         //
             
         MmUnmapReservedMapping(DeviceExtension->ReservedPages,
                                SCSIPORT_TAG_MAPPING_LIST,
                                irp->MdlAddress);

         //
         // Indicate that the reserved pages are no longer in use so the
         // next request can be started.
         //
             
         CLEAR_FLAG(SrbData->Flags, SRB_DATA_RESERVED_PAGES);
         CLEAR_FLAG(DeviceExtension->Flags, PD_RESERVED_PAGES_IN_USE);
             
         KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
             
     }
#endif

     //
     // If the no disconnect flag was set for this SRB, then check to see
     // if SpStartNextPacket must be called.
     //

     if (TEST_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_DISCONNECT)) {

         //
         // Acquire the spinlock to protect the flags strcuture.
         //

         KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

         //
         // Set the disconnect running flag and check the busy flag.
         //

         SET_FLAG(DeviceExtension->Flags, PD_DISCONNECT_RUNNING);

         //
         // The interrupt flags are checked unsynchonized.  This works because
         // the RESET_HOLD flag is cleared with the spinlock held and the
         // counter is only set with the spinlock held.  So the only case where
         // there is a problem is is a reset occurs before this code get run,
         // but this code runs before the timer is set for a reset hold;
         // the timer will soon set for the new value.
         //

         if (!TEST_FLAG(DeviceExtension->InterruptData.InterruptFlags,
                        PD_RESET_HOLD)) {

             //
             // The miniport is ready for the next request and there is not a
             // pending reset hold, so clear the port timer.
             //

             DeviceExtension->PortTimeoutCounter = PD_TIMER_STOPPED;
         }

         //
         // Release the spinlock.
         //

         KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

         if (!(*CallStartIo) &&
             !TEST_FLAG(DeviceExtension->Flags, (PD_DEVICE_IS_BUSY |
                                                 PD_PENDING_DEVICE_REQUEST))) {

             //
             // The busy flag is clear so the miniport has requested the
             // next request. Call SpStartNextPacket.
             //

             SpStartNextPacket(DeviceExtension->DeviceObject, FALSE);
         }
     }

 #ifndef USE_DMA_MACROS
     if(SrbData->ScatterGatherList != NULL) {

         SpFreeSGList(DeviceExtension, SrbData);
     }
 #endif

     //
     // Move bytes transfered to IRP.
     //

     irp->IoStatus.Information = srb->DataTransferLength;

     //
     // Save the sequence number in case an error needs to be logged later.
     //

     sequenceNumber = SrbData->SequenceNumber;
     SrbData->ErrorLogRetryCount = 0;

     //
     // Acquire the spinlock to protect the flags structure,
     // and the free of the srb extension.
     //

     KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

     //
     // Free SrbExtension to list if necessary.
     //

     if (srb->SrbExtension) {

         if ((srb->Function != SRB_FUNCTION_WMI) &&
             DeviceExtension->AutoRequestSense &&
             (srb->SenseInfoBuffer != NULL)) {

             ASSERT(SrbData->RequestSenseSave != NULL ||
                    srb->SenseInfoBuffer == NULL);

             //
             // If the request sense data is valid then copy the data to the
             // real buffer.
             //

             if (TEST_FLAG(srb->SrbStatus, SRB_STATUS_AUTOSENSE_VALID)) {

                 //
                 // If WMI Sense Data events are enabled for this adapter, fire
                 // the event.
                 //

                 if (DeviceExtension->EnableSenseDataEvent) {

                     NTSTATUS status;

                     status = SpFireSenseDataEvent(srb, deviceObject);
                     if (status != STATUS_SUCCESS) {

                         DebugPrint((1, "Failed to send SenseData WMI event (%08X)\n", status));

                     }                
                 }

                 //
                 // Check the srb flags to see if we are supposed to allocate
                 // the sense data buffer.  The buffer we allocate  will be
                 // freed for us by whoever is requesting us to do the 
                 // allocation.
                 //

                 if (srb->SrbFlags & SRB_FLAGS_PORT_DRIVER_ALLOCSENSE) {

                     PSENSE_DATA ReturnBuffer;
                     UCHAR AlignmentFixup;
                     ULONG BufferSize;

                     //
                     // We communicate the scsi port number to the class driver
                     // by allocating enough space in the sense buffer and
                     // copying it there.  We align the location into which we
                     // copy the port number on a 4-byte boundary.
                     //

                     AlignmentFixup = 
                         ((srb->SenseInfoBufferLength + 3) & ~3)
                         - srb->SenseInfoBufferLength;

                     BufferSize = srb->SenseInfoBufferLength
                                  + AlignmentFixup
                                  + sizeof(ULONG64);

                     ReturnBuffer = SpAllocatePool(
                                        NonPagedPoolCacheAligned,
                                        BufferSize,
                                        SCSIPORT_TAG_SENSE_BUFFER,
                                        deviceObject->DriverObject);

                     if (ReturnBuffer) {

                         PULONG PortNumber;

                         //
                         // Set a flag in the SRB to indicate that we have 
                         // allocated a new sense buffer and that the class
                         // driver must free it.
                         //

                         SET_FLAG(srb->SrbFlags, 
                                  SRB_FLAGS_FREE_SENSE_BUFFER);
                         
                         //
                         // We've successfully allocated a sense buffer.
                         // Set a flag in the srb flags to indicate that
                         // the scsi port number resides adjacent to the
                         // sense info.
                         //

                         srb->SrbFlags |= SRB_FLAGS_PORT_DRIVER_SENSEHASPORT;

                         //
                         // Initialize a pointer to the location at the end of
                         // the sense buffer into which we copy the scsi port
                         // number.
                         //

                         PortNumber = (PULONG)((PUCHAR)ReturnBuffer 
                                               + srb->SenseInfoBufferLength
                                               + AlignmentFixup);
                         *PortNumber = DeviceExtension->PortNumber;

                         //
                         // Overwrite the pointer we've saved to the original
                         // sense buffer passed down to us with the one we've
                         // allocated.  This is where we will copy the sense
                         // data we've collected in our own buffer.
                         //

                         SrbData->RequestSenseSave = ReturnBuffer;

                     } else {

                         srb->SenseInfoBufferLength = 
                             SrbData->RequestSenseLengthSave;

                     }

                 } else {

                     //
                     // Restore the original sense info buffer length which we
                     // modified in SpAllocateSrbExtension.  We modified then
                     // to reflect the adapter specified size.
                     //

                     srb->SenseInfoBufferLength = SrbData->RequestSenseLengthSave;

                 }

                 //
                 // Copy the sense info we've collected in our own buffer into
                 // a buffer that is returned back up the stack.  This may be
                 // the buffer supplied to us, or it may be one we've allocated.
                 //

                 RtlCopyMemory(SrbData->RequestSenseSave,
                               srb->SenseInfoBuffer,
                               srb->SenseInfoBufferLength);

             } else {

                 //
                 // If there is no request sense data, restore the request sense
                 // length.
                 //

                 srb->SenseInfoBufferLength = SrbData->RequestSenseLengthSave;

             }

             //
             // Restore the SenseInfoBuffer pointer in the srb.
             //

             srb->SenseInfoBuffer = SrbData->RequestSenseSave;

         }

         if (SpVerifyingCommonBuffer(DeviceExtension)) {

             SpInsertSrbExtension(DeviceExtension,
                                  srb->SrbExtension);

         } else {

             *((PVOID *) srb->SrbExtension) = DeviceExtension->SrbExtensionListHeader;
             DeviceExtension->SrbExtensionListHeader = srb->SrbExtension;

         }
     }

     //
     // Decrement the queue count for the logical unit.
     //

     logicalUnit->QueueCount--;

     if (DeviceExtension->Flags & PD_PENDING_DEVICE_REQUEST) {

         //
         // The start I/O routine needs to be called because it could not
         // allocate an srb extension.  Clear the pending flag and note
         // that it needs to be called later.
         //

         DebugPrint(((deviceObject->CurrentIrp == NULL) ? 0 : 2,
                     "SpProcessCompletedRequest(%#p): will call start "
                     "i/o when we return to process irp %#p\n",
                     SrbData,
                     deviceObject->CurrentIrp));
         ASSERT(deviceObject->CurrentIrp != NULL);

         DeviceExtension->Flags &= ~PD_PENDING_DEVICE_REQUEST;
         *CallStartIo = TRUE;
     }

     //
     // If success then start next packet.
     // Not starting packet effectively
     // freezes the queue.
     //

     if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS) {

         irp->IoStatus.Status = STATUS_SUCCESS;

         //
         // If the queue is being bypassed then keep the queue frozen.
         // If there are outstanding requests as indicated by the timer
         // being active then don't start the then next request.
         //

         if(!TEST_FLAG(srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE) &&
             logicalUnit->RequestTimeoutCounter == PD_TIMER_STOPPED) {

             //
             // This is a normal request start the next packet.
             //

             GetNextLuRequest(logicalUnit);

         } else {

             //
             // Release the spinlock.
             //

             KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

         }

         DebugPrint((3,
                     "SpProcessCompletedRequests: Iocompletion IRP %p\n",
                     irp));

         //
         // Note that the retry count and sequence number are not cleared
         // for completed packets which were generated by the port driver.
         //

         srb->OriginalRequest = irp;

         SpReleaseRemoveLock(deviceObject, irp);
         SpCompleteRequest(deviceObject, irp, SrbData, IO_DISK_INCREMENT);

         //
         // Decrement the number of active requests.  If the count is negitive, and
         // this is a slave with an adapter then free the adapter object and
         // map registers.  Doing this allows another request to be started for
         // this logical unit before adapter is released.
         //

         interlockResult = InterlockedDecrement( &DeviceExtension->ActiveRequestCount );

         if ((interlockResult < 0) &&
             (!DeviceExtension->PortConfig->Master) &&
             (DeviceExtension->DmaAdapterObject != NULL)) {

             //
             // Clear the map register base for safety.
             //

             DeviceExtension->MapRegisterBase = NULL;

             FreeAdapterChannel(DeviceExtension->DmaAdapterObject);
         }

         return;

     }

     //
     // Decrement the number of active requests.  If the count is negative, and
     // this is a slave with an adapter then free the adapter object and
     // map registers.
     //

     interlockResult = InterlockedDecrement( &DeviceExtension->ActiveRequestCount );

     if (interlockResult < 0 &&
         !DeviceExtension->PortConfig->Master &&
         DeviceExtension->DmaAdapterObject != NULL) {

         //
         // Clear the map register base for safety.
         //

         DeviceExtension->MapRegisterBase = NULL;

         FreeAdapterChannel(DeviceExtension->DmaAdapterObject);
     }

     //
     // Set IRP status. Class drivers will reset IRP status based
     // on request sense if error.
     //

     if(srb->SrbStatus != SRB_STATUS_INTERNAL_ERROR) {
         irp->IoStatus.Status = SpTranslateScsiStatus(srb);
     } else {
         ASSERT(srb->ScsiStatus == 0xff);
         ASSERT(logicalUnit->ActiveFailedRequest != SrbData);
         ASSERT(logicalUnit->BlockedFailedRequest != SrbData);
         srb->InternalStatus = internalStatus;
         irp->IoStatus.Status = internalStatus;
    }

    DebugPrint((2, "SpProcessCompletedRequests: Queue frozen TID %d\n",
        srb->TargetId));

    //
    // Perform busy processing if a busy type status was returned and this
    // is not a recovery request.
    //
    // For now we're choosing to complete the SRB's with BYPASS_FROZEN_QUEUE
    // set in them if they are completed as BUSY.
    // Though if we wanted to do busy processing on them, the
    // if statement below should be changed, along with the next if statement
    // to get them to be placed on the lun-extension slot, and then
    // modify the scsiport tick handler so that it will retry SRB's
    // that have the BYPASS_FROZEN_QUEUE flag set when the queue is frozen.
    //

    if ((srb->ScsiStatus == SCSISTAT_BUSY ||
         srb->SrbStatus == SRB_STATUS_BUSY ||
         srb->ScsiStatus == SCSISTAT_QUEUE_FULL) &&
         !(srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE)) {

        DebugPrint((1,
                   "SCSIPORT: Busy SRB status %x, SCSI status %x)\n",
                   srb->SrbStatus,
                   srb->ScsiStatus));

        //
        // Restore the request transfer length in case the miniport
        // destroyed it.
        //

        srb->DataTransferLength = SrbData->OriginalDataTransferLength;

        //
        // If the logical unit is already busy then just requeue this request.
        // Unless the SRB is a BYPASS_LOCKED_QUEUE SRB
        //

        if ((TEST_FLAG(logicalUnit->LuFlags, LU_LOGICAL_UNIT_IS_BUSY)) &&
            (!TEST_FLAG(srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE))) {


            DebugPrint((1,
                       "SpProcessCompletedRequest: Requeuing busy request\n"));

            srb->SrbStatus = SRB_STATUS_PENDING;
            srb->ScsiStatus = 0;

            //
            // Set the tick count so we know how long this request has
            // been queued.
            //

            SrbData->TickCount = DeviceExtension->TickCount;

            if (!KeInsertByKeyDeviceQueue(
                    &logicalUnit->DeviceObject->DeviceQueue,
                    &irp->Tail.Overlay.DeviceQueueEntry,
                    srb->QueueSortKey)) {

                //
                // The LU says it is busy, so there should be a busy request.
                //

                ASSERT(logicalUnit->BusyRequest != NULL);

                //
                // We can arrive here if the LU's device queue was drained by
                // the DCP routine prior to calling us, transitioning the queue
                // from busy to not busy.  It is safe for us to force the
                // request into the queue because we know we have a busy
                // request that will get restarted by our TickHandler routine.
                //

                KeInsertByKeyDeviceQueue(
                    &logicalUnit->DeviceObject->DeviceQueue,
                    &irp->Tail.Overlay.DeviceQueueEntry,
                    srb->QueueSortKey);
            }

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            return;

        } else if (logicalUnit->RetryCount++ < BUSY_RETRY_COUNT) {

            //
            // If busy status is returned, then indicate that the logical
            // unit is busy.  The timeout code will restart the request
            // when it fires. Reset the status to pending.
            //

            srb->SrbStatus = SRB_STATUS_PENDING;
            srb->ScsiStatus = 0;

            SET_FLAG(logicalUnit->LuFlags, LU_LOGICAL_UNIT_IS_BUSY);
            logicalUnit->BusyRequest = SrbData;

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            return;

        } else {

            //
            // Freeze the queue if it isn't already locked.
            //

            if((!TEST_FLAG(logicalUnit->LuFlags, LU_QUEUE_LOCKED)) &&
                !TEST_FLAG(srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE)) {

                SET_FLAG(srb->SrbStatus, SRB_STATUS_QUEUE_FROZEN);
                SET_FLAG(logicalUnit->LuFlags, LU_QUEUE_FROZEN);
            }

            //
            // Clear the queue full flag.
            //

            CLEAR_FLAG(logicalUnit->LuFlags, LU_QUEUE_IS_FULL);

            //
            // Log an a timeout erorr.
            //

            #define ERRLOG_DATA_ENTRIES 6

            errorLogEntry = (PIO_ERROR_LOG_PACKET)
                IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                        (sizeof(IO_ERROR_LOG_PACKET) +
                                         (ERRLOG_DATA_ENTRIES * sizeof(ULONG))));

            if (errorLogEntry != NULL) {
                errorLogEntry->ErrorCode = IO_ERR_NOT_READY;
                errorLogEntry->SequenceNumber = sequenceNumber;
                errorLogEntry->MajorFunctionCode =
                   IoGetCurrentIrpStackLocation(irp)->MajorFunction;
                errorLogEntry->RetryCount = logicalUnit->RetryCount;
                errorLogEntry->UniqueErrorValue = 259;
                errorLogEntry->FinalStatus = STATUS_DEVICE_NOT_READY;
                errorLogEntry->DumpDataSize = ERRLOG_DATA_ENTRIES * sizeof(ULONG);
                errorLogEntry->DumpData[0] = srb->PathId;
                errorLogEntry->DumpData[1] = srb->TargetId;
                errorLogEntry->DumpData[2] = srb->Lun;
                errorLogEntry->DumpData[3] = srb->ScsiStatus;
                errorLogEntry->DumpData[4] = SP_REQUEST_TIMEOUT;
                errorLogEntry->DumpData[5] = srb->SrbStatus;

                IoWriteErrorLogEntry(errorLogEntry);
            }
            #undef ERRLOG_DATA_ENTRIES

            irp->IoStatus.Status = STATUS_DEVICE_NOT_READY;

            //
            // Fall through and complete this as a failed request.  This that ensures 
            // we propagate ourselves by handling any queued requests.
            //
        }

    }

    //
    // If the request sense data is valid, or none is needed and this request
    // is not going to freeze the queue, then start the next request for this
    // logical unit if it is idle.
    //

    if (!NEED_REQUEST_SENSE(srb) &&
        TEST_FLAG(srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE)) {

        if (logicalUnit->RequestTimeoutCounter == PD_TIMER_STOPPED) {

            GetNextLuRequest(logicalUnit);

            //
            // The spinlock is released by GetNextLuRequest.
            //

        } else {

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        }

    } else {

        //
        // NOTE:  This will also freeze the queue.  For a case where there
        // is no request sense.
        //

        //
        // Don't freeze the queue if it's already been locked.  Frozen and
        // locked queue are mutually exclusive.
        //

        if(!TEST_FLAG(logicalUnit->LuFlags, LU_QUEUE_LOCKED)) {

            //
            // If the caller asked us not to freeze the queue and we don't need
            // to do a request sense then don't freeze the queue.  If we do
            // need to do a request sense then the queue will be unfrozen
            // once it's finished.
            //

            if(!TEST_FLAG(srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE) ||
               NEED_REQUEST_SENSE(srb)) {
                SET_FLAG(srb->SrbStatus, SRB_STATUS_QUEUE_FROZEN);
                SET_FLAG(logicalUnit->LuFlags, LU_QUEUE_FROZEN);
            }
        }

        //
        // Determine if a REQUEST SENSE command needs to be done.
        // Check that a CHECK_CONDITION was received, an autosense has not
        // been done already, and that autosense has been requested.
        //

        if (NEED_REQUEST_SENSE(srb)) {

            //
            // If a request sense is going to be issued then any busy
            // requests must be requeue so that the time out routine does
            // not restart them while the request sense is being executed.
            //

            if (TEST_FLAG(logicalUnit->LuFlags, LU_LOGICAL_UNIT_IS_BUSY)) {

                DebugPrint((1, "SpProcessCompletedRequest: Requeueing busy "
                               "request to allow request sense.\n"));

                //
                // Set the tick count so we know how long this request has
                // been queued.
                //

                SrbData->TickCount = DeviceExtension->TickCount;

                if (!KeInsertByKeyDeviceQueue(
                    &logicalUnit->CommonExtension.DeviceObject->DeviceQueue,
                    &logicalUnit->BusyRequest->CurrentIrp->Tail.Overlay.DeviceQueueEntry,
                    srb->QueueSortKey)) {

                    //
                    // This should never occur since there is a busy request.
                    // Complete the current request without request sense
                    // informaiton.
                    //

                    ASSERT(FALSE);
                    DebugPrint((3, "SpProcessCompletedRequests: Iocompletion IRP %p\n", irp ));

                    //
                    // Release the spinlock.
                    //

                    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                    SpReleaseRemoveLock(deviceObject, irp);
                    SpCompleteRequest(deviceObject, irp, SrbData, IO_DISK_INCREMENT);
                    return;

                }

                //
                // Clear the busy flag.
                //

                logicalUnit->LuFlags &= ~(LU_LOGICAL_UNIT_IS_BUSY | LU_QUEUE_IS_FULL);

            }

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            //
            // Call IssueRequestSense and it will complete the request
            // after the REQUEST SENSE completes.
            //

            IssueRequestSense(DeviceExtension, srb);

            return;

        } else {
            ASSERTMSG("Srb is failed request but doesn't indicate needing requests sense: ",
                      ((SrbData != logicalUnit->ActiveFailedRequest) &&
                       (SrbData != logicalUnit->BlockedFailedRequest)));
        }

        //
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
    }

    SpReleaseRemoveLock(deviceObject, irp);
    SpCompleteRequest(deviceObject, irp, SrbData, IO_DISK_INCREMENT);
}

PSRB_DATA
SpGetSrbData(
    IN PADAPTER_EXTENSION DeviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    UCHAR QueueTag,
    BOOLEAN AcquireBinLock
    )

/*++

Routine Description:

    This function returns the SRB data for the addressed unit.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension.

    Address - Supplies the address of the logical unit.

    QueueTag - Supplies the queue tag if the request is tagged.

Return Value:

    Returns a pointer to the SRB data.  NULL is returned if the address is not
    valid.

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit;

    //
    // We're going to have to search the appropriate logical unit for this
    // request.
    //

    logicalUnit = GetLogicalUnitExtension(DeviceExtension,
                                          PathId,
                                          TargetId,
                                          Lun,
                                          FALSE,
                                          AcquireBinLock);

    if(logicalUnit == NULL) {
        return NULL;
    }

    //
    // Check for an untagged request.
    //

    if (QueueTag == SP_UNTAGGED) {

        return logicalUnit->CurrentUntaggedRequest;

    } else {

        PLIST_ENTRY listEntry;

        for(listEntry = logicalUnit->RequestList.Flink;
            listEntry != &(logicalUnit->RequestList);
            listEntry = (PLIST_ENTRY) listEntry->Flink) {

            PSRB_DATA srbData;

            srbData = CONTAINING_RECORD(listEntry,
                                        SRB_DATA,
                                        RequestList);

            if(srbData->CurrentSrb->QueueTag == QueueTag) {
                return srbData;
            }
        }
        return NULL;
    }
}



VOID
SpCompleteSrb(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PSRB_DATA SrbData,
    IN UCHAR SrbStatus
    )
/*++

Routine Description:

    The routine completes the specified request.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension.

    SrbData - Supplies a pointer to the SrbData for the request to be
        completed.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb;

    //
    // Make sure there is a current request.
    //

    srb = SrbData->CurrentSrb;

    if (srb == NULL || !(srb->SrbFlags & SRB_FLAGS_IS_ACTIVE)) {
        return;
    }

    //
    // Update SRB status.
    //

    srb->SrbStatus = SrbStatus;

    //
    // Indicate no bytes transferred.
    //

    srb->DataTransferLength = 0;

    //
    // Call notification routine.
    //

    ScsiPortNotification(RequestComplete,
                DeviceExtension->HwDeviceExtension,
                srb);

}

BOOLEAN
SpAllocateSrbExtension(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT BOOLEAN *StartNextRequest,
    OUT BOOLEAN *Tagged
    )
/*++

Routine Description:

    The routine allocates an SRB data structure and/or an SRB extension for
    the request.

    It first determines if the request is can be executed at this time.
    In particular, untagged requests cannot execute if there are any active
    tagged queue requests.  If the request cannot be executed, the pending
    flag is set in the logical unit FALSE is returned.  The request will be
    retried after the last tagged queue request completes.

    If one of the structures cannot be allocated, then the pending flag is
    set in the device extension and FALSE is returned.  The request will be
    retried the next time a request completes.

Arguments:

    DeviceExtension - Supplies a pointer to the devcie extension for this
        adapter.

    LogicalUnit - Supplies a pointer to the logical unit that this request is
        is for.

    Srb - Supplies a pointer to the SCSI request.

    StartNextRequest - Pointer to a BOOLEAN that we'll set to TRUE if the caller
                       needs to start the next packet.

    Tagged - Supplies a pointer to a BOOLEAN that we'll set to TRUE if the
             request is to receive a queue tag and can be dispatched to the
             miniport while other tagged commands are active.

Return Value:

    TRUE if the SRB can be execute currently. If FALSE is returneed the reuqest
    should not be started.

--*/
{
    PSRB_DATA srbData = (PSRB_DATA) Srb->OriginalRequest;
    PCCHAR srbExtension;
    PCCHAR remappedSrbExt;
    ULONG tagValue = 0;

    ASSERT_SRB_DATA(srbData);

    //
    // Acquire the spinlock while the allocations are attempted.
    //
    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    //
    // If the adapter supports mulitple requests, then determine if it can
    // be executed.
    //

    if (DeviceExtension->SupportsMultipleRequests == TRUE) {
        
        //
        // SupportsMultipleRequests means the miniport supports tagged queuing,
        // MultipleRequestPerLu, or both.  Here is the way we handle each
        // case:
        // 1) TaggedQueuing and SupportsMultipleLu:
        //    In this case, if the command's QUEUE_ACTION_ENABLE bit OR the
        //    NO_QUEUE_FREEZE bit is set, we give the command a tag and
        //    hand it to the miniport.
        // 2) TaggedQueuing Only:
        //    In this case the miniport does not expect to receive any
        //    untagged commands while there are active tagged commands, so
        //    we only give the SRB a tag if QUEUE_ACTION_ENABLE is set.
        // 3) MultipleRequestPerLu Only:
        //    This can be treated the same as case 1.  Any command that has
        //    QUEUE_ACTION_ENABLE or NO_QUEUE_FREEZE set can be assigned a
        //    tag and given to the miniport.
        //

        ULONG tagMask = SRB_FLAGS_QUEUE_ACTION_ENABLE;
        if (DeviceExtension->MultipleRequestPerLu == TRUE) {
            tagMask |= SRB_FLAGS_NO_QUEUE_FREEZE;
        }

        if (Srb->Function == SRB_FUNCTION_ABORT_COMMAND) {

            ASSERT(FALSE);
            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            return FALSE;

        } else if (TEST_FLAG(Srb->SrbFlags, tagMask) &&
                   !TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_DISABLE_DISCONNECT)) {
            //
            // If the need request sense flag is set then tagged commands cannot
            // be started and must be marked as pending.
            //

            *Tagged = TRUE;
            if (TEST_FLAG(LogicalUnit->LuFlags, LU_NEED_REQUEST_SENSE)) {
                DebugPrint((1, "SCSIPORT: SpAllocateSrbExtension: "
                               "Marking tagged request as pending.\n"));

                //
                // This request cannot be executed now.  Mark it as pending
                // in the logical unit structure and return.
                // GetNextLogicalUnit will restart the commnad after all of the
                // active commands have completed.
                //

                ASSERT(!(LogicalUnit->LuFlags & LU_PENDING_LU_REQUEST));
                ASSERT(LogicalUnit->PendingRequest == NULL);

                LogicalUnit->LuFlags |= LU_PENDING_LU_REQUEST;
                LogicalUnit->PendingRequest = Srb->OriginalRequest;
                LogicalUnit->PendingRequest->TickCount = DeviceExtension->TickCount;

                //
                // Indicate that the logical unit is still active so that the
                // request will get processed when the request list is empty.
                //

                LogicalUnit->LuFlags |= LU_LOGICAL_UNIT_IS_ACTIVE;

                //  
                // Notify the caller that it needs to start the next request.
                //

                *StartNextRequest = TRUE;

                //
                // Release the spinlock and return.
                //
                KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                return FALSE;
            }

        } else {
            //
            // This is an untagged command.  It is only allowed to execute, if
            // logical unit queue is being by-passed or there are no other
            // requests active.
            //

            *Tagged = FALSE;
            if ((!IsListEmpty(&LogicalUnit->RequestList) ||
                LogicalUnit->LuFlags & LU_NEED_REQUEST_SENSE) &&
                !SpSrbIsBypassRequest(Srb, LogicalUnit->LuFlags)) {

                //
                // This request cannot be executed now.  Mark it as pending
                // in the logical unit structure and return.
                // GetNextLogicalUnit will restart the commnad after all of the
                // active commands have completed.
                //

                ASSERT(!(LogicalUnit->LuFlags & LU_PENDING_LU_REQUEST));
                LogicalUnit->LuFlags |= LU_PENDING_LU_REQUEST;
                LogicalUnit->PendingRequest = Srb->OriginalRequest;
                LogicalUnit->PendingRequest->TickCount = DeviceExtension->TickCount;

                //
                // Indicate that the logical unit is still active so that the
                // request will get processed when the request list is empty.
                //

                LogicalUnit->LuFlags |= LU_LOGICAL_UNIT_IS_ACTIVE;

                //
                // Notify the caller that it needs to start the next request.
                //

                *StartNextRequest = TRUE;

                //
                // Release the spinlock and return.
                //
    
                KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                return FALSE;
            }

            //
            // Set the QueueTag to SP_UNTAGGED
            // Set use the SRB data in the logical unit extension.
            //
            Srb->QueueTag = SP_UNTAGGED;
            srbData->TickCount = DeviceExtension->TickCount;
            LogicalUnit->CurrentUntaggedRequest = srbData;
        } 
    } else {
        
        //
        // The adapter does not support multiple requests.
        //

        *Tagged = FALSE;
        Srb->QueueTag = SP_UNTAGGED;
        srbData->TickCount = DeviceExtension->TickCount;
        LogicalUnit->CurrentUntaggedRequest = srbData;
    }

    ASSERT(Srb->QueueTag != 0);

    if (DeviceExtension->AllocateSrbExtension) {

        //
        // Allocate SRB extension from list if available.
        //

        srbExtension = DeviceExtension->SrbExtensionListHeader;

        //
        // If the Srb extension cannot be allocated, then special processing
        // is required.
        //

        if (srbExtension == NULL) {

            //
            // Indicate there is a pending request.  The DPC completion routine
            // will call this function again after it has freed at least one
            // Srb extension.
            //

            DeviceExtension->Flags |= PD_PENDING_DEVICE_REQUEST;

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
            return FALSE;
        }

        //
        // Remove SRB extension from list.
        //

        DeviceExtension->SrbExtensionListHeader  = *((PVOID *) srbExtension);

        if (SpVerifyingCommonBuffer(DeviceExtension)) {

            remappedSrbExt = SpPrepareSrbExtensionForUse(DeviceExtension,
                                                         srbExtension);

        } else {
            remappedSrbExt = NULL;
        }

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        Srb->SrbExtension = (remappedSrbExt != NULL) ? remappedSrbExt : 
                                                       srbExtension;

        //
        // If the adapter supports auto request sense, the SenseInfoBuffer
        // needs to point to the Srb extension.  This buffer is already mapped
        // for the adapter. Note that this is not done for WMI requests.
        //

        if ((Srb->Function != SRB_FUNCTION_WMI) &&
            (DeviceExtension->AutoRequestSense &&
             Srb->SenseInfoBuffer != NULL)) {

            //
            // Save the request sense buffer and the length of the buffer.
            //

            srbData->RequestSenseSave = Srb->SenseInfoBuffer;
            srbData->RequestSenseLengthSave = Srb->SenseInfoBufferLength;

            //
            // Make sure the allocated buffer is large enough for the requested
            // sense buffer.
            //

            if (Srb->SenseInfoBufferLength > 
                (sizeof(SENSE_DATA) + DeviceExtension->AdditionalSenseBytes)) {

                //
                // Auto request sense cannot be done for this request sense 
                // because the buffer is larger than the adapter supports.  
                // Disable auto request sense.
                //

                DebugPrint((1,"SpAllocateSrbExtension: SenseInfoBuffer too big "
                              "SenseInfoBufferLength:%x MaxSupported:%x\n",
                            Srb->SenseInfoBufferLength,
                            (sizeof(SENSE_DATA) + DeviceExtension->AdditionalSenseBytes)));

                Srb->SrbFlags |= SRB_FLAGS_DISABLE_AUTOSENSE;

            } else {

                //
                // Modify the size of the sense buffer to reflect the size of 
                // the one we redirect to.
                //

                Srb->SenseInfoBufferLength = 
                    sizeof(SENSE_DATA) + DeviceExtension->AdditionalSenseBytes;

                //
                // Replace it with the request sense buffer in the Srb
                // extension.
                //

                if (SpVerifyingCommonBuffer(DeviceExtension)) {

                    Srb->SenseInfoBuffer = SpPrepareSenseBufferForUse(
                                               DeviceExtension,
                                               srbExtension);                    
                } else { 
                    Srb->SenseInfoBuffer = srbExtension +
                       DeviceExtension->SrbExtensionSize;
                }
            }
        }

    } else  {

        Srb->SrbExtension = NULL;

        //
        // Release the spinlock before returning.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    }

    return TRUE;
}

NTSTATUS
SpSendMiniPortIoctl(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    )

/*++

Routine Description:

    This function sends a miniport ioctl to the miniport driver.
    It creates an srb which is processed normally by the port driver.
    This call is synchronous.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    RequestIrp - Supplies a pointe to the Irp which made the original request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/

{
    PIRP                    irp;
    PIO_STACK_LOCATION      irpStack;
    PSRB_IO_CONTROL         srbControl;
    SCSI_REQUEST_BLOCK      srb;
    KEVENT                  event;
    LARGE_INTEGER           startingOffset;
    IO_STATUS_BLOCK         ioStatusBlock;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    ULONG                   outputLength;
    ULONG                   length;
    ULONG                   target;

    NTSTATUS                status;

    PAGED_CODE();
    startingOffset.QuadPart = (LONGLONG) 1;

    DebugPrint((3,"SpSendMiniPortIoctl: Enter routine\n"));

    //
    // Get a pointer to the control block.
    //

    irpStack = IoGetCurrentIrpStackLocation(RequestIrp);
    srbControl = RequestIrp->AssociatedIrp.SystemBuffer;
    RequestIrp->IoStatus.Information = 0;

    //
    // Validiate the user buffer.
    //

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SRB_IO_CONTROL)){

        RequestIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        return(STATUS_INVALID_PARAMETER);
    }

    if (srbControl->HeaderLength != sizeof(SRB_IO_CONTROL)) {
        RequestIrp->IoStatus.Status = STATUS_REVISION_MISMATCH;
        return(STATUS_REVISION_MISMATCH);
    }

    length = srbControl->HeaderLength + srbControl->Length;
    if ((length < srbControl->HeaderLength) ||
        (length < srbControl->Length)) {

        //
        // total length overflows a ULONG
        //
        return(STATUS_INVALID_PARAMETER);
    }

    outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < length &&
        irpStack->Parameters.DeviceIoControl.InputBufferLength < length ) {

        RequestIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        return(STATUS_BUFFER_TOO_SMALL);
    }

    //
    // Set the logical unit addressing to the first logical unit.  This is
    // merely used for addressing purposes.
    //

    logicalUnit = SpFindSafeLogicalUnit(
                    DeviceExtension->CommonExtension.DeviceObject,
                    0xff,
                    RequestIrp);

    if (logicalUnit == NULL) {
        RequestIrp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        return(STATUS_DEVICE_DOES_NOT_EXIST);
    }

    //
    // Must be at PASSIVE_LEVEL to use synchronous FSD.
    //

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Initialize the notification event.
    //

    KeInitializeEvent(&event,
                        NotificationEvent,
                        FALSE);

    //
    // Build IRP for this request.
    // Note we do this synchronously for two reasons.  If it was done
    // asynchonously then the completion code would have to make a special
    // check to deallocate the buffer.  Second if a completion routine were
    // used then an additional IRP stack location would be needed.
    //

    irp = IoBuildSynchronousFsdRequest(
                IRP_MJ_SCSI,
                DeviceExtension->CommonExtension.DeviceObject,
                srbControl,
                length,
                &startingOffset,
                &event,
                &ioStatusBlock);

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set major and minor codes.
    //

    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->MinorFunction = 1;

    //
    // Fill in SRB fields.
    //

    irpStack->Parameters.Others.Argument1 = &srb;

    //
    // Zero out the srb.
    //

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    srb.PathId = logicalUnit->PathId;
    srb.TargetId = logicalUnit->TargetId;
    srb.Lun = logicalUnit->Lun;

    srb.Function = SRB_FUNCTION_IO_CONTROL;
    srb.Length = sizeof(SCSI_REQUEST_BLOCK);

    srb.SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_NO_QUEUE_FREEZE;
    srb.QueueAction = SRB_SIMPLE_TAG_REQUEST;

    srb.OriginalRequest = irp;

    //
    // Set timeout to requested value.
    //

    srb.TimeOutValue = srbControl->Timeout;

    //
    // Set the data buffer.
    //

    srb.DataBuffer = srbControl;
    srb.DataTransferLength = length;

    //
    // Flush the data buffer for output. This will insure that the data is
    // written back to memory.  Since the data-in flag is the the port driver
    // will flush the data again for input which will ensure the data is not
    // in the cache.
    //

    KeFlushIoBuffers(irp->MdlAddress, FALSE, TRUE);

    //
    // Call port driver to handle this request.
    //

    status = IoCallDriver(DeviceExtension->CommonExtension.DeviceObject, irp);

    //
    // Wait for request to complete.
    //

    if(status == STATUS_PENDING) {
        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
    }

    //
    // Set the information length to the smaller of the output buffer length
    // and the length returned in the srb.
    //

    RequestIrp->IoStatus.Information = srb.DataTransferLength > outputLength ?
        outputLength : srb.DataTransferLength;

    RequestIrp->IoStatus.Status = ioStatusBlock.Status;

    SpReleaseRemoveLock(logicalUnit->CommonExtension.DeviceObject,
                        RequestIrp);

    return RequestIrp->IoStatus.Status;
}


NTSTATUS
SpSendPassThrough (
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    )

/*++

Routine Description:

    This function sends a user specified SCSI request block.
    It creates an srb which is processed normally by the port driver.
    This call is synchornous.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    RequestIrp - Supplies a pointe to the Irp which made the original request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/

{
    PIRP                    irp;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_PASS_THROUGH      srbControl;
    SCSI_REQUEST_BLOCK      srb;
    KEVENT                  event;
    LARGE_INTEGER           startingOffset;
    IO_STATUS_BLOCK         ioStatusBlock;
    KIRQL                   currentIrql;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    ULONG                   outputLength;
    ULONG                   length;
    ULONG                   bufferOffset;
    PVOID                   buffer;
    PVOID                   senseBuffer;
    UCHAR                   majorCode;
    NTSTATUS                status;

#if defined (_WIN64)
    PSCSI_PASS_THROUGH32    srbControl32;
#endif

    PAGED_CODE();
    startingOffset.QuadPart = (LONGLONG) 1;

    DebugPrint((3,"SpSendPassThrough: Enter routine\n"));

    //
    // Get a pointer to the control block.
    //

    irpStack = IoGetCurrentIrpStackLocation(RequestIrp);
    srbControl = RequestIrp->AssociatedIrp.SystemBuffer;

    //
    // Validiate the user buffer.
    //

#if defined (_WIN64)

    if (IoIs32bitProcess(RequestIrp)) {

        ULONG32 dataBufferOffset;
        ULONG   senseInfoOffset;

        srbControl32 = (PSCSI_PASS_THROUGH32) (RequestIrp->AssociatedIrp.SystemBuffer);

        //
        // copy the fields that follow the ULONG_PTR
        //
        dataBufferOffset = (ULONG32) (srbControl32->DataBufferOffset);
        senseInfoOffset = srbControl32->SenseInfoOffset;
        srbControl->DataBufferOffset = (ULONG_PTR) dataBufferOffset;
        srbControl->SenseInfoOffset = senseInfoOffset;

        RtlCopyMemory(srbControl->Cdb,
                      srbControl32->Cdb,
                      16*sizeof(UCHAR)
                      );

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SCSI_PASS_THROUGH32)){
            return(STATUS_INVALID_PARAMETER);
        }

        if (srbControl->Length != sizeof(SCSI_PASS_THROUGH32) &&
            srbControl->Length != sizeof(SCSI_PASS_THROUGH_DIRECT32)) {
            return(STATUS_REVISION_MISMATCH);
        }

    } else {

#endif
        if (irpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SCSI_PASS_THROUGH)){
            DebugPrint((2, "SpSendPassThrough: Input buffer length %#08lx too small\n",
                        irpStack->Parameters.DeviceIoControl.InputBufferLength));
            return(STATUS_INVALID_PARAMETER);
        }

        if (srbControl->Length != sizeof(SCSI_PASS_THROUGH) &&
            srbControl->Length != sizeof(SCSI_PASS_THROUGH_DIRECT)) {
            DebugPrint((2, "SpSendPassThrough: SrbControl length %#08lx incorrect\n",
                        srbControl->Length));
            return(STATUS_REVISION_MISMATCH);
        }

#if defined (_WIN64)
    }
#endif
    //
    // Get a pointer to the logical unit extension.  If none exists it's a
    // fatal error.
    //

    logicalUnit = GetLogicalUnitExtension(DeviceExtension,
                                          srbControl->PathId,
                                          srbControl->TargetId,
                                          srbControl->Lun,
                                          RequestIrp,
                                          TRUE);

    if(logicalUnit == NULL) {
        RequestIrp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        DebugPrint((2, "SpSendPassThrough: no such logical unit (%d,%d,%d)\n",
                    srbControl->PathId,
                    srbControl->TargetId,
                    srbControl->Lun));

        return STATUS_NO_SUCH_DEVICE;
    }

    if(logicalUnit->CommonExtension.IsRemoved) {
        DebugPrint((2, "SpSendPassThrough: lun (%d,%d,%d) is removed\n",
                    srbControl->PathId,
                    srbControl->TargetId,
                    srbControl->Lun));
        SpReleaseRemoveLock(logicalUnit->DeviceObject,
                            RequestIrp);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Validate the rest of the buffer parameters.
    //

    if (srbControl->CdbLength > 16) {
        DebugPrint((2, "SpSendPassThrough: CdbLength %#x is incorrect\n",
                    srbControl->CdbLength));
        SpReleaseRemoveLock(logicalUnit->DeviceObject,
                            RequestIrp);
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // If there's a sense buffer then its offset cannot be shorter than the
    // length of the srbControl block, nor can it be located after the data
    // buffer (if any)
    //

    if (srbControl->SenseInfoLength != 0 &&
        (srbControl->Length > srbControl->SenseInfoOffset ||
        (srbControl->SenseInfoOffset + srbControl->SenseInfoLength >
        srbControl->DataBufferOffset && srbControl->DataTransferLength != 0))) {

        DebugPrint((2, "SpSendPassThrough: Bad sense info offset\n"));

        SpReleaseRemoveLock(logicalUnit->DeviceObject,
                            RequestIrp);
        return(STATUS_INVALID_PARAMETER);
    }

    majorCode = !srbControl->DataIn ? IRP_MJ_WRITE : IRP_MJ_READ;

    if (srbControl->DataTransferLength == 0) {

        length = 0;
        buffer = NULL;
        bufferOffset = 0;
        majorCode = IRP_MJ_FLUSH_BUFFERS;

    } else if (srbControl->DataBufferOffset > outputLength &&
        srbControl->DataBufferOffset > irpStack->Parameters.DeviceIoControl.InputBufferLength) {

        //
        // The data buffer offset is greater than system buffer.  Assume this
        // is a user mode address.
        //

        if (srbControl->SenseInfoOffset + srbControl->SenseInfoLength  > outputLength
            && srbControl->SenseInfoLength) {

            DebugPrint((2, "SpSendPassThrough: sense buffer is not in ioctl buffer\n"));

            SpReleaseRemoveLock(logicalUnit->DeviceObject,
                                RequestIrp);
            return(STATUS_INVALID_PARAMETER);

        }

        //
        // Make sure the buffer is properly aligned.
        //

        if (srbControl->DataBufferOffset &
            logicalUnit->DeviceObject->AlignmentRequirement) {

            DebugPrint((2, "SpSendPassThrough: data buffer not aligned "
                           "[%#p doesn't have alignment of %#0x\n",
                        srbControl->DataBufferOffset,
                        logicalUnit->DeviceObject->AlignmentRequirement));

            SpReleaseRemoveLock(logicalUnit->DeviceObject,
                                RequestIrp);
            return(STATUS_INVALID_PARAMETER);

        }

        length = srbControl->DataTransferLength;
        buffer = (PCHAR) srbControl->DataBufferOffset;
        bufferOffset = 0;

        //
        // make sure the user buffer is valid.  The last byte must be at or 
        // below the highest possible user address.  Additionally the end of 
        // the buffer must not wrap around in memory (taking care to ensure that
        // a one-byte length buffer is okay)
        //

        if (RequestIrp->RequestorMode != KernelMode) {
            if (length) {
                ULONG_PTR endByte = (ULONG_PTR) buffer + length - 1;

                if ((endByte > (ULONG_PTR) MM_HIGHEST_USER_ADDRESS) ||
                    ((ULONG_PTR) buffer >= endByte + 1)) {

                    DebugPrint((2, "SpSendPassThrough: user buffer invalid\n"));

                    SpReleaseRemoveLock(logicalUnit->DeviceObject,
                                        RequestIrp);

                    return STATUS_INVALID_USER_BUFFER;
                }
            }
        }

    } else {

        if (srbControl->DataIn != SCSI_IOCTL_DATA_IN) {

            if ((srbControl->SenseInfoOffset + srbControl->SenseInfoLength > outputLength
                && srbControl->SenseInfoLength != 0) ||
                srbControl->DataBufferOffset + srbControl->DataTransferLength >
                irpStack->Parameters.DeviceIoControl.InputBufferLength ||
                srbControl->Length > srbControl->DataBufferOffset) {

                DebugPrint((2, "SpSendPassThrough: sense or data buffer not in ioctl buffer\n"));

                SpReleaseRemoveLock(logicalUnit->DeviceObject, RequestIrp);
                return STATUS_INVALID_PARAMETER;
            }
        }

        //
        // Make sure the buffer is properly aligned.
        //

        if (srbControl->DataBufferOffset &
            logicalUnit->DeviceObject->AlignmentRequirement) {

            DebugPrint((2, "SpSendPassThrough: data buffer not aligned "
                           "[%#p doesn't have alignment of %#0x\n",
                        srbControl->DataBufferOffset,
                        logicalUnit->DeviceObject->AlignmentRequirement));

            SpReleaseRemoveLock(logicalUnit->DeviceObject,
                                RequestIrp);
            return STATUS_INVALID_PARAMETER;
        }

        if (srbControl->DataIn) {

            if (srbControl->DataBufferOffset + srbControl->DataTransferLength > outputLength ||
                srbControl->Length > srbControl->DataBufferOffset) {

                DebugPrint((2, "SpSendPassThrough: data buffer not in ioctl buffer or offset too small\n"));

                SpReleaseRemoveLock(logicalUnit->DeviceObject, RequestIrp);
                return STATUS_INVALID_PARAMETER;
            }
        }

        length = (ULONG)srbControl->DataBufferOffset +
                        srbControl->DataTransferLength;
        buffer = (PUCHAR) srbControl;
        bufferOffset = (ULONG)srbControl->DataBufferOffset;

    }

    //
    // Validate that the request isn't too large for the miniport.
    //

    if (srbControl->DataTransferLength &&
        ((ADDRESS_AND_SIZE_TO_SPAN_PAGES(
              (PUCHAR)buffer+bufferOffset,
              srbControl->DataTransferLength
              ) > DeviceExtension->Capabilities.MaximumPhysicalPages) ||
        (DeviceExtension->Capabilities.MaximumTransferLength <
         srbControl->DataTransferLength))) {

        DebugPrint((2, "SpSendPassThrough: request is too large for this miniport\n"));

        SpReleaseRemoveLock(logicalUnit->DeviceObject, RequestIrp);
        return(STATUS_INVALID_PARAMETER);

    }


    if (srbControl->TimeOutValue == 0 ||
        srbControl->TimeOutValue > 30 * 60 * 60) {
        DebugPrint((2, "SpSendPassThrough: timeout value %d is invalid\n",
                    srbControl->TimeOutValue));
        SpReleaseRemoveLock(logicalUnit->DeviceObject, RequestIrp);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check for illegal command codes.
    //

    if (srbControl->Cdb[0] == SCSIOP_COPY ||
        srbControl->Cdb[0] == SCSIOP_COMPARE ||
        srbControl->Cdb[0] == SCSIOP_COPY_COMPARE) {

        DebugPrint((2, "SpSendPassThrough: failing attempt to send restricted "
                       "SCSI command %#x\n", srbControl->Cdb[0]));
        SpReleaseRemoveLock(logicalUnit->DeviceObject, RequestIrp);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // If this request came through a normal device control rather than from
    // class driver then the device must exist and be unclaimed. Class drivers
    // will set the minor function code for the device control.  It is always
    // zero for a user request.
    //

    if((irpStack->MinorFunction == 0) &&
       (logicalUnit->IsClaimed)) {

        DebugPrint((2, "SpSendPassThrough: Pass through request to claimed "
                       "device must come through the driver which claimed it\n"));
        SpReleaseRemoveLock(logicalUnit->DeviceObject, RequestIrp);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Allocate an aligned request sense buffer.
    //

    if (srbControl->SenseInfoLength != 0) {

        senseBuffer = SpAllocatePool(
                        NonPagedPoolCacheAligned,
                        srbControl->SenseInfoLength,
                        SCSIPORT_TAG_SENSE_BUFFER,
                        DeviceExtension->DeviceObject->DriverObject);

        if (senseBuffer == NULL) {

            DebugPrint((2, "SpSendPassThrogh: Unable to allocate sense buffer\n"));
            SpReleaseRemoveLock(logicalUnit->DeviceObject, RequestIrp);
            return(STATUS_INSUFFICIENT_RESOURCES);

        }

    } else {

        senseBuffer = NULL;

    }

    //
    // Must be at PASSIVE_LEVEL to use synchronous FSD.
    //

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Initialize the notification event.
    //

    KeInitializeEvent(&event,
                        NotificationEvent,
                        FALSE);

    //
    // Build IRP for this request.
    // Note we do this synchronously for two reasons.  If it was done
    // asynchonously then the completion code would have to make a special
    // check to deallocate the buffer.  Second if a completion routine were
    // used then an addation stack locate would be needed.
    //

    try {

        irp = IoBuildSynchronousFsdRequest(
                    majorCode,
                    logicalUnit->DeviceObject,
                    buffer,
                    length,
                    &startingOffset,
                    &event,
                    &ioStatusBlock);

    } except(EXCEPTION_EXECUTE_HANDLER) {

        NTSTATUS exceptionCode;

        //
        // An exception was incurred while attempting to probe the
        // caller's parameters.  Dereference the file object and return
        // an appropriate error status code.
        //

        if (senseBuffer != NULL) {
            ExFreePool(senseBuffer);
        }

        exceptionCode = GetExceptionCode();
        DebugPrint((2, "SpSendPassThrough: Exception %#08lx building irp\n",
                    exceptionCode));
        SpReleaseRemoveLock(logicalUnit->DeviceObject, RequestIrp);
        return exceptionCode;

    }

    if (irp == NULL) {

        if (senseBuffer != NULL) {
            ExFreePool(senseBuffer);
        }

        DebugPrint((2, "SpSendPassThrough: Couldn't allocate irp\n"));
        SpReleaseRemoveLock(logicalUnit->DeviceObject,
                            RequestIrp);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set major code.
    //

    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->MinorFunction = 1;

    //
    // Fill in SRB fields.
    //

    irpStack->Parameters.Others.Argument1 = &srb;

    //
    // Zero out the srb.
    //

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Fill in the srb.
    //

    srb.Length = SCSI_REQUEST_BLOCK_SIZE;
    srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb.SrbStatus = SRB_STATUS_PENDING;
    srb.PathId = srbControl->PathId;
    srb.TargetId = srbControl->TargetId;
    srb.Lun = srbControl->Lun;
    srb.CdbLength = srbControl->CdbLength;
    srb.SenseInfoBufferLength = srbControl->SenseInfoLength;

    switch (srbControl->DataIn) {
    case SCSI_IOCTL_DATA_OUT:
       if (srbControl->DataTransferLength) {
           srb.SrbFlags = SRB_FLAGS_DATA_OUT;
       }
       break;

    case SCSI_IOCTL_DATA_IN:
       if (srbControl->DataTransferLength) {
           srb.SrbFlags = SRB_FLAGS_DATA_IN;
       }
       break;

    default:
        srb.SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT;
        break;
    }

    if (srbControl->DataTransferLength == 0) {
        srb.SrbFlags = 0;
    } else {

        //
        // Flush the data buffer for output. This will insure that the data is
        // written back to memory.
        //

        KeFlushIoBuffers(irp->MdlAddress, FALSE, TRUE);

    }

    srb.SrbFlags |= logicalUnit->CommonExtension.SrbFlags;
    srb.SrbFlags |= (SRB_FLAGS_DISABLE_SYNCH_TRANSFER & DeviceExtension->CommonExtension.SrbFlags);
    srb.SrbFlags |= SRB_FLAGS_NO_QUEUE_FREEZE;
    srb.DataTransferLength = srbControl->DataTransferLength;
    srb.TimeOutValue = srbControl->TimeOutValue;
    srb.DataBuffer = (PCHAR) buffer + bufferOffset;
    srb.SenseInfoBuffer = senseBuffer;

    srb.OriginalRequest = irp;

    RtlCopyMemory(srb.Cdb, srbControl->Cdb, srbControl->CdbLength);

    //
    // Disable autosense if there's no sense buffer to put the data in.
    //

    if(senseBuffer == NULL) {
        srb.SrbFlags |= SRB_FLAGS_DISABLE_AUTOSENSE;
    }

    //
    // Call port driver to handle this request.
    //

    status = IoCallDriver(logicalUnit->DeviceObject, irp);

    //
    // Wait for request to complete.
    //

    if (status == STATUS_PENDING) {

          KeWaitForSingleObject(&event,
                                Executive,
                                KernelMode,
                                FALSE,
                                NULL);
    } else {
        ioStatusBlock.Status = status;
    }

    //
    // Copy the returned values from the srb to the control structure.
    //

    srbControl->ScsiStatus = srb.ScsiStatus;
    if (srb.SrbStatus  & SRB_STATUS_AUTOSENSE_VALID) {

        //
        // Set the status to success so that the data is returned.
        //

        ioStatusBlock.Status = STATUS_SUCCESS;
        srbControl->SenseInfoLength = srb.SenseInfoBufferLength;

        //
        // Copy the sense data to the system buffer.
        //

        RtlCopyMemory((PUCHAR) srbControl + srbControl->SenseInfoOffset,
                      senseBuffer,
                      srb.SenseInfoBufferLength);

    } else {
        srbControl->SenseInfoLength = 0;
    }

    //
    // Free the sense buffer.
    //

    if (senseBuffer != NULL) {
        ExFreePool(senseBuffer);
    }

    //
    // If the srb status is buffer underrun then set the status to success.
    // This insures that the data will be returned to the caller.
    //

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        ioStatusBlock.Status = STATUS_SUCCESS;

    }

    srbControl->DataTransferLength = srb.DataTransferLength;

    //
    // Set the information length
    //

    if (!srbControl->DataIn || bufferOffset == 0) {

        RequestIrp->IoStatus.Information = srbControl->SenseInfoOffset +
            srbControl->SenseInfoLength;

    } else {

        RequestIrp->IoStatus.Information = srbControl->DataBufferOffset +
            srbControl->DataTransferLength;

    }

    RequestIrp->IoStatus.Status = ioStatusBlock.Status;

    ASSERT(TEST_FLAG(srb.SrbStatus, SRB_STATUS_QUEUE_FROZEN) == 0);

    SpReleaseRemoveLock(logicalUnit->DeviceObject, RequestIrp);

    return ioStatusBlock.Status;
}


VOID
SpMiniPortTimerDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine calls the miniport when its requested timer fires.
    It interlocks either with the port spinlock and the interrupt object.

Arguments:

    Dpc - Unsed.

    DeviceObject - Supplies a pointer to the device object for this adapter.

    SystemArgument1 - Unused.

    SystemArgument2 - Unused.

Return Value:

    None.

--*/

{
    PADAPTER_EXTENSION deviceExtension = ((PDEVICE_OBJECT) DeviceObject)->DeviceExtension;

    //
    // Acquire the port spinlock.
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

    //
    // Make sure we haven't removed the adapter in the meantime.
    //

    if (!TEST_FLAG(deviceExtension->InterruptData.InterruptFlags,
                   PD_ADAPTER_REMOVED)) {

        //
        // Make sure the timer routine is still desired.
        //

        if (deviceExtension->HwTimerRequest != NULL) {

            deviceExtension->SynchronizeExecution(
                deviceExtension->InterruptObject,
                (PKSYNCHRONIZE_ROUTINE) deviceExtension->HwTimerRequest,
                deviceExtension->HwDeviceExtension
                );

        }
    }

    //
    // Release the spinlock.
    //

    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

    // Check for miniport work requests. Note this is an unsynchonized
    // test on a bit that can be set by the interrupt routine; however,
    // the worst that can happen is that the completion DPC checks for work
    // twice.
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

        SpRequestCompletionDpc(DeviceObject);
    }

}


BOOLEAN
SpSynchronizeExecution (
    IN PKINTERRUPT Interrupt,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    This routine calls the miniport entry point which was passed in as
    a parameter.  It acquires a spin lock so that all accesses to the
    miniport's routines are synchronized.  This routine is used as a
    subsitute for KeSynchronizedExecution for miniports which do not use
    hardware interrupts.


Arguments:

    Interrrupt - Supplies a pointer to the port device extension.

    SynchronizeRoutine - Supplies a pointer to the routine to be called.

    SynchronizeContext - Supplies the context to pass to the
        SynchronizeRoutine.

Return Value:

    Returns the returned by the SynchronizeRoutine.

--*/

{
    PADAPTER_EXTENSION deviceExtension = (PADAPTER_EXTENSION) Interrupt;
    BOOLEAN returnValue;
    KIRQL oldIrql;

    KeAcquireSpinLock(&deviceExtension->InterruptSpinLock, &oldIrql);

    returnValue = SynchronizeRoutine(SynchronizeContext);

    KeReleaseSpinLock(&deviceExtension->InterruptSpinLock, oldIrql);

    return(returnValue);
}

NTSTATUS
SpClaimLogicalUnit(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnitExtension,
    IN PIRP Irp,
    IN BOOLEAN LegacyClaim
    )

/*++

Routine Description:

    This function finds the specified device in the logical unit information
    and either updates the device object point or claims the device.  If the
    device is already claimed, then the request fails.  If the request succeeds,
    then the current device object is returned in the data buffer pointer
    of the SRB.

    This routine must be called with the remove lock held for the logical
    unit.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    Irp - Supplies a pointer to the Irp which made the original request.

    LegacyClaim - indicates whether the device should be started before being
                  claimed.  Used for to start the device before allowing
                  legacy drivers to claim it.

Return Value:

    Returns the status of the operation.  Either success, no device or busy.

--*/

{
    KIRQL currentIrql;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    PDEVICE_OBJECT saveDevice;

    PVOID sectionHandle;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Get SRB address from current IRP stack.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = (PSCSI_REQUEST_BLOCK) irpStack->Parameters.Others.Argument1;

    //
    // Make sure the device can be started - this needs to be done outside
    // of the spinlock.
    //

    if(LegacyClaim) {

        status = ScsiPortStartLogicalUnit(LogicalUnitExtension);

        if(!NT_SUCCESS(status)) {

            srb->SrbStatus = SRB_STATUS_ERROR;
            return status;
        }

        LogicalUnitExtension->IsLegacyClaim = TRUE;
    }

#ifdef ALLOC_PRAGMA
    sectionHandle = MmLockPagableCodeSection(SpClaimLogicalUnit);
    InterlockedIncrement(&SpPAGELOCKLockCount);
#endif

    //
    // Lock the data.
    //

    KeAcquireSpinLock(&AdapterExtension->SpinLock, &currentIrql);

    if (srb->Function == SRB_FUNCTION_RELEASE_DEVICE) {

        LogicalUnitExtension->IsClaimed = FALSE;
        KeReleaseSpinLock(&AdapterExtension->SpinLock, currentIrql);
        srb->SrbStatus = SRB_STATUS_SUCCESS;
        return(STATUS_SUCCESS);
    }

    //
    // Check for a claimed device.
    //

    if (LogicalUnitExtension->IsClaimed) {

        KeReleaseSpinLock(&AdapterExtension->SpinLock, currentIrql);
        srb->SrbStatus = SRB_STATUS_BUSY;
        return(STATUS_DEVICE_BUSY);
    }

    //
    // Save the current device object.
    //

    saveDevice = LogicalUnitExtension->CommonExtension.DeviceObject;

    //
    // Update the lun information based on the operation type.
    //

    if (srb->Function == SRB_FUNCTION_CLAIM_DEVICE) {
        LogicalUnitExtension->IsClaimed = TRUE;
    }

    if (srb->Function == SRB_FUNCTION_ATTACH_DEVICE) {
        ASSERT(FALSE);
        LogicalUnitExtension->CommonExtension.DeviceObject = srb->DataBuffer;
    }

    srb->DataBuffer = saveDevice;

    KeReleaseSpinLock(&AdapterExtension->SpinLock, currentIrql);
    srb->SrbStatus = SRB_STATUS_SUCCESS;

#ifdef ALLOC_PRAGMA
    InterlockedDecrement(&SpPAGELOCKLockCount);
    MmUnlockPagableImageSection(sectionHandle);
#endif

    return(STATUS_SUCCESS);
}


NTSTATUS
SpSendReset(
    IN PDEVICE_OBJECT Adapter,
    IN PIRP RequestIrp
    )

/*++

Routine Description:

    This routine will create an assynchronous request to reset the scsi bus
    and route that through the port driver.  The completion routine on the
    request will take care of completing the original irp

    This call is asynchronous.

Arguments:

    Adapter - the port driver to be reset

    Irp - a pointer to the reset request - this request will already have been
          marked as PENDING.

Return Value:

    STATUS_PENDING if the request is pending
    STATUS_SUCCESS if the request completed successfully
    or an error status

--*/

{
    PADAPTER_EXTENSION adapterExtension = Adapter->DeviceExtension;

    PSTORAGE_BUS_RESET_REQUEST resetRequest =
        RequestIrp->AssociatedIrp.SystemBuffer;

    PIRP irp = NULL;
    PIO_STACK_LOCATION irpStack = NULL;

    PRESET_COMPLETION_CONTEXT completionContext = NULL;

    BOOLEAN completeRequest = FALSE;
    NTSTATUS status;

    PLOGICAL_UNIT_EXTENSION logicalUnit = NULL;

    PAGED_CODE();

    ASSERT_FDO(Adapter);

    //
    // use finally handler to complete request if necessary
    //

    try {

        //
        // Make sure the path id is valid
        //

        if(resetRequest->PathId >= adapterExtension->NumberOfBuses) {

            status = STATUS_INVALID_PARAMETER;
            completeRequest = TRUE;
            leave;
        }

        //
        // Find a logical unit that's going to be sticking around for a while
        // and lock it using the original request irp.  We'll unlock it in the
        // completion routine.
        //

        logicalUnit = SpFindSafeLogicalUnit(Adapter,
                                            resetRequest->PathId,
                                            RequestIrp);

        if(logicalUnit == NULL) {

            //
            // There's nothing safe on this bus so in this case we won't bother
            // resetting it
            // XXX - this may be a bug
            //

            status = STATUS_DEVICE_DOES_NOT_EXIST;
            completeRequest = TRUE;
            leave;
        }

        //
        // Try to allocate a completion context block
        //

        completionContext = SpAllocatePool(NonPagedPool,
                                           sizeof(RESET_COMPLETION_CONTEXT),
                                           SCSIPORT_TAG_RESET,
                                           Adapter->DriverObject);

        if(completionContext == NULL) {

            DebugPrint((1, "SpSendReset: Unable to allocate completion "
                           "context\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            completeRequest = TRUE;
            leave;
        }

        RtlZeroMemory(completionContext, sizeof(RESET_COMPLETION_CONTEXT));

        completionContext->OriginalIrp = RequestIrp;
        completionContext->SafeLogicalUnit = logicalUnit->DeviceObject;
        completionContext->AdapterDeviceObject = Adapter;

        irp = IoBuildAsynchronousFsdRequest(
                IRP_MJ_FLUSH_BUFFERS,
                logicalUnit->DeviceObject,
                NULL,
                0,
                NULL,
                NULL);

        if(irp == NULL) {
            DebugPrint((1, "SpSendReset: unable to allocate irp\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            completeRequest = TRUE;
            leave;
        }

        //
        // Stick the srb pointer into the irp stack
        //

        irpStack = IoGetNextIrpStackLocation(irp);

        irpStack->MajorFunction = IRP_MJ_SCSI;
        irpStack->MinorFunction = 1;
        irpStack->Parameters.Scsi.Srb = &(completionContext->Srb);

        //
        // Fill in the srb
        //

        completionContext->Srb.Function = SRB_FUNCTION_RESET_BUS;
        completionContext->Srb.SrbStatus = SRB_STATUS_PENDING;

        completionContext->Srb.OriginalRequest = irp;

        IoSetCompletionRoutine(
            irp,
            SpSendResetCompletion,
            completionContext,
            TRUE,
            TRUE,
            TRUE);

        completeRequest = FALSE;

        status = IoCallDriver(logicalUnit->DeviceObject, irp);

    } finally {

        if(completeRequest) {

            if(completionContext != NULL) {
                ExFreePool(completionContext);
            }

            if(irp != NULL) {
                IoFreeIrp(irp);
            }

            RequestIrp->IoStatus.Status = status;

            if(logicalUnit != NULL) {
                SpReleaseRemoveLock(logicalUnit->DeviceObject,
                                    RequestIrp);
            }

            //
            // Release the remove lock for the adapter.
            //

            SpReleaseRemoveLock(Adapter, RequestIrp);

            SpCompleteRequest(Adapter, RequestIrp, NULL, IO_NO_INCREMENT);
        }
    }

    return status;
}

NTSTATUS
SpSendResetCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PRESET_COMPLETION_CONTEXT Context
    )

/*++

Routine Description:

    This routine handles completion of the srb generated from an asynchronous
    IOCTL_SCSI_RESET_BUS request.  It will take care of freeing all resources
    allocated during SpSendReset as well as completing the original request.

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp sent to the port driver

    Context - a pointer to a reset completion context which contains
              the original request and a pointer to the srb sent down

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    PIRP originalIrp = Context->OriginalIrp;

    originalIrp->IoStatus.Status = Irp->IoStatus.Status;

    SpReleaseRemoveLock(Context->SafeLogicalUnit, originalIrp);
    SpReleaseRemoveLock(Context->AdapterDeviceObject, originalIrp);
    SpCompleteRequest(Context->AdapterDeviceObject,
                      originalIrp,
                      NULL,
                      IO_NO_INCREMENT);

    ExFreePool(Context);
    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


PLOGICAL_UNIT_EXTENSION
SpFindSafeLogicalUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR PathId,
    IN PVOID LockTag
    )

/*++

Routine Description:

    This routine will scan the bus in question and return a pointer to the
    first logical unit on the bus that is not involved in a rescan operation.
    This can be used to find a logical unit for ioctls or other requests that
    may not specify one (IOCTL_SCSI_MINIPORT, IOCTL_SCSI_RESET_BUS, etc)

Arguments:

    DeviceObject - a pointer to the device object

    PathId - The path number to be searched for a logical unit.  If this is 0xff
             then the first unit on any path will be found.

Return Value:

    a pointer to a logical unit extension
    NULL if none was found

--*/

{
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    UCHAR target;

    PLOGICAL_UNIT_EXTENSION logicalUnit;

    ASSERT_FDO(DeviceObject);

    //
    // Set the logical unit addressing to the first logical unit.  This is
    // merely used for addressing purposes.
    //

    for (target = 0; target < NUMBER_LOGICAL_UNIT_BINS; target++) {
        PLOGICAL_UNIT_BIN bin = &deviceExtension->LogicalUnitList[target];
        KIRQL oldIrql;

        KeAcquireSpinLock(&bin->Lock, &oldIrql);

        logicalUnit = bin->List;

        //
        // Walk the logical unit list to the end, looking for a safe one.
        // If it was created for a rescan, it might be freed before this
        // request is complete.
        //

        for(logicalUnit = bin->List;
            logicalUnit != NULL;
            logicalUnit = logicalUnit->NextLogicalUnit) {

            if ((logicalUnit->IsTemporary == FALSE) &&
                ((PathId == 0xff) || (logicalUnit->PathId == PathId))) {

                ULONG isRemoved;

                //
                // This lu isn't being rescanned and if a path id was specified
                // it matches so this must be the right one
                //

                isRemoved = SpAcquireRemoveLock(
                                logicalUnit->DeviceObject,
                                LockTag);
                if(isRemoved) {
                    SpReleaseRemoveLock(
                        logicalUnit->DeviceObject,
                        LockTag);
                    continue;
                }
                KeReleaseSpinLock(&bin->Lock, oldIrql);
                return logicalUnit;
            }
        }
        KeReleaseSpinLock(&bin->Lock, oldIrql);
    }

    return NULL;
}


NTSTATUS
SpRerouteLegacyRequest(
    IN PDEVICE_OBJECT AdapterObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the adapter receives requests which have
    not been assigned SRB_DATA blocks.  The routine will build a new irp
    for the SRB and issue that irp to the appropriate logical unit for
    processing.

    The adapter remove lock should NOT be held when processing this
    request.

Arguments:

    AdapterObject - the adapter which received the request

    Irp - the request

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION adapter = AdapterObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

    ULONG_PTR tag;

    PLOGICAL_UNIT_EXTENSION logicalUnit;

    NTSTATUS status;

    //
    // Acqire a lock on the logical unit we're going to send this through.
    // use IRP+1 so we don't collide with the regular i/o locks.
    //

    tag = ((ULONG_PTR) Irp) + 1;

    logicalUnit = GetLogicalUnitExtension(adapter,
                                          srb->PathId,
                                          srb->TargetId,
                                          srb->Lun,
                                          (PVOID) tag,
                                          TRUE);

    //
    // Release the lock the caller acquired on the adapter.
    //

    SpReleaseRemoveLock(AdapterObject, Irp);

    if(logicalUnit == NULL) {
        status = STATUS_DEVICE_DOES_NOT_EXIST;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    } else {

        //
        // Reference the device object.  That way it won't go away and we
        // don't have to keep a remove lock around.
        //

        ObReferenceObject(logicalUnit->DeviceObject);
        SpReleaseRemoveLock(logicalUnit->DeviceObject, (PVOID) tag);

        //
        // Skip the current irp stack location.  That will cause it
        // to get rerun by the logical unit we call.
        //

        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(logicalUnit->DeviceObject, Irp);

        ObDereferenceObject(logicalUnit->DeviceObject);

    }
    return status;
}


NTSTATUS
SpFlushReleaseQueue(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN Flush
    )
{
    PADAPTER_EXTENSION adapter = LogicalUnit->AdapterExtension;
    KIRQL oldIrql;

    NTSTATUS status = STATUS_SUCCESS;

    DebugPrint((2,"SpFlushReleaseQueue: SCSI unfreeze queue TID %d\n",
        LogicalUnit->TargetId));

    ASSERT(!TEST_FLAG(LogicalUnit->LuFlags, LU_QUEUE_LOCKED));

    //
    // Acquire the spinlock to protect the flags structure and the saved
    // interrupt context.
    //

    KeAcquireSpinLock(&adapter->SpinLock, &oldIrql);

    //
    // Make sure the queue is frozen.
    //

    if (!TEST_FLAG(LogicalUnit->LuFlags, LU_QUEUE_FROZEN)) {

        DebugPrint((1,"ScsiPortFdoDispatch:  Request to unfreeze an "
                      "unfrozen queue!\n"));

        KeReleaseSpinLock(&adapter->SpinLock, oldIrql);

        if(Flush) {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        return status;
    }

    CLEAR_FLAG(LogicalUnit->LuFlags, LU_QUEUE_FROZEN);

    if(Flush) {

        PIRP listIrp = NULL;

        PKDEVICE_QUEUE_ENTRY packet;

        PIRP nextIrp;
        PIO_STACK_LOCATION irpStack;
        PSCSI_REQUEST_BLOCK srb;

        //
        // The queue may not be busy so we have to use the IfBusy variant.  
        // Use a zero key to pull items from the head of it (if any are there)
        //

        while ((packet =
                KeRemoveByKeyDeviceQueueIfBusy(
                    &(LogicalUnit->DeviceObject->DeviceQueue),
                    0))
            != NULL) {

            PIRP nextIrp;
            PIO_STACK_LOCATION irpStack;
            PSCSI_REQUEST_BLOCK srb;

            nextIrp = CONTAINING_RECORD(packet,
                                        IRP,
                                        Tail.Overlay.DeviceQueueEntry);

            //
            // Get the srb.
            //

            irpStack = IoGetCurrentIrpStackLocation(nextIrp);
            srb = irpStack->Parameters.Scsi.Srb;

            //
            // Set the status code.
            //

            srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
            nextIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

            //
            // Link the requests. They will be completed after the
            // spinlock is released.
            //

            nextIrp->Tail.Overlay.ListEntry.Flink = (PLIST_ENTRY)
                listIrp;

            listIrp = nextIrp;
        }

        //
        // If there is a pending request on the LU, add it to the list so it
        // gets flushed along with the queued requests.
        //

        if (LogicalUnit->PendingRequest != NULL) {

            PIRP irp = LogicalUnit->PendingRequest->CurrentIrp;
            PSCSI_REQUEST_BLOCK srb = LogicalUnit->PendingRequest->CurrentSrb;

            DebugPrint((1, "SpFlushReleaseQueue: flushing pending request irp:%p srb:%p\n", irp, srb));

            srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
            irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            irp->Tail.Overlay.ListEntry.Flink = (PLIST_ENTRY) listIrp;
            listIrp = irp;

            LogicalUnit->PendingRequest = NULL;
            ASSERT(LogicalUnit->LuFlags | LU_PENDING_LU_REQUEST);
            CLEAR_FLAG(LogicalUnit->LuFlags, LU_PENDING_LU_REQUEST);

        }

        //
        // Mark the queue as unfrozen.  Since all the requests have
        // been removed and the device queue is no longer busy, it
        // is effectively unfrozen.
        //

        CLEAR_FLAG(LogicalUnit->LuFlags, LU_QUEUE_FROZEN);

        //
        // Release the spinlock.
        //

        KeReleaseSpinLock(&adapter->SpinLock, oldIrql);

        //
        // Complete the flushed requests.
        //

        while (listIrp != NULL) {

            PSRB_DATA srbData;

            nextIrp = listIrp;
            listIrp = (PIRP) nextIrp->Tail.Overlay.ListEntry.Flink;

            //
            // Get the srb.
            //

            irpStack = IoGetCurrentIrpStackLocation(nextIrp);
            srb = irpStack->Parameters.Scsi.Srb;
            srbData = srb->OriginalRequest;

            srb->OriginalRequest = nextIrp;

            SpReleaseRemoveLock(adapter->DeviceObject, nextIrp);
            SpCompleteRequest(adapter->DeviceObject,
                              nextIrp,
                              srbData,
                              IO_NO_INCREMENT);
        }

    } else {

        //
        // If there is not an untagged request running then start the
        // next request for this logical unit.  Otherwise free the
        // spin lock.
        //

        if (LogicalUnit->CurrentUntaggedRequest == NULL) {

            //
            // GetNextLuRequest frees the spinlock.
            //

            GetNextLuRequest(LogicalUnit);
            KeLowerIrql(oldIrql);

        } else {

            DebugPrint((1,"SpFlushReleaseQueue:  Request to unfreeze queue "
                          "with active request.\n"));
            KeReleaseSpinLock(&adapter->SpinLock, oldIrql);

        }
    }

    return status;
}



VOID
SpLogInterruptFailure(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This function logs an error when an interrupt has not been delivered.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.

    Srb - Supplies a pointer to the request which timed-out.

    UniqueId - Supplies the UniqueId for this error.

Return Value:

    None.

Notes:

    The port device extension spinlock should be held when this routine is
    called.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;

    errorLogEntry = (PIO_ERROR_LOG_PACKET)
        IoAllocateErrorLogEntry(Adapter->DeviceObject,
                                sizeof(IO_ERROR_LOG_PACKET));

    if (errorLogEntry != NULL) {
        errorLogEntry->ErrorCode         = IO_WARNING_INTERRUPT_STILL_PENDING;
        errorLogEntry->SequenceNumber    = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->RetryCount        = 0;
        errorLogEntry->UniqueErrorValue  = 0x215;
        errorLogEntry->FinalStatus       = STATUS_PENDING;
        errorLogEntry->DumpDataSize      = 0;
        IoWriteErrorLogEntry(errorLogEntry);
    }

    DbgPrint("SpTimeoutSynchronized: Adapter %#p had interrupt "
             "pending - the system may not be delivering "
             "interrupts from this adapter\n",
             Adapter->DeviceObject);

    if(ScsiCheckInterrupts) {
        DbgBreakPoint();
    }

    return;
}


VOID
SpDelayedWmiRegistrationControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    This funciton is a callback for a IOWorkItem that will be queued in the CompltetionDpc
    for scsiport.  The completion DPC cannot call IoWMIRegistrationControl because
    it is running at DPC level.

Arguments:

    DeviceObject        - The device object for which this WorkItem was queued.
    Context             - The context contains a pointer to the IOWorkItem so
                          we can free it.

Return Value:

    This work item has to be called with the remove lock held so that the
    device doesn't go before we get to run.

Notes:

    This routine should be called with the RemoveLock held for the deviceObject

--*/
{
    PIO_WORKITEM    pIOWorkItem = (PIO_WORKITEM) Context;

    IoWMIRegistrationControl(DeviceObject, WMIREG_ACTION_REREGISTER);

    // Free the IOWorkItem
    IoFreeWorkItem(pIOWorkItem);

    // Release the remove lock on the device object
    SpReleaseRemoveLock(DeviceObject, pIOWorkItem);
}


VOID
SpCompletionDpcProcessWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PINTERRUPT_DATA savedInterruptData
    )
/*++

Routine Description:

    Will do the processing for WMI events (and registration) for
    completionDpc.

Arguments:

Return Value:

    None

Notes:

--*/
{
    LARGE_INTEGER                currentTime;
    PLOGICAL_UNIT_EXTENSION      logicalUnit;
    PDEVICE_OBJECT               providerDeviceObject;
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    // Pointers to the WMIEventRequests passed in for execution
    PWMI_MINIPORT_REQUEST_ITEM   wmiMiniPortRequestCurrent;
    PWMI_MINIPORT_REQUEST_ITEM   nextRequest = NULL;

    PWNODE_HEADER                wnodeEventItemHeader;

    //
    // Process the requests in the same order they were posted.  All
    // requests are stamped with the same time.
    //

    KeQuerySystemTime(&currentTime);

    wmiMiniPortRequestCurrent =
        savedInterruptData->WmiMiniPortRequests;


    while (wmiMiniPortRequestCurrent) {

        // Initialize the next request
        nextRequest = wmiMiniPortRequestCurrent->NextRequest;

       //
       // Determine if the WMI data provider is the
       // adapter (FDO; PathId=0xFF) or one of the SCSI
       // targets (PDO; identified by
       // PathId,TargedId,Lun).
       //

       if (wmiMiniPortRequestCurrent->PathId == 0xFF) {                    // [FDO]
          providerDeviceObject = DeviceObject;
       } else {                                                     // [PDO]
          logicalUnit = GetLogicalUnitExtension(
              deviceExtension,
              wmiMiniPortRequestCurrent->PathId,
              wmiMiniPortRequestCurrent->TargetId,
              wmiMiniPortRequestCurrent->Lun,
              FALSE,
              TRUE);

          if (logicalUnit) {
             providerDeviceObject =
                 logicalUnit->CommonExtension.DeviceObject;
          } else {

              // [SCSI target does not exist]
              providerDeviceObject = NULL;

             // The deviceObject is NULL, then we should
             // delete the entry.  Because the deviceObject
             // becomes NULL when the adapter or LUN has
             // been removed.  That means that there is no
             // free list for this cell to go back to,
             // if we dont delete the cell it will be leaked
             ExFreePool(wmiMiniPortRequestCurrent);

          }
       }

       //
       // Ignore this WMI request if we cannot locate
       // the WMI ProviderId (device object pointer) or
       // WMI is not initialized for some reason,
       // therwise process the request.
       //

       if (providerDeviceObject && ((PCOMMON_EXTENSION)
           providerDeviceObject->DeviceExtension)->WmiInitialized) {

           // Do we place the cell back onto the free list
           BOOLEAN      freeCell;

           freeCell = TRUE;

          if (wmiMiniPortRequestCurrent->TypeOfRequest == WMIReregister) {

              //
              // Re-register this device object with WMI, instructing WMI to
              // requery for the GUIDs we support.
              //

              // The Call to IoWMIRegistrationControl is not supported at
              // DPC level (must be made at PASSIVE level, so we will
              // queue a work item.
              PIO_WORKITEM   pIOWorkItem;

              // The remove lock will be release by the IOWorkItem
              // callback
              pIOWorkItem = IoAllocateWorkItem(providerDeviceObject);
              if (pIOWorkItem) {

                  // Acquire the RemoveLock on this deviceObject
                  SpAcquireRemoveLock(providerDeviceObject, pIOWorkItem);

                  // We succesfully allocated the work item
                  IoQueueWorkItem(pIOWorkItem,
                                 SpDelayedWmiRegistrationControl,
                                 DelayedWorkQueue,
                                 pIOWorkItem);

              } else {
                  DebugPrint((1, "ScsiPortCompletionDPC: IoAllocateWorkItem failed for WmiRegistrationControl event\n"));
              }

              //
              // Falling through we'll place the cell into the free list later
              //

          } else if (wmiMiniPortRequestCurrent->TypeOfRequest == WMIEvent) {
              //
              // The miniport posted a WMI event.
              //
              // Make sure we have an event item, then stamp it with
              NTSTATUS                      status;

              wnodeEventItemHeader =
                  (PWNODE_HEADER) wmiMiniPortRequestCurrent->WnodeEventItem;

              ASSERT(wnodeEventItemHeader->Flags & WNODE_FLAG_EVENT_ITEM);

              wnodeEventItemHeader->ProviderId = IoWMIDeviceObjectToProviderId(providerDeviceObject);
              wnodeEventItemHeader->TimeStamp  = currentTime;

              //
              // We will be passing this WMI_MINIPORT_REQUEST_ITEM directly
              // to WMI and allocating a new request item to take its place.
              //
              // Note that WMI is expecting a WNODE_EVENT_ITEM to be passed
              // in, however we are passing it a WMI_MINIPORT_REQUEST_ITEM.
              // This is alright,  since the WNODE_EVENT_ITEM buffer is the
              // very first field in WMI_MINIPORT_REQUEST_ITEM.  This is an
              // optimization to save one copy operation.   The alternative
              // was to allocate a WNODE_EVENT_ITEM and copy in the data.
              //
              status = IoWMIWriteEvent(
                  (PWNODE_EVENT_ITEM)wmiMiniPortRequestCurrent);

              if (NT_SUCCESS(status)) {

                  // Dont put this cell back onto the free list
                  freeCell = FALSE;

                  #if DBG
                  // This is a global counter, it wont
                  // make sense if you have more than
                  // one scsiport adapter
                  ScsiPortWmiWriteCalls++;
                  #endif

              } else {
                  // WMI Wont release the memory that we're
                  // currently pointing to

                  #if DBG
                  // This is a global counter, it wont
                  // make sense if you have more than
                  // one scsiport adapter
                  ScsiPortWmiWriteCallsFailed++;
                  #endif

                  DebugPrint((1, "ScsiPortCompletionDPC: IoWMIWriteEvent failed\n"));
              }

          } else { // unknown TypeOfRequest, ignore the request
                ASSERT(FALSE);
          }

          if (freeCell) {

              //
              // Free the cell back onto the free list.
              //

              SpWmiPushExistingFreeRequestItem(
                  deviceExtension,
                  wmiMiniPortRequestCurrent);
          }
       } // good providerId / WMI initialized

       // Advance the Current request pointer
       wmiMiniPortRequestCurrent = nextRequest;

    } // while more requests exist

    // Clear the Request List
    savedInterruptData->WmiMiniPortRequests = NULL;

    // See if we need to repopulate the free
    // REQUEST_ITEM list
    while (deviceExtension->WmiFreeMiniPortRequestCount <
        deviceExtension->WmiFreeMiniPortRequestWatermark) {

        // Add one to the free list
        if (!NT_SUCCESS(
            SpWmiPushFreeRequestItem(
                deviceExtension))) {

            // We failed to add, most likely a memory
            // problem, so just stop trying for now
            break;
        }
    } // re-populate the free list (REQUEST_ITEMS)

    return;
}

NTSTATUS
SpFireSenseDataEvent(
    PSCSI_REQUEST_BLOCK Srb, 
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine fires a WMI event which contains the SenseData
    returned by a REQUEST SENSE command.
    
    WMI frees the buffer we alloc and pass to it.
    
    This routine must be called at IRQL <= DISPATCH_LEVEL, as
    required by WmiFireEvent.

Arguments:

    Srb - Points to the failed SRB for which a REQUEST SENSE
          was performed.
    
    DeviceObject - Points to the driver's device object.

Return Value:

    STATUS_SUCCESS if successful

Notes:

--*/

{
    typedef struct _SCSIPORTSENSEDATA{
        ULONG Port;
        UCHAR Cdb[16];
        UCHAR SenseData[255];
    } SCSIPORTSENSEDATA, *PSCSIPORTSENSEDATA;

    NTSTATUS status;
    PSCSIPORTSENSEDATA SenseData;
    ULONG SenseDataLength = 255;
    PADAPTER_EXTENSION AdapterExtension;

    //
    // Allocate a buffer into which the event data will be copied.  This
    // buffer gets freed by WMI.
    //

    SenseData = SpAllocatePool(NonPagedPoolCacheAligned,
                               sizeof(SCSIPORTSENSEDATA),
                               SCSIPORT_TAG_SENSE_BUFFER,
                               DeviceObject->DriverObject);

    if (NULL == SenseData) {
        DebugPrint((1, "Unable to alloc buffer for SenseData WMI event\n"));
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Initialize a pointer to the adapter extension.  We use it below to
    // get information for firing the event and filling out the event
    // data.
    //

    AdapterExtension = DeviceObject->DeviceExtension;

    //
    // Zero the buffer, then copy the event information into it.
    //

    RtlZeroMemory(SenseData, sizeof(SCSIPORTSENSEDATA));

    SenseData->Port = AdapterExtension->PortNumber;
    RtlCopyMemory(&SenseData->Cdb,
                  Srb->Cdb,
                  Srb->CdbLength);
    RtlCopyMemory(&SenseData->SenseData,
                  Srb->SenseInfoBuffer,
                  Srb->SenseInfoBufferLength);

    //
    // Fire the event.
    //

    DebugPrint((3, "SpFireSenseDataEvent: DeviceObject %p\n", DeviceObject));

    status = WmiFireEvent(DeviceObject,
                          (LPGUID)&AdapterExtension->SenseDataEventClass,
                          0,
                          sizeof(SCSIPORTSENSEDATA),
                          SenseData);

    return status;
}

#if defined(FORWARD_PROGRESS)
PMDL
SpPrepareReservedMdlForUse(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN ULONG ScatterListLength
    )

/*++

Routine Description:

    This routine attempts to prepare the reserved MDL on the supplied adapter
    for use.

Arguments:

    Adapter           - Points to an adapter extension object.

    SrbData           - Points to the SRB_DATA structure for this request.

    Srb               - Points to the SRB that describes the request for which 
                        we are enabling forward progress.

    ScatterListLength - The size of the SG list.

Return Value:

    Pointer to the reserved MDL if successful.

    NULL if the reserved MDL is too small.

    -1 if the reserved MDL are already in use.

Notes:

    This routine is called with the adapter spinlock held.

--*/

{
    PMDL Mdl;

    //
    // Check if the reserved MDL is already in use by another request.
    //

    if (TEST_FLAG(Adapter->Flags, PD_RESERVED_MDL_IN_USE)) {

        //
        // The spare is already in use.
        //
    
        Mdl = (PMDL)-1;

    } else {
        
        //
        // The spare is available.  Check if it's big enough enough to 
        // accommodate this request.
        //

        ULONG PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                              Srb->DataBuffer, 
                              Srb->DataTransferLength);

        if (PageCount > SP_RESERVED_PAGES) {

            //
            // The spare MDL is not big enough to accommodate the request.
            // return NULL.
            //

            Mdl = NULL;

        } else {
            
            DebugPrint((1, "SpPrepareReservedMdlForUse: using reserved MDL DevExt:%p srb:%p\n",
                        Adapter, Srb));

            //
            // The spare is adequate.  Claim it and prepare it
            // for use with this request.
            //

            SET_FLAG(Adapter->Flags, PD_RESERVED_MDL_IN_USE);
            SET_FLAG(SrbData->Flags, SRB_DATA_RESERVED_MDL);
            Mdl = Adapter->ReservedMdl;

            MmInitializeMdl(Mdl,Srb->DataBuffer,Srb->DataTransferLength);

            SpPrepareMdlForMappedTransfer(
                Mdl,
                Adapter->DeviceObject,
                Adapter->DmaAdapterObject,
                SrbData->CurrentIrp->MdlAddress,
                Srb->DataBuffer,
                Srb->DataTransferLength,
                SrbData->ScatterGatherList,
                ScatterListLength);

        }

    }

    return Mdl;
}

PVOID
SpMapLockedPagesWithReservedMapping(
    IN PADAPTER_EXTENSION Adapter,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PSRB_DATA SrbData,
    IN PMDL Mdl
    )

/*++

Routine Description:

    This routine attempts to map the physical pages represented by the supplied
    MDL using the adapter's reserved page range.

Arguments:

    Adapter - Points to an adapter extension object.

    Srb     - Points to the SRB that describes the request for which we
              are enabling forward progress.

    SrbData - Points to the SRB_DATA structure for this request.

    Mdl     - Points to an MDL that describes the physical range we
              are tring to map.

Return Value:

    Kernel VA of the mapped pages if mapped successfully.

    NULL if the reserved page range is too small or if the pages are 
    not successfully mapped.

    -1 if the reserved pages are already in use.

Notes:

    This routine is called with the adapter spinlock held.

--*/

{
    ULONG_PTR NumberOfPages;
    PVOID StartingVa;
    PVOID SystemAddress;

    //
    // Determine if the reserved range is already in use by another
    // request.
    //

    if (TEST_FLAG(Adapter->Flags, PD_RESERVED_PAGES_IN_USE)) {

        //
        // The reserved range is already in use, return -1.
        //

        SystemAddress = (PVOID)-1;

    } else {

        //
        // The reserved range is available.  Calculate the number of pages
        // spanned by the MDL and determine if the reserved range is large
        // enough to map the pages.
        //

        StartingVa = (PVOID)((PCHAR)Mdl->StartVa + Mdl->ByteOffset);
        NumberOfPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(StartingVa, Mdl->ByteCount);
        
        if (NumberOfPages > SP_RESERVED_PAGES) {

            //
            // Not enough reserved pages to map the required physical memory.
            // Return NULL.
            //

            SystemAddress = NULL;
            
        } else {
                
            DebugPrint((1, "SpMapLockedPagesWithReservedMapping: using reserved range DevExt:%p srb:%p\n",
                        Adapter, Srb));

            //
            // The reserved range is large enough to map all the pages.  Go ahead
            // and try to map them.  Since we are specifying MmCached as cache 
            // type and we've ensured that we have enough reserved pages to
            // cover the request, this should never fail.
            //
            
            SystemAddress = MmMapLockedPagesWithReservedMapping(
                                Adapter->ReservedPages,
                                SCSIPORT_TAG_MAPPING_LIST,
                                Mdl,
                                MmCached);

            if (SystemAddress == NULL) {
                
                ASSERT(FALSE);

            } else {

                //
                // The mapping succeeded.  Claim the reserved range and mark the
                // request so we'll know at completion that it's using the
                // reserved range.
                //
                
                SET_FLAG(Adapter->Flags, PD_RESERVED_PAGES_IN_USE);
                SET_FLAG(SrbData->Flags, SRB_DATA_RESERVED_PAGES);
                
            }       

        } 

    }

    return SystemAddress;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\pnpstop.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    stop.c

Abstract:

    This is the NT SCSI port driver.  This file contains the initialization
    code.

Authors:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include "port.h"

typedef struct _SP_STOP_DEVICE_CONTEXT {
    OUT NTSTATUS Status;
    IN  KEVENT Event;
} SP_STOP_DEVICE_CONTEXT, *PSP_STOP_DEVICE_CONTEXT;

VOID
SpCallHwStopAdapter(
    IN PDEVICE_OBJECT Adapter
    );

BOOLEAN
SpCallHwStopAdapterSynchronized(
    IN PADAPTER_EXTENSION AdapterExtension
    );

VOID
SpDeviceStoppedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PSP_STOP_DEVICE_CONTEXT Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ScsiPortStopLogicalUnit)
#pragma alloc_text(PAGE, ScsiPortStopAdapter)
#endif


NTSTATUS
ScsiPortStopLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )

/*++

Routine Description:

    This routine will lock the queue for the given logical unit to make sure
    that all request processing for this device is stopped.  It will clear
    the IsStarted flag once the queue has been locked successfully.  This will
    keep any other requests from being processed until a start has been
    received.

Arguments:

    LogicalUnit - the logical unit to be started.

    Irp - the stop request

Return Value:

    status

--*/

{
    SP_STOP_DEVICE_CONTEXT context;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    if(LogicalUnit->CommonExtension.CurrentPnpState == IRP_MN_STOP_DEVICE) {
        return STATUS_SUCCESS;
    }

    KeInitializeEvent(&(context.Event), SynchronizationEvent, FALSE);

    status = SpEnableDisableLogicalUnit(LogicalUnit,
                                        FALSE,
                                        SpDeviceStoppedCompletion,
                                        &context);

    KeWaitForSingleObject(&(context.Event),
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    return context.Status;
}


VOID
SpDeviceStoppedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PSP_STOP_DEVICE_CONTEXT Context
    )
{

    Context->Status = Status;
    KeSetEvent(&(Context->Event), IO_NO_INCREMENT, FALSE);
    return;
}


NTSTATUS
ScsiPortStopAdapter(
    IN PDEVICE_OBJECT Adapter,
    IN PIRP StopRequest
    )

/*++

Routine Description:

    This routine will stop an adapter and release it's io and interrupt
    resources.  Pool allocations will not be freed, nor will the various
    miniport extensions.

Arguments:

    Adapter - the device object for the adapter.

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION adapterExtension = Adapter->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = Adapter->DeviceExtension;

    KEVENT event;

    ULONG bin;

    PAGED_CODE();

    ASSERT(adapterExtension->IsPnp);

    //
    // If we're not started and we weren't started then there's no reason
    // to do any work when stopping.
    //

    if((commonExtension->CurrentPnpState != IRP_MN_START_DEVICE) &&
       (commonExtension->PreviousPnpState != IRP_MN_START_DEVICE)) {

        return STATUS_SUCCESS;
    }

    //
    // Since all the children are stopped no requests can get through to the
    // adapter.
    //

    //
    // Send a request through the start-io routine to shut it down so that we
    // can start it back up later.
    //

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    StopRequest->IoStatus.Information = (ULONG_PTR) &event;

    IoStartPacket(Adapter, StopRequest, 0, NULL);

    KeWaitForSingleObject(&event,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    //
    // Call the miniport and get it to shut the adapter down.
    //

    SpEnableDisableAdapter(adapterExtension, FALSE);

    SpReleaseAdapterResources(adapterExtension, TRUE);

    //
    // Zero out all the logical unit extensions.
    //

    for(bin = 0; bin < NUMBER_LOGICAL_UNIT_BINS; bin++) {

        PLOGICAL_UNIT_EXTENSION lun;

        for(lun = adapterExtension->LogicalUnitList[bin].List;
            lun != NULL;
            lun = lun->NextLogicalUnit) {

            RtlZeroMemory(lun->HwLogicalUnitExtension,
                          adapterExtension->HwLogicalUnitExtensionSize);
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\pdo.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    pdo.c

Abstract:

    This module contains the dispatch routines for scsiport's physical device
    objects

Authors:

    Peter Wieland

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#define KEEP_COMPLETE_REQUEST

#include "port.h"

#define __FILE_ID__ 'pdo '

#if DBG
static const char *__file__ = __FILE__;
#endif

LONG SpPowerIdleTimeout = -1;      // use system default

NTSTATUS
SpPagingPathNotificationCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP LowerIrp,
    IN PDEVICE_OBJECT Fdo
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ScsiPortPdoPnp)
#pragma alloc_text(PAGE, ScsiPortPdoCreateClose)
#pragma alloc_text(PAGE, ScsiPortStartLogicalUnit)
#endif

NTSTATUS
ScsiPortPdoDeviceControl(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles device control requests for scsi target devices

Arguments:

    Pdo - a pointer to the physical device object

    Irp - a pointer to the io request packet

Return Value:

    status

--*/

{
    PLOGICAL_UNIT_EXTENSION physicalExtension = Pdo->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = Pdo->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

    NTSTATUS status;
    BOOLEAN completeRequest = TRUE;

    ULONG isRemoved;

    isRemoved = SpAcquireRemoveLock(Pdo, Irp);
    if(isRemoved) {

        SpReleaseRemoveLock(Pdo, Irp);
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        SpCompleteRequest(Pdo, Irp, NULL, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    ASSERT(commonExtension->IsPdo);

    Irp->IoStatus.Status = 0;

    switch(ioControlCode) {

        case IOCTL_STORAGE_QUERY_PROPERTY: {

            //
            // Validate the query
            //

            PSTORAGE_PROPERTY_QUERY query = Irp->AssociatedIrp.SystemBuffer;

            if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
               sizeof(STORAGE_PROPERTY_QUERY)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            status = ScsiPortQueryProperty(Pdo, Irp);

            return status;

            break;
        }

        case IOCTL_SCSI_GET_ADDRESS: {

            PSCSI_ADDRESS scsiAddress = Irp->AssociatedIrp.SystemBuffer;

            if(irpStack->Parameters.DeviceIoControl.OutputBufferLength <
               sizeof(SCSI_ADDRESS)) {

                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            scsiAddress->Length = sizeof(PSCSI_ADDRESS);
            scsiAddress->PortNumber = (UCHAR) physicalExtension->PortNumber;
            scsiAddress->PathId = physicalExtension->PathId;
            scsiAddress->TargetId = physicalExtension->TargetId;
            scsiAddress->Lun = physicalExtension->Lun;

            Irp->IoStatus.Information = sizeof(SCSI_ADDRESS);
            status = STATUS_SUCCESS;
            break;
        }

        //
        // XXX - need to handle
        //
        // IOCTL_STORAGE_PASS_THROUGH
        // IOCTL_STORAGE_PASS_THROUGH_DIRECT
        //

        case IOCTL_SCSI_PASS_THROUGH:
        case IOCTL_SCSI_PASS_THROUGH_DIRECT: {

            PSCSI_PASS_THROUGH srbControl = Irp->AssociatedIrp.SystemBuffer;

            if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
               sizeof(SCSI_PASS_THROUGH)) {

                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            srbControl->PathId = physicalExtension->PathId;
            srbControl->TargetId = physicalExtension->TargetId;
            srbControl->Lun = physicalExtension->Lun;

            //
            // Fall through to the default handler
            //

        }

        default: {

            IoSkipCurrentIrpStackLocation(Irp);
            SpReleaseRemoveLock(Pdo, Irp);
            status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
            completeRequest = FALSE;
        }

    }

    if(completeRequest) {

        Irp->IoStatus.Status = status;
        SpReleaseRemoveLock(Pdo, Irp);
        SpCompleteRequest(Pdo, Irp, NULL, IO_NO_INCREMENT);
    }
    return status;
}

NTSTATUS
ScsiPortPdoPnp(
    IN PDEVICE_OBJECT LogicalUnit,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles pnp-power requests.  Currently it will just be
    successful

Arguments:

    LogicalUnit - pointer to the physical device object
    Irp - pointer to the io request packet

Return Value:

    status

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnitExtension = LogicalUnit->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = LogicalUnit->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    static ULONG i = 0;

    NTSTATUS status = STATUS_SUCCESS;

    ULONG isRemoved;

    PAGED_CODE();

    isRemoved = SpAcquireRemoveLock(LogicalUnit, Irp);

#if 0
    if(isRemoved != ) {

        ASSERT(isRemoved != REMOVE_PENDING);

        status = STATUS_DEVICE_DOES_NOT_EXIST;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
#else
    ASSERT(isRemoved != REMOVE_COMPLETE);
#endif

    switch(irpStack->MinorFunction) {

        case IRP_MN_QUERY_PNP_DEVICE_STATE: {

            //
            // If the device is in the paging path then mark it as
            // not-disableable.
            //

            PPNP_DEVICE_STATE deviceState =
                (PPNP_DEVICE_STATE) &(Irp->IoStatus.Information);

            DebugPrint((1, "ScsiPortPdoPnp: QUERY_DEVICE_STATE for PDO %#x\n", LogicalUnit));

            if(commonExtension->PagingPathCount != 0) {
                SET_FLAG((*deviceState), PNP_DEVICE_NOT_DISABLEABLE);
                DebugPrint((1, "ScsiPortPdoPnp: QUERY_DEVICE_STATE: %#x - not disableable\n",
                            LogicalUnit));
            }

            Irp->IoStatus.Status = STATUS_SUCCESS;
            SpReleaseRemoveLock(LogicalUnit, Irp);
            SpCompleteRequest(LogicalUnit, Irp, NULL, IO_NO_INCREMENT);
            return STATUS_SUCCESS;
        }

        case IRP_MN_START_DEVICE: {

            if(commonExtension->CurrentPnpState == IRP_MN_START_DEVICE) {
                Irp->IoStatus.Status = STATUS_SUCCESS;
                break;
            }

            if(commonExtension->IsInitialized == FALSE) {
                status = ScsiPortInitLogicalUnit(logicalUnitExtension);
            }

            if(NT_SUCCESS(status)) {
                commonExtension->IsInitialized = TRUE;
                status = ScsiPortStartLogicalUnit(logicalUnitExtension);
            }

            if(NT_SUCCESS(status)) {
                commonExtension->CurrentPnpState = IRP_MN_START_DEVICE;
                commonExtension->PreviousPnpState = 0xff;
            }

            Irp->IoStatus.Status = status;

            break;
        }

        case IRP_MN_QUERY_ID: {

            UCHAR rawIdString[64] = "UNKNOWN ID TYPE";
            ANSI_STRING ansiIdString;
            UNICODE_STRING unicodeIdString;
            BOOLEAN multiStrings;

            PINQUIRYDATA inquiryData = &(logicalUnitExtension->InquiryData);

            //
            // We've been asked for the id of one of the physical device objects
            //

            DebugPrint((2, "ScsiPortPnp: got IRP_MN_QUERY_ID\n"));

            RtlInitUnicodeString(&unicodeIdString, NULL);
            RtlInitAnsiString(&ansiIdString, NULL);

            switch(irpStack->Parameters.QueryId.IdType) {

                case BusQueryDeviceID: {

                    status = ScsiPortGetDeviceId(LogicalUnit, &unicodeIdString);
                    multiStrings = FALSE;

                    break;
                }

                case BusQueryInstanceID: {

                    status = ScsiPortGetInstanceId(LogicalUnit, &unicodeIdString);
                    multiStrings = FALSE;

                    break;
                }

                case BusQueryHardwareIDs: {

                    status = ScsiPortGetHardwareIds(
                                LogicalUnit->DriverObject,
                                &(logicalUnitExtension->InquiryData),
                                &unicodeIdString);
                    multiStrings = TRUE;
                    break;
                }

                case BusQueryCompatibleIDs: {

                    status = ScsiPortGetCompatibleIds(
                                LogicalUnit->DriverObject,
                                &(logicalUnitExtension->InquiryData),
                                &unicodeIdString);
                    multiStrings = TRUE;

                    break;
                }

                default: {

                    status = Irp->IoStatus.Status;
                    Irp->IoStatus.Information = 0;
                    multiStrings = FALSE;

                    break;

                }
            }

            Irp->IoStatus.Status = status;

            if(NT_SUCCESS(status)) {

                PWCHAR idString;

                //
                // fix up all invalid characters
                //
                idString = unicodeIdString.Buffer;
                while (*idString) {

                    if ((*idString <= L' ')  ||
                        (*idString > (WCHAR)0x7F) ||
                        (*idString == L',')) {
                        *idString = L'_';
                    }
                    idString++;

                    if ((*idString == L'\0') && multiStrings) {
                        idString++;
                    }
                }

                Irp->IoStatus.Information = (ULONG_PTR) unicodeIdString.Buffer;
            } else {
                Irp->IoStatus.Information = (ULONG_PTR) NULL;
            }

            SpReleaseRemoveLock(LogicalUnit, Irp);
            SpCompleteRequest(LogicalUnit, Irp, NULL, IO_NO_INCREMENT);

            return status;
            break;
        }

        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS: {

            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = (ULONG_PTR) NULL;
            SpReleaseRemoveLock(LogicalUnit, Irp);
            SpCompleteRequest(LogicalUnit, Irp, NULL, IO_NO_INCREMENT);
            return STATUS_SUCCESS;
        }

        case IRP_MN_SURPRISE_REMOVAL:
        case IRP_MN_REMOVE_DEVICE: {

            BOOLEAN destroyed;

            //
            // Release the lock for this IRP before going in.
            //

            if(commonExtension->IsRemoved == NO_REMOVE) {
                commonExtension->IsRemoved = REMOVE_PENDING;
            }

            SpReleaseRemoveLock(LogicalUnit, Irp);

            destroyed = SpRemoveLogicalUnit(logicalUnitExtension,
                                            irpStack->MinorFunction);

            if(destroyed) {
                commonExtension->PreviousPnpState =
                    commonExtension->CurrentPnpState;
                commonExtension->CurrentPnpState = irpStack->MinorFunction;
            } else {
                commonExtension->CurrentPnpState = 0xff;
                commonExtension->PreviousPnpState = irpStack->MinorFunction;
            }

            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;
        }

        case IRP_MN_QUERY_DEVICE_TEXT: {

            Irp->IoStatus.Status =
                SpQueryDeviceText(
                    LogicalUnit,
                    irpStack->Parameters.QueryDeviceText.DeviceTextType,
                    irpStack->Parameters.QueryDeviceText.LocaleId,
                    (PWSTR *) &Irp->IoStatus.Information
                    );

            break;
        }

        case IRP_MN_QUERY_CAPABILITIES: {

            PDEVICE_CAPABILITIES capabilities =
                irpStack->Parameters.DeviceCapabilities.Capabilities;

            PSCSIPORT_DEVICE_TYPE deviceType = NULL;

            capabilities->RawDeviceOK = 1;

            deviceType = SpGetDeviceTypeInfo(
                            logicalUnitExtension->InquiryData.DeviceType
                            );

            if((deviceType != NULL) && (deviceType->IsStorage)) {
                capabilities->SilentInstall = 1;
            }

            capabilities->Address = logicalUnitExtension->TargetId;

            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE: {

            if ((commonExtension->PagingPathCount != 0) ||
                (logicalUnitExtension->IsLegacyClaim == TRUE)) {
                Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
            } else {
                Irp->IoStatus.Status = STATUS_SUCCESS;

                commonExtension->PreviousPnpState =
                    commonExtension->CurrentPnpState;
                commonExtension->CurrentPnpState = irpStack->MinorFunction;
            }
            break;
        }

        case IRP_MN_CANCEL_STOP_DEVICE: {

            if(commonExtension->CurrentPnpState == IRP_MN_QUERY_STOP_DEVICE) {
                commonExtension->CurrentPnpState =
                    commonExtension->PreviousPnpState;
                commonExtension->PreviousPnpState = 0xff;
            }

            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_CANCEL_REMOVE_DEVICE: {

            if(commonExtension->CurrentPnpState == IRP_MN_QUERY_REMOVE_DEVICE) {
                commonExtension->CurrentPnpState =
                    commonExtension->PreviousPnpState;
                commonExtension->PreviousPnpState = 0xff;
            }

            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_STOP_DEVICE: {

            ASSERT(commonExtension->CurrentPnpState == IRP_MN_QUERY_STOP_DEVICE);

            status = ScsiPortStopLogicalUnit(logicalUnitExtension);

            ASSERT(NT_SUCCESS(status));

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = (ULONG_PTR) NULL;

            if(NT_SUCCESS(status)) {
                commonExtension->CurrentPnpState = IRP_MN_STOP_DEVICE;
                commonExtension->PreviousPnpState = 0xff;
            }

            SpReleaseRemoveLock(LogicalUnit, Irp);
            SpCompleteRequest(LogicalUnit, Irp, NULL, IO_NO_INCREMENT);

            return status;
        }

        case IRP_MN_QUERY_DEVICE_RELATIONS: {

            PDEVICE_RELATIONS deviceRelations;

            if(irpStack->Parameters.QueryDeviceRelations.Type !=
               TargetDeviceRelation) {

                break;
            }

            //
            // DEVICE_RELATIONS definition contains one object pointer.
            //

            deviceRelations = SpAllocatePool(PagedPool,
                                             sizeof(DEVICE_RELATIONS),
                                             SCSIPORT_TAG_DEVICE_RELATIONS,
                                             LogicalUnit->DriverObject);

            if(deviceRelations == NULL) {

                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            RtlZeroMemory(deviceRelations, sizeof(DEVICE_RELATIONS));

            deviceRelations->Count = 1;
            deviceRelations->Objects[0] = LogicalUnit;

            ObReferenceObject(deviceRelations->Objects[0]);

            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

            break;
        }

        case IRP_MN_DEVICE_USAGE_NOTIFICATION: {

            PIRP newIrp;
            PIO_STACK_LOCATION nextStack;

            DebugPrint((1, "Pdo - IRP_MN_DEVICE_USAGE_NOTIFICATION %#p received for "
                           "logical unit %#p\n",
                        Irp,
                        LogicalUnit));

            newIrp = SpAllocateIrp(
                        commonExtension->LowerDeviceObject->StackSize,
                        FALSE,
                        LogicalUnit->DriverObject);

            if(newIrp == NULL) {

                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            newIrp->AssociatedIrp.MasterIrp = Irp;

            newIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

            nextStack = IoGetNextIrpStackLocation(newIrp);
            *nextStack = *IoGetCurrentIrpStackLocation(Irp);

            IoSetCompletionRoutine(newIrp,
                                   SpPagingPathNotificationCompletion,
                                   commonExtension->LowerDeviceObject,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            status = IoCallDriver(commonExtension->LowerDeviceObject,
                                  newIrp);
            return status;
            break;
        }
    }

    SpReleaseRemoveLock(LogicalUnit, Irp);

    status = Irp->IoStatus.Status;
    SpCompleteRequest(LogicalUnit, Irp, NULL, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
SpPagingPathNotificationCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP LowerIrp,
    IN PDEVICE_OBJECT Fdo
    )
{
    PIRP upperIrp = LowerIrp->AssociatedIrp.MasterIrp;

    PIO_STACK_LOCATION lowerStack = IoGetCurrentIrpStackLocation(LowerIrp);
    PIO_STACK_LOCATION upperStack = IoGetCurrentIrpStackLocation(upperIrp);

    PDEVICE_OBJECT pdo = upperStack->DeviceObject;

    PADAPTER_EXTENSION lowerExtension;
    PLOGICAL_UNIT_EXTENSION upperExtension;

    ASSERT(Fdo != NULL);
    ASSERT(pdo != NULL);

    DebugPrint((1, "Completion - IRP_MN_DEVICE_USAGE_NOTIFICATION: Completion of "
                   "paging notification irp %#p sent due to irp %#p\n",
                LowerIrp, upperIrp));

    lowerExtension = (PADAPTER_EXTENSION) Fdo->DeviceExtension;
    upperExtension = (PLOGICAL_UNIT_EXTENSION) pdo->DeviceExtension;

    ASSERT_FDO(lowerExtension->DeviceObject);
    ASSERT_PDO(upperExtension->DeviceObject);

    DebugPrint((1, "Completion - IRP_MN_DEVICE_USAGE_NOTIFICATION: irp status %#08lx\n",
                LowerIrp->IoStatus.Status));

    if(NT_SUCCESS(LowerIrp->IoStatus.Status)) {

        PUCHAR typeName = "INSERT TYPE HERE";
        PULONG lowerCount;
        PULONG upperCount;

        //
        // The parameters have already been erased from the lower irp stack
        // location - use the parameters from the upper once since they're
        // just a copy.
        //

        switch(upperStack->Parameters.UsageNotification.Type) {

            case DeviceUsageTypePaging: {

                lowerCount = &(lowerExtension->CommonExtension.PagingPathCount);
                upperCount = &(upperExtension->CommonExtension.PagingPathCount);
                typeName = "PagingPathCount";
                break;
            }

            case DeviceUsageTypeHibernation: {

                lowerCount = &(lowerExtension->CommonExtension.HibernatePathCount);
                upperCount = &(upperExtension->CommonExtension.HibernatePathCount);
                typeName = "HibernatePathCount";
                break;
            }

            case DeviceUsageTypeDumpFile: {

                lowerCount = &(lowerExtension->CommonExtension.DumpPathCount);
                upperCount = &(upperExtension->CommonExtension.DumpPathCount);
                typeName = "DumpPathCount";
                break;
            }

            default: {

                typeName = "unknown type";
                lowerCount = upperCount = NULL;
                break;
            }
        }

        if(lowerCount != NULL) {
            IoAdjustPagingPathCount(
                lowerCount,
                upperStack->Parameters.UsageNotification.InPath
                );
            DebugPrint((1, "Completion - IRP_MN_DEVICE_USAGE_NOTIFICATION: "
                           "Fdo %s count - %d\n",
                        typeName, *lowerCount));
            IoInvalidateDeviceState(lowerExtension->LowerPdo);
        }

        if(upperCount != NULL) {
            IoAdjustPagingPathCount(
                upperCount,
                upperStack->Parameters.UsageNotification.InPath
                );
            DebugPrint((1, "Completion - IRP_MN_DEVICE_USAGE_NOTIFICATION: "
                           "Pdo %s count - %d\n",
                        typeName, *upperCount));
            IoInvalidateDeviceState(upperExtension->DeviceObject);
        }
    }

    upperIrp->IoStatus = LowerIrp->IoStatus;

    SpReleaseRemoveLock(upperExtension->CommonExtension.DeviceObject, upperIrp);

    SpCompleteRequest(upperExtension->CommonExtension.DeviceObject,
                      upperIrp,
                      NULL,
                      IO_NO_INCREMENT);

    IoFreeIrp(LowerIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
ScsiPortPdoCreateClose(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles creates and closes for bus device pdo's

Arguments:

    Pdo - a pointer to the physical device object
    Irp - a pointer to the io request packet

Return Value:

    status

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit = Pdo->DeviceExtension;

    ULONG isRemoved;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT_PDO(Pdo);

    isRemoved = SpAcquireRemoveLock(Pdo, Irp);

    if(IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_CREATE) {

        if(isRemoved) {
            status = STATUS_DEVICE_DOES_NOT_EXIST;
        } else if(logicalUnit->IsTemporary == TRUE) {
            status = STATUS_DEVICE_NOT_READY;
        }
    }

    Irp->IoStatus.Status = status;
    SpReleaseRemoveLock(Pdo, Irp);
    SpCompleteRequest(Pdo, Irp, NULL, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
ScsiPortScsi1PdoScsi(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is a wrapper around ScsiPortPdoScsi.  It inserts the LUN number
    into the CDB before calling the generic version.  this is for use with 
    older target controllers which don't pay attention to the identify message
    sent before the command phase.

Arguments:

    Pdo - a pointer to the physical device object
    Irp - a pointer to the io request packet

Return Value:

    status

--*/

{
    PLOGICAL_UNIT_EXTENSION lun = Pdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

    //
    // NOTICE:  The SCSI-II specification indicates that this field should be
    // zero; however, some target controllers ignore the logical unit number
    // in the INDENTIFY message and only look at the logical unit number field
    // in the CDB.
    //

    srb->Cdb[1] |= lun->Lun << 5;

    return ScsiPortPdoScsi(Pdo, Irp);
}

NTSTATUS
ScsiPortPdoScsi(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches SRB's for a particular target device.  It will fill
    in the Port, Path, Target and Lun values and then forward the request
    through to the FDO for the bus

Arguments:

    Pdo - a pointer to the physical device object
    Irp - a pointer to the io request packet

Return Value:

    status

--*/

{
    PLOGICAL_UNIT_EXTENSION lun = Pdo->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

#if DBG
    PDRIVER_OBJECT lowerDriverObject =
                        lun->CommonExtension.LowerDeviceObject->DriverObject;
#endif

    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

    ULONG isRemoved;

    PSRB_DATA srbData;
    BOOLEAN isLock = FALSE;

    NTSTATUS status;

    isRemoved = SpAcquireRemoveLock(Pdo, Irp);

    if(isRemoved &&
       !IS_CLEANUP_REQUEST(irpStack) &&
       (srb->Function != SRB_FUNCTION_CLAIM_DEVICE)) {

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;

        SpReleaseRemoveLock(Pdo, Irp);
        SpCompleteRequest(Pdo, Irp, NULL, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    srb->PathId = lun->PathId;
    srb->TargetId = lun->TargetId;
    srb->Lun = lun->Lun;

    //
    // Queue tags should be assigned only by the StartIo routine.  Set it to
    // a benign value here so we can tell later on that we don't have to
    // clear the tag value in the bitmap.
    //

    srb->QueueTag = SP_UNTAGGED;

#if DBG
    ASSERT(lowerDriverObject->MajorFunction[IRP_MJ_SCSI] != NULL);
    ASSERT(lowerDriverObject->MajorFunction[IRP_MJ_SCSI] == ScsiPortGlobalDispatch);
#endif

    switch(srb->Function) {


        case SRB_FUNCTION_ABORT_COMMAND: {

            status = STATUS_NOT_SUPPORTED;
            break;

        }

        case SRB_FUNCTION_CLAIM_DEVICE:
        case SRB_FUNCTION_REMOVE_DEVICE: {

            status = SpClaimLogicalUnit(
                        lun->CommonExtension.LowerDeviceObject->DeviceExtension,
                        lun,
                        Irp,
                        FALSE);
            break;
        }

        case SRB_FUNCTION_UNLOCK_QUEUE:
        case SRB_FUNCTION_LOCK_QUEUE: {

            SpStartLockRequest(lun, Irp);

            return STATUS_PENDING;
        }

        case SRB_FUNCTION_RELEASE_QUEUE:
        case SRB_FUNCTION_FLUSH_QUEUE: {

            srbData = SpAllocateBypassSrbData(lun);
            ASSERT(srbData != NULL);

            goto RunSrb;
        }

        default: {

            if(TEST_FLAG(srb->SrbFlags, (SRB_FLAGS_BYPASS_LOCKED_QUEUE |
                                         SRB_FLAGS_BYPASS_FROZEN_QUEUE))) {

                srbData = SpAllocateBypassSrbData(lun);
                ASSERT(srbData != NULL);
            } else {
                srbData = SpAllocateSrbData( lun->AdapterExtension, Irp);

                if(srbData == NULL) {

                    //
                    // There wasn't an SRB_DATA block available for this
                    // request so it's been queued waiting for resources -
                    // leave the logical unit remove-locked and return pending.
                    //

                    DebugPrint((1, "ScsiPortPdoScsi: Insufficient resources "
                                   "to allocate SRB_DATA structure\n"));
                    return STATUS_PENDING;
                }
            }
RunSrb:
            srbData->CurrentIrp = Irp;
            srbData->CurrentSrb = srb;
            srbData->LogicalUnit = lun;

            srb->OriginalRequest = srbData;
            return SpDispatchRequest(lun, Irp);
        }
    }

    Irp->IoStatus.Status = status;
    SpReleaseRemoveLock(Pdo, Irp);
    SpCompleteRequest(Pdo, Irp, NULL, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
ScsiPortStartLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )

/*++

Routine Description:

    This routine will attempt to start the specified device object.

    Currently this involves clearing the INITIALIZING flag if it was set,
    and running through to the device node and marking itself as started.  This
    last is a kludge

Arguments:

    LogicalUnit - a pointer to the PDO being started

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION adapterExtension = LogicalUnit->AdapterExtension;

    HANDLE instanceHandle;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Open the devnode for this PDO and see if anyone's given us some
    // default SRB flags.
    //

    status = IoOpenDeviceRegistryKey(LogicalUnit->DeviceObject,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ,
                                     &instanceHandle);

    if(NT_SUCCESS(status)) {

        RTL_QUERY_REGISTRY_TABLE queryTable[2];
        ULONG zero = 0;

        RtlZeroMemory(queryTable, sizeof(queryTable));

        queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[0].Name = L"DefaultRequestFlags";
        queryTable[0].EntryContext = &(LogicalUnit->CommonExtension.SrbFlags);
        queryTable[0].DefaultType = REG_DWORD;
        queryTable[0].DefaultData = &zero;
        queryTable[0].DefaultLength = sizeof(ULONG);

        status = RtlQueryRegistryValues(
                    RTL_REGISTRY_HANDLE | RTL_REGISTRY_OPTIONAL,
                    (PWSTR) instanceHandle,
                    queryTable,
                    NULL,
                    NULL);

        //
        // CODEWORK: need a way to turn off tagged queuing and caching.  Ie.
        // keep track of negative flags as well.
        //

        LogicalUnit->CommonExtension.SrbFlags &=
            ( SRB_FLAGS_DISABLE_DISCONNECT |
              SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
              SRB_FLAGS_DISABLE_SYNCH_TRANSFER);

        DebugPrint((1, "SpStartDevice: Default SRB flags for (%d,%d,%d) are "
                       "%#08lx\n",
                    LogicalUnit->PathId,
                    LogicalUnit->TargetId,
                    LogicalUnit->Lun,
                    LogicalUnit->CommonExtension.SrbFlags));

        ZwClose(instanceHandle);

    } else {

        DebugPrint((1, "SpStartDevice: Error opening instance key for pdo "
                       "[%#08lx]\n",
                    status));
    }

    //
    // If the queue is locked then unlock it to start i/o processing.
    //

    if(LogicalUnit->QueueLockCount > 0) {
        status = SpLockUnlockQueue(LogicalUnit->DeviceObject,
                                   FALSE,
                                   TRUE);
    }

    return status;
}


NTSTATUS
ScsiPortInitLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )

/*++

Routine Description:

    This routine will attempt to start the specified device object.

Arguments:

    DeviceObject - a pointer to the PDO being started

Return Value:

    status

--*/

{
    PCOMMON_EXTENSION commonExtension = &(LogicalUnit->CommonExtension);
    PADAPTER_EXTENSION adapterExtension = LogicalUnit->AdapterExtension;

    HANDLE instanceHandle;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Initialize the idle detection timer.  Tell the system to put us into a
    // D3 state when we're not being used.
    //

    LogicalUnit->CommonExtension.IdleTimer =
        PoRegisterDeviceForIdleDetection(LogicalUnit->DeviceObject,
                                         SpPowerIdleTimeout,
                                         SpPowerIdleTimeout,
                                         PowerDeviceD3);

    //
    // Now that we have a LUN, we can initialize WMI support for the adapter if
    // the miniport supports WMI.  This may be a re-register if we've already
    // registered on behalf of scsiport itself.  We have to wait until we have
    // a LUN when the miniport supports WMI because we send it an SRB to do
    // its own initialization. We can't send it an SRB until we have a logical
    // unit.
    //

    if (adapterExtension->CommonExtension.WmiMiniPortInitialized == FALSE &&
        adapterExtension->CommonExtension.WmiMiniPortSupport == TRUE) {

        ULONG action;

        //
        // Decide whether we are registering or reregistering WMI for the FDO.
        //

        action = (adapterExtension->CommonExtension.WmiInitialized == FALSE) ?
           WMIREG_ACTION_REGISTER : WMIREG_ACTION_REREGISTER;

        //
        // Register/reregister. We can get WMI irps as soon as we do this.
        //
        
        IoWMIRegistrationControl(adapterExtension->DeviceObject, action);
        adapterExtension->CommonExtension.WmiMiniPortInitialized = TRUE;
        adapterExtension->CommonExtension.WmiInitialized = TRUE;
    }
    
    //
    // Initialize WMI support.
    //

    if (commonExtension->WmiInitialized == FALSE) {

        //
        // Build the SCSIPORT WMI registration information buffer for this PDO.
        //

        SpWmiInitializeSpRegInfo(LogicalUnit->DeviceObject);

        //
        // Register this device object only if the miniport supports WMI and/or
        // SCSIPORT will support certain WMI GUIDs on behalf of the miniport.
        //

        if (commonExtension->WmiMiniPortSupport ||
            commonExtension->WmiScsiPortRegInfoBuf) {

            //
            // Register this physical device object as a WMI data provider,
            // instructing WMI that it is ready to receive WMI IRPs.
            //

            IoWMIRegistrationControl(LogicalUnit->DeviceObject, WMIREG_ACTION_REGISTER);
            commonExtension->WmiInitialized = TRUE;

        }

        //
        // Allocate several WMI_MINIPORT_REQUEST_ITEM blocks to satisfy a
        // potential onslaught of WMIEvent notifications by the miniport.
        //

        if (commonExtension->WmiMiniPortSupport) {

            //
            // Currently we only allocate two per new SCSI target (PDO).
            //
            SpWmiInitializeFreeRequestList(LogicalUnit->DeviceObject, 2);
        }
    }

    //
    // Build a device map entry for this logical unit.
    //

    SpBuildDeviceMapEntry(commonExtension);

    return status;
}

VOID
SpStartLockRequest(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PIRP Irp OPTIONAL
    )
/*++

Routine Description:

    This routine is responsible for queueing, starting or restarting a lock 
    request.  

    If Irp is provided then it will dispatched iff no existing lock or unlock
    request is already running.  If one is already running this request will 
    be queued.

    If Irp is not provided then the next request on the LockRequestQueue will 
    be removed and dispatched.
    
    This routine relies on the device queue to provide synchronization.  Since 
    we can only have one request get past the device queue at any given time we 
    should only have one call at any given time with Irp set to NULL.
    
Arguments:

    LogicalUnit - the logical unit to which this lock request was sent.
    
    Irp - the irp for the lock request.

Return Value:

    none    
--*/
    
{
    KIRQL oldIrql;

    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;

    PSRB_DATA srbData;

    BOOLEAN lock;

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    // If no IRP was provided then get one out of the device queue.
    // Otherwise make sure the device queue is not busy.
    //

    if(Irp == NULL) {
        PKDEVICE_QUEUE_ENTRY entry;

        ASSERT(LogicalUnit->CurrentLockRequest != NULL);
        LogicalUnit->CurrentLockRequest = NULL;

        entry = KeRemoveDeviceQueue(&(LogicalUnit->LockRequestQueue));

        if(entry == NULL) {

            //
            // No more requests have come in while processing this one - 
            // we can just return.
            //

            KeLowerIrql(oldIrql);
            return;

        } else {
            Irp = CONTAINING_RECORD(entry, 
                                    IRP,
                                    Tail.Overlay.DeviceQueueEntry);
            irpStack = IoGetCurrentIrpStackLocation(Irp);
            srb = irpStack->Parameters.Scsi.Srb;

            lock = (srb->Function == SRB_FUNCTION_LOCK_QUEUE);

        }

    } else {
        irpStack = IoGetCurrentIrpStackLocation(Irp);
        srb = irpStack->Parameters.Scsi.Srb;

        lock = (srb->Function == SRB_FUNCTION_LOCK_QUEUE);


        DebugPrint((2, "SpStartLockRequest: called to %s queue %#p\n",
                       lock ? "lock" : "unlock",
                       LogicalUnit));

        //
        // See if we can let this request keep processing or if we'll 
        // have to queue it.
        //

        IoMarkIrpPending(Irp);
        if(KeInsertDeviceQueue(&(LogicalUnit->LockRequestQueue),
                               &(Irp->Tail.Overlay.DeviceQueueEntry))) {
            KeLowerIrql(oldIrql);
            return;
        }
    }

    ASSERT(Irp != NULL);
    ASSERT(LogicalUnit->CurrentLockRequest == NULL);

    //
    // This srb function is only valid as part of a power up request
    // and will be ignored if the power state is D0.
    //

    CLEAR_FLAG(srb->SrbFlags, SRB_FLAGS_QUEUE_ACTION_ENABLE);
    SET_FLAG(srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE);

    //
    // Throw this request down so it gets processed as a real
    // request.  We need to get the completion dpc to start
    // things running again.  there are too many flags to set
    // to do it from here.
    //

    DebugPrint((2, "SpStartLockRequest: %s %#p into "
                   "queue %#p ... issuing request\n",
                lock ? "lock" : "unlock", srb, LogicalUnit));

    //
    // There are four bypass srb data blocks available - we should have at most
    // one lock request awaiting completion and the one we're about to start 
    // so this call should never, ever fail.
    //

    srbData = SpAllocateBypassSrbData(LogicalUnit);
    ASSERT(srbData != NULL);

    //
    // Set the current lock request.  As long as this is cleared
    // before the next item is removed from the queue everything
    // will be happy.
    //

    ASSERT(LogicalUnit->CurrentLockRequest == NULL);
    LogicalUnit->CurrentLockRequest = srbData;

    srbData->CurrentIrp = Irp;
    srbData->CurrentSrb = srb;
    srbData->LogicalUnit = LogicalUnit;
    srb->OriginalRequest = srbData;

    SpDispatchRequest(LogicalUnit, Irp);

    KeLowerIrql(oldIrql);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\prop.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1998

Module Name:

    prop.c

Abstract:

    This is the NT SCSI port driver.  This module contains code relating to
    property queries

Authors:

    Peter Wieland

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "port.h"

NTSTATUS
SpBuildDeviceDescriptor(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    );

NTSTATUS
SpBuildDeviceIdDescriptor(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSTORAGE_DEVICE_ID_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    );

NTSTATUS
SpBuildAdapterDescriptor(
    IN PADAPTER_EXTENSION Adapter,
    IN PSTORAGE_ADAPTER_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpBuildDeviceDescriptor)
#pragma alloc_text(PAGE, SpBuildDeviceIdDescriptor)
#pragma alloc_text(PAGE, SpBuildAdapterDescriptor)
#pragma alloc_text(PAGE, ScsiPortQueryProperty)
#pragma alloc_text(PAGE, SpQueryDeviceText)
#endif


NTSTATUS
ScsiPortQueryProperty(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP QueryIrp
    )

/*++

Routine Description:

    This routine will handle a property query request.  It will build the
    descriptor on it's own if possible, or it may forward the request down
    to lower level drivers.

    Since this routine may forward the request downwards the caller should
    not complete the irp

    This routine is asynchronous.
    This routine must be called at <= IRQL_DISPATCH
    This routine must be called with the remove lock held

Arguments:

    DeviceObject - a pointer to the device object being queried

    QueryIrp - a pointer to the irp for the query

Return Value:

    STATUS_PENDING if the request cannot be completed yet
    STATUS_SUCCESS if the query was successful

    STATUS_INVALID_PARAMETER_1 if the property id does not exist
    STATUS_INVALID_PARAMETER_2 if the query type is invalid
    STATUS_INVALID_PARAMETER_3 if an invalid optional parameter was passed

    STATUS_INVALID_DEVICE_REQUEST if this request cannot be handled by this
    device

    other error values as applicable

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(QueryIrp);

    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PSTORAGE_PROPERTY_QUERY query = QueryIrp->AssociatedIrp.SystemBuffer;
    ULONG queryLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    NTSTATUS status;

    PAGED_CODE();

    //
    // We don't actually support mask queries.
    //

    if(query->QueryType >= PropertyMaskQuery) {

        status = STATUS_INVALID_PARAMETER_1;
        QueryIrp->IoStatus.Status = status;
        QueryIrp->IoStatus.Information = 0;
        SpReleaseRemoveLock(DeviceObject, QueryIrp);
        SpCompleteRequest(DeviceObject, QueryIrp, NULL, IO_NO_INCREMENT);
        return status;
    }

    switch(query->PropertyId) {

        case StorageDeviceProperty: {

            //
            // Make sure this is a target device.
            //

            if(!commonExtension->IsPdo) {

                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            if(query->QueryType == PropertyExistsQuery) {

                status = STATUS_SUCCESS;

            } else {

                status = SpBuildDeviceDescriptor(
                            (PLOGICAL_UNIT_EXTENSION) commonExtension,
                            QueryIrp->AssociatedIrp.SystemBuffer,
                            &queryLength);

                QueryIrp->IoStatus.Information = queryLength;
            }
            break;
        }

        case StorageAdapterProperty: {

            PDEVICE_OBJECT adapterObject = DeviceObject;

            //
            // if this is a target device then forward it down to the
            // underlying device object.  This lets filters do their magic
            //

            if(commonExtension->IsPdo) {

                //
                // Call the lower device
                //

                IoSkipCurrentIrpStackLocation(QueryIrp);
                SpReleaseRemoveLock(DeviceObject, QueryIrp);
                status = IoCallDriver(commonExtension->LowerDeviceObject, QueryIrp);

                return status;
            }

            if(query->QueryType == PropertyExistsQuery) {

                status = STATUS_SUCCESS;

            } else {

                status = SpBuildAdapterDescriptor(
                            (PADAPTER_EXTENSION) commonExtension,
                            QueryIrp->AssociatedIrp.SystemBuffer,
                            &queryLength);

                QueryIrp->IoStatus.Information = queryLength;
            }
            break;
        }

        case StorageDeviceIdProperty: {

            PLOGICAL_UNIT_EXTENSION logicalUnit;

            //
            // Make sure this is a target device.
            //

            if(!commonExtension->IsPdo) {

                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            logicalUnit = DeviceObject->DeviceExtension;

            //
            // Check to see if we have a device identifier page.  If not then
            // fail any calls for this type of identifier.
            //

            if(logicalUnit->DeviceIdentifierPage != NULL) {

                if(query->QueryType == PropertyExistsQuery) {
                    status = STATUS_SUCCESS;
                } else {
                    status = SpBuildDeviceIdDescriptor(
                                logicalUnit,
                                QueryIrp->AssociatedIrp.SystemBuffer,
                                &queryLength);

                    QueryIrp->IoStatus.Information = queryLength;
                }
            } else {
                status = STATUS_NOT_SUPPORTED;
            }

            break;
        }

        default: {

            //
            // If this is a target device then some filter beneath us may
            // handle this property.
            //

            if(commonExtension->IsPdo) {

                //
                // Call the lower device.
                //

                IoSkipCurrentIrpStackLocation(QueryIrp);
                SpReleaseRemoveLock(DeviceObject, QueryIrp);
                status = IoCallDriver(commonExtension->LowerDeviceObject, QueryIrp);

                return status;
            }

            //
            // Nope, this property really doesn't exist
            //

            status = STATUS_INVALID_PARAMETER_1;
            QueryIrp->IoStatus.Information = 0;
            break;
        }
    }

    if(status != STATUS_PENDING) {
        QueryIrp->IoStatus.Status = status;
        SpReleaseRemoveLock(DeviceObject, QueryIrp);
        SpCompleteRequest(DeviceObject, QueryIrp, NULL, IO_DISK_INCREMENT);
    }

    return status;
}

NTSTATUS
SpBuildDeviceDescriptor(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    )

/*++

Routine Description:

    This routine will create a device descriptor based on the information in
    it's device extension.  It will copy as much data as possible into
    the Descriptor and will update the DescriptorLength to indicate the
    number of bytes copied

Arguments:

    DeviceObject - a pointer to the PDO we are building a descriptor for

    Descriptor - a buffer to store the descriptor in

    DescriptorLength - the length of the buffer and the number of bytes
                       returned

    QueryIrp - unused

Return Value:

    status

--*/

{
    PSCSIPORT_DRIVER_EXTENSION driverExtension =
        IoGetDriverObjectExtension(LogicalUnit->DeviceObject->DriverObject,
                                   ScsiPortInitialize);

    LONG maxLength = *DescriptorLength;
    LONG bytesRemaining = maxLength;
    LONG realLength = sizeof(STORAGE_DEVICE_DESCRIPTOR);

    LONG serialNumberLength;

    PUCHAR currentOffset = (PUCHAR) Descriptor;

    LONG inquiryLength;

    PINQUIRYDATA inquiryData = &(LogicalUnit->InquiryData);

    STORAGE_DEVICE_DESCRIPTOR tmp;

    PAGED_CODE();

    ASSERT_PDO(LogicalUnit->DeviceObject);
    ASSERT(Descriptor != NULL);

    serialNumberLength = LogicalUnit->SerialNumber.Length + 1;

    //
    // Figure out what the total size of this structure is going to be
    //

    inquiryLength = 4 + inquiryData->AdditionalLength;

    if(inquiryLength > INQUIRYDATABUFFERSIZE) {
        inquiryLength = INQUIRYDATABUFFERSIZE;
    }

    realLength += inquiryLength + 31;   // 31 = length of the 3 id strings +
                                        // 3 nuls

    //
    // Add the length of the serial number.
    //

    realLength += serialNumberLength;

    //
    // Zero the buffer provided.
    //

    RtlZeroMemory(Descriptor, *DescriptorLength);

    //
    // Build the device descriptor structure on the stack then copy as much as
    // can be copied over
    //

    RtlZeroMemory(&tmp, sizeof(STORAGE_DEVICE_DESCRIPTOR));

    tmp.Version = sizeof(STORAGE_DEVICE_DESCRIPTOR);
    tmp.Size = realLength;

    tmp.DeviceType = inquiryData->DeviceType;
    tmp.DeviceTypeModifier = inquiryData->DeviceTypeModifier;

    tmp.RemovableMedia = inquiryData->RemovableMedia;

    tmp.CommandQueueing = inquiryData->CommandQueue;

    tmp.SerialNumberOffset = 0xffffffff;

    tmp.BusType = driverExtension->BusType;

    RtlCopyMemory(currentOffset,
                  &tmp,
                  min(sizeof(STORAGE_DEVICE_DESCRIPTOR), bytesRemaining));

    bytesRemaining -= sizeof(STORAGE_DEVICE_DESCRIPTOR);

    if(bytesRemaining <= 0) {
        *DescriptorLength = maxLength;
        return STATUS_SUCCESS;
    }

    currentOffset = ((PUCHAR) Descriptor) + (maxLength - bytesRemaining);

    //
    // Copy over as much inquiry data as we can and update the raw byte count
    //

    RtlCopyMemory(currentOffset, inquiryData, min(inquiryLength, bytesRemaining));

    bytesRemaining -= inquiryLength;

    if(bytesRemaining <= 0) {

        *DescriptorLength = maxLength;

        Descriptor->RawPropertiesLength = maxLength -
                                          sizeof(STORAGE_DEVICE_DESCRIPTOR);

        return STATUS_SUCCESS;
    }

    Descriptor->RawPropertiesLength = inquiryLength;

    currentOffset = ((PUCHAR) Descriptor) + (maxLength - bytesRemaining);

    //
    // Now we need to start copying inquiry strings
    //

    //
    // first the vendor id
    //

    RtlCopyMemory(currentOffset,
                  inquiryData->VendorId,
                  min(bytesRemaining, sizeof(UCHAR) * 8));

    bytesRemaining -= sizeof(UCHAR) * 9;     // include trailing null

    if(bytesRemaining >= 0) {

        Descriptor->VendorIdOffset = (ULO