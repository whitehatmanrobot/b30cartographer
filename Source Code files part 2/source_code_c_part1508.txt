lib            \
        ..\..\ref\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dref.lib             

NO_NTDLL = 1

DLLENTRY = _DllMainCRTStartup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\d3ddev.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3ddev.cpp
 *  Content:    Direct3D device implementation
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: device.c,v 1.26 1995/12/04 11:29:47 sjl Exp $
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
/*
 * Create an api for the Direct3DDevice object
 */
extern "C" {
#define this _this
#include "ddrawpr.h"
#undef this
}
#include "drawprim.hpp"
#include "fe.h"
#include "enum.hpp"

//#define APIPROF
#ifdef APIPROF
#include "apiprof.cpp"
#endif //APIPROF

#if defined(PROFILE4)
#include <icecap.h>
#elif defined(PROFILE)
#include <icapexp.h>
#endif

// Remove DDraw's type unsafe definition and replace with our C++ friendly def
#ifdef VALIDEX_CODE_PTR
#undef VALIDEX_CODE_PTR
#endif
#define VALIDEX_CODE_PTR( ptr ) \
(!IsBadCodePtr( (FARPROC) ptr ) )

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice"

extern void setIdentity(D3DMATRIXI * m);

#ifndef PROFILE4
#ifdef _X86_
extern HRESULT D3DAPI katmai_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
extern HRESULT D3DAPI wlmt_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
extern HRESULT D3DAPI x3DContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
#endif
#endif

#ifdef _X86_
extern BOOL IsWin95();
#endif

extern HINSTANCE hMsGeometryDLL;

// This is a list of all rstates that UpdateInternalState does some
// work other than updating this->rstates[] array. This is used to
// do a quick bitwise check to see if this rstate is trivial or not.

const D3DRENDERSTATETYPE rsList[] = {

    // renderstates that either need runtime attention or that cannot be sent
    // to legacy drivers
    D3DRENDERSTATE_FOGENABLE,
    D3DRENDERSTATE_SPECULARENABLE,
    D3DRENDERSTATE_RANGEFOGENABLE,
    D3DRENDERSTATE_FOGDENSITY,
    D3DRENDERSTATE_FOGSTART,
    D3DRENDERSTATE_FOGEND,
    D3DRENDERSTATE_WRAP0,
    D3DRENDERSTATE_WRAP1,
    D3DRENDERSTATE_WRAP2,
    D3DRENDERSTATE_WRAP3,
    D3DRENDERSTATE_WRAP4,
    D3DRENDERSTATE_WRAP5,
    D3DRENDERSTATE_WRAP6,
    D3DRENDERSTATE_WRAP7,
    D3DRENDERSTATE_CLIPPING,
    D3DRENDERSTATE_LIGHTING,
    D3DRENDERSTATE_AMBIENT,
    D3DRENDERSTATE_FOGVERTEXMODE,
    D3DRENDERSTATE_COLORVERTEX,
    D3DRENDERSTATE_LOCALVIEWER,
    D3DRENDERSTATE_NORMALIZENORMALS,
    D3DRENDERSTATE_COLORKEYBLENDENABLE,
    D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
    D3DRENDERSTATE_SPECULARMATERIALSOURCE,
    D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
    D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
    D3DRENDERSTATE_VERTEXBLEND,
    D3DRENDERSTATE_CLIPPLANEENABLE,
    D3DRENDERSTATE_SHADEMODE,
    D3DRS_SOFTWAREVERTEXPROCESSING,
    D3DRS_POINTSIZE,
    D3DRS_POINTSIZE_MIN,
    D3DRS_POINTSPRITEENABLE,
    D3DRS_POINTSCALEENABLE,
    D3DRS_POINTSCALE_A,
    D3DRS_POINTSCALE_B,
    D3DRS_POINTSCALE_C,
    D3DRS_MULTISAMPLEANTIALIAS,
    D3DRS_MULTISAMPLEMASK,
    D3DRS_PATCHEDGESTYLE,
    D3DRS_PATCHSEGMENTS,
    D3DRS_DEBUGMONITORTOKEN,
    D3DRS_POINTSIZE_MAX,
    D3DRS_INDEXEDVERTEXBLENDENABLE,
    D3DRS_COLORWRITEENABLE,
    D3DRS_TWEENFACTOR,
    D3DRS_DEBUGMONITORTOKEN,
    D3DRS_BLENDOP,
    D3DRS_PATCHSEGMENTS,

    // Retired renderstates to be filtered with DPF error and INVALID return
    // NOTE: everything listed here is also assumed to appear in rsListRetired
    D3DRENDERSTATE_TEXTUREHANDLE,
    D3DRENDERSTATE_TEXTUREADDRESS,
    D3DRENDERSTATE_WRAPU,
    D3DRENDERSTATE_WRAPV,
    D3DRENDERSTATE_MONOENABLE,
    D3DRENDERSTATE_ROP2,
    D3DRENDERSTATE_PLANEMASK,
    D3DRENDERSTATE_TEXTUREMAG,
    D3DRENDERSTATE_TEXTUREMIN,
    D3DRENDERSTATE_TEXTUREMAPBLEND,
    D3DRENDERSTATE_SUBPIXEL,
    D3DRENDERSTATE_SUBPIXELX,
    D3DRENDERSTATE_STIPPLEENABLE,
    D3DRENDERSTATE_BORDERCOLOR,
    D3DRENDERSTATE_TEXTUREADDRESSU,
    D3DRENDERSTATE_TEXTUREADDRESSV,
    D3DRENDERSTATE_MIPMAPLODBIAS,
    D3DRENDERSTATE_ANISOTROPY,
    D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT,
    D3DRENDERSTATE_STIPPLEPATTERN00,
    D3DRENDERSTATE_STIPPLEPATTERN01,
    D3DRENDERSTATE_STIPPLEPATTERN02,
    D3DRENDERSTATE_STIPPLEPATTERN03,
    D3DRENDERSTATE_STIPPLEPATTERN04,
    D3DRENDERSTATE_STIPPLEPATTERN05,
    D3DRENDERSTATE_STIPPLEPATTERN06,
    D3DRENDERSTATE_STIPPLEPATTERN07,
    D3DRENDERSTATE_STIPPLEPATTERN08,
    D3DRENDERSTATE_STIPPLEPATTERN09,
    D3DRENDERSTATE_STIPPLEPATTERN10,
    D3DRENDERSTATE_STIPPLEPATTERN11,
    D3DRENDERSTATE_STIPPLEPATTERN12,
    D3DRENDERSTATE_STIPPLEPATTERN13,
    D3DRENDERSTATE_STIPPLEPATTERN14,
    D3DRENDERSTATE_STIPPLEPATTERN15,
    D3DRENDERSTATE_STIPPLEPATTERN16,
    D3DRENDERSTATE_STIPPLEPATTERN17,
    D3DRENDERSTATE_STIPPLEPATTERN18,
    D3DRENDERSTATE_STIPPLEPATTERN19,
    D3DRENDERSTATE_STIPPLEPATTERN20,
    D3DRENDERSTATE_STIPPLEPATTERN21,
    D3DRENDERSTATE_STIPPLEPATTERN22,
    D3DRENDERSTATE_STIPPLEPATTERN23,
    D3DRENDERSTATE_STIPPLEPATTERN24,
    D3DRENDERSTATE_STIPPLEPATTERN25,
    D3DRENDERSTATE_STIPPLEPATTERN26,
    D3DRENDERSTATE_STIPPLEPATTERN27,
    D3DRENDERSTATE_STIPPLEPATTERN28,
    D3DRENDERSTATE_STIPPLEPATTERN29,
    D3DRENDERSTATE_STIPPLEPATTERN30,
    D3DRENDERSTATE_STIPPLEPATTERN31,
    // newly retired for DX8
    D3DRENDERSTATE_ANTIALIAS,
    D3DRENDERSTATE_TEXTUREPERSPECTIVE,
    D3DRENDERSTATE_COLORKEYENABLE,
    D3DRENDERSTATE_COLORKEYBLENDENABLE,
    D3DRENDERSTATE_STIPPLEDALPHA,

};

// list of retired renderstates - need to make sure these are
// filtered and never get from app directly to driver
const D3DRENDERSTATETYPE rsListRetired[] = {
    D3DRENDERSTATE_TEXTUREHANDLE,
    D3DRENDERSTATE_TEXTUREADDRESS,
    D3DRENDERSTATE_WRAPU,
    D3DRENDERSTATE_WRAPV,
    D3DRENDERSTATE_MONOENABLE,
    D3DRENDERSTATE_ROP2,
    D3DRENDERSTATE_PLANEMASK,
    D3DRENDERSTATE_TEXTUREMAG,
    D3DRENDERSTATE_TEXTUREMIN,
    D3DRENDERSTATE_TEXTUREMAPBLEND,
    D3DRENDERSTATE_SUBPIXEL,
    D3DRENDERSTATE_SUBPIXELX,
    D3DRENDERSTATE_STIPPLEENABLE,
    D3DRENDERSTATE_BORDERCOLOR,
    D3DRENDERSTATE_TEXTUREADDRESSU,
    D3DRENDERSTATE_TEXTUREADDRESSV,
    D3DRENDERSTATE_MIPMAPLODBIAS,
    D3DRENDERSTATE_ANISOTROPY,
    D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT,
    D3DRENDERSTATE_STIPPLEPATTERN00,
    D3DRENDERSTATE_STIPPLEPATTERN01,
    D3DRENDERSTATE_STIPPLEPATTERN02,
    D3DRENDERSTATE_STIPPLEPATTERN03,
    D3DRENDERSTATE_STIPPLEPATTERN04,
    D3DRENDERSTATE_STIPPLEPATTERN05,
    D3DRENDERSTATE_STIPPLEPATTERN06,
    D3DRENDERSTATE_STIPPLEPATTERN07,
    D3DRENDERSTATE_STIPPLEPATTERN08,
    D3DRENDERSTATE_STIPPLEPATTERN09,
    D3DRENDERSTATE_STIPPLEPATTERN10,
    D3DRENDERSTATE_STIPPLEPATTERN11,
    D3DRENDERSTATE_STIPPLEPATTERN12,
    D3DRENDERSTATE_STIPPLEPATTERN13,
    D3DRENDERSTATE_STIPPLEPATTERN14,
    D3DRENDERSTATE_STIPPLEPATTERN15,
    D3DRENDERSTATE_STIPPLEPATTERN16,
    D3DRENDERSTATE_STIPPLEPATTERN17,
    D3DRENDERSTATE_STIPPLEPATTERN18,
    D3DRENDERSTATE_STIPPLEPATTERN19,
    D3DRENDERSTATE_STIPPLEPATTERN20,
    D3DRENDERSTATE_STIPPLEPATTERN21,
    D3DRENDERSTATE_STIPPLEPATTERN22,
    D3DRENDERSTATE_STIPPLEPATTERN23,
    D3DRENDERSTATE_STIPPLEPATTERN24,
    D3DRENDERSTATE_STIPPLEPATTERN25,
    D3DRENDERSTATE_STIPPLEPATTERN26,
    D3DRENDERSTATE_STIPPLEPATTERN27,
    D3DRENDERSTATE_STIPPLEPATTERN28,
    D3DRENDERSTATE_STIPPLEPATTERN29,
    D3DRENDERSTATE_STIPPLEPATTERN30,
    D3DRENDERSTATE_STIPPLEPATTERN31,
    // newly retired for DX8
    D3DRENDERSTATE_ANTIALIAS,
    D3DRENDERSTATE_TEXTUREPERSPECTIVE,
    D3DRENDERSTATE_COLORKEYENABLE,
    D3DRENDERSTATE_COLORKEYBLENDENABLE,
    D3DRENDERSTATE_STIPPLEDALPHA,
};

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DHal                                                                 //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------
CD3DHal::CD3DHal()
{
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // DO NOT PUT INITIALIZATION IN THE CONSTRUCTOR.
    // Put it in Init() instead. This is because the device can be
    // "Destroy()ed" and "Init()ed" anytime via Reset. In this
    // situation, the constructor is never called. (snene 01/00)
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::StateInitialize"

void CD3DHal::StateInitialize(BOOL bZEnable)
{
    DWORD i,j;

    // Initialize the bit array indicating the rstates needing non-trivial
    // work.
    for (i=0; i < sizeof(rsList) / sizeof(D3DRENDERSTATETYPE); ++i)
        rsVec.SetBit(rsList[i]);
    // Initialize the bit array indicating the retired rstates
    for (i=0; i < sizeof(rsListRetired) / sizeof(D3DRENDERSTATETYPE); ++i)
        rsVecRetired.SetBit(rsListRetired[i]);
    // Initialize the bit array indicating the vertex processing only rstates
    for (i=0; i < sizeof(rsVertexProcessingList) / sizeof(D3DRENDERSTATETYPE); ++i)
        rsVertexProcessingOnly.SetBit(rsVertexProcessingList[i]);

    // Obviate Set(Render;TextureStage)State filtering 'redundant' device state settings
    // since this is the init step.
//    memset( this->rstates, 0xff, sizeof(DWORD)*D3D_MAXRENDERSTATES);
    for (i=0; i<D3D_MAXRENDERSTATES; i++)
        this->rstates[i] = 0xbaadcafe;
//    memset( this->tsstates, 0xff, sizeof(DWORD)*D3DHAL_TSS_MAXSTAGES*D3DHAL_TSS_STATESPERSTAGE );
    for (j=0; j<D3DHAL_TSS_MAXSTAGES; j++)
        for (i=0; i<D3DHAL_TSS_STATESPERSTAGE; i++)
            this->tsstates[j][i] = 0xbaadcafe;

    CD3DBase::StateInitialize(bZEnable);

    if (GetDDIType() < D3DDDITYPE_DX8)
    {
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREPERSPECTIVE, TRUE);
        SetRenderStateInternal(D3DRENDERSTATE_COLORKEYENABLE, FALSE);
        SetRenderStateInternal(D3DRENDERSTATE_COLORKEYBLENDENABLE, FALSE);
        SetRenderStateInternal(D3DRENDERSTATE_STIPPLEDALPHA, FALSE);
    }

    if (GetDDIType() < D3DDDITYPE_DX7)
    {
        // send retired renderstate init's to pre-DX7 HALs only
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEENABLE, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_MONOENABLE, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_ROP2, R2_COPYPEN);
        SetRenderStateInternal( D3DRENDERSTATE_PLANEMASK, (DWORD)~0);
        SetRenderStateInternal( D3DRENDERSTATE_WRAPU, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_WRAPV, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_ANTIALIAS, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_SUBPIXEL, FALSE); /* 30 */
        SetRenderStateInternal( D3DRENDERSTATE_SUBPIXELX, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN00, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN01, 0); /* 40 */
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN02, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN03, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN04, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN05, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN06, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN07, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN08, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN09, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN10, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN11, 0); /* 50 */
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN12, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN13, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN14, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN15, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN16, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN17, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN18, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN19, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN20, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN21, 0); /* 60 */
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN22, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN23, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN24, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN25, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN26, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN27, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN28, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN29, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN30, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN31, 0); /* 70 */
    }

    if( BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING )
    {
        SwitchVertexProcessingMode(TRUE);
        rstates[D3DRS_SOFTWAREVERTEXPROCESSING] = TRUE;
    }
    else if( BehaviorFlags() & D3DCREATE_HARDWARE_VERTEXPROCESSING )
    {
        SwitchVertexProcessingMode(FALSE);
        rstates[D3DRS_SOFTWAREVERTEXPROCESSING] = FALSE;
    }
    else if( BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING )
    {
        SetRenderStateInternal( D3DRS_SOFTWAREVERTEXPROCESSING, 0);
    }
    else
    {
        D3D_INFO( 0, "No Vertex Processing behavior specified, assuming software" );
        SwitchVertexProcessingMode(TRUE);
        rstates[D3DRS_SOFTWAREVERTEXPROCESSING] = TRUE;
    }
}

/*
 * Initialisation - class part and device part
 */

//---------------------------------------------------------------------
HRESULT CD3DHal::D3DFE_Create()
{
    DDSURFACEDESC ddsd;
    HRESULT hr;
    const D3DCAPS8 *pCaps = GetD3DCaps();

    if (m_pDDI->GetDDIType() < D3DDDITYPE_DX7)
    {
        m_dwRuntimeFlags |= D3DRT_ONLY2FLOATSPERTEXTURE;
    }
    else
    if (m_pDDI->GetDDIType() < D3DDDITYPE_DX8)
    {
        // Some drivers (G200, G400) cannot handle more than 2 floats in
        // texture coordinates, even they are supposed to. We set the
        // runtime bit to mark such drivers and compute output FVF for vertex
        // shaders accordingly
        if (!(pCaps->TextureCaps & D3DPTEXTURECAPS_PROJECTED ||
              pCaps->TextureCaps & D3DPTEXTURECAPS_CUBEMAP))
        {
            m_dwRuntimeFlags |= D3DRT_ONLY2FLOATSPERTEXTURE;
        }
    }
    if (!(pCaps->TextureCaps & D3DPTEXTURECAPS_PROJECTED))
        m_dwRuntimeFlags |= D3DRT_EMULATEPROJECTEDTEXTURE;

    if (pCaps && pCaps->FVFCaps)
    {
        this->m_pv->dwMaxTextureIndices =
            pCaps->FVFCaps & D3DFVFCAPS_TEXCOORDCOUNTMASK;
        if (pCaps->FVFCaps & D3DFVFCAPS_DONOTSTRIPELEMENTS)
            this->m_pv->dwDeviceFlags |= D3DDEV_DONOTSTRIPELEMENTS;

        DWORD value;
        if ((GetD3DRegValue(REG_DWORD, "DisableStripFVF", &value, 4) &&
            value != 0))
        {
            this->m_pv->dwDeviceFlags |= D3DDEV_DONOTSTRIPELEMENTS;
        }
    }
    else
    {
        this->m_pv->dwMaxTextureIndices = 1;
    }

    this->dwFEFlags |= D3DFE_FRONTEND_DIRTY;

#if DBG
    this->dwCaller=0;
    memset(this->dwPrimitiveType,0,sizeof(this->dwPrimitiveType));
    memset(this->dwVertexType1,0,sizeof(this->dwVertexType1));
    memset(this->dwVertexType2,0,sizeof(this->dwVertexType2));
#endif

    // True for software rendering
    m_dwNumStreams = __NUMSTREAMS;
    m_dwMaxUserClipPlanes = __MAXUSERCLIPPLANES;

    this->m_pv->dwClipMaskOffScreen = 0xFFFFFFFF;
    if (pCaps != NULL)
    {
        if (pCaps->GuardBandLeft   != 0.0f ||
            pCaps->GuardBandRight  != 0.0f ||
            pCaps->GuardBandTop    != 0.0f ||
            pCaps->GuardBandBottom != 0.0f)
        {
            this->m_pv->dwDeviceFlags |= D3DDEV_GUARDBAND;
            this->m_pv->dwClipMaskOffScreen = ~__D3DCS_INGUARDBAND;
            DWORD v;
            if (GetD3DRegValue(REG_DWORD, "DisableGB", &v, 4) &&
                v != 0)
            {
                this->m_pv->dwDeviceFlags &= ~D3DDEV_GUARDBAND;
                this->m_pv->dwClipMaskOffScreen = 0xFFFFFFFF;
            }
#if DBG
            // Try to get test values for the guard band
            char value[80];
            if (GetD3DRegValue(REG_SZ, "GuardBandLeft", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &pCaps->GuardBandLeft);
            if (GetD3DRegValue(REG_SZ, "GuardBandRight", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &pCaps->GuardBandRight);
            if (GetD3DRegValue(REG_SZ, "GuardBandTop", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &pCaps->GuardBandTop);
            if (GetD3DRegValue(REG_SZ, "GuardBandBottom", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &pCaps->GuardBandBottom);
#endif // DBG
        }
    }

    LIST_INITIALIZE(&this->specular_tables);
    this->specular_table = NULL;

    this->lightVertexFuncTable = &lightVertexTable;
    m_pv->lighting.activeLights = NULL;

    this->m_ClipStatus.ClipUnion = 0;
    this->m_ClipStatus.ClipIntersection = ~0;

    m_pv->pDDI = m_pDDI;
#if DBG
    m_pv->pDbgMon = m_pDbgMon;
#endif

    return S_OK;
}

void CD3DHal::D3DFE_Destroy()
{
// Destroy lighting data

    SpecularTable *spec;
    SpecularTable *spec_next;

    for (spec = LIST_FIRST(&this->specular_tables); spec; spec = spec_next)
    {
        spec_next = LIST_NEXT(spec,list);
        D3DFree(spec);
    }
    LIST_INITIALIZE(&specular_tables);

    delete m_pLightArray;
    m_pLightArray = NULL;

    delete m_pv;
    m_pv = NULL;

    delete m_pConvObj;
    m_pConvObj = NULL;

    if (m_clrRects)
    {
        D3DFree(m_clrRects);
        m_clrRects = NULL;
    }
}

/*
 * Generic device part destroy
 */
CD3DHal::~CD3DHal()
{
    Destroy();
}

void
CD3DHal::Destroy()
{
    try // Since Destroy() can be called directly by fw
    {
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // MUST CLEANUP AND RELEASE CURRENTLY SET TEXTURES BEFORE
        // DOING ANY OTHER WORK, else we will get into situations
        // where we are calling FlushStates or batching DDI tokens.
        CleanupTextures();
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        /* Clear flags that could prohibit cleanup */
        m_dwHintFlags &=  ~(D3DDEVBOOL_HINTFLAGS_INSCENE);

        // Destroy vertex shaders. We need to delete vertex shaders completely
        // to preserve behavior for DX8.0 apps. For DX8.1 apps we delete only
        // PSGP part of a vertex shader. The rest will be used to re-create 
        // the shader during Reset()
        if (m_pVShaderArray != NULL)
        {
            UINT size = m_pVShaderArray->GetSize();
            for (UINT i=0; i < size; i++)
            {
                UINT Handle = m_pVShaderArray->HandleFromIndex(i);
                CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(Handle);
                if (pShader)
                {
                    if (Enum()->GetAppSdkVersion() == D3D_SDK_VERSION_DX8)
                    {
                        m_pVShaderArray->ReleaseHandle(Handle, TRUE);
                    }
                    else
                    {
                        // We need to delete PSGP shader object before deleting
                        // D3DFE_PROCESSVERTICES object, because AMD has keeps a 
                        // pointer to it inside the code object
                        if (pShader->m_dwFlags & CVShader::SOFTWARE)
                        {
                            delete pShader->m_pCode;
                            pShader->m_pCode = NULL;
                        }
                    }
                }
            }
        }
        
        // Destroy pixel shaders for DX8.0 apps to preserve trhe original behavior
        if (m_pPShaderArray != NULL)
        {
            UINT size = m_pPShaderArray->GetSize();
            for (UINT i=0; i < size; i++)
            {
                UINT Handle = m_pPShaderArray->HandleFromIndex(i);
                CPShader* pShader = (CPShader*)m_pPShaderArray->GetObject(Handle);
                if (pShader)
                {
                    if (Enum()->GetAppSdkVersion() == D3D_SDK_VERSION_DX8)
                    {
                        m_pPShaderArray->ReleaseHandle(Handle, TRUE);
                    }
                }
            }
        }

        if (m_pv)
        {
            if ( 0 != m_pv->pGeometryFuncs &&
                (LPVOID)m_pv->pGeometryFuncs != (LPVOID)GeometryFuncsGuaranteed)
            {
                delete m_pv->pGeometryFuncs;
                m_pv->pGeometryFuncs = 0;
            }

            if ( 0 != GeometryFuncsGuaranteed)
            {
                delete GeometryFuncsGuaranteed;
                GeometryFuncsGuaranteed = 0;
                m_pv->pGeometryFuncs = 0;
            }
        }

        this->D3DFE_Destroy();

        if ( 0 != rstates)
        {
            delete[] rstates;
            rstates = 0;
        }

        delete pMatrixDirtyForDDI;
        pMatrixDirtyForDDI = NULL;

        CD3DBase::Destroy();
    }
    catch(HRESULT ret)
    {
        DPF_ERR("There was some error when Reset()ing the device; as a result some resources may not be freed.");
    }
}

/*
 * Create a device.
 *
 * This method
 * implements the CreateDevice method of the CEnum object. (The CEnum
 * object exposes the IDirect3D8 interface which supports enumeration
 * etc.)
 *
 */

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::CreateDevice"

STDMETHODIMP CEnum::CreateDevice(
        UINT                    iAdapter,
        D3DDEVTYPE              DeviceType,
        HWND                    hwndFocusWindow,
        DWORD                   dwFlags,
        D3DPRESENT_PARAMETERS  *pPresentationParams,
        IDirect3DDevice8      **ppNewInterface)
{
    API_ENTER(this);

    PD3D8_DEVICEDATA pDD;
    LPD3DBASE        pd3ddev;
    HRESULT          ret = D3D_OK;
    VOID*            pInit = NULL;

    if (!VALID_PTR_PTR(ppNewInterface))
    {
        DPF_ERR("Invalid IDirect3DDevice8* pointer, CreateDevice fails");
        return D3DERR_INVALIDCALL;
    }

    // Zero out out parameters
    *ppNewInterface = NULL;

    if (!VALID_PTR(pPresentationParams, sizeof(D3DPRESENT_PARAMETERS)))
    {
        DPF_ERR("Invalid D3DPRESENT_PARAMETERS pointer, CreateDevice fails");
        return D3DERR_INVALIDCALL;
    }

    // Check that fullscreen parameters are correct
    if (pPresentationParams->Windowed)
    {
        if (pPresentationParams->FullScreen_RefreshRateInHz != 0)
        {
            DPF_ERR("FullScreen_RefreshRateInHz must be zero for windowed mode. CreateDevice fails.");
            return D3DERR_INVALIDCALL;
        }
        if (pPresentationParams->FullScreen_PresentationInterval != 0)
        {
            DPF_ERR("FullScreen_PresentationInterval must be zero for windowed mode. CreateDevice fails.");
            return D3DERR_INVALIDCALL;
        }
    }
    else
    {
        DWORD interval = pPresentationParams->FullScreen_PresentationInterval;
        switch (interval)
        {
        case D3DPRESENT_INTERVAL_DEFAULT:
        case D3DPRESENT_INTERVAL_ONE:
        case D3DPRESENT_INTERVAL_TWO:
        case D3DPRESENT_INTERVAL_THREE:
        case D3DPRESENT_INTERVAL_FOUR:
        case D3DPRESENT_INTERVAL_IMMEDIATE:
            break;
        default:
            DPF_ERR("Invalid value for FullScreen_PresentationInterval. CreateDevice Fails.");
            return D3DERR_INVALIDCALL;
        }
    }
    if (pPresentationParams->BackBufferFormat == D3DFMT_UNKNOWN)
    {
        DPF_ERR("Invalid backbuffer format specified. CreateDevice fails.");
        return D3DERR_INVALIDCALL;
    }

    if (pPresentationParams->Flags & ~D3DPRESENTFLAG_LOCKABLE_BACKBUFFER)
    {
        DPF_ERR("Invalid flag for Flags. CreateDevice fails.");
        return D3DERR_INVALIDCALL;
    }

    // Validate the HWNDs that we are given
    if (hwndFocusWindow && !IsWindow(hwndFocusWindow))
    {
        DPF_ERR("Invalid HWND specified for hwndFocusWindow, CreateDevice fails");
        return D3DERR_INVALIDCALL;
    }
    if (pPresentationParams->hDeviceWindow && !IsWindow(pPresentationParams->hDeviceWindow))
    {
        DPF_ERR("Invalid HWND specified for PresentationParams.hDeviceWindow. CreateDevice fails.");
        return D3DERR_INVALIDCALL;
    }

    // Make sure that we are given a focus window or a device window
    if (NULL == hwndFocusWindow)
    {
        if (!pPresentationParams->Windowed)
        {
            DPF_ERR("Fullscreen CreateDevice must specify Focus window");
            return D3DERR_INVALIDCALL;
        }
        else
        if (NULL == pPresentationParams->hDeviceWindow)
        {
            DPF_ERR("Neither hDeviceWindow nor Focus window specified. CreateDevice Failed.");
            return D3DERR_INVALIDCALL;
        }
    }

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid iAdapter parameter passed to CreateDevice");
        return D3DERR_INVALIDCALL;
    }

    if (dwFlags & ~VALID_D3DCREATE_FLAGS)
    {
        DPF_ERR("Invalid BehaviorFlags passed to CreateDevice");
        return D3DERR_INVALIDCALL;
    }

    // Check that exactly one of the vertex processing flags is set
    DWORD dwVertexProcessingFlags = dwFlags & (D3DCREATE_HARDWARE_VERTEXPROCESSING |
                                               D3DCREATE_SOFTWARE_VERTEXPROCESSING |
                                               D3DCREATE_MIXED_VERTEXPROCESSING);

    if (dwVertexProcessingFlags != D3DCREATE_HARDWARE_VERTEXPROCESSING &&
        dwVertexProcessingFlags != D3DCREATE_SOFTWARE_VERTEXPROCESSING &&
        dwVertexProcessingFlags != D3DCREATE_MIXED_VERTEXPROCESSING)
    {
        DPF_ERR("Invalid Flags parameter to CreateDevice: Exactly One of the"
                " following must be set: D3DCREATE_HARDWARE_VERTEXPROCESSING,"
                " D3DCREATE_SOFTWARE_VERTEXPROCESSING or"
                " D3DCREATE_MIXED_VERTEXPROCESSING");
        return D3DERR_INVALIDCALL;
    }


    if (DeviceType == D3DDEVTYPE_SW)
    {
        pInit = m_pSwInitFunction;
        if (pInit == NULL)
        {
            D3D_ERR("App specified D3DDEVTYPE_SW without first registering a software device. CreateDevice Failed.");
            return D3DERR_INVALIDCALL;
        }
        GetSwCaps(iAdapter);
    }
    else if (DeviceType == D3DDEVTYPE_REF)
    {
        GetRefCaps(iAdapter);
    }

    ret = InternalDirectDrawCreate(&pDD,
                                   &m_AdapterInfo[iAdapter],
                                   DeviceType,
                                   pInit,
                                   GetUnknown16(iAdapter),
                                   m_AdapterInfo[iAdapter].HALCaps.pGDD8SupportedFormatOps,
                                   m_AdapterInfo[iAdapter].HALCaps.GDD8NumSupportedFormatOps);
    if( FAILED(ret) )
    {
        D3D_ERR("Failed to create DirectDraw. CreateDevice Failed.");
        return ret;
    }

    if((dwFlags & D3DCREATE_SOFTWARE_VERTEXPROCESSING) != 0)
    {
        if((dwFlags & D3DCREATE_PUREDEVICE) != 0)
        {
            D3D_ERR("Pure device cannot perform software processing. CreateDevice Failed.");
            InternalDirectDrawRelease(pDD);
            return D3DERR_INVALIDCALL;
        }
    }
    else if((dwFlags & D3DCREATE_HARDWARE_VERTEXPROCESSING) != 0)
    {
        if((pDD->DriverData.D3DCaps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) 
           == 0)
        {
            D3D_ERR("Device cannot perform hardware processing");
            InternalDirectDrawRelease(pDD);
            return D3DERR_INVALIDCALL;
        }
    }
    else if((dwFlags & D3DCREATE_MIXED_VERTEXPROCESSING) != 0)
    {
        if((pDD->DriverData.D3DCaps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) == 0 ||
           (dwFlags & D3DCREATE_PUREDEVICE) != 0)
        {
            D3D_ERR("Device cannot perform mixed processing because driver cannot do hardware T&L. CreateDevice Failed.");
            InternalDirectDrawRelease(pDD);
            return D3DERR_INVALIDCALL;
        }
    }
    else
    {
        if((dwFlags & D3DCREATE_PUREDEVICE) != 0)
        {
            if((pDD->DriverData.D3DCaps.DevCaps & D3DDEVCAPS_PUREDEVICE) == 0)
            {
                D3D_ERR("Hardware should be capable of creating a pure device");
                InternalDirectDrawRelease(pDD);
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            D3D_ERR("Must specify software, hardware or mixed vertex processing");
            InternalDirectDrawRelease(pDD);
            return D3DERR_INVALIDCALL;
        }
    }

    switch (DeviceType)
    {
    case D3DDEVTYPE_SW:
    case D3DDEVTYPE_REF:
    case D3DDEVTYPE_HAL:
        if (dwFlags & D3DCREATE_PUREDEVICE)
        {
            pd3ddev = new CD3DBase();
        }
        else
        {
            pd3ddev = static_cast<LPD3DBASE>(new CD3DHal());
        }
        break;
    default:
        D3D_ERR("Unrecognized or unsupported DeviceType. CreateDevice Failed.");
        InternalDirectDrawRelease(pDD);
        return D3DERR_INVALIDCALL;
    }

    if (!pd3ddev)
    {
        D3D_ERR("Failed to allocate space for the device object. CreateDevice Failed.");
        InternalDirectDrawRelease(pDD);
        return (E_OUTOFMEMORY);
    }

#if DBG
    {
        char DevTypeMsg[256];
        _snprintf( DevTypeMsg, 256, "=======================" );
        switch( DeviceType )
        {
        case D3DDEVTYPE_HAL:
            _snprintf( DevTypeMsg, 256, "%s Hal", DevTypeMsg );
            break;
        case D3DDEVTYPE_SW:
            _snprintf( DevTypeMsg, 256, "%s Pluggable SW", DevTypeMsg );
            break;
        case D3DDEVTYPE_REF:
            _snprintf( DevTypeMsg, 256, "%s Reference", DevTypeMsg );
            break;
        default:
            _snprintf( DevTypeMsg, 256, "%s Unknown", DevTypeMsg );
            break;
        }
        if (dwFlags & D3DCREATE_HARDWARE_VERTEXPROCESSING)
        {
            _snprintf( DevTypeMsg, 256, "%s HWVP", DevTypeMsg );
        }
        else if (dwFlags & D3DCREATE_MIXED_VERTEXPROCESSING)
        {
            _snprintf( DevTypeMsg, 256, "%s MixedVP", DevTypeMsg );
        }
        else if (dwFlags & D3DCREATE_SOFTWARE_VERTEXPROCESSING)
        {
            _snprintf( DevTypeMsg, 256, "%s SWVP", DevTypeMsg );
        }
        if (dwFlags & D3DCREATE_PUREDEVICE)
        {
            _snprintf( DevTypeMsg, 256, "%s Pure", DevTypeMsg );
        }
        _snprintf( DevTypeMsg, 256, "%s device selected", DevTypeMsg );
        D3D_INFO( 0, DevTypeMsg );
    }
#endif

    //
    // FW's Init
    //
    ret = static_cast<CBaseDevice*>(pd3ddev)->Init(
        pDD,
        DeviceType,
        hwndFocusWindow,
        dwFlags,
        pPresentationParams,
        iAdapter,
        this);
    if (FAILED(ret))
    {
        D3D_ERR("Failed to initialize Framework Device. CreateDevice Failed.");
        delete pd3ddev;
        return ret;
    }

    // We try and create a dummy vidmem vertexbuffer. If this doesn't
    // succeed, we just turn off vidmem VBs. This is to work around
    // the Rage 128 driver that reports DDERR_OUTOFVIDEOMEMORY even
    // though it simply doesn't support vidmem VBs
    if(!IS_DX8HAL_DEVICE(pd3ddev))
    {
#ifdef WIN95
        //ON 9x we probe to see if the driver can do vidmem VBs...
        CVertexBuffer *pVertexBuffer;
        ret = CVertexBuffer::CreateDriverVertexBuffer(pd3ddev,
                                                      1024,
                                                      D3DFVF_TLVERTEX,
                                                      D3DUSAGE_WRITEONLY | D3DUSAGE_DONOTCLIP,
                                                      D3DUSAGE_WRITEONLY | D3DUSAGE_DONOTCLIP | D3DUSAGE_LOCK,
                                                      D3DPOOL_DEFAULT,
                                                      D3DPOOL_DEFAULT,
                                                      REF_INTERNAL,
                                                      &pVertexBuffer);
        if(FAILED(ret))
        {
            if(pd3ddev->VBFailOversDisabled())
            {
                DPF_ERR("Cannot create Vidmem vertex buffer. Will ***NOT*** failover to Sysmem.");
                return ret;
            }
            DPF(1,"Driver doesnt support VidMemVBs which is fine");
        }
        else
        {
            // Get rid of the vb
            pVertexBuffer->DecrementUseCount();
            pd3ddev->EnableVidmemVBs();
        }
#else //WIN95
        //On NT we require the drivers to tell us (by setting D3DDEVCAPS_HWVERTEXBUFFER)

        //Turn off DX7 driver VBs on NT if asked to do so...
        DWORD value;
        if ((GetD3DRegValue(REG_DWORD, "DisableVidMemVBs", &value, 4) != 0) &&
            (value != 0))
        {
            pd3ddev->DisableVidmemVBs();
        }
#endif //!WIN95
    }

    ret = pd3ddev->Init();
    if (ret != D3D_OK)
    {
        delete pd3ddev;
        D3D_ERR("Failed to initialize D3DDevice. CreateDevice Failed.");
        return ret;
    }

    // Looks like everything is in order
    *ppNewInterface = static_cast<IDirect3DDevice8*>(pd3ddev);

#ifdef APIPROF
    CApiProfileDevice* profile = new CApiProfileDevice;
    if (profile)
    {
        if (profile->Init() == D3D_OK)
        {
            profile->SetDevice(*ppNewInterface);
            *ppNewInterface = static_cast<IDirect3DDevice8*>(profile);
        }
        else
        {
            delete profile;
        }
    }
#endif // APIPROF

    return S_OK;
}

#ifdef _X86_

// --------------------------------------------------------------------------
// Detect 3D extensions
// --------------------------------------------------------------------------
BOOL _asm_isX3D()
{
    DWORD retval = 0;
    _asm
        {
            pushad                      ; CPUID trashes lots - save everything
            mov     eax,80000000h       ; Check for extended CPUID support

            ;;; We need to upgrade our compiler
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2

            cmp     eax,80000001h       ; Jump if no extended CPUID
            jb      short done          ;

            mov     eax,80000001h       ; Check for feature
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2

            xor     eax,eax             ;
            test    edx,80000000h       ;
            setnz   al                  ;
            mov     retval,eax          ;

done:
            popad               ; Restore everything
        };
    return retval;
}

static BOOL isX3Dprocessor(void)
{
    __try
    {
            if( _asm_isX3D() )
            {
            return TRUE;
            }
    }
    __except(GetExceptionCode() == STATUS_ILLEGAL_INSTRUCTION ?
             EXCEPTION_EXECUTE_HANDLER :
             EXCEPTION_CONTINUE_SEARCH)
    {
    }
    return FALSE;
}
//---------------------------------------------------------------------
// Detects Intel SSE processor
//
#pragma optimize("", off)
#define CPUID _asm _emit 0x0f _asm _emit 0xa2

#define SSE_PRESENT 0x02000000                  // bit number 25
#define WNI_PRESENT 0x04000000                  // bit number 26

DWORD IsIntelSSEProcessor(void)
{
        DWORD retval = 0;
        DWORD RegisterEAX;
        DWORD RegisterEDX;
        char VendorId[12];
        const char IntelId[13]="GenuineIntel";

        __try
        {
                _asm {
            xor         eax,eax
            CPUID
                mov             RegisterEAX, eax
                mov             dword ptr VendorId, ebx
                mov             dword ptr VendorId+4, edx
                mov             dword ptr VendorId+8, ecx
                }
        } __except (1)
        {
                return retval;
        }

        // make sure EAX is > 0 which means the chip
        // supports a value >=1. 1 = chip info
        if (RegisterEAX == 0)
                return retval;

        // this CPUID can't fail if the above test passed
        __asm {
                mov eax,1
                CPUID
                mov RegisterEAX,eax
                mov RegisterEDX,edx
        }

        if (RegisterEDX  & SSE_PRESENT) {
                retval |= D3DCPU_SSE;
        }

        if (RegisterEDX  & WNI_PRESENT) {
                retval |= D3DCPU_WLMT;
        }

        return retval;
}
#pragma optimize("", on)

// IsProcessorFeatureAvailable() is supported only by WINNT. For other OS
// we emulate it
#ifdef WINNT

static BOOL D3DIsProcessorFeaturePresent(UINT feature)
{
    switch (feature)
    {
    // WINNT does not recognize Willamette processor when we use
    // PF_XMMI64_INSTRUCTIONS_AVAILABLE, so use our detection instead
    case PF_XMMI64_INSTRUCTIONS_AVAILABLE:
        {
            DWORD flags = IsIntelSSEProcessor();
            return flags & D3DCPU_WLMT;
        }
    default: return IsProcessorFeaturePresent(feature);
    }
}

#else

#define PF_XMMI_INSTRUCTIONS_AVAILABLE      6
#define PF_3DNOW_INSTRUCTIONS_AVAILABLE     7
#define PF_XMMI64_INSTRUCTIONS_AVAILABLE   10

static BOOL D3DIsProcessorFeaturePresent(UINT feature)
{
    switch (feature)
    {
    case PF_XMMI_INSTRUCTIONS_AVAILABLE:
        {
            if (IsWin95())
                return FALSE;
            DWORD flags = IsIntelSSEProcessor();
            return flags & D3DCPU_SSE;
        }
    case PF_3DNOW_INSTRUCTIONS_AVAILABLE: return isX3Dprocessor();
    case PF_XMMI64_INSTRUCTIONS_AVAILABLE:
        {
            if (IsWin95())
                return FALSE;
            DWORD flags = IsIntelSSEProcessor();
            return flags & D3DCPU_WLMT;
        }
    default: return FALSE;
    }
}
#endif // WINNT

#endif // _X86_
//------------------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "CD3DHal::InitDevice"

HRESULT
CD3DHal::InitDevice()
{
    HRESULT       ret;

    // Initialize values so we don't crash at shutdown
    this->GeometryFuncsGuaranteed = NULL;
    this->rstates = NULL;
    m_pLightArray = NULL;
    m_pv = NULL;
    m_pCurrentShader = NULL;
    m_pConvObj = NULL;
    pMatrixDirtyForDDI = NULL;
    m_clrRects = NULL;
    m_clrCount = 0;
    m_pv = new D3DFE_PROCESSVERTICES;
    if (m_pv == NULL)
    {
        D3D_ERR("Could not allocate the FE/PSGP data structure (D3DFE_PROCESSVERTICES).");
        return E_OUTOFMEMORY;
    }
    m_pv->pGeometryFuncs = NULL;

    ret = CD3DBase::InitDevice();
    if (ret != D3D_OK)
    {
        D3D_ERR("Failed to initialize CD3DBase.");
        return(ret);
    }

    pMatrixDirtyForDDI = new CPackedBitArray;
    if( pMatrixDirtyForDDI == NULL )
    {
        D3D_ERR("Could not allocate memory for internal data structure pMatrixDirtyForDDI.");
        return E_OUTOFMEMORY;
    }

    if (FAILED(rsVec.Init(D3D_MAXRENDERSTATES)) ||
        FAILED(rsVecRetired.Init(D3D_MAXRENDERSTATES)) ||
        FAILED(rsVertexProcessingOnly.Init(D3D_MAXRENDERSTATES)) ||
        FAILED(pMatrixDirtyForDDI->Init(D3D_MAXTRANSFORMSTATES)))
    {
        D3D_ERR("Could not allocate memory for renderstate processing bit vectors");
        return E_OUTOFMEMORY;
    }

    m_pLightArray = new CHandleArray;
    if (m_pLightArray == NULL)
    {
        D3D_ERR("Could not allocate memory for internal data structure m_pLightArray");
        return E_OUTOFMEMORY;
    }

    dwFEFlags = 0;

    // Initialize FEFlags content that depends on DDI type
    if ( (GetDDIType() == D3DDDITYPE_DX7TL) ||
         (GetDDIType() == D3DDDITYPE_DX8TL) )
        dwFEFlags |= D3DFE_TLHAL;

    // Since this is HAL, initialize it to use the software pipeline
    // this will be turned off when the SW/HW renderstate is set.
    m_pv->dwVIDIn = 0;

    m_pv->pD3DMappedTexI = (LPVOID*)(m_lpD3DMappedTexI);

    /*-------------------------------------------------------------------------
     * Up till now we have done the easy part of the initialization. This is
     * the stuff that cannot fail. It initializes the object so that the
     * destructor can be safely called if any of the further initialization
     * does not succeed.
     *-----------------------------------------------------------------------*/

    this->GeometryFuncsGuaranteed = new D3DFE_PVFUNCSI;
    if (this->GeometryFuncsGuaranteed == NULL)
    {
        D3D_ERR("Could not allocate memory for internal data structure GeometryFuncsGuaranteed");
        return E_OUTOFMEMORY;
    }
    // Software constant register buffer must handle all constants, provided by
    // hardware, to make Set/Get constants possible
    this->GeometryFuncsGuaranteed->m_VertexVM.Init(GetD3DCaps()->MaxVertexShaderConst);

    m_pv->pGeometryFuncs = (LPD3DFE_PVFUNCS)GeometryFuncsGuaranteed;

    if (this->GeometryFuncsGuaranteed == NULL)
    {
        D3D_ERR("Could not allocate memory for FE/PSGP function table.");
        return D3DERR_INVALIDCALL;
    }
    // set up flag to use MMX when requested RGB
    BOOL bUseMMXAsRGBDevice = FALSE;

    D3DSURFACE_DESC desc = this->RenderTarget()->InternalGetDesc();

    /*
     * Check if the 3D cap is set on the surface.
     */
    if ((desc.Usage & D3DUSAGE_RENDERTARGET) == 0)
    {
        D3D_ERR("**** The D3DUSAGE_RENDERTARGET is not set on this surface.");
        D3D_ERR("**** You need to add D3DUSAGE_RENDERTARGET to the Usage parameter");
        D3D_ERR("**** when creating the surface.");
        return (D3DERR_INVALIDCALL);
    }

    // Create front-end support structures.
    ret = this->D3DFE_Create();
    if (ret != D3D_OK)
    {
        D3D_ERR("Failed to create front-end data-structures.");
        goto handle_err;
    }

    // In all other cases we simply allocate memory for rstates
    rstates = new DWORD[D3D_MAXRENDERSTATES];

    m_pv->lpdwRStates = this->rstates;

#ifndef PROFILE4
#ifdef _X86_
    if ((ULONG_PTR)&m_pv->view & 0xF)
    {
        char s[256];
        sprintf(s, "0%xh \n", (ULONG_PTR)&m_pv->view);
        OutputDebugString("INTERNAL ERROR:View matrix in D3DFE_PROCESSVERTICES structure must be aligned to 16 bytes\n");
        OutputDebugString(s);
        ret = D3DERR_INVALIDCALL;
        goto handle_err;
    }
    // Check if we have a processor specific implementation available
    //  only use if DisablePSGP is not in registry or set to zero
    DWORD value;
    if (!GetD3DRegValue(REG_DWORD, "DisablePSGP", &value, sizeof(DWORD)))
    {
        value = 0;
    }
#if DBG
    if (m_pDbgMon && m_pDbgMon->MonitorConnected())
    {
        value = 1;
    }
#endif
    // value =
    //      0   - PSGP enabled
    //      1   - PSGP disabled
    //      2   - X3D PSGP disabled
    if (value != 1)
    {
        // Ask the PV implementation to create a device specific "context"
        LPD3DFE_PVFUNCS pOptGeoFuncs = m_pv->pGeometryFuncs;

        // TODO (bug 40438): Remove DLL interface for final
        // Try to use PSGP DLL first
        if (pfnFEContextCreate)
        {
            ret = pfnFEContextCreate(m_pv->dwDeviceFlags, &pOptGeoFuncs);
            if ((ret == D3D_OK) && pOptGeoFuncs)
            {
                D3D_INFO(0, "Using PSGP DLL");
                m_pv->pGeometryFuncs = pOptGeoFuncs;
                goto l_chosen;
            }
        }

        if (D3DIsProcessorFeaturePresent(PF_3DNOW_INSTRUCTIONS_AVAILABLE) &&
            value != 2)
        {
            ret = x3DContextCreate(m_pv->dwDeviceFlags, &pOptGeoFuncs);
            if (ret == S_OK && pOptGeoFuncs)
            {
                D3D_INFO(0, "Using X3D PSGP");
                m_pv->pGeometryFuncs = pOptGeoFuncs;
                goto l_chosen;
            }
        }
        if (D3DIsProcessorFeaturePresent(PF_XMMI64_INSTRUCTIONS_AVAILABLE))
        {
            ret = wlmt_FEContextCreate(m_pv->dwDeviceFlags, &pOptGeoFuncs);
            if (ret == S_OK && pOptGeoFuncs)
            {
                D3D_INFO(0, "Using WLMT PSGP");
                m_pv->pGeometryFuncs = pOptGeoFuncs;
                goto l_chosen;
            }
        }
        if (D3DIsProcessorFeaturePresent(PF_XMMI_INSTRUCTIONS_AVAILABLE))
        {
            ret = katmai_FEContextCreate(m_pv->dwDeviceFlags, &pOptGeoFuncs);
            if (ret == S_OK && pOptGeoFuncs)
            {
                D3D_INFO(0, "Using P3 PSGP");
                m_pv->pGeometryFuncs = pOptGeoFuncs;
                goto l_chosen;
            }
        }
l_chosen:;
    }

#endif // _X86_
#endif // PROFILE4

    {
        if (HVbuf.Grow((__INIT_VERTEX_NUMBER*2)*sizeof(D3DFE_CLIPCODE)) != DD_OK)
        {
            D3D_ERR( "Could not allocate memory for internal buffer HVBuf" );
            ret = E_OUTOFMEMORY;
            goto handle_err;
        }
    }

    // Setup lights
    if( FAILED( m_pLightArray->Grow( 8 ) ) )
    {
        D3D_ERR( "Could not allocate memory for the light array" );
        ret = E_OUTOFMEMORY;
        goto handle_err;
    }
    LIST_INITIALIZE(&m_ActiveLights);

    // Setup material
    memset(&m_pv->lighting.material, 0, sizeof(m_pv->lighting.material));

    // Set viewport to update front-end data
    SetViewportI(&m_Viewport);

    m_pv->PointSizeMax = GetD3DCaps()->MaxPointSize;
    {
        DWORD EmulatePointSprites = 1;
        GetD3DRegValue(REG_DWORD, "EmulatePointSprites", &EmulatePointSprites, sizeof(DWORD));
        if ((m_pv->PointSizeMax == 0 || !(GetD3DCaps()->FVFCaps & D3DFVFCAPS_PSIZE)) &&
            EmulatePointSprites)
        {
            m_dwRuntimeFlags |= D3DRT_DOPOINTSPRITEEMULATION;
            if (m_pv->PointSizeMax == 0)
                m_pv->PointSizeMax = __MAX_POINT_SIZE;
            else
                m_dwRuntimeFlags |= D3DRT_SUPPORTSPOINTSPRITES;
        }
    }
    m_pfnPrepareToDraw = NULL;

    return (D3D_OK);

handle_err:
    return(ret);
}
//---------------------------------------------------------------------
DWORD
ProcessRects(CD3DHal* pDevI, DWORD dwCount, CONST D3DRECT* rects)
{
    RECT vwport;
    DWORD i,j;

    /*
     * Rip through the rects and validate that they
     * are within the viewport.
     */

    if (dwCount == 0 && rects == NULL)
    {
        dwCount = 1;
    }
#if DBG
    else if (rects == NULL)
    {
        D3D_ERR("The rects parameter is NULL.");
        throw D3DERR_INVALIDCALL;
    }
#endif

    if (dwCount > pDevI->m_clrCount)
    {
        LPD3DRECT       newRects;
        if (D3D_OK == D3DMalloc((void**)&newRects, dwCount * sizeof(D3DRECT)))
        {
            memcpy((void*)newRects,(void*)pDevI->m_clrRects,
                pDevI->m_clrCount* sizeof(D3DRECT));
            D3DFree((LPVOID)pDevI->m_clrRects);
            pDevI->m_clrRects = newRects;
        }
        else
        {
            pDevI->m_clrCount = 0;
            D3DFree((LPVOID)pDevI->m_clrRects);
            pDevI->m_clrRects = NULL;
            D3D_ERR("failed to allocate space for rects");
            throw E_OUTOFMEMORY;
        }
    }
    pDevI->m_clrCount = dwCount;

    // If nothing is specified, assume the viewport needs to be cleared
    if (!rects)
    {
        pDevI->m_clrRects[0].x1 = pDevI->m_Viewport.X;
        pDevI->m_clrRects[0].y1 = pDevI->m_Viewport.Y;
        pDevI->m_clrRects[0].x2 = pDevI->m_Viewport.X + pDevI->m_Viewport.Width;
        pDevI->m_clrRects[0].y2 = pDevI->m_Viewport.Y + pDevI->m_Viewport.Height;
        return 1;
    }
    else
    {
        vwport.left   = pDevI->m_Viewport.X;
        vwport.top    = pDevI->m_Viewport.Y;
        vwport.right  = pDevI->m_Viewport.X + pDevI->m_Viewport.Width;
        vwport.bottom = pDevI->m_Viewport.Y + pDevI->m_Viewport.Height;

        j=0;
        for (i = 0; i < dwCount; i++)
        {
            if (IntersectRect((LPRECT)(pDevI->m_clrRects + j), &vwport, (LPRECT)(rects + i)))
                j++;
        }
        return j;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::ClearI"

void
CD3DHal::ClearI(DWORD dwCount,
                 CONST D3DRECT* rects,
                 DWORD dwFlags,
                 D3DCOLOR dwColor,
                 D3DVALUE dvZ,
                 DWORD dwStencil)
{
    dwCount = ProcessRects(this, dwCount, rects);
    // Device should never receive 0 count, because for Pure device this
    // means "clear whole viewport"
    if (dwCount != 0)
    {
        // Call DDI specific Clear routine
        m_pDDI->Clear(dwFlags, dwCount, m_clrRects, dwColor, dvZ, dwStencil);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\d3dpr.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dpr.h
 *  Content:    Direct3D private include file
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *   23/11/95   colinmc Made various Direct3D interfaces queryable off
 *                      DirectDraw.
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *   17/04/96   colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef _D3DPR_H_
#define _D3DPR_H_
#include "d3di.hpp"
#include "dpf.h"

#if 0
extern "C" {
#define this _this
#include "ddrawpr.h"
#undef this
};
#endif

/*
 * Macros for validating parameters.
 * Only implement those not available in ddrawpr.h.
 */

#define VALID_OUTPTR(x) ((x) && VALID_PTR_PTR(x))

// FAST_CHECKING macro is defined in ddrawpr.h
// so in make sure that ddrawpr.h is always included
// before this header.

#ifndef FAST_CHECKING

#define VALID_DIRECT3DBASETEXTURE8_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( LPVOID )))
#define VALID_DDSURF_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWSURFACE_INT )))
#define VALID_DIRECT3DVERTEXBUFFER_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( CDirect3DVertexBuffer )))

#define VALID_D3DVERTEXBUFFERDESC_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DVERTEXBUFFERDESC8 ) ))
#define VALID_D3DCAPS8_PTR( ptr ) \
    (! IsBadWritePtr(ptr, sizeof( D3DCAPS8)) )
#define VALID_D3DRECT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DRECT ) ))
#define VALID_GDIRECT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( RECT ) ))
#define VALID_GDIPOINT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( POINT ) ))
#define VALID_D3DTEXTUREHANDLE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DTEXTUREHANDLE ) ) )
#define VALID_D3DDEVINFOSTRUCT_PTR( ptr, size ) \
    (!IsBadWritePtr( ptr, size ) )

// Note: these macros are replacements for the VALID_DIRECTDRAWSURFACE_PTR ddraw macros
// because those macros need access to the ddCallbacks ddraw globals.
// At some point these could be replaced with a ddraw exported fn that actually
// verifies the callback table type

#define VALID_D3D_DIRECTDRAWSURFACE8_PTR(ptr) (!IsBadWritePtr(ptr, sizeof(VOID*)))

#else /* !FAST_CHECKING */

#define VALID_DIRECT3DBASETEXTURE8_PTR( ptr ) (ptr)
#define VALID_DIRECT3DDEVICE_PTR( ptr ) (ptr)
#define VALID_DDSURF_PTR( ptr ) (ptr)
#define VALID_DIRECT3DVERTEXBUFFER_PTR( ptr ) (ptr)

#define VALID_D3DVERTEXBUFFERDESC_PTR( ptr ) (ptr)
#define VALID_D3DCAPS8_PTR( ptr ) (ptr)
#define VALID_D3DRECT_PTR( ptr ) (ptr)
#define VALID_GDIRECT_PTR( ptr ) (ptr)
#define VALID_GDIPOINT_PTR( ptr ) (ptr)
#define VALID_D3DTEXTUREHANDLE_PTR( ptr ) (ptr)

#define VALID_D3D_DIRECTDRAWSURFACE8_PTR(ptr) (ptr)
#define VALID_D3DDEVINFOSTRUCT_PTR( ptr, size ) (ptr)

#endif /* !FAST_CHECKING */


#endif /* _D3DPR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\d3dbase.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dbase.cpp
 *  Content:    Direct3D base device implementation
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
/*
 * Create an api for the Direct3DDevice object
 */
extern "C" {
#define this _this
#include "ddrawpr.h"
#undef this
}
#include "drawprim.hpp"
#include "vvm.h"
#include "ddi.h"

#if defined(PROFILE4)
#include <icecap.h>
#elif defined(PROFILE)
#include <icapexp.h>
#endif

// Remove DDraw's type unsafe definition and replace with our C++ friendly def
#ifdef VALIDEX_CODE_PTR
#undef VALIDEX_CODE_PTR
#endif
#define VALIDEX_CODE_PTR(ptr) \
(!IsBadCodePtr((FARPROC) ptr))

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice"

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DBase                                                                //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
CD3DBase::CD3DBase()
{
    // Shaders are not re-created inside Init()
    m_pVShaderArray = NULL;
    m_pPShaderArray = NULL;

    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // DO NOT PUT INITIALIZATION IN THE CONSTRUCTOR.
    // Put it in Init() instead. This is because the device can be
    // "Destroy()ed" and "Init()ed" anytime via Reset. In this
    // situation, the constructor is never called. (snene 01/00)
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    m_qwBatch = 1; // this is ok to put here because we DONT WANT
                   // it to be reinitialized upon Reset() (snene 02/00)

#ifdef FAST_PATH
    m_pOrigVtbl = 0; // This is ok to put here since we DONT want it to
                     // be touched at Destroy()
#endif

#if DBG
    // Enable/disable state of debug monitor should be independent
    // of Init()/Destroy() calls, so initialization belongs here.
    m_bDbgMonConnectionEnabled = TRUE;
#endif //DBG

}
//---------------------------------------------------------------------
HRESULT CD3DBase::ResetShaders()
{
    try
    {
        // Re-create vertex shaders for after DX8.0 apps only
        UINT size = m_pVShaderArray->GetSize();
        for (UINT i=0; i < size; i++)
        {
            UINT Handle = m_pVShaderArray->HandleFromIndex(i);
            CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(Handle);
            if (pShader)
            {
                if (Enum()->GetAppSdkVersion() != D3D_SDK_VERSION_DX8)
                {
                    CreateVertexShaderI(pShader->m_pOrgDeclaration,
                                        pShader->m_OrgDeclSize,
                                        pShader->m_pOrgFuncCode,
                                        pShader->m_OrgFuncCodeSize, 
                                        Handle);
                }
            }
        }
        
        // Re-create pixel shaders for after DX8.0 apps only
        size = m_pPShaderArray->GetSize();
        for (i=0; i < size; i++)
        {
            UINT Handle = m_pPShaderArray->HandleFromIndex(i);
            CPShader* pShader = (CPShader*)m_pPShaderArray->GetObject(Handle);
            if (pShader)
            {
                if (Enum()->GetAppSdkVersion() != D3D_SDK_VERSION_DX8)
                {
                    m_pDDI->CreatePixelShader(pShader->m_pCode, 
                                              pShader->m_dwCodeSize, Handle);
                }
            }
        }
    }
    catch(HRESULT ret)
    {
        DPF_ERR("There was some error when resetting shaders");
        return ret;
    }
    return S_OK;
}
//---------------------------------------------------------------------

CD3DBase::~CD3DBase()
{
    // Destroy() is called during Reset() and we do not want to delete
    // shaders there

    try
    {
        delete m_pPShaderArray;
        m_pPShaderArray = NULL;
        delete m_pVShaderArray;
        m_pVShaderArray = NULL;
    }
    catch(HRESULT ret)
    {
        DPF_ERR("There was some error when destroying device");
    }

    Destroy();
}

//---------------------------------------------------------------------
// This function can be called TWICE, so it is ESSENTIAL that all
// pointers be NULLED out and pointer dereferences be protected.
// This function is capable of cleaning up partial initialization.
void
CD3DBase::Destroy()
{
    try // Since Destroy() can be called directly by fw
    {
        // The DDI layer is about to be be deleted; so
        // we need to make sure that if Sync is called for
        // any object, we don't try to use the DDI.
        //
        // So we increment our sync counter
        // CONSIDER: should we NULL m_pDDI instead and check
        // for that in various places?
        DDASSERT(m_qwBatch > 0);
        m_qwBatch++;

        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // MUST CLEANUP AND RELEASE CURRENTLY SET TEXTURES BEFORE
        // DOING ANY OTHER WORK, else we will get into situations
        // where we are calling FlushStates or batching DDI tokens.
        CleanupTextures();
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        delete m_pCreatedLights;
        m_pCreatedLights = NULL;

        // Delete state sets
        if (0 != m_pStateSets)
        {
            delete m_pStateSets;
            m_pStateSets = 0;
        }

#if DBG
        delete m_pRTPatchValidationInfo;
        m_pRTPatchValidationInfo = NULL;
#endif

        delete m_pPaletteArray;
        m_pPaletteArray = NULL;

        delete [] m_pStream;
        m_pStream = NULL; // Must NULL out
        delete m_pIndexStream;
        m_pIndexStream = NULL; // Must NULL out

        // NOTE: we must free the DDI last; because releasing Driver
        // allocated VBs causes an intrinsic call to Unlock through
        // the DDI.

        delete m_pDDI;
        m_pDDI = NULL; // Must NULL out

    #if DBG
        if (m_pDbgMon) delete m_pDbgMon; m_pDbgMon = NULL;
        m_pDbgMonBase = NULL;   // this memory is not owned by this pointer
    #endif //DBG
    }
    catch(HRESULT ret)
    {
        DPF_ERR("There was some error when Reset()ing the device; as a result some resources may not be freed.");
    }
}
//---------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CleanupTextures"

void __declspec(nothrow) CD3DBase::CleanupTextures()
{
    if(GetDDIType() < D3DDDITYPE_DX8)
    {
        // We need to unset currently set textures on DX8 drives since we have
        // seen these drivers do bad things when the TextureDestroy DDI is called.
        BOOL bNeedFlush = FALSE;
        for (DWORD dwStage = 0; dwStage < m_dwMaxTextureBlendStages; dwStage++)
        {
            if(m_dwDDITexHandle[dwStage] != 0)
            {
                try
                {
                    m_pDDI->SetTSS(dwStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, 0);
                }
                catch(HRESULT ret)
                {
                }
                m_dwDDITexHandle[dwStage] = 0;
                bNeedFlush = TRUE;
            }
        }
        // Since flush-states (or any command stream thing) can throw
        // we need to catch an error (so we can cleanup
        // properly.) This flush here is a best-effort
        // attempt for old-drivers; we don't want new drivers to rely on
        // it since it can fail for lots of reasons.
        try
        {
            if(bNeedFlush)
            {
                m_pDDI->FlushStates();
            }
        }
        catch(HRESULT ret)
        {
        }
    }

    /*
     * We need to do this backwards because we cannot have a texture bound to
     * stage i + 1 when there is a texture bound to stage i.
     */
    for (int i = D3DHAL_TSS_MAXSTAGES - 1; i >= 0; --i)
    {
        if (m_lpD3DMappedTexI[i])
        {
            m_lpD3DMappedTexI[i]->DecrementUseCount();
            m_lpD3DMappedTexI[i] = NULL; // Must NULL out
        }
    }

}
//---------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "CD3DBase::Init"

HRESULT __declspec(nothrow)
CD3DBase::Init()
{
    HRESULT ret = S_OK;

    //
    // FE's Init
    //
    ret = InitDevice();
    if (ret!=D3D_OK)
    {
        D3D_ERR("Failed to initialize D3DDevice");
        Destroy();
        return ret;
    }

    //
    // Initialize states
    //
    try
    {
        StateInitialize(ZBuffer() != 0);
    }
    catch (HRESULT ret)
    {
        D3D_ERR("Failed to initialize device state");
        Destroy();
        return ret;
    }
    return ret;
}

//------------------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "CD3DBase::InitDevice"

HRESULT
CD3DBase::InitDevice()
{
    HRESULT               ret = D3D_OK;
    HKEY                  hKey = (HKEY) NULL;

    m_dwRuntimeFlags = 0;
    m_dwHintFlags = 0;
    m_pDDI = NULL;
    m_dwMaxTextureBlendStages = 0;
    m_dwStageDirty = 0;
    m_dwStreamDirty = 0;
    m_pStateSets = NULL;

    m_dwCurrentShaderHandle = 0;
    m_dwCurrentPixelShaderHandle = 0;
    m_dwNumStreams = 0;
    m_dwMaxUserClipPlanes = 0;
    m_pStream = NULL;
    m_pIndexStream = NULL;
    m_dwPalette = __INVALIDPALETTE;
    m_pPaletteArray = NULL;
#if DBG
    m_pRTPatchValidationInfo = NULL;
    m_SceneStamp = 0;
#endif
    m_pCreatedLights = NULL;

    m_pCreatedLights = new CPackedBitArray;
    if( m_pCreatedLights == NULL )
    {
        D3D_ERR("Could not allocate internal light array m_pCreatedLights");
        return E_OUTOFMEMORY;
    }

    if (FAILED(m_pCreatedLights->Init(64)))
    {
        D3D_ERR("Could not allocate internal bit vector for m_pCreatedLights");
        return E_OUTOFMEMORY;
    }
    if (m_pVShaderArray == NULL)
        m_pVShaderArray = new CVShaderHandleFactory;
    if (m_pVShaderArray == NULL)
    {
        D3D_ERR("Could not allocate internal handle factory m_pVShaderArray");
        return E_OUTOFMEMORY;
    }
    // Allocate the zero'th handle. We use the handle as a flag that no
    // shader set.
    if (__INVALIDHANDLE == m_pVShaderArray->CreateNewHandle(NULL))
    {
        D3D_ERR("Vertex shader Zero'th handle allocation failed");
        return E_OUTOFMEMORY;
    }

    if (m_pPShaderArray == NULL)
        m_pPShaderArray = new CHandleFactory;
    if (m_pPShaderArray == NULL)
    {
        D3D_ERR("Could not allocate internal handle factory m_pPShaderArray");
        return E_OUTOFMEMORY;
    }
    // Allocate the zero'th handle. We use the handle as a flag that no
    // shader set.
    if (__INVALIDHANDLE == m_pPShaderArray->CreateNewHandle(NULL))
    {
        D3D_ERR("Pixel shader Zero'th handle allocation failed");
        return E_OUTOFMEMORY;
    }

    m_pPaletteArray = new CHandleArray;
    if (m_pPaletteArray == NULL)
    {
        D3D_ERR("Could not allocate internal handle array m_pPaletteArray");
        return E_OUTOFMEMORY;
    }

#if DBG
    m_pRTPatchValidationInfo = new CHandleArray;
    if (m_pRTPatchValidationInfo == NULL)
    {
        D3D_ERR("Could not allocate internal handle array m_pRTPatchValidationInfo");
        return E_OUTOFMEMORY;
    }
#endif

    m_MaxVertexShaderConst = GetD3DCaps()->MaxVertexShaderConst;

    DWORD value;
    if ((GetD3DRegValue(REG_DWORD, "DisableNVPS", &value, 4) &&
        value != 0))
    {
        m_dwRuntimeFlags |= D3DRT_DISALLOWNVPSHADERS;
    }

    // Figure out the DDI type of the underlying driver

    //---------------------------------------------------------------------
    // HKEY_LOCAL_MACHINE\Software\Microsoft\Direct3D\DriverStyle
    // In DX7 this registry key replaces the host of keys we had before like
    // DisableDP, DisableDP2 etc. This stuff is for testing purpose only.
    // It is more like a hint, in that, if the requested driver type is
    // available, it is used otherwise the latest available driver is used
    // The following is the meanings for this dword:
    //
    // Value:                    Driver-type:
    //       0x0                           Latest available
    //       0x3                           (DX6)
    //       0x4                           (DX7)
    //       0x5                           (DX7+TL)
    //       0x6                           (DX8)
    //       0x7                           (DX8+TL)
    //
    // The following are the various cases we need to consider:
    // 1) NT Hardware: 4 and above are legal
    // 2) W9x Hardware: 3 and above are legal
    // 3) Reference: 4 and above
    //---------------------------------------------------------------------

    WORD wDriverCaps = 0;
    D3DDDITYPE LatestDDI = D3DDDITYPE_NULL;
    //
    // 1) Determine what styles of DDIs the driver is capable of
    //

    // DX6 ?
    if (GetHalCallbacks()->DrawPrimitives2 != 0)
    {
        wDriverCaps |= (1 << D3DDDITYPE_DX6);
        LatestDDI = D3DDDITYPE_DX6;
    }

    // DX7 ?
    if ((wDriverCaps & (1 << D3DDDITYPE_DX6)) &&
        (GetHalCallbacks()->GetDriverState != 0))
    {
        wDriverCaps |= (1 << D3DDDITYPE_DX7);
        LatestDDI = D3DDDITYPE_DX7;
    }

    // DX7&TL ?
    if ((wDriverCaps & (1 << D3DDDITYPE_DX7)) &&
        (GetD3DCaps()->DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT))
    {
        wDriverCaps |= (1 << D3DDDITYPE_DX7TL);
        LatestDDI = D3DDDITYPE_DX7TL;
    }

    // DX8 ?
    if ((wDriverCaps & (1 << D3DDDITYPE_DX7)) &&
        (GetD3DCaps()->MaxStreams != 0))
    {
        wDriverCaps |= (1 << D3DDDITYPE_DX8);
        LatestDDI = D3DDDITYPE_DX8;
    }

    // DX8&TL ?
    if ((wDriverCaps & (1 << D3DDDITYPE_DX8)) &&
         (GetD3DCaps()->DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT))
    {
        wDriverCaps |= (1 << D3DDDITYPE_DX8TL);
        LatestDDI = D3DDDITYPE_DX8TL;
    }

    //
    // 2) Verify if the requested driver is supported
    //
    if (wDriverCaps == 0)
    {
        m_ddiType = D3DDDITYPE_NULL;   // nothing supported so fail
    }
    else
    {
        // use the latest available if not specified or
        // incorrectly specified or specified but not available
        m_ddiType = LatestDDI;
    }
    D3D_INFO(1,"HalDevice Driver Style %x", GetDDIType());

    // Pure device is available only for DX8+ drivers only (check for cap)
    if ( (BehaviorFlags() & D3DCREATE_PUREDEVICE) &&
         !(GetD3DCaps()->DevCaps & D3DDEVCAPS_PUREDEVICE) )
    {
        DPF_ERR("No PUREDEVICE support available on this driver");
        return E_NOTIMPL;
    }

#ifdef _IA64_
    if (GetDDIType() < D3DDDITYPE_DX8)
    {
        D3D_ERR( "Pre-DX8 drivers are not supported in IA64" );
        return E_FAIL;
    }
#endif // _IA64_

    // Now create the DDI object
    // Note: If m_dwDriverStyle == 0x0 here, driver creation will fail
    // Something must have been chosen by now
    switch (GetDDIType())
    {
    case D3DDDITYPE_DX6:
        m_pDDI = new CD3DDDIDX6();
        break;
    case D3DDDITYPE_DX7:
        m_pDDI = new CD3DDDIDX7();
        break;
    case D3DDDITYPE_DX7TL:
        m_pDDI = new CD3DDDITL();
        break;
    case D3DDDITYPE_DX8:
        m_pDDI = new CD3DDDIDX8();
        break;
    case D3DDDITYPE_DX8TL:
        m_pDDI = new CD3DDDIDX8TL();
        break;
    default:
        D3D_ERR("The currently requested/installed driver is not supported.");
        // Change this return value ?
        return (E_OUTOFMEMORY);
    }

    if( m_pDDI == NULL )
    {
        D3D_ERR( "Could not allocate internal driver interface object" );
        return E_OUTOFMEMORY;
    }

    // Now try to initialize the ddi object
    try
    {
        m_pDDI->Init(this);
        m_pfnDrawPrim = m_pDDI->GetDrawPrimFunction();
        m_pfnDrawIndexedPrim = m_pDDI->GetDrawIndexedPrimFunction();
        m_pfnDrawPrimFromNPatch = m_pDDI->GetDrawPrimFunction();
        m_pfnDrawIndexedPrimFromNPatch = m_pDDI->GetDrawIndexedPrimFunction();
    }
    catch(HRESULT hr)
    {
        return hr;
    }

#if DBG
    // Initialize debug monitor
    m_pDbgMon = NULL;
    m_pDbgMonBase = NULL;
    if ( !(BehaviorFlags() & D3DCREATE_INTERNALTEMPDEVICE))
    {
        if ( GetDeviceType() == D3DDEVTYPE_REF )
        {
            ULONG_PTR dwhDeviceContext = m_pDDI->GetDeviceContext();
            HINSTANCE hLibrary = GetDeviceData()->hLibrary;
            typedef HRESULT (WINAPI FNCreateDM)( ULONG_PTR dwContext, BOOL bDbgMonConnectionEnabled, D3DDebugMonitor** ppDbgMon );
            FNCreateDM* pfnCreateDM = (FNCreateDM*)GetProcAddress(hLibrary, "D3D8CreateDebugMonitor");
            if (NULL != pfnCreateDM)
            {
                if ( (*pfnCreateDM)( dwhDeviceContext, m_bDbgMonConnectionEnabled, &m_pDbgMonBase ) != S_OK )
                {
                    D3D_ERR("Could not initialize debug monitor for D3DDEVTYPE_REF");
                    m_pDbgMonBase = NULL;
                }
            }
        }
        else if ( ( GetDeviceType() == D3DDEVTYPE_HAL) &&
                  ( BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING ) )
        {
            m_pDbgMon = new RTDebugMonitor( this, m_bDbgMonConnectionEnabled );
            if ( m_pDbgMon == NULL )
            {
                D3D_ERR(" debug monitor object allocation failed ");
                return E_OUTOFMEMORY;
            }
            m_pDbgMonBase = (D3DDebugMonitor*)m_pDbgMon;

            m_pDbgMon->AttachToMonitor(1);
        }
    }
#endif

    // Initialize some caps for the Software Vertex Processing
    m_dwNumStreams = max(1, GetD3DCaps()->MaxStreams);
    m_dwMaxUserClipPlanes = GetD3DCaps()->MaxUserClipPlanes;

#ifdef _X86_
    if (!(BehaviorFlags() & D3DCREATE_FPU_PRESERVE))
    {
        m_dwHintFlags |= D3DDEVBOOL_HINTFLAGS_FPUSETUP;
        WORD wSave, wTemp;
        __asm {
            fstcw wSave
            mov ax, wSave
            and ax, not 300h    ;; single mode
            or  ax, 3fh         ;; disable all exceptions
            and ax, not 0C00h   ;; round to nearest mode
            mov wTemp, ax
            fldcw   wTemp
        }
    }
#endif

#ifdef FAST_PATH
    if(m_pOrigVtbl == 0)
    {
        m_pOrigVtbl = *((VOID***)this);
        memcpy(m_pVtbl, m_pOrigVtbl, sizeof(VOID*) * NUMVTBLENTRIES);
        *((VOID***)this) = m_pVtbl;
    }

    FastPathSetRenderStateExecute();
    FastPathSetTextureStageStateExecute();
    FastPathApplyStateBlockExecute();
    FastPathSetTextureExecute();
    FastPathSetMaterialExecute();
    FastPathSetVertexShaderFast();
    FastPathSetStreamSourceFast();
    FastPathSetIndicesFast();
    FastPathSetTransformExecute();
    FastPathMultiplyTransformExecute();
    FastPathSetPixelShaderExecute();
    FastPathSetPixelShaderConstantExecute();
    FastPathSetVertexShaderConstantExecute();
#endif

    // Setup the viewport
    D3DSURFACE_DESC d3ddesc = RenderTarget()->InternalGetDesc();
    D3DVIEWPORT8 Viewport;
    Viewport.X = 0;
    Viewport.Y = 0;
    Viewport.Width  = d3ddesc.Width;
    Viewport.Height = d3ddesc.Height;
    Viewport.MinZ = (D3DVALUE)0;
    Viewport.MaxZ = (D3DVALUE)1;
    if (FAILED(ret = this->SetViewport(&Viewport)))
    {
        return ret;
    }

    m_pStream = new CVStream[__NUMSTREAMS];
    if( m_pStream == NULL )
    {
        return E_OUTOFMEMORY;
    }

    for (UINT i=0; i < __NUMSTREAMS; i++)
    {
        m_pStream[i].m_dwIndex = i;
    }
    m_pIndexStream = new CVIndexStream;
    if( m_pIndexStream == NULL )
    {
        return E_OUTOFMEMORY;
    }

    //
    // Initialize the caps
    //
    const D3DCAPS8 *pCaps = GetD3DCaps();
    DDASSERT( pCaps );

    if (pCaps && pCaps->FVFCaps)
    {
        m_dwMaxTextureBlendStages = pCaps->MaxTextureBlendStages;
    }

    // Setup Statesets
    m_pStateSets = new CStateSets;
    if (m_pStateSets == NULL)
    {
        return E_OUTOFMEMORY;
    }
    m_pStateSets->Init(this);

#if defined(PROFILE4) || defined(PROFILE)
    m_dwProfStart = m_dwProfStop = 0;
    GetD3DRegValue(REG_DWORD, "ProfileStartFrame", &m_dwProfStart, 4);
    GetD3DRegValue(REG_DWORD, "ProfileStopFrame", &m_dwProfStop, 4);
#endif

    return D3D_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::TextureManagerDiscardBytes"

HRESULT D3DAPI
CD3DBase::ResourceManagerDiscardBytes(DWORD cbBytes)
{
    API_ENTER(this);

    // For driver-management we pass the number of
    // bytes needed down through this renderstate. For DX7
    // we passed the value "1" which mean EvictAll. Now
    // if the app specifices 0 for cbBytes, that means EvictAll.
    // So this should make it easy for drivers to support both
    // dx7 and dx8+ uses of this renderstate.
    if (CanDriverManageResource())
    {
        try
        {
            m_pDDI->SetRenderState((D3DRENDERSTATETYPE)D3DRENDERSTATE_EVICTMANAGEDTEXTURES,
                                   cbBytes + 1);
            m_pDDI->FlushStates();
        }
        catch (HRESULT ret)
        {
            DPF_ERR("ResourceManagerDiscardBytes failed.");
            return ret;
        }
    }
    else
    {
        ResourceManager()->DiscardBytes(cbBytes);
    }

    return D3D_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::ValidateDevice"

HRESULT D3DAPI
CD3DBase::ValidateDevice(LPDWORD lpdwNumPasses)
{
    API_ENTER(this); // Takes D3D Lock if necessary
#if DBG
    // Validate Parameters
    if (!VALID_WRITEPTR(lpdwNumPasses, sizeof(DWORD)))
    {
        D3D_ERR("Invalid NumPasses pointer passed. ValidateDevice failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    try
    {
        m_pDDI->ValidateDevice(lpdwNumPasses);
    }
    catch(HRESULT hr)
    {
        D3D_INFO(0, "ValidateDevice failed.");
        return hr;
    }

    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::BeginScene"

HRESULT D3DAPI
CD3DBase::BeginScene()
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if defined(PROFILE4) || defined(PROFILE)
    static DWORD dwFrameCount = 0;
#endif
    DebugEvent(D3DDM_EVENT_BEGINSCENE);
    try
    {
        if (m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)
        {
            D3D_ERR("BeginScene, already in scene. BeginScene failed.");
            return (D3DERR_INVALIDCALL);
        }

        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            D3D_ERR("Cannot be recording state macros when calling BeginScene. BeginScene failed.");
            throw (D3DERR_INVALIDCALL);
        }

        m_pDDI->BeginScene();

#if defined(PROFILE4)
        if (++dwFrameCount == m_dwProfStart)
        {
            OutputDebugString("Direct3D IM 8.0: Started Profiling...\n");
            StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
        }
        else if (dwFrameCount == m_dwProfStop)
        {
            StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
            OutputDebugString("Direct3D IM 8.0: Stopped Profiling.\n");
        }
#elif defined(PROFILE)
        if (++dwFrameCount == m_dwProfStart)
        {
            OutputDebugString("Direct3D IM 8.0: Started Profiling...\n");
            StartCAP();
        }
        else if (dwFrameCount == m_dwProfStop)
        {
            StopCAP();
            OutputDebugString("Direct3D IM 8.0: Stopped Profiling.\n");
        }
#endif

        // So that currently bound textures get scene stamped
        m_dwStageDirty = (1ul << m_dwMaxTextureBlendStages) - 1ul;
        m_dwStreamDirty = (((1ul << m_dwNumStreams) - 1ul) | (1 << __NUMSTREAMS));
        m_dwRuntimeFlags |= (D3DRT_NEED_TEXTURE_UPDATE | D3DRT_NEED_VB_UPDATE);
        m_dwHintFlags |= D3DDEVBOOL_HINTFLAGS_INSCENE;
        return (D3D_OK);
    }
    catch (HRESULT ret)
    {
        DPF_ERR("BeginScene failed.");
        return ret;
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::EndScene"

HRESULT D3DAPI
CD3DBase::EndScene()
{
    API_ENTER(this); // Takes D3D Lock if necessary

    DebugEvent(D3DDM_EVENT_ENDSCENE);

    try
    {
        if (!(m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE))
        {
            D3D_ERR("EndScene, not in scene. EndScene failed.");
            return (D3DERR_INVALIDCALL);
        }

        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            D3D_ERR("Cannot be recording state macros when calling EndScene. EndScene failed.");
            throw (D3DERR_INVALIDCALL);
        }

        m_dwHintFlags &= ~D3DDEVBOOL_HINTFLAGS_INSCENE;

        m_pDDI->EndScene();

        // Update the scene count in texman
        ResourceManager()->SceneStamp();

#if DBG
        ++m_SceneStamp;
#endif

        return (D3D_OK);
    }
    catch (HRESULT ret)
    {
        DPF_ERR("EndScene failed.");
        return ret;
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::MultiplyTransformI"

void
CD3DBase::MultiplyTransformI(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat)
{
    m_pDDI->MultiplyTransform(state, lpMat);
}
#ifdef FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::MultiplyTransformFast"

HRESULT D3DAPI
CD3DBase::MultiplyTransformFast(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat)
{
#if DBG
    if (!VALID_PTR(lpMat, sizeof(D3DMATRIX)))
    {
        D3D_ERR("Invalid matrix pointer. MultiplyTransform failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < __WORLDMATRIXBASE + __MAXWORLDMATRICES)
    {
    }
    else
    switch (state)
    {
    case D3DTS_VIEW :
    case D3DTS_PROJECTION :
    case D3DTS_TEXTURE0:
    case D3DTS_TEXTURE1:
    case D3DTS_TEXTURE2:
    case D3DTS_TEXTURE3:
    case D3DTS_TEXTURE4:
    case D3DTS_TEXTURE5:
    case D3DTS_TEXTURE6:
    case D3DTS_TEXTURE7:
        break;
    default :
        D3D_ERR("Invalid state value passed to MultiplyTransform. MultiplyTransform failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    DXGASSERT((m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE) == 0 &&
              (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0 &&
              (BehaviorFlags() & D3DCREATE_PUREDEVICE) != 0);
    try
    {
        m_pDDI->MultiplyTransform(state, lpMat);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("MultiplyTransform failed.");
        return ret;
    }

    return D3D_OK;
}
#endif
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::MultiplyTransform"

HRESULT D3DAPI
CD3DBase::MultiplyTransform(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat)
{
    API_ENTER(this);
#if DBG
    if (!VALID_PTR(lpMat, sizeof(D3DMATRIX)))
    {
        D3D_ERR("Invalid matrix pointer. MultiplyTransform failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < __WORLDMATRIXBASE + __MAXWORLDMATRICES)
    {
    }
    else
    switch (state)
    {
    case D3DTS_VIEW :
    case D3DTS_PROJECTION :
    case D3DTS_TEXTURE0:
    case D3DTS_TEXTURE1:
    case D3DTS_TEXTURE2:
    case D3DTS_TEXTURE3:
    case D3DTS_TEXTURE4:
    case D3DTS_TEXTURE5:
    case D3DTS_TEXTURE6:
    case D3DTS_TEXTURE7:
        break;
    default :
        D3D_ERR("Invalid state value passed to MultiplyTransform. MultiplyTransform failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        MultiplyTransformI(state, lpMat);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("MultiplyTransform failed.");
        return ret;
    }
    return D3D_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTransformI"

void CD3DBase::SetTransformI(D3DTRANSFORMSTATETYPE state,
                             CONST D3DMATRIX* lpMat)
{
    if( state == D3DTS_PROJECTION )
        m_pDDI->UpdateWInfo( lpMat );
    m_pDDI->SetTransform(state, lpMat);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTransform"

HRESULT D3DAPI
CD3DBase::SetTransform(D3DTRANSFORMSTATETYPE state,
                       CONST D3DMATRIX* lpMat)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!VALID_PTR(lpMat, sizeof(D3DMATRIX)))
    {
        D3D_ERR("Invalid matrix pointer. SetTransform failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < __WORLDMATRIXBASE + __MAXWORLDMATRICES)
    {
    }
    else
    switch (state)
    {
    case D3DTS_VIEW :
    case D3DTS_PROJECTION :
    case D3DTS_TEXTURE0:
    case D3DTS_TEXTURE1:
    case D3DTS_TEXTURE2:
    case D3DTS_TEXTURE3:
    case D3DTS_TEXTURE4:
    case D3DTS_TEXTURE5:
    case D3DTS_TEXTURE6:
    case D3DTS_TEXTURE7:
        break;
    default :
        D3D_ERR("Invalid state value passed to SetTransform. SetTransform failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertTransform(state, lpMat);
        else
            SetTransformI(state, lpMat);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetTransform failed.");
        return ret;
    }
    return D3D_OK;
}
#ifdef FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTransformFast"

HRESULT D3DAPI
CD3DBase::SetTransformFast(D3DTRANSFORMSTATETYPE state,
                           CONST D3DMATRIX* lpMat)
{
#if DBG
    if (!VALID_PTR(lpMat, sizeof(D3DMATRIX)))
    {
        D3D_ERR("Invalid matrix pointer. SetTransform failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < __WORLDMATRIXBASE + __MAXWORLDMATRICES)
    {
    }
    else
    switch (state)
    {
    case D3DTS_VIEW :
    case D3DTS_PROJECTION :
    case D3DTS_TEXTURE0:
    case D3DTS_TEXTURE1:
    case D3DTS_TEXTURE2:
    case D3DTS_TEXTURE3:
    case D3DTS_TEXTURE4:
    case D3DTS_TEXTURE5:
    case D3DTS_TEXTURE6:
    case D3DTS_TEXTURE7:
        break;
    default :
        D3D_ERR("Invalid state value passed to SetTransform. SetTransform failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    DXGASSERT((m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE) == 0 &&
              (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0 &&
              (BehaviorFlags() & D3DCREATE_PUREDEVICE) != 0);
    try
    {
        m_pDDI->SetTransform(state, lpMat);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetTransform failed.");
        return ret;
    }
    return S_OK;
}
#endif // FAST_PATH
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetRenderTarget"

HRESULT D3DAPI
CD3DBase::SetRenderTarget(IDirect3DSurface8 *pRenderTarget,
                          IDirect3DSurface8 *pZStencil)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        CBaseSurface *pTarget;
        CBaseSurface *pZ;

        if (pRenderTarget != NULL)
        {
            if (!VALID_D3D_DIRECTDRAWSURFACE8_PTR(pRenderTarget))
            {
                D3D_ERR("Invalid IDirect3DSurface8 pointer passed for RenderTarget. SetRenderTarget failed.");
                return D3DERR_INVALIDCALL;
            }
            pTarget = static_cast<CBaseSurface*>(pRenderTarget);
            if (pTarget->InternalGetDevice() != this)
            {
                D3D_ERR("Render Target wasn't created with this Device. SetRenderTarget fails");
                return D3DERR_INVALIDCALL;
            }

            D3DSURFACE_DESC desc = pTarget->InternalGetDesc();

            if ((desc.Usage & D3DUSAGE_RENDERTARGET) == 0)
            {
                D3D_ERR("**** The D3DUSAGE_RENDERTARGET is not set on this surface.");
                D3D_ERR("**** You need to add D3DUSAGE_RENDERTARGET to the Usage parameter");
                D3D_ERR("**** when creating the surface. SetRenderTarget failed.");
                return (D3DERR_INVALIDCALL);
            }

        }
        else
        {
            pTarget = RenderTarget();
        }

        if (pZStencil != NULL)
        {
            if (!VALID_D3D_DIRECTDRAWSURFACE8_PTR(pZStencil))
            {
                D3D_ERR("Invalid IDirect3DSurface8 pointer passed for ZStencil.  SetRenderTarget failed.");
                return D3DERR_INVALIDCALL;
            }
            pZ = static_cast<CBaseSurface*>(pZStencil);
            if (pZ->InternalGetDevice() != this)
            {
                D3D_ERR("Zbuffer wasn't created with this Device. SetRenderTarget fails");
                return D3DERR_INVALIDCALL;
            }

            // We call the external interface because
            // we need to get the Z format that the user
            // specified NOT our internal mapping.
            D3DSURFACE_DESC descZ;
            pZ->GetDesc(&descZ);

            if ((descZ.Usage & D3DUSAGE_DEPTHSTENCIL) == 0)
            {
                D3D_ERR("**** The D3DUSAGE_DEPTHSTENCIL is not set on this surface.");
                D3D_ERR("**** You need to add D3DUSAGE_DEPTHSTENCIL to the Usage parameter");
                D3D_ERR("**** when creating the surface. SetRenderTarget failed.");
                return (D3DERR_INVALIDCALL);
            }

            // Check that RT and Z have matching Multi-Sampleness

            DXGASSERT(pTarget != NULL);
            D3DSURFACE_DESC descTarget = pTarget->InternalGetDesc();

            if (descZ.MultiSampleType != descTarget.MultiSampleType)
            {
                DPF_ERR("MultiSampleType between DepthStencil Buffer and RenderTarget must match. SetRenderTarget failed.");
                return D3DERR_INVALIDCALL;
            }

            // Ensure that the ZBuffer that is being set is atleast as big as the RenderTarget
            if ((descZ.Width < descTarget.Width) ||
                (descZ.Height < descTarget.Height))
            {
                DPF_ERR("DepthStencil Buffer must be atleast as big as the RenderTarget. SetRenderTarget failed.");
                return D3DERR_INVALIDCALL;
            }

            // Need to check whether formats are compatible if
            // the format is the lockable D16 or has Stencil
            if (descZ.Format == D3DFMT_D16_LOCKABLE ||
                CPixel::HasStencilBits(descZ.Format))
            {
                HRESULT hr = CheckDepthStencilMatch(descTarget.Format, descZ.Format);
                if (FAILED(hr))
                {
                    DPF_ERR("SetRenderTarget failed; Z Buffer is incompatible with Render Target. See CheckDepthStencilMatch documentation.");
                    if (descZ.Format == D3DFMT_D16_LOCKABLE)
                    {
                        DPF_ERR("If you don't need to lock the z-buffer, then you should use D3DFMT_D16 instead of D3DFMT_D16_LOCKABLE");
                    }

                    return D3DERR_INVALIDCALL;
                }
            }

        }
        else
        {
            pZ = NULL;
        }

        HRESULT hr = SetRenderTargetI(pTarget, pZ);
        if( FAILED(hr) )
        {
            DPF_ERR("SetRenderTargetI failed because the driver failed a command a batch");
            return hr;
        }

        // Set the viewport to default to the whole render-target
        D3DVIEWPORT8 vp;
        D3DSURFACE_DESC desc = pTarget->InternalGetDesc();
        vp.X      = 0;
        vp.Y      = 0;
        vp.Width  = desc.Width;
        vp.Height = desc.Height;
        vp.MinZ   = 0.0f;
        vp.MaxZ   = 1.0f;
        SetViewportI( &vp );
    }
    catch (HRESULT ret)
    {
        DPF_ERR("SetRenderTarget failed.");
        return ret;
    }
    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetRenderTargetI"

HRESULT __declspec(nothrow)
CD3DBase::SetRenderTargetI( CBaseSurface* pTarget,
                            CBaseSurface* pZ )
{
    try
    {
        m_pDDI->SetRenderTarget(pTarget, pZ);
        UpdateRenderTarget(pTarget, pZ);

        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetRenderTarget"

HRESULT D3DAPI
CD3DBase::GetRenderTarget(LPDIRECT3DSURFACE8* lplpDDS)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_OUTPTR(lplpDDS))
    {
        D3D_ERR("Invalid ptr to IDirect3DSurface8*. GetRenderTarget failed.");
        return D3DERR_INVALIDCALL;
    }

    *lplpDDS = this->RenderTarget();

    this->RenderTarget()->AddRef();
    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetZStencilSurface"

HRESULT D3DAPI
CD3DBase::GetDepthStencilSurface(LPDIRECT3DSURFACE8* lplpDDS)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_OUTPTR(lplpDDS))
    {
        D3D_ERR("Invalid ptr to IDirect3DSurface8*. GetDepthStencilSurface failed.");
        return D3DERR_INVALIDCALL;
    }

    *lplpDDS = this->ZBuffer();

    if (*lplpDDS)
    {
        (*lplpDDS)->AddRef();
        return S_OK;
    }
    else
    {
        D3D_INFO(0, "Device doesn't have a Z Buffer.");
        return D3DERR_NOTFOUND;
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetViewport"

HRESULT D3DAPI
CD3DBase::SetViewport(CONST D3DVIEWPORT8* lpData)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_PTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR("Invalid viewport pointer. SetViewport failed.");
        return D3DERR_INVALIDCALL;
    }
    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertViewport(lpData);
        else
            SetViewportI(lpData);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetViewport failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetViewportI"

void CD3DBase::SetViewportI(CONST D3DVIEWPORT8* lpData)
{
#if DBG
    CheckViewport(lpData);
#endif
    m_pDDI->SetViewport(lpData);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetMaterial"

HRESULT D3DAPI
CD3DBase::SetMaterial(CONST D3DMATERIAL8* lpData)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!VALID_PTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR("Invalid D3DMATERIAL pointer. SetMaterial failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertMaterial(lpData);
        else
            this->SetMaterialFast(lpData);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetMaterial failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetMaterialFast"

HRESULT D3DAPI
CD3DBase::SetMaterialFast(CONST D3DMATERIAL8* lpData)
{
#if DBG
    if (!VALID_PTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR("Invalid D3DMATERIAL pointer. SetMaterial failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        m_pDDI->SetMaterial(lpData);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetMaterial failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetLight"

extern void CheckLightParams(CONST D3DLIGHT8* lpData);

HRESULT D3DAPI
CD3DBase::SetLight(DWORD dwLightIndex,
                   CONST D3DLIGHT8* lpData)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_PTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR( "Invalid D3DLIGHT pointer. SetLight failed." );
        return D3DERR_INVALIDCALL;
    }
    try
    {
#if DBG
        CheckLightParams(lpData);
#endif // DBG

        // If new index greater than allocated array - re-allocate the array
        if (dwLightIndex >= m_pCreatedLights->GetSize())
            m_pCreatedLights->Init(dwLightIndex + 32);

        // If the light if not already created, send command to the DDI to
        // create it.
        if (!m_pCreatedLights->IsBitSet(dwLightIndex))
        {
            m_pDDI->CreateLight(dwLightIndex);
            m_pCreatedLights->SetBit(dwLightIndex);

            // If we are in the record mode, we need to create the light object.
            // Otherwise, if we access the light during capture, we will have
            // access violation.
            if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            {
                // Set default value to the light
                D3DLIGHT8 light;
                memset(&light, 0, sizeof(light));
                light.Type = D3DLIGHT_DIRECTIONAL;
                light.Direction.x = D3DVAL(0);
                light.Direction.y = D3DVAL(0);
                light.Direction.z = D3DVAL(1);
                light.Diffuse.r = D3DVAL(1);
                light.Diffuse.g = D3DVAL(1);
                light.Diffuse.b = D3DVAL(1);

                this->SetLightI(dwLightIndex, &light);
            }
        }

        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertLight(dwLightIndex, lpData);
        else
            this->SetLightI(dwLightIndex, lpData);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        D3D_ERR("SetLight failed.");
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetLightI"

void
CD3DBase::SetLightI(DWORD dwLightIndex, CONST D3DLIGHT8* lpData)
{
    m_pDDI->SetLight(dwLightIndex, lpData);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::LightEnableI"

void
CD3DBase::LightEnableI(DWORD dwLightIndex, BOOL bEnable)
{
    m_pDDI->LightEnable(dwLightIndex, bEnable);
}
//---------------------------------------------------------------------
BOOL ValidateRenderState(D3DRENDERSTATETYPE dwState, DWORD value)
{
    if (dwState >= D3D_MAXRENDERSTATES || dwState == 0)
    {
        D3D_ERR("Invalid render state type. SetRenderState failed.");
        return FALSE;
    }
    switch (dwState)
    {
    case D3DRS_POSITIONORDER:
        if (!((value == D3DORDER_LINEAR) || (value == D3DORDER_CUBIC)))
        {
            D3D_ERR("D3DRS_POSITIONORDER should be D3DORDER_LINEAR or D3DORDER_CUBIC");
            return FALSE;
        }
        break;
    case D3DRS_NORMALORDER:
        if (!((value == D3DORDER_LINEAR) || (value == D3DORDER_QUADRATIC)))
        {
            D3D_ERR("D3DRS_NORMALORDER should be D3DORDER_LINEAR or D3DORDER_QUADRATIC");
            return FALSE;
        }
        break;
    }
    return TRUE;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetRenderState"

HRESULT D3DAPI
CD3DBase::SetRenderState(D3DRENDERSTATETYPE dwState,
                         DWORD value)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!ValidateRenderState(dwState, value))
        return D3DERR_INVALIDCALL;
#endif

    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertRenderState(dwState, value,
                                            CanHandleRenderState(dwState));
        else
            m_pDDI->SetRenderState(dwState, value);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetRenderState failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetRenderStateFast"

HRESULT D3DAPI CD3DBase::SetRenderStateFast(D3DRENDERSTATETYPE dwState,
                                            DWORD value)
{

#if DBG
    if (!ValidateRenderState(dwState, value))
        return D3DERR_INVALIDCALL;
#endif

    DXGASSERT((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0);

    try
    {
        m_pDDI->SetRenderState(dwState, value);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetRenderState failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetClipStatus"

HRESULT D3DAPI
CD3DBase::SetClipStatus(CONST D3DCLIPSTATUS8* lpStatus)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    D3D_ERR("SetClipStatus is not available for D3DCREATE_PUREDEVICE. SetClipStatus failed.");
    return E_NOTIMPL;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetClipStatus"

HRESULT D3DAPI
CD3DBase::GetClipStatus(D3DCLIPSTATUS8* lpStatus)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    D3D_ERR("GetClipStatus is not available for D3DCREATE_PUREDEVICE. GetClipStatus failed.");
    return E_NOTIMPL;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::ProcessVertices"

HRESULT D3DAPI
CD3DBase::ProcessVertices(UINT SrcStartIndex, UINT DestIndex, UINT VertexCount,
                          IDirect3DVertexBuffer8 *pDestBuffer,
                          DWORD Flags)
{
    API_ENTER(this); // Takes D3D Lock if necessary
    if (pDestBuffer == NULL)
    {
        D3D_ERR("Invalid vertex buffer pointer. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    CVertexBuffer* pVB = static_cast<CVertexBuffer*>(pDestBuffer);
    if (pVB->Device() != this)
    {
        D3D_ERR("VertexBuffer not created with this device. Process Vertices failed.");
        return D3DERR_INVALIDCALL;
    }

    D3D_ERR("ProcessVertices is not available for a PUREDEVICE. ProcessVertices failed.");
    return E_NOTIMPL;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTexture"

HRESULT D3DAPI
CD3DBase::SetTexture(DWORD                  dwStage,
                     IDirect3DBaseTexture8 *lpTex)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {

#if DBG
        HRESULT ret = VerifyTexture(dwStage, lpTex);
        if (ret != D3D_OK)
            return ret;
#endif
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            m_pStateSets->InsertTexture(dwStage, lpTex);
            return D3D_OK;
        }

        return SetTextureFast(dwStage, lpTex);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetTexture failed.");
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::VerifyTexture"
HRESULT
CD3DBase::VerifyTexture(DWORD                    dwStage,
                        IDirect3DBaseTexture8   *lpTex)
{
    if (dwStage >= D3DHAL_TSS_MAXSTAGES)
    {
        D3D_ERR("Invalid texture stage or state index. SetTexture failed.");
        return D3DERR_INVALIDCALL;
    }

    if (lpTex)
    {
        if (!VALID_DIRECT3DBASETEXTURE8_PTR(lpTex))
        {
            D3D_ERR("Invalid texture pointer. SetTexture failed.");
            return D3DERR_INVALIDCALL;
        }

        CBaseTexture *pTex = CBaseTexture::SafeCast(lpTex);
        if (pTex->Device() != this)
        {
            D3D_ERR("Texture not created with this device. SetTexture failed.");
            return D3DERR_INVALIDCALL;
        }

        if (pTex->GetUserPool() == D3DPOOL_SYSTEMMEM)
        {
            if ((GetD3DCaps()->DevCaps & D3DDEVCAPS_TEXTURESYSTEMMEMORY) == 0)
            {
                D3D_ERR("Device cannot render using texture surface from system memory. SetTexture failed.");
                return D3DERR_INVALIDCALL;
            }
        }
        if (pTex->GetUserPool() == D3DPOOL_SCRATCH)
        {
            D3D_ERR("D3DPOOL_SCRATCH resources cannot be passed to SetTexture. SetTexture fails.");
            return D3DERR_INVALIDCALL;
        }

    }

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTextureFast"

HRESULT D3DAPI
CD3DBase::SetTextureFast(DWORD                   dwStage,
                         IDirect3DBaseTexture8  *lpTex)
{
    // NOTE: This can become a public API through the
    // v-table hack. This should only happen for
    // single-threaded apps; so we don't need
    // to take the critical section.
#if DBG
    HRESULT ret = VerifyTexture(dwStage, lpTex);
    if (ret != D3D_OK)
        return ret;
#endif

    CBaseTexture *lpTexI = CBaseTexture::SafeCast(lpTex);

    if (m_lpD3DMappedTexI[dwStage] == lpTexI)
    {
        return  D3D_OK;
    }

    if (m_lpD3DMappedTexI[dwStage])
    {
        m_lpD3DMappedTexI[dwStage]->DecrementUseCount();
    }

    m_lpD3DMappedTexI[dwStage] = lpTexI;

    if (lpTexI)
    {
        lpTexI->IncrementUseCount();
    }

    m_dwStageDirty |= (1 << dwStage);

    // Need to call UpdateTextures()
    m_dwRuntimeFlags |= D3DRT_NEED_TEXTURE_UPDATE;

    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetTexture"

HRESULT D3DAPI
CD3DBase::GetTexture(DWORD dwStage,
                     IDirect3DBaseTexture8 **lplpTex)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES)
    {
        D3D_ERR("Invalid texture stage or state index. GetTexture failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    if (!VALID_WRITEPTR(lplpTex, sizeof(LPVOID)))
    {
        D3D_ERR("Invalid pointer to IDirect3DBaseTexture8*. GetTexture failed.");
        return D3DERR_INVALIDCALL;
    }

    if (m_lpD3DMappedTexI[dwStage])
    {
        switch(m_lpD3DMappedTexI[dwStage]->GetBufferDesc()->Type)
        {
        case D3DRTYPE_TEXTURE:
            *lplpTex = static_cast<IDirect3DTexture8*>(static_cast<CMipMap*>(m_lpD3DMappedTexI[dwStage]));
            break;
        case D3DRTYPE_CUBETEXTURE:
            *lplpTex = static_cast<IDirect3DCubeTexture8*>(static_cast<CCubeMap*>(m_lpD3DMappedTexI[dwStage]));
            break;
        case D3DRTYPE_VOLUMETEXTURE:
            *lplpTex = static_cast<IDirect3DVolumeTexture8*>(static_cast<CMipVolume*>(m_lpD3DMappedTexI[dwStage]));
            break;
        }
        (*lplpTex)->AddRef();
    }
    else
    {
        *lplpTex = NULL;
    }
    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTextureStageState"

HRESULT D3DAPI
CD3DBase::SetTextureStageState(DWORD dwStage,
                               D3DTEXTURESTAGESTATETYPE dwState,
                               DWORD dwValue)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if ( (dwStage >= D3DHAL_TSS_MAXSTAGES) ||
         (dwState == 0) ||
         (dwState >= D3DTSS_MAX) ||
         (dwState == 12) )  // D3DTSS_ADDRESS no longer valid
    {
        D3D_ERR("Invalid texture stage or state index. SetTextureStageState failed.");
        return D3DERR_INVALIDCALL;
    }
#endif //DBG
    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertTextureStageState(dwStage, dwState, dwValue);
        else
            m_pDDI->SetTSS(dwStage, dwState, dwValue);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetTextureStageState failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTextureStageStateFast"

HRESULT D3DAPI
CD3DBase::SetTextureStageStateFast(DWORD dwStage,
                                   D3DTEXTURESTAGESTATETYPE dwState,
                                   DWORD dwValue)
{
#if DBG
    if ( (dwStage >= D3DHAL_TSS_MAXSTAGES) ||
         (dwState == 0) ||
         (dwState >= D3DTSS_MAX) ||
         (dwState == 12) )  // D3DTSS_ADDRESS no longer valid
    {
        D3D_ERR("Invalid texture stage or state index. SetTextureStageState failed.");
        return D3DERR_INVALIDCALL;
    }
#endif //DBG

    DXGASSERT((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0);

    try
    {
        m_pDDI->SetTSS(dwStage, dwState, dwValue);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetTextureStageState failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::LightEnable"

HRESULT D3DAPI
CD3DBase::LightEnable(DWORD dwLightIndex,
                      BOOL bEnable)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        // If light was never created, we create a default light
        if (dwLightIndex >= m_pCreatedLights->GetSize() ||
            !m_pCreatedLights->IsBitSet(dwLightIndex))
        {
            // Set default value to the light
            D3DLIGHT8 light;
            memset(&light, 0, sizeof(light));
            light.Type = D3DLIGHT_DIRECTIONAL;
            light.Direction.x = D3DVAL(0);
            light.Direction.y = D3DVAL(0);
            light.Direction.z = D3DVAL(1);
            light.Diffuse.r = D3DVAL(1);
            light.Diffuse.g = D3DVAL(1);
            light.Diffuse.b = D3DVAL(1);

            // When a new light is created we need to actually create it even
            // in the record mode. So we clear record flag, create light and
            // restore the flag.
            DWORD OldBit = m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE;
            m_dwRuntimeFlags &= ~D3DRT_RECORDSTATEMODE;

            HRESULT ret = SetLight(dwLightIndex, &light);

            m_dwRuntimeFlags |= OldBit;

            if (ret != S_OK)
                return ret;
        }

        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertLightEnable(dwLightIndex, bEnable);
        else
            LightEnableI(dwLightIndex, bEnable);
    }
    catch (HRESULT ret)
    {
        DPF_ERR("LightEnable failed.");
        return ret;
    }
    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetInfo"

HRESULT D3DAPI
CD3DBase::GetInfo(DWORD dwDevInfoID,
                  LPVOID pDevInfoStruct,
                  DWORD dwSize)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (dwSize == 0 || !VALID_D3DDEVINFOSTRUCT_PTR(pDevInfoStruct, dwSize))
    {
        D3D_ERR("Invalid structure pointer or size. GetInfo failed.");
        return D3DERR_INVALIDCALL;
    }
    memset(pDevInfoStruct, 0, dwSize);
    if (dwDevInfoID < D3DDEVINFOID_VCACHE)
    {
        D3D_ERR("DX7 DevInfo IDs not supported in DX8. GetInfo failed.");
        return E_FAIL;
    }
#if DBG
    if (m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)
    {
        DPF(2, "GetInfo called within a scene");
    }
#endif
    try
    {
        if( !IS_DX7HAL_DEVICE(this) )  // must be at least DX7
        {
            DPF( 1, "Device information query unsupported" );
            return E_FAIL;
        }

        m_pDDI->FlushStates();
    }
    catch(HRESULT hr)
    {
        DPF_ERR("GetInfo failed.");
        return hr;
    }

    D3D8_GETDRIVERSTATEDATA dsd;
    dsd.dwFlags = dwDevInfoID;
    dsd.dwhContext = m_pDDI->GetDeviceContext();
    dsd.lpdwStates = (LPDWORD)pDevInfoStruct;
    dsd.dwLength = dwSize;

    HRESULT hr;
    hr = GetHalCallbacks()->GetDriverState(&dsd);
    if (hr != DDHAL_DRIVER_HANDLED)
    {
        DPF( 1, "Device information query unsupported" );
        memset(pDevInfoStruct, 0, dwSize);
        return S_FALSE;
    }
    else if (dsd.ddRVal != DD_OK)
    {
        D3D_ERR("Driver failed query. GetInfo failed.");
        memset(pDevInfoStruct, 0, dwSize);
        return E_FAIL;
    }

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetCurrentTexturePalette"

HRESULT D3DAPI
CD3DBase::SetCurrentTexturePalette(UINT PaletteNumber)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            m_pStateSets->InsertCurrentTexturePalette(PaletteNumber);
        }
        else
        {
#if DBG
            if (PaletteNumber >= m_pPaletteArray->GetSize())
            {
                D3D_ERR("Palette not defined. SetCurrentTexturePalette failed.");
                return D3DERR_INVALIDCALL;
            }
#endif
            if(PaletteNumber != m_dwPalette)
            {
                m_dwPalette = PaletteNumber;

                // Need to call UpdateTextures()
                m_dwRuntimeFlags |= D3DRT_NEED_TEXTURE_UPDATE;
            }
        }
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetCurrentTexturePalette failed.");
        return ret;
    }

    return S_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetCurrentTexturePalette"

HRESULT D3DAPI
CD3DBase::GetCurrentTexturePalette(UINT *PaletteNumber)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!VALID_PTR(PaletteNumber, sizeof(UINT)))
    {
        D3D_ERR("Invalid PaletteNumber pointer. GetCurrentTexturePalette failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    *PaletteNumber = m_dwPalette;

    return S_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetPaletteEntries"

HRESULT D3DAPI
CD3DBase::SetPaletteEntries(UINT PaletteNumber, CONST PALETTEENTRY *pEntries)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!VALID_PTR(pEntries, sizeof(PALETTEENTRY) * 256))
    {
        D3D_ERR("Invalid Entries pointer. SetPaletteEntries failed.");
        return D3DERR_INVALIDCALL;
    }
    if (PaletteNumber > 0xffff)
    {
        D3D_ERR("Illegal PaletteNumber value. SetPaletteEntries failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    if (Enum()->GetAppSdkVersion() > D3D_SDK_VERSION_DX8)
    {
        bool bAlpha=false;
#if DBG
        bool bAllTransparent = true;
#endif
        for (int i=0;i<256;i++)
        {
            if (pEntries[i].peFlags != 0xff)
            {
                bAlpha = true;
            }
#if DBG
            if (pEntries[i].peFlags != 0)
            {
                bAllTransparent = false;
            }
#endif
        }
#if DBG
        if (bAllTransparent)
        {
            D3D_WARN(0,"Every entry in palette has alpha (peFlags) == 0. Texture may not appear.");
        }
#endif
        if (bAlpha && (0 == (GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_ALPHAPALETTE)) )
        {
            D3D_ERR("Application cannot set a non-opaque palette alpha value (peFlags other than 0xFF) unless the device exposes D3DPTEXTURECAPS_ALPHAPALETTE. SetPaletteEntries failed.");
            return D3DERR_INVALIDCALL;
        }
    }


    HRESULT hr = m_pPaletteArray->Grow(PaletteNumber);
    if(FAILED(hr))
    {
        D3D_ERR("Failed to set palette entries. SetPaletteEntries failed.");
        return hr;
    }

    CPalette *pal = static_cast<CPalette*>((*m_pPaletteArray)[PaletteNumber].m_pObj);
    if(pal == 0)
    {
        pal = new CPalette;
        (*m_pPaletteArray)[PaletteNumber].m_pObj = pal;
        if(pal == 0)
        {
            D3D_ERR("Could not allocate space to hold palette. SetPaletteEntries failed.");
            return E_OUTOFMEMORY;
        }
    }
    memcpy(pal->m_pEntries, pEntries, sizeof(PALETTEENTRY) * 256);

    pal->m_dirty = TRUE;

    if(m_dwPalette == PaletteNumber)
    {
        // Need to call UpdateTextures()
        m_dwRuntimeFlags |= D3DRT_NEED_TEXTURE_UPDATE;
    }

    return S_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetPaletteEntries"

HRESULT D3DAPI
CD3DBase::GetPaletteEntries(UINT PaletteNumber, PALETTEENTRY *pEntries)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!VALID_WRITEPTR(pEntries, sizeof(PALETTEENTRY) * 256))
    {
        D3D_ERR("Invalid ppEntries pointer. GetPaletteEntries failed.");
        return D3DERR_INVALIDCALL;
    }
    if (PaletteNumber >= m_pPaletteArray->GetSize())
    {
        D3D_ERR("Palette not defined. GetPaletteEntries failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    CPalette *pal = static_cast<CPalette*>((*m_pPaletteArray)[PaletteNumber].m_pObj);

#if DBG
    if(pal == 0)
    {
        D3D_ERR("Palette not defined.  GetPaletteEntries failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    memcpy(pEntries, pal->m_pEntries, sizeof(PALETTEENTRY) * 256);

    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetClipPlaneI"

void CD3DBase::SetClipPlaneI(DWORD dwPlaneIndex,
                             CONST D3DVALUE* pPlaneEquation)
{
    m_pDDI->SetClipPlane(dwPlaneIndex, pPlaneEquation);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetClipPlane"

HRESULT D3DAPI
CD3DBase::SetClipPlane(DWORD dwPlaneIndex,
                       CONST D3DVALUE* pPlaneEquation)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (dwPlaneIndex >= m_dwMaxUserClipPlanes)
    {
        D3D_ERR("Plane index is too big. SetClipPlane failed.");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_PTR(pPlaneEquation, sizeof(D3DVALUE)*4))
    {
        D3D_ERR("Invalid plane pointer. SetClipPlane failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertClipPlane(dwPlaneIndex, pPlaneEquation);
        else
            SetClipPlaneI(dwPlaneIndex, pPlaneEquation);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetClipPlane failed.");
        return ret;
    }
    return D3D_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetStreamSource"

HRESULT D3DAPI
CD3DBase::SetStreamSource(UINT StreamNumber,
                          IDirect3DVertexBuffer8 *pStreamData,
                          UINT Stride)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    // Validate Parameters
    if (StreamNumber >= m_dwNumStreams)
    {
        D3D_ERR("Stream number should be less than %d. SetStreamSource failed.", m_dwNumStreams);
        return D3DERR_INVALIDCALL;
    }
    if (Stride > this->GetD3DCaps()->MaxStreamStride)
    {
        D3D_ERR("Stream stride is too big. Check device caps. SetStreamSource failed.");
        return D3DERR_INVALIDCALL;
    }
    // NULL is allowed to be passed
    if (pStreamData)
    {
        CVertexBuffer* pVB = static_cast<CVertexBuffer*>(pStreamData);
        if (pVB->Device() != this)
        {
            D3D_ERR("VertexBuffer not created with this Device. SetStreamSource fails.");
            return D3DERR_INVALIDCALL;
        }
    }
#endif

    if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
    {
        try
        {
            m_pStateSets->InsertStreamSource(StreamNumber, static_cast<CVertexBuffer *>(pStreamData), Stride);
        }
        catch(HRESULT hr)
        {
            DPF_ERR("SetStreamSource failed.");
            return hr;
        }
        return S_OK;
    }

    CVStream* pStream = &m_pStream[StreamNumber];

    if (pStream->m_pVB == static_cast<CVertexBuffer *>(pStreamData) &&
        Stride == pStream->m_dwStride)
        return D3D_OK;

    // Release previously set vertex buffer
    if (pStream->m_pVB)
    {
        m_pDDI->VBReleased(pStream->m_pVB);
        pStream->m_pVB->DecrementUseCount();
        pStream->m_pVB = NULL;
    }
    pStream->m_pData = NULL;
    pStream->m_pVB = static_cast<CVertexBuffer *>(pStreamData);
    if (pStreamData)
    {
        pStream->m_pVB->IncrementUseCount();
        pStream->m_dwStride = Stride;
#if DBG
        pStream->m_dwSize = pStream->m_pVB->GetBufferDesc()->Size;
#endif // DBG
        m_dwStreamDirty |= (1 << StreamNumber);
        m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
#if DBG
        if (Stride == 0)
            pStream->m_dwNumVertices = 1;
        else
            pStream->m_dwNumVertices = pStream->m_dwSize / Stride;
#endif
        try
        {
            SetStreamSourceI(pStream);
        }
        catch(HRESULT hr)
        {
            DPF_ERR("SetStreamSource failed.");
            return hr;
        }
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetStreamSourceI"

void
CD3DBase::SetStreamSourceI(CVStream* pStream)
{
}
#ifdef FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetStreamSourceFast"

HRESULT D3DAPI
CD3DBase::SetStreamSourceFast(UINT StreamNumber,
                              IDirect3DVertexBuffer8 *pStreamData,
                              UINT Stride)
{
#if DBG
    // Validate Parameters
    if (StreamNumber >= m_dwNumStreams)
    {
        D3D_ERR("Stream number should be less than %d. SetStreamSource failed.", m_dwNumStreams);
        return D3DERR_INVALIDCALL;
    }
    if (Stride > this->GetD3DCaps()->MaxStreamStride)
    {
        D3D_ERR("Stream stride is too big. Check device caps. SetStreamSource failed.");
        return D3DERR_INVALIDCALL;
    }
    // NULL is allowed to be passed
    if (pStreamData)
    {
        CVertexBuffer* pVB = static_cast<CVertexBuffer*>(pStreamData);
        if (pVB->Device() != this)
        {
            D3D_ERR("VertexBuffer not created with this Device. SetStreamSource fails.");
            return D3DERR_INVALIDCALL;
        }
    }
#endif

    DXGASSERT((m_dwRuntimeFlags & (D3DRT_RECORDSTATEMODE | D3DRT_RSSOFTWAREPROCESSING)) == 0 &&
                  (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0);

    CVStream* pStream = &m_pStream[StreamNumber];

    if (pStream->m_pVB == static_cast<CVertexBuffer *>(pStreamData) &&
        Stride == pStream->m_dwStride)
        return D3D_OK;

    // Release previously set vertex buffer
    if (pStream->m_pVB)
    {
        // We don't call VBReleased() here because there is no need to update the DDI object since
        // the fe/PSGP never does the redundant stream set check. This check is done in DrawPrim,
        // DrawIndexPrim and DrawClippedPrim. It is important to call VBReleased whenever fe/PSGP
        // is being used because it is possible that the user freed and recreated the same VB with
        // the same address and then the redundant set check will not work.
        pStream->m_pVB->DecrementUseCount();
        pStream->m_pVB = NULL;
    }
    pStream->m_pData = NULL;
    pStream->m_pVB = static_cast<CVertexBuffer *>(pStreamData);
    if (pStreamData)
    {
        pStream->m_pVB->IncrementUseCount();
        pStream->m_dwStride = Stride;
#if DBG
        pStream->m_dwSize = pStream->m_pVB->GetBufferDesc()->Size;
#endif // DBG
        m_dwStreamDirty |= (1 << StreamNumber);
        m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
#if DBG
        if (Stride == 0)
            pStream->m_dwNumVertices = 1;
        else
            pStream->m_dwNumVertices = pStream->m_dwSize / Stride;
#endif
    }
    if (!IS_DX8HAL_DEVICE(this))
    {
        PickDrawPrimFn();
    }
    return S_OK;
}
#endif // FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetStreamSource"

HRESULT
CD3DBase::GetStreamSource(UINT StreamNumber, IDirect3DVertexBuffer8 **ppStreamData,
                          UINT* pStride)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (StreamNumber >= m_dwNumStreams)
    {
        D3D_ERR("Stream number should be less than %d. GetStreamSource failed.", m_dwNumStreams);
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_WRITEPTR(ppStreamData, sizeof(IDirect3DVertexBuffer8*)))
    {
        D3D_ERR("Invalid stream data pointer. GetStreamSource failed.");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_WRITEPTR(pStride, sizeof(UINT*)))
    {
        D3D_ERR("Invalid stride pointer. GetStreamSource failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    CVStream* pStream = &m_pStream[StreamNumber];
    *ppStreamData = (pStream) ? (pStream->m_pVB) : (NULL);
    if (pStream->m_pVB)
        pStream->m_pVB->AddRef();
    *pStride = (pStream) ? (pStream->m_dwStride) : (0);
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetIndices"

HRESULT D3DAPI
CD3DBase::SetIndices(IDirect3DIndexBuffer8 *pIndexData, UINT BaseVertexIndex)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        CIndexBuffer * pVB = static_cast<CIndexBuffer*>(pIndexData);
#if DBG
        if (pVB && pVB->Device() != this)
        {
            D3D_ERR("IndexBuffer not created with this Device. SetIndices fails.");
            return D3DERR_INVALIDCALL;
        }
#endif
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            m_pStateSets->InsertIndices(pVB, BaseVertexIndex);
            return S_OK;
        }

        if (m_pIndexStream->m_pVBI == static_cast<CIndexBuffer *>(pIndexData))
        {
            m_pIndexStream->m_dwBaseIndex = BaseVertexIndex;
            return D3D_OK;
        }

       // Release previously set vertex buffer
        if (m_pIndexStream->m_pVBI)
        {
            m_pDDI->VBIReleased(m_pIndexStream->m_pVBI);
            m_pIndexStream->m_pVBI->DecrementUseCount();
            m_pIndexStream->m_pVBI = NULL;
        }
        m_pIndexStream->m_pVBI = static_cast<CIndexBuffer *>(pIndexData);
        if (pVB)
        {
            switch (pVB->GetBufferDesc()->Format)
            {
            case D3DFMT_INDEX16:
                m_pIndexStream->m_dwStride = 2;
                break;
            case D3DFMT_INDEX32:
#if DBG
                if (GetD3DCaps()->MaxVertexIndex <= 0xFFFF)
                    D3D_THROW(D3DERR_INVALIDCALL, "Device does not support 32-bit indices");
#endif
                m_pIndexStream->m_dwStride = 4;
                break;
            default:
                D3D_THROW(D3DERR_INVALIDCALL, "Invalid index buffer format");
            }
#if DBG
            m_pIndexStream->m_dwSize = pVB->GetBufferDesc()->Size;
#endif
            m_pIndexStream->m_dwBaseIndex = BaseVertexIndex;
            m_pIndexStream->m_pData = NULL;
#if DBG
            m_pIndexStream->m_dwNumVertices = m_pIndexStream->m_dwSize /
                                            m_pIndexStream->m_dwStride;
#endif
            m_pIndexStream->m_pVBI->IncrementUseCount();
            m_dwStreamDirty |= (1 << __NUMSTREAMS);
            m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()

            SetIndicesI(m_pIndexStream);
        }
    }
    catch(HRESULT hr)
    {
        DPF_ERR("SetIndices failed.");
        return hr;
    }

    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetIndicesI"

void
CD3DBase::SetIndicesI(CVIndexStream* pStream)
{
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetIndices"

HRESULT D3DAPI
CD3DBase::GetIndices(IDirect3DIndexBuffer8 **ppIndexData, UINT* pBaseVertexIndex)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!VALID_WRITEPTR(ppIndexData, sizeof(IDirect3DIndexBuffer8*)))
    {
        D3D_ERR("Invalid index data pointer. GetIndices failed.");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_WRITEPTR(pBaseVertexIndex, sizeof(UINT*)))
    {
        D3D_ERR("Invalid base index pointer. GetIndices failed.");
        return D3DERR_INVALIDCALL;
    }
#endif //DBG
    *ppIndexData = m_pIndexStream->m_pVBI;
    if (m_pIndexStream->m_pVBI)
        m_pIndexStream->m_pVBI->AddRef();
    *pBaseVertexIndex = m_pIndexStream->m_dwBaseIndex;
    return S_OK;
}
#ifdef FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetIndicesFast"

HRESULT D3DAPI
CD3DBase::SetIndicesFast(IDirect3DIndexBuffer8 *pIndexData, UINT BaseVertexIndex)
{
    CIndexBuffer * pVB = static_cast<CIndexBuffer*>(pIndexData);
#if DBG
    if (pVB && pVB->Device() != this)
    {
        D3D_ERR("IndexBuffer not created with this device. SetIndices fails.");
        return D3DERR_INVALIDCALL;
    }
#endif

    DXGASSERT((m_dwRuntimeFlags & (D3DRT_RECORDSTATEMODE | D3DRT_RSSOFTWAREPROCESSING)) == 0 &&
                  (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0);

    if (m_pIndexStream->m_pVBI == pVB)
    {
        m_pIndexStream->m_dwBaseIndex = BaseVertexIndex;
        return D3D_OK;
    }

    // Release previously set index buffer
    if (m_pIndexStream->m_pVBI)
    {
        // We don't call VBReleased() here because there is no need to update the DDI object since
        // the fe/PSGP never does the redundant stream set check. This check is done in DrawPrim,
        // DrawIndexPrim and DrawClippedPrim. It is important to call VBReleased whenever fe/PSGP
        // is being used because it is possible that the user freed and recreated the same VB with
        // the same address and then the redundant set check will not work.
        m_pIndexStream->m_pVBI->DecrementUseCount();
        m_pIndexStream->m_pVBI = NULL;
    }
    m_pIndexStream->m_pVBI = static_cast<CIndexBuffer *>(pIndexData);
    if (pVB)
    {
        switch (pVB->GetBufferDesc()->Format)
        {
        case D3DFMT_INDEX16:
            m_pIndexStream->m_dwStride = 2;
            break;
        case D3DFMT_INDEX32:
#if DBG
            if (GetD3DCaps()->MaxVertexIndex <= 0xFFFF)
            {
                DPF_ERR("Device does not support 32-bit indices. SetIndices failed.");
                return D3DERR_INVALIDCALL;
            }
#endif
            m_pIndexStream->m_dwStride = 4;
            break;
        default:
            DPF_ERR("Invalid index buffer format. SetIndices failed.");
            return D3DERR_INVALIDCALL;
        }
#if DBG
        m_pIndexStream->m_dwSize = pVB->GetBufferDesc()->Size;
#endif
        m_pIndexStream->m_dwBaseIndex = BaseVertexIndex;
        m_pIndexStream->m_pData = NULL;
#if DBG
        m_pIndexStream->m_dwNumVertices = m_pIndexStream->m_dwSize /
                                        m_pIndexStream->m_dwStride;
#endif
        m_pIndexStream->m_pVBI->IncrementUseCount();
        m_dwStreamDirty |= (1 << __NUMSTREAMS);
        m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
    }
    return S_OK;
}
#endif // FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CreateVertexShader"

HRESULT D3DAPI
CD3DBase::CreateVertexShader(CONST DWORD* pdwDeclaration,
                             CONST DWORD* pdwFunction,
                             LPDWORD pdwHandle, DWORD Usage)
{
    API_ENTER(this); // Takes D3D Lock if necessary
#if DBG
    // Validate Parameters
    // WARNING!! sizeof(LPVOID) is not good enough
    if (!VALID_PTR(pdwDeclaration, sizeof(LPVOID)))
    {
        D3D_ERR("Invalid shader declaration pointer. CreateVertexShader failed.");
        return D3DERR_INVALIDCALL;
    }
    // WARNING!! sizeof(LPVOID) is not good enough
    if (pdwFunction && !VALID_PTR(pdwFunction, sizeof(LPVOID)))
    {
        D3D_ERR("Invalid shader function pointer. CreateVertexShader failed.");
        return D3DERR_INVALIDCALL;
    }
    if (pdwHandle && !VALID_WRITEPTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR("Invalid shader handle pointer. CreateVertexShader failed.");
        return D3DERR_INVALIDCALL;
    }
    if (Usage & ~D3DUSAGE_SOFTWAREPROCESSING)
    {
        D3D_ERR("Illegal usage value. CreateVertexShader failed.");
        return D3DERR_INVALIDCALL;
    }
    if (pdwHandle == NULL)
    {
        // Temporary vertex shaders are disabled
        D3D_ERR("Output handle pointer cannot be NULL. CreateVertexShader failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((pdwFunction != NULL) &&
        (GetD3DCaps()->VertexShaderVersion == D3DVS_VERSION(0,0)) &&
        (BehaviorFlags() & (D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE)))
    {
        D3D_ERR("No programmable vertex shaders are supported by this device. CreateVertexShader failed.");
        return D3DERR_INVALIDCALL;
    }

#endif // DBG
    DWORD dwHandle = m_pVShaderArray->CreateNewHandle(NULL);
    HRESULT ret = S_OK;
    if (dwHandle == __INVALIDHANDLE)
    {
        D3D_ERR("Error in creating shader handle. CreateVertexShader failed.");
        return E_OUTOFMEMORY;
    }
    CVShader *pShader = new CVShader(m_dwNumStreams);
    if (pShader == NULL)
    {
        D3D_ERR("Cannot allocate memory for internal shader object. CreateVertexShader failed.");
        return E_OUTOFMEMORY;
    }
    if (Usage & D3DUSAGE_SOFTWAREPROCESSING ||
        BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING)
    {
        pShader->m_dwFlags |= CVShader::SOFTWARE;
        Usage |= D3DUSAGE_SOFTWAREPROCESSING;
    }

    try
    {
        D3DCAPS8 Caps, *pCaps = NULL;
        const D3DCAPS8 *pConstCaps = GetD3DCaps();
        if( pConstCaps )
        {
            pCaps = &Caps;
            memcpy(pCaps,pConstCaps,sizeof(D3DCAPS8));
            pCaps->MaxStreams = m_dwNumStreams;
            if( pShader->m_dwFlags & CVShader::SOFTWARE )
            {
                pCaps->VertexShaderVersion = D3DVS_VERSION(1, 1); // Version 1.1
                pCaps->MaxVertexShaderConst = D3DVS_CONSTREG_MAX_V1_1;
            }
        }
        if( !ValidateVertexShaderInternal(pdwFunction, pdwDeclaration, pCaps) )
        {
            ret = D3DERR_INVALIDCALL;
            goto error;
        }

        // Even for the D3DCREATE_PUREDEVICE we create a shader object for
        // validation
        DWORD dwCodeOnlySize = 0;
        DWORD dwCodeAndCommentSize = 0;
        DWORD dwDeclSize = 0;
        if (pdwFunction == NULL)
        {
            pShader->m_dwFlags |= CVShader::FIXEDFUNCTION;
            pShader->m_Declaration.Parse(this, pdwDeclaration, TRUE, &dwDeclSize, Usage);
        }
        else
        {
            pShader->m_Declaration.Parse(this, pdwDeclaration, FALSE, &dwDeclSize, Usage);
            HRESULT hr = ComputeShaderCodeSize(pdwFunction,
                                               &dwCodeOnlySize,
                                               &dwCodeAndCommentSize,
                                               NULL);
            if (hr != S_OK)
            {
                D3D_THROW(hr, "Unable to compute shader code size.");
            }
            pShader->m_pOrgFuncCode = new DWORD[dwCodeAndCommentSize];
            pShader->m_pStrippedFuncCode = new DWORD[dwCodeOnlySize];
            if (pShader->m_pOrgFuncCode == NULL ||
                pShader->m_pStrippedFuncCode == NULL)
            {
                D3D_THROW(E_OUTOFMEMORY, "Could not allocate space for holding vertex shader");
            }

            pShader->m_OrgFuncCodeSize = dwCodeAndCommentSize;
            memcpy(pShader->m_pOrgFuncCode, pdwFunction, dwCodeAndCommentSize);

            pShader->m_StrippedFuncCodeSize = dwCodeOnlySize;
            // copy and strip comments (instead of memcpy)
            DWORD* pDst = pShader->m_pStrippedFuncCode;
            CONST DWORD* pSrc = pdwFunction;
            *pDst++ = *pSrc++; // copy version
            while (*pSrc != 0x0000FFFF)
            {
                if(IsInstructionToken(*pSrc))
                {
                    DWORD opCode = (*pSrc) & D3DSI_OPCODE_MASK;
                    if ( opCode == D3DSIO_COMMENT )
                    {
                        UINT DWordSize = ((*pSrc)&D3DSI_COMMENTSIZE_MASK)>>D3DSI_COMMENTSIZE_SHIFT;
                        pSrc += (DWordSize + 1);  // comment + instruction token
                    }
                    else
                    {
                        *pDst++ = *pSrc++;
                    }
                }
                else
                {
                    *pDst++ = *pSrc++;
                }
            }
            *pDst++ = *pSrc++; // copy END
        }

        // ALways save the original declaration
        pShader->m_pOrgDeclaration = new DWORD[dwDeclSize];
        if (pShader->m_pOrgDeclaration == NULL)
        {
            D3D_THROW(E_OUTOFMEMORY, "Could not allocate space for holding vertex shader");
        }
        pShader->m_OrgDeclSize = dwDeclSize;
        memcpy(pShader->m_pOrgDeclaration, pdwDeclaration, dwDeclSize);

        m_pVShaderArray->SetObject(dwHandle, pShader);

        CreateVertexShaderI(pdwDeclaration,
                            dwDeclSize,
                            pdwFunction,
                            dwCodeAndCommentSize, dwHandle);
    }
    catch(HRESULT hr)
    {
        ret = hr;
        goto error;
    }

    *pdwHandle = dwHandle;
    return S_OK;

error:
    D3D_ERR("CreateVertexShader failed.");
    delete pShader;
    m_pVShaderArray->ReleaseHandle(dwHandle, FALSE);
    return ret;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CheckVertexShaderHandle"

void CD3DBase::CheckVertexShaderHandle(DWORD dwHandle)
{
    if (dwHandle == 0)
    {
        D3D_THROW(D3DERR_INVALIDCALL, "Invalid vertex shader handle");
    }
    if (D3DVSD_ISLEGACY(dwHandle))
    {
        if (((GetD3DCaps()->DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) == 0) &&
            !FVF_TRANSFORMED(dwHandle) &&
            (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) == 0)
        {
            D3D_THROW(D3DERR_INVALIDCALL,
                      "Untransformed data cannot be handles by this device");
        }

        if (FAILED(ValidateFVF(dwHandle)))
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid FVF (or legacy vertex shader handle)");
        }
    }
    else
    {
        CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
        if (pShader == NULL)
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid vertex shader handle");
        }
        if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
        {
            if (!(pShader->m_dwFlags & CVShader::SOFTWARE))
            {
                D3D_THROW_FAIL("Vertex shader created in hardware mode cannot be used in software mode");
            }
        }
        else
        {
            if (pShader->m_dwFlags & CVShader::SOFTWARE)
            {
                D3D_THROW_FAIL("Vertex shader created in software mode cannot be used in hardware mode");
            }
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CheckPixelShaderHandle"

void CD3DBase::CheckPixelShaderHandle(DWORD dwHandle)
{
    if (dwHandle != 0)
    {
        CPShader* pShader = (CPShader*)m_pPShaderArray->GetObject(dwHandle);
        if (pShader == NULL)
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid pixel shader handle");
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetVertexShader"

HRESULT D3DAPI
CD3DBase::SetVertexShader(DWORD dwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
#if DBG
        CheckVertexShaderHandle(dwHandle);
#endif
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            if (D3DVSD_ISLEGACY(dwHandle))
            {
                m_pStateSets->InsertVertexShader(dwHandle, TRUE);
            }
            else
            {
                CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
                if (pShader->m_dwFlags & CVShader::SOFTWARE)
                    m_pStateSets->InsertVertexShader(dwHandle, FALSE);
                else
                    m_pStateSets->InsertVertexShader(dwHandle, TRUE);
            }
        }
        else
        {
            SetVertexShaderI(dwHandle);
        }
    }
    catch(HRESULT hr)
    {
        DPF_ERR("SetVertexShader failed.");
        ClearVertexShaderHandle();
        return hr;
    }
   return S_OK;
}
#ifdef FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetVertexShaderFast"

HRESULT D3DAPI
CD3DBase::SetVertexShaderFast(DWORD dwHandle)
{
    try
    {
#if DBG
        CheckVertexShaderHandle(dwHandle);
        if (!D3DVSD_ISLEGACY(dwHandle))
        {
            CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
            if (pShader->m_dwFlags & CVShader::SOFTWARE)
            {
                D3D_THROW_FAIL("Vertex shader created in software mode cannot be used in hardware mode");
            }
        }
#endif
        DXGASSERT((m_dwRuntimeFlags & (D3DRT_RECORDSTATEMODE | D3DRT_RSSOFTWAREPROCESSING)) == 0 &&
                  (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0);

        m_pDDI->SetVertexShaderHW(dwHandle);
    }
    catch(HRESULT hr)
    {
        DPF_ERR("SetVertexShader failed.");
        ClearVertexShaderHandle();
        return hr;
    }
   return S_OK;
}
#endif // FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetVertexShader"

HRESULT D3DAPI
CD3DBase::GetVertexShader(LPDWORD pdwHandle)
{
    API_ENTER(this);
    D3D_ERR("GetVertexShader does not work in pure-device. GetVertexShader failed.");
    return D3DERR_INVALIDCALL;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DeleteVertexShader"

HRESULT D3DAPI
CD3DBase::DeleteVertexShader(DWORD dwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    // Validate Parameters
    if (dwHandle == 0)
    {
        DPF_ERR( "Cannot delete a NULL vertex shader handle." );
        return D3DERR_INVALIDCALL;
    }
    if (D3DVSD_ISLEGACY(dwHandle))
    {
        DPF_ERR( "Cannot delete a legacy vertex shader handle (FVF ?)." );
        return D3DERR_INVALIDCALL;
    }
#endif
    if( m_pVShaderArray->GetObject(dwHandle) == NULL )
    {
        DPF_ERR( "Cannot delete a vertex shader handle that does not exist." );
        return D3DERR_INVALIDCALL;
    }
    try
    {
        DeleteVertexShaderI(dwHandle);

        // Release handle and delete shader object
        m_pVShaderArray->ReleaseHandle(dwHandle, TRUE);
    }
    catch(HRESULT hr)
    {
        DPF_ERR("DeleteVertexShader failed.");
        return hr;
    }

    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetVertexShaderConstant"

HRESULT D3DAPI
CD3DBase::SetVertexShaderConstant(DWORD Register,
                                  CONST VOID* pData,
                                  DWORD count)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    // Validate Parameters
    if (!VALID_PTR(pData, 4* sizeof(DWORD) * count))
    {
        D3D_ERR("Invalid constant data pointer. SetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((GetD3DCaps()->VertexShaderVersion == D3DVS_VERSION(0,0)) &&
        (BehaviorFlags() & (D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE)))
    {
        D3D_ERR("No programmable vertex shaders are supported by this device. SetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    UINT ValidationCount;
    if (BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING)
        ValidationCount = max(m_MaxVertexShaderConst, D3DVS_CONSTREG_MAX_V1_1);
    else
    if (BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING)
        ValidationCount = D3DVS_CONSTREG_MAX_V1_1;
    else
        ValidationCount = m_MaxVertexShaderConst;
    if((Register + count) > ValidationCount)
    {
        D3D_ERR("Not that many constant registers in the vertex machine. SetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertVertexShaderConstant(Register,
                                                     pData,
                                                     count);
        else
            SetVertexShaderConstantI(Register, pData, count);
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetVertexShaderConstant failed.");
        return hr;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetVertexShaderConstantFast"

HRESULT D3DAPI
CD3DBase::SetVertexShaderConstantFast(DWORD Register,
                                      CONST VOID* pData,
                                      DWORD count)
{

#if DBG
    // Validate Parameters
    if (!VALID_PTR(pData, 4* sizeof(DWORD) * count))
    {
        D3D_ERR("Invalid constant data pointer. SetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((GetD3DCaps()->VertexShaderVersion == D3DVS_VERSION(0,0)) &&
        (BehaviorFlags() & (D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE)))
    {
        D3D_ERR("No programmable vertex shaders are supported by this device. SetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    UINT ValidationCount;
    if (BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING)
        ValidationCount = max(m_MaxVertexShaderConst, D3DVS_CONSTREG_MAX_V1_1);
    else
    if (BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING)
        ValidationCount = D3DVS_CONSTREG_MAX_V1_1;
    else
        ValidationCount = m_MaxVertexShaderConst;
    if((Register + count) > ValidationCount)
    {
        D3D_ERR("Not that many constant registers in the vertex machine. SetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    DXGASSERT((m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE) == 0 &&
              (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0 &&
              (BehaviorFlags() & D3DCREATE_PUREDEVICE) != 0);
    try
    {
        m_pDDI->SetVertexShaderConstant(Register, pData, count);
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetVertexShaderConstant failed.");
        return hr;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetVertexShaderConstantI"

void
CD3DBase::SetVertexShaderConstantI(DWORD dwRegister, CONST VOID* pData, DWORD count)
{
    m_pDDI->SetVertexShaderConstant(dwRegister, pData, count);
}
//-----------------------------------------------------------------------------
//
// Pixel Shaders
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CreatePixelShader"

HRESULT D3DAPI
CD3DBase::CreatePixelShader(CONST DWORD* pdwFunction, LPDWORD pdwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    // Validate Parameters
    // WARNING!! sizeof(LPVOID) is not good enough
    if (!VALID_PTR(pdwFunction, sizeof(LPVOID)))
    {
        D3D_ERR("Invalid shader function pointer. CreatePixelShader failed.");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_WRITEPTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR("Invalid handle pointer. CreatePixelShader failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    DWORD dwHandle = m_pPShaderArray->CreateNewHandle(NULL);
    HRESULT ret = S_OK;
    if (dwHandle == __INVALIDHANDLE)
    {
        D3D_ERR("Error in creating shader handle. CreatePixelShader failed.");
        return E_OUTOFMEMORY;
    }
    CPShader *pShader = new CPShader();
    if (pShader == NULL)
    {
        D3D_ERR("Cannot allocate memory for internal pixel shader object. CreatePixelShader failed.");
        return E_OUTOFMEMORY;
    }
    try
    {
        if( !ValidatePixelShaderInternal(pdwFunction, GetD3DCaps()) )
        {
            ret = D3DERR_INVALIDCALL;
            goto error;
        }
        DWORD dwVersion = *pdwFunction;

        if ( (0xff == D3DSHADER_VERSION_MAJOR(dwVersion) )
            && (m_dwRuntimeFlags & D3DRT_DISALLOWNVPSHADERS) )
        {
            D3D_ERR("Disallowing non-versioned pixel shader.");
            ret = D3DERR_INVALIDCALL;
            goto error;
        }

        // Even for the D3DCREATE_PUREDEVICE we create a shader object for validation
        pShader->Initialize(pdwFunction, GetDeviceType());
        m_pPShaderArray->SetObject(dwHandle, pShader);

        try
        {
            m_pDDI->CreatePixelShader(pShader->m_pCode,
                                      pShader->m_dwCodeSize, dwHandle);
        }

        catch(HRESULT hr)
        {
            if( 0xff == D3DSHADER_VERSION_MAJOR(dwVersion) )
            {
                // This is a ff.ff shader. The driver is allowed to fail this.
                D3D_INFO(0, "Driver failed the creation of this non-versioned pixel "
                         "shader");
                throw D3DERR_DRIVERINVALIDCALL;
            }
            else
            {
                OutputDebugString( "Driver failed to create the requested "
                                   "pixel shader. Please contact your "
                                   "friendly video card manufacturer "
                                   "to inquire why this problem was "
                                   "encountered.\n" );
                OutputDebugString( "\n" );

                // NOTE! Prefix will catch this as a bug, but it is entirely
                // intentional
                *(DWORD *)0 = 0;
            }
        }
    }
    catch(HRESULT hr)
    {
        ret = hr;
        goto error;
    }

    *pdwHandle = dwHandle;
    return S_OK;

error:

    D3D_ERR("CreatePixelShader failed.");
    delete pShader;
    m_pPShaderArray->ReleaseHandle(dwHandle, FALSE);
    return ret;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetPixelShader"

HRESULT D3DAPI
CD3DBase::SetPixelShader(DWORD dwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary
    try
    {
#if DBG
        CheckPixelShaderHandle(dwHandle);
#endif
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertPixelShader(dwHandle);
        else
            SetPixelShaderFast(dwHandle);
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetPixelShader failed.");
        m_dwCurrentPixelShaderHandle = 0;
        return hr;
    }
   return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetPixelShaderFast"

HRESULT D3DAPI
CD3DBase::SetPixelShaderFast(DWORD dwHandle)
{
    try
    {
#if DBG
        CheckPixelShaderHandle(dwHandle);
#endif
        // m_dwCurrentPixelShaderHandle is not defined for pure device
        m_pDDI->SetPixelShader(dwHandle);
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetPixelShader failed.");
        m_dwCurrentPixelShaderHandle = 0;
        return hr;
    }
   return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetPixelShader"

HRESULT D3DAPI
CD3DBase::GetPixelShader(LPDWORD pdwHandle)
{
    API_ENTER(this);
    D3D_ERR("GetPixelShader is not available for PUREDEVICE. GetPixelShader failed.");
    return D3DERR_INVALIDCALL;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DeletePixelShader"

HRESULT D3DAPI
CD3DBase::DeletePixelShader(DWORD dwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    // Validate Parameters
    CPShader* pShader = (CPShader*)m_pPShaderArray->GetObject(dwHandle);
    if (pShader == NULL)
    {
        D3D_ERR("Invalid pixel shader handle. DeletePixelShader failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        m_pDDI->DeletePixelShader(dwHandle);

        // Release handle and delete shader object
        m_pPShaderArray->ReleaseHandle(dwHandle, TRUE);

        // If the pixel shader is current, set an invalid shader as current
        // This is needed only for non-pure device.
        if (dwHandle == m_dwCurrentPixelShaderHandle)
        {
            m_dwCurrentPixelShaderHandle = 0x0;
        }
    }
    catch(HRESULT hr)
    {
        D3D_ERR("DeletePixelShader failed.");
        return hr;
    }

    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetPixelShaderConstant"

HRESULT D3DAPI
CD3DBase::SetPixelShaderConstant(DWORD Register, CONST VOID* pData,
                                 DWORD count)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    // Validate Parameters
    if (!VALID_PTR(pData, sizeof(DWORD) * count))
    {
        D3D_ERR("Invalid constant data pointer. SetPixelShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    if(Register >= D3DPS_CONSTREG_MAX_DX8)
    {
        D3D_ERR("Invalid Constant Register number. SetPixelShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    if( (Register + count) > D3DPS_CONSTREG_MAX_DX8 )
    {
        D3D_ERR("Not that many constant registers in the pixel machine. SetPixelShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertPixelShaderConstant(Register,
                                                    pData,
                                                    count);
        else
            SetPixelShaderConstantFast(Register, pData, count);
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetPixelShaderConstant failed.");
        return hr;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetPixelShaderConstantFast"

HRESULT D3DAPI
CD3DBase::SetPixelShaderConstantFast(DWORD Register, CONST VOID* pData,
                                     DWORD count)
{

#if DBG
    // Validate Parameters
    if (!VALID_PTR(pData, sizeof(DWORD) * count))
    {
        D3D_ERR("Invalid constant data pointer. SetPixelShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    if(Register >= D3DPS_CONSTREG_MAX_DX8)
    {
        D3D_ERR("Invalid Constant Register number. SetPixelShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    if( (Register + count) > D3DPS_CONSTREG_MAX_DX8 )
    {
        D3D_ERR("Not that many constant registers in the pixel machine. SetPixelShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        m_pDDI->SetPixelShaderConstant(Register, pData, count);
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetPixelShaderConstant failed.");
        return hr;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetPixelShaderConstantI"

void
CD3DBase::GetPixelShaderConstantI(DWORD dwRegister, DWORD count, LPVOID pData)
{
    // Should never be called.
    DDASSERT( FALSE );
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::ValidateDraw"

void CD3DBase::ValidateDraw(D3DPRIMITIVETYPE primType,
                            UINT StartVertex,
                            UINT PrimitiveCount,
                            UINT NumVertices,
                            BOOL bIndexPrimitive,
                            BOOL bUserMemPrimitive)
{
#if DBG
    if ((m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE) == 0)
    {
        D3D_THROW_FAIL("Need to call BeginScene before rendering.");
    }
    if (primType < D3DPT_POINTLIST || primType > D3DPT_TRIANGLEFAN)
    {
        D3D_THROW_FAIL("Invalid primitive type");
    }
    if (primType == D3DPT_POINTLIST && bIndexPrimitive)
    {
        D3D_THROW_FAIL("Indexed point lists are not supported");
    }
    if (PrimitiveCount == 0)
    {
        D3D_THROW_FAIL("Invalid primitive count");
    }
    // Number of vertices is always greater than or equal number of primitives
    if (max(NumVertices, PrimitiveCount) > this->GetD3DCaps()->MaxPrimitiveCount)
    {
        D3D_THROW_FAIL("Primitive count or vertex count is too big. Check device caps.");
    }
    for (DWORD dwStage = 0; dwStage < m_dwMaxTextureBlendStages; dwStage++)
    {
        if (m_lpD3DMappedTexI[dwStage] != 0)
        {
            if (m_lpD3DMappedTexI[dwStage]->IsTextureLocked())
            {
                D3D_THROW_FAIL("Cannot render when currently set textures are locked.");
            }
        }
    }
#endif //DBG
}
//-----------------------------------------------------------------------------
// Check if indices are within the range. We do it only for software
// processing because we do not want to read video memory
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CheckIndices"

void CD3DBase::CheckIndices(CONST BYTE* pIndices, UINT NumIndices,
                            UINT StartIndex,
                            UINT MinIndex, UINT NumVertices, UINT IndexStride)
{
    // Check if indices are within the range. We do it only for software
    // processing because we do not want to read video memory
    if (pIndices == NULL)
    {
        D3D_THROW_FAIL("Invalid index data pointer");
    }
    UINT MaxIndex = MinIndex + NumVertices - 1;
    pIndices += IndexStride * StartIndex;
    for (DWORD i = 0; i < NumIndices; i++)
    {
        DWORD dwIndex = IndexStride == 4?
                        *(DWORD*)pIndices : *(WORD*)pIndices;
        pIndices += IndexStride;
        if (dwIndex < MinIndex || dwIndex > MaxIndex)
        {
            D3D_ERR("Invalid index in the index stream: %d", dwIndex);
            D3D_THROW_FAIL("");
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawPrimitive"

HRESULT D3DAPI
CD3DBase::DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                        UINT StartVertex,
                        UINT PrimitiveCount)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
#if DBG
        UINT nVer = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
        try
        {
            ValidateDraw(PrimitiveType, StartVertex, PrimitiveCount, nVer,
                         FALSE, FALSE);
        }
        catch (HRESULT ret)
        {
            D3D_ERR("DrawPrimitive failed.");
            return ret;
        }

#endif // DBG
        if (PrimitiveType != D3DPT_POINTLIST)
        {
            (*m_pfnDrawPrim)(this, PrimitiveType, StartVertex, PrimitiveCount);
        }
        else
            DrawPointsI(PrimitiveType, StartVertex, PrimitiveCount);
    }
    catch (HRESULT ret)
    {
        D3D_ERR("DrawPrimitive failed.");
        m_pDDI->ClearBatch(FALSE);
        return ret;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawIndexedPrimitive"

HRESULT D3DAPI
CD3DBase::DrawIndexedPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                     UINT MinIndex, UINT NumVertices, UINT StartIndex,
                     UINT PrimitiveCount)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    try
    {
        if (NumVertices == 0)
        {
            D3D_ERR("Invalid number of vertices. DrawIndexedPrimitive failed.");
            return D3DERR_INVALIDCALL;
        }

        DWORD dwNumIndices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
        if (dwNumIndices + StartIndex > m_pIndexStream->m_dwNumVertices)
        {
            D3D_ERR("Index stream does not have required number of indices. DrawIndexedPrimitive failed.");
            return D3DERR_INVALIDCALL;
        }
        if (m_pIndexStream == NULL)
        {
            D3D_ERR("No index stream object. Perhaps something went wrong at a mode-change. DrawIndexedPrimitive failed.");
            return D3DERR_INVALIDCALL;
        }
        if (m_pIndexStream->m_pVBI == NULL)
        {
            D3D_ERR("No valid index stream currently set. DrawIndexedPrimitive failed.");
            return D3DERR_INVALIDCALL;
        }
        ValidateDraw(PrimitiveType, MinIndex + m_pIndexStream->m_dwBaseIndex,
                     PrimitiveCount, NumVertices, TRUE, FALSE);
        if (m_pIndexStream->m_pVBI->GetBufferDesc()->Pool == D3DPOOL_SYSTEMMEM &&
            (m_pIndexStream->m_pVBI->GetBufferDesc()->Usage & D3DUSAGE_SOFTWAREPROCESSING) != 0)
        {
            CheckIndices((BYTE*)m_pIndexStream->m_pVBI->Data(),
                         dwNumIndices,
                         StartIndex, MinIndex, NumVertices,
                         m_pIndexStream->m_dwStride);
        }
    }
    catch(HRESULT hr)
    {
        D3D_ERR("DrawIndexedPrimitive failed.");
        return hr;
    }
#endif //DBG
    try
    {
        (*m_pfnDrawIndexedPrim)(this, PrimitiveType,
                                m_pIndexStream->m_dwBaseIndex,
                                MinIndex, NumVertices, StartIndex,
                                PrimitiveCount);
    }
    catch (HRESULT ret)
    {
        D3D_ERR("DrawIndexedPrimitive failed.");
        m_pDDI->ClearBatch(FALSE);
        return ret;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawRectPatch"

HRESULT D3DAPI CD3DBase::DrawRectPatch(UINT Handle, CONST FLOAT *pNumSegs,
                                       CONST D3DRECTPATCH_INFO *pSurf)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if ((m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE) == 0)
    {
        D3D_ERR("Need to call BeginScene before rendering.");
        return (D3DERR_INVALIDCALL);
    }
    if ((m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) != 0)
    {
        D3D_ERR("There is no emulation support for RT patches, hence only hardware device or hardware mode is legal. DrawRectPatch failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0)
    {
        CD3DHal* pDevice = static_cast<CD3DHal*>(this);
        if (!D3DVSD_ISLEGACY(pDevice->m_dwCurrentShaderHandle))
        {
            if (pDevice->m_pv->dwDeviceFlags & D3DDEV_VERTEXSHADERS)
            {
                for (DWORD i=0; i < D3DHAL_TSS_MAXSTAGES; i++)
                {
                    if (pDevice->tsstates[i][D3DTSS_TEXCOORDINDEX] != i)
                    {
                        D3D_ERR("Stage %d - Texture coordinate index in the stage "
                                "must be equal to the stage index when programmable"
                                " vertex pipeline is used", i);
                        return D3DERR_INVALIDCALL;
                    }
                    DWORD TexTransformFlags = pDevice->tsstates[i][D3DTSS_TEXTURETRANSFORMFLAGS];
                    if ((TexTransformFlags & ~D3DTTFF_PROJECTED) != D3DTTFF_DISABLE)
                    {
                        D3D_ERR("Stage %d - Count in D3DTSS_TEXTURETRANSFORMFLAGS "
                                "must be 0 when programmable pipeline is used", i);
                        return D3DERR_INVALIDCALL;
                    }
                }
            }
        }
    }

    if ((GetD3DCaps()->DevCaps & D3DDEVCAPS_RTPATCHES) == 0)
    {
        D3D_ERR("RT patches unsupported on current device. DrawRectPatch failed.");
        return D3DERR_INVALIDCALL;
    }

    if (Handle == 0 && pSurf == 0)
    {
        D3D_ERR("Handle and patch specification cannot be both zero. DrawRectPatch failed.");
        return D3DERR_INVALIDCALL;
    }

    if (pSurf != 0)
    {
        if (!VALID_PTR(pSurf, sizeof(D3DRECTPATCH_INFO)))
        {
            D3D_ERR("Invalid patch information pointer. DrawRectPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Order != D3DORDER_LINEAR &&
            pSurf->Order != D3DORDER_CUBIC &&
            pSurf->Order != D3DORDER_QUINTIC)
        {
            D3D_ERR("Order not supported. DrawRectPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Order == D3DORDER_QUINTIC && (GetD3DCaps()->DevCaps & D3DDEVCAPS_QUINTICRTPATCHES) == 0)
        {
            D3D_ERR("Quintic patches not supported on this device. DrawRectPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Basis != D3DBASIS_BEZIER &&
            pSurf->Basis != D3DBASIS_BSPLINE &&
            pSurf->Basis != D3DBASIS_INTERPOLATE)
        {
            D3D_ERR("Basis not supported. DrawRectPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Basis == D3DBASIS_BEZIER)
        {
            if (pSurf->Width != (DWORD)pSurf->Order + 1 ||
                pSurf->Height != (DWORD)pSurf->Order + 1)
            {
                D3D_ERR("Bezier patch must have correct dimensions to match order. DrawRectPatch failed.");
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            if (pSurf->Width <= (DWORD)pSurf->Order ||
                pSurf->Height <= (DWORD)pSurf->Order)
            {
                D3D_ERR("Patch dimensions too small for the order. DrawRectPatch failed.");
                return D3DERR_INVALIDCALL;
            }
            if (pSurf->Basis == D3DBASIS_INTERPOLATE && pSurf->Order != D3DORDER_CUBIC)
            {
                D3D_ERR("Only bicubic interpolating splines supported. DrawRectPatch failed.");
                return D3DERR_INVALIDCALL;
            }
        }

        if (pSurf->Stride == 0)
        {
            D3D_ERR("Stride cannot be zero. DrawRectPatch failed.");
            return D3DERR_INVALIDCALL;
        }

        if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0)
        {
            try
            {
                static_cast<CD3DHal*>(this)->ValidateRTPatch();
            }
            catch(HRESULT ret)
            {
                D3D_ERR("DrawRectPatch failed.");
                return ret;
            }
        }

        if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0 && Handle != 0)
        {
            // Need to snapshot current Vshader in the Handle table
            HRESULT hr = m_pRTPatchValidationInfo->Grow(Handle);
            if (FAILED(hr))
            {
                D3D_ERR("Could not grow handle table. DrawRectPatch failed.");
                return hr;
            }
            if ((*m_pRTPatchValidationInfo)[Handle].m_pObj == 0)
            {
                (*m_pRTPatchValidationInfo)[Handle].m_pObj = new CRTPatchValidationInfo;
                if ((*m_pRTPatchValidationInfo)[Handle].m_pObj == 0)
                {
                    D3D_ERR("Out of memory growing handle table. DrawRectPatch failed.");
                    return E_OUTOFMEMORY;
                }
            }
            static_cast<CRTPatchValidationInfo*>((*m_pRTPatchValidationInfo)[Handle].m_pObj)->m_ShaderHandle = m_dwCurrentShaderHandle;
        }
    }
    else
    {
        if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0 && Handle != 0)
        {
            if (Handle >= m_pRTPatchValidationInfo->GetSize())
            {
                D3D_ERR("Cannot draw a patch without any information. DrawRectPatch failed.");
                return D3DERR_INVALIDCALL;
            }
            if ((*m_pRTPatchValidationInfo)[Handle].m_pObj == 0)
            {
                D3D_ERR("Cannot draw a patch without any information. DrawRectPatch failed.");
                return D3DERR_INVALIDCALL;
            }
            if (static_cast<CRTPatchValidationInfo*>((*m_pRTPatchValidationInfo)[Handle].m_pObj)->m_ShaderHandle != m_dwCurrentShaderHandle)
            {
                D3D_ERR("Cannot set a vertex shader different from the one set when the patch was first created. DrawRectPatch failed.");
                return D3DERR_INVALIDCALL;
            }
        }
    }
    if (pNumSegs != 0)
    {
        if (!VALID_PTR(pNumSegs, sizeof(FLOAT) * 4))
        {
            D3D_ERR("Invalid pointer to array of 4 floats (NumSegs). DrawRectPatch failed.");
            return D3DERR_INVALIDCALL;
        }
    }
#endif

    try
    {
        m_pDDI->DrawRectPatch(Handle, pSurf, pNumSegs);
    }
    catch(HRESULT ret)
    {
        D3D_ERR("DrawRectPatch failed.");
        return ret;
    }

    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawTriPatch"

HRESULT D3DAPI CD3DBase::DrawTriPatch(UINT Handle, CONST FLOAT *pNumSegs,
                                      CONST D3DTRIPATCH_INFO *pSurf)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if ((m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE) == 0)
    {
        D3D_ERR("Need to call BeginScene before rendering.");
        return (D3DERR_INVALIDCALL);
    }
    if ((m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) != 0)
    {
        D3D_ERR("There is no emulation support for RT patches, hence only hardware device or hardware mode is legal. DrawTriPatch failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0)
    {
        CD3DHal* pDevice = static_cast<CD3DHal*>(this);
        if (!D3DVSD_ISLEGACY(pDevice->m_dwCurrentShaderHandle))
        {
            if (pDevice->m_pv->dwDeviceFlags & D3DDEV_VERTEXSHADERS)
            {
                for (DWORD i=0; i < D3DHAL_TSS_MAXSTAGES; i++)
                {
                    if (pDevice->tsstates[i][D3DTSS_TEXCOORDINDEX] != i)
                    {
                        D3D_ERR("Stage %d - Texture coordinate index in the stage "
                                "must be equal to the stage index when programmable"
                                " vertex pipeline is used", i);
                        return D3DERR_INVALIDCALL;
                    }
                    DWORD TexTransformFlags = pDevice->tsstates[i][D3DTSS_TEXTURETRANSFORMFLAGS];
                    if ((TexTransformFlags & ~D3DTTFF_PROJECTED) != D3DTTFF_DISABLE)
                    {
                        D3D_ERR("Stage %d - Count in D3DTSS_TEXTURETRANSFORMFLAGS "
                                "must be 0 when programmable pipeline is used", i);
                        return D3DERR_INVALIDCALL;
                    }
                }
            }
        }
    }


    if ((GetD3DCaps()->DevCaps & D3DDEVCAPS_RTPATCHES) == 0)
    {
        D3D_ERR("RT patches unsupported on current device. DrawTriPatch failed.");
        return D3DERR_INVALIDCALL;
    }

    if (Handle == 0 && pSurf == 0)
    {
        D3D_ERR("Handle and patch specification cannot be both zero. DrawTriPatch failed.");
        return D3DERR_INVALIDCALL;
    }

    if (pSurf != 0)
    {
        if (!VALID_PTR(pSurf, sizeof(D3DTRIPATCH_INFO)))
        {
            D3D_ERR("Invalid patch information pointer. DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Order != D3DORDER_LINEAR &&
            pSurf->Order != D3DORDER_CUBIC &&
            pSurf->Order != D3DORDER_QUINTIC)
        {
            D3D_ERR("Order not supported. DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Order == D3DORDER_QUINTIC && (GetD3DCaps()->DevCaps & D3DDEVCAPS_QUINTICRTPATCHES) == 0)
        {
            D3D_ERR("Quintic patches not supported on this device. DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Basis != D3DBASIS_BEZIER)
        {
            D3D_ERR("Only Bezier basis is supported. DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Order == D3DORDER_LINEAR && pSurf->NumVertices != 3)
        {
            D3D_ERR("Only three vertices supported with linear order. DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        else if (pSurf->Order == D3DORDER_CUBIC && pSurf->NumVertices != 10)
        {
            D3D_ERR("Only ten vertices supported with cubic order. DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        else if (pSurf->Order == D3DORDER_QUINTIC && pSurf->NumVertices != 21)
        {
            D3D_ERR("Only 21 vertices supported with quintic order. DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0)
        {
            try
            {
                static_cast<CD3DHal*>(this)->ValidateRTPatch();
            }
            catch(HRESULT ret)
            {
                D3D_ERR("DrawTriPatch failed.");
                return ret;
            }
        }
        if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0 && Handle != 0)
        {
            // Need to snapshot current Vshader in the Handle table
            HRESULT hr = m_pRTPatchValidationInfo->Grow(Handle);
            if (FAILED(hr))
            {
                D3D_ERR("Could not grow handle table. DrawTriPatch failed.");
                return hr;
            }
            if ((*m_pRTPatchValidationInfo)[Handle].m_pObj == 0)
            {
                (*m_pRTPatchValidationInfo)[Handle].m_pObj = new CRTPatchValidationInfo;
                if ((*m_pRTPatchValidationInfo)[Handle].m_pObj == 0)
                {
                    D3D_ERR("Out of memory growing handle table. DrawTriPatch failed.");
                    return E_OUTOFMEMORY;
                }
            }
            static_cast<CRTPatchValidationInfo*>((*m_pRTPatchValidationInfo)[Handle].m_pObj)->m_ShaderHandle = m_dwCurrentShaderHandle;
        }
    }
    else
    {
        if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0 && Handle != 0)
        {
            if (Handle >= m_pRTPatchValidationInfo->GetSize())
            {
                D3D_ERR("Cannot draw a patch without any information. DrawTriPatch failed.");
                return D3DERR_INVALIDCALL;
            }
            if ((*m_pRTPatchValidationInfo)[Handle].m_pObj == 0)
            {
                D3D_ERR("Cannot draw a patch without any information. DrawTriPatch failed.");
                return D3DERR_INVALIDCALL;
            }
            if (static_cast<CRTPatchValidationInfo*>((*m_pRTPatchValidationInfo)[Handle].m_pObj)->m_ShaderHandle != m_dwCurrentShaderHandle)
            {
                D3D_ERR("Cannot set a vertex shader different from the one set when the patch was first created. DrawTriPatch failed.");
                return D3DERR_INVALIDCALL;
            }
        }
    }
    if (pNumSegs != 0)
    {
        if (!VALID_PTR(pNumSegs, sizeof(FLOAT) * 3))
        {
            D3D_ERR("Invalid pointer to array of 3 floats (NumSegs). DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
    }
#endif

    try
    {
        m_pDDI->DrawTriPatch(Handle, pSurf, pNumSegs);
    }
    catch(HRESULT ret)
    {
        D3D_ERR("DrawTriPatch failed.");
        return ret;
    }

    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DeletePatch"

HRESULT D3DAPI CD3DBase::DeletePatch(UINT Handle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if ((GetD3DCaps()->DevCaps & D3DDEVCAPS_RTPATCHES) == 0)
    {
        D3D_ERR("High order surfaces unsupported on current device. DeletePatch failed.");
        return D3DERR_INVALIDCALL;
    }

    if (Handle == 0)
    {
        return S_OK;
    }

#if DBG
    if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0)
    {
        if (Handle >= m_pRTPatchValidationInfo->GetSize())
        {
            D3D_ERR("Attempt to delete non-existent patch. DeletePatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if ((*m_pRTPatchValidationInfo)[Handle].m_pObj == 0)
        {
            D3D_ERR("Attempt to delete non-existent patch. DeletePatch failed.");
            return D3DERR_INVALIDCALL;
        }
        delete (*m_pRTPatchValidationInfo)[Handle].m_pObj;
        (*m_pRTPatchValidationInfo)[Handle].m_pObj = 0;
    }
#endif // DBG

    try
    {
        m_pDDI->SetRenderState((D3DRENDERSTATETYPE)D3DRS_DELETERTPATCH, Handle);
    }
    catch(HRESULT ret)
    {
        D3D_ERR("DeletePatch failed.");
        return ret;
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawPrimitiveUP"

HRESULT D3DAPI
CD3DBase::DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                          UINT PrimitiveCount,
                          CONST VOID *pVertexStreamZeroData,
                          UINT VertexStreamZeroStride)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    m_dwRuntimeFlags |= D3DRT_USERMEMPRIMITIVE;
    try
    {
        if (m_pStream[0].m_pVB)
        {
            m_pDDI->VBReleased(m_pStream[0].m_pVB);
            m_pStream[0].m_pVB->DecrementUseCount();
            m_pStream[0].m_pVB = NULL;
        }
        m_pStream[0].m_pData = (BYTE*)pVertexStreamZeroData;
        m_pStream[0].m_dwStride = VertexStreamZeroStride;
#if DBG
        UINT nVer = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
        if (!VALID_PTR(pVertexStreamZeroData, nVer*VertexStreamZeroStride))
        {
            D3D_THROW_FAIL("Invalid input vertex stream pointer");
        }
        m_pStream[0].m_dwSize = nVer * VertexStreamZeroStride;
        m_pStream[0].m_dwNumVertices = nVer;
        try
        {
            ValidateDraw(PrimitiveType, 0, PrimitiveCount, nVer, FALSE, TRUE);
        }
        catch (HRESULT ret)
        {
            m_dwRuntimeFlags &= ~D3DRT_USERMEMPRIMITIVE;
            return ret;
        }
#endif // DBG
        DrawPrimitiveUPI(PrimitiveType, PrimitiveCount);
        // Invalidate stream zero
        m_pStream[0].m_pData = NULL;
#if DBG
        m_pStream[0].m_dwSize = 0;
#endif
        m_pStream[0].m_dwStride = 0;
    }
    catch (HRESULT ret)
    {
        D3D_ERR("DrawPrimitiveUP failed.");
#if DBG
        m_dwRuntimeFlags &= ~D3DRT_USERMEMPRIMITIVE;
#endif
        m_pDDI->ClearBatch(FALSE);
        return ret;
    }
    m_dwRuntimeFlags &= ~D3DRT_USERMEMPRIMITIVE;
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawPrimitiveUPI"

void CD3DBase::DrawPrimitiveUPI(D3DPRIMITIVETYPE PrimType, UINT PrimCount)
{
    m_pDDI->DrawPrimitiveUP(PrimType, PrimCount);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawIndexedPrimitiveUPI"

void
CD3DBase::DrawIndexedPrimitiveUPI(D3DPRIMITIVETYPE PrimitiveType,
                                  UINT MinVertexIndex,
                                  UINT NumVertices,
                                  UINT PrimitiveCount)
{
    m_pDDI->DrawIndexedPrimitiveUP(PrimitiveType, MinVertexIndex, NumVertices,
                                   PrimitiveCount);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawIndexedPrimitiveUP"

HRESULT D3DAPI
CD3DBase::DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                                 UINT MinIndex, UINT NumVertices,
                                 UINT PrimitiveCount,
                                 CONST VOID *pIndexData, D3DFORMAT IndexDataFormat,
                                 CONST VOID *pVertexStreamZeroData,
                                 UINT VertexStreamZeroStride)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    m_dwRuntimeFlags |= D3DRT_USERMEMPRIMITIVE;

    try
    {
        if (m_pStream[0].m_pVB)
        {
            m_pDDI->VBReleased(m_pStream[0].m_pVB);
            m_pStream[0].m_pVB->DecrementUseCount();
            m_pStream[0].m_pVB = NULL;
        }
        if (m_pIndexStream->m_pVBI)
        {
            m_pDDI->VBIReleased(m_pIndexStream->m_pVBI);
            m_pIndexStream->m_pVBI->DecrementUseCount();
            m_pIndexStream->m_pVBI = NULL;
        }
        m_pStream[0].m_pData = (BYTE*)pVertexStreamZeroData;
        m_pStream[0].m_dwStride = VertexStreamZeroStride;

        m_pIndexStream->m_pData = (BYTE*)pIndexData;
        m_pIndexStream->m_dwBaseIndex = 0;
        if (IndexDataFormat == D3DFMT_INDEX16)
            m_pIndexStream->m_dwStride = 2;
        else
        if (IndexDataFormat == D3DFMT_INDEX32)
        {
#if DBG
            if (GetD3DCaps()->MaxVertexIndex <= 0xFFFF)
                D3D_THROW(D3DERR_INVALIDCALL, "Device does not support 32-bit indices");
#endif
            m_pIndexStream->m_dwStride = 4;
        }
        else
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid index data format");
        }
#if DBG
        try
        {
            if (pVertexStreamZeroData == NULL)
            {
                D3D_THROW(D3DERR_INVALIDCALL, "Invalid vertex stream pointer");
            }
            if (pIndexData == NULL)
            {
                D3D_THROW(D3DERR_INVALIDCALL, "Invalid index data pointer");
            }
            if (NumVertices == 0)
            {
                D3D_THROW(D3DERR_INVALIDCALL, "Invalid number of vertices");
            }
            m_pStream[0].m_dwSize = NumVertices * VertexStreamZeroStride;
            m_pStream[0].m_dwNumVertices = NumVertices;

            UINT NumIndices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
            m_pIndexStream[0].m_dwSize = NumIndices * m_pIndexStream[0].m_dwStride;
            m_pIndexStream[0].m_dwNumVertices = NumIndices;
            if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
            {
                CheckIndices((BYTE*)pIndexData, NumIndices, 0, MinIndex,
                             NumVertices, m_pIndexStream->m_dwStride);
            }
            ValidateDraw(PrimitiveType, MinIndex, PrimitiveCount, NumVertices,
                         TRUE, TRUE);
        }
        catch (HRESULT ret)
        {
            D3D_ERR("DrawIndexedPrimitiveUP failed.");
            m_dwRuntimeFlags &= ~D3DRT_USERMEMPRIMITIVE;
            return ret;
        }
#endif // DBG

        DrawIndexedPrimitiveUPI(PrimitiveType, MinIndex, NumVertices, PrimitiveCount);

        // Invalidate stream zero
        m_pStream[0].m_pData = NULL;
#if DBG
        m_pStream[0].m_dwSize = 0;
#endif
        m_pStream[0].m_dwStride = 0;
        //Invalidate index stream
        m_pIndexStream[0].m_pData = NULL;
#if DBG
        m_pIndexStream[0].m_dwSize = 0;
#endif
        m_pIndexStream[0].m_dwStride = 0;
    }
    catch (HRESULT ret)
    {
        D3D_ERR("DrawIndexedPrimitiveUP failed.");
        m_dwRuntimeFlags &= ~D3DRT_USERMEMPRIMITIVE;
        m_pDDI->ClearBatch(FALSE);
        return ret;
    }
    m_dwRuntimeFlags &= ~D3DRT_USERMEMPRIMITIVE;
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawPointsI"

void
CD3DBase::DrawPointsI(D3DPRIMITIVETYPE PrimitiveType,
                         UINT StartVertex,
                         UINT PrimitiveCount)
{
    (*m_pfnDrawPrim)(this, PrimitiveType, StartVertex, PrimitiveCount);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CreateVertexShaderI"

void
CD3DBase::CreateVertexShaderI(CONST DWORD* pdwDeclaration, DWORD dwDeclSize,
                              CONST DWORD* pdwFunction, DWORD dwCodeSize,
                              DWORD dwHandle)
{
    CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
#if DBG
    if (pShader->m_dwFlags & CVShader::SOFTWARE)
    {
        D3D_THROW_FAIL("Software vertex shader cannot be created with a PUREDEVICE");
    }

#endif // DBG
    // always pass stripped version for pure hal
    m_pDDI->CreateVertexShader(pdwDeclaration, dwDeclSize,
                               pShader->m_pStrippedFuncCode,
                               pShader->m_StrippedFuncCodeSize, dwHandle,
                               pShader->m_Declaration.m_bLegacyFVF);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetVertexShaderI"

void CD3DBase::SetVertexShaderI(DWORD dwHandle)
{
#if DBG
    CheckVertexShaderHandle(dwHandle);
    if (!D3DVSD_ISLEGACY(dwHandle))
    {
        CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
        if (pShader->m_dwFlags & CVShader::SOFTWARE)
        {
            D3D_THROW_FAIL("Vertex shader created in software mode cannot be used in hardware mode");
        }
    }
#endif // DBG
    m_pDDI->SetVertexShaderHW(dwHandle);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DeleteVertexShaderI"

void CD3DBase::DeleteVertexShaderI(DWORD dwHandle)
{
    m_pDDI->DeleteVertexShader(dwHandle);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::Clear"

#define bDoRGBClear ((dwFlags & D3DCLEAR_TARGET)!=0)
#define bDoZClear   ((dwFlags & D3DCLEAR_ZBUFFER)!=0)
#define bDoStencilClear ((dwFlags & D3DCLEAR_STENCIL)!=0)

// Maximum number of clear rectangles considered legal.
// This limit is set by NT kernel for Clear2 callback
const DWORD MAX_CLEAR_RECTS  = 0x1000;

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::ClearI"

void
CD3DBase::ClearI(DWORD dwCount,
                 CONST D3DRECT* rects,
                 DWORD dwFlags,
                 D3DCOLOR dwColor,
                 D3DVALUE dvZ,
                 DWORD dwStencil)
{
    if (rects == NULL)
        dwCount = 0;

    // We do not cull rects against viewport, so let the driver do it
    dwFlags |= D3DCLEAR_COMPUTERECTS;
    m_pDDI->Clear(dwFlags, dwCount, (LPD3DRECT)rects, dwColor, dvZ, dwStencil);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::Clear"

HRESULT D3DAPI
CD3DBase::Clear(DWORD dwCount,
                 CONST D3DRECT* rects,
                 DWORD dwFlags,
                 D3DCOLOR dwColor,
                 D3DVALUE dvZ,
                 DWORD dwStencil)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (IsBadReadPtr(rects, dwCount * sizeof(D3DRECT)))
    {
        D3D_ERR("Invalid rects pointer. Clear failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        HRESULT err;
        LPDDPIXELFORMAT pZPixFmt=NULL;

        if (dwCount > MAX_CLEAR_RECTS)
        {
            D3D_ERR("Cannot support more than 64K rectangles. Clear failed.");
            return D3DERR_INVALIDCALL;
        }
        if (!(GetD3DCaps()->RasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR))
        {
            if (bDoStencilClear||bDoZClear)
            {
                if (this->ZBuffer()==NULL)
                {
                    // unlike Clear(), specifying a Zbuffer-clearing flag without a zbuffer will
                    // be considered an error
#if DBG
                    if (bDoZClear)
                    {
                        D3D_ERR("Invalid flag D3DCLEAR_ZBUFFER: no zbuffer is associated with device. Clear failed.");
                    }
                    if (bDoStencilClear)
                    {
                        D3D_ERR("Invalid flag D3DCLEAR_STENCIL: no zbuffer is associated with device. Clear failed.");
                    }
#endif
                    return D3DERR_INVALIDCALL;
                }
                if (bDoStencilClear)
                {
                    D3DSURFACE_DESC desc = (this->ZBuffer())->InternalGetDesc();
                    if (!CPixel::IsIHVFormat(desc.Format) &&
                        !CPixel::HasStencilBits(desc.Format))
                    {
                        D3D_ERR("Invalid flag D3DCLEAR_STENCIL; current zbuffer's pixel format doesnt support stencil bits. Clear failed.");
                        return D3DERR_INVALIDCALL;
                    }
                }
            }
        }
        if (!(dwFlags & (D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL)))
        {
            D3D_ERR("Flags not valid. Clear failed.");
            return D3DERR_INVALIDCALL;
        }

        // bad clear values just cause wacky results but no crashes, so OK to allow in retail bld

        DDASSERT(!bDoZClear || ((dvZ>=0.0) && (dvZ<=1.0)));
        DDASSERT(!bDoStencilClear || !pZPixFmt || (dwStencil <= (DWORD)((1<<pZPixFmt->dwStencilBitDepth)-1)));

        ClearI(dwCount, rects, dwFlags, dwColor, dvZ, dwStencil);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        D3D_ERR("Clear failed.");
        return ret;
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::FlushStatesNoThrow"
void __declspec(nothrow) CD3DBase::FlushStatesNoThrow()
{
    try
    {
        DXGASSERT(m_pDDI);
        m_pDDI->FlushStates();
    }
    catch(HRESULT hr)
    {
        DPF_ERR("Driver failed a command batch will synchronizing a synchronous call with the command stream. (No error will be returned to the app)");
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::TexBlt"
HRESULT __declspec(nothrow) CD3DBase::TexBlt(CBaseTexture *pDst,
                                             CBaseTexture *pSrc,
                                             POINT        *pPoint,
                                             RECTL        *pRect)
{
    // Get the draw prim handles
    DWORD dwSrc = pSrc->BaseDrawPrimHandle();

    DWORD dwDst = 0;
    if (pDst)
    {
        dwDst = pDst->DriverAccessibleDrawPrimHandle();
    }

    // Insert the tokens now
    try
    {
        m_pDDI->TexBlt(dwDst, dwSrc, pPoint, pRect);
    }
    catch(HRESULT ret)
    {
        return ret;
    }

    // If successful, batch the source and dest
    // For the source, we want to call BatchBase since
    // we want to batch the backing (or sysmem) texture
    // rather than the promoted one.
    pSrc->BatchBase();
    if (pDst != NULL)
    {
        pDst->Batch();
    }

    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CubeTexBlt"

// Very similar function to TexBlt except that
// this is done for cube-maps which are special since we
// need to send different handles for each face
HRESULT __declspec(nothrow) CD3DBase::CubeTexBlt(CBaseTexture *pDstParent,
                                                 CBaseTexture *pSrcParent,
                                                 DWORD         dwDestFaceHandle,
                                                 DWORD         dwSrcFaceHandle,
                                                 POINT        *pPoint,
                                                 RECTL        *pRect)
{
    // CubeTexBlt is not overloaded for use with PreLoad semantics
    // so we should always have a source and a dest
    DXGASSERT(pDstParent);
    DXGASSERT(pSrcParent);

    // Insert the tokens now
    try
    {
        m_pDDI->TexBlt(dwDestFaceHandle, dwSrcFaceHandle, pPoint, pRect);
    }
    catch(HRESULT ret)
    {
        return ret;
    }

    // If successful, batch the parents of the source and dest
    // For the source, we want to call BatchBase since
    // we want to batch the backing (or sysmem) texture
    // rather than the promoted one.
    pSrcParent->BatchBase();
    pDstParent->Batch();

    return D3D_OK;
}


//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::VolBlt"
HRESULT __declspec(nothrow)
CD3DBase::VolBlt(CBaseTexture *lpDst, CBaseTexture* lpSrc, DWORD dwDestX,
                 DWORD dwDestY, DWORD dwDestZ, D3DBOX *pBox)
{
    try
    {
        m_pDDI->VolBlt(lpDst, lpSrc, dwDestX, dwDestY, dwDestZ, pBox);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::BufBlt"
HRESULT __declspec(nothrow)
CD3DBase::BufBlt(CBuffer *lpDst, CBuffer* lpSrc, DWORD dwOffset,
                 D3DRANGE* pRange)
{
    try
    {
        m_pDDI->BufBlt(lpDst, lpSrc, dwOffset, pRange);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetPriority"

HRESULT __declspec(nothrow) CD3DBase::SetPriority(CResource *pRes, DWORD dwPriority)
{
    try
    {
        m_pDDI->SetPriority(pRes, dwPriority);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTexLOD"

HRESULT __declspec(nothrow) CD3DBase::SetTexLOD(CBaseTexture *pTex, DWORD dwLOD)
{
    try
    {
        m_pDDI->SetTexLOD(pTex, dwLOD);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::AddDirtyRect"

HRESULT __declspec(nothrow) CD3DBase::AddDirtyRect(CBaseTexture *pTex, CONST RECTL *pRect)
{
    DXGASSERT(pTex->IsD3DManaged() == 0);
    DXGASSERT(pTex->GetBufferDesc()->Pool == D3DPOOL_MANAGED);
    DXGASSERT((GetD3DCaps()->Caps2 & DDCAPS2_CANMANAGERESOURCE) != 0);
    try
    {
        m_pDDI->AddDirtyRect(pTex->BaseDrawPrimHandle(), pRect);
    }
    catch(HRESULT ret)
    {
        return ret;
    }
    pTex->BatchBase();
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::AddCubeDirtyRect"

HRESULT __declspec(nothrow) CD3DBase::AddCubeDirtyRect(CBaseTexture *pTex, DWORD dwFaceHandle, CONST RECTL *pRect)
{
    DXGASSERT(pTex->IsD3DManaged() == 0);
    DXGASSERT(pTex->GetBufferDesc()->Pool == D3DPOOL_MANAGED);
    DXGASSERT((GetD3DCaps()->Caps2 & DDCAPS2_CANMANAGERESOURCE) != 0);
    try
    {
        m_pDDI->AddDirtyRect(dwFaceHandle, pRect);
    }
    catch(HRESULT ret)
    {
        return ret;
    }
    pTex->BatchBase();
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::AddDirtyBox"

HRESULT __declspec(nothrow) CD3DBase::AddDirtyBox(CBaseTexture *pTex, CONST D3DBOX *pBox)
{
    DXGASSERT(pTex->IsD3DManaged() == 0);
    DXGASSERT(pTex->GetBufferDesc()->Pool == D3DPOOL_MANAGED);
    DXGASSERT((GetD3DCaps()->Caps2 & DDCAPS2_CANMANAGERESOURCE) != 0);
    try
    {
        m_pDDI->AddDirtyBox(pTex->BaseDrawPrimHandle(), pBox);
    }
    catch(HRESULT ret)
    {
        return ret;
    }
    pTex->BatchBase();
    return D3D_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::OnTextureDestroy"

void __declspec(nothrow) CD3DBase::OnTextureDestroy(CBaseTexture *pTex)
{
    // On a pre-DX8 driver, the code will ensure that if any
    // texture got unset by an API call, the driver will be
    // informed. This needs to be done before calling the
    // driver to destroy a texture handle as we have seen
    // instances of drivers crashing. (snene - 4/24/00)
    if(GetDDIType() < D3DDDITYPE_DX8)
    {
        D3DTEXTUREHANDLE dwDDIHandle = pTex->DriverAccessibleDrawPrimHandle();
        if(dwDDIHandle != 0)
        {
            try
            {
                BOOL bNeedFlush = FALSE;
                for (DWORD dwStage = 0; dwStage < m_dwMaxTextureBlendStages; dwStage++)
                {
                    if(dwDDIHandle == m_dwDDITexHandle[dwStage])
                    {
                        m_pDDI->SetTSS(dwStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, 0);
                        m_dwDDITexHandle[dwStage] = 0;
                        bNeedFlush = TRUE;
                    }
                }
                if(bNeedFlush)
                {
                    m_pDDI->FlushStates();
                }
            }
            catch(HRESULT ret)
            {
            }
        }
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetRenderStateInternal"

void
CD3DBase::SetRenderStateInternal(D3DRENDERSTATETYPE dwState, DWORD dwValue)
{
    if (CanHandleRenderState(dwState))
        m_pDDI->SetRenderState(dwState, dwValue);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::StateInitialize"

void
CD3DBase::StateInitialize(BOOL bZEnable)
{
    m_rsMax  = m_pDDI->GetMaxRenderState();
    m_tssMax = m_pDDI->GetMaxTSS();

    D3DLINEPATTERN defLPat;
    SetRenderStateInternal(D3DRENDERSTATE_ZENABLE, bZEnable);
    SetRenderStateInternal(D3DRENDERSTATE_FILLMODE, D3DFILL_SOLID);
    SetRenderStateInternal(D3DRENDERSTATE_SHADEMODE, D3DSHADE_GOURAUD);

    defLPat.wRepeatFactor = 0;
    defLPat.wLinePattern = 0;

    SetRenderStateInternal(D3DRENDERSTATE_LINEPATTERN, *((LPDWORD)&defLPat)); /* 10 */

    float tmpval;
    /*
      ((LPD3DSTATE)lpPointer)->drstRenderStateType =
      (D3DRENDERSTATETYPE)D3DRENDERSTATE_LINEPATTERN;
      memcpy(&(((LPD3DSTATE)lpPointer)->dwArg[0]), &defLPat, sizeof(DWORD));
      lpPointer = (void *)(((LPD3DSTATE)lpPointer) + 1);*/

    SetRenderStateInternal(D3DRENDERSTATE_ZWRITEENABLE, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_ALPHATESTENABLE, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_LASTPIXEL, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_SRCBLEND, D3DBLEND_ONE);
    SetRenderStateInternal(D3DRENDERSTATE_DESTBLEND, D3DBLEND_ZERO);
    SetRenderStateInternal(D3DRENDERSTATE_CULLMODE, D3DCULL_CCW); /* 21 */
    SetRenderStateInternal(D3DRENDERSTATE_ZFUNC, D3DCMP_LESSEQUAL);
    SetRenderStateInternal(D3DRENDERSTATE_ALPHAREF, 0);
    SetRenderStateInternal(D3DRENDERSTATE_ALPHAFUNC, D3DCMP_ALWAYS);
    SetRenderStateInternal(D3DRENDERSTATE_DITHERENABLE, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_ALPHABLENDENABLE, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_FOGENABLE, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_SPECULARENABLE, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_ZVISIBLE, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_FOGCOLOR, 0);
    SetRenderStateInternal(D3DRENDERSTATE_FOGTABLEMODE, D3DFOG_NONE);
    tmpval = 0.0f;
    SetRenderStateInternal(D3DRENDERSTATE_FOGSTART, *((DWORD *)&tmpval));
    tmpval = 1.0f;
    SetRenderStateInternal(D3DRENDERSTATE_FOGEND, *((DWORD *)&tmpval));
    tmpval = 1.0f;
    SetRenderStateInternal(D3DRENDERSTATE_FOGDENSITY, *((DWORD *)&tmpval));
    SetRenderStateInternal(D3DRENDERSTATE_EDGEANTIALIAS, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_ZBIAS, 0);
    SetRenderStateInternal(D3DRENDERSTATE_RANGEFOGENABLE, FALSE);

    // init stencil states to something reasonable
    // stencil enable is OFF by default since stenciling rasterizers will be
    // faster with it disabled, even if stencil states are benign
    SetRenderStateInternal(D3DRENDERSTATE_STENCILENABLE,   FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_STENCILFAIL,     D3DSTENCILOP_KEEP);
    SetRenderStateInternal(D3DRENDERSTATE_STENCILZFAIL,    D3DSTENCILOP_KEEP);
    SetRenderStateInternal(D3DRENDERSTATE_STENCILPASS,     D3DSTENCILOP_KEEP);
    SetRenderStateInternal(D3DRENDERSTATE_STENCILFUNC,     D3DCMP_ALWAYS);
    SetRenderStateInternal(D3DRENDERSTATE_STENCILREF,      0);
    SetRenderStateInternal(D3DRENDERSTATE_STENCILMASK,     0xFFFFFFFF);
    SetRenderStateInternal(D3DRENDERSTATE_STENCILWRITEMASK,0xFFFFFFFF);

    // don't forget about texturefactor (like we did in DX6.0...)
    SetRenderStateInternal(D3DRENDERSTATE_TEXTUREFACTOR,   0xFFFFFFFF);

    for (DWORD i = 0; i < 8; i++)
    {
        SetRenderStateInternal((D3DRENDERSTATETYPE)
                        (D3DRENDERSTATE_WRAPBIAS + i), FALSE);
    }
    for (i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        m_lpD3DMappedTexI[i] = NULL;
        m_dwDDITexHandle[i] = 0;
    }
    m_dwStageDirty = 0;

    for (i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        SetTexture(i, NULL);
        if (i == 0)
            SetTextureStageState(i, D3DTSS_COLOROP, D3DTOP_MODULATE);
        else
            SetTextureStageState(i, D3DTSS_COLOROP, D3DTOP_DISABLE);
        SetTextureStageState(i, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        SetTextureStageState(i, D3DTSS_COLORARG2, D3DTA_CURRENT);
        if (i == 0)
            SetTextureStageState(i, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
        else
            SetTextureStageState(i, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
        SetTextureStageState(i, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        SetTextureStageState(i, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT00, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT01, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT10, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT11, 0);
        SetTextureStageState(i, D3DTSS_TEXCOORDINDEX, i);
        SetTextureStageState(i, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_BORDERCOLOR, 0x00000000);
        SetTextureStageState(i, D3DTSS_MAGFILTER, D3DTEXF_POINT);
        SetTextureStageState(i, D3DTSS_MINFILTER, D3DTEXF_POINT);
        SetTextureStageState(i, D3DTSS_MIPFILTER, D3DTEXF_NONE);
        SetTextureStageState(i, D3DTSS_MIPMAPLODBIAS, 0);
        SetTextureStageState(i, D3DTSS_MAXMIPLEVEL, 0);
        SetTextureStageState(i, D3DTSS_MAXANISOTROPY, 1);
        SetTextureStageState(i, D3DTSS_BUMPENVLSCALE, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVLOFFSET, 0);
        SetTextureStageState(i, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
        SetTextureStageState(i, D3DTSS_ADDRESSW, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_COLORARG0, D3DTA_CURRENT);
        SetTextureStageState(i, D3DTSS_ALPHAARG0, D3DTA_CURRENT);
        SetTextureStageState(i, D3DTSS_RESULTARG, D3DTA_CURRENT);
    }

    SetRenderStateInternal(D3DRENDERSTATE_CLIPPING, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_LIGHTING, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_AMBIENT, 0);
    SetRenderStateInternal(D3DRENDERSTATE_FOGVERTEXMODE, D3DFOG_NONE);
    SetRenderStateInternal(D3DRENDERSTATE_COLORVERTEX, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_LOCALVIEWER, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_NORMALIZENORMALS, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,  D3DMCS_COLOR1);
    SetRenderStateInternal(D3DRENDERSTATE_SPECULARMATERIALSOURCE, D3DMCS_COLOR2);
    SetRenderStateInternal(D3DRENDERSTATE_AMBIENTMATERIALSOURCE,  D3DMCS_MATERIAL);
    SetRenderStateInternal(D3DRENDERSTATE_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
    SetRenderStateInternal(D3DRENDERSTATE_VERTEXBLEND, D3DVBF_DISABLE);
    SetRenderStateInternal(D3DRENDERSTATE_CLIPPLANEENABLE, 0);

    //
    // new for DX8
    //
    SetRenderStateInternal(D3DRS_SOFTWAREVERTEXPROCESSING, 0);

    tmpval = GetD3DCaps()->MaxPointSize;
    if (tmpval == 0)
        tmpval = __MAX_POINT_SIZE;
    SetRenderStateInternal(D3DRS_POINTSIZE_MAX, *((DWORD *)&tmpval));

    tmpval = 1.F;
    SetRenderStateInternal(D3DRS_POINTSIZE, *((DWORD *)&tmpval));
    SetRenderStateInternal(D3DRS_POINTSIZE_MIN, 0);
    SetRenderStateInternal(D3DRS_POINTSPRITEENABLE, 0);
    SetRenderStateInternal(D3DRS_POINTSCALEENABLE , 0);
    SetRenderStateInternal(D3DRS_POINTSCALE_A, *((DWORD *)&tmpval));
    SetRenderStateInternal(D3DRS_POINTSCALE_B, 0);
    SetRenderStateInternal(D3DRS_POINTSCALE_C, 0);

    SetRenderStateInternal(D3DRS_MULTISAMPLEMASK, 0xffffffff);
    SetRenderStateInternal(D3DRS_MULTISAMPLEANTIALIAS, TRUE);

    SetRenderStateInternal(D3DRS_PATCHEDGESTYLE, D3DPATCHEDGE_DISCRETE);
    tmpval = 1.F;
    SetRenderStateInternal(D3DRS_PATCHSEGMENTS, *((DWORD *)&tmpval));
    SetRenderStateInternal(D3DRS_INDEXEDVERTEXBLENDENABLE, FALSE);

    SetRenderStateInternal(D3DRS_COLORWRITEENABLE, 0xF);

    tmpval = 0.F;
    SetRenderStateInternal(D3DRS_TWEENFACTOR, *((DWORD *)&tmpval));

    SetRenderStateInternal(D3DRS_BLENDOP, D3DBLENDOP_ADD);

    // New for DX8.1

    SetRenderStateInternal(D3DRS_POSITIONORDER, D3DORDER_CUBIC);
    SetRenderStateInternal(D3DRS_NORMALORDER, D3DORDER_LINEAR);

    // Initialize the transform state
    D3DMATRIXI m;
    setIdentity(&m);
    this->SetTransform(D3DTS_VIEW, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_PROJECTION, (D3DMATRIX*)&m);
    {
        for (UINT i=0; i < __MAXWORLDMATRICES; i++)
            this->SetTransform(D3DTS_WORLDMATRIX(i),  (D3DMATRIX*)&m);
    }
    this->SetTransform(D3DTS_TEXTURE0, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_TEXTURE1, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_TEXTURE2, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_TEXTURE3, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_TEXTURE4, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_TEXTURE5, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_TEXTURE6, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_TEXTURE7, (D3DMATRIX*)&m);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::UpdatePalette"

void CD3DBase::UpdatePalette(CBaseTexture *pTex, DWORD Palette, DWORD dwStage, BOOL bSavedWithinPrimitive)
{
    try
    {
        if(Palette == __INVALIDPALETTE)
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Current palette not set");
        }
        if(pTex->GetPalette() != Palette)
        {
            DWORD dwFlags = DDRAWIPAL_256 | DDRAWIPAL_ALLOW256;
            if (Enum()->GetAppSdkVersion() > D3D_SDK_VERSION_DX8)
            {
                if ((GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_ALPHAPALETTE) &&
                   (pTex->GetBufferDesc()->Format != D3DFMT_A8P8) )
                {
                    dwFlags |= DDRAWIPAL_ALPHA;
                }
            }
            else
            {
                //This odd selection of formats to receive the palette flag
                //is inherited from DX8. It is wrong, but left in for app-compat reasons.
                if (pTex->GetBufferDesc()->Format != D3DFMT_A8P8)
                {
                    dwFlags |= DDRAWIPAL_ALPHA;
                }
            }
            m_pDDI->SetPalette(Palette,
                               dwFlags,
                               pTex);
        }
        CPalette *pal = static_cast<CPalette*>((*m_pPaletteArray)[Palette].m_pObj);
        if(pal->m_dirty)
        {
            m_pDDI->UpdatePalette(Palette, 0, 256, pal->m_pEntries);
            pal->m_dirty = FALSE;
        }
    }
    catch(HRESULT ret)
    {
        try
        {
            m_pDDI->SetTSS(dwStage,
                           (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP,
                           0);
        }
        catch(HRESULT ret)
        {
            m_pDDI->SetWithinPrimitive( bSavedWithinPrimitive );
            D3D_THROW(ret, "");
        }
        m_dwDDITexHandle[dwStage] = 0;
        m_pDDI->SetWithinPrimitive( bSavedWithinPrimitive );
        D3D_THROW(ret, "");
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::UpdateTextures"

void CD3DBase::UpdateTextures()
{
    BOOL bSavedWithinPrimitive = m_pDDI->GetWithinPrimitive();
    m_pDDI->SetWithinPrimitive(TRUE);
    for (DWORD dwStage = 0, StageMask = 1; dwStage < m_dwMaxTextureBlendStages; dwStage++, StageMask <<= 1)
    {
        D3DTEXTUREHANDLE dwDDIHandle;
        BOOL bDirty = (m_dwStageDirty & StageMask) != 0;
        m_dwStageDirty &= ~StageMask; // reset stage dirty
        CBaseTexture *lpTexI = m_lpD3DMappedTexI[dwStage];
        if(lpTexI)
        {
#if DBG
            if (lpTexI->IsTextureLocked())
            {
                DPF_ERR("Cannot update a locked texture. Texture will be disabled.");
                dwDDIHandle = 0; //tell driver to disable this texture
            }
            else
            {
#endif // DBG
            if (lpTexI->IsD3DManaged())
            {
                HRESULT hr = ResourceManager()->UpdateVideo(lpTexI->RMHandle(), &bDirty);
                if (FAILED(hr))
                {
                    DPF_ERR("The resource manager failed to promote or update a dirty texture. The texture will be disabled.");
                    dwDDIHandle = 0; //tell driver to disable this texture
                }
                else
                {
                    if (lpTexI->IsPaletted())
                    {
                        // UpdatePalette can THROW but it safely handles bSavedWithinPrimitive
                        UpdatePalette(lpTexI, m_dwPalette, dwStage, bSavedWithinPrimitive);
                    }
                    if (!bDirty)
                    {
                        continue; // Ok, then nothing needs to be done further
                    }
                    dwDDIHandle = static_cast<CMgmtInfo*>(lpTexI->RMHandle())->m_pRes->BaseDrawPrimHandle();
                }
            }
            else
            {
                if (lpTexI->IsPaletted())
                {
                    // UpdatePalette can THROW but it safely handles bSavedWithinPrimitive
                    UpdatePalette(lpTexI, m_dwPalette, dwStage, bSavedWithinPrimitive);
                }
                if (!bDirty)
                {
                    continue; // Ok, then nothing needs to be done further
                }
                dwDDIHandle = lpTexI->BaseDrawPrimHandle();
            }
#if DBG
            }
#endif // DBG
        }
        else if (bDirty)
        {
            dwDDIHandle = 0; //tell driver to disable this texture
        }
        else
        {
            continue;
        }

        try
        {
            m_pDDI->SetTSS(dwStage,
                           (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP,
                           dwDDIHandle);
        }
        catch (HRESULT ret)
        {
            m_pDDI->SetWithinPrimitive( bSavedWithinPrimitive );
            D3D_THROW(ret, "");
        }

        m_dwDDITexHandle[dwStage] = dwDDIHandle;
        if (lpTexI != 0)
        {
            lpTexI->Batch();
        }
    }
    m_pDDI->SetWithinPrimitive( bSavedWithinPrimitive );
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::IncrementBatch"

void CD3DBase::IncrementBatchCount()
{
    DXGASSERT(m_qwBatch > 0);
    m_qwBatch++;

    // Also we need to update the
    // batch counts of our currently set
    // render target and z

    // Batch the current RT
    // RT could be gone during Reset()
    if (RenderTarget() != 0)
    {
        RenderTarget()->Batch();
    }

    if (ZBuffer() != 0)
    {
        // Update the batch count for the current Zbuffer
        ZBuffer()->Batch();
    }

    // So that currently bound textures get rebatched
    for (DWORD dwStage = 0; dwStage < m_dwMaxTextureBlendStages; dwStage++)
    {
        CBaseTexture *lpTexI = m_lpD3DMappedTexI[dwStage];
        if (NULL != lpTexI)
        {
            lpTexI->Batch();
        }
    }

} // IncrementBatch
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetMaterial"

HRESULT D3DAPI
CD3DBase::GetMaterial(D3DMATERIAL8*)
{
    API_ENTER(this);
    D3D_ERR("GetMaterial does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetTransform"

HRESULT D3DAPI
CD3DBase::GetTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX)
{
    API_ENTER(this);
    D3D_ERR("GetTransform does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetLight"

HRESULT D3DAPI
CD3DBase::GetLight(DWORD, D3DLIGHT8*)
{
    API_ENTER(this);
    D3D_ERR("GetLight does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetLightEnable"

HRESULT D3DAPI
CD3DBase::GetLightEnable(DWORD dwLightIndex, BOOL*)
{
    API_ENTER(this);
    D3D_ERR("GetLightEnable does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetClipPlane"

HRESULT D3DAPI
CD3DBase::GetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation)
{
    API_ENTER(this);
    D3D_ERR("GetClipPlane does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetTextureStageState"

HRESULT D3DAPI
CD3DBase::GetTextureStageState(DWORD, D3DTEXTURESTAGESTATETYPE, LPDWORD)
{
    API_ENTER(this);
    D3D_ERR("GetTextureStageState does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetViewport"

HRESULT D3DAPI
CD3DBase::GetViewport(D3DVIEWPORT8*)
{
    API_ENTER(this);
    D3D_ERR("GetViewport does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetRenderState"

HRESULT D3DAPI
CD3DBase::GetRenderState(D3DRENDERSTATETYPE, LPDWORD)
{
    API_ENTER(this);
    D3D_ERR("GetRenderState does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetPixelShaderConstant"

HRESULT D3DAPI
CD3DBase::GetPixelShaderConstant(DWORD dwRegisterAddress,
                                 LPVOID lpvConstantData,
                                 DWORD dwConstantCount)
{
    API_ENTER(this);
    D3D_ERR("GetPixelShaderConstant does not work in pure-device");
    return E_NOTIMPL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetVertexShaderConstant"

HRESULT D3DAPI
CD3DBase::GetVertexShaderConstant(DWORD dwRegisterAddress,
                                   LPVOID lpvConstantData,
                                   DWORD dwConstantCount)
{
    API_ENTER(this);
    D3D_ERR("GetVertexShaderConstant does not work in pure-device");
    return E_NOTIMPL;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetVertexShaderDeclaration"

HRESULT D3DAPI
CD3DBase::GetVertexShaderDeclaration(DWORD dwHandle, void *pData,
                                     DWORD *pSizeOfData)
{
    API_ENTER(this);
    try
    {
#if DBG
        if (!(VALID_WRITEPTR(pSizeOfData, sizeof(*pSizeOfData))))
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid data size pointer");
        }
        if (pData && !(VALID_WRITEPTR(pData, *pSizeOfData)))
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid data pointer");
        }
#endif
        if (D3DVSD_ISLEGACY(dwHandle))
        {
            *pSizeOfData = 0;
            D3D_THROW(D3DERR_INVALIDCALL, "Legacy vertex shaders do not have declaration");
        }
        else
        {
            CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
            if (pShader == NULL)
            {
                D3D_THROW(D3DERR_INVALIDCALL, "Invalid vertex shader handle");
            }
            if (pData)
            {
                if (*pSizeOfData < pShader->m_OrgDeclSize)
                {
                    D3D_THROW(D3DERR_INVALIDCALL, "Invalid data pointer");
                }
                memcpy(pData, pShader->m_pOrgDeclaration, pShader->m_OrgDeclSize);
            }
            *pSizeOfData = pShader->m_OrgDeclSize;
        }
    }
    catch (HRESULT ret)
    {
        DPF_ERR("GetVertexShaderDeclaration failed.");
        return ret;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetVertexShaderFunction"

HRESULT D3DAPI
CD3DBase::GetVertexShaderFunction(DWORD dwHandle, void *pData,
                                  DWORD *pSizeOfData)
{
    API_ENTER(this);
    try
    {
#if DBG
        if (!(VALID_WRITEPTR(pSizeOfData, sizeof(*pSizeOfData))))
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid data size pointer");
        }
        if (pData && !(VALID_WRITEPTR(pData, *pSizeOfData)))
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid data pointer");
        }
#endif
        if (D3DVSD_ISLEGACY(dwHandle))
        {
            *pSizeOfData = 0;
            D3D_THROW(D3DERR_INVALIDCALL, "Legacy vertex shaders do not have function code");
        }
        else
        {
            CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
            if (pShader == NULL)
            {
                D3D_THROW(D3DERR_INVALIDCALL, "Invalid vertex shader handle");
            }
            if (pData)
            {
                if (*pSizeOfData < pShader->m_OrgFuncCodeSize)
                {
                    D3D_THROW(D3DERR_INVALIDCALL, "Invalid data buffer size");
                }
                memcpy(pData, pShader->m_pOrgFuncCode, pShader->m_OrgFuncCodeSize);
            }
            *pSizeOfData = pShader->m_OrgFuncCodeSize;
        }
    }
    catch (HRESULT ret)
    {
        DPF_ERR("GetVertexShaderFunction failed.");
        return ret;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetPixelShaderFunction"

HRESULT D3DAPI
CD3DBase::GetPixelShaderFunction(DWORD dwHandle, void *pData,
                                 DWORD *pSizeOfData)
{
    API_ENTER(this);
    try
    {
#if DBG
        if (!(VALID_WRITEPTR(pSizeOfData, sizeof(*pSizeOfData))))
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid data size pointer");
        }
        if (pData && !(VALID_WRITEPTR(pData, *pSizeOfData)))
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid data pointer");
        }
#endif
        CPShader* pShader = (CPShader*)m_pPShaderArray->GetObject(dwHandle);
        if (pShader == NULL)
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid pixel shader handle");
        }
        if (pData)
        {
            if (*pSizeOfData < pShader->m_dwCodeSizeOrig)
            {
                D3D_THROW(D3DERR_INVALIDCALL, "Invalid data buffer size");
            }
            memcpy(pData, pShader->m_pCodeOrig, pShader->m_dwCodeSizeOrig);
        }
        *pSizeOfData = pShader->m_dwCodeSizeOrig;
    }
    catch (HRESULT ret)
    {
        DPF_ERR("GetPixelShaderFunction failed");
        return ret;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\ddidx8.cpp ===
#include "pch.cpp"
#pragma hdrstop
/*==========================================================================;
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddidx8.cpp
 *  Content:    Direct3D Dx8 DDI encapsulation implementations
 *
 ***************************************************************************/
#include "d3d8p.h"
#include "ddi.h"
#include "fe.h"
#include "ddi.inl"

extern DWORD g_DebugFlags;
extern HRESULT ProcessClippedPointSprites(D3DFE_PROCESSVERTICES *pv);
extern DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv);
//-----------------------------------------------------------------------------
// TL stream which is read-only
//
class CTLStreamRO: public CTLStream
{
public:
    CTLStreamRO(): CTLStream(TRUE) {m_dwIndex = 0; m_bUserMemStream = FALSE;}
    void Init(CVertexBuffer* pVB, UINT primitiveBase);
    BYTE* Lock(UINT NeededSize, CD3DDDIDX6* pDDI);
    void Unlock() {}
    BOOL IsUserMemStream() {return m_bUserMemStream;}
    void AddVertices(UINT NumVertices) {}
    void SubVertices(UINT NumVertices) {}
    void MovePrimitiveBase(int NumVertices)
        {
            m_dwPrimitiveBase += NumVertices * m_dwStride;
        }
    void SkipVertices(DWORD NumVertices)
        {
            m_dwPrimitiveBase += NumVertices * m_dwStride;
        }
protected:
    BOOL m_bUserMemStream;
};
//-----------------------------------------------------------------------------
void CTLStreamRO::Init(CVertexBuffer* pVB, UINT primitiveBase)
{
    if (m_pVB)
    {
        m_pVB->DecrementUseCount();
        m_pVB = NULL;
    }
    m_pVB = pVB;
    if (pVB)
    {
        m_bUserMemStream = FALSE;
        m_pVB->IncrementUseCount();
    }
    else
    {
        m_bUserMemStream = TRUE;
    }
    m_dwPrimitiveBase = primitiveBase;
}
//-----------------------------------------------------------------------------
// Index stream which is read-only
//
class CTLIndexStreamRO: public CTLIndexStream
{
public:
    CTLIndexStreamRO() {m_dwIndex = __NUMSTREAMS;}
    void Init(CIndexBuffer* pVB, UINT primitiveBase);
    BYTE* Lock(UINT NeededSize, CD3DDDIDX6* pDDI);
    void Unlock() {}
    void AddVertices(UINT NumVertices) {}
    void SubVertices(UINT NumVertices) {}
    void MovePrimitiveBase(int NumVertices)
        {
            m_dwPrimitiveBase += NumVertices * m_dwStride;
        }
    void SkipVertices(DWORD NumVertices)
        {
            m_dwPrimitiveBase += NumVertices * m_dwStride;
        }
};
//-----------------------------------------------------------------------------
void CTLIndexStreamRO::Init(CIndexBuffer* pVB, UINT primitiveBase)
{
    if (m_pVBI)
    {
        m_pVBI->DecrementUseCount();
        m_pVBI = NULL;
    }
    m_pVBI = pVB;
    if (m_pVBI)
        m_pVBI->IncrementUseCount();
    m_dwPrimitiveBase = primitiveBase;
}
//-----------------------------------------------------------------------------
CTLStream::CTLStream(BOOL bWriteOnly)
{
    m_bWriteOnly = bWriteOnly;
    m_dwSize = 0;
    m_dwPrimitiveBase = 0;
    m_dwUsedSize = 0;
    m_dwIndex = 0;
    m_Usage = 0;
}
//-----------------------------------------------------------------------------
CTLStream::CTLStream(BOOL bWriteOnly, UINT Usage)
{
    m_bWriteOnly = bWriteOnly;
    m_dwSize = 0;
    m_dwPrimitiveBase = 0;
    m_dwUsedSize = 0;
    m_dwIndex = 0;
    m_Usage = Usage;
}
//-----------------------------------------------------------------------------
void CTLStream::Grow(UINT RequiredSize, CD3DDDIDX6* pDDI)
{
    if (RequiredSize > m_dwSize)
    {
        // We create the new vertex buffer before releasing the old one to
        // prevent creating the buffer on the same place in memory
        DWORD dwUsage = D3DUSAGE_INTERNALBUFFER | D3DUSAGE_DYNAMIC | m_Usage;
        if (m_bWriteOnly)
            dwUsage |= D3DUSAGE_WRITEONLY;
        IDirect3DVertexBuffer8 * pVB;
        HRESULT ret = CVertexBuffer::Create(pDDI->GetDevice(),
                                            RequiredSize,
                                            dwUsage,
                                            0,
                                            D3DPOOL_DEFAULT,
                                            REF_INTERNAL,
                                            &pVB);
        if (ret != DD_OK)
        {
            D3D_THROW(ret, "Could not allocate internal vertex buffer");
        }
        if (m_pVB)
            m_pVB->DecrementUseCount();
        m_pVB = static_cast<CVertexBuffer*>(pVB);
        m_dwSize = RequiredSize;
    }
}
//-----------------------------------------------------------------------------
BYTE* CTLStream::Lock(UINT NeededSize, CD3DDDIDX6* pDDI)
{
    HRESULT ret;
    DXGASSERT(m_dwSize >= m_dwUsedSize);
    if (NeededSize > m_dwSize - m_dwUsedSize || m_dwUsedSize == 0)
    {
        Grow(NeededSize, pDDI);
        ret = m_pVB->Lock(0, m_dwSize, &m_pData, D3DLOCK_DISCARD |
                                                 D3DLOCK_NOSYSLOCK);
        this->Reset();
    }
    else
    {
        ret = m_pVB->Lock(0, m_dwSize, &m_pData, D3DLOCK_NOOVERWRITE |
                                                 D3DLOCK_NOSYSLOCK);
    }
    if (ret != DD_OK)
    {
        D3D_THROW(ret, "Could not lock internal vertex buffer");
    }
    // m_dwPrimitiveBase could be out of sync with m_dwUsedSize, because
    // sometimes we re-use vertices (like when clipping line strips). Make
    // sure that they are in sync.
    m_dwPrimitiveBase = m_dwUsedSize;
    return m_pData + m_dwUsedSize;
}
//-----------------------------------------------------------------------------
void CTLStream::Unlock()
{
    m_pVB->Unlock();
}
//-----------------------------------------------------------------------------
CTLIndexStream::CTLIndexStream()
{
    m_dwSize = 0;
    m_dwPrimitiveBase = 0;
    m_dwUsedSize = 0;
    m_dwIndex = 0;
}
//-----------------------------------------------------------------------------
void CTLIndexStream::Grow(UINT RequiredSize, CD3DDDIDX6* pDDI)
{
    if (RequiredSize > m_dwSize)
    {
        // We create the new vertex buffer before releasing the old one to
        // prevent creating the buffer on the same place in memory
        DWORD dwUsage = D3DUSAGE_INTERNALBUFFER | D3DUSAGE_WRITEONLY | D3DUSAGE_DYNAMIC;
        IDirect3DIndexBuffer8 * pVB;
        HRESULT ret = CIndexBuffer::Create(pDDI->GetDevice(),
                                           RequiredSize,
                                           dwUsage,
                                           D3DFMT_INDEX16,
                                           D3DPOOL_DEFAULT,
                                           REF_INTERNAL,
                                           &pVB);
        if (ret != DD_OK)
        {
            D3D_THROW(ret, "Could not allocate internal index buffer");
        }
        if (m_pVBI)
            m_pVBI->DecrementUseCount();
        m_pVBI = static_cast<CIndexBuffer*>(pVB);
        m_dwSize = RequiredSize;
    }
}
//-----------------------------------------------------------------------------
BYTE* CTLIndexStream::Lock(UINT NeededSize, CD3DDDIDX6* pDDI)
{
    HRESULT ret;
    DXGASSERT(m_dwSize >= m_dwUsedSize);
    if (NeededSize > m_dwSize - m_dwUsedSize || m_dwUsedSize == 0)
    {
        Grow(NeededSize, pDDI);
        ret = m_pVBI->Lock(0, m_dwSize, &m_pData, D3DLOCK_DISCARD |
                                                  D3DLOCK_NOSYSLOCK);
        this->Reset();
    }
    else
    {
        ret = m_pVBI->Lock(0, m_dwSize, &m_pData, D3DLOCK_NOOVERWRITE |
                                                  D3DLOCK_NOSYSLOCK);
    }
    if (ret != DD_OK)
    {
        D3D_THROW(ret, "Could not lock internal index buffer");
    }
    // m_dwPrimitiveBase could be out of sync with m_dwUsedSize, because
    // sometimes we re-use vertices (like when clipping line strips). Make
    // sure that they are in sync.
    m_dwPrimitiveBase = m_dwUsedSize;
    return m_pData + m_dwUsedSize;
}
//-----------------------------------------------------------------------------
BYTE* CTLIndexStream::LockDiscard(UINT NeededSize, CD3DDDIDX6* pDDI)
{
    HRESULT ret;
    DXGASSERT(m_dwSize >= m_dwUsedSize);
    Grow(NeededSize, pDDI);
    ret = m_pVBI->Lock(0, m_dwSize, &m_pData, D3DLOCK_DISCARD |
                                              D3DLOCK_NOSYSLOCK);
    this->Reset();
    if (ret != DD_OK)
    {
        D3D_THROW(ret, "Could not lock internal index buffer");
    }
    // We have called Reset() so no need to set PrimitiveBase
    return m_pData;
}
//-----------------------------------------------------------------------------
void CTLIndexStream::Unlock()
{
    m_pVBI->Unlock();
}
//-----------------------------------------------------------------------------
BYTE* CTLStreamRO::Lock(UINT NeededSize, CD3DDDIDX6* pDDI)
{
    return m_pVB->Data();
}
//-----------------------------------------------------------------------------
BYTE* CTLIndexStreamRO::Lock(UINT NeededSize, CD3DDDIDX6* pDDI)
{
    return m_pVBI->Data();
}

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX8                                                              //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

const DWORD CD3DDDIDX8::m_dwDummyVertexLength = 10;
const DWORD CD3DDDIDX8::m_dwDummyVertexSize   = sizeof(D3DVERTEX);

CD3DDDIDX8::CD3DDDIDX8()
{
    m_ddiType = D3DDDITYPE_DX8;
    m_pTLStream = NULL;
    m_pTLStreamRO = NULL;
    m_pTLStreamW = NULL;
    m_pCurrentTLStream = NULL;
    m_pIndexStream = NULL;
    m_pTLStreamClip = NULL;
    m_pCurrentIndexStream = NULL;
    m_pTLIndexStreamRO = NULL;
    m_dwInterfaceNumber = 4;
    m_pvDummyArray = NULL;
}

//-----------------------------------------------------------------------------
CD3DDDIDX8::~CD3DDDIDX8()
{
    // During deletion of the objects below, the Flush could happen.
    // We have to assing pointers to NULL to prevent accessing objects
    // during the Flush.
    m_pCurrentTLStream = NULL;

    delete m_pTLStreamW;
    m_pTLStreamW = NULL;
    delete m_pTLStream;
    m_pTLStream = NULL;
    delete m_pTLStreamRO;
    m_pTLStreamRO = NULL;
    delete m_pTLIndexStreamRO;
    m_pTLIndexStreamRO = NULL;
    delete m_pIndexStream;
    m_pIndexStream = NULL;
    delete m_pTLStreamClip;
    m_pTLStreamClip = NULL;
    if (m_pvDummyArray)
    {
        delete [] m_pvDummyArray;
        m_pvDummyArray = NULL;
    }
    delete m_pPointStream;
    m_pPointStream = NULL;
    return;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::Init"

void
CD3DDDIDX8::Init(CD3DBase* pDevice)
{
    // CD3DDDIDX6::Init( pDevice );
    m_pDevice = pDevice;
    CreateContext();
    GrowCommandBuffer(dwD3DDefaultCommandBatchSize);

    m_pvDummyArray =
        (VOID *)new BYTE[m_dwDummyVertexSize*m_dwDummyVertexLength];
    if( m_pvDummyArray == NULL )
    {
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate dummy array");
    }

    // Fill the dp2data structure with initial values
    dp2data.dwFlags = D3DHALDP2_SWAPCOMMANDBUFFER;
    dp2data.dwVertexType = 0; // Initial assumption
    // We always pass this flag to prevent NT kernel from validation of vertex
    // buffer pointer
    dp2data.dwFlags |= D3DHALDP2_USERMEMVERTICES;
    SetDummyData();
    ClearBatch(FALSE);

    m_pTLStream = new CTLStream(FALSE);
    if (m_pTLStream == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal stream m_pTLStream");
    m_pTLStreamW = new CTLStream(TRUE);
    if (m_pTLStreamW == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal stream m_pTLStreamW");
    m_pTLStreamClip = new CTLStream(TRUE);
    if (m_pTLStreamClip == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal stream m_pTLStreamClip");
    m_pIndexStream = new CTLIndexStream();
    if (m_pIndexStream == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal stream m_pIndexStream");
    m_pTLStreamRO = new CTLStreamRO();
    if (m_pTLStreamRO == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal stream m_pTLStreamRO");
    m_pTLIndexStreamRO = new CTLIndexStreamRO();
    if (m_pTLIndexStreamRO == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal stream m_pTLIndexStreamRO");

    m_pTLStream->Grow(__INIT_VERTEX_NUMBER*2*sizeof(D3DTLVERTEX), this);
    m_pTLStreamW->Grow(__INIT_VERTEX_NUMBER*2*sizeof(D3DTLVERTEX), this);
    m_pTLStreamClip->Grow(__INIT_VERTEX_NUMBER*2*sizeof(D3DTLVERTEX), this);
    m_pIndexStream->Grow(__INIT_VERTEX_NUMBER*4, this);

    m_CurrentVertexShader = 0;

    m_pPointStream  = new CTLStream(FALSE);
    if (m_pPointStream == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal data structure CTLStream");

#if DBG
    m_bValidateCommands = FALSE;
#endif
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ValidateDevice"

void
CD3DDDIDX8::ValidateDevice(LPDWORD lpdwNumPasses)
{
    HRESULT ret;
    D3D8_VALIDATETEXTURESTAGESTATEDATA vd;
    memset( &vd, 0, sizeof( vd ) );
    vd.dwhContext = m_dwhContext;

    // First, Update textures since drivers pass /fail this call based
    // on the current texture handles
    m_pDevice->UpdateTextures();

    UpdateDirtyStreams();

    // Flush states, so we can validate the current state
    FlushStates();

    // Now ask the driver!
    ret = m_pDevice->GetHalCallbacks()->ValidateTextureStageState(&vd);
    *lpdwNumPasses = vd.dwNumPasses;

    if (ret != DDHAL_DRIVER_HANDLED)
        throw E_NOTIMPL;
    else if (FAILED(vd.ddrval))
        throw vd.ddrval;
}


//-----------------------------------------------------------------------------
// Sends "dirty" streams to the command buffer
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::UpdateDirtyStreams"

void CD3DDDIDX8::UpdateDirtyStreams()
{
    DWORD dwNumStreams = m_pDevice->m_dwNumStreams;
    if (m_pDevice->m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
    {
        // For software vertex processing we should update only stream 0 
        // and index stream
        dwNumStreams = 1;
    }
    for(unsigned dwStream = 0, StreamMask = 1; dwStream <= dwNumStreams; dwStream++, StreamMask <<= 1)
    {
        // When max number of vertex stream is reached, process index stream
        if (dwStream == dwNumStreams)
        {
            dwStream = __NUMSTREAMS;
            StreamMask = (1 << __NUMSTREAMS);
        }

        BOOL bDirty = (m_pDevice->m_dwStreamDirty & StreamMask) != 0;
        m_pDevice->m_dwStreamDirty &= ~StreamMask; // reset stage dirty
        CBuffer *pBuf;
        if(dwStream < dwNumStreams)
        {
            pBuf = m_pDevice->m_pStream[dwStream].m_pVB;
        }
        else
        {
            pBuf = m_pDevice->m_pIndexStream->m_pVBI;
        }
        if(pBuf != 0)
        {
            if(pBuf->IsD3DManaged())
            {
                HRESULT result;
                result = m_pDevice->ResourceManager()->UpdateVideo(pBuf->RMHandle(), &bDirty);
                if(result != D3D_OK)
                {
                    D3D_THROW(result, "Resource manager failed to create or update video memory VB/IB");
                }
            }
        }
        if (!bDirty)
        {
            continue;
        }
        if(dwStream < dwNumStreams)
        {
            InsertStreamSource(&m_pDevice->m_pStream[dwStream]);
            CDDIStream &Stream = m_pDDIStream[dwStream];
            Stream.m_pStream = &m_pDevice->m_pStream[dwStream];
            Stream.m_pBuf = pBuf;
            Stream.m_dwStride = m_pDevice->m_pStream[dwStream].m_dwStride;
        }
        else
        {
            DXGASSERT(dwStream == __NUMSTREAMS);
            InsertIndices(m_pDevice->m_pIndexStream);
            CDDIStream &Stream = m_pDDIStream[dwStream];
            Stream.m_pStream = m_pDevice->m_pIndexStream;
            Stream.m_pBuf = pBuf;
            Stream.m_dwStride = m_pDevice->m_pIndexStream->m_dwStride;
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::LockVB"

HRESULT __declspec(nothrow) CD3DDDIDX8::LockVB(CDriverVertexBuffer *pVB, DWORD dwFlags)
{
    HRESULT hr;
    if (pVB->GetCachedDataPointer() != 0) // if lock was cached
    {
        DXGASSERT((dwFlags & (D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE)) == 0);
        DXGASSERT((pVB->GetBufferDesc()->Usage & D3DUSAGE_DYNAMIC) != 0);
        hr = pVB->UnlockI();
        if(FAILED(hr))
        {
            DPF_ERR("Driver failed to unlock a vertex buffer"
                    " when attempting to re-cache the lock.");
            pVB->SetCachedDataPointer(0);
            return hr;
        }
    }
    hr = pVB->LockI(dwFlags | D3DLOCK_NOSYSLOCK);
    if (FAILED(hr))
    {
        DPF_ERR("Driver failed to lock a vertex buffer" 
                " when attempting to cache the lock.");
        pVB->SetCachedDataPointer(0);
        return hr;
    }
    return D3D_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::UnlockVB"

HRESULT __declspec(nothrow) CD3DDDIDX8::UnlockVB(CDriverVertexBuffer *pVB)
{
    return pVB->UnlockI();
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::SetTSS"

void
CD3DDDIDX8::SetTSS(DWORD dwStage,
                   D3DTEXTURESTAGESTATETYPE dwState,
                   DWORD dwValue)
{
    // Filter unsupported states
    if (dwState >= m_pDevice->m_tssMax)
        return;

    if (bDP2CurrCmdOP == D3DDP2OP_TEXTURESTAGESTATE)
    { // Last instruction is a texture stage state, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2TEXTURESTAGESTATE) <=
            dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2TEXTURESTAGESTATE lpRState =
                (LPD3DHAL_DP2TEXTURESTAGESTATE)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpRState->wStage = (WORD)dwStage;
            lpRState->TSState = (WORD)dwState;
            lpRState->dwValue = dwValue;
            dwDP2CommandLength += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2TEXTURESTAGESTATE) > dwDP2CommandBufSize)
    {
            FlushStates();
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_TEXTURESTAGESTATE;
    bDP2CurrCmdOP = D3DDP2OP_TEXTURESTAGESTATE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add renderstate data
    LPD3DHAL_DP2TEXTURESTAGESTATE lpRState =
        (LPD3DHAL_DP2TEXTURESTAGESTATE)(lpDP2CurrCommand + 1);
    lpRState->wStage = (WORD)dwStage;
    lpRState->TSState = (WORD)dwState;
    lpRState->dwValue = dwValue;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) +
                          sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::CreatePixelShader"

void
CD3DDDIDX8::CreatePixelShader(CONST DWORD* pdwFunction,
                              DWORD dwCodeSize,
                              DWORD dwHandle)
{
    FlushStates();
    LPD3DHAL_DP2CREATEPIXELSHADER pData;
    pData = (LPD3DHAL_DP2CREATEPIXELSHADER)
            GetHalBufferPointer(D3DDP2OP_CREATEPIXELSHADER,
                                sizeof(*pData) + dwCodeSize);
    pData->dwHandle = dwHandle;
    pData->dwCodeSize = dwCodeSize;
    LPBYTE p = (LPBYTE)&pData[1];
    memcpy(p, pdwFunction, dwCodeSize);
    FlushStates(TRUE,FALSE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::SetPixelShader"

void
CD3DDDIDX8::SetPixelShader( DWORD dwHandle )
{
    LPD3DHAL_DP2PIXELSHADER pData;
    pData = (LPD3DHAL_DP2PIXELSHADER)
            GetHalBufferPointer(D3DDP2OP_SETPIXELSHADER, sizeof(*pData));
    pData->dwHandle = dwHandle;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DeletePixelShader"

void
CD3DDDIDX8::DeletePixelShader(DWORD dwHandle)
{
    LPD3DHAL_DP2PIXELSHADER pData;
    pData = (LPD3DHAL_DP2PIXELSHADER)
            GetHalBufferPointer(D3DDP2OP_DELETEPIXELSHADER, sizeof(*pData));
    pData->dwHandle = dwHandle;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::SetPixelShaderConstant"

void
CD3DDDIDX8::SetPixelShaderConstant(DWORD dwRegister, CONST VOID* data, 
                                   DWORD count)
{
    const DWORD size = count << 4;
    LPD3DHAL_DP2SETPIXELSHADERCONST pData;
    pData = (LPD3DHAL_DP2SETPIXELSHADERCONST)
            GetHalBufferPointer(D3DDP2OP_SETPIXELSHADERCONST,
                                sizeof(*pData) + size);
    pData->dwRegister = dwRegister;
    pData->dwCount = count;
    memcpy(pData+1, data, size);
}
//-----------------------------------------------------------------------------
// Inserts SetStreamSource command into the command buffer
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::InsertStreamSource"

void
CD3DDDIDX8::InsertStreamSource(CVStream* pStream)
{
    if (pStream->IsUserMemStream())
    {
        InsertStreamSourceUP(pStream->m_dwStride);
        return;
    }
    LPD3DHAL_DP2SETSTREAMSOURCE pData;
    pData = (LPD3DHAL_DP2SETSTREAMSOURCE)
        GetHalBufferPointer(D3DDP2OP_SETSTREAMSOURCE, sizeof(*pData));
    pData->dwStream   = pStream->m_dwIndex;
    pData->dwVBHandle = pStream->m_pVB != 0 ? pStream->m_pVB->DriverAccessibleDrawPrimHandle() : 0;
    pData->dwStride   = pStream->m_dwStride;
    CDDIStream* pDDIStream = &m_pDDIStream[pStream->m_dwIndex];
    pDDIStream->m_dwStride = pStream->m_dwStride;
    pDDIStream->m_pStream = pStream;
    pDDIStream->m_pBuf = pStream->m_pVB;
    if (pStream->m_pVB != 0)
    {
        pStream->m_pVB->Batch();
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::InsertStreamSourceUP"

void
CD3DDDIDX8::InsertStreamSourceUP(DWORD dwStride)
{
    // User memory source
    LPD3DHAL_DP2SETSTREAMSOURCEUM pData;
    pData = (LPD3DHAL_DP2SETSTREAMSOURCEUM)
        GetHalBufferPointer(D3DDP2OP_SETSTREAMSOURCEUM, sizeof(*pData));
    pData->dwStream   = 0;
    pData->dwStride   = dwStride;
    CDDIStream* pDDIStream = &m_pDDIStream[0];
    pDDIStream->m_dwStride = dwStride;
    pDDIStream->m_pStream = NULL;
    pDDIStream->m_pBuf = NULL;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::InsertIndices"

void
CD3DDDIDX8::InsertIndices(CVIndexStream* pStream)
{
    LPD3DHAL_DP2SETINDICES pData;
    pData = (LPD3DHAL_DP2SETINDICES)
            GetHalBufferPointer(D3DDP2OP_SETINDICES, sizeof(*pData));
    pData->dwVBHandle = pStream->m_pVBI != 0 ? pStream->m_pVBI->DriverAccessibleDrawPrimHandle() : 0;
    pData->dwStride = pStream->m_dwStride;
    m_pDDIStream[__NUMSTREAMS].m_dwStride = pStream->m_dwStride;
    m_pDDIStream[__NUMSTREAMS].m_pStream = pStream;
    m_pDDIStream[__NUMSTREAMS].m_pBuf = pStream->m_pVBI;
    if(pStream->m_pVBI != 0)
    {
        pStream->m_pVBI->Batch();
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8_DrawPrimitive"

void
CD3DDDIDX8_DrawPrimitive(CD3DBase* pDevice, D3DPRIMITIVETYPE PrimitiveType,
                         UINT StartVertex, UINT PrimitiveCount)
{
#if DBG
    if (!(pDevice->BehaviorFlags() & D3DCREATE_PUREDEVICE))
    {
        CD3DHal* pDev = static_cast<CD3DHal*>(pDevice);
        UINT nVer = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
        pDev->ValidateDraw2(PrimitiveType, StartVertex, PrimitiveCount, 
                            nVer, FALSE);
    }
#endif // DBG
    CD3DDDIDX8* pDDI = static_cast<CD3DDDIDX8*>(pDevice->m_pDDI);
    if(pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        pDevice->UpdateTextures();
        pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    if (pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE)
    {
        pDDI->UpdateDirtyStreams();
        pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
    }
    if (pDDI->bDP2CurrCmdOP == D3DDP2OP_DRAWPRIMITIVE)
    { // Last instruction is a DrawPrimitive, append this one to it
        //
        // First check if the new instruction is a TRIANGLELIST. If it is,
        // AND if the new StartVertex = prev StartVertex + prev PrimitiveCount * 3
        // then we can simply bump up the prev primitive count. This makes
        // drivers go a LOT faster. (snene - 12/00)
        //
        
        //!!!!!!!!!!!!!!!!!!!!!!!!!!ALERT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // The following code READS BACK from the batched command. This is
        // NOT a problem for sysmem command buffers in DX8. However, going
        // forward, if we ever implement vidmem command buffers, we need
        // to FIX this code to not read back. (snene - 12/00)
        LPD3DHAL_DP2DRAWPRIMITIVE pData = (LPD3DHAL_DP2DRAWPRIMITIVE)
            ((LPBYTE)pDDI->lpvDP2Commands + pDDI->dwDP2CommandLength - sizeof(D3DHAL_DP2DRAWPRIMITIVE) +
            pDDI->dp2data.dwCommandOffset);
        if(pData->primType == D3DPT_TRIANGLELIST && 
           pData->primType == PrimitiveType && 
           pData->VStart + pData->PrimitiveCount * 3 == StartVertex &&
           pData->PrimitiveCount + PrimitiveCount >= pData->PrimitiveCount) // overflow
        {
            pData->PrimitiveCount += PrimitiveCount;
            return;
        }                
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        if (pDDI->dwDP2CommandLength + sizeof(D3DHAL_DP2DRAWPRIMITIVE) <=
            pDDI->dwDP2CommandBufSize)
        {
            ++pData;
            pDDI->lpDP2CurrCommand->wStateCount = ++pDDI->wDP2CurrCmdCnt;
            pData->primType = PrimitiveType;
            pData->VStart = StartVertex;
            pData->PrimitiveCount = PrimitiveCount;
            pDDI->dwDP2CommandLength += sizeof(D3DHAL_DP2DRAWPRIMITIVE);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)pDDI->lpDP2CurrCommand);
            return;
        }
    }
    // Check for space
    if (pDDI->dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2DRAWPRIMITIVE) > pDDI->dwDP2CommandBufSize)
    {
        pDDI->FlushStates();
    }
    // Add new DrawPrimitive instruction
    pDDI->lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)pDDI->lpvDP2Commands +
        pDDI->dwDP2CommandLength + pDDI->dp2data.dwCommandOffset);
    pDDI->lpDP2CurrCommand->bCommand = D3DDP2OP_DRAWPRIMITIVE;
    pDDI->bDP2CurrCmdOP = D3DDP2OP_DRAWPRIMITIVE;
    pDDI->lpDP2CurrCommand->bReserved = 0;
    pDDI->lpDP2CurrCommand->wStateCount = 1;
    pDDI->wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)pDDI->lpDP2CurrCommand);
    // Add DrawPrimitive data
    LPD3DHAL_DP2DRAWPRIMITIVE pData;
    pData = (LPD3DHAL_DP2DRAWPRIMITIVE)(pDDI->lpDP2CurrCommand + 1);
    pData->primType = PrimitiveType;
    pData->VStart = StartVertex;
    pData->PrimitiveCount = PrimitiveCount;
    pDDI->dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) +
                                sizeof(D3DHAL_DP2DRAWPRIMITIVE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::SetDummyData"

void
CD3DDDIDX8::SetDummyData()
{
    dp2data.dwVertexSize   = m_dwDummyVertexSize;
    dp2data.lpVertices     = m_pvDummyArray;
    dp2data.dwVertexLength = m_dwDummyVertexLength;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8_DrawIndexedPrimitive"

void
CD3DDDIDX8_DrawIndexedPrimitive(CD3DBase* pDevice,
                                D3DPRIMITIVETYPE PrimitiveType,
                                UINT BaseVertexIndex,
                                UINT MinIndex, UINT NumVertices,
                                UINT StartIndex, UINT PrimitiveCount)
{
#if DBG
    if (!(pDevice->BehaviorFlags() & D3DCREATE_PUREDEVICE))
    {
        CD3DHal* pDev = static_cast<CD3DHal*>(pDevice);
        pDev->ValidateDraw2(PrimitiveType, MinIndex + BaseVertexIndex,
                            PrimitiveCount, NumVertices, TRUE, StartIndex);
    }
#endif // DBG
    CD3DDDIDX8* pDDI = static_cast<CD3DDDIDX8*>(pDevice->m_pDDI);
    if(pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        pDevice->UpdateTextures();
        pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    if (pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE)
    {
        pDDI->UpdateDirtyStreams();
        pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
    }
    if (pDDI->bDP2CurrCmdOP == D3DDP2OP_DRAWINDEXEDPRIMITIVE)
    { // Last instruction is a DrawIndexedPrimitive, append this one to it
        //
        // First check if the new instruction is a TRIANGLELIST. If it is,
        // AND if the new StartIndex = prev StartIndex + prev PrimitiveCount * 3
        // AND if the new BaseVertexIndex = prev BaseVertexIndex
        // then we can simply bump up the prev primitive count. This makes
        // drivers go a LOT faster. (snene - 12/00)
        //
        
        //!!!!!!!!!!!!!!!!!!!!!!!!!!ALERT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // The following code READS BACK from the batched command. This is
        // NOT a problem for sysmem command buffers in DX8. However, going
        // forward, if we ever implement vidmem command buffers, we need
        // to FIX this code to not read back. (snene - 12/00)
        LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pData = (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE)
            ((LPBYTE)pDDI->lpvDP2Commands + pDDI->dwDP2CommandLength - sizeof(D3DHAL_DP2DRAWINDEXEDPRIMITIVE) +
            pDDI->dp2data.dwCommandOffset);
        if(pData->primType == D3DPT_TRIANGLELIST && 
           pData->primType == PrimitiveType && 
           pData->BaseVertexIndex == BaseVertexIndex &&
           pData->StartIndex + pData->PrimitiveCount * 3 == StartIndex &&
           pData->PrimitiveCount + PrimitiveCount >= pData->PrimitiveCount) // overflow
        {
            UINT mnidx = min(pData->MinIndex, MinIndex);
            UINT mxidx = max(pData->MinIndex + pData->NumVertices, MinIndex + NumVertices);
            if(mxidx - mnidx <= pData->NumVertices + NumVertices)
            {
                pData->NumVertices = mxidx - mnidx;
                pData->MinIndex = mnidx;
                pData->PrimitiveCount += PrimitiveCount;
                return;
            }
        }                
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        if (pDDI->dwDP2CommandLength + sizeof(D3DHAL_DP2DRAWINDEXEDPRIMITIVE) <=
            pDDI->dwDP2CommandBufSize)
        {
            ++pData;
            pDDI->lpDP2CurrCommand->wStateCount = ++pDDI->wDP2CurrCmdCnt;
            pData->BaseVertexIndex = BaseVertexIndex;
            pData->primType = PrimitiveType;
            pData->PrimitiveCount = PrimitiveCount;
            pData->MinIndex = MinIndex;
            pData->NumVertices = NumVertices;
            pData->StartIndex = StartIndex;
            pDDI->dwDP2CommandLength += sizeof(D3DHAL_DP2DRAWINDEXEDPRIMITIVE);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)pDDI->lpDP2CurrCommand);
            return;
        }
    }
    // Check for space
    if (pDDI->dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2DRAWINDEXEDPRIMITIVE) > pDDI->dwDP2CommandBufSize)
    {
        pDDI->FlushStates();
    }
    // Add new DrawIndexedPrimitive instruction
    pDDI->lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)pDDI->lpvDP2Commands +
        pDDI->dwDP2CommandLength + pDDI->dp2data.dwCommandOffset);
    pDDI->lpDP2CurrCommand->bCommand = D3DDP2OP_DRAWINDEXEDPRIMITIVE;
    pDDI->bDP2CurrCmdOP = D3DDP2OP_DRAWINDEXEDPRIMITIVE;
    pDDI->lpDP2CurrCommand->bReserved = 0;
    pDDI->lpDP2CurrCommand->wStateCount = 1;
    pDDI->wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)pDDI->lpDP2CurrCommand);
    // Add DrawIndexedPrimitive data
    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pData;
    pData = (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE)(pDDI->lpDP2CurrCommand + 1);
    pData->BaseVertexIndex = BaseVertexIndex;
    pData->primType = PrimitiveType;
    pData->PrimitiveCount = PrimitiveCount;
    pData->MinIndex = MinIndex;
    pData->NumVertices = NumVertices;
    pData->StartIndex = StartIndex;
    pDDI->dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) +
                                sizeof(D3DHAL_DP2DRAWINDEXEDPRIMITIVE);

#if DBG
//    if (m_bValidateCommands)
//        ValidateCommand(lpDP2CurrCommand);
#endif
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DrawPrimitiveUP"

void
CD3DDDIDX8::DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount)
{
    UINT NumVertices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
    if (NumVertices > LOWVERTICESNUMBER)
    {
        if (m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE)
        {
            UpdateDirtyStreams();
            m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
        }
        this->FlushStates();
        dp2data.dwVertexType = 0;
        dp2data.dwVertexSize = m_pDevice->m_pStream[0].m_dwStride;
        dp2data.lpVertices = m_pDevice->m_pStream[0].m_pData;
        dp2data.dwVertexLength = NumVertices;
        try
        {
            InsertStreamSourceUP(m_pDevice->m_pStream[0].m_dwStride);
            CD3DDDIDX8_DrawPrimitive(m_pDevice, PrimitiveType, 0, PrimitiveCount);
            this->FlushStates();
        }
        catch( HRESULT hr )
        {
            SetDummyData();
            throw hr;
        }
        SetDummyData();
    }
    else
    {
        // Copy vertices to the internal TL buffer

        UINT VertexSize = m_pDevice->m_pStream[0].m_dwStride;
        // When vertex size has been changed we need to start from the 
        // beginning of the vertex buffer to correctly handle vertex offsets
        if (m_pTLStreamW->GetPrimitiveBase() % VertexSize)
        {
            this->FlushStates();
            m_pTLStreamW->Reset();
        }

        // Copy vertices into the internal write only buffer
        m_pTLStreamW->SetVertexSize(VertexSize);
        UINT VertexPoolSize = VertexSize * NumVertices;
        LPVOID lpvOut = m_pTLStreamW->Lock(VertexPoolSize, this);
        UINT StartVertex = m_pTLStreamW->GetPrimitiveBase() / VertexSize;
        memcpy(lpvOut, m_pDevice->m_pStream[0].m_pData, VertexPoolSize);
        m_pTLStreamW->Unlock();
        m_pTLStreamW->SkipVertices(NumVertices);

        // To prevent overriding of stream 0 we clear D3DRT_NEED_VB_UPDATE and
        // stream dirty bit. We need to clear the stream dirty bit, because during
        // UpdateTextures D3DRT_NEED_VB_UPDATE could be set again
        DWORD dwRuntimeFlags = m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE;
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
        m_pDevice->m_dwStreamDirty &= ~1;

        if (m_pDDIStream[0].m_pBuf != m_pTLStreamW->m_pVB || 
            m_pDDIStream[0].m_dwStride != m_pTLStreamW->m_dwStride)
        {
            InsertStreamSource(m_pTLStreamW);
        }

#if DBG
        // Need this to pass validation
        m_pDevice->m_pStream[0].m_dwNumVertices = StartVertex + NumVertices;
#endif
        // Insert drawing command
        CD3DDDIDX8_DrawPrimitive(m_pDevice, PrimitiveType, StartVertex, PrimitiveCount);

        m_pDevice->m_dwRuntimeFlags |= dwRuntimeFlags;
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DrawIndexedPrimitiveUP"

void
CD3DDDIDX8::DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                                  UINT MinVertexIndex,
                                  UINT NumVertices,
                                  UINT PrimitiveCount)
{
    if (NumVertices > LOWVERTICESNUMBER)
    {
        if (m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE)
        {
            UpdateDirtyStreams();
            m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
        }
        this->FlushStates();
        dp2data.dwVertexType = 0;
        dp2data.dwVertexSize = m_pDevice->m_pStream[0].m_dwStride;
        dp2data.lpVertices = m_pDevice->m_pStream[0].m_pData;
        dp2data.dwVertexLength = NumVertices;
        try
        {
            InsertStreamSourceUP(m_pDevice->m_pStream[0].m_dwStride);

            UINT NumIndices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
            m_pIndexStream->SetVertexSize(m_pDevice->m_pIndexStream->m_dwStride);
            // Always start from the beginning of the index stream
            // Copy indices into the internal stream
            DWORD dwIndicesByteCount = NumIndices * m_pIndexStream->m_dwStride;
            BYTE* pIndexData = m_pIndexStream->LockDiscard(dwIndicesByteCount, this);
            memcpy(pIndexData, m_pDevice->m_pIndexStream->m_pData, dwIndicesByteCount);
            m_pIndexStream->Unlock();

            InsertIndices(m_pIndexStream);

            CD3DDDIDX8_DrawIndexedPrimitive(m_pDevice, PrimitiveType, 0,
                                            MinVertexIndex, NumVertices, 0,
                                            PrimitiveCount);
            this->FlushStates();
        }
        catch( HRESULT hr )
        {
            SetDummyData();
            throw hr;
        }
        SetDummyData();
    }
    else
    {
        // Copy user data into internal buffers
        
        UINT VertexSize = m_pDevice->m_pStream[0].m_dwStride;
        UINT IndexSize = m_pDevice->m_pIndexStream->m_dwStride;
        if ((m_pTLStreamW->GetPrimitiveBase() % VertexSize) ||
            (m_pIndexStream->GetPrimitiveBase() % IndexSize))
        {
            this->FlushStates();
            m_pTLStreamW->Reset();
            m_pIndexStream->Reset();
        }

        // Copy vertices into the internal write only buffer
        m_pTLStreamW->SetVertexSize(VertexSize);
        UINT VertexPoolSize = VertexSize * NumVertices;
        LPVOID lpvOut = m_pTLStreamW->Lock(VertexPoolSize, this);
        UINT StartVertex = m_pTLStreamW->GetPrimitiveBase() / VertexSize;
        UINT FirstVertexOffset = MinVertexIndex * VertexSize;
        memcpy(lpvOut, m_pDevice->m_pStream[0].m_pData + FirstVertexOffset, 
               VertexPoolSize);
        m_pTLStreamW->Unlock();
        m_pTLStreamW->SkipVertices(NumVertices);

        // To prevent overriding of stream 0 we clear D3DRT_NEED_VB_UPDATE and
        // stream dirty bit. We need to clear the stream dirty bit, because during
        // UpdateTextures D3DRT_NEED_VB_UPDATE could be set again
        DWORD dwRuntimeFlags = m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE;
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
        m_pDevice->m_dwStreamDirty &= ~(1 | (1 << __NUMSTREAMS));

        if (m_pDDIStream[0].m_pBuf != m_pTLStreamW->m_pVB || 
            m_pDDIStream[0].m_dwStride != m_pTLStreamW->m_dwStride)
        {
            InsertStreamSource(m_pTLStreamW);
        }

        // Copy indices into the internal buffer. Re-base indices if necessery.
        m_pIndexStream->SetVertexSize(IndexSize);
        UINT NumIndices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
        UINT IndexPoolSize = IndexSize * NumIndices;
        lpvOut = m_pIndexStream->Lock(IndexPoolSize, this);
        UINT StartIndex = m_pIndexStream->GetPrimitiveBase() / IndexSize;
        memcpy(lpvOut, m_pDevice->m_pIndexStream->m_pData, IndexPoolSize);
        m_pIndexStream->Unlock();
        m_pIndexStream->SkipVertices(NumIndices);

        if (m_pDDIStream[__NUMSTREAMS].m_pBuf != m_pIndexStream->m_pVBI || 
            m_pDDIStream[__NUMSTREAMS].m_dwStride != m_pIndexStream->m_dwStride)
        {
            InsertIndices(m_pIndexStream);
        }

#if DBG
        // Need this to pass validation
        m_pDevice->m_pStream[0].m_dwNumVertices = StartVertex + NumVertices;
        m_pDevice->m_pIndexStream->m_dwNumVertices = StartIndex + NumIndices;
#endif
        // Draw primitive
        CD3DDDIDX8_DrawIndexedPrimitive(m_pDevice, PrimitiveType, 
                                        StartVertex - MinVertexIndex,
                                        MinVertexIndex, NumVertices, StartIndex, 
                                        PrimitiveCount);

        m_pDevice->m_dwRuntimeFlags |= dwRuntimeFlags;
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DrawRectPatch"

void
CD3DDDIDX8::DrawRectPatch(UINT Handle, CONST D3DRECTPATCH_INFO *pSurf, 
                          CONST FLOAT *pNumSegs)
{
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    if (m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE)
    {
        UpdateDirtyStreams();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
    }
    LPD3DHAL_DP2DRAWRECTPATCH pData;
    pData = (LPD3DHAL_DP2DRAWRECTPATCH)
            GetHalBufferPointer(D3DDP2OP_DRAWRECTPATCH,
                                sizeof(*pData) + (pSurf != 0 ? sizeof(D3DRECTPATCH_INFO) : 0) + (pNumSegs != 0 ? sizeof(FLOAT) * 4 : 0));
    pData->Handle = Handle;
    DWORD offset;
    if(pNumSegs != 0)
    {
        offset = sizeof(FLOAT) * 4;
        memcpy(pData + 1, pNumSegs, offset);
        pData->Flags = RTPATCHFLAG_HASSEGS;
    }
    else
    {
        pData->Flags = 0;
        offset = 0;
    }
    if(pSurf != 0)
    {
        memcpy((BYTE*)(pData + 1) + offset, pSurf, sizeof(D3DRECTPATCH_INFO));
        pData->Flags |= RTPATCHFLAG_HASINFO;
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DrawTriSurface"

void
CD3DDDIDX8::DrawTriPatch(UINT Handle, CONST D3DTRIPATCH_INFO *pSurf, 
                         CONST FLOAT *pNumSegs)
{
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    if (m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE)
    {
        UpdateDirtyStreams();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
    }
    LPD3DHAL_DP2DRAWTRIPATCH pData;
    pData = (LPD3DHAL_DP2DRAWTRIPATCH)
            GetHalBufferPointer(D3DDP2OP_DRAWTRIPATCH,
                                sizeof(*pData) + (pSurf != 0 ? sizeof(D3DTRIPATCH_INFO) : 0) + (pNumSegs != 0 ? sizeof(FLOAT) * 3 : 0));
    pData->Handle = Handle;
    DWORD offset;
    if(pNumSegs != 0)
    {
        offset = sizeof(FLOAT) * 3;
        memcpy(pData + 1, pNumSegs, offset);
        pData->Flags = RTPATCHFLAG_HASSEGS;
    }
    else
    {
        pData->Flags = 0;
        offset = 0;
    }
    if(pSurf != 0)
    {
        memcpy((BYTE*)(pData + 1) + offset, pSurf, sizeof(D3DTRIPATCH_INFO));
        pData->Flags |= RTPATCHFLAG_HASINFO;
    }
}
//-----------------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called only if vertices from user memory are NOT used for rendering
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::StartPrimVB"

void
CD3DDDIDX8::StartPrimVB(D3DFE_PROCESSVERTICES * pv, CVStream* pStream,
                        DWORD dwStartVertex)
{
    SetWithinPrimitive(TRUE);
    UINT size = dwStartVertex * pv->dwOutputSize;
    if (pStream)
        m_pTLStreamRO->Init(pStream->m_pVB, size);
    else
        m_pTLStreamRO->Init(NULL, size);
    m_pTLStreamRO->SetVertexSize(pv->dwOutputSize);
    m_pCurrentTLStream = m_pTLStreamRO;
}
//-----------------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called only if vertices from user memory are NOT used for rendering
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::StartIndexPrimVB"

void
CD3DDDIDX8::StartIndexPrimVB(CVIndexStream* pStream, UINT StartIndex,
                             UINT IndexSize)
{
    m_pTLIndexStreamRO->Init(pStream->m_pVBI, StartIndex * IndexSize);
    m_pTLIndexStreamRO->SetVertexSize(IndexSize);
    m_pCurrentIndexStream = m_pTLIndexStreamRO;
}
//-----------------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called when the runtime needs to output vertices to a TL buffer
// TL buffer grows if necessary
//
// Uses the following global variables:
//      pv->dwOutputSize
//     Sets "within primitive" to TRUE
// Returns:
//      TL buffer address
//
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::StartPrimTL"

LPVOID
CD3DDDIDX8::StartPrimTL(D3DFE_PROCESSVERTICES * pv, DWORD dwVertexPoolSize,
                        BOOL bWriteOnly)
{
    CTLStream* pStream = bWriteOnly? m_pTLStreamW : m_pTLStream;
    LPVOID p = pStream->Lock(dwVertexPoolSize, this);
    pStream->SetVertexSize(pv->dwOutputSize);
    m_pCurrentTLStream = pStream;
    SetWithinPrimitive(TRUE);
    return p;
}
//---------------------------------------------------------------------
// Uses the following members of D3DFE_PROCESSVERTICES:
//      primType
//      dwNumVertices
//      dwNumPrimitives
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DrawPrim"

void
CD3DDDIDX8::DrawPrim(D3DFE_PROCESSVERTICES* pv)
{
#ifdef DEBUG_PIPELINE
    if (g_DebugFlags & __DEBUG_NORENDERING)
        return;
#endif

    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    if (m_pDDIStream[0].m_pBuf != static_cast<CBuffer*>(m_pCurrentTLStream->m_pVB) ||
        pv->dwOutputSize != m_pDDIStream[0].m_dwStride)
    {
        InsertStreamSource(m_pCurrentTLStream);
        // API stream should be set dirty, in case it is later passed to DDI directly
        m_pDevice->m_dwStreamDirty |= 1;
        m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;
    }
    if (pv->primType == D3DPT_POINTLIST &&
        pv->dwDeviceFlags & D3DDEV_DOPOINTSPRITEEMULATION)
    {
        DrawPrimPS(pv);
        return;
    }
    LPD3DHAL_DP2DRAWPRIMITIVE2 pData;
    pData = (LPD3DHAL_DP2DRAWPRIMITIVE2)
            GetHalBufferPointer(D3DDP2OP_DRAWPRIMITIVE2, sizeof(*pData));
    pData->primType = pv->primType;
    pData->FirstVertexOffset = m_pCurrentTLStream->GetPrimitiveBase();
    pData->PrimitiveCount = pv->dwNumPrimitives;

    m_pCurrentTLStream->SkipVertices(pv->dwNumVertices);

#if DBG
    if (m_bValidateCommands)
        ValidateCommand(lpDP2CurrCommand);
#endif
}
//---------------------------------------------------------------------
//
// The vertices are already in the vertex buffer.
//
// Uses the following members of D3DFE_PROCESSVERTICES:
//      primType
//      dwNumVertices
//      dwNumPrimitives
//      dwNumIndices
//      dwIndexSize
//      lpwIndices
//

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DrawIndexPrim"

void
CD3DDDIDX8::DrawIndexPrim(D3DFE_PROCESSVERTICES* pv)
{
#ifdef DEBUG_PIPELINE
    if (g_DebugFlags & __DEBUG_NORENDERING)
        return;
#endif
    this->dwDP2Flags |= D3DDDI_INDEXEDPRIMDRAWN;
    if (m_pCurrentIndexStream == m_pIndexStream)
    {
        // We always copy user provided indices to the internal index stream.
        // Therefore we have to check the available stream size and do Lock/Unlock
        DWORD dwIndicesByteCount = pv->dwNumIndices * pv->dwIndexSize;
        // We cannot mix DWORD and WORD indices because of alignment issues 
        // on ia64
        if (m_pIndexStream->GetVertexSize() != pv->dwIndexSize)
        {
            this->FlushStates();
            m_pIndexStream->Reset();
            m_pIndexStream->SetVertexSize(pv->dwIndexSize);
        }
        BYTE* pIndexData = m_pIndexStream->Lock(dwIndicesByteCount, this);
        memcpy(pIndexData, pv->lpwIndices, dwIndicesByteCount);
        m_pIndexStream->Unlock();
    }
    if (m_pCurrentIndexStream->m_pVBI->IsD3DManaged())
    {
        if (m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE)
        {
            BOOL bDirty = FALSE;
            HRESULT result = m_pDevice->ResourceManager()->UpdateVideo(m_pCurrentIndexStream->m_pVBI->RMHandle(), &bDirty);
            if(result != D3D_OK)
            {
                D3D_THROW(result, "Resource manager failed to create or update video memory IB");
            }
            if((m_pDevice->m_dwStreamDirty & (1 << __NUMSTREAMS)) != 0 || bDirty)
            {
                InsertIndices(m_pCurrentIndexStream);
                CDDIStream &Stream = m_pDDIStream[__NUMSTREAMS];
                Stream.m_pStream = m_pCurrentIndexStream;
                Stream.m_pBuf = m_pCurrentIndexStream->m_pVBI;
                Stream.m_dwStride = m_pCurrentIndexStream->m_dwStride;
                m_pDevice->m_dwStreamDirty &= ~(1 << __NUMSTREAMS); // reset stage dirty
            }
            m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
        }
    }
    else
    {
        if (m_pDDIStream[__NUMSTREAMS].m_pBuf != static_cast<CBuffer*>(m_pCurrentIndexStream->m_pVBI) ||
            pv->dwIndexSize != m_pDDIStream[__NUMSTREAMS].m_dwStride)
        {
            m_pCurrentIndexStream->SetVertexSize(pv->dwIndexSize);
            InsertIndices(m_pCurrentIndexStream);
            // API stream should be set dirty, in case it is later passed to DDI directly
            m_pDevice->m_dwStreamDirty |= (1 << __NUMSTREAMS);
            m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
        }
    }
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }

    if (m_pDDIStream[0].m_pBuf != static_cast<CBuffer*>(m_pCurrentTLStream->m_pVB) ||
        pv->dwOutputSize != m_pDDIStream[0].m_dwStride)
    {
        m_pDDIStream[0].m_dwStride = pv->dwOutputSize;
        InsertStreamSource(m_pCurrentTLStream);
        // API stream should be set dirty, in case it is later passed to DDI directly
        m_pDevice->m_dwStreamDirty |= 1;
        m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
    }

    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2 pData;
    pData = (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2)
            GetHalBufferPointer(D3DDP2OP_DRAWINDEXEDPRIMITIVE2, sizeof(*pData));
    pData->primType = pv->primType;
    pData->BaseVertexOffset = m_BaseVertexIndex;
    pData->MinIndex = m_MinVertexIndex;
    pData->NumVertices = m_NumVertices;
    pData->StartIndexOffset = m_pCurrentIndexStream->GetPrimitiveBase();
    pData->PrimitiveCount = pv->dwNumPrimitives;

    m_pCurrentIndexStream->SkipVertices(pv->dwNumIndices);

}
//-----------------------------------------------------------------------------
// This primitive is generated by the clipper.
// The vertices of this primitive are pointed to by the
// lpvOut member, which need to be copied into the
// command stream immediately after the command itself.
//
// Uses the following members of D3DFE_PROCESSVERTICES:
//      primType
//      dwNumVertices
//      dwNumPrimitives
//      dwOutputSize
//      dwFlags (D3DPV_NONCLIPPED)
//      lpdwRStates (FILLMODE)
//      lpvOut
//      ClipperState.current_vbuf
//

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DrawClippedPrim"

void
CD3DDDIDX8::DrawClippedPrim(D3DFE_PROCESSVERTICES* pv)
{
#ifdef DEBUG_PIPELINE
    if (g_DebugFlags & __DEBUG_NORENDERING)
        return;
#endif
    if (m_pDDIStream[0].m_pBuf != static_cast<CBuffer*>(m_pTLStreamClip->m_pVB) ||
        pv->dwOutputSize != m_pDDIStream[0].m_dwStride)
    {
        m_pTLStreamClip->SetVertexSize(pv->dwOutputSize);
        InsertStreamSource(m_pTLStreamClip);
        // API stream should be set dirty, in case it is later passed to DDI directly
        m_pDevice->m_dwStreamDirty |= 1;
        m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
    }
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    DWORD dwVertexPoolSize = pv->dwNumVertices * pv->dwOutputSize;
    LPVOID pVertices;
    if (pv->primType == D3DPT_TRIANGLEFAN)
    {
        if (pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME &&
            pv->dwFlags & D3DPV_NONCLIPPED)
        {
            // For unclipped (but pretended to be clipped) tri fans in
            // wireframe mode we generate 3-vertex tri fans to enable drawing
            // of interior edges
            BYTE vertices[__MAX_VERTEX_SIZE*3];
            BYTE *pV1 = vertices + pv->dwOutputSize;
            BYTE *pV2 = pV1 + pv->dwOutputSize;
            BYTE *pInput = (BYTE*)pv->lpvOut;
            memcpy(vertices, pInput, pv->dwOutputSize);
            pInput += pv->dwOutputSize;
            const DWORD nTriangles = pv->dwNumVertices - 2;
            pv->dwNumVertices = 3;
            pv->dwNumPrimitives = 1;
            pv->lpvOut = vertices;
            // Remove this flag for recursive call
            pv->dwFlags &= ~D3DPV_NONCLIPPED;
            for (DWORD i = nTriangles; i; i--)
            {
                memcpy(pV1, pInput, pv->dwOutputSize);
                memcpy(pV2, pInput + pv->dwOutputSize, pv->dwOutputSize);
                pInput += pv->dwOutputSize;
                // To enable all edge flag we set the fill mode to SOLID.
                // This will prevent checking the clip flags in the clipper
                // state
                pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] = D3DFILL_SOLID;
                DrawClippedPrim(pv);
                pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] = D3DFILL_WIREFRAME;
            }
            return;
        }
        // Lock should be before GetPrimitiveBase(), because the primitive
        // base could be changed during Lock()
        pVertices = m_pTLStreamClip->Lock(dwVertexPoolSize, this);
        LPD3DHAL_CLIPPEDTRIANGLEFAN pData;
        pData = (LPD3DHAL_CLIPPEDTRIANGLEFAN)
                GetHalBufferPointer(D3DDP2OP_CLIPPEDTRIANGLEFAN, sizeof(*pData));
        pData->FirstVertexOffset = m_pTLStreamClip->GetPrimitiveBase();
        pData->PrimitiveCount = pv->dwNumPrimitives;
        if (pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] != D3DFILL_WIREFRAME)
        {
            // Mark all exterior edges visible
            pData->dwEdgeFlags = 0xFFFFFFFF;
        }
        else
        {
            pData->dwEdgeFlags = 0;
            ClipVertex **clip = pv->ClipperState.current_vbuf;
            // Look at the exterior edges and mark the visible ones
            for(DWORD i = 0; i < pv->dwNumVertices; ++i)
            {
                if (clip[i]->clip & CLIPPED_ENABLE)
                    pData->dwEdgeFlags |= (1 << i);
            }
        }
    }
    else
    {
        // Lock should be before GetPrimitiveBase(), because the primitive
        // base could be changed during Lock()
        pVertices = m_pTLStreamClip->Lock(dwVertexPoolSize, this);
#if DBG
        if (pv->primType != D3DPT_LINELIST)
        {
            D3D_THROW_FAIL("Internal error - invalid primitive type");
        }
#endif
        LPD3DHAL_DP2DRAWPRIMITIVE2 pData;
        pData = (LPD3DHAL_DP2DRAWPRIMITIVE2)
                GetHalBufferPointer(D3DDP2OP_DRAWPRIMITIVE2, sizeof(*pData));
        pData->primType = D3DPT_LINELIST;
        pData->FirstVertexOffset = m_pTLStreamClip->GetPrimitiveBase();
        pData->PrimitiveCount = pv->dwNumPrimitives;
    }

    // Copy vertices to the clipped stream
    memcpy(pVertices, pv->lpvOut, dwVertexPoolSize);
    m_pTLStreamClip->Unlock();
    m_pTLStreamClip->SkipVertices(pv->dwNumVertices);

#if DBG
    if (m_bValidateCommands)
        ValidateCommand(lpDP2CurrCommand);
#endif
}
//-----------------------------------------------------------------------------
// This function is called whe software vertex processing is used
// Handle should be always legacy
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::SetVertexShader"

void
CD3DDDIDX8::SetVertexShader( DWORD dwHandle )
{
    DXGASSERT(D3DVSD_ISLEGACY(dwHandle));

    if (dwHandle != m_CurrentVertexShader)
    {
        m_CurrentVertexShader = dwHandle;
        LPD3DHAL_DP2VERTEXSHADER pData;
        pData = (LPD3DHAL_DP2VERTEXSHADER)
                GetHalBufferPointer(D3DDP2OP_SETVERTEXSHADER, sizeof(*pData));
        {
            // Drivers do not need to know about D3DFVF_LASTBETA_UBYTE4 bit
            dwHandle &= ~D3DFVF_LASTBETA_UBYTE4;
        }
        pData->dwHandle = dwHandle;
    }
}
//-----------------------------------------------------------------------------
// This function is called whe hardware vertex processing is used
// Redundant shader check has been done at the API level
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::SetVertexShaderHW"

void
CD3DDDIDX8::SetVertexShaderHW( DWORD dwHandle )
{
    m_CurrentVertexShader = dwHandle;
    LPD3DHAL_DP2VERTEXSHADER pData;
    pData = (LPD3DHAL_DP2VERTEXSHADER)
            GetHalBufferPointer(D3DDP2OP_SETVERTEXSHADER, sizeof(*pData));
    if( D3DVSD_ISLEGACY(dwHandle) )
    {
        // Drivers do not need to know about D3DFVF_LASTBETA_UBYTE4 bit
        dwHandle &= ~D3DFVF_LASTBETA_UBYTE4;
    }
    pData->dwHandle = dwHandle;
}
//-----------------------------------------------------------------------------
// Point sprites are drawn as indexed triangle list
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::StartPointSprites"

void CD3DDDIDX8::StartPointSprites()
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;
    
    // For StartPrimTL we should use vertex size, which will go to the driver
    DWORD tmpVertexSize = pv->dwOutputSize;
    pv->dwOutputSize = m_dwOutputSizePS;

    // Set new output vertex shader for the DDI
    SetVertexShader(m_dwVIDOutPS);
    
    // Reserve place for the output vertices
    const UINT size = NUM_SPRITES_IN_BATCH * 4 * pv->dwOutputSize;
    m_pCurSpriteVertex = (BYTE*)StartPrimTL(pv, size, TRUE);

    // Restore vertex size, which is size before point sprite emulation
    pv->dwOutputSize = tmpVertexSize;

    // Index stream used to hold indices
    m_pCurrentIndexStream = m_pIndexStream;
    pv->dwIndexSize = 2;
    // Reserve place for indices
    UINT count = NUM_SPRITES_IN_BATCH * 2 * 6;
    m_pCurPointSpriteIndex = (WORD*)m_pIndexStream->Lock(count, this);

    m_CurNumberOfSprites = 0;
    SetWithinPrimitive(TRUE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::EndPointSprites"

void CD3DDDIDX8::EndPointSprites()
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;
    m_pCurrentIndexStream->Unlock();
    m_pCurrentTLStream->Unlock();
    if (m_CurNumberOfSprites)
    {
        if (m_pDDIStream[__NUMSTREAMS].m_pBuf != static_cast<CBuffer*>(m_pCurrentIndexStream->m_pVBI) ||
            pv->dwIndexSize != m_pDDIStream[__NUMSTREAMS].m_dwStride)
        {
            m_pCurrentIndexStream->SetVertexSize(pv->dwIndexSize);
            InsertIndices(m_pCurrentIndexStream);
        }
        if (m_pDDIStream[0].m_pBuf != static_cast<CBuffer*>(m_pCurrentTLStream->m_pVB) ||
            m_dwOutputSizePS != m_pDDIStream[0].m_dwStride)
        {
            InsertStreamSource(m_pCurrentTLStream);
        }
        if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
        {
            m_pDevice->UpdateTextures();
            m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
        }
        UINT NumVertices = m_CurNumberOfSprites * 4;
        LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2 pData;
        pData = (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2)
                GetHalBufferPointer(D3DDP2OP_DRAWINDEXEDPRIMITIVE2, sizeof(*pData));
        pData->primType = D3DPT_TRIANGLELIST;
        pData->BaseVertexOffset = m_pCurrentTLStream->GetPrimitiveBase();
        pData->MinIndex = 0;
        pData->NumVertices = NumVertices;
        pData->StartIndexOffset = m_pCurrentIndexStream->GetPrimitiveBase();
        pData->PrimitiveCount = m_CurNumberOfSprites * 2;

        m_pCurrentIndexStream->SkipVertices(m_CurNumberOfSprites * 6);
        m_pCurrentTLStream->SkipVertices(NumVertices);

        m_CurNumberOfSprites = 0;
    }
    SetWithinPrimitive(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX8TL                                                            //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

CD3DDDIDX8TL::CD3DDDIDX8TL()
{
    m_ddiType = D3DDDITYPE_DX8TL;
    m_dwInterfaceNumber = 4;
}

//-----------------------------------------------------------------------------
CD3DDDIDX8TL::~CD3DDDIDX8TL()
{
    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::CreateVertexShader"

void
CD3DDDIDX8TL::CreateVertexShader(CONST DWORD* pdwDeclaration,
                                 DWORD dwDeclSize,
                                 CONST DWORD* pdwFunction,
                                 DWORD dwCodeSize,
                                 DWORD dwHandle,
                                 BOOL bLegacyFVF)
{
    FlushStates();
    LPD3DHAL_DP2CREATEVERTEXSHADER pData;
    pData = (LPD3DHAL_DP2CREATEVERTEXSHADER)
            GetHalBufferPointer(D3DDP2OP_CREATEVERTEXSHADER,
                                sizeof(*pData) + dwDeclSize + dwCodeSize);
    pData->dwHandle = dwHandle;
    pData->dwDeclSize = dwDeclSize;
    pData->dwCodeSize = dwCodeSize;
    LPBYTE p = (LPBYTE)&pData[1];
    memcpy(p, pdwDeclaration, dwDeclSize);
    if (pdwFunction)
    {
        p += dwDeclSize;
        memcpy(p, pdwFunction, dwCodeSize);
    }
    FlushStates();
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::DeleteVertexShader"

void
CD3DDDIDX8TL::DeleteVertexShader(DWORD dwHandle)
{
    if (dwHandle == m_CurrentVertexShader)
        m_CurrentVertexShader = 0;
    LPD3DHAL_DP2VERTEXSHADER pData;
    pData = (LPD3DHAL_DP2VERTEXSHADER)
            GetHalBufferPointer(D3DDP2OP_DELETEVERTEXSHADER, sizeof(*pData));
    pData->dwHandle = dwHandle;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::SetVertexShaderConstant"

void
CD3DDDIDX8TL::SetVertexShaderConstant(DWORD dwRegister, CONST VOID* data, DWORD count)
{
    const DWORD size = count << 4;
    LPD3DHAL_DP2SETVERTEXSHADERCONST pData;
    pData = (LPD3DHAL_DP2SETVERTEXSHADERCONST)
            GetHalBufferPointer(D3DDP2OP_SETVERTEXSHADERCONST,
                                sizeof(*pData) + size);
    pData->dwRegister = dwRegister;
    pData->dwCount = count;
    memcpy(pData+1, data, size);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::MultiplyTransform"

void
CD3DDDIDX8TL::MultiplyTransform(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat)
{
    // Send down the state and the matrix
    LPD3DHAL_DP2MULTIPLYTRANSFORM pData;
    pData = (LPD3DHAL_DP2MULTIPLYTRANSFORM)
            GetHalBufferPointer(D3DDP2OP_MULTIPLYTRANSFORM, sizeof(*pData));
    pData->xfrmType = state;
    pData->matrix = *lpMat;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::SetTransform"

void
CD3DDDIDX8TL::SetTransform(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat)
{
    // Send down the state and the matrix
    LPD3DHAL_DP2SETTRANSFORM pData;
    pData = (LPD3DHAL_DP2SETTRANSFORM)
            GetHalBufferPointer(D3DDP2OP_SETTRANSFORM, sizeof(*pData));
    pData->xfrmType = state;
    pData->matrix = *lpMat;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::SetViewport"

void
CD3DDDIDX8TL::SetViewport(CONST D3DVIEWPORT8* lpVwpData)
{
    // Update viewport size
    CD3DDDIDX6::SetViewport(lpVwpData);

    // Update Z range
    LPD3DHAL_DP2ZRANGE pData;
    pData = (LPD3DHAL_DP2ZRANGE)GetHalBufferPointer(D3DDP2OP_ZRANGE, sizeof(*pData));
    pData->dvMinZ = lpVwpData->MinZ;
    pData->dvMaxZ = lpVwpData->MaxZ;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::SetMaterial"

void
CD3DDDIDX8TL::SetMaterial(CONST D3DMATERIAL8* pMat)
{
    LPD3DHAL_DP2SETMATERIAL pData;
    pData = (LPD3DHAL_DP2SETMATERIAL)GetHalBufferPointer(D3DDP2OP_SETMATERIAL, sizeof(*pData));
    *pData = *((LPD3DHAL_DP2SETMATERIAL)pMat);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::SetLight"

void
CD3DDDIDX8TL::SetLight(DWORD dwLightIndex, CONST D3DLIGHT8* pLight)
{
    LPD3DHAL_DP2SETLIGHT pData;
    pData = (LPD3DHAL_DP2SETLIGHT)
            GetHalBufferPointer(D3DDP2OP_SETLIGHT,
                                sizeof(*pData) + sizeof(D3DLIGHT8));
    pData->dwIndex = dwLightIndex;
    pData->dwDataType = D3DHAL_SETLIGHT_DATA;
    D3DLIGHT8 UNALIGNED64 * p = (D3DLIGHT8 UNALIGNED64 *)((LPBYTE)pData + sizeof(D3DHAL_DP2SETLIGHT));
    *p = *pLight;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::CreateLight"

void
CD3DDDIDX8TL::CreateLight(DWORD dwLightIndex)
{
    LPD3DHAL_DP2CREATELIGHT pData;
    pData = (LPD3DHAL_DP2CREATELIGHT)GetHalBufferPointer(D3DDP2OP_CREATELIGHT, sizeof(*pData));
    pData->dwIndex = dwLightIndex;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::LightEnable"

void
CD3DDDIDX8TL::LightEnable(DWORD dwLightIndex, BOOL bEnable)
{
    LPD3DHAL_DP2SETLIGHT pData;
    pData = (LPD3DHAL_DP2SETLIGHT)GetHalBufferPointer(D3DDP2OP_SETLIGHT, sizeof(*pData));
    pData->dwIndex = dwLightIndex;
    if (bEnable)
        pData->dwDataType = D3DHAL_SETLIGHT_ENABLE;
    else
        pData->dwDataType = D3DHAL_SETLIGHT_DISABLE;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::SetClipPlane"

void
CD3DDDIDX8TL::SetClipPlane(DWORD dwPlaneIndex, CONST D3DVALUE* pPlaneEquation)
{
    LPD3DHAL_DP2SETCLIPPLANE pData;
    pData = (LPD3DHAL_DP2SETCLIPPLANE)
            GetHalBufferPointer(D3DDP2OP_SETCLIPPLANE, sizeof(*pData));
    pData->dwIndex = dwPlaneIndex;
    pData->plane[0] = pPlaneEquation[0];
    pData->plane[1] = pPlaneEquation[1];
    pData->plane[2] = pPlaneEquation[2];
    pData->plane[3] = pPlaneEquation[3];
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ClearBatch"

void
CD3DDDIDX8::ClearBatch(BOOL bWithinPrimitive)
{
    // Reset command buffer
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)lpvDP2Commands;
    dwDP2CommandLength = 0;
    dp2data.dwCommandOffset = 0;
    dp2data.dwCommandLength = 0;
    bDP2CurrCmdOP = 0;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::FlushStates"

void
CD3DDDIDX8::FlushStates(BOOL bReturnDriverError, BOOL bWithinPrimitive)
{
    HRESULT dwRet=D3D_OK;
    if (m_bWithinPrimitive)
        bWithinPrimitive = TRUE;
    if (dwDP2CommandLength) // Do we have some instructions to flush ?
    {
        m_pDevice->IncrementBatchCount();

        // Batch currently set VB streams
        CDDIStream* pStream = m_pDDIStream;
        for (UINT i=0; i < __NUMSTREAMS; i++)
        {
            if (pStream->m_pStream)
            {
                CVStream* p = static_cast<CVStream*>(pStream->m_pStream);
                CVertexBuffer* pVB = p->m_pVB;
                if (pVB)
                    pVB->Batch();
            }
            pStream++;
        }
        // Now pStream points to the index stream
        if (pStream->m_pStream)
        {
            CVIndexStream* p = static_cast<CVIndexStream*>(pStream->m_pStream);
            CIndexBuffer* pVB = p->m_pVBI;
            if (pVB)
                pVB->Batch();
        }
        // Save since it will get overwritten by ddrval after DDI call
        DWORD dwVertexSize = dp2data.dwVertexSize;

        dp2data.dwCommandLength = dwDP2CommandLength;
        //we clear this to break re-entering as SW rasterizer needs to lock DDRAWSURFACE
        dwDP2CommandLength = 0;
        // Try and set these 2 values only once during initialization
        dp2data.dwhContext = m_dwhContext;
        dp2data.lpdwRStates = (LPDWORD)lpwDPBuffer;

        // Spin waiting on the driver if wait requested
        do {
            // Need to set this since the driver may have overwrote it by
            // setting ddrval = DDERR_WASSTILLDRAWING
            dp2data.dwVertexSize = dwVertexSize;
            dwRet = m_pDevice->GetHalCallbacks()->DrawPrimitives2(&dp2data);
            if (dwRet != DDHAL_DRIVER_HANDLED)
            {
                D3D_ERR ( "Driver not handled in DrawPrimitives2" );
                // Need sensible return value in this case,
                // currently we return whatever the driver stuck in here.
            }
        } while (dp2data.ddrval == DDERR_WASSTILLDRAWING);

        dwRet= dp2data.ddrval;
        // update command buffer pointer
        if ((dwRet == D3D_OK) &&
            (dp2data.dwFlags & D3DHALDP2_SWAPCOMMANDBUFFER))
        {
            // Implement VidMem command buffer and
            // command buffer swapping.
        }

        // Restore to value before the DDI call
        dp2data.dwVertexSize = dwVertexSize;
        ClearBatch(bWithinPrimitive);
    }
    // There are situations when the command stream has no data,
    // but there is data in the vertex pool. This could happen, for instance
    // if every triangle got rejected while clipping. In this case we still
    // need to "Flush out" the vertex data.
    else if (dp2data.dwCommandLength == 0)
    {
        ClearBatch(bWithinPrimitive);
    }

    if( FAILED( dwRet ) )
    {
        ClearBatch(FALSE);
        if( !bReturnDriverError )
        {
            switch( dwRet )
            {
            case D3DERR_OUTOFVIDEOMEMORY:
                D3D_ERR("Driver out of video memory!");
                break;
            case D3DERR_COMMAND_UNPARSED:
                D3D_ERR("Driver could not parse this batch!");
                break;
            default:
                D3D_ERR("Driver returned error: %s", HrToStr(dwRet));
                break;
            }
            DPF_ERR("Driver failed command batch. Attempting to reset device"
                    " state. The device may now be in an unstable state and"
                    " the application may experience an access violation.");
        }
        else
        {
            throw dwRet;
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ProcessPointSprites"

void CD3DDDIDX8::PickProcessPrimitive()
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;
    if (pv->dwDeviceFlags & D3DDEV_DOPOINTSPRITEEMULATION)
    {
        m_pfnProcessPrimitive = ProcessPointSprites;
    }
    else
    if (pv->dwDeviceFlags & D3DDEV_TRANSFORMEDFVF)
    {
        m_pfnProcessPrimitive =
            static_cast<PFN_PROCESSPRIM>(ProcessPrimitiveT);
        m_pfnProcessIndexedPrimitive =
            static_cast<PFN_PROCESSPRIM>(ProcessIndexedPrimitiveT);
    }
    else
    if (pv->dwDeviceFlags & D3DDEV_DONOTCLIP)
    {
        m_pfnProcessPrimitive =
            static_cast<PFN_PROCESSPRIM>(ProcessPrimitive);
        m_pfnProcessIndexedPrimitive =
            static_cast<PFN_PROCESSPRIM>(ProcessIndexedPrimitive);
    }
    else
    {
        m_pfnProcessPrimitive =
            static_cast<PFN_PROCESSPRIM>(ProcessPrimitiveC);
        m_pfnProcessIndexedPrimitive =
            static_cast<PFN_PROCESSPRIM>(ProcessIndexedPrimitiveC);
    }
}
//-----------------------------------------------------------------------------
// Processes non-indexed primitives with untransformed vertices and without
// clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ProcessPrimitive"

void
CD3DDDIDX8::ProcessPrimitive(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);

    pv->lpvOut = StartPrimTL(pv, pv->dwNumVertices * pv->dwOutputSize, TRUE);
    HRESULT ret = pv->pGeometryFuncs->ProcessVertices(pv);
    if (ret != D3D_OK)
    {
        SetWithinPrimitive(FALSE);
        m_pCurrentTLStream->Unlock();
        D3D_THROW(ret, "Error in PSGP");
    }
    DrawPrim(pv);
    SetWithinPrimitive(FALSE);
    m_pCurrentTLStream->Unlock();
}
//-----------------------------------------------------------------------------
// Processes non-indexed primitives with untransformed vertices and with
// clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ProcessPrimitiveC"

void
CD3DDDIDX8::ProcessPrimitiveC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    // Update lighting and related flags
    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);

    PrepareForClipping(pv, 0);
    pv->lpvOut = StartPrimTL(pv, pv->dwNumVertices * pv->dwOutputSize, 
                             NeverReadFromTLBuffer(pv));
    // When a triangle strip is clipped, we draw indexed primitives
    // sometimes. This is why we need to initialize the index stream
    m_BaseVertexIndex = m_pCurrentTLStream->GetPrimitiveBase();
    m_pCurrentIndexStream = m_pIndexStream;

    HRESULT ret;
    if (pv->primType == D3DPT_POINTLIST)
    {
        // When all points are clipped by X or Y planes we do not throw
        // them away, because they could have point size and be visible
        ret = D3D_OK;
        DWORD clipIntersection = pv->pGeometryFuncs->ProcessVertices(pv);
        clipIntersection &= ~(D3DCS_LEFT | D3DCS_RIGHT | 
                              D3DCS_TOP | D3DCS_BOTTOM |
                              __D3DCLIPGB_ALL);
        if (!clipIntersection)
        {
            // There are some vertices inside the screen
            if (pv->dwClipUnion == 0)
                DrawPrim(pv);
            else
                ret = ProcessClippedPointSprites(pv);
        }
    }
    else
    {
        ret = pv->pGeometryFuncs->ProcessPrimitive(pv);
    }
    if (ret != D3D_OK)
    {
        SetWithinPrimitive(FALSE);
        m_pCurrentTLStream->Unlock();
        D3D_THROW(ret, "Error in PSGP");
    }
    SetWithinPrimitive(FALSE);
    m_pCurrentTLStream->Unlock();
    UpdateClipStatus(pDevice);
}
//-----------------------------------------------------------------------------
// Processes non-indexed primitives with transformed vertices with clipping
//
// Only transformed vertices generated by ProcessVertices call are allowed here
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ProcessPrimitiveT"

void
CD3DDDIDX8::ProcessPrimitiveT(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW);
    // Clipping must be enabled when we are here
    DXGASSERT((pv->dwDeviceFlags & D3DDEV_DONOTCLIP) == 0);

    BOOL bNoClipping = FALSE;

    pv->dwOutputSize = m_pDevice->m_pStream[0].m_dwStride;

    // We need to do special processing for point sprites - they should not be
    // clipped as points without size.
    if (m_pDevice->m_dwRuntimeFlags & D3DRT_POINTSIZEPRESENT &&
        pv->primType == D3DPT_POINTLIST)
    {
        // This function is called only if a device supports point sprites.
        // Otherwise DrawPoints() function should be called.
        DXGASSERT((pv->dwDeviceFlags & D3DDEV_DOPOINTSPRITEEMULATION) == 0);

        PrepareForClipping(pv, StartVertex);

        if (!(pv->dwDeviceFlags & D3DDEV_VBPROCVER))
        {
            // Set emulation flag, because we want to compute clipping code as
            // for point sprites
            pv->dwDeviceFlags |= D3DDEV_DOPOINTSPRITEEMULATION;
            // Compute clip codes, because there was no ProcessVertices
            DWORD clip_intersect = D3DFE_GenClipFlags(pv);
            UpdateClipStatus(static_cast<CD3DHal*>(m_pDevice));
            pv->dwDeviceFlags &= ~D3DDEV_DOPOINTSPRITEEMULATION;
            if (clip_intersect)
            {
                return;
            }
        }
        // There are some vertices inside the screen. We need to do clipping if
        // a result of ProcessVertices is used as input (clip union is unknown)
        // or clipping is needed based on clip union and guard band flags.
        if (pv->dwDeviceFlags & D3DDEV_VBPROCVER || CheckIfNeedClipping(pv))
        {
            // Set emulation flag, because clipped points should be expanded,
            // not regected. We will clip point sprites by viewport during
            // the expansion.
            pv->dwDeviceFlags |= D3DDEV_DOPOINTSPRITEEMULATION;

            // This will prevent computing clip codes second time.
            pv->dwDeviceFlags |= D3DDEV_VBPROCVER | D3DDEV_DONOTCOMPUTECLIPCODES;

            // Now we can call a function which will take care of point sprite
            // expansion, clipping, culling mode etc.
            ProcessPointSprites(pv, StartVertex);

            pv->dwDeviceFlags &= ~(D3DDEV_DOPOINTSPRITEEMULATION |
                                   D3DDEV_VBPROCVER |
                                   D3DDEV_DONOTCOMPUTECLIPCODES);
            return;
        }
        // We are here when all point centres are inside guard band. We can 
        // draw them as points without clipping, because device supports point
        // sprites.
        bNoClipping = TRUE;
    }

    if (m_pDevice->m_dwRuntimeFlags & D3DRT_USERMEMPRIMITIVE)
    {
        DXGASSERT(StartVertex == 0);
        // Copy vertices to the TL buffer
        UINT VertexPoolSize = pv->dwOutputSize * pv->dwNumVertices;
        pv->lpvOut = (BYTE*)StartPrimTL(pv, VertexPoolSize, FALSE);
        pv->position.lpvData = pv->lpvOut;
        memcpy(pv->lpvOut, m_pDevice->m_pStream[0].m_pData, VertexPoolSize);
    }
    else
        StartPrimVB(pv, &m_pDevice->m_pStream[0], StartVertex);

    if (bNoClipping)
    {
        DrawPrim(pv);
        goto l_exit;
    }

    PrepareForClipping(pv, StartVertex);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    pv->dwVIDOut = pv->dwVIDIn;
    pv->dwIndexOffset = 0;
    pv->lpvOut = pv->position.lpvData;

    if (!(pv->dwDeviceFlags & D3DDEV_VBPROCVER))
    {
        pv->dwFlags |= D3DPV_TLVCLIP;
        // Compute clip codes, because there was no ProcessVertices
        DWORD clip_intersect = D3DFE_GenClipFlags(pv);
        UpdateClipStatus(pDevice);
        if (clip_intersect)
            goto l_exit;
    }
    // When a triangle strip is clipped, we draw indexed primitives
    // sometimes.
    m_BaseVertexIndex = 0;
    HRESULT ret = pDevice->GeometryFuncsGuaranteed->DoDrawPrimitive(pv);
    if (ret != D3D_OK)
        throw ret;
l_exit:
    pv->dwFlags &= ~D3DPV_TLVCLIP;
    SetWithinPrimitive(FALSE);
    if (m_pDevice->m_dwRuntimeFlags & D3DRT_USERMEMPRIMITIVE)
    {
        m_pCurrentTLStream->Unlock();
    }
    else
    {
        // If DDI vertex stream has been set to the internal stream during 
        // clipping, we need to restore the original stream
        if (m_pDDIStream[0].m_pBuf != m_pDevice->m_pStream[0].m_pVB)
        {
            m_pDevice->m_dwStreamDirty |= 1;
            m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
        }
    }
    pv->dwFlags &= ~D3DPV_TLVCLIP;
}
//-----------------------------------------------------------------------------
// Processes indexed primitives with untransformed vertices and without
// clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ProcessIndexedPrimitive"

void
CD3DDDIDX8::ProcessIndexedPrimitive(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    // Update lighting and related flags
    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);

    pv->lpvOut = StartPrimTL(pv, pv->dwNumVertices * pv->dwOutputSize, TRUE);

    HRESULT ret = pv->pGeometryFuncs->ProcessVertices(pv);
    if (ret != D3D_OK)
    {
        SetWithinPrimitive(FALSE);
        m_pCurrentTLStream->Unlock();
        D3D_THROW(ret, "Error in PSGP");
    }

    if (pDevice->m_pIndexStream->m_pVBI)
        StartIndexPrimVB(pDevice->m_pIndexStream, m_StartIndex,
                         pv->dwIndexSize);
    else
        m_pCurrentIndexStream = m_pIndexStream;
    // Let the driver map indices to be relative to the start of
    // the processed vertices
    m_BaseVertexIndex = m_pCurrentTLStream->GetPrimitiveBase() -
                          m_MinVertexIndex * pv->dwOutputSize;
    DrawIndexPrim(pv);
    m_pCurrentTLStream->SkipVertices(pv->dwNumVertices);
    SetWithinPrimitive(FALSE);
    m_pCurrentTLStream->Unlock();
}


//-----------------------------------------------------------------------------
// Processes indexed primitives with untransformed vertices and with
// clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ProcessIndexedPrimitiveC"

void
CD3DDDIDX8::ProcessIndexedPrimitiveC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    // Update lighting and related flags
    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);

    pv->lpwIndices = (WORD*)(pDevice->m_pIndexStream->Data() +
                     m_StartIndex * pDevice->m_pIndexStream->m_dwStride);

    PrepareForClipping(pv, 0);

    pv->lpvOut = StartPrimTL(pv, pv->dwNumVertices * pv->dwOutputSize, FALSE);
    m_BaseVertexIndex = m_pCurrentTLStream->GetPrimitiveBase() -
                          m_MinVertexIndex * pv->dwOutputSize;

    pv->dwIndexOffset = m_MinVertexIndex;   // Needed for clipping
    m_pCurrentIndexStream = m_pIndexStream;

    this->dwDP2Flags &= ~D3DDDI_INDEXEDPRIMDRAWN;
    m_pCurrentTLStream->AddVertices(pv->dwNumVertices);
    DWORD NumVertices = pv->dwNumVertices;

    HRESULT ret = pv->pGeometryFuncs->ProcessIndexedPrimitive(pv);

    if (this->dwDP2Flags & D3DDDI_INDEXEDPRIMDRAWN)
        m_pCurrentTLStream->MovePrimitiveBase(NumVertices);
    else
        m_pCurrentTLStream->SubVertices(NumVertices);

    SetWithinPrimitive(FALSE);
    m_pCurrentTLStream->Unlock();
    UpdateClipStatus(pDevice);

    if (ret != D3D_OK)
    {
        D3D_THROW(ret, "Error in PSGP");
    }
}
//-----------------------------------------------------------------------------
// Processes indexed primitives with transformed vertices and with clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ProcessIndexedPrimitiveT"

void
CD3DDDIDX8::ProcessIndexedPrimitiveT(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW);
    // Clipping must be enabled when we are here
    DXGASSERT((pv->dwDeviceFlags & D3DDEV_DONOTCLIP) == 0);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    pv->dwOutputSize = m_pDevice->m_pStream[0].m_dwStride;

    if (m_pDevice->m_dwRuntimeFlags & D3DRT_USERMEMPRIMITIVE)
    {
        // We copy user vertices, starting from MinVertexIndex, to the internal
        // TL buffer and do the clipping. Vertex base changes in the process.

        // m_NumVertices has been computed as MinVertexIndex + NumVertices, so 
        // it needs to be adjusted, because vertex base has benn changed
        m_NumVertices -= m_MinVertexIndex;
        pv->dwNumVertices = m_NumVertices;
        // Copy vertices to the TL buffer
        UINT VertexPoolSize = pv->dwOutputSize * pv->dwNumVertices;
        pv->lpvOut = (BYTE*)StartPrimTL(pv, VertexPoolSize, FALSE);
        pv->position.lpvData = pv->lpvOut;
        memcpy(pv->lpvOut, 
               m_pDevice->m_pStream[0].m_pData + m_MinVertexIndex * pv->dwOutputSize, 
               VertexPoolSize);
        // We need to adjust m_BaseVertexIndex, bacause we do not want to 
        // re-compute indices for the new vertex base
        m_BaseVertexIndex = m_pCurrentTLStream->GetPrimitiveBase() - 
                            m_MinVertexIndex * pv->dwOutputSize;
        m_pCurrentTLStream->AddVertices(pv->dwNumVertices);        

        // During clipping we need to adjust indices by m_MinVertexIndex
        pv->dwIndexOffset = m_MinVertexIndex;

        pv->lpwIndices = (WORD*)(pDevice->m_pIndexStream->Data());
    }
    else
    {
        StartPrimVB(pv, &m_pDevice->m_pStream[0], StartVertex);
        m_BaseVertexIndex = pDevice->m_pIndexStream->m_dwBaseIndex *
                            pv->dwOutputSize;
        pv->dwIndexOffset = m_MinVertexIndex;   // For clipping
        pv->lpwIndices = (WORD*)(pDevice->m_pIndexStream->Data() +
                         m_StartIndex * pDevice->m_pIndexStream->m_dwStride);
    }

    PrepareForClipping(pv, StartVertex);
    if (!(pv->dwDeviceFlags & D3DDEV_VBPROCVER))
    {
        pv->dwFlags |= D3DPV_TLVCLIP;
        // Compute clip codes, because there was no ProcessVertices
        DWORD clip_intersect = D3DFE_GenClipFlags(pv);
        UpdateClipStatus(pDevice);
        if (clip_intersect)
            goto l_exit;
    }
    pv->dwVIDOut = pv->dwVIDIn;
    pv->lpvOut = pv->position.lpvData;
    m_pCurrentIndexStream = m_pIndexStream;

    HRESULT ret;
    ret = pDevice->GeometryFuncsGuaranteed->DoDrawIndexedPrimitive(pv);
    if (ret != D3D_OK)
        throw ret;
l_exit:
    SetWithinPrimitive(FALSE);
    if (m_pDevice->m_dwRuntimeFlags & D3DRT_USERMEMPRIMITIVE)
    {
        m_pCurrentTLStream->Unlock();
        m_pCurrentTLStream->MovePrimitiveBase(pv->dwNumVertices);        
    }
    else
    {
        // If DDI vertex stream has been set to the internal stream during 
        // clipping, we need to restore the original stream
        if (m_pDDIStream[0].m_pBuf != m_pDevice->m_pStream[0].m_pVB)
        {
            m_pDevice->m_dwStreamDirty |= 1;
            m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
        }
        // If DDI index stream has been set to the internal stream during 
        // clipping, we need to restore the original stream
        if (m_pDDIStream[__NUMSTREAMS].m_pBuf != m_pDevice->m_pIndexStream->m_pVBI)
        {
            m_pDevice->m_dwStreamDirty |= (1 << __NUMSTREAMS);
            m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
        }
    }
    pv->dwFlags &= ~D3DPV_TLVCLIP;
}
//-----------------------------------------------------------------------------
#if DBG

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ValidateCommand"

void CD3DDDIDX8::ValidateCommand(LPD3DHAL_DP2COMMAND lpCmd)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;

    if (!(pDevice->m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING))
        return;

    DWORD dwVertexSize = pv->dwOutputSize;
    BOOL bNeedUnlock = FALSE;
    UINT  count;
    BYTE* pVertices;
    CTLStream* pStream = (CTLStream*)m_pDDIStream[0].m_pStream;
    if (pStream->m_pVB)
        if (pStream->m_pVB->IsLocked())
            pVertices = pStream->m_pData;
        else
        {
            pVertices = pStream->Lock(pStream->m_pVB->GetBufferDesc()->Size, this);
            bNeedUnlock = TRUE;
        }
    else
        // User memory vertices
        pVertices = (LPBYTE)(dp2data.lpVertices);

    switch (lpCmd->bCommand)
    {
    case D3DDP2OP_DRAWPRIMITIVE:
        {
            LPD3DHAL_DP2DRAWPRIMITIVE pData = (LPD3DHAL_DP2DRAWPRIMITIVE)(lpCmd+1);
            count = GETVERTEXCOUNT(pData->primType, pData->PrimitiveCount);
            pVertices += pData->VStart * dwVertexSize;
            for (WORD i = 0; i < count; i++)
            {
                ValidateVertex((LPDWORD)(pVertices + i * dwVertexSize));
            }
        }
        break;
    case D3DDP2OP_DRAWPRIMITIVE2:
        {
            LPD3DHAL_DP2DRAWPRIMITIVE2 pData = (LPD3DHAL_DP2DRAWPRIMITIVE2)(lpCmd+1);
            count = GETVERTEXCOUNT(pData->primType, pData->PrimitiveCount);
            pVertices += pData->FirstVertexOffset;
            for (WORD i = 0; i < count; i++)
            {
                ValidateVertex((LPDWORD)(pVertices + i * dwVertexSize));
            }
        }
        break;
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE:
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE2:
        {
            BYTE* pIndices;
            BOOL bNeedUnlock = FALSE;
            CTLIndexStream* pStream = (CTLIndexStream*)m_pDDIStream[__NUMSTREAMS].m_pStream;
            if (pStream->m_pVBI->IsLocked())
                pIndices = pStream->m_pData;
            else
            {
                pIndices = pStream->Lock(pStream->m_pVBI->GetBufferDesc()->Size, this);
                bNeedUnlock = TRUE;
            }

            UINT MaxIndex;
            UINT MinIndex;
            if (lpCmd->bCommand == D3DDP2OP_DRAWINDEXEDPRIMITIVE)
            {
                LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pData =
                    (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE)(lpCmd+1);
                pIndices += pData->StartIndex * pv->dwIndexSize;
                pVertices += pData->BaseVertexIndex * dwVertexSize;
                MaxIndex = pData->MinIndex + pData->NumVertices - 1;
                count = GETVERTEXCOUNT(pData->primType, pData->PrimitiveCount);
                MinIndex = pData->MinIndex;
            }
            else
            {
                LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2 pData =
                    (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2)(lpCmd+1);
                pIndices += pData->StartIndexOffset;
                pVertices += pData->BaseVertexOffset;
                MaxIndex = pData->MinIndex + pData->NumVertices - 1;
                count = GETVERTEXCOUNT(pData->primType, pData->PrimitiveCount);
                MinIndex = pData->MinIndex;
            }
            for (WORD i = 0; i < count; i++)
            {
                DWORD index;
                if (pv->dwIndexSize == 4)
                    index = *(DWORD*)(pIndices + i * 4);
                else
                    index = *(WORD*)(pIndices + i * 2);
                if (index  < MinIndex || index  > MaxIndex)
                {
                    D3D_THROW_FAIL("Invalid index in the index stream");
                }
                BYTE* pVertex = &pVertices[index];
                if (pVertex < pVertices ||
                    pVertex > pVertices + dwVertexSize * MaxIndex)
                {
                    D3D_THROW_FAIL("Bad vertex address");
                }
                ValidateVertex((LPDWORD)(pVertices + index * dwVertexSize));
            }
            if (bNeedUnlock)
                pStream->Unlock();
        }
        break;
    case D3DDP2OP_CLIPPEDTRIANGLEFAN:
        if (bNeedUnlock)
            pStream->Unlock();
        CD3DDDIDX6::ValidateCommand(lpCmd);
        return;
    case D3DDP2OP_DRAWRECTPATCH:
    case D3DDP2OP_DRAWTRIPATCH:
        return;

    default:
        D3D_THROW_FAIL("Invalid DX8 drawing command in DP2 stream");
    }
    if (bNeedUnlock)
        pStream->Unlock();
}
#endif

//-----------------------------------------------------------------------------
// Volume Blt
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::VolBlt"

void
CD3DDDIDX8::VolBlt(CBaseTexture *lpDst, CBaseTexture* lpSrc, DWORD dwDestX,
                   DWORD dwDestY, DWORD dwDestZ, D3DBOX *pBox)
{
    if (bDP2CurrCmdOP == D3DDP2OP_VOLUMEBLT)
    { // Last instruction is a tex blt, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2VOLUMEBLT) <=
            dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2VOLUMEBLT lpVolBlt =
                (LPD3DHAL_DP2VOLUMEBLT)((LPBYTE)lpvDP2Commands +
                                        dwDP2CommandLength +
                                        dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpVolBlt->dwDDDestSurface   = lpDst == NULL ? 0 :
                lpDst->DriverAccessibleDrawPrimHandle();
            lpVolBlt->dwDDSrcSurface    = lpSrc->BaseDrawPrimHandle();
            lpVolBlt->dwDestX            = dwDestX;
            lpVolBlt->dwDestY            = dwDestY;
            lpVolBlt->dwDestZ            = dwDestZ;
            lpVolBlt->srcBox             = *pBox;
            lpVolBlt->dwFlags            = 0;
            dwDP2CommandLength += sizeof(D3DHAL_DP2VOLUMEBLT);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);

            // For the source, we want to call BatchBase since
            // we want to batch the backing (or sysmem) texture
            // rather than the promoted one.
            lpSrc->BatchBase();
            if(lpDst != 0)
            {
                lpDst->Batch();
            }
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2VOLUMEBLT) > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_VOLUMEBLT;
    bDP2CurrCmdOP = D3DDP2OP_VOLUMEBLT;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add texture blt data
    LPD3DHAL_DP2VOLUMEBLT lpVolBlt =
        (LPD3DHAL_DP2VOLUMEBLT)(lpDP2CurrCommand + 1);
    lpVolBlt->dwDDDestSurface   = lpDst == NULL ? 0 :
        lpDst->DriverAccessibleDrawPrimHandle();
    lpVolBlt->dwDDSrcSurface    = lpSrc->BaseDrawPrimHandle();
    lpVolBlt->dwDestX           = dwDestX;
    lpVolBlt->dwDestY           = dwDestY;
    lpVolBlt->dwDestZ           = dwDestZ;
    lpVolBlt->srcBox            = *pBox;
    lpVolBlt->dwFlags           = 0;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2VOLUMEBLT);
    // For the source, we want to call BatchBase since
    // we want to batch the backing (or sysmem) texture
    // rather than the promoted one.
    lpSrc->BatchBase();
    if(lpDst != 0)
    {
        lpDst->Batch();
    }
}

//-----------------------------------------------------------------------------
// Buffer Blt
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::BufBlt"

void
CD3DDDIDX8::BufBlt(CBuffer *lpDst, CBuffer* lpSrc, DWORD dwOffset,
                   D3DRANGE* pRange)
{
    if (bDP2CurrCmdOP == D3DDP2OP_BUFFERBLT)
    { // Last instruction is a tex blt, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2BUFFERBLT) <=
            dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2BUFFERBLT lpBufBlt =
                (LPD3DHAL_DP2BUFFERBLT)((LPBYTE)lpvDP2Commands +
                                        dwDP2CommandLength +
                                        dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpBufBlt->dwDDDestSurface   = lpDst == NULL ? 0 :
                lpDst->DriverAccessibleDrawPrimHandle();
            lpBufBlt->dwDDSrcSurface    = lpSrc->BaseDrawPrimHandle();
            lpBufBlt->dwOffset          = dwOffset;
            lpBufBlt->rSrc              = *pRange;
            lpBufBlt->dwFlags           = 0;
            dwDP2CommandLength += sizeof(D3DHAL_DP2BUFFERBLT);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);

            // For the source, we want to call BatchBase since
            // we want to batch the backing (or sysmem) texture
            // rather than the promoted one.
            lpSrc->BatchBase();
            if(lpDst != 0)
            {
                lpDst->Batch();
            }
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2BUFFERBLT) > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_BUFFERBLT;
    bDP2CurrCmdOP = D3DDP2OP_BUFFERBLT;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add texture blt data
    LPD3DHAL_DP2BUFFERBLT lpBufBlt =
        (LPD3DHAL_DP2BUFFERBLT)(lpDP2CurrCommand + 1);
    lpBufBlt->dwDDDestSurface   = lpDst == NULL ? 0 :
        lpDst->DriverAccessibleDrawPrimHandle();
    lpBufBlt->dwDDSrcSurface    = lpSrc->BaseDrawPrimHandle();
    lpBufBlt->dwOffset          = dwOffset;
    lpBufBlt->rSrc              = *pRange;
    lpBufBlt->dwFlags           = 0;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2BUFFERBLT);
    // For the source, we want to call BatchBase since
    // we want to batch the backing (or sysmem) texture
    // rather than the promoted one.
    lpSrc->BatchBase();
    if(lpDst != 0)
    {
        lpDst->Batch();
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::GetMaxRenderState"

// Note: This is a hack for DX8.1 release. The only renderstates that we added 
// in DX8.1 pertain to the NPATCHES features. At the time of DX8.1 release 
// there were no real drivers besides Reference that could support this feature. 
// We also know that the only can driver that does support the NPATCH feature 
// will support these renderstates (i.e. will be a DX8.1 driver. Hence it is 
// safe to assume that if any driver supports the D3DDEVCAPS_NPATCHES cap, then 
// it is a DX8.1 driver and understands the extra renderstates that were added 
// in DX8.1.
D3DRENDERSTATETYPE CD3DDDIDX8::GetMaxRenderState() 
{   
    const D3DCAPS8* pCaps = m_pDevice->GetD3DCaps();
    if (pCaps->DevCaps & D3DDEVCAPS_NPATCHES)
    {
        return D3D_MAXRENDERSTATES;
    }
    else
    {
        return D3DRS_POSITIONORDER;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\ddi.cpp ===
#include "pch.cpp"
#pragma hdrstop
/*==========================================================================;
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddi.cpp
 *  Content:    Direct3D DDI encapsulation implementations
 *
 ***************************************************************************/
#include "d3d8p.h"
#include "ddi.h"
#include "ddrawint.h"
#include "fe.h"
#include "pvvid.h"
#include "ddi.inl"

#ifndef WIN95
extern BOOL bVBSwapEnabled, bVBSwapWorkaround;
#endif // WIN95

extern HRESULT ProcessClippedPointSprites(D3DFE_PROCESSVERTICES *pv);
extern DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv);
extern DWORD g_DebugFlags;
HRESULT ValidateCommandBuffer(LPBYTE pBuffer, DWORD dwCommandLength, DWORD dwStride);

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDI                                                                 //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
CD3DDDI::CD3DDDI()
{
    m_StartIndex = 0;
    m_MinVertexIndex = 0;
    m_NumVertices = 0;
    m_BaseVertexIndex = 0;
}

//---------------------------------------------------------------------------
CD3DDDI::~CD3DDDI()
{
    return;
}
/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX6                                                              //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

// Command buffer size tuned to 16K to minimize flushes in Unreal
// * 1 = 16K bytes
const DWORD CD3DDDIDX6::dwD3DDefaultCommandBatchSize = 16384;

CD3DDDIDX6::CD3DDDIDX6() : CD3DDDI()
{
    m_ddiType = D3DDDITYPE_DX6;
    m_pDevice = NULL;
    m_bWithinPrimitive = FALSE;
    m_dwhContext = 0;
    m_pfnProcessPrimitive = NULL;
    m_pfnProcessIndexedPrimitive = NULL;
    m_dwInterfaceNumber = 3;

    lpDP2CurrBatchVBI = NULL;
    TLVbuf_size = 0;
    TLVbuf_base = 0;
    dwDP2CommandBufSize = 0;
    dwDP2CommandLength  = 0;
    lpvDP2Commands = NULL;
    lpDP2CurrCommand = NULL;
    wDP2CurrCmdCnt = 0;
    bDP2CurrCmdOP  = 0;
    bDummy         = 0;
    memset(&dp2data, 0x00, sizeof(dp2data) ) ;
    dwDP2VertexCount = 0;
    dwVertexBase     = 0;
    lpDDSCB1        = NULL;
    allocatedBuf    = NULL;
    alignedBuf      = NULL;
    dwTLVbufChanges = 0;
    dwDP2Flags      = 0;
    m_pPointStream = NULL;
    // For the legacy DDI, we say we are DX7
    m_dwInterfaceNumber = 3;
    lpwDPBuffer = NULL;
    dwDPBufferSize  = 0;
    m_pNullVB = 0;
#if DBG
    m_bValidateCommands = FALSE;
#endif
}
//---------------------------------------------------------------------
CD3DDDIDX6::~CD3DDDIDX6()
{
    delete m_pPointStream;
    m_pPointStream = NULL;
    if (m_pNullVB)
        m_pNullVB->DecrementUseCount();
    if (allocatedBuf)
        allocatedBuf->DecrementUseCount();
    allocatedBuf = NULL;
    if (lpDP2CurrBatchVBI)
        lpDP2CurrBatchVBI->DecrementUseCount();
    lpDP2CurrBatchVBI = NULL;
    if (lpDDSCB1)
        lpDDSCB1->DecrementUseCount();
    lpDDSCB1 = NULL;
    DestroyContext();
}
//---------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::NotSupported"

void
CD3DDDIDX6::NotSupported(char* msg)
{
    D3D_ERR("%s is not supported by the current DDI", msg);
    throw D3DERR_INVALIDCALL;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SceneCapture"

void
CD3DDDIDX6::SceneCapture(BOOL bState)
{
    D3D8_SCENECAPTUREDATA data;

    if (m_pDevice->GetHalCallbacks()->SceneCapture == 0)
        return;

    D3D_INFO(6, "SceneCapture, setting %d dwhContext = %d",
             bState, m_dwhContext);

    memset(&data, 0, sizeof(D3DHAL_SCENECAPTUREDATA));
    data.dwhContext = m_dwhContext;
    data.dwFlag = bState ? D3DHAL_SCENE_CAPTURE_START : D3DHAL_SCENE_CAPTURE_END;

    HRESULT ret = m_pDevice->GetHalCallbacks()->SceneCapture(&data);

    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK)
    {
        D3D_ERR("Driver failed to handle SceneCapture");
        throw (data.ddrval);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ClearBatch"

void
CD3DDDIDX6::ClearBatch(BOOL bWithinPrimitive)
{
    // Reset command buffer
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)lpvDP2Commands;
    dwDP2CommandLength = 0;
    dp2data.dwCommandOffset = 0;
    dp2data.dwCommandLength = 0;
    bDP2CurrCmdOP = 0;
    // Reset vertex buffer
    if (!bWithinPrimitive)
    {
        dp2data.dwVertexOffset = 0;
        this->dwDP2VertexCount = 0;
        this->dwVertexBase = 0;
        TLVbuf_Base() = 0;
        if (dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES)
        {
            // We are flushing a user mem primitive.
            // We need to clear dp2data.lpUMVertices
            // since we are done with it. We replace
            // it with TLVbuf.
            DDASSERT(lpDP2CurrBatchVBI == NULL);
            dp2data.hDDVertex = TLVbuf_GetVBI()->DriverAccessibleKernelHandle();
            lpDP2CurrBatchVBI = TLVbuf_GetVBI();
            lpDP2CurrBatchVBI->IncrementUseCount();
            dp2data.dwFlags &= ~D3DHALDP2_USERMEMVERTICES;
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::Init"

void
CD3DDDIDX6::Init( LPD3DBASE pDevice )
{
    m_pDevice = pDevice;
    CreateContext();
    GrowCommandBuffer(dwD3DDefaultCommandBatchSize);
    // Fill the dp2data structure with initial values
    dp2data.dwFlags = D3DHALDP2_SWAPCOMMANDBUFFER;
    dp2data.dwVertexType = D3DFVF_TLVERTEX; // Initial assumption
    dp2data.dwVertexSize = sizeof(D3DTLVERTEX); // Initial assumption
    ClearBatch(FALSE);

    // Since we plan to call TLV_Grow for the first time with "TRUE"
    dwDP2Flags |= D3DDDI_TLVBUFWRITEONLY;
    GrowTLVbuf((__INIT_VERTEX_NUMBER*2)*sizeof(D3DTLVERTEX), TRUE);

    // Create a dummy sysmem VB to be used as a backup for lowmem situations
    LPDIRECT3DVERTEXBUFFER8 t;
    HRESULT ret = CVertexBuffer::Create(pDevice,
                                        sizeof(D3DTLVERTEX),
                                        D3DUSAGE_INTERNALBUFFER | D3DUSAGE_DYNAMIC,
                                        D3DFVF_TLVERTEX,
                                        D3DPOOL_SYSTEMMEM,
                                        REF_INTERNAL,
                                        &t);
    if (ret != D3D_OK)
    {
        D3D_THROW(ret, "Cannot allocate internal backup TLVBuf");
    }
    m_pNullVB = static_cast<CVertexBuffer*>(t);

    m_pPointStream  = new CTLStream(FALSE);
    if (m_pPointStream == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal data structure CTLStream");

    m_pStream0 = NULL;
    m_CurrentVertexShader = 0;
#if DBG
    m_VertexSizeFromShader = 0;
#endif
    m_pIStream = NULL;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::CreateContext"

void
CD3DDDIDX6::CreateContext()
{
    D3D8_CONTEXTCREATEDATA data;
    HRESULT ret;

    D3D_INFO(6, "in CreateContext. Creating Context for driver = %08lx",
             this);

    memset(&data, 0, sizeof(data));

    data.hDD = m_pDevice->GetHandle();
    data.hSurface = m_pDevice->RenderTarget()->KernelHandle();
    if(m_pDevice->ZBuffer() != 0)
        data.hDDSZ = m_pDevice->ZBuffer()->KernelHandle();
    // Hack Alert!! dwhContext is used to inform the driver which version
    // of the D3D interface is calling it.
    data.dwhContext = m_dwInterfaceNumber;
    data.dwPID  = GetCurrentProcessId();
    // Hack Alert!! ddrval is used to inform the driver which driver type
    // the runtime thinks it is (DriverStyle registry setting)
    data.ddrval = m_ddiType;

    data.cjBuffer = dwDPBufferSize;
    data.pvBuffer = NULL;

    ret = m_pDevice->GetHalCallbacks()->CreateContext(&data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK)
    {
        D3D_ERR( "Driver did not handle ContextCreate" );
        throw D3DERR_INVALIDCALL;
    }
    m_dwhContext = data.dwhContext;

#if 0 //def WIN95
    LPWORD lpwDPBufferAlloced = NULL;
    if (D3DMalloc((void**)&lpwDPBufferAlloced, dwDPBufferSize) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate" );
        throw E_OUTOFMEMORY;
    }
    lpwDPBuffer = (LPWORD)(((DWORD) lpwDPBufferAlloced+31) & (~31));

#else
    if( dwDPBufferSize && (data.cjBuffer < dwDPBufferSize) )
    {
        D3D_ERR( "Driver did not correctly allocate DrawPrim buffer");
        throw D3DERR_INVALIDCALL;
    }

    // Need to save the buffer space provided and its size
    dwDPBufferSize = data.cjBuffer;
    lpwDPBuffer = (LPWORD)data.pvBuffer;
#endif
    D3D_INFO(6, "in CreateContext. Succeeded. dwhContext = %d",
             data.dwhContext);

}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::DestroyContext"

void
CD3DDDIDX6::DestroyContext()
{
    D3D8_CONTEXTDESTROYDATA data;
    HRESULT ret;

    D3D_INFO(6, "Destroying Context for driver = %08lx", this);
    D3D_INFO(6, "dwhContext = %d", m_dwhContext);

    if( m_dwhContext )
    {
        memset(&data, 0, sizeof(D3DHAL_CONTEXTDESTROYDATA));
        data.dwhContext = m_dwhContext;
        ret = m_pDevice->GetHalCallbacks()->ContextDestroy(&data);
        if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK)
        {
            D3D_WARN(0,"Failed ContextDestroy HAL call");
            return;
        }
    }
}
//-----------------------------------------------------------------------------
// This code may be needed when we debug some problems
#if 0
void PrintBuffer(LPBYTE alignedBuf, D3D8_DRAWPRIMITIVES2DATA* dp2data, LPBYTE lpvDP2Commands)
{
    FILE* f = fopen("\\ddi.log", "a+");
    if (f == NULL)
        return;
    fprintf(f,  "-----------\n");
    fprintf(f, "dwFlags: %d, dwVertexType: 0x%xh, CommandOffset: %d, CommandLength: %d, VertexOffset: %d, VertexLength: %d\n",
            dp2data->dwFlags,
            dp2data->dwVertexType,
            dp2data->dwCommandOffset,
            dp2data->dwCommandLength,
            dp2data->dwVertexOffset,
            dp2data->dwVertexLength,
            dp2data->dwVertexSize);
    float* p = (float*)alignedBuf;
    UINT nTex = FVF_TEXCOORD_NUMBER(dp2data->dwVertexType);
    for (UINT i=0; i < dp2data->dwVertexLength; i++)
    {
        fprintf(f, "%4d %10.5f %10.5f %10.5f %10.5f ", i, p[0], p[1], p[2], p[3]);
        UINT index = 4;
        if (dp2data->dwVertexType & D3DFVF_DIFFUSE)
        {
//            fprintf(f, "0x%6x ", *(DWORD*)&p[index]);
            index++;
        }
        if (dp2data->dwVertexType & D3DFVF_SPECULAR)
        {
//            fprintf(f, "0x%6x ", *(DWORD*)&p[index]);
            index++;
        }
        for (UINT j=0; j < nTex; j++)
        {
            fprintf(f, "%10.5f %10.5f ", p[index], p[index+1]);
            index += 2;
        }
        fprintf(f, "\n");
        p = (float*)((BYTE*)p + dp2data->dwVertexSize);
    }
    fclose(f);
}
#endif // 0
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::FlushStates"

void
CD3DDDIDX6::FlushStates(BOOL bReturnDriverError, BOOL bWithinPrimitive)
{
    HRESULT dwRet=D3D_OK;
    if (m_bWithinPrimitive)
        bWithinPrimitive = TRUE;
    if (dwDP2CommandLength) // Do we have some instructions to flush ?
    {
        m_pDevice->IncrementBatchCount();

        if (lpDP2CurrBatchVBI)
            lpDP2CurrBatchVBI->Batch();
        // Check if render target and / or z buffer is lost
        // Save since it will get overwritten by ddrval after DDI call
        DWORD dwVertexSize = dp2data.dwVertexSize;

        dp2data.dwVertexLength = dwDP2VertexCount;
        dp2data.dwCommandLength = dwDP2CommandLength;
        //we clear this to break re-entering as SW rasterizer needs to lock DDRAWSURFACE
        dwDP2CommandLength = 0;
        // Try and set these 2 values only once during initialization
        dp2data.dwhContext = m_dwhContext;
        dp2data.lpdwRStates = (LPDWORD)lpwDPBuffer;
        DDASSERT(dp2data.dwVertexSize != 0);
        D3D_INFO(6, "FVF passed to the driver via DrawPrimitives2 = 0x%08x", dp2data.dwVertexType);

            // If we need the same TLVbuf next time do not swap buffers.
            // Save and restore this bit
        BOOL bSwapVB = (dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) != 0;
#ifndef WIN95
        BOOL bDidWorkAround = FALSE;
#endif // WIN95
        if (bWithinPrimitive)
        {
            dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        }
        // At the end of the DP2 call we expect the VB to be unlocked if
        // 1. We cannot allow the driver to swap the VB
        // 2. We are using a VB (not USERMEMVERTICES)
        // 3. It is not TLVbuf
        // In this case we might as well tell the driver that it is unlocked.
        // More importantly, we need to let DDraw know that the VB is unlocked.
        if (!(dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER))
        {
            if ((lpDP2CurrBatchVBI) && (lpDP2CurrBatchVBI != TLVbuf_GetVBI()))
            {
                // This seems contradictory, but IsLocked() checks whether
                // the app is holding a Lock.
                if(!lpDP2CurrBatchVBI->IsLocked())
                {
                    lpDP2CurrBatchVBI->UnlockI();
                }
            }
        }
#ifndef WIN95
        else if (bVBSwapWorkaround && lpDP2CurrBatchVBI != 0 && lpDP2CurrBatchVBI == TLVbuf_GetVBI() && 
                 lpDP2CurrBatchVBI->GetBufferDesc()->Pool == D3DPOOL_DEFAULT)
        {
            static_cast<CDriverVertexBuffer*>(lpDP2CurrBatchVBI)->UnlockI();
            bDidWorkAround = TRUE;
        }
        if (!bVBSwapEnabled)  // Note: bVBSwapEnabled not the same as bSwapVB above.
                              // bVBSwapEnabled is a global to indicate whether VB
                              // VB swapping should be turned off due to broken
                              // Win2K kernel implementation
        {
            dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        }
#endif // WIN95

        // Spin waiting on the driver if wait requested
        do {
            // Need to set this since the driver may have overwrote it by
            // setting ddrval = DDERR_WASSTILLDRAWING
            dp2data.dwVertexSize = dwVertexSize;
            dwRet = m_pDevice->GetHalCallbacks()->DrawPrimitives2(&dp2data);
            if (dwRet != DDHAL_DRIVER_HANDLED)
            {
                D3D_ERR ( "Driver not handled in DrawPrimitives2" );
                // Need sensible return value in this case,
                // currently we return whatever the driver stuck in here.
            }

        } while (dp2data.ddrval == DDERR_WASSTILLDRAWING);

        dwRet = dp2data.ddrval;
        // update command buffer pointer
        if ((dwRet == D3D_OK) &&
            (dp2data.dwFlags & D3DHALDP2_SWAPCOMMANDBUFFER))
        {
            // Implement VidMem command buffer and
            // command buffer swapping.
        }
        // update vertex buffer pointer
        if ((dwRet == D3D_OK) &&
            (dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) &&
            dp2data.lpVertices)
        {
#if DBG
            if (this->lpDP2CurrBatchVBI->GetBufferDesc()->Pool == D3DPOOL_DEFAULT)
            {
                if ((VOID*)static_cast<CDriverVertexBuffer*>(this->lpDP2CurrBatchVBI)->GetCachedDataPointer() != (VOID*)dp2data.fpVidMem_VB)
                {
                    DPF(2, "Driver swapped VB pointer in FlushStates");
                }
            }
#endif // DBG

            if (lpDP2CurrBatchVBI == TLVbuf_GetVBI())
            {
                this->alignedBuf = (LPVOID)dp2data.fpVidMem_VB;
                this->TLVbuf_size = dp2data.dwLinearSize_VB;
            }

            this->lpDP2CurrBatchVBI->SetCachedDataPointer(
                (BYTE*)dp2data.fpVidMem_VB);
        }
#ifndef WIN95
        if (bDidWorkAround)
        {
            CDriverVertexBuffer *pVB = static_cast<CDriverVertexBuffer*>(lpDP2CurrBatchVBI);

            // Prepare a LockData structure for the HAL call
            D3D8_LOCKDATA lockData;
            ZeroMemory(&lockData, sizeof lockData);

            lockData.hDD = m_pDevice->GetHandle();
            lockData.hSurface = pVB->BaseKernelHandle();
            lockData.bHasRange = FALSE;
            lockData.dwFlags = D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK;

            HRESULT hr = m_pDevice->GetHalCallbacks()->Lock(&lockData);
            if (FAILED(hr))
            {
                D3D_ERR("Driver failed Lock in FlushStates");
                if (SUCCEEDED(dwRet))
                {
                    dwRet = hr;
                }
                this->alignedBuf = 0;
            }
            else
            {
#if DBG
                if (this->alignedBuf != lockData.lpSurfData)
                {
                    DPF(2, "Driver swapped VB pointer at Lock in FlushStates");
                }
#endif // DBG
                pVB->SetCachedDataPointer((BYTE*)lockData.lpSurfData);
                this->alignedBuf = lockData.lpSurfData;
            }
        }
#endif // WIN95
        // Restore flag if necessary
        if (bSwapVB)
            dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER;
        // Restore to value before the DDI call
        dp2data.dwVertexSize = dwVertexSize;
        ClearBatch(bWithinPrimitive);
    }
    // There are situations when the command stream has no data,
    // but there is data in the vertex pool. This could happen, for instance
    // if every triangle got rejected while clipping. In this case we still
    // need to "Flush out" the vertex data.
    else if (dp2data.dwCommandLength == 0)
    {
        ClearBatch(bWithinPrimitive);
    }

    if( FAILED( dwRet ) )
    {
        ClearBatch(FALSE);
        if( !bReturnDriverError )
        {
            switch( dwRet )
            {
            case D3DERR_OUTOFVIDEOMEMORY:
                D3D_ERR("Driver out of video memory!");
                break;
            case D3DERR_COMMAND_UNPARSED:
                D3D_ERR("Driver could not parse this batch!");
                break;
            default:
                D3D_ERR("Driver returned error: %s", HrToStr(dwRet));
                break;
            }
            DPF_ERR("Driver failed command batch. Attempting to reset device"
                    " state. The device may now be in an unstable state and"
                    " the application may experience an access violation.");
        }
        else
        {
            throw dwRet;
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::FlushstatesReq"

void
CD3DDDIDX6::FlushStatesReq(DWORD dwReqSize)
{
    DWORD sav = (dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER);
    dp2data.dwReqVertexBufSize = dwReqSize;
    dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER | D3DHALDP2_REQVERTEXBUFSIZE;
    try
    {
        FlushStates();
    }
    catch( HRESULT hr )
    {
        dp2data.dwFlags &= ~(D3DHALDP2_SWAPVERTEXBUFFER | D3DHALDP2_REQVERTEXBUFSIZE);
        dp2data.dwFlags |= sav;
        throw hr;
    }

    dp2data.dwFlags &= ~(D3DHALDP2_SWAPVERTEXBUFFER | D3DHALDP2_REQVERTEXBUFSIZE);
    dp2data.dwFlags |= sav;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::FlushStatesCmdBufReq"

void
CD3DDDIDX6::FlushStatesCmdBufReq(DWORD dwReqSize)
{
    dp2data.dwReqCommandBufSize = dwReqSize;
    dp2data.dwFlags |= D3DHALDP2_REQCOMMANDBUFSIZE;
    try
    {
        FlushStates();
    }
    catch( HRESULT hr )
    {
        dp2data.dwFlags &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
        throw hr;
    }
    dp2data.dwFlags &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ValidateDevice"

void
CD3DDDIDX6::ValidateDevice(LPDWORD lpdwNumPasses)
{
    HRESULT ret;
    D3D8_VALIDATETEXTURESTAGESTATEDATA vd;
    memset( &vd, 0, sizeof( vd ) );
    vd.dwhContext = m_dwhContext;

    // First, Update textures since drivers pass /fail this call based
    // on the current texture handles
    m_pDevice->UpdateTextures();

    // Flush states, so we can validate the current state
    FlushStates();

    // Now ask the driver!
    ret = m_pDevice->GetHalCallbacks()->ValidateTextureStageState(&vd);
    *lpdwNumPasses = vd.dwNumPasses;

    if (ret != DDHAL_DRIVER_HANDLED) 
        throw E_NOTIMPL;
    else if (FAILED(vd.ddrval))
        throw vd.ddrval;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ReserveSpaceInCommandBuffer"

LPVOID CD3DDDIDX6::ReserveSpaceInCommandBuffer(UINT ByteCount)
{
    if (dwDP2CommandLength + ByteCount > dwDP2CommandBufSize)
    {
        // Request the driver to grow the command buffer upon flush
        FlushStatesCmdBufReq(ByteCount);
        // Check if the driver did give us what we need or do it ourselves
        GrowCommandBuffer(ByteCount);
    }
    return (BYTE*)lpvDP2Commands + dwDP2CommandLength + dp2data.dwCommandOffset;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetRenderTarget"

void
CD3DDDIDX6::SetRenderTarget(CBaseSurface *pTarget, CBaseSurface *pZ)
{
    HRESULT ret;

    // We are going to destroy all texture handles, so we need to unset
    // all currently bound textures, because we have seen DX6 drivers
    // crash when called to destroy a texture handle of a currently set
    // texture - snene (4/24/00)
    m_pDevice->m_dwStageDirty = (1ul << m_pDevice->m_dwMaxTextureBlendStages) - 1ul; // set dirty so that UpdateTextures() is called next time around
    m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_TEXTURE_UPDATE;
    for (DWORD dwStage = 0; dwStage < m_pDevice->m_dwMaxTextureBlendStages; dwStage++)
    {
        SetTSS(dwStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, 0);
        m_pDevice->m_dwDDITexHandle[dwStage] = 0;
    }

    // Flush before switching RenderTarget..
    FlushStates();

    D3D8_SETRENDERTARGETDATA rtData;
    memset( &rtData, 0, sizeof( rtData ) );
    rtData.dwhContext = m_dwhContext;
    rtData.hDDS       = pTarget->KernelHandle();
    if( pZ )
        rtData.hDDSZ  = pZ->KernelHandle();

    ret = m_pDevice->GetHalCallbacks()->SetRenderTarget( &rtData );
    if ((ret != DDHAL_DRIVER_HANDLED) || (rtData.ddrval != DD_OK))
    {
        D3D_ERR( "Driver failed SetRenderTarget call" );
        // Need sensible return value in this case,
        // currently we return whatever the driver stuck in here.
        ret = rtData.ddrval;
        throw ret;
    }
    if( rtData.bNeedUpdate )
    {
        m_pDevice->UpdateDriverStates();
    }
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetRenderState"

void
CD3DDDIDX6::SetRenderState(D3DRENDERSTATETYPE dwStateType, DWORD value)
{
    if (bDP2CurrCmdOP == D3DDP2OP_RENDERSTATE)
    { // Last instruction is a renderstate, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2RENDERSTATE) <=
            dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2RENDERSTATE lpRState = (LPD3DHAL_DP2RENDERSTATE)
                ((LPBYTE)lpvDP2Commands + dwDP2CommandLength +
                 dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpRState->RenderState = dwStateType;
            lpRState->dwState = value;
            dwDP2CommandLength += sizeof(D3DHAL_DP2RENDERSTATE);
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2RENDERSTATE) > dwDP2CommandBufSize)
    {
            FlushStates();

            // Since we ran out of space, we were not able to put
            // (dwStateType, value) into the batch so rstates will reflect only
            // the last batched renderstate (since the driver updates rstates
            // from the batch). To fix this, we simply put the current
            // (dwStateType, value) into rstates.
            m_pDevice->UpdateRenderState(dwStateType, value);
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_RENDERSTATE;
    bDP2CurrCmdOP = D3DDP2OP_RENDERSTATE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add renderstate data
    LPD3DHAL_DP2RENDERSTATE lpRState;
    lpRState = (LPD3DHAL_DP2RENDERSTATE)(lpDP2CurrCommand + 1);
    lpRState->RenderState = dwStateType;
    lpRState->dwState = value;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) +
                          sizeof(D3DHAL_DP2RENDERSTATE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::UpdateWInfo"

void
CD3DDDIDX6::UpdateWInfo(CONST D3DMATRIX* lpMat)
{
    LPD3DHAL_DP2WINFO pData;
    pData = (LPD3DHAL_DP2WINFO)
            GetHalBufferPointer(D3DDP2OP_WINFO, sizeof(*pData));
    D3DMATRIX m = *lpMat;
    if( (m._33 == m._34) || (m._33 == 0.0f) )
    {
        D3D_WARN(1, "Cannot compute WNear and WFar from the supplied projection matrix");
        D3D_WARN(1, "Setting wNear to 0.0 and wFar to 1.0");
        pData->dvWNear = 0.0f;
        pData->dvWFar  = 1.0f;
        return;
    }
    pData->dvWNear = m._44 - m._43/m._33*m._34;
    pData->dvWFar  = (m._44 - m._43)/(m._33 - m._34)*m._34 + m._44;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetViewport"

void
CD3DDDIDX6::SetViewport(CONST D3DVIEWPORT8* lpVwpData)
{
    LPD3DHAL_DP2VIEWPORTINFO pData;
    pData = (LPD3DHAL_DP2VIEWPORTINFO)GetHalBufferPointer(D3DDP2OP_VIEWPORTINFO, sizeof(*pData));
    pData->dwX = lpVwpData->X;
    pData->dwY = lpVwpData->Y;
    pData->dwWidth = lpVwpData->Width;
    pData->dwHeight = lpVwpData->Height;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetTSS"

void
CD3DDDIDX6::SetTSS(DWORD dwStage,
                   D3DTEXTURESTAGESTATETYPE dwState,
                   DWORD dwValue)
{
    // Filter unsupported states
    if (dwState >= m_pDevice->m_tssMax)
        return;

    // Map DX8 filter enums to DX6/7 enums
    switch (dwState)
    {
    case D3DTSS_MAGFILTER: dwValue = texf2texfg[min(D3DTEXF_GAUSSIANCUBIC,dwValue)]; break;
    case D3DTSS_MINFILTER: dwValue = texf2texfn[min(D3DTEXF_GAUSSIANCUBIC,dwValue)]; break;
    case D3DTSS_MIPFILTER: dwValue = texf2texfp[min(D3DTEXF_GAUSSIANCUBIC,dwValue)]; break;
    }

    if (bDP2CurrCmdOP == D3DDP2OP_TEXTURESTAGESTATE)
    { // Last instruction is a texture stage state, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2TEXTURESTAGESTATE) <=
            dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2TEXTURESTAGESTATE lpRState =
                (LPD3DHAL_DP2TEXTURESTAGESTATE)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpRState->wStage = (WORD)dwStage;
            lpRState->TSState = (WORD)dwState;
            lpRState->dwValue = dwValue;
            dwDP2CommandLength += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2TEXTURESTAGESTATE) > dwDP2CommandBufSize)
    {
            FlushStates();
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_TEXTURESTAGESTATE;
    bDP2CurrCmdOP = D3DDP2OP_TEXTURESTAGESTATE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add renderstate data
    LPD3DHAL_DP2TEXTURESTAGESTATE lpRState =
        (LPD3DHAL_DP2TEXTURESTAGESTATE)(lpDP2CurrCommand + 1);
    lpRState->wStage = (WORD)dwStage;
    lpRState->TSState = (WORD)dwState;
    lpRState->dwValue = dwValue;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) +
                          sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
}
//---------------------------------------------------------------------
// Map D3DPRIMITIVETYPE to D3DHAL_DP2OPERATION for indexed primitives
const WORD iprim2cmdop[] = {
    0, // Invalid
    0, // Points are invalid too
    D3DDP2OP_INDEXEDLINELIST2,
    D3DDP2OP_INDEXEDLINESTRIP,
    D3DDP2OP_INDEXEDTRIANGLELIST2,
    D3DDP2OP_INDEXEDTRIANGLESTRIP,
    D3DDP2OP_INDEXEDTRIANGLEFAN
};
// Map D3DPRIMITIVETYPE to D3DHAL_DP2OPERATION
const WORD prim2cmdop[] = {
    0, // Invalid
    D3DDP2OP_POINTS,
    D3DDP2OP_LINELIST,
    D3DDP2OP_LINESTRIP,
    D3DDP2OP_TRIANGLELIST,
    D3DDP2OP_TRIANGLESTRIP,
    D3DDP2OP_TRIANGLEFAN
};
// Map D3DPRIMITIVETYPE to bytes needed in command stream
const WORD prim2cmdsz[] = {
    0, // Invalid
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2POINTS),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2LINELIST),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2LINESTRIP),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLELIST),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLESTRIP),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLEFAN)
};
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetVertexShader"

void CD3DDDIDX6::SetVertexShader(DWORD dwHandle)
{
    DXGASSERT(D3DVSD_ISLEGACY(dwHandle));
    DXGASSERT( (dwHandle == 0) || FVF_TRANSFORMED(dwHandle) );
    m_CurrentVertexShader = dwHandle;
#if DBG
    m_VertexSizeFromShader = ComputeVertexSizeFVF(dwHandle);
#endif
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetVertexShaderHW"

void CD3DDDIDX6::SetVertexShaderHW(DWORD dwHandle)
{
    DXGASSERT(D3DVSD_ISLEGACY(dwHandle));
    DXGASSERT( (dwHandle == 0) || FVF_TRANSFORMED(dwHandle) );
    m_CurrentVertexShader = dwHandle;
#if DBG
    m_VertexSizeFromShader = ComputeVertexSizeFVF(dwHandle);
#endif
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetStreamSource"

void CD3DDDIDX6::SetStreamSource(UINT StreamIndex, CVStream* pStream)
{
    DXGASSERT(StreamIndex == 0);
    m_pStream0 = pStream;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetIndices"

void CD3DDDIDX6::SetIndices(CVIndexStream* pStream)
{
    m_pIStream = pStream;
}
//-----------------------------------------------------------------------------
// Assumes that VB has not been changed between DrawPrimitive calss
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6_DrawPrimitiveFast"

void CD3DDDIDX6_DrawPrimitiveFast(CD3DBase* pDevice,
                                  D3DPRIMITIVETYPE primType,
                                  UINT StartVertex,
                                  UINT PrimitiveCount)
{
    CD3DDDIDX6* pDDI = static_cast<CD3DDDIDX6*>(pDevice->m_pDDI);

    UINT NumVertices = GETVERTEXCOUNT(primType, PrimitiveCount);
    pDDI->SetWithinPrimitive(TRUE);

    if(pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        pDevice->UpdateTextures();
        pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }

    pDDI->dwDP2VertexCount = max(pDDI->dwDP2VertexCount,
                                 StartVertex + NumVertices);

    // Check for space in the command buffer for new command.
    // The vertices are already in the vertex buffer.
    if (pDDI->dwDP2CommandLength + prim2cmdsz[primType] > pDDI->dwDP2CommandBufSize)
    {
        pDDI->FlushStates(FALSE, TRUE);
    }

    // Insert non indexed primitive instruction

    LPD3DHAL_DP2COMMAND lpDP2CurrCommand;
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)pDDI->lpvDP2Commands +
                        pDDI->dwDP2CommandLength + pDDI->dp2data.dwCommandOffset);
    pDDI->bDP2CurrCmdOP = (BYTE)prim2cmdop[primType];
    // This will initialize bCommand and bReserved
    *(WORD*)&lpDP2CurrCommand->bCommand = prim2cmdop[primType];
    if (pDDI->bDP2CurrCmdOP != D3DDP2OP_POINTS)
    {
        // Linestrip, trianglestrip, trianglefan, linelist and trianglelist are identical
        pDDI->wDP2CurrCmdCnt = (WORD)PrimitiveCount;
        lpDP2CurrCommand->wPrimitiveCount = (WORD)PrimitiveCount;
        LPD3DHAL_DP2LINESTRIP lpStrip = (LPD3DHAL_DP2LINESTRIP)(lpDP2CurrCommand + 1);
        lpStrip->wVStart = (WORD)StartVertex;
    }
    else
    {
        pDDI->wDP2CurrCmdCnt = 1;
        lpDP2CurrCommand->wPrimitiveCount = 1;
        LPD3DHAL_DP2POINTS lpPoints = (LPD3DHAL_DP2POINTS)(lpDP2CurrCommand + 1);
        lpPoints->wCount = (WORD)NumVertices;
        lpPoints->wVStart = (WORD)StartVertex;
    }
    pDDI->dwDP2CommandLength += prim2cmdsz[primType];

#if DBG
    if (pDDI->m_bValidateCommands)
        pDDI->ValidateCommand(lpDP2CurrCommand);
#endif
    pDDI->SetWithinPrimitive(FALSE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6_DrawPrimitive"

void CD3DDDIDX6_DrawPrimitive(CD3DBase* pDevice,
                              D3DPRIMITIVETYPE primType,
                              UINT StartVertex,
                              UINT PrimitiveCount)
{
#if DBG
    if (!(pDevice->BehaviorFlags() & D3DCREATE_PUREDEVICE))
    {
        CD3DHal* pDev = static_cast<CD3DHal*>(pDevice);
        UINT nVer = GETVERTEXCOUNT(primType, PrimitiveCount);
        pDev->ValidateDraw2(primType, StartVertex, PrimitiveCount, 
                            nVer, FALSE);
    }
#endif // DBG
    CD3DDDIDX6* pDDI = static_cast<CD3DDDIDX6*>(pDevice->m_pDDI);
    CVStream* pStream0 = &pDevice->m_pStream[0];
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(pDevice)->m_pv;

    pv->dwNumVertices = GETVERTEXCOUNT(primType, PrimitiveCount);
    pv->dwVIDOut = pDDI->m_CurrentVertexShader;
    pv->dwOutputSize = pStream0->m_dwStride;
    DXGASSERT(pStream0->m_pVB != NULL);
#if DBG
    if (pStream0->m_dwStride != pDDI->m_VertexSizeFromShader)
    {
        D3D_THROW_FAIL("Device requires stream stride and vertex size,"
                       "computed from vertex shader, to be the same");
    }
#endif
    if(pStream0->m_pVB->IsD3DManaged())
    {
        BOOL bDirty = FALSE;
        HRESULT result = pDevice->ResourceManager()->UpdateVideo(pStream0->m_pVB->RMHandle(), &bDirty);
        if(result != D3D_OK)
        {
            D3D_THROW(result, "Resource manager failed to create or update video memory VB");
        }
    }

    pDDI->StartPrimVB(pv, pStream0, StartVertex);

    CD3DDDIDX6_DrawPrimitiveFast(pDevice, primType, StartVertex, PrimitiveCount);
    pDevice->m_pfnDrawPrim = CD3DDDIDX6_DrawPrimitiveFast;
}
//-----------------------------------------------------------------------------
// Assumes that VB has not been changed between DrawIndexedPrimitive calls
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6_IndexedDrawPrimitiveFast"

void CD3DDDIDX6_DrawIndexedPrimitiveFast(CD3DBase* pDevice,
                                     D3DPRIMITIVETYPE primType,
                                     UINT BaseVertexIndex,
                                     UINT MinIndex, UINT NumVertices,
                                     UINT StartIndex, UINT PrimitiveCount)
{
    CD3DDDIDX6* pDDI = static_cast<CD3DDDIDX6*>(pDevice->m_pDDI);
    CVIndexStream* pIStream = pDevice->m_pIndexStream;

    UINT  NumIndices = GETVERTEXCOUNT(primType, PrimitiveCount);
    WORD* lpwIndices = (WORD*)(pIStream->Data() + StartIndex * pIStream->m_dwStride);
    pDDI->SetWithinPrimitive(TRUE);

#if DBG
    // DP2 HAL supports 16 bit indices only
    if (pIStream->m_dwStride != 2)
    {
        D3D_THROW_FAIL("Device does not support 32-bit indices");
    }
    DXGASSERT(BaseVertexIndex <= 0xFFFF &&
              NumVertices <= 0xFFFF &&
              PrimitiveCount <= 0xFFFF);
#endif

    DWORD dwByteCount;          // Command length plus indices
    DWORD dwIndicesByteCount;   // Indices only
    if(pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        pDevice->UpdateTextures();
        pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    dwIndicesByteCount = NumIndices << 1;
    dwByteCount = dwIndicesByteCount + sizeof(D3DHAL_DP2COMMAND) +
                  sizeof(D3DHAL_DP2STARTVERTEX);

    LPD3DHAL_DP2COMMAND lpDP2CurrCommand;
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)
                       pDDI->ReserveSpaceInCommandBuffer(dwByteCount);
    pDDI->bDP2CurrCmdOP = (BYTE)iprim2cmdop[primType];
    // This will initialize bCommand and bReserved
    *(WORD*)&lpDP2CurrCommand->bCommand = iprim2cmdop[primType];
    lpDP2CurrCommand->wPrimitiveCount = (WORD)PrimitiveCount;

    LPBYTE pIndices = (BYTE*)(lpDP2CurrCommand + 1);     // Place for indices
    WORD* pStartVertex = &((LPD3DHAL_DP2STARTVERTEX)(lpDP2CurrCommand+1))->wVStart;
    pIndices += sizeof(D3DHAL_DP2STARTVERTEX);

#if DBG
    if (lpDP2CurrCommand->bCommand == 0)
    {
        D3D_THROW_FAIL("Illegal primitive type");
    }
#endif
    *pStartVertex = (WORD)BaseVertexIndex;
    memcpy(pIndices, lpwIndices, dwIndicesByteCount);

    pDDI->wDP2CurrCmdCnt = (WORD)PrimitiveCount;
    pDDI->dwDP2CommandLength += dwByteCount;

#if DBG
    if (pDDI->m_bValidateCommands)
        pDDI->ValidateCommand(lpDP2CurrCommand);
#endif
    pDDI->dwDP2VertexCount = max(pDDI->dwDP2VertexCount, MinIndex + NumVertices);

    // End of the primitive
    pDDI->SetWithinPrimitive(FALSE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6_IndexedDrawPrimitive"

void CD3DDDIDX6_DrawIndexedPrimitive(CD3DBase* pDevice,
                                     D3DPRIMITIVETYPE primType,
                                     UINT BaseVertexIndex,
                                     UINT MinIndex, UINT NumVertices,
                                     UINT StartIndex, UINT PrimitiveCount)
{
#if DBG
    if (!(pDevice->BehaviorFlags() & D3DCREATE_PUREDEVICE))
    {
        CD3DHal* pDev = static_cast<CD3DHal*>(pDevice);
        pDev->ValidateDraw2(primType, MinIndex + BaseVertexIndex,
                            PrimitiveCount, NumVertices, TRUE, StartIndex);
    }
#endif // DBG
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(pDevice)->m_pv;
    CD3DDDIDX6* pDDI = static_cast<CD3DDDIDX6*>(pDevice->m_pDDI);
    CVIndexStream* pIStream = pDevice->m_pIndexStream;
    CVStream* pStream0 = &pDevice->m_pStream[0];

    DXGASSERT(pStream0->m_pVB != NULL);
    if(pStream0->m_pVB->IsD3DManaged())
    {
        BOOL bDirty = FALSE;
        HRESULT result = pDevice->ResourceManager()->UpdateVideo(pStream0->m_pVB->RMHandle(), &bDirty);
        if(result != D3D_OK)
        {
            D3D_THROW(result, "Resource manager failed to create or update video memory VB");
        }
    }

    // Parameters needed for StartPrimVB
    pv->dwNumVertices = NumVertices + MinIndex;
    pv->dwVIDOut = pDDI->m_CurrentVertexShader;
    pv->dwOutputSize = pStream0->m_dwStride;
#if DBG
    if (pStream0->m_dwStride != pDDI->m_VertexSizeFromShader)
    {
        D3D_THROW_FAIL("Device requires stream stride and vertex size,"
                       "computed from vertex shader, to be the same");
    }
#endif

    pDDI->StartPrimVB(pv, pStream0, BaseVertexIndex);

    CD3DDDIDX6_DrawIndexedPrimitiveFast(pDevice, primType, BaseVertexIndex,
                                        MinIndex, NumVertices,
                                        StartIndex, PrimitiveCount);
    pDevice->m_pfnDrawIndexedPrim = CD3DDDIDX6_DrawIndexedPrimitiveFast;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::DrawPrimitiveUP"

void
CD3DDDIDX6::DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                            UINT PrimitiveCount)
{
#if DBG
    if (m_pDevice->m_pStream[0].m_dwStride != m_VertexSizeFromShader)
    {
        D3D_THROW_FAIL("Device requires stream stride and vertex size,"
                       "computed from vertex shader, to be the same");
    }
#endif
    UINT NumVertices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
    if (NumVertices > LOWVERTICESNUMBER)
    {
        this->FlushStates();
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->DecrementUseCount();
            lpDP2CurrBatchVBI = NULL;
        }
        this->dwDP2VertexCount = NumVertices;
#if DBG
        DXGASSERT(PrimitiveCount <= 0xFFFF && this->dwDP2VertexCount <= 0xFFFF);
#endif
        dp2data.dwVertexType = m_CurrentVertexShader;
        dp2data.dwVertexSize = m_pDevice->m_pStream[0].m_dwStride;
        dp2data.lpVertices = m_pDevice->m_pStream[0].m_pData;
        dp2data.dwFlags |= D3DHALDP2_USERMEMVERTICES;
        dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
        {
            m_pDevice->UpdateTextures();
            m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
        }
        // Insert non indexed primitive instruction
        lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                            dwDP2CommandLength + dp2data.dwCommandOffset);
        bDP2CurrCmdOP = (BYTE)prim2cmdop[PrimitiveType];
        lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
        lpDP2CurrCommand->bReserved = 0;
        if (bDP2CurrCmdOP == D3DDP2OP_POINTS)
        {
            wDP2CurrCmdCnt = 1;
            LPD3DHAL_DP2POINTS lpPoints = (LPD3DHAL_DP2POINTS)(lpDP2CurrCommand + 1);
            lpPoints->wCount = (WORD)this->dwDP2VertexCount;
            lpPoints->wVStart = 0;
        }
        else
        {
            // Linestrip, trianglestrip, trianglefan, linelist and trianglelist are identical
            wDP2CurrCmdCnt = (WORD)PrimitiveCount;
            LPD3DHAL_DP2LINESTRIP lpStrip = (LPD3DHAL_DP2LINESTRIP)(lpDP2CurrCommand + 1);
            lpStrip->wVStart = 0;
        }
        lpDP2CurrCommand->wPrimitiveCount = wDP2CurrCmdCnt;
        dwDP2CommandLength += prim2cmdsz[PrimitiveType];

        this->FlushStates();
        dp2data.dwFlags &= ~D3DHALDP2_USERMEMVERTICES;
    }
    else
    {
        // There is no PURE HAL device for pre-DX8 HALs, so this cast is safe
        CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
        D3DFE_PROCESSVERTICES& pv = *pDevice->m_pv;
        // Copy vertices to the internal TL buffer and insert a new 
        // DrawPrimitive command
        UINT VertexPoolSize = m_pDevice->m_pStream[0].m_dwStride * NumVertices;
        pv.dwNumVertices = NumVertices;
        pv.dwOutputSize = m_pDevice->m_pStream[0].m_dwStride;
        pv.primType = PrimitiveType;
        pv.dwNumPrimitives = PrimitiveCount;
        pv.dwVIDOut = m_CurrentVertexShader;
        pv.lpvOut = StartPrimTL(&pv, VertexPoolSize, TRUE);
        memcpy(pv.lpvOut, m_pDevice->m_pStream[0].m_pData, VertexPoolSize);
        DrawPrim(&pv);
        EndPrim(pv.dwOutputSize);
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::DrawIndexedPrimitiveUP"

void
CD3DDDIDX6::DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                                  UINT MinVertexIndex,
                                  UINT NumVertexIndices,
                                  UINT PrimitiveCount)
{
#if DBG
    if (m_pDevice->m_pStream[0].m_dwStride != m_VertexSizeFromShader)
    {
        D3D_THROW_FAIL("Device requires stream stride and vertex size,"
                       "computed from vertex shader, to be the same");
    }
#endif
    if (NumVertexIndices > LOWVERTICESNUMBER)
    {
        this->FlushStates();
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->DecrementUseCount();
            lpDP2CurrBatchVBI = NULL;
        }
        this->dwDP2VertexCount = NumVertexIndices + MinVertexIndex;
#if DBG
        DXGASSERT(PrimitiveCount <= 0xFFFF && this->dwDP2VertexCount <= 0xFFFF);
#endif
        dp2data.dwVertexType = m_CurrentVertexShader;
        dp2data.dwVertexSize = m_pDevice->m_pStream[0].m_dwStride;
        dp2data.lpVertices = m_pDevice->m_pStream[0].m_pData;
        dp2data.dwFlags |= D3DHALDP2_USERMEMVERTICES;
        dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        DWORD dwByteCount;          // Command length plus indices
        DWORD dwIndicesByteCount;   // Indices only
        if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
        {
            m_pDevice->UpdateTextures();
            m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
        }
        dwIndicesByteCount = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount) << 1;
        dwByteCount = dwIndicesByteCount + sizeof(D3DHAL_DP2COMMAND) +
                      sizeof(D3DHAL_DP2STARTVERTEX);

        if (dwDP2CommandLength + dwByteCount > dwDP2CommandBufSize)
        {
            // Request the driver to grow the command buffer upon flush
            dp2data.dwReqCommandBufSize = dwByteCount;
            dp2data.dwFlags |= D3DHALDP2_REQCOMMANDBUFSIZE;
            try
            {
                FlushStates(FALSE,TRUE);
                dp2data.dwFlags &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
            }
            catch (HRESULT ret)
            {
                dp2data.dwFlags &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
                throw ret;
            }
            // Check if the driver did give us what we need or do it ourselves
            GrowCommandBuffer(dwByteCount);
        }
        // Insert indexed primitive instruction
        lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                           dwDP2CommandLength + dp2data.dwCommandOffset);
        lpDP2CurrCommand->bReserved = 0;
        lpDP2CurrCommand->wPrimitiveCount = (WORD)PrimitiveCount;

        LPBYTE pIndices = (BYTE*)(lpDP2CurrCommand + 1);     // Place for indices
        lpDP2CurrCommand->bCommand = (BYTE)iprim2cmdop[PrimitiveType];
        WORD* pStartVertex = &((LPD3DHAL_DP2STARTVERTEX)(lpDP2CurrCommand+1))->wVStart;
        pIndices += sizeof(D3DHAL_DP2STARTVERTEX);
        *pStartVertex = 0;

        bDP2CurrCmdOP = lpDP2CurrCommand->bCommand;

        memcpy(pIndices, m_pDevice->m_pIndexStream->m_pData, dwIndicesByteCount);

        wDP2CurrCmdCnt = lpDP2CurrCommand->wPrimitiveCount;
        dwDP2CommandLength += dwByteCount;

        this->FlushStates();
        dp2data.dwFlags &= ~D3DHALDP2_USERMEMVERTICES;
    }
    else
    {
        // There is no PURE HAL device for pre-DX8 HALs, so this cast is safe
        CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
        D3DFE_PROCESSVERTICES& pv = *pDevice->m_pv;

        m_MinVertexIndex = MinVertexIndex;
        // Copy vertices to the internal TL buffer and insert a new 
        // DrawIndexedPrimitive command
        UINT VertexPoolSize = m_pDevice->m_pStream[0].m_dwStride * NumVertexIndices;
        pv.dwNumVertices = NumVertexIndices;
        pv.dwOutputSize = m_pDevice->m_pStream[0].m_dwStride;
        pv.primType = PrimitiveType;
        pv.dwNumPrimitives = PrimitiveCount;
        pv.dwVIDOut = m_CurrentVertexShader;

        // Copy vertices
        UINT FirstVertexOffset = MinVertexIndex * pv.dwOutputSize;
        pv.lpvOut = StartPrimTL(&pv, VertexPoolSize, TRUE);
        memcpy(pv.lpvOut, m_pDevice->m_pStream[0].m_pData + FirstVertexOffset,
               VertexPoolSize);

        pv.dwNumIndices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
        pv.dwIndexSize = m_pDevice->m_pIndexStream->m_dwStride;
        pv.lpwIndices = (WORD*)(m_pDevice->m_pIndexStream->Data());

        m_dwIndexOffset = MinVertexIndex;
        AddVertices(pv.dwNumVertices);

        DrawIndexPrim(&pv);

        MovePrimitiveBase(NumVertexIndices);
        EndPrim(pv.dwOutputSize);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::DrawPrimPS"

void
CD3DDDIDX6::DrawPrimPS(D3DFE_PROCESSVERTICES* pv)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    BYTE* p = (BYTE*)pv->lpvOut;
    float PointSize = *(float*)&pv->lpdwRStates[D3DRS_POINTSIZE];
    float PointSizeMin = *(float*)&pv->lpdwRStates[D3DRS_POINTSIZE_MIN];
    if (PointSize < PointSizeMin)
        PointSize = PointSizeMin;
    if (PointSize > pv->PointSizeMax)
        PointSize = pv->PointSizeMax;

    for (UINT i=0; i < pv->dwNumVertices; i++)
    {
        if (pv->dwVIDOut & D3DFVF_PSIZE)
        {
            PointSize = *(float*)(p + pv->pointSizeOffsetOut);
            if (PointSize < PointSizeMin)
                PointSize = PointSizeMin;
            if (PointSize > pv->PointSizeMax)
                PointSize = pv->PointSizeMax;
        }
        DWORD diffuse = 0;
        DWORD specular = 0;
        if (pv->dwVIDOut & D3DFVF_DIFFUSE)
            diffuse = *(DWORD*)(p + pv->diffuseOffsetOut);
        if (pv->dwVIDOut & D3DFVF_SPECULAR)
            specular = *(DWORD*)(p + pv->specularOffsetOut);
        NextSprite(((float*)p)[0], ((float*)p)[1],   // x, y
                   ((float*)p)[2], ((float*)p)[3],   // z, w
                   diffuse, specular,
                   (float*)(p + pv->texOffsetOut),
                   pv->dwTextureCoordSizeTotal,
                   PointSize);
        p += pv->dwOutputSize;
    }
}
//---------------------------------------------------------------------
// Uses the following members of D3DFE_PROCESSVERTICES:
//      primType
//      dwNumVertices
//      dwNumPrimitives
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::DrawPrim"

void
CD3DDDIDX6::DrawPrim(D3DFE_PROCESSVERTICES* pv)
{
#ifdef DEBUG_PIPELINE
    if (g_DebugFlags & __DEBUG_NORENDERING)
        return;
#endif

    D3DPRIMITIVETYPE primType = pv->primType;
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    if (pv->primType == D3DPT_POINTLIST &&
        pv->dwDeviceFlags & D3DDEV_DOPOINTSPRITEEMULATION)
    {
        DrawPrimPS(pv);
        return;
    }
    // Check for space in the command buffer for new command.
    // The vertices are already in the vertex buffer.
    if (dwDP2CommandLength + prim2cmdsz[primType] > dwDP2CommandBufSize)
    {
        FlushStates(FALSE,TRUE);
    }
    this->AddVertices(pv->dwNumVertices);
    // Insert non indexed primitive instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    bDP2CurrCmdOP = (BYTE)prim2cmdop[primType];
    lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
    lpDP2CurrCommand->bReserved = 0;
    if (bDP2CurrCmdOP == D3DDP2OP_POINTS)
    {
        wDP2CurrCmdCnt = 1;
        LPD3DHAL_DP2POINTS lpPoints = (LPD3DHAL_DP2POINTS)(lpDP2CurrCommand + 1);
        lpPoints->wCount = (WORD)pv->dwNumVertices;
        lpPoints->wVStart = (WORD)this->dwVertexBase;
    }
    else
    {
        // Linestrip, trianglestrip, trianglefan, linelist and trianglelist are identical
        wDP2CurrCmdCnt = (WORD)pv->dwNumPrimitives;
        LPD3DHAL_DP2LINESTRIP lpStrip = (LPD3DHAL_DP2LINESTRIP)(lpDP2CurrCommand + 1);
        lpStrip->wVStart = (WORD)this->dwVertexBase;
    }
    lpDP2CurrCommand->wPrimitiveCount = wDP2CurrCmdCnt;
    dwDP2CommandLength += prim2cmdsz[primType];

    this->MovePrimitiveBase(pv->dwNumVertices);
#if DBG
    if (m_bValidateCommands)
        ValidateCommand(lpDP2CurrCommand);
#endif
}
//---------------------------------------------------------------------
//
// The vertices are already in the vertex buffer.
//
// Uses the following members of D3DFE_PROCESSVERTICES:
//      primType
//      dwNumVertices
//      dwNumPrimitives
//      dwNumIndices
//      dwIndexOffset
//      dwIndexSize
//      lpwIndices
//

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDDIDX6::DrawIndexPrim"

void
CD3DDDIDX6::DrawIndexPrim(D3DFE_PROCESSVERTICES* pv)
{
#ifdef DEBUG_PIPELINE
    if (g_DebugFlags & __DEBUG_NORENDERING)
        return;
#endif
#if DBG
    // DP2 HAL supports 16 bit indices only
    if (pv->dwIndexSize != 2)
    {
        D3D_THROW_FAIL("Device does not support 32-bit indices");
    }
#endif
    this->dwDP2Flags |= D3DDDI_INDEXEDPRIMDRAWN;
    DWORD dwByteCount;          // Command length plus indices
    DWORD dwIndicesByteCount;   // Indices only
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    dwIndicesByteCount = pv->dwNumIndices << 1;
    dwByteCount = dwIndicesByteCount + sizeof(D3DHAL_DP2COMMAND) +
                  sizeof(D3DHAL_DP2STARTVERTEX);

    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)
                       ReserveSpaceInCommandBuffer(dwByteCount);
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wPrimitiveCount = (WORD)pv->dwNumPrimitives;

    LPBYTE pIndices = (BYTE*)(lpDP2CurrCommand + 1);     // Place for indices
    lpDP2CurrCommand->bCommand = (BYTE)iprim2cmdop[pv->primType];
    WORD* pStartVertex = &((LPD3DHAL_DP2STARTVERTEX)(lpDP2CurrCommand+1))->wVStart;
    pIndices += sizeof(D3DHAL_DP2STARTVERTEX);

#if DBG
    if (lpDP2CurrCommand->bCommand == 0)
    {
        D3D_THROW_FAIL("Illegal primitive type");
    }
#endif
    bDP2CurrCmdOP = lpDP2CurrCommand->bCommand;

    // We have to handle the case when we copied vertices into our
    // TL buffer, so MinVertexIndex corresponds to 0.
    *pStartVertex = (WORD)this->dwVertexBase;
    if (m_dwIndexOffset == 0)
    {
        memcpy(pIndices, pv->lpwIndices, dwIndicesByteCount);
    }
    else
    if ((WORD)dwVertexBase > (WORD)m_dwIndexOffset)
    {
        // We can modify StartVertex by setting it outside vertex range
        *pStartVertex = (WORD)dwVertexBase - (WORD)m_dwIndexOffset;
        memcpy(pIndices, pv->lpwIndices, dwIndicesByteCount);
    }
    else
    {
        WORD* pout = (WORD*)pIndices;
        WORD* pin  = (WORD*)pv->lpwIndices;
        for (UINT i=0; i < pv->dwNumIndices; i++)
        {
            pout[i] = (WORD)pin[i] - (WORD)m_dwIndexOffset;
        }
    }

    wDP2CurrCmdCnt = lpDP2CurrCommand->wPrimitiveCount;
    dwDP2CommandLength += dwByteCount;

#if DBG
    if (m_bValidateCommands)
        ValidateCommand(lpDP2CurrCommand);
#endif

}
//-----------------------------------------------------------------------------
// This primitive is generated by the clipper.
// The vertices of this primitive are pointed to by the
// lpvOut member, which need to be copied into the
// command stream immediately after the command itself.
//
// Uses the following members of D3DFE_PROCESSVERTICES:
//      primType
//      dwNumVertices
//      dwNumPrimitives
//      dwOutputSize
//      dwFlags (D3DPV_NONCLIPPED)
//      lpdwRStates (FILLMODE)
//      lpvOut
//      ClipperState.current_vbuf
//

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::DrawClippedPrim"

void
CD3DDDIDX6::DrawClippedPrim(D3DFE_PROCESSVERTICES* pv)
{
#ifdef DEBUG_PIPELINE
    if (g_DebugFlags & __DEBUG_NORENDERING)
        return;
#endif
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    DWORD dwExtra = 0;
    LPVOID lpvVerticesImm;  // Place for vertices
    DWORD dwVertexPoolSize = pv->dwNumVertices * pv->dwOutputSize;
    if (pv->primType == D3DPT_TRIANGLEFAN)
    {
        if (pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME &&
            pv->dwFlags & D3DPV_NONCLIPPED)
        {
            // For unclipped (but pretended to be clipped) tri fans in
            // wireframe mode we generate 3-vertex tri fans to enable drawing
            // of interior edges
            BYTE vertices[__MAX_VERTEX_SIZE*3];
            BYTE *pV1 = vertices + pv->dwOutputSize;
            BYTE *pV2 = pV1 + pv->dwOutputSize;
            BYTE *pInput = (BYTE*)pv->lpvOut;
            memcpy(vertices, pInput, pv->dwOutputSize);
            pInput += pv->dwOutputSize;
            const DWORD nTriangles = pv->dwNumVertices - 2;
            pv->dwNumVertices = 3;
            pv->dwNumPrimitives = 1;
            pv->lpvOut = vertices;
            // Remove this flag for recursive call
            pv->dwFlags &= ~D3DPV_NONCLIPPED;
            for (DWORD i = nTriangles; i; i--)
            {
                memcpy(pV1, pInput, pv->dwOutputSize);
                memcpy(pV2, pInput + pv->dwOutputSize, pv->dwOutputSize);
                pInput += pv->dwOutputSize;
                // To enable all edge flag we set the fill mode to SOLID.
                // This will prevent checking the clip flags in the clipper
                // state
                pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] = D3DFILL_SOLID;
                DrawClippedPrim(pv);
                pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] = D3DFILL_WIREFRAME;
            }
            return;
        }
        dwExtra = sizeof(D3DHAL_DP2TRIANGLEFAN_IMM);
    }
    DWORD dwPad;
    dwPad = (sizeof(D3DHAL_DP2COMMAND) + dwDP2CommandLength + dwExtra) & 3;
    DWORD dwByteCount = sizeof(D3DHAL_DP2COMMAND) + dwPad + dwExtra +
                        dwVertexPoolSize;

    // Check for space in the command buffer for commands & vertices
    if (dwDP2CommandLength + dwByteCount > dwDP2CommandBufSize)
    {
        // Flush the current batch but hold on to the vertices
        FlushStates(FALSE,TRUE);
        if (dwByteCount > dwDP2CommandBufSize)
        {
            GrowCommandBuffer(dwByteCount);
        }

        dwPad = (sizeof(D3DHAL_DP2COMMAND) + dwExtra) & 3;
        dwByteCount = sizeof(D3DHAL_DP2COMMAND) + dwExtra + dwPad +
                      dwVertexPoolSize;
    }
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->wPrimitiveCount = (WORD)pv->dwNumPrimitives;
    lpDP2CurrCommand->bReserved = 0;
    if (pv->primType == D3DPT_TRIANGLEFAN)
    {
        // Insert inline instruction and vertices
        bDP2CurrCmdOP = D3DDP2OP_TRIANGLEFAN_IMM;
        lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
        LPD3DHAL_DP2TRIANGLEFAN_IMM lpTriFanImm;
        lpTriFanImm = (LPD3DHAL_DP2TRIANGLEFAN_IMM)(lpDP2CurrCommand + 1);
        if (pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME)
        {
            lpTriFanImm->dwEdgeFlags = 0;
            ClipVertex **clip = pv->ClipperState.current_vbuf;
            // Look at the exterior edges and mark the visible ones
            for(DWORD i = 0; i < pv->dwNumVertices; ++i)
            {
                if (clip[i]->clip & CLIPPED_ENABLE)
                    lpTriFanImm->dwEdgeFlags |= (1 << i);
            }
        }
        else
        {
            // Mark all exterior edges visible
            lpTriFanImm->dwEdgeFlags = 0xFFFFFFFF;
        }
        lpvVerticesImm = (LPBYTE)(lpTriFanImm + 1) + dwPad;
    }
    else
    {
        // Insert inline instruction and vertices
        bDP2CurrCmdOP = D3DDP2OP_LINELIST_IMM;
        lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
        lpvVerticesImm = (LPBYTE)(lpDP2CurrCommand + 1) + dwPad;
    }
    memcpy(lpvVerticesImm, pv->lpvOut, dwVertexPoolSize);
    dwDP2CommandLength += dwByteCount;
#if DBG
    if (m_bValidateCommands)
        ValidateCommand(lpDP2CurrCommand);
#endif

}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::PickProcessPrimitive"

void CD3DDDIDX6::PickProcessPrimitive()
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;
    if (pv->dwDeviceFlags & D3DDEV_DOPOINTSPRITEEMULATION)
    {
        m_pfnProcessPrimitive = ProcessPointSprites;
    }
    else
    if (pv->dwDeviceFlags & D3DDEV_DONOTCLIP)
    {
        // Transformed vertices should not be processed using
        // m_pfnProcessPrimitive. They should go directly to the DDI using
        // pDevice->m_pfnDrawPrim
        m_pfnProcessPrimitive = ProcessPrimitive;
        m_pfnProcessIndexedPrimitive = ProcessIndexedPrimitive;
    }
    else
    {
        if (pv->dwDeviceFlags & D3DDEV_TRANSFORMEDFVF)
        {
            m_pfnProcessPrimitive = ProcessPrimitiveTC;
            m_pfnProcessIndexedPrimitive = ProcessIndexedPrimitiveTC;
        }
        else
        {
            m_pfnProcessPrimitive = ProcessPrimitiveC;
            m_pfnProcessIndexedPrimitive = ProcessIndexedPrimitiveC;
        }
    }
}
//-----------------------------------------------------------------------------
// The function does the point sprite expansion
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ProcessPointSprites"

void
CD3DDDIDX6::ProcessPointSprites(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    DWORD dwOldCullMode = D3DCULL_NONE;   
    DWORD dwOldFillMode = D3DFILL_SOLID;
    // Point spritest should not be culled. They are generated assuming that 
    // D3DCULL_CCW is set
    if (pDevice->rstates[D3DRS_CULLMODE] == D3DCULL_CW)
    {
        dwOldCullMode = D3DCULL_CW;
        SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
    }

    // In case of multitexture we need to re-program texture stages to use
    // texture coordonate set 0, because we generate only one set during
    // emulation
    DWORD TexCoordIndex[D3DDP_MAXTEXCOORD];
    for (DWORD i=0; i < D3DDP_MAXTEXCOORD; i++)
    {
        if (pDevice->tsstates[i][D3DTSS_COLOROP] == D3DTOP_DISABLE)
            break;
        if (pDevice->m_lpD3DMappedTexI[i])
        {
            DWORD dwIndex = pDevice->tsstates[i][D3DTSS_TEXCOORDINDEX];
            if (dwIndex != 0)
            {
                TexCoordIndex[i] = dwIndex;
                SetTSS(i, D3DTSS_TEXCOORDINDEX, 0);
            }
            else
            {
                // Mark stage to not restore
                TexCoordIndex[i] = 0xFFFFFFFF;
            }
        }
    }

    // Fill mode should be SOLID for point sprites
    if (pDevice->rstates[D3DRS_FILLMODE] != D3DFILL_SOLID)
    {
        dwOldFillMode = pDevice->rstates[D3DRS_FILLMODE];
        SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
    }
    // Compute new output FVF
    m_dwVIDOutPS = pv->dwVIDOut;
    m_dwVIDOutPS &= ~D3DFVF_PSIZE;
    if (pv->lpdwRStates[D3DRS_POINTSPRITEENABLE])
    {
        // Generate two floats for texture coord set
        m_dwVIDOutPS &= 0xFF;
        m_dwVIDOutPS |= D3DFVF_TEX1;
    }
    m_dwOutputSizePS = ComputeVertexSizeFVF(m_dwVIDOutPS);

    StartPointSprites();

    UINT VertexPoolSize = pv->dwNumVertices * pv->dwOutputSize;

    if (pv->dwDeviceFlags & D3DDEV_TRANSFORMEDFVF)
    {
        // In case of transformed vertices, input is user memory (or vertex 
        // buffer) and the output is internal TL buffer
        pv->dwOutputSize = pv->position.dwStride;
        if (pv->dwDeviceFlags & D3DDEV_DONOTCLIP)
        {
            pv->lpvOut = (BYTE*)pv->position.lpvData;
            DrawPrim(pv);
        }
        else
        {
            if (!(pv->dwDeviceFlags & D3DDEV_DONOTCOMPUTECLIPCODES))
                PrepareForClipping(pv, StartVertex);
            pv->lpvOut = (BYTE*)pv->position.lpvData;
            HRESULT ret = D3D_OK;
            if (!(pv->dwDeviceFlags & D3DDEV_VBPROCVER))
            {
                // Compute clip codes, because there was no ProcessVertices
                DWORD clip_intersect = D3DFE_GenClipFlags(pv);
                UpdateClipStatus(pDevice);
                if (clip_intersect)
                {
                    goto l_exit;
                }
                // There are some vertices inside the screen
                if ( CheckIfNeedClipping(pv))
                    ret = ProcessClippedPointSprites(pv);
                else
                    DrawPrim(pv);
                }
            else
            {
                // With the result of ProcessVertices as input we do not know
                // clip union, so we need always do clipping
                ret = ProcessClippedPointSprites(pv);
            }

            if (ret != D3D_OK)
            {
                EndPointSprites();
                throw ret;
            }
        }
    }
    else
    {
        if (!(pv->dwDeviceFlags & D3DDEV_DONOTCLIP))
            PrepareForClipping(pv, 0);

        // Update lighting and related flags
        if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
            DoUpdateState(pDevice);

        UINT VertexPoolSize = pv->dwNumVertices * pv->dwOutputSize;
        pv->lpvOut = m_pPointStream->Lock(VertexPoolSize, this);

        // We call ProcessVertices instead of DrawPrimitive, because we want to
        // process sprites which are clippied by X or Y planes
        DWORD clipIntersection = pv->pGeometryFuncs->ProcessVertices(pv);

        HRESULT ret = D3D_OK;
        if (pv->dwDeviceFlags & D3DDEV_DONOTCLIP)
        {
            DrawPrim(pv);
        }
        else
        {
            // We throw away points which are clipped by Z or by user planes.
            // Otherwise a point sprite could be partially visible
            clipIntersection &= ~(D3DCS_LEFT | D3DCS_RIGHT | 
                                  D3DCS_TOP | D3DCS_BOTTOM |
                                  __D3DCLIPGB_ALL);
            if (!clipIntersection)
            {
                // There are some vertices inside the screen
                if (!CheckIfNeedClipping(pv))
                    DrawPrim(pv);
                else
                    ret = ProcessClippedPointSprites(pv);
            }
        }

        m_pPointStream->Unlock();
        m_pPointStream->Reset();
        
        if (ret != D3D_OK)
            D3D_THROW(ret, "Error in PSGP");

        if (!(pv->dwDeviceFlags & D3DDEV_DONOTCLIP))
            UpdateClipStatus(pDevice);
    }
l_exit:
    EndPointSprites();
    // Restore fill mode and cull mode if needed
    if (dwOldCullMode != D3DCULL_NONE)
    {
        SetRenderState(D3DRS_CULLMODE, dwOldCullMode);
    }
    if (dwOldFillMode != D3DFILL_SOLID)
    {
        SetRenderState(D3DRS_FILLMODE, dwOldFillMode);
    }
    // We need to re-send API vertex shader to the driver next time 
    // SetVertexShader is called. If we do not call the function then next 
    // the same SetVertexShader call will be ignored and driver vertex shader
    // will not be updated
    static_cast<CD3DHal*>(m_pDevice)->ForceFVFRecompute();

    // Now we need to restore re-programmed stages
    for (DWORD i=0; i < D3DDP_MAXTEXCOORD; i++)
    {
        if (pDevice->tsstates[i][D3DTSS_COLOROP] == D3DTOP_DISABLE)
            break;
        if (pDevice->m_lpD3DMappedTexI[i] && TexCoordIndex[i] != 0xFFFFFFFF)
        {
            this->SetTSS(i, D3DTSS_TEXCOORDINDEX, TexCoordIndex[i]);
        }
    }
}
//-----------------------------------------------------------------------------
// Processes non-indexed primitives with transformed vertices and with
// clipping
//
// Only transformed vertices generated by ProcessVertices call are allowed here
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ProcessPrimitiveTC"

void
CD3DDDIDX6::ProcessPrimitiveTC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    CVStream* pStream = &m_pDevice->m_pStream[0];

    PrepareForClipping(pv, StartVertex);

    pv->dwOutputSize = pStream->m_dwStride;
    pv->lpvOut = pv->position.lpvData;

    if (m_pDevice->m_dwRuntimeFlags & D3DRT_USERMEMPRIMITIVE)
    {
        DXGASSERT(StartVertex == 0);
        // Copy vertices to the TL buffer
        UINT VertexPoolSize = pv->dwOutputSize * pv->dwNumVertices;
        pv->lpvOut = (BYTE*)StartPrimTL(pv, VertexPoolSize, FALSE);
        pv->position.lpvData = pv->lpvOut;
        memcpy(pv->lpvOut, m_pDevice->m_pStream[0].m_pData, VertexPoolSize);
    }
    else
        StartPrimVB(pv, pStream, StartVertex);
    if (!(pv->dwDeviceFlags & D3DDEV_VBPROCVER))
    {
        pv->dwFlags |= D3DPV_TLVCLIP;
        // Compute clip codes, because there was no ProcessVertices
        DWORD clip_intersect = D3DFE_GenClipFlags(pDevice->m_pv);
        UpdateClipStatus(pDevice);
        if (clip_intersect)
            goto l_exit;
    }
    HRESULT ret = pDevice->GeometryFuncsGuaranteed->DoDrawPrimitive(pv);
    if (ret != D3D_OK)
    {
        EndPrim(pv->dwOutputSize);
        throw ret;
    }
l_exit:
    EndPrim(pv->dwOutputSize);
    pv->dwFlags &= ~D3DPV_TLVCLIP;
}
//-----------------------------------------------------------------------------
// Processes non-indexed primitives with untransformed vertices and with
// clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ProcessPrimitiveC"

void
CD3DDDIDX6::ProcessPrimitiveC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    PrepareForClipping(pv, 0);
    // Update lighting and related flags
    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);
    // When a triangle strip is clipped, we draw indexed primitives
    // sometimes. So we set m_dwIndexOffset to zero.
    m_dwIndexOffset = 0;
    UINT VertexPoolSize = pv->dwNumVertices * pv->dwOutputSize;
    pv->lpvOut = StartPrimTL(pv, VertexPoolSize, TRUE);

    HRESULT ret = pv->pGeometryFuncs->ProcessPrimitive(pv);
    if (ret != D3D_OK)
    {
        EndPrim(pv->dwOutputSize);
        D3D_THROW(ret, "Error in PSGP");
    }
    EndPrim(pv->dwOutputSize);
    UpdateClipStatus(pDevice);
}
//-----------------------------------------------------------------------------
// Processes non-indexed primitives with untransformed vertices and without
// clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ProcessPrimitive"

void
CD3DDDIDX6::ProcessPrimitive(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    // Update lighting and related flags
    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);

    UINT VertexPoolSize = pv->dwNumVertices * pv->dwOutputSize;
    pv->lpvOut = StartPrimTL(pv, VertexPoolSize, NeverReadFromTLBuffer(pv));

    HRESULT ret = pv->pGeometryFuncs->ProcessPrimitive(pv);
    if (ret != D3D_OK)
    {
        EndPrim(pv->dwOutputSize);
        D3D_THROW(ret, "Error in PSGP");
    }
    EndPrim(pv->dwOutputSize);
}
//-----------------------------------------------------------------------------
// Processes indexed primitive with untransformed vertices and without clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ProcessIndexedPrimitive"

void
CD3DDDIDX6::ProcessIndexedPrimitive(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    // Update lighting and related flags
    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);

    pv->lpwIndices = (WORD*)(pDevice->m_pIndexStream->Data() +
                     m_StartIndex * pDevice->m_pIndexStream->m_dwStride);

    m_dwIndexOffset = m_MinVertexIndex;
    pv->lpvOut = StartPrimTL(pv, pv->dwNumVertices * pv->dwOutputSize, TRUE);
    AddVertices(pv->dwNumVertices);

    HRESULT ret = pv->pGeometryFuncs->ProcessIndexedPrimitive(pv);

    MovePrimitiveBase(pv->dwNumVertices);
    EndPrim(pv->dwOutputSize);

    if (ret != D3D_OK)
        D3D_THROW(ret, "Error in PSGP");
}
//-----------------------------------------------------------------------------
// Processes indexed primitive with untransformed vertices and witht clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ProcessIndexedPrimitiveC"

void
CD3DDDIDX6::ProcessIndexedPrimitiveC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    pv->lpwIndices = (WORD*)(pDevice->m_pIndexStream->Data() +
                     m_StartIndex * pDevice->m_pIndexStream->m_dwStride);

    PrepareForClipping(pv, 0);

    // Update lighting and related flags
    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);

    pv->dwIndexOffset = m_MinVertexIndex;   // For clipping
    m_dwIndexOffset = m_MinVertexIndex;     // For DrawIndexPrim
    pv->lpvOut = StartPrimTL(pv, pv->dwNumVertices * pv->dwOutputSize, FALSE);
    DWORD dwNumVertices = pv->dwNumVertices;
    AddVertices(pv->dwNumVertices);

    this->dwDP2Flags &= ~D3DDDI_INDEXEDPRIMDRAWN;

    HRESULT ret = pv->pGeometryFuncs->ProcessIndexedPrimitive(pv);

    if (this->dwDP2Flags & D3DDDI_INDEXEDPRIMDRAWN)
    {
        // There was a indexed primitive drawn
        MovePrimitiveBase(dwNumVertices);
    }
    else
    {
        // All triangle were clipped. Remove vertices from TL buffer
        SubVertices(dwNumVertices);
    }
    EndPrim(pv->dwOutputSize);
    UpdateClipStatus(pDevice);

    if (ret != D3D_OK)
        D3D_THROW(ret, "Error in PSGP");
}
//-----------------------------------------------------------------------------
// Processes indexed primitive with transformed vertices and with clipping
//
// Only transformed vertices generated by ProcessVertices call are allowed here
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ProcessIndexedPrimitiveTC"

void
CD3DDDIDX6::ProcessIndexedPrimitiveTC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    HRESULT ret = S_OK;
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    CVStream* pStream = &m_pDevice->m_pStream[0];
    pv->lpwIndices = (WORD*)(pDevice->m_pIndexStream->Data() +
                     m_StartIndex * pDevice->m_pIndexStream->m_dwStride);

    PrepareForClipping(pv, StartVertex);

    pv->dwOutputSize = pStream->m_dwStride;
    pv->lpvOut = pv->position.lpvData;
    pv->dwNumVertices = m_MinVertexIndex + m_NumVertices;

    if (m_pDevice->m_dwRuntimeFlags & D3DRT_USERMEMPRIMITIVE)
    {
        // We copy user vertices, starting from MinVertexIndex, to the internal
        // TL buffer and do the clipping. Vertex base changes in the process.

        // m_NumVertices has been computed as MinVertexIndex + NumVertices, so 
        // it needs to be adjusted, because vertex base has benn changed
        m_NumVertices -= m_MinVertexIndex;
        pv->dwNumVertices = m_NumVertices;
        // Copy vertices to the TL buffer
        UINT VertexPoolSize = pv->dwOutputSize * pv->dwNumVertices;
        pv->lpvOut = (BYTE*)StartPrimTL(pv, VertexPoolSize, FALSE);
        pv->position.lpvData = pv->lpvOut;
        memcpy(pv->lpvOut, 
               m_pDevice->m_pStream[0].m_pData + m_MinVertexIndex * pv->dwOutputSize, 
               VertexPoolSize);
        // Pre-DX8 DDI does not have BaseVertexIndex parameter, so we need to 
        // re-compute indices before passing them to the driver to reflect
        // the changed vertex base
        m_dwIndexOffset = m_MinVertexIndex ;
    }
    else
    {
        StartPrimVB(pv, pStream, m_BaseVertexIndex);
        m_dwIndexOffset = 0;                    // For DrawIndexPrim
    }

    pv->dwNumVertices = m_NumVertices;

    if (!(pv->dwDeviceFlags & D3DDEV_VBPROCVER))
    {
        pv->dwFlags |= D3DPV_TLVCLIP;
        // Compute clip codes, because there was no ProcessVertices
        DWORD clip_intersect = D3DFE_GenClipFlags(pv);
        UpdateClipStatus(pDevice);
        if (clip_intersect)
            goto l_exit;
    }
    
    pv->dwIndexOffset = m_MinVertexIndex ;    // For clipping
    this->dwDP2Flags &= ~D3DDDI_INDEXEDPRIMDRAWN;
    DWORD dwNumVertices = pv->dwNumVertices;
    AddVertices(pv->dwNumVertices);

    ret = pDevice->GeometryFuncsGuaranteed->DoDrawIndexedPrimitive(pv);

    if (this->dwDP2Flags & D3DDDI_INDEXEDPRIMDRAWN)
    {
        // There was an indexed primitive drawn
        MovePrimitiveBase(dwNumVertices);
    }
    else
    {
        // All triangles were clipped. Remove vertices from TL buffer
        SubVertices(dwNumVertices);
    }
l_exit:
    pv->dwFlags &= ~D3DPV_TLVCLIP;
    EndPrim(pv->dwOutputSize);
    UpdateClipStatus(pDevice);
    if (ret != D3D_OK)
        throw ret;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::GrowCommandBuffer"

// Check and grow command buffer
void CD3DDDIDX6::GrowCommandBuffer(DWORD dwSize)
{
    HRESULT ret;
    if (dwSize > dwDP2CommandBufSize)
    {
        if (lpDDSCB1)
        {
            lpDDSCB1->DecrementUseCount();
            lpDDSCB1 = NULL;
        }
        // Create command buffer through Framework.
        // NOTE: Command buffers are always REF_INTERNAL
        // objects and must be released through
        // DecrementUseCount
        //
        ret = CCommandBuffer::Create(m_pDevice,
                                     dwSize,
                                     D3DPOOL_SYSTEMMEM,
                                     &lpDDSCB1);
        if (ret != DD_OK)
        {
            dwDP2CommandBufSize = 0;
            D3D_THROW(ret, "Failed to allocate Command Buffer");
        }
        // Lock command buffer
        ret = lpDDSCB1->Lock(0, dwSize, (BYTE**)&lpvDP2Commands, NULL);
        if (ret != DD_OK)
        {
            lpDDSCB1->DecrementUseCount();
            lpDDSCB1 = NULL;
            dwDP2CommandBufSize = 0;
            D3D_THROW(ret, "Could not lock command buffer");
        }
        // lpDDCommands will be filled in by the thunk layer
        dp2data.hDDCommands = lpDDSCB1->DriverAccessibleKernelHandle();
        dwDP2CommandBufSize = dwSize;
    }
}
//-----------------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called if vertices from user memory are used for rendering
//
// If bWriteOnly is set to TRUE, then there will be no read from the vertex
// processing output (no clipping or TL HAL).
//
// Expects the following members of D3DFE_PROCESSVERTICES to be initialized
//      dwNumVertices
//      lpvOut
//      dwOutputSize
//      dwVIDOut
//
// We fail vid mem VB for clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::StartPrimUserMem"

void
CD3DDDIDX6::StartPrimUserMem(D3DFE_PROCESSVERTICES* pv, UINT VertexPoolSize)
{
    // If the primitive is small, we copy vertices into the TL buffer
    if (pv->dwNumVertices < LOWVERTICESNUMBER)
    {
        LPVOID tmp = StartPrimTL(pv, VertexPoolSize, TRUE);
        memcpy(tmp, pv->lpvOut, VertexPoolSize);
        this->dwDP2VertexCount += pv->dwNumVertices;
    }
    else
    {
        // We can not mix user memory primitive with other primitives, so
        // flush the batch.
        // Do not forget to flush the batch after rendering this primitive
        this->FlushStates();

        SetWithinPrimitive( TRUE );
        // Release previously used vertex buffer (if any), because we do not
        // it any more
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->DecrementUseCount();
            lpDP2CurrBatchVBI = NULL;
        }
        dp2data.dwVertexType = pv->dwVIDOut;
        dp2data.dwVertexSize = pv->dwOutputSize;
        dp2data.lpVertices = pv->lpvOut;
        dp2data.dwFlags |= D3DHALDP2_USERMEMVERTICES;
        dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2Flags |= D3DDDI_USERMEMVERTICES;
        this->dwDP2VertexCount = pv->dwNumVertices;
        this->dwDP2VertexCountMask = 0;
    }
}
//-----------------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called only if vertices from user memory are NOT used for rendering
//
// Uses the following data from D3DFE_PROCESSVERTICES:
//      pv->dwVIDOut
//      pv->dwOutputSize
//      pv->dwNumVertices
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::StartPrimVB"

void
CD3DDDIDX6::StartPrimVB(D3DFE_PROCESSVERTICES * pv, CVStream* pStream,
                        DWORD dwStartVertex)
{
    CVertexBuffer * lpVBI = pStream->m_pVB;
    // If VID has been changed or new vertex buffer is used we flush the batch
    if (pv->dwVIDOut != dp2data.dwVertexType ||
        lpDP2CurrBatchVBI != lpVBI)
    {
        this->FlushStates();
        dp2data.dwVertexType = pv->dwVIDOut;
        dp2data.dwVertexSize = pv->dwOutputSize;
        dp2data.hDDVertex = lpVBI->DriverAccessibleKernelHandle();
        // Release previously used vertex buffer (if any), because we do not
        // need it any more. We did IncrementUseCount() to TL buffer,
        // so it is safe.
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->DecrementUseCount();
        }
        // If a vertex buffer is used for rendering, make sure that it is no
        // released by user. So do IncrementUseCount().
        lpDP2CurrBatchVBI = lpVBI;
        lpDP2CurrBatchVBI->IncrementUseCount();
    }
    DXGASSERT(dp2data.hDDVertex == lpVBI->DriverAccessibleKernelHandle());
    lpDP2CurrBatchVBI->Batch();
    SetWithinPrimitive( TRUE );
    this->dwVertexBase = dwStartVertex;
    dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
    this->dwDP2VertexCount = max(this->dwDP2VertexCount,
                                 this->dwVertexBase + pv->dwNumVertices);
    // Prevent modification of dwDP2VertexCount during DrawPrim
    this->dwDP2VertexCountMask = 0;
}
//-----------------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called when the runtime needs to output vertices to a TL buffer
// TL buffer grows if necessary
//
// Uses the following global variables:
//      pv->dwVIDOut
//      pv->dwNumVertices
//      this->dp2data
//      this->dwDP2VertexCount;
//      this->lpDP2CurrBatchVBI
//      this->dwDP2Flags
//      pv->dwOutputSize
// Updates the following variables:
//      this->dwVertexBase
//      this->dwDP2VertexCount;
//      this->lpDP2CurrBatchVBI
//      dp2data.dwFlags
 //     Sets "within primitive" to TRUE
// Returns:
//      TL buffer address
//
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::StartPrimTL"

LPVOID
CD3DDDIDX6::StartPrimTL(D3DFE_PROCESSVERTICES * pv, DWORD dwVertexPoolSize,
                        BOOL bWriteOnly)
{
    if (bWriteOnly)
    {
        if (dwVertexPoolSize > this->GetTLVbufSize())
        {
            this->GrowTLVbuf(dwVertexPoolSize, TRUE);
        }
    }
    else
    {
        if (this->dwDP2Flags & D3DDDI_TLVBUFWRITEONLY ||
            dwVertexPoolSize > this->GetTLVbufSize())
        {
            this->GrowTLVbuf(dwVertexPoolSize, FALSE);
        }
    }

    CVertexBuffer * lpVBI = this->TLVbuf_GetVBI();

    // If VID has been changed or new vertex buffer is used we flush the batch
    if (pv->dwVIDOut != dp2data.dwVertexType ||
        lpDP2CurrBatchVBI != lpVBI ||
        dp2data.hDDVertex != lpVBI->DriverAccessibleKernelHandle())
    {
        this->FlushStates();
        dp2data.dwVertexType = pv->dwVIDOut;
        dp2data.dwVertexSize = pv->dwOutputSize;
        dp2data.hDDVertex = lpVBI->DriverAccessibleKernelHandle();
        // Release previously used vertex buffer (if any), because we do not
        // need it any more. We did IncrementUseCount() to TL buffer,
        // so it is safe.
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->DecrementUseCount();
        }
        // If a vertex buffer is used for rendering, make sure that it is not
        // released by user. So do IncrementUseCount().
        lpDP2CurrBatchVBI = lpVBI;
        lpDP2CurrBatchVBI->IncrementUseCount();
    }
    SetWithinPrimitive( TRUE );
    this->dwVertexBase = this->dwDP2VertexCount;
    DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
    dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER;
    this->dwDP2VertexCountMask = 0xFFFFFFFF;

    return this->TLVbuf_GetAddress();
}
//---------------------------------------------------------------------
// This function should not be called from DrawVertexBufferVB
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::EndPrim"

void
CD3DDDIDX6::EndPrim(UINT vertexSize)
{
    // Should be called before the FlushStates
    SetWithinPrimitive(FALSE);
    if (this->dwDP2Flags & D3DDDI_USERMEMVERTICES)
        // We can not mix user memory primitive, so flush it.
    {
        FlushStates();
        this->dwDP2Flags &= ~D3DDDI_USERMEMVERTICES;
    }
    else
    if (lpDP2CurrBatchVBI == this->TLVbuf_GetVBI())
    {
        // If TL buffer was used, we have to move its internal base pointer
        this->TLVbuf_Base() = this->dwDP2VertexCount * vertexSize;
#if DBG
        if (this->TLVbuf_base > this->TLVbuf_size)
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Internal error: TL buffer error");
        }
#endif
    }
}
//----------------------------------------------------------------------
// Growing aligned vertex buffer implementation.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::GrowTLVbuf"

void
CD3DDDIDX6::GrowTLVbuf(DWORD growSize, BOOL bWriteOnly)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    DWORD dwRefCnt = 1;
    // Is ref cnt of TLVbuf 1 or 2 ?
    DWORD bTLVbufIsCurr = this->allocatedBuf == this->lpDP2CurrBatchVBI;

    BOOL bDP2WriteOnly = (dwDP2Flags & D3DDDI_TLVBUFWRITEONLY) != 0;
    // Avoid to many changes. Restrict TLVbuf to sys mem if too many changes
    if (this->dwTLVbufChanges >= D3D_MAX_TLVBUF_CHANGES)
    {
#if DBG
        if (this->dwTLVbufChanges == D3D_MAX_TLVBUF_CHANGES)
            DPF(1, "Too many changes: Limiting internal VB to sys mem.");
#endif
        bWriteOnly = FALSE;
    }
    if (this->TLVbuf_base || (bWriteOnly != bDP2WriteOnly))
    {
        FlushStatesReq(growSize);
        this->TLVbuf_base = 0;
    }
    if (growSize <= this->TLVbuf_size)
    {
        if (bWriteOnly == bDP2WriteOnly)
            return;
        else
            this->dwTLVbufChanges++;
    }
    if (this->allocatedBuf)
    {
        this->allocatedBuf->DecrementUseCount();
        this->allocatedBuf = NULL;
    }
    if (bTLVbufIsCurr)
    {
        if (this->lpDP2CurrBatchVBI)
            this->lpDP2CurrBatchVBI->DecrementUseCount();
        this->lpDP2CurrBatchVBI = NULL;
        this->dp2data.lpVertices = NULL;
    }
    DWORD dwNumVerts = (max(growSize, TLVbuf_size) + 31) / sizeof(D3DTLVERTEX);
    this->TLVbuf_size = dwNumVerts * sizeof(D3DTLVERTEX);
    D3DPOOL Pool = D3DPOOL_DEFAULT;
    DWORD dwUsage = D3DUSAGE_INTERNALBUFFER | D3DUSAGE_DYNAMIC;
    if (bWriteOnly)
    {
        dwUsage |= D3DUSAGE_WRITEONLY;
        dwDP2Flags |= D3DDDI_TLVBUFWRITEONLY;
    }
    else
    {
        dwDP2Flags &= ~D3DDDI_TLVBUFWRITEONLY;
    }
    LPDIRECT3DVERTEXBUFFER8 t;
    HRESULT ret = CVertexBuffer::Create(pDevice,
                                        this->TLVbuf_size,
                                        dwUsage,
                                        D3DFVF_TLVERTEX,
                                        Pool,
                                        REF_INTERNAL,
                                        &t); // This should fail duirng ulta-low memory situations. 
    if (ret != DD_OK)
    {
        // We set allocatedBuf to a valid VB object since it gets dereferenced many places without
        // checking for it being NULL. WE use the special "NULL" VB created at init time for just 
        // this purpose
        allocatedBuf = m_pNullVB;
        if (m_pNullVB) // We do this check because GrowTLVbuf will be called before m_pNullVB is set first time round.
        {
            allocatedBuf->IncrementUseCount();
            // Update lpDP2CurrentBatchVBI if necessary
            if (bTLVbufIsCurr)
            {
                lpDP2CurrBatchVBI = allocatedBuf;
                lpDP2CurrBatchVBI->IncrementUseCount();
                dp2data.hDDVertex = lpDP2CurrBatchVBI->DriverAccessibleKernelHandle();
            }
        }
        this->TLVbuf_size = 0;
        this->alignedBuf = NULL; // Lets see if some one tries to use this...
        D3D_THROW(ret, "Could not allocate internal vertex buffer");
    }
    allocatedBuf = static_cast<CVertexBuffer*>(t);
    ret = allocatedBuf->Lock(0, this->TLVbuf_size, (BYTE**)&alignedBuf, 0);
    if (ret != DD_OK)
    {
        TLVbuf_size = 0;
        alignedBuf = NULL; // Lets see if some one tries to use this...
        D3D_THROW(ret, "Could not lock internal vertex buffer");
    }
    // Update lpDP2CurrentBatchVBI if necessary
    if (bTLVbufIsCurr)
    {
        lpDP2CurrBatchVBI = allocatedBuf;
        lpDP2CurrBatchVBI->IncrementUseCount();
        dp2data.hDDVertex = lpDP2CurrBatchVBI->DriverAccessibleKernelHandle();
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::Clear"

void
CD3DDDIDX6::Clear(DWORD dwFlags, DWORD clrCount, LPD3DRECT clrRects,
                  D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil)
{
    HRESULT err;
    // Flush any outstanding geometry to put framebuffer/Zbuffer in a known
    // state for Clears that don't use tris (i.e. HAL Clears and Blts).
    // Note this doesn't work for tiled architectures
    // outside of Begin/EndScene, this will be fixed later


    FlushStates();

    // Clear2 HAL Callback exists
    D3D8_CLEAR2DATA Clear2Data;
    Clear2Data.dwhContext   = m_dwhContext;
    Clear2Data.dwFlags      = dwFlags;
    // Here I will follow the ClearData.dwFillColor convention that
    // color word is raw 32bit ARGB, unadjusted for surface bit depth
    Clear2Data.dwFillColor  = dwColor;
    // depth/stencil values both passed straight from user args
    Clear2Data.dvFillDepth  = dvZ;
    Clear2Data.dwFillStencil= dwStencil;
    Clear2Data.lpRects      = clrRects;
    Clear2Data.dwNumRects   = clrCount;
    Clear2Data.ddrval       = D3D_OK;
    Clear2Data.hDDS         = m_pDevice->RenderTarget()->KernelHandle();
    if(m_pDevice->ZBuffer() != 0)
    {
        Clear2Data.hDDSZ    = m_pDevice->ZBuffer()->KernelHandle();
    }
    else
    {
        Clear2Data.hDDSZ    = NULL;
    }
    err = m_pDevice->GetHalCallbacks()->Clear2(&Clear2Data);
    if (err != DDHAL_DRIVER_HANDLED)
    {
        D3D_THROW(E_NOTIMPL, "Driver does not support Clear");
    }
    else if (Clear2Data.ddrval != DD_OK)
    {
        D3D_THROW(Clear2Data.ddrval, "Error in Clear");
    }
    else
        return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::LockVB"

HRESULT __declspec(nothrow) CD3DDDIDX6::LockVB(CDriverVertexBuffer *pVB, DWORD dwFlags)
{
    if(pVB->GetCachedDataPointer() == 0)
    {
        HRESULT hr = pVB->LockI((dwFlags & D3DLOCK_DISCARD) | D3DLOCK_NOSYSLOCK);
        if(FAILED(hr))
        {
            DPF_ERR("Driver failed to lock a vertex buffer" 
                    " when attempting to cache the lock.");
            return hr;
        }
        DXGASSERT(pVB->GetCachedDataPointer() != 0);
    }
    else
    {
        DXGASSERT((dwFlags & (D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE)) == 0);
        // We CANNOT use the usual Sync check here (ie Device->BatchNumber <= pVB->BatchNumber)
        // since there are situations in which this condition is true, but the VB is not really
        // batched at all! This is the case for instance, when StartPrimVB calls FlushStates.
        // FlushStates rebatches the current VB but StartPrimVB then switches to a new one. So 
        // both new and old "appear" batched, but only one of them is. This would be harmless 
        // (as it is for textures), were it not for the fact that we call FlushStatesReq to 
        // swap the pointer. When we call FlushStatesReq on an unbatched VB, we pretty much 
        // swap a random pointer with very bad effects. This repros in the Unreal driver. (snene)
        if(static_cast<CVertexBuffer*>(pVB) == lpDP2CurrBatchVBI)
        {
            try
            {
                if((dwFlags & D3DLOCK_DISCARD) != 0)
                {
                    FlushStatesReq(pVB->GetBufferDesc()->Size);
                }
                else
                {
                    FlushStates();
                }
            }
            catch(HRESULT hr)
            {
                DPF_ERR("Driver failed the command batch submitted to it" 
                        " when attempting to swap the current pointer"
                        " in response to D3DLOCK_DISCARDCONTENTS.");
                pVB->SetCachedDataPointer(0);
                return hr;
            }
            DXGASSERT(pVB->GetCachedDataPointer() != 0);
        }
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::UnlockVB"

HRESULT __declspec(nothrow) CD3DDDIDX6::UnlockVB(CDriverVertexBuffer *pVB)
{
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::EndScene"
void
CD3DDDIDX6::EndScene()
{
    this->dwTLVbufChanges = 0; // reset this every frame
    SceneCapture(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX7                                                              //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
CD3DDDIDX7::CD3DDDIDX7() : CD3DDDIDX6()
{
    m_ddiType = D3DDDITYPE_DX7;
}
//-----------------------------------------------------------------------------
CD3DDDIDX7::~CD3DDDIDX7()
{
    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::SetRenderTarget"

void
CD3DDDIDX7::SetRenderTarget(CBaseSurface *pTarget, CBaseSurface* pZBuffer)
{
    LPD3DHAL_DP2SETRENDERTARGET pData;
    pData = (LPD3DHAL_DP2SETRENDERTARGET)
             GetHalBufferPointer(D3DDP2OP_SETRENDERTARGET, sizeof(*pData));
    pData->hRenderTarget = pTarget->DrawPrimHandle();
    if (pZBuffer)
        pData->hZBuffer = pZBuffer->DrawPrimHandle();
    else
        pData->hZBuffer = 0;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::TexBlt"

void
CD3DDDIDX7::TexBlt(DWORD dwDst, DWORD dwSrc,
                   LPPOINT p, RECTL *r)
{
    if (bDP2CurrCmdOP == D3DDP2OP_TEXBLT)
    { // Last instruction is a tex blt, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2TEXBLT) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2TEXBLT lpTexBlt = (LPD3DHAL_DP2TEXBLT)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpTexBlt->dwDDDestSurface   = dwDst;
            lpTexBlt->dwDDSrcSurface    = dwSrc;
            lpTexBlt->pDest             = *p;
            lpTexBlt->rSrc              = *r;
            lpTexBlt->dwFlags           = 0;
            dwDP2CommandLength += sizeof(D3DHAL_DP2TEXBLT);
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2TEXBLT) > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_TEXBLT;
    bDP2CurrCmdOP = D3DDP2OP_TEXBLT;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add texture blt data
    LPD3DHAL_DP2TEXBLT lpTexBlt = (LPD3DHAL_DP2TEXBLT)(lpDP2CurrCommand + 1);
    lpTexBlt->dwDDDestSurface   = dwDst;
    lpTexBlt->dwDDSrcSurface    = dwSrc;
    lpTexBlt->pDest             = *p;
    lpTexBlt->rSrc              = *r;
    lpTexBlt->dwFlags           = 0;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TEXBLT);

    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::InsertStateSetOp"

void
CD3DDDIDX7::InsertStateSetOp(DWORD dwOperation, DWORD dwParam,
                             D3DSTATEBLOCKTYPE sbt)
{
    LPD3DHAL_DP2STATESET pData;
    pData = (LPD3DHAL_DP2STATESET)GetHalBufferPointer(D3DDP2OP_STATESET,
                                                      sizeof(*pData));
    pData->dwOperation = dwOperation;
    pData->dwParam = dwParam;
    pData->sbType = sbt;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::SceneCapture"

void
CD3DDDIDX7::SceneCapture(BOOL bState)
{
    SetRenderState((D3DRENDERSTATETYPE)D3DRENDERSTATE_SCENECAPTURE, bState);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::SetPriority"

void
CD3DDDIDX7::SetPriority(CResource *pRes, DWORD dwPriority)
{
    DXGASSERT(pRes->BaseDrawPrimHandle() == pRes->DriverAccessibleDrawPrimHandle());

    if (bDP2CurrCmdOP == D3DDP2OP_SETPRIORITY)
    { // Last instruction is a set priority, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2SETPRIORITY) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2SETPRIORITY lpSetPriority = (LPD3DHAL_DP2SETPRIORITY)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpSetPriority->dwDDSurface    = pRes->BaseDrawPrimHandle();
            lpSetPriority->dwPriority     = dwPriority;
            dwDP2CommandLength += sizeof(D3DHAL_DP2SETPRIORITY);
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif

            pRes->BatchBase();
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETPRIORITY) > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new setpriority instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_SETPRIORITY;
    bDP2CurrCmdOP = D3DDP2OP_SETPRIORITY;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add texture blt data
    LPD3DHAL_DP2SETPRIORITY lpSetPriority = (LPD3DHAL_DP2SETPRIORITY)(lpDP2CurrCommand + 1);
    lpSetPriority->dwDDSurface = pRes->BaseDrawPrimHandle();
    lpSetPriority->dwPriority  = dwPriority;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETPRIORITY);

    pRes->BatchBase();
    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::SetTexLOD"

void
CD3DDDIDX7::SetTexLOD(CBaseTexture *pTex, DWORD dwLOD)
{
    DXGASSERT(pTex->BaseDrawPrimHandle() == pTex->DriverAccessibleDrawPrimHandle());

    if (bDP2CurrCmdOP == D3DDP2OP_SETTEXLOD)
    { // Last instruction is a set LOD, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2SETTEXLOD) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2SETTEXLOD lpSetTexLOD = (LPD3DHAL_DP2SETTEXLOD)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpSetTexLOD->dwDDSurface      = pTex->BaseDrawPrimHandle();
            lpSetTexLOD->dwLOD            = dwLOD;
            dwDP2CommandLength += sizeof(D3DHAL_DP2SETTEXLOD);
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif

            pTex->BatchBase();
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETTEXLOD) > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new set LOD instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_SETTEXLOD;
    bDP2CurrCmdOP = D3DDP2OP_SETTEXLOD;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add texture blt data
    LPD3DHAL_DP2SETTEXLOD lpSetTexLOD = (LPD3DHAL_DP2SETTEXLOD)(lpDP2CurrCommand + 1);
    lpSetTexLOD->dwDDSurface = pTex->BaseDrawPrimHandle();
    lpSetTexLOD->dwLOD       = dwLOD;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETTEXLOD);

    pTex->BatchBase();
    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::AddDirtyRect"

void
CD3DDDIDX7::AddDirtyRect(DWORD dwHandle, CONST RECTL *pRect)
{
    if (bDP2CurrCmdOP == D3DDP2OP_ADDDIRTYRECT)
    { // Last instruction is a adddirtyrect, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2ADDDIRTYRECT) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2ADDDIRTYRECT lpDirtyRect = (LPD3DHAL_DP2ADDDIRTYRECT)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpDirtyRect->dwSurface  = dwHandle;
            lpDirtyRect->rDirtyArea = *pRect;
            dwDP2CommandLength += sizeof(D3DHAL_DP2ADDDIRTYRECT);
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2ADDDIRTYRECT) > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_ADDDIRTYRECT;
    bDP2CurrCmdOP = D3DDP2OP_ADDDIRTYRECT;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add adddirtyrect data
    LPD3DHAL_DP2ADDDIRTYRECT lpDirtyRect = (LPD3DHAL_DP2ADDDIRTYRECT)(lpDP2CurrCommand + 1);
    lpDirtyRect->dwSurface  = dwHandle;
    lpDirtyRect->rDirtyArea = *pRect;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2ADDDIRTYRECT);

    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::AddDirtyBox"

void
CD3DDDIDX7::AddDirtyBox(DWORD dwHandle, CONST D3DBOX *pBox)
{
    if (bDP2CurrCmdOP == D3DDP2OP_ADDDIRTYBOX)
    { // Last instruction is a adddirtybox, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2ADDDIRTYBOX) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2ADDDIRTYBOX lpDirtyBox = (LPD3DHAL_DP2ADDDIRTYBOX)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpDirtyBox->dwSurface = dwHandle;
            lpDirtyBox->DirtyBox  = *pBox;
            dwDP2CommandLength += sizeof(D3DHAL_DP2ADDDIRTYBOX);
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2ADDDIRTYBOX) > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_ADDDIRTYBOX;
    bDP2CurrCmdOP = D3DDP2OP_ADDDIRTYBOX;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add adddirtybox data
    LPD3DHAL_DP2ADDDIRTYBOX lpDirtyBox = (LPD3DHAL_DP2ADDDIRTYBOX)(lpDP2CurrCommand + 1);
    lpDirtyBox->dwSurface = dwHandle;
    lpDirtyBox->DirtyBox  = *pBox;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2ADDDIRTYBOX);

    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::Clear"

void
CD3DDDIDX7::Clear(DWORD dwFlags, DWORD clrCount, LPD3DRECT clrRects,
                  D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil)
{
    DWORD dwCommandSize = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2CLEAR) + sizeof(RECT) * (clrCount - 1);

    // Check to see if there is space to add a new command for space
    if (dwCommandSize + dwDP2CommandLength > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_CLEAR;
    bDP2CurrCmdOP = D3DDP2OP_CLEAR;
    lpDP2CurrCommand->bReserved = 0;
    wDP2CurrCmdCnt = (WORD)clrCount;
    lpDP2CurrCommand->wStateCount = wDP2CurrCmdCnt;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    dwDP2CommandLength += dwCommandSize;

    // Write data
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(lpDP2CurrCommand + 1);
    pData->dwFlags = dwFlags;
    pData->dwFillColor = dwColor;
    pData->dvFillDepth = dvZ;
    pData->dwFillStencil = dwStencil;
    memcpy(pData->Rects, clrRects, clrCount * sizeof(D3DRECT));
}

//-----------------------------------------------------------------------------
// This function should be called from PaletteUpdateNotify
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::UpdatePalette"

void
CD3DDDIDX7::UpdatePalette(DWORD dwPaletteHandle,
                          DWORD dwStartIndex,
                          DWORD dwNumberOfIndices,
                          PALETTEENTRY *pFirstIndex)
{
    DWORD   dwSizeChange=sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2UPDATEPALETTE) + dwNumberOfIndices*sizeof(PALETTEENTRY);
    if (bDP2CurrCmdOP == D3DDP2OP_UPDATEPALETTE)
    { // Last instruction is same, append this one to it
        if (dwDP2CommandLength + dwSizeChange <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2UPDATEPALETTE lpUpdatePal = (LPD3DHAL_DP2UPDATEPALETTE)((LPBYTE)lpvDP2Commands +
                    dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpUpdatePal->dwPaletteHandle=dwPaletteHandle + 1;
            lpUpdatePal->wStartIndex=(WORD)dwStartIndex;
            lpUpdatePal->wNumEntries=(WORD)dwNumberOfIndices;
            memcpy((LPVOID)(lpUpdatePal+1),(LPVOID)pFirstIndex,
                dwNumberOfIndices*sizeof(PALETTEENTRY));
            dwDP2CommandLength += dwSizeChange;
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + dwSizeChange > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_UPDATEPALETTE;
    bDP2CurrCmdOP = D3DDP2OP_UPDATEPALETTE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add texture blt data
    LPD3DHAL_DP2UPDATEPALETTE lpUpdatePal = (LPD3DHAL_DP2UPDATEPALETTE)(lpDP2CurrCommand + 1);
    lpUpdatePal->dwPaletteHandle=dwPaletteHandle + 1;
    lpUpdatePal->wStartIndex=(WORD)dwStartIndex;
    lpUpdatePal->wNumEntries=(WORD)dwNumberOfIndices;
    memcpy((LPVOID)(lpUpdatePal+1),(LPVOID)pFirstIndex,
        dwNumberOfIndices*sizeof(PALETTEENTRY));
    dwDP2CommandLength += dwSizeChange;
}

//-----------------------------------------------------------------------------
// This function should be called from PaletteAssociateNotify
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::SetPalette"

void
CD3DDDIDX7::SetPalette(DWORD dwPaletteHandle,
                       DWORD dwPaletteFlags,
                       CBaseTexture *pTex )
{
    if (pTex->IsD3DManaged())
    {
        if (!m_pDevice->ResourceManager()->InVidmem(pTex->RMHandle()))
        {
            // We will hit this return ONLY
            // when for some reason promoting
            // pTex to vidmem failed.
            return;
        }
    }
    pTex->SetPalette(dwPaletteHandle);
    DWORD   dwSizeChange=sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETPALETTE);
    if (bDP2CurrCmdOP == D3DDP2OP_SETPALETTE)
    { // Last instruction is a tex blt, append this one to it
        if (dwDP2CommandLength + dwSizeChange <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2SETPALETTE lpSetPal = (LPD3DHAL_DP2SETPALETTE)((LPBYTE)lpvDP2Commands +
                    dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpSetPal->dwPaletteHandle=dwPaletteHandle + 1;
            lpSetPal->dwPaletteFlags=dwPaletteFlags;
            lpSetPal->dwSurfaceHandle=pTex->DriverAccessibleDrawPrimHandle();
            dwDP2CommandLength += dwSizeChange;
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif

            pTex->Batch();
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + dwSizeChange > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_SETPALETTE;
    bDP2CurrCmdOP = D3DDP2OP_SETPALETTE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    LPD3DHAL_DP2SETPALETTE lpSetPal = (LPD3DHAL_DP2SETPALETTE)(lpDP2CurrCommand + 1);
    lpSetPal->dwPaletteHandle=dwPaletteHandle + 1;
    lpSetPal->dwPaletteFlags=dwPaletteFlags;
    lpSetPal->dwSurfaceHandle=pTex->DriverAccessibleDrawPrimHandle();
    dwDP2CommandLength += dwSizeChange;

    pTex->Batch();
    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::WriteStateSetToDevice"

void
CD3DDDIDX7::WriteStateSetToDevice(D3DSTATEBLOCKTYPE sbt)
{
    DWORD  dwDeviceHandle;
    LPVOID pBuffer;
    DWORD  dwBufferSize;

    m_pDevice->m_pStateSets->GetDeviceBufferInfo(&dwDeviceHandle, &pBuffer,
                                                 &dwBufferSize);

    // If device buffer is empty we do not create the set state macro in the device
    if (dwBufferSize == 0)
        return;

    DWORD dwByteCount = dwBufferSize + (sizeof(D3DHAL_DP2STATESET) +
                        sizeof(D3DHAL_DP2COMMAND)) * 2;

    // Check to see if there is space to add a new command for space
    if (dwByteCount + dwDP2CommandLength > dwDP2CommandBufSize)
    {
        // Request the driver to grow the command buffer upon flush
        FlushStatesCmdBufReq(dwByteCount);
        // Check if the driver did give us what we need or do it ourselves
        GrowCommandBuffer(dwByteCount);
    }

    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_STATESET;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    LPD3DHAL_DP2STATESET pData = (LPD3DHAL_DP2STATESET)(lpDP2CurrCommand + 1);
    pData->dwOperation = D3DHAL_STATESETBEGIN;
    pData->dwParam = dwDeviceHandle;
    pData->sbType = sbt;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif

    // Copy the entire state macro to the DP2 buffer
    memcpy(pData + 1, pBuffer, dwBufferSize);
    if (m_ddiType < D3DDDITYPE_DX8)
    {
        // Translate buffer content to DX7 DDI
        m_pDevice->m_pStateSets->TranslateDeviceBufferToDX7DDI( (DWORD*)(pData + 1), dwBufferSize );
    }

    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pData + 1) + dwBufferSize);
    lpDP2CurrCommand->bCommand = D3DDP2OP_STATESET;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    pData = (LPD3DHAL_DP2STATESET)(lpDP2CurrCommand + 1);
    pData->dwOperation = D3DHAL_STATESETEND;
    pData->dwParam = dwDeviceHandle;
    pData->sbType = sbt;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif

    dwDP2CommandLength += dwByteCount;

    FlushStates();
}

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDITL                                                               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

CD3DDDITL::CD3DDDITL() : CD3DDDIDX7()
{
    m_ddiType = D3DDDITYPE_DX7TL;
}

CD3DDDITL::~CD3DDDITL()
{
    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::SetTransform"

void
CD3DDDITL::SetTransform(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat)
{
    // Do mapping between new world matrix states and the old ones
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < (__WORLDMATRIXBASE + __MAXWORLDMATRICES))
    {
        // World matrix is set
        UINT index = (DWORD)state - __WORLDMATRIXBASE;
        switch (index)
        {
        case 0  : state = (D3DTRANSFORMSTATETYPE)D3DTRANSFORMSTATE_WORLD_DX7;   break;
        case 1  : state = (D3DTRANSFORMSTATETYPE)D3DTRANSFORMSTATE_WORLD1_DX7;  break;
        case 2  : state = (D3DTRANSFORMSTATETYPE)D3DTRANSFORMSTATE_WORLD2_DX7;  break;
        case 3  : state = (D3DTRANSFORMSTATETYPE)D3DTRANSFORMSTATE_WORLD3_DX7;  break;
        default : return; // State is not supported
        }
    }
    // Send down the state and the matrix
    LPD3DHAL_DP2SETTRANSFORM pData;
    pData = (LPD3DHAL_DP2SETTRANSFORM)
            GetHalBufferPointer(D3DDP2OP_SETTRANSFORM, sizeof(*pData));
    pData->xfrmType = state;
    pData->matrix = *lpMat;
    // Update W info in case of projection matrix
    if (state == D3DTRANSFORMSTATE_PROJECTION)
        CD3DDDIDX6::SetTransform(state, lpMat);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::SetViewport"

void
CD3DDDITL::SetViewport(CONST D3DVIEWPORT8* lpVwpData)
{
    // Update viewport size
    CD3DDDIDX6::SetViewport(lpVwpData);

    // Update Z range
    LPD3DHAL_DP2ZRANGE pData;
    pData = (LPD3DHAL_DP2ZRANGE)GetHalBufferPointer(D3DDP2OP_ZRANGE, sizeof(*pData));
    pData->dvMinZ = lpVwpData->MinZ;
    pData->dvMaxZ = lpVwpData->MaxZ;
}
//-----------------------------------------------------------------------------
// This function is called whe software vertex processing is used
// Handle should be always legacy
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::SetVertexShader"

void CD3DDDITL::SetVertexShader(DWORD dwHandle)
{
    DXGASSERT(D3DVSD_ISLEGACY(dwHandle));
    // Pre-DX8 drivers should not recieve D3DFVF_LASTBETA_UBYTE4 bit
    m_CurrentVertexShader = dwHandle & ~D3DFVF_LASTBETA_UBYTE4;
#if DBG
    m_VertexSizeFromShader = ComputeVertexSizeFVF(dwHandle);
#endif
}
//-----------------------------------------------------------------------------
// This function is called whe hardware vertex processing is used
// Redundant shader check has been done at the API level
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::SetVertexShaderHW"

void CD3DDDITL::SetVertexShaderHW(DWORD dwHandle)
{
    if( D3DVSD_ISLEGACY(dwHandle) )
    {
        // Pre-DX8 drivers should not recieve D3DFVF_LASTBETA_UBYTE4 bit
        m_CurrentVertexShader = dwHandle & ~D3DFVF_LASTBETA_UBYTE4;
    }
    else
    {
        CVShader* pShader =
            (CVShader*)m_pDevice->m_pVShaderArray->GetObject(dwHandle);
        if( pShader == NULL )
        {
            D3D_THROW( D3DERR_INVALIDCALL,
                       "Bad handle passed to SetVertexShader DDI" )
        }
        if( pShader->m_Declaration.m_bLegacyFVF == FALSE )
        {
            D3D_THROW( D3DERR_INVALIDCALL, "Declaration is too complex for "
                       "the Driver to handle." );
        }
        else
        {
            m_CurrentVertexShader = pShader->m_Declaration.m_dwInputFVF;
        }
    }
#if DBG
    m_VertexSizeFromShader = ComputeVertexSizeFVF(m_CurrentVertexShader);
#endif
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::SetMaterial"

void
CD3DDDITL::SetMaterial(CONST D3DMATERIAL8* pMat)
{
    LPD3DHAL_DP2SETMATERIAL pData;
    pData = (LPD3DHAL_DP2SETMATERIAL)GetHalBufferPointer(D3DDP2OP_SETMATERIAL, sizeof(*pData));
    *pData = *((LPD3DHAL_DP2SETMATERIAL)pMat);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::SetLight"

void
CD3DDDITL::SetLight(DWORD dwLightIndex, CONST D3DLIGHT8* pLight)
{
    LPD3DHAL_DP2SETLIGHT pData;
    pData = (LPD3DHAL_DP2SETLIGHT)
            GetHalBufferPointer(D3DDP2OP_SETLIGHT,
                                sizeof(*pData) + sizeof(D3DLIGHT8));
    pData->dwIndex = dwLightIndex;
    pData->dwDataType = D3DHAL_SETLIGHT_DATA;
    D3DLIGHT8* p = (D3DLIGHT8*)((LPBYTE)pData + sizeof(D3DHAL_DP2SETLIGHT));
    *p = *pLight;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::CreateLight"

void
CD3DDDITL::CreateLight(DWORD dwLightIndex)
{
    LPD3DHAL_DP2CREATELIGHT pData;
    pData = (LPD3DHAL_DP2CREATELIGHT)GetHalBufferPointer(D3DDP2OP_CREATELIGHT, sizeof(*pData));
    pData->dwIndex = dwLightIndex;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::LightEnable"

void
CD3DDDITL::LightEnable(DWORD dwLightIndex, BOOL bEnable)
{
    LPD3DHAL_DP2SETLIGHT pData;
    pData = (LPD3DHAL_DP2SETLIGHT)GetHalBufferPointer(D3DDP2OP_SETLIGHT, sizeof(*pData));
    pData->dwIndex = dwLightIndex;
    if (bEnable)
        pData->dwDataType = D3DHAL_SETLIGHT_ENABLE;
    else
        pData->dwDataType = D3DHAL_SETLIGHT_DISABLE;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::SetClipPlane"

void
CD3DDDITL::SetClipPlane(DWORD dwPlaneIndex, CONST D3DVALUE* pPlaneEquation)
{
    LPD3DHAL_DP2SETCLIPPLANE pData;
    pData = (LPD3DHAL_DP2SETCLIPPLANE)
            GetHalBufferPointer(D3DDP2OP_SETCLIPPLANE, sizeof(*pData));
    pData->dwIndex = dwPlaneIndex;
    pData->plane[0] = pPlaneEquation[0];
    pData->plane[1] = pPlaneEquation[1];
    pData->plane[2] = pPlaneEquation[2];
    pData->plane[3] = pPlaneEquation[3];
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::CreateVertexShader"

void
CD3DDDITL::CreateVertexShader(CONST DWORD* pdwDeclaration,
                              DWORD dwDeclarationSize,
                              CONST DWORD* pdwFunction,
                              DWORD dwFunctionSize,
                              DWORD dwHandle,
                              BOOL bLegacyFVF)
{
    if( bLegacyFVF == FALSE )
    {
        D3D_THROW(D3DERR_INVALIDCALL,
                  "The declaration is too complex for the driver to handle");
    }
}
//-----------------------------------------------------------------------------
// Allocates space for the internal clip buffer and sets lpClipFlags pointer
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::PrepareForClipping"

void
CD3DDDIDX6::PrepareForClipping(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    if (!(pv->dwDeviceFlags & D3DDEV_VBPROCVER))
    {
        // Grow clip flags buffer if we need clipping
        DWORD size = pv->dwNumVertices * sizeof(D3DFE_CLIPCODE);
        if (size > pDevice->HVbuf.GetSize())
        {
            if (pDevice->HVbuf.Grow(size) != D3D_OK)
            {
                D3D_THROW(E_OUTOFMEMORY, "Could not grow clip buffer" );
            }
        }
        pv->lpClipFlags = (D3DFE_CLIPCODE*)pDevice->HVbuf.GetAddress();
    }
    else
    {
        // For vertex buffers, which are destination for ProcessVertices
        // clip buffer is already computed
        pv->lpClipFlags = pDevice->m_pStream[0].m_pVB->GetClipCodes();
#if DBG
        if (pv->lpClipFlags == NULL)
        {
            D3D_THROW_FAIL("Clip codes are not computed for the vertex buffer");
        }
#endif
        pv->dwClipUnion = 0xFFFFFFFF;  // Force clipping
        pv->lpClipFlags += StartVertex;
    }
}
//-----------------------------------------------------------------------------
// Point sprites are drawn as indexed triangle list
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::StartPointSprites"

void CD3DDDIDX6::StartPointSprites()
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    // Reserve place for the output vertices
    const UINT size = NUM_SPRITES_IN_BATCH * 4 * m_dwOutputSizePS;

    // We may have a different vertex type for point sprites
    DWORD tmpFVF = pv->dwVIDOut;
    pv->dwVIDOut = m_dwVIDOutPS;

    // For StartPrimTL we should use vertex size, which will go to the driver
    DWORD tmpVertexSize = pv->dwOutputSize;
    pv->dwOutputSize = m_dwOutputSizePS;

    m_pCurSpriteVertex = (BYTE*)StartPrimTL(pv, size, TRUE);

    // Restore vertex size, which is size before point sprite emulation
    pv->dwOutputSize = tmpVertexSize;

    // Vertex base and vertex count could be changed during clipping
    // So we save them here and use in the EndPointSprites
    m_dwVertexBasePS = this->dwVertexBase;
    m_dwVertexCountPS = this->dwDP2VertexCount;

    // Continue processing with the original FVF
    pv->dwVIDOut = tmpFVF;
    // Reserve place for indices
    UINT count = NUM_SPRITES_IN_BATCH * 2 * 6;

    // We change lpDP2CurrCommand here, so to prevent combining multiple driver
    // calls to one token in case when all points are off screen, we clear 
    // bDP2CurrCmdOP.
    bDP2CurrCmdOP = 0;

    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)ReserveSpaceInCommandBuffer(count);
    m_pCurPointSpriteIndex = (WORD*)((BYTE*)(lpDP2CurrCommand + 1) +
                                    sizeof(D3DHAL_DP2STARTVERTEX));
    m_CurNumberOfSprites = 0;
    ((LPD3DHAL_DP2STARTVERTEX)(lpDP2CurrCommand+1))->wVStart = (WORD)this->dwVertexBase;

    SetWithinPrimitive(TRUE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::NextSprite"

void CD3DDDIDX6::NextSprite(float x, float y, float z, float w, DWORD diffuse,
                            DWORD specular, float* pTexture, UINT TextureSize,
                            float PointSize)
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;

    BOOL bTexGen = pv->lpdwRStates[D3DRS_POINTSPRITEENABLE] != 0;

    if (m_CurNumberOfSprites >= NUM_SPRITES_IN_BATCH)
    {
        EndPointSprites();
        StartPointSprites();
    }
    // Compute point size
    PointSize = PointSize * 0.5f;

    // Build sprite vertices
    BYTE* v1 = m_pCurSpriteVertex;
    BYTE* v2 = m_pCurSpriteVertex + m_dwOutputSizePS;
    BYTE* v3 = m_pCurSpriteVertex + m_dwOutputSizePS * 2;
    BYTE* v4 = m_pCurSpriteVertex + m_dwOutputSizePS * 3;
    float x1, y1, x2, y2, x3, y3, x4, y4;
    x1 = x - PointSize;
    y1 = y - PointSize;
    x2 = x + PointSize;
    y2 = y + PointSize;
    float tx1 = 0;  // Interpolation coefficient at left plane
    float tx2 = 1;  // Interpolation coefficient at right plane
    float ty1 = 0;  // Interpolation coefficient at top plane
    float ty2 = 1;  // Interpolation coefficient at bottom plane
    if (pv->dwDeviceFlags & D3DDEV_DONOTCLIP)
    {
        ((D3DVECTORH*)v1)->x = x1;
        ((D3DVECTORH*)v1)->y = y1;
        ((D3DVECTORH*)v1)->z = z;
        ((D3DVECTORH*)v1)->w = w;
        ((D3DVECTORH*)v2)->x = x2;
        ((D3DVECTORH*)v2)->y = y1;
        ((D3DVECTORH*)v2)->z = z;
        ((D3DVECTORH*)v2)->w = w;
        ((D3DVECTORH*)v3)->x = x2;
        ((D3DVECTORH*)v3)->y = y2;
        ((D3DVECTORH*)v3)->z = z;
        ((D3DVECTORH*)v3)->w = w;
        ((D3DVECTORH*)v4)->x = x1;
        ((D3DVECTORH*)v4)->y = y2;
        ((D3DVECTORH*)v4)->z = z;
        ((D3DVECTORH*)v4)->w = w;
    }
    else
    {// Do clipping
        // new x and y
        float xnew1 = x1, xnew2 = x2;
        float ynew1 = y1, ynew2 = y2;
        if (x1 < pv->vcache.minX)
            if (x2 < pv->vcache.minX)
                return;
            else
            {
                xnew1 = pv->vcache.minX;
                if (bTexGen)
                    tx1 = (xnew1 - x1) / (x2 - x1);
            }
        else
        if (x2 > pv->vcache.maxX)
            if (x1 > pv->vcache.maxX)
                return;
            else
            {
                xnew2 = pv->vcache.maxX;
                if (bTexGen)
                    tx2 = (xnew2 - x1) / (x2 - x1);
            }
        if (y1 < pv->vcache.minY)
            if (y2 < pv->vcache.minY)
                return;
            else
            {
                ynew1 = pv->vcache.minY;
                if (bTexGen)
                    ty1 = (ynew1 - y1) / (y2 - y1);
            }
        else
        if (y2 > pv->vcache.maxY)
            if (y1 > pv->vcache.maxY)
                return;
            else
            {
                ynew2 = pv->vcache.maxY;
                if (bTexGen)
                    ty2 = (ynew2 - y1) / (y2 - y1);
            }
        ((D3DVECTORH*)v1)->x = xnew1;
        ((D3DVECTORH*)v1)->y = ynew1;
        ((D3DVECTORH*)v1)->z = z;
        ((D3DVECTORH*)v1)->w = w;
        ((D3DVECTORH*)v2)->x = xnew2;
        ((D3DVECTORH*)v2)->y = ynew1;
        ((D3DVECTORH*)v2)->z = z;
        ((D3DVECTORH*)v2)->w = w;
        ((D3DVECTORH*)v3)->x = xnew2;
        ((D3DVECTORH*)v3)->y = ynew2;
        ((D3DVECTORH*)v3)->z = z;
        ((D3DVECTORH*)v3)->w = w;
        ((D3DVECTORH*)v4)->x = xnew1;
        ((D3DVECTORH*)v4)->y = ynew2;
        ((D3DVECTORH*)v4)->z = z;
        ((D3DVECTORH*)v4)->w = w;
    }
    UINT offset = 4*4;
    if (m_dwVIDOutPS & D3DFVF_DIFFUSE)
    {
        *(DWORD*)(v1 + offset) = diffuse;
        *(DWORD*)(v2 + offset) = diffuse;
        *(DWORD*)(v3 + offset) = diffuse;
        *(DWORD*)(v4 + offset) = diffuse;
        offset += 4;
    }
    if (m_dwVIDOutPS & D3DFVF_SPECULAR)
    {
        *(DWORD*)(v1 + offset) = specular;
        *(DWORD*)(v2 + offset) = specular;
        *(DWORD*)(v3 + offset) = specular;
        *(DWORD*)(v4 + offset) = specular;
        offset += 4;
    }
    if (bTexGen)
    {
        ((float*)(v1 + offset))[0] = tx1;
        ((float*)(v1 + offset))[1] = ty1;
        ((float*)(v2 + offset))[0] = tx2;
        ((float*)(v2 + offset))[1] = ty1;
        ((float*)(v3 + offset))[0] = tx2;
        ((float*)(v3 + offset))[1] = ty2;
        ((float*)(v4 + offset))[0] = tx1;
        ((float*)(v4 + offset))[1] = ty2;
    }
    else
    {
        // Copy input texture coordinates
        memcpy(v1 + offset, pTexture, TextureSize);
        memcpy(v2 + offset, pTexture, TextureSize);
        memcpy(v3 + offset, pTexture, TextureSize);
        memcpy(v4 + offset, pTexture, TextureSize);
    }
    m_pCurSpriteVertex = v4 + m_dwOutputSizePS;

    // Output indices for 2 triangles
    WORD index = m_CurNumberOfSprites << 2;
    m_pCurPointSpriteIndex[0] = index;
    m_pCurPointSpriteIndex[1] = index + 1;
    m_pCurPointSpriteIndex[2] = index + 2;
    m_pCurPointSpriteIndex[3] = index;
    m_pCurPointSpriteIndex[4] = index + 2;
    m_pCurPointSpriteIndex[5] = index + 3;
    m_pCurPointSpriteIndex += 6;

    m_CurNumberOfSprites++;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::EndPointSprites"

void CD3DDDIDX6::EndPointSprites()
{
    if (m_CurNumberOfSprites)
    {
        dwDP2CommandLength += (DWORD) ((BYTE*)this->m_pCurPointSpriteIndex -
                                       (BYTE*)this->lpDP2CurrCommand);
        this->lpDP2CurrCommand->bCommand = D3DDP2OP_INDEXEDTRIANGLELIST2;
        this->bDP2CurrCmdOP = D3DDP2OP_INDEXEDTRIANGLELIST2;
        this->lpDP2CurrCommand->bReserved = 0;
        this->lpDP2CurrCommand->wPrimitiveCount = m_CurNumberOfSprites * 2;
#if DBG
        if (m_bValidateCommands)
            ValidateCommand(this->lpDP2CurrCommand);
#endif
        UINT vertexCount = m_CurNumberOfSprites << 2;
        this->dwVertexBase = m_dwVertexBasePS + vertexCount;
        this->dwDP2VertexCount = m_dwVertexCountPS + vertexCount;
        EndPrim(m_dwOutputSizePS);
        m_CurNumberOfSprites = 0;
    }
    else
    {
        // We need to restore dwVertexBase and dwDP2VertexCount, because
        // they could be changed during clipping of transformed vertices.
        // But they should reflect position in TL buffer, not in user buffer
        this->dwVertexBase = m_dwVertexBasePS;
        this->dwDP2VertexCount = m_dwVertexCountPS;
        EndPrim(m_dwOutputSizePS);
    }
    SetWithinPrimitive(FALSE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::UpdatePalette"

void CD3DDDIDX6::UpdatePalette(DWORD dwPaletteHandle,
                               DWORD dwStartIndex,
                               DWORD dwNumberOfIndices,
                               PALETTEENTRY *pFirstIndex)
{
    D3D8_UPDATEPALETTEDATA Data;
    Data.hDD = m_pDevice->GetHandle();
    Data.Palette = dwPaletteHandle;
    Data.ColorTable = pFirstIndex;
    Data.ddRVal = S_OK;
    HRESULT ret = m_pDevice->GetHalCallbacks()->UpdatePalette(&Data);
    if (ret != DDHAL_DRIVER_HANDLED || Data.ddRVal != S_OK)
    {
        D3D_ERR( "Driver failed UpdatePalette call" );
        throw D3DERR_INVALIDCALL;
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetPalette"

void CD3DDDIDX6::SetPalette(DWORD dwPaletteHandle,
                            DWORD dwPaletteFlags,
                            CBaseTexture *pTex)
{
    if (pTex->IsD3DManaged())
    {
        if (!m_pDevice->ResourceManager()->InVidmem(pTex->RMHandle()))
        {
            // We will hit this return ONLY
            // when for some reason promoting
            // pTex to vidmem failed.
            return;
        }
    }
    D3D8_SETPALETTEDATA Data;
    Data.hDD = m_pDevice->GetHandle();
    Data.hSurface = pTex->DriverAccessibleKernelHandle();
    Data.Palette = dwPaletteHandle;
    Data.ddRVal = S_OK;
    HRESULT ret = m_pDevice->GetHalCallbacks()->SetPalette(&Data);
    if (ret != DDHAL_DRIVER_HANDLED || Data.ddRVal != S_OK)
    {
        D3D_ERR( "Driver failed SetPalette call" );
        throw D3DERR_INVALIDCALL;
    }
    pTex->SetPalette(dwPaletteHandle);
}
//-----------------------------------------------------------------------------
#if DBG

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ValidateVertex"

void CD3DDDIDX6::ValidateVertex(LPDWORD lpdwVertex)
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;
    DWORD dwFVF = pv->dwVIDOut;
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    if (FVF_TRANSFORMED(dwFVF))
    {
        float left, right, top, bottom;
        if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
        {
            left   = pv->vcache.minXgb;
            right  = pv->vcache.maxXgb;
            top    = pv->vcache.minYgb;
            bottom = pv->vcache.maxYgb;
        }
        else
        {
            left   = (float)pDevice->m_Viewport.X;
            top    = (float)pDevice->m_Viewport.Y;
            right  = (float)pDevice->m_Viewport.X + pDevice->m_Viewport.Width;
            bottom = (float)pDevice->m_Viewport.Y + pDevice->m_Viewport.Height;
        }
        float x = ((float*)lpdwVertex)[0];
        float y = ((float*)lpdwVertex)[1];
        float z = ((float*)lpdwVertex)[2];
        float w = ((float*)lpdwVertex)[3];

        if (x < left || x > right)
        {
            D3D_THROW_FAIL("X coordinate out of range!");
        }

        if (y < top || y > bottom)
        {
            D3D_THROW_FAIL("Y coordinate out of range!");
        }

        if (pv->lpdwRStates[D3DRS_ZENABLE] ||
            pv->lpdwRStates[D3DRS_ZWRITEENABLE])
        {
            // Allow a little slack for those generating triangles exactly on the
            // depth limit.  Needed for Quake.
            if (z < -0.00015f || z > 1.00015f)
            {
                D3D_THROW_FAIL("Z coordinate out of range!");
            }
        }
        UINT index = 4;

        if (dwFVF & D3DFVF_DIFFUSE)
            index++;

        if (dwFVF & D3DFVF_SPECULAR)
            index++;

        UINT nTex = FVF_TEXCOORD_NUMBER(dwFVF);
        if (nTex > 0)
        {
            if (w <= 0 )
            {
                D3D_THROW_FAIL("RHW out of range!");
            }
            for (UINT i=0; i < nTex; i++)
            {
                float u = ((float*)lpdwVertex)[index];
                float v = ((float*)lpdwVertex)[index+1];
                if (u < -100 || u > 100 || v < -100 || v > 100)
                {
                    D3D_THROW_FAIL("Texture coordinate out of range!");
                }
                index += 2;
            }
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ValidateCommand"

void CD3DDDIDX6::ValidateCommand(LPD3DHAL_DP2COMMAND lpCmd)
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;

    BYTE* pVertices;
    if (dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES)
        pVertices = (LPBYTE)(dp2data.lpVertices);
    else
        if (!lpDP2CurrBatchVBI->IsLocked())
        {
            lpDP2CurrBatchVBI->Lock(dp2data.dwVertexOffset,
                                    this->dwDP2VertexCount,
                                    &pVertices, DDLOCK_READONLY);
        }
        else
        {
            pVertices = lpDP2CurrBatchVBI->Data();
        }

    DWORD dwVertexSize = pv->dwOutputSize;
    WORD wStart, wCount;
    switch (lpCmd->bCommand)
    {
    case D3DDP2OP_TRIANGLELIST:
        {
            LPD3DHAL_DP2TRIANGLELIST pTri = (LPD3DHAL_DP2TRIANGLELIST)(lpCmd + 1);
            wStart = pTri->wVStart;
            wCount =lpCmd->wPrimitiveCount * 3;
        }
        break;
    case D3DDP2OP_TRIANGLESTRIP:
    case D3DDP2OP_TRIANGLEFAN:
        {
            LPD3DHAL_DP2TRIANGLEFAN pFan = (LPD3DHAL_DP2TRIANGLEFAN)(lpCmd + 1);
            wStart = pFan->wVStart;
            wCount = lpCmd->wPrimitiveCount + 2;
        }
        break;
    case D3DDP2OP_TRIANGLEFAN_IMM:
        {
            wCount = lpCmd->wPrimitiveCount + 2;
            BYTE* pVertices = (BYTE*)(lpCmd + 1) + sizeof(D3DHAL_DP2TRIANGLEFAN_IMM);
            pVertices = (BYTE*)(((ULONG_PTR)pVertices + 3) & ~3);
            for (WORD i=0; i < wCount; ++i)
            {
                ValidateVertex((DWORD*)(pVertices + i * dwVertexSize));
            }
            goto l_exit;
        }
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        {
            wCount = lpCmd->wPrimitiveCount * 3;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(lpCmd + 1);
            WORD* pIndices = (WORD*)(lpStartVertex + 1);
                        wStart = lpStartVertex->wVStart;
            pVertices += wStart * dwVertexSize;
            DWORD dwNumVertices = this->dwDP2VertexCount - wStart;
            for (WORD i = 0; i < wCount; ++i)
            {
                if (pIndices[i] >= dwNumVertices)
                {
                    D3D_THROW_FAIL("Invalid index in ValidateCommand");
                }
                ValidateVertex((LPDWORD)(pVertices + pIndices[i] * dwVertexSize));
            }
        }
        goto l_exit;
        // Fall through
    default:
        goto l_exit;
    }

    {
        for (WORD i = wStart; i < wStart + wCount; ++i)
        {
            ValidateVertex((LPDWORD)(pVertices + i * dwVertexSize));
        }
    }
l_exit:
    if (!(dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES))
        lpDP2CurrBatchVBI->Unlock();
}
//-----------------------------------------------------------------------------
// This function could be used to go through all commands in the command buffer
// and find failed command at a particular offset
//
#undef DPF_MODNAME
#define DPF_MODNAME "ValidateCommandBuffer"

HRESULT ValidateCommandBuffer(LPBYTE pBuffer, DWORD dwCommandLength, DWORD dwStride)
{
    LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)pBuffer;
    LPBYTE CmdEnd = pBuffer + dwCommandLength;
loop:
    UINT CommandOffset = (UINT)((LPBYTE)pCmd - pBuffer);
    switch(pCmd->bCommand)
    {
    case D3DDP2OP_STATESET:
        {
            LPD3DHAL_DP2STATESET pStateSetOp = 
                (LPD3DHAL_DP2STATESET)(pCmd + 1);

            switch (pStateSetOp->dwOperation)
            {
            case D3DHAL_STATESETBEGIN  :
                break;
            case D3DHAL_STATESETEND    :
                break;
            case D3DHAL_STATESETDELETE :
                break;
            case D3DHAL_STATESETEXECUTE:
                break;
            case D3DHAL_STATESETCAPTURE:
                break;
            case D3DHAL_STATESETCREATE:
                break;
            default :
                return DDERR_INVALIDPARAMS;
            }
            pCmd = (LPD3DHAL_DP2COMMAND)(pStateSetOp + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_VIEWPORTINFO:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                   ((D3DHAL_DP2VIEWPORTINFO *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_WINFO:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                   ((D3DHAL_DP2WINFO *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_RENDERSTATE:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                   ((D3DHAL_DP2RENDERSTATE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_TEXTURESTAGESTATE:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
               ((LPD3DHAL_DP2TEXTURESTAGESTATE)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLELIST:
        {
            WORD cPrims = pCmd->wPrimitiveCount;
            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(pCmd + 1) +
                         sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST) * cPrims);
        }
        break;
    case D3DDP2OP_INDEXEDLINELIST:
        {
            // Update the command buffer pointer
            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(pCmd + 1) +
                    pCmd->wPrimitiveCount * sizeof(D3DHAL_DP2INDEXEDLINELIST));
        }
        break;
    case D3DDP2OP_POINTS:
        {
            D3DHAL_DP2POINTS *pPt = (D3DHAL_DP2POINTS *)(pCmd + 1);
            pPt += pCmd->wPrimitiveCount;
            pCmd = (LPD3DHAL_DP2COMMAND)pPt;
        }
        break;
    case D3DDP2OP_LINELIST:
        {
            D3DHAL_DP2LINELIST *pLine = (D3DHAL_DP2LINELIST *)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)(pLine + 1);
        }
        break;
    case D3DDP2OP_INDEXEDLINELIST2:
        {
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                    pCmd->wPrimitiveCount * sizeof(D3DHAL_DP2INDEXEDLINELIST));
        }
        break;
    case D3DDP2OP_LINESTRIP:
        {
            D3DHAL_DP2LINESTRIP *pLine = (D3DHAL_DP2LINESTRIP *)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)(pLine + 1);
        }
        break;
    case D3DDP2OP_INDEXEDLINESTRIP:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount + 1;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLELIST:
        {
            D3DHAL_DP2TRIANGLELIST *pTri = (D3DHAL_DP2TRIANGLELIST *)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount*3;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLESTRIP:
        {
            D3DHAL_DP2TRIANGLESTRIP *pTri = (D3DHAL_DP2TRIANGLESTRIP *)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount+2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLEFAN:
        {
            D3DHAL_DP2TRIANGLEFAN *pTri = (D3DHAL_DP2TRIANGLEFAN *)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLEFAN:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount + 2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLEFAN_IMM:
        {
            DWORD vertexCount = pCmd->wPrimitiveCount + 2;
            // Make sure the pFanVtx pointer is DWORD aligned: (pFanVtx +3) % 4
            PUINT8 pFanVtx = (PUINT8)
                (((ULONG_PTR)(pCmd + 1) + 
                  sizeof(D3DHAL_DP2TRIANGLEFAN_IMM) + 3) & ~3);

            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)pFanVtx +
                                           vertexCount * dwStride);
        }
        break;
    case D3DDP2OP_LINELIST_IMM:
        {
            DWORD vertexCount = pCmd->wPrimitiveCount * 2;
            // Make sure the pLineVtx pointer is DWORD aligned:
            // (pLineVtx +3) % 4
            PUINT8 pLineVtx = (PUINT8)(((ULONG_PTR)(pCmd + 1) + 3) & ~3);
            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)pLineVtx +
                                           vertexCount * dwStride);
        }
        break;
    case D3DDP2OP_DRAWPRIMITIVE:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWPRIMITIVE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_DRAWPRIMITIVE2:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWPRIMITIVE2 *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_DRAWRECTPATCH:
        {
            LPD3DHAL_DP2DRAWRECTPATCH pDP = 
                (LPD3DHAL_DP2DRAWRECTPATCH)(pCmd + 1);
            for( int i = 0; i < pCmd->wStateCount; i++ )
            {
                bool hassegs = (pDP->Flags & RTPATCHFLAG_HASSEGS) != 0;
                bool hasinfo = (pDP->Flags & RTPATCHFLAG_HASINFO) != 0;
                if(hassegs)
                {
                    pDP = (LPD3DHAL_DP2DRAWRECTPATCH)((BYTE*)(pDP + 1) + 
                                                      sizeof(FLOAT) * 4);
                }
                else
                {
                    ++pDP;
                }
                if(hasinfo)
                {
                    pDP = (LPD3DHAL_DP2DRAWRECTPATCH)((BYTE*)pDP + sizeof(D3DRECTPATCH_INFO));
                }
            }
            pCmd = (LPD3DHAL_DP2COMMAND)pDP;
        }
        break;
    case D3DDP2OP_DRAWTRIPATCH:
        {
            LPD3DHAL_DP2DRAWTRIPATCH pDP = 
                (LPD3DHAL_DP2DRAWTRIPATCH)(pCmd + 1);
            for( int i = 0; i < pCmd->wStateCount; i++ )
            {
                bool hassegs = (pDP->Flags & RTPATCHFLAG_HASSEGS) != 0;
                bool hasinfo = (pDP->Flags & RTPATCHFLAG_HASINFO) != 0;
                if(hassegs)
                {
                    pDP = (LPD3DHAL_DP2DRAWTRIPATCH)((BYTE*)(pDP + 1) + 
                                                      sizeof(FLOAT) * 3);
                }
                else
                {
                    ++pDP;
                }
                if(hasinfo)
                {
                    pDP = (LPD3DHAL_DP2DRAWTRIPATCH)((BYTE*)pDP + sizeof(D3DTRIPATCH_INFO));
                }
            }
            pCmd = (LPD3DHAL_DP2COMMAND)pDP;
        }
        break;
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWINDEXEDPRIMITIVE *)(pCmd + 1) +
                 pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE2:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWINDEXEDPRIMITIVE2 *)(pCmd + 1) +
                 pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_CLIPPEDTRIANGLEFAN:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_CLIPPEDTRIANGLEFAN*)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_ZRANGE:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2ZRANGE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETMATERIAL:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETMATERIAL *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETLIGHT:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pCmd + 1)  + sizeof(D3DHAL_DP2SETLIGHT));
        }
        break;
    case D3DDP2OP_CREATELIGHT:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2CREATELIGHT *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETTRANSFORM:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETTRANSFORM *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_MULTIPLYTRANSFORM:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2MULTIPLYTRANSFORM *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_EXT:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2EXT *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETRENDERTARGET:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETRENDERTARGET*)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_CLEAR:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pCmd + 1) +
                sizeof(D3DHAL_DP2CLEAR) + (pCmd->wStateCount - 1) * sizeof(RECT));
        }
        break;
    case D3DDP2OP_SETCLIPPLANE:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2SETCLIPPLANE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DOP_SPAN:
        // Skip over
        pCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pCmd + 1) +
                  pCmd->wPrimitiveCount * pCmd->bReserved );
        break;
    case D3DDP2OP_CREATEVERTEXSHADER:
    {
        LPD3DHAL_DP2CREATEVERTEXSHADER pCVS =
            (LPD3DHAL_DP2CREATEVERTEXSHADER)(pCmd + 1);
        WORD i;

        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pDecl = (LPDWORD)(pCVS + 1);
            LPDWORD pCode = (LPDWORD)((LPBYTE)pDecl + pCVS->dwDeclSize);
            pCVS = (LPD3DHAL_DP2CREATEVERTEXSHADER)((LPBYTE)pCode +
                                                    pCVS->dwCodeSize);
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pCVS;
        break;
    }
    case D3DDP2OP_DELETEVERTEXSHADER:
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2VERTEXSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETVERTEXSHADER:
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2VERTEXSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETVERTEXSHADERCONST:
    {
        LPD3DHAL_DP2SETVERTEXSHADERCONST pSVC =
            (LPD3DHAL_DP2SETVERTEXSHADERCONST)(pCmd + 1);
        WORD i;
        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pData = (LPDWORD)(pSVC + 1);
            pSVC = (LPD3DHAL_DP2SETVERTEXSHADERCONST)((LPBYTE)pData +
                                                      pSVC->dwCount * 4 *
                                                      sizeof( float ) );
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pSVC;
        break;
    }
    case D3DDP2OP_SETSTREAMSOURCE:
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETSTREAMSOURCE *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETSTREAMSOURCEUM:
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETSTREAMSOURCEUM *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETINDICES:
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETINDICES *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_CREATEPIXELSHADER:
    {
        LPD3DHAL_DP2CREATEPIXELSHADER pCPS =
            (LPD3DHAL_DP2CREATEPIXELSHADER)(pCmd + 1);
        WORD i;

        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pCode = (LPDWORD)(pCPS + 1);
            pCPS = (LPD3DHAL_DP2CREATEPIXELSHADER)((LPBYTE)pCode +
                                                    pCPS->dwCodeSize);
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pCPS;
        break;
    }
    case D3DDP2OP_DELETEPIXELSHADER:
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2PIXELSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETPIXELSHADER:
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2PIXELSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETPIXELSHADERCONST:
    {
        LPD3DHAL_DP2SETPIXELSHADERCONST pSVC =
            (LPD3DHAL_DP2SETPIXELSHADERCONST)(pCmd + 1);
        WORD i;
        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pData = (LPDWORD)(pSVC + 1);
            pSVC = (LPD3DHAL_DP2SETPIXELSHADERCONST)((LPBYTE)pData +
                                                      pSVC->dwCount * 4 *
                                                      sizeof( float ) );
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pSVC;
        break;
    }
    case D3DDP2OP_SETPALETTE:
    {
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETPALETTE *)(pCmd + 1) + pCmd->wStateCount);
        break;
    }
    case D3DDP2OP_UPDATEPALETTE:
    {
        LPD3DHAL_DP2UPDATEPALETTE pUP = (LPD3DHAL_DP2UPDATEPALETTE)(pCmd + 1);
        WORD i;
        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            PALETTEENTRY* pEntries = (PALETTEENTRY *)(pUP + 1);
            pUP = (LPD3DHAL_DP2UPDATEPALETTE)(pEntries + pUP->wNumEntries);
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pUP;
        break;
    }
    case D3DDP2OP_SETTEXLOD:
    {
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETTEXLOD *)(pCmd + 1) + pCmd->wStateCount);
        break;
    }
    case D3DDP2OP_SETPRIORITY:
    {
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETPRIORITY *)(pCmd + 1) + pCmd->wStateCount);
        break;
    }
    case D3DDP2OP_TEXBLT:
    {
        LPD3DHAL_DP2TEXBLT pTB = (LPD3DHAL_DP2TEXBLT)(pCmd + 1);
        for( WORD i = 0; i < pCmd->wStateCount ; i++ )
        {
            pTB++;
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pTB;
        break;
    }
    case D3DDP2OP_BUFFERBLT:
    {
        LPD3DHAL_DP2BUFFERBLT pBB = (LPD3DHAL_DP2BUFFERBLT)(pCmd + 1);
        for( WORD i = 0; i < pCmd->wStateCount ; i++ )
        {
            pBB++;
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pBB;
        break;
    }
    case D3DDP2OP_VOLUMEBLT:
    {
        LPD3DHAL_DP2VOLUMEBLT pVB = (LPD3DHAL_DP2VOLUMEBLT)(pCmd + 1);
        for( WORD i = 0; i < pCmd->wStateCount ; i++ )
        {
            pVB++;
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pVB;
        break;
    }
    case D3DOP_MATRIXLOAD:
    case D3DOP_MATRIXMULTIPLY:
    case D3DOP_STATETRANSFORM:
    case D3DOP_STATELIGHT:
    case D3DOP_TEXTURELOAD:
    case D3DOP_BRANCHFORWARD:
    case D3DOP_SETSTATUS:
    case D3DOP_EXIT:
    case D3DOP_PROCESSVERTICES:
    {
        D3D_ERR( "Command is not supported\n" );
        return E_FAIL;
        break;
    }
    default:
        D3D_ERR( "Unknown command encountered" );
        return E_FAIL;
    }
    if ((LPBYTE)pCmd < CmdEnd)
        goto loop;

    return S_OK;    
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\devstate.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       devstate.c
 *  Content:    device state management
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "drawprim.hpp"
#include "pvvid.h"
#include "ddibase.h"

//---------------------------------------------------------------------
#if DBG
void CPackedBitArray::CheckIndex(UINT index)
{
    if (index >= m_size)
    {
        D3D_THROW_FAIL("Invalid index");
    }
}
#endif // DBG
//---------------------------------------------------------------------
inline void UpdateFogFactor(D3DFE_PROCESSVERTICES* lpDevI)
{
    if (lpDevI->lighting.fog_end == lpDevI->lighting.fog_start)
        lpDevI->lighting.fog_factor = D3DVAL(0.0);
    else
        lpDevI->lighting.fog_factor = D3DVAL(255) /
                                     (lpDevI->lighting.fog_end - lpDevI->lighting.fog_start);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetRenderState"

HRESULT D3DAPI
CD3DHal::SetRenderState(D3DRENDERSTATETYPE dwState, DWORD value)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (dwState >= D3D_MAXRENDERSTATES || dwState == 0 )
    {
        D3D_ERR( "Invalid render state type. SetRenderState failed." );
        return D3DERR_INVALIDCALL;
    }
#endif

    try
    {
        if (this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            if(this->CheckForRetiredRenderState(dwState))
            {
                m_pStateSets->InsertRenderState(dwState, value, CanHandleRenderState(dwState));
            }
            else
            {
                D3D_ERR("Invalid renderstate %d. SetRenderState failed.", dwState);
                return D3DERR_INVALIDCALL;
            }
        }
        else
            this->SetRenderStateFast(dwState, value);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        D3D_ERR("SetRenderState failed.");
        return ret;
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetRenderStateFast"

HRESULT D3DAPI CD3DHal::SetRenderStateFast(D3DRENDERSTATETYPE dwState, DWORD value)
{
    // NOTE: This can become a public API through the
    // v-table hack. This should only happen for
    // single-threaded apps; so we don't need
    // to take the critical section.
    // API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (dwState >= D3D_MAXRENDERSTATES || dwState == 0 )
    {
        D3D_ERR( "Invalid render state type. SetRenderState failed." );
        return D3DERR_INVALIDCALL;
    }
#endif

    if (!rsVec.IsBitSet(dwState))
    {   // Fast path. We do not need any processing done in UpdateInternalState
        // other than updating rstates array
        if ( (this->rstates[dwState] == value)
#if DBG
             && (dwState != D3DRS_DEBUGMONITORTOKEN) // don't filter these
#endif
           )
        {
            D3D_WARN(4,"Ignoring redundant SetRenderState - %d", dwState);
            return D3D_OK;
        }
        this->rstates[dwState] = value;
        // Output state to the device driver
        try
        {
           m_pDDI->SetRenderState(dwState, value);
        }
        catch(HRESULT ret)
        {
            D3D_ERR("SetRenderState failed.");
            return ret;
        }
    }
    else
    {
        try
        {
            // Wrap modes could be re-programmed. We need to restore them before
            // filtering redundant values
            if (m_pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
            {
                RestoreTextureStages(this);
                ForceFVFRecompute();
            }
            if ( (this->rstates[dwState] == value)
#if DBG
                 && (dwState != D3DRS_DEBUGMONITORTOKEN) // don't filter these
#endif
               )
            {
                D3D_WARN(4,"Ignoring redundant SetRenderState - %d", dwState);
                return D3D_OK;
            }

            this->UpdateInternalState(dwState, value);
            // Vertex processing only render states will be passed to the
            // driver when we switch to the hardware vertex processing mode
            if ((!(rsVertexProcessingOnly.IsBitSet(dwState) &&
                   m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)))
            {
                if (CanHandleRenderState(dwState))
                {
#if DBG
                    if(!CheckForRetiredRenderState(dwState))
                    {
                        D3D_ERR("Invalid (old) renderstate %d. SetRenderState failed.", dwState);
                        return D3DERR_INVALIDCALL;
                    }
#endif // DBG
                    m_pDDI->SetRenderState(dwState, value);
                }
            }
        }
        catch(HRESULT ret)
        {
            D3D_ERR("SetRenderState failed.");
            return ret;
        }
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetRenderStateInternal"

void
CD3DHal::SetRenderStateInternal(D3DRENDERSTATETYPE dwState, DWORD dwValue)
{
    if (this->rstates[dwState] == dwValue)
    {
        D3D_WARN(4,"Ignoring redundant SetRenderState - %d", dwState);
        return;
    }
    this->UpdateInternalState(dwState, dwValue);
    if (CanHandleRenderState(dwState))
        m_pDDI->SetRenderState(dwState, dwValue);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetRenderState"

HRESULT D3DAPI
CD3DHal::GetRenderState(D3DRENDERSTATETYPE dwState, LPDWORD lpdwValue)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (dwState >= D3D_MAXRENDERSTATES || dwState == 0)
    {
        D3D_ERR( "Invalid render state value. GetRenderState failed." );
        return D3DERR_INVALIDCALL;
    }
#endif

    if (!VALID_WRITEPTR(lpdwValue, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer. GetRenderState failed." );
        return D3DERR_INVALIDCALL;
    }

    if(!CheckForRetiredRenderState(dwState))
    {
        D3D_ERR("invalid renderstate %d. GetRenderState failed.", dwState);
        return D3DERR_INVALIDCALL;
    }

    // WRAP render states could be re-mapped so we have to return the original
    // value
    if (dwState >= D3DRENDERSTATE_WRAP0 && dwState <= D3DRENDERSTATE_WRAP7)
    {
        if (m_pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
        {
            DWORD dwTexCoordIndex = dwState - D3DRENDERSTATE_WRAP0;
            for (DWORD i=0; i < this->dwNumTextureStagesToRemap; i++)
            {
                LPD3DFE_TEXTURESTAGE pStage = &this->textureStageToRemap[i];
                if (pStage->dwInpCoordIndex == dwTexCoordIndex)
                {
                    if (pStage->dwInpCoordIndex != pStage->dwOutCoordIndex)
                    {
                        *lpdwValue = pStage->dwOrgWrapMode;
                        return D3D_OK;
                    }
                }
            }
        }
    }
    *lpdwValue = this->rstates[dwState];
    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetTextureStageState"

HRESULT D3DAPI
CD3DHal::SetTextureStageState(DWORD dwStage,
                              D3DTEXTURESTAGESTATETYPE dwState,
                              DWORD dwValue)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if ( (dwStage >= D3DHAL_TSS_MAXSTAGES) ||
         (dwState == 0) ||
         (dwState >= D3DTSS_MAX) ||
         (dwState == 12) )  // D3DTSS_ADDRESS no longer valid
    {
        D3D_ERR( "Invalid texture stage or state index. SetTextureStageState failed." );
        return D3DERR_INVALIDCALL;
    }
#endif //DBG
    try
    {
        if (this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            m_pStateSets->InsertTextureStageState(dwStage, dwState, dwValue);
            return D3D_OK;
        }
        return this->SetTextureStageStateFast(dwStage, dwState, dwValue);
    }
    catch(HRESULT ret)
    {
        D3D_ERR("SetTextureStageState failed.");
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetTextureStageStateFast"

HRESULT D3DAPI
CD3DHal::SetTextureStageStateFast(DWORD dwStage,
                                  D3DTEXTURESTAGESTATETYPE dwState,
                                  DWORD dwValue)
{
    // NOTE: This can become a public API through the
    // v-table hack. This should only happen for
    // single-threaded apps; so we don't need
    // to take the critical section.
    // API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if ( (dwStage >= D3DHAL_TSS_MAXSTAGES) ||
         (dwState == 0) ||
         (dwState >= D3DTSS_MAX) ||
         (dwState == 12) )  // D3DTSS_ADDRESS no longer valid
    {
        D3D_ERR( "Invalid texture stage or state index. SetTextureStageState failed." );
        return D3DERR_INVALIDCALL;
    }
#endif //DBG

    // Fast path. We do not need any processing done in UpdateInternalTSS other than updating tsstates array
    if (NeedInternalTSSUpdate(dwState))
    {
        // Texture stages could be re-programmed. We need to restore them before
        // filtering  redundant values
        if (m_pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
        {
            RestoreTextureStages(this);
            ForceFVFRecompute();
        }
        if (this->tsstates[dwStage][dwState] == dwValue)
        {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState. Stage: %d, State: %d", dwStage, dwState);
            return D3D_OK;
        }
        if(this->UpdateInternalTextureStageState(dwStage, dwState, &dwValue))
            return D3D_OK;
    }
    else
    {
        if (this->tsstates[dwStage][dwState] == dwValue)
        {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState. Stage: %d, State: %d", dwStage, dwState);
            return D3D_OK;
        }
        tsstates[dwStage][dwState] = dwValue;
    }

    if (dwStage >= m_dwMaxTextureBlendStages)
        return D3D_OK;

    try
    {
        m_pDDI->SetTSS(dwStage, dwState, dwValue);
    }
    catch (HRESULT ret)
    {
        D3D_ERR("SetTextureStageState failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetTextureStageState"

HRESULT D3DAPI
CD3DHal::GetTextureStageState(DWORD dwStage,
                                      D3DTEXTURESTAGESTATETYPE dwState,
                                      LPDWORD pdwValue)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if ( (dwStage >= D3DHAL_TSS_MAXSTAGES) ||
         (dwState == 0) ||
         (dwState >= D3DTSS_MAX) ||
         (dwState == 12) )  // D3DTSS_ADDRESS no longer valid
    {
        D3D_ERR( "Invalid texture stage or state index. GetTextureStageState failed." );
        return D3DERR_INVALIDCALL;
    }
#endif  //DBG

    if (!VALID_WRITEPTR(pdwValue, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer. GetTextureStageState failed." );
        return D3DERR_INVALIDCALL;
    }

    // If texture indices were re-mapped we have to find and return the original value
    if (dwState == D3DTSS_TEXCOORDINDEX && m_pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(this);
        ForceFVFRecompute();
    }
    // Don't bother to check for DX6 support, just return the
    // cached value.
    *pdwValue = tsstates[dwStage][dwState];
    return D3D_OK;
}
#ifdef FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetVertexShaderFast"

HRESULT D3DAPI
CD3DHal::SetVertexShaderFast(DWORD dwHandle)
{
    try
    {
#if DBG
        CheckVertexShaderHandle(dwHandle);

        DebugStateChanged( D3DDM_SC_VSSETSHADER );
#endif
        DXGASSERT((m_dwRuntimeFlags & (D3DRT_RECORDSTATEMODE | D3DRT_RSSOFTWAREPROCESSING)) == 0 &&
                  (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0);

        // We need to set m_pCurrentShader becausu we do NPatch emulation in 
        // hardware vertex processing mode

        static_cast<CD3DHal*>(this)->m_pCurrentShader = NULL;
        CVConstantData* pConst = NULL;
#if DBG
        m_pv->dwDeviceFlags &= ~D3DDEV_VERTEXSHADERS;
#endif
        if (!D3DVSD_ISLEGACY(dwHandle))
        {
            static_cast<CD3DHal*>(this)->m_pCurrentShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
            CVShader* pShader = (CVShader*)m_pVShaderArray->GetObjectFast(dwHandle);
            pConst = pShader->m_Declaration.m_pConstants;
#ifdef DBG
            if(!(pShader->m_dwFlags & CVShader::FIXEDFUNCTION))
            {
                // Programmable pipeline is used
                m_pv->dwDeviceFlags |= D3DDEV_VERTEXSHADERS;
            }
#endif
        }

        // We can return earlier when we do not need to update constants
        if (pConst == NULL)
        {
            if (dwHandle == m_dwCurrentShaderHandle)
                return S_OK;
        }
        else
            // Update our copy of constants for Get()
            while (pConst)
            {
                HRESULT hr;
                hr = m_pv->pGeometryFuncs->LoadShaderConstants(pConst->m_dwAddress,
                                                               pConst->m_dwCount,
                                                               pConst->m_pData);
                if (FAILED(hr))
                {
                    D3D_THROW_FAIL("Failed to load vertex shader constants");
                }
                pConst =  (CVConstantData*)pConst->m_pNext;
            }

        m_dwCurrentShaderHandle = dwHandle;
        if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
        {
            m_pDDI->SetVertexShaderHW(dwHandle);
        }
        if (!IS_DX8HAL_DEVICE(this))
        {
            PickDrawPrimFn();
        }
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetVertexShader failed.");
        ClearVertexShaderHandle();
        return hr;
    }
   return S_OK;
}
#endif // FAST_PATH
//----------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetTransformI"

void CD3DHal::SetTransformI(D3DTRANSFORMSTATETYPE state,
                            CONST D3DMATRIX* lpMat)
{
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < (__WORLDMATRIXBASE + __MAXWORLDMATRICES))
    {
        // World matrix is set
        UINT index = (DWORD)state - __WORLDMATRIXBASE;
        *(LPD3DMATRIX)&m_pv->world[index] = *lpMat;
        if (index == 0)
            this->dwFEFlags |= D3DFE_WORLDMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
    }
    else
    switch (state)
    {
    case D3DTS_VIEW       :
        *(D3DMATRIX*)&m_pv->view = *lpMat;
        this->dwFEFlags |= D3DFE_VIEWMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTS_PROJECTION :
        *(D3DMATRIX*)&this->transform.proj = *lpMat;
        this->dwFEFlags |= D3DFE_PROJMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTS_TEXTURE0:
    case D3DTS_TEXTURE1:
    case D3DTS_TEXTURE2:
    case D3DTS_TEXTURE3:
    case D3DTS_TEXTURE4:
    case D3DTS_TEXTURE5:
    case D3DTS_TEXTURE6:
    case D3DTS_TEXTURE7:
        {
            m_pv->dwDeviceFlags |= D3DDEV_TEXTRANSFORMDIRTY;
            DWORD dwIndex = state - D3DTS_TEXTURE0;
            *(D3DMATRIX*)&m_pv->mTexture[dwIndex] = *lpMat;
            break;
        }
    }
    m_pv->MatrixStateCount++;
    if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
    {
        if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
            this->pMatrixDirtyForDDI->SetBit(state);
        else
            m_pDDI->SetTransform(state, lpMat);
        // W range should always be updated
        if (state == D3DTS_PROJECTION)
            m_pDDI->UpdateWInfo(lpMat);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetTransform"

HRESULT D3DAPI
CD3DHal::GetTransform(D3DTRANSFORMSTATETYPE state, LPD3DMATRIX lpMat)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    HRESULT ret = D3D_OK;
#if DBG
    if (!VALID_WRITEPTR(lpMat, sizeof(D3DMATRIX)))
    {
        D3D_ERR( "Invalid matrix pointer. GetTransform failed." );
        return D3DERR_INVALIDCALL;
    }
#endif
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < (__WORLDMATRIXBASE + __MAXWORLDMATRICES))
    {
        // World matrix is set
        UINT index = (DWORD)state - __WORLDMATRIXBASE;
        *lpMat = *(LPD3DMATRIX)&m_pv->world[index];
    }
    else
    switch (state) {
    case D3DTS_VIEW :
        *lpMat = *(LPD3DMATRIX)&m_pv->view._11;
        break;
    case D3DTS_PROJECTION :
        *lpMat = *(LPD3DMATRIX)&this->transform.proj._11;
        break;
    case D3DTS_TEXTURE0:
    case D3DTS_TEXTURE1:
    case D3DTS_TEXTURE2:
    case D3DTS_TEXTURE3:
    case D3DTS_TEXTURE4:
    case D3DTS_TEXTURE5:
    case D3DTS_TEXTURE6:
    case D3DTS_TEXTURE7:
        *lpMat = *(LPD3DMATRIX)&m_pv->mTexture[state-D3DTS_TEXTURE0]._11;
        break;
    default :
        D3D_ERR( "Invalid state value passed to GetTransform. GetTransform failed." );
        ret = D3DERR_INVALIDCALL; /* Work Item: Generate new meaningful return code */
        break;
    }

    return ret;
}       // end of D3DDev2_GetTransform()

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::UpdateDriverStates"

void
CD3DHal::UpdateDriverStates()
{
    // note we can't do a loop from 1 to D3DHAL_MAX_RSTATES(256) as some of
    // rstates are not valid states, passin them down to drivers(like
    // voodoo2 DX6 driver) will crash.
    static D3DRENDERSTATETYPE dx6states[] =
    {
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_ZVISIBLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_COLORKEYENABLE,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_STIPPLEENABLE,
        D3DRENDERSTATE_MONOENABLE,
        D3DRENDERSTATE_ROP2,
        D3DRENDERSTATE_PLANEMASK,
        D3DRENDERSTATE_WRAPU,
        D3DRENDERSTATE_WRAPV,
        D3DRENDERSTATE_ANTIALIAS,
        D3DRENDERSTATE_SUBPIXEL,
        D3DRENDERSTATE_SUBPIXELX,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_STIPPLEPATTERN00,
        D3DRENDERSTATE_STIPPLEPATTERN01,
        D3DRENDERSTATE_STIPPLEPATTERN02,
        D3DRENDERSTATE_STIPPLEPATTERN03,
        D3DRENDERSTATE_STIPPLEPATTERN04,
        D3DRENDERSTATE_STIPPLEPATTERN05,
        D3DRENDERSTATE_STIPPLEPATTERN06,
        D3DRENDERSTATE_STIPPLEPATTERN07,
        D3DRENDERSTATE_STIPPLEPATTERN08,
        D3DRENDERSTATE_STIPPLEPATTERN09,
        D3DRENDERSTATE_STIPPLEPATTERN10,
        D3DRENDERSTATE_STIPPLEPATTERN11,
        D3DRENDERSTATE_STIPPLEPATTERN12,
        D3DRENDERSTATE_STIPPLEPATTERN13,
        D3DRENDERSTATE_STIPPLEPATTERN14,
        D3DRENDERSTATE_STIPPLEPATTERN15,
        D3DRENDERSTATE_STIPPLEPATTERN16,
        D3DRENDERSTATE_STIPPLEPATTERN17,
        D3DRENDERSTATE_STIPPLEPATTERN18,
        D3DRENDERSTATE_STIPPLEPATTERN19,
        D3DRENDERSTATE_STIPPLEPATTERN20,
        D3DRENDERSTATE_STIPPLEPATTERN21,
        D3DRENDERSTATE_STIPPLEPATTERN22,
        D3DRENDERSTATE_STIPPLEPATTERN23,
        D3DRENDERSTATE_STIPPLEPATTERN24,
        D3DRENDERSTATE_STIPPLEPATTERN25,
        D3DRENDERSTATE_STIPPLEPATTERN26,
        D3DRENDERSTATE_STIPPLEPATTERN27,
        D3DRENDERSTATE_STIPPLEPATTERN28,
        D3DRENDERSTATE_STIPPLEPATTERN29,
        D3DRENDERSTATE_STIPPLEPATTERN30,
        D3DRENDERSTATE_STIPPLEPATTERN31,
        D3DRENDERSTATE_TEXTUREPERSPECTIVE,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7
    };

    HRESULT ret;
    for (DWORD i=0; i<sizeof(dx6states)/sizeof(D3DRENDERSTATETYPE); ++i)
    {
        m_pDDI->SetRenderState( dx6states[i], rstates[dx6states[i]] );
    }

    for( i = 0; i < m_dwMaxTextureBlendStages; i++ )
    {
        for(  DWORD j = D3DTSS_COLOROP ; j < D3DTSS_TEXTURETRANSFORMFLAGS;
              ++j )
        {
            m_pDDI->SetTSS( i, (D3DTEXTURESTAGESTATETYPE)j,
                            this->tsstates[i][j] );
        }
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetClipStatus"

HRESULT D3DAPI CD3DHal::SetClipStatus(CONST D3DCLIPSTATUS8* status)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!VALID_PTR(status, sizeof(D3DCLIPSTATUS8)) )
    {
        D3D_ERR( "Invalid status pointer. SetClipStatus failed." );
        return D3DERR_INVALIDCALL;
    }

#endif
    m_ClipStatus = * status;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetClipStatus"

HRESULT D3DAPI CD3DHal::GetClipStatus(D3DCLIPSTATUS8* status)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (! VALID_WRITEPTR(status, sizeof(D3DCLIPSTATUS8)) )
    {
        D3D_ERR( "Invalid status pointer. GetClipStatus failed." );
        return D3DERR_INVALIDCALL;
    }
#endif
    *status = m_ClipStatus;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SwitchVertexProcessingMode"

void CD3DHal::SwitchVertexProcessingMode(DWORD SoftwareMode)
{
    m_pDDI->FlushStates(FALSE);	
    // Invalidate all streams
    // What if a vertex buffer is batched?
    CVStream* pStream = m_pStream;
    for (UINT i=0; i < __NUMSTREAMS; i++)
    {
        pStream->m_pData = NULL;
        if (pStream->m_pVB)
        {
            m_pDDI->VBReleased(pStream->m_pVB);
            pStream->m_pVB->DecrementUseCount();
            pStream->m_pVB = NULL;
        }
        pStream++;
    }
    m_pIndexStream->m_pData = NULL;
    if (m_pIndexStream->m_pVBI)
    {
        m_pDDI->VBIReleased(m_pIndexStream->m_pVBI);
        m_pIndexStream->m_pVBI->DecrementUseCount();
        m_pIndexStream->m_pVBI = NULL;
    }
    ClearVertexShaderHandle();
    m_pCurrentShader = NULL;
    // Setup capabilities
    if (SoftwareMode)
    {
        m_MaxVertexShaderConst = D3DVS_CONSTREG_MAX_V1_1;
        m_dwRuntimeFlags |= D3DRT_RSSOFTWAREPROCESSING;
        m_dwNumStreams = __NUMSTREAMS;
        m_dwMaxUserClipPlanes = __MAXUSERCLIPPLANES;
#ifdef FAST_PATH
        FastPathSetVertexShaderSlow();
        FastPathSetStreamSourceSlow();
        FastPathSetIndicesSlow();
#endif // FAST_PATH
    }
    else
    {
        // We are switching from the software to the hardware mode
        m_dwRuntimeFlags &= ~D3DRT_RSSOFTWAREPROCESSING;
#ifdef FAST_PATH
        FastPathSetVertexShaderFast();
        FastPathSetStreamSourceFast();    
        FastPathSetIndicesFast();    
#endif // FAST_PATH

        // Update caps from the hardware
        m_dwNumStreams = max(1, GetD3DCaps()->MaxStreams);
        m_dwMaxUserClipPlanes = GetD3DCaps()->MaxUserClipPlanes;

        // Update vertex processing state in the driver. We did not pass the
        // state when it was changed for performance reasons
        for (UINT i=0; i < sizeof(rsVertexProcessingList) / sizeof(D3DRENDERSTATETYPE); ++i)
        {
            D3DRENDERSTATETYPE dwState = (D3DRENDERSTATETYPE)rsVertexProcessingList[i];
            if (CanHandleRenderState(dwState))
                m_pDDI->SetRenderState(dwState, this->rstates[dwState]);
        }

        // Update clip planes
        for (i=0; i < m_dwMaxUserClipPlanes; i++)
            m_pDDI->SetClipPlane(i, (float*)&this->transform.userClipPlane[i]);

        // Update lights
        const UINT size = m_pLightArray->GetSize();
        for (i = 0; i < size; i++)
        {
            DIRECT3DLIGHTI* pLight = static_cast<DIRECT3DLIGHTI*>
                                     ((*m_pLightArray)[i].m_pObj);
            if (pLight)
            {
                if (pLight->DirtyForDDI())
                {
                    m_pDDI->SetLight(i, &pLight->m_Light);
                    pLight->ClearDirtyForDDI();
                }
            }
        }
        // Update Enable/Disable light state. This is done separately to combine
        // multiple calls to the driver into one call.
        for (i = 0; i < size; i++)
        {
            DIRECT3DLIGHTI* pLight = static_cast<DIRECT3DLIGHTI*>
                                     ((*m_pLightArray)[i].m_pObj);
            if (pLight)
            {
                if (pLight->EnableDirtyForDDI())
                {
                    m_pDDI->LightEnable(i, pLight->Enabled());
                    pLight->ClearEnableDirtyForDDI();
                }
            }
        }

        // Update transformation matrices
        if (this->pMatrixDirtyForDDI->IsBitSet(D3DTS_VIEW))
        {
            m_pDDI->SetTransform(D3DTS_VIEW, &m_pv->view);
            this->pMatrixDirtyForDDI->ClearBit(D3DTS_VIEW);
        }
        if (this->pMatrixDirtyForDDI->IsBitSet(D3DTS_PROJECTION))
        {
            m_pDDI->SetTransform(D3DTS_PROJECTION, &this->transform.proj);
            this->pMatrixDirtyForDDI->ClearBit(D3DTS_PROJECTION);
        }
        for (i=D3DTS_TEXTURE0; i <= D3DTS_TEXTURE7; i++)
        {
            if (this->pMatrixDirtyForDDI->IsBitSet(i))
            {
                m_pDDI->SetTransform((D3DTRANSFORMSTATETYPE)i, 
                                     &m_pv->mTexture[i - D3DTS_TEXTURE0]);
                this->pMatrixDirtyForDDI->ClearBit(i);
            }
        }
        for (i=0; i < __MAXWORLDMATRICES; i++)
        {
            UINT index = i + __WORLDMATRIXBASE;
            if (this->pMatrixDirtyForDDI->IsBitSet(index))
            {
                m_pDDI->SetTransform((D3DTRANSFORMSTATETYPE)index, &m_pv->world[i]);
                this->pMatrixDirtyForDDI->ClearBit(index);
            }
        }

        // Update material
        m_pDDI->SetMaterial(&m_pv->lighting.material);

        m_MaxVertexShaderConst = GetD3DCaps()->MaxVertexShaderConst;
        // Update vertex shader constants
        if (m_dwRuntimeFlags & D3DRT_NEED_VSCONST_UPDATE)
        {
            VVM_WORD data[D3DVS_CONSTREG_MAX_V1_1];
            UINT count = min(m_MaxVertexShaderConst, D3DVS_CONSTREG_MAX_V1_1);
            if (count)
            {
                m_pv->pGeometryFuncs->GetShaderConstants(0, count, &data);
                m_pDDI->SetVertexShaderConstant(0, &data, count);
            }
            m_dwRuntimeFlags &= ~D3DRT_NEED_VSCONST_UPDATE;
        }
    }
    PickDrawPrimFn();
}
//---------------------------------------------------------------------
// This function is called from HALEXE.CPP, from device::SetRenderState and
// from device::SetTexture.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::UpdateInternalState"

void CD3DHal::UpdateInternalState(D3DRENDERSTATETYPE type, DWORD value)
{
    switch (type)
    {
#if DBG
    case D3DRS_DEBUGMONITORTOKEN:
        switch(value)
        {
        case D3DDMT_ENABLE:
            m_bDbgMonConnectionEnabled = TRUE;
            break;
        case D3DDMT_DISABLE:
            m_bDbgMonConnectionEnabled = FALSE;
            break;
        }
        rstates[type] = value; // update now so that rtdmon can access value.
        if( m_pDbgMon ) m_pDbgMon->NextEvent( D3DDM_EVENT_RSTOKEN );
        break;
#endif; //DBG
    case D3DRENDERSTATE_LIGHTING:
        if (value)
            m_pv->dwDeviceFlags |= D3DDEV_LIGHTING;
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_LIGHTING;
        ForceFVFRecompute();
        break;
    case D3DRENDERSTATE_FOGENABLE:
        rstates[type] = value;      // set rstates BEFORE calling SetFogFlags
        SetFogFlags();
        break;
    case D3DRENDERSTATE_SPECULARENABLE:
        this->dwFEFlags |= D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY | D3DFE_FRONTEND_DIRTY;
        if (value)
            m_pv->dwDeviceFlags |= D3DDEV_SPECULARENABLE;
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_SPECULARENABLE;
        ForceFVFRecompute();
        break;
    case D3DRENDERSTATE_AMBIENT:
        {
            const D3DVALUE SCALE = 1.0f/255.0f;
            m_pv->lighting.ambientSceneScaled.r = D3DVAL(RGBA_GETRED(value));
            m_pv->lighting.ambientSceneScaled.g = D3DVAL(RGBA_GETGREEN(value));
            m_pv->lighting.ambientSceneScaled.b = D3DVAL(RGBA_GETBLUE(value));
            m_pv->lighting.ambientScene.r = m_pv->lighting.ambientSceneScaled.r * SCALE;
            m_pv->lighting.ambientScene.g = m_pv->lighting.ambientSceneScaled.g * SCALE;
            m_pv->lighting.ambientScene.b = m_pv->lighting.ambientSceneScaled.b * SCALE;
            m_pv->lighting.ambient_save  = value;
            this->dwFEFlags |= D3DFE_MATERIAL_DIRTY | D3DFE_FRONTEND_DIRTY;
            break;
        }
    case D3DRENDERSTATE_RANGEFOGENABLE:
        if (value)
            m_pv->dwDeviceFlags |= D3DDEV_RANGEBASEDFOG;
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_RANGEBASEDFOG;
        break;
    case D3DRENDERSTATE_FOGVERTEXMODE:
        m_pv->lighting.fog_mode = (D3DFOGMODE)value;
        SetFogFlags();
        break;
    case D3DRENDERSTATE_COLORVERTEX:
        if (value)
            m_pv->dwDeviceFlags |= D3DDEV_COLORVERTEX;
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_COLORVERTEX;
        // It is faster to initialize these values here, than setting a dirty
        // bit ang going through the slow UpdateState path
        m_pv->lighting.alpha = (DWORD)m_pv->lighting.materialAlpha;
        m_pv->lighting.alphaSpecular = (DWORD)m_pv->lighting.materialAlphaS;
        break;
    case D3DRENDERSTATE_CLIPPING:
        if (!value)
        {
            m_pv->dwDeviceFlags |= D3DDEV_DONOTCLIP;
            // Clear clip union and intersection flags
            m_pv->dwClipIntersection = 0;
            m_pv->dwClipUnion = 0;
        }
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_DONOTCLIP;
        // Change our internal ProcessPrimitive functions which depend on
        // the clipping state
        m_pDDI->PickProcessPrimitive();
        PickDrawPrimFn();
        break;
    case D3DRENDERSTATE_FOGDENSITY:
        m_pv->lighting.fog_density = *(D3DVALUE*)&value;
        break;
    case D3DRENDERSTATE_FOGSTART:
        m_pv->lighting.fog_start = *(D3DVALUE*)&value;
        UpdateFogFactor(this->m_pv);
        break;
    case D3DRENDERSTATE_FOGEND:
        m_pv->lighting.fog_end = *(D3DVALUE*)&value;
        UpdateFogFactor(this->m_pv);
        break;
    case D3DRENDERSTATE_LOCALVIEWER:
        if (value)
            m_pv->dwDeviceFlags |= D3DDEV_LOCALVIEWER;
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_LOCALVIEWER;
        this->dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DRENDERSTATE_NORMALIZENORMALS:
        if (value)
        {
            if (m_pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)
            {
                m_pv->dwDeviceFlags &= ~D3DDEV_MODELSPACELIGHTING;
                this->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
            }
            m_pv->dwDeviceFlags |= D3DDEV_NORMALIZENORMALS;
        }
        else
        {
            m_pv->dwDeviceFlags &= ~D3DDEV_NORMALIZENORMALS;
            if (!(m_pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                this->dwFEFlags |= D3DFE_NEEDCHECKWORLDVIEWVMATRIX | D3DFE_FRONTEND_DIRTY;
        }
        break;
    case D3DRENDERSTATE_EMISSIVEMATERIALSOURCE:
        m_pv->lighting.dwEmissiveSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            m_pv->lighting.dwEmissiveSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            m_pv->lighting.dwEmissiveSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for DIFFUSEMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_DIFFUSEMATERIALSOURCE:
        m_pv->lighting.dwDiffuseSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            m_pv->lighting.dwDiffuseSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            m_pv->lighting.dwDiffuseSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for DIFFUSEMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_AMBIENTMATERIALSOURCE:
        m_pv->lighting.dwAmbientSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            m_pv->lighting.dwAmbientSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            m_pv->lighting.dwAmbientSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for AMBIENTMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_SPECULARMATERIALSOURCE:
        m_pv->lighting.dwSpecularSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            m_pv->lighting.dwSpecularSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            m_pv->lighting.dwSpecularSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for SPECULARMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_VERTEXBLEND:
        {
#if DBG
            switch (value)
            {
            case D3DVBF_DISABLE:
            case D3DVBF_0WEIGHTS:
            case D3DVBF_1WEIGHTS:
            case D3DVBF_2WEIGHTS:
            case D3DVBF_3WEIGHTS:
            case D3DVBF_TWEENING:
                break;
            default:
                D3D_ERR("Illegal value for D3DRENDERSTATE_VERTEXBLEND");
                goto error_exit;
            }
#endif
            this->dwFEFlags |= D3DFE_VERTEXBLEND_DIRTY | D3DFE_FRONTEND_DIRTY;
            break;
        }
    case D3DRENDERSTATE_CLIPPLANEENABLE:
        {
            this->dwFEFlags |= D3DFE_CLIPPLANES_DIRTY | D3DFE_FRONTEND_DIRTY;
            m_pv->dwMaxUserClipPlanes = 0;
            break;
        }
    case D3DRENDERSTATE_SHADEMODE:
        if (value == D3DSHADE_FLAT)
            m_pv->dwDeviceFlags |= D3DDEV_FLATSHADEMODE;
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_FLATSHADEMODE;
        break;
    case D3DRS_SOFTWAREVERTEXPROCESSING:
        // If DDI cannot do transformation and lighting,
        // D3DRT_RSSOFTWAREPROCESSING is always set to TRUE
        if( BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING )
        {
            DDASSERT( m_pDDI->CanDoTL() );
            if (value != this->rstates[type])
                SwitchVertexProcessingMode(value);
        }
        break;
    case D3DRS_POINTSCALEENABLE:
        if (value)
        {
            // We need world-view matrix to scale point sprites
            this->dwFEFlags |= D3DFE_WORLDVIEWMATRIX_DIRTY |
                               D3DFE_FRONTEND_DIRTY;
        }
        break;
    case D3DRS_POINTSIZE:
        if (*(float*)&value != 1.0f)
            m_dwRuntimeFlags |=  D3DRT_POINTSIZEINRS;
        else
            m_dwRuntimeFlags &= ~D3DRT_POINTSIZEINRS;
        break;

    case D3DRS_POINTSIZE_MAX:
        {
            float MaxPointSize = GetD3DCaps()->MaxPointSize;
            if (MaxPointSize == 0)
                MaxPointSize = __MAX_POINT_SIZE;

            if (*(float*)&value <= MaxPointSize)
                m_pv->PointSizeMax = *(float*)&value;
#if DBG
            else
            {
                D3D_ERR("Max point size is greater than supported by the device");
                goto error_exit;
            }
#endif
        }
        break;
    case D3DRS_INDEXEDVERTEXBLENDENABLE:
        if (value)
            m_pv->dwDeviceFlags |= D3DDEV_INDEXEDVERTEXBLENDENABLE;
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_INDEXEDVERTEXBLENDENABLE;
        ForceFVFRecompute();
        break;
    case D3DRS_PATCHSEGMENTS:
        {
            const D3DCAPS8* pCaps = GetD3DCaps();
            if (!(pCaps->DevCaps & D3DDEVCAPS_NPATCHES) &&
                (pCaps->DevCaps & D3DDEVCAPS_RTPATCHES))
            {
                if (*(float*)&value > 1.0f)
                    m_dwRuntimeFlags |= D3DRT_DONPATCHCONVERSION;
                else
                    m_dwRuntimeFlags &= ~D3DRT_DONPATCHCONVERSION;
                rstates[type] = value;  // Must set before Pick
                PickDrawPrimFn();
            }
        }
        break;

    default:
        // WRAP render states could be re-mapped so we have to restore them before
        // setting a new value
        if (type >= D3DRENDERSTATE_WRAP0 &&  type <= D3DRENDERSTATE_WRAP7)
        {
            if (m_pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
            {
                RestoreTextureStages(this);
                ForceFVFRecompute();
            }
        }
        break;
    }
    rstates[type] = value;      // set rstates for all other cases
    return;

#if DBG
error_exit:
    throw D3DERR_INVALIDCALL;
#endif
}
//---------------------------------------------------------------------
#if DBG
static  char ProfileStr[PROF_DRAWINDEXEDPRIMITIVEVB+1][32]=
{
    "Execute",
    "Begin",
    "BeginIndexed",
    "DrawPrimitive(Device2)",
    "DrawIndexedPrimitive(Device2)",
    "DrawPrimitiveStrided",
    "DrawIndexedPrimitiveStrided",
    "DrawPrimitive(Device7)",
    "DrawIndexedPrimitive(Device7)",
    "DrawPrimitiveVB",
    "DrawIndexedPrimitiveVB",
};
static  char PrimitiveStr[D3DPT_TRIANGLEFAN][16]=
{
    "POINTLIST",
    "LINELIST",
    "LINESTRIP",
    "TRIANGLELIST",
    "TRIANGLESTRIP",
    "TRIANGLEFAN",
};
static  char VertexStr[D3DVT_TLVERTEX][16]=
{
    "D3DVERTEX",
    "D3DLVERTEX",
    "D3DTLVERTEX",
};
#define PROFILE_LEVEL 0

void    CD3DHal::Profile(DWORD caller, D3DPRIMITIVETYPE dwPrimitive, DWORD dwVertex)
{
    DWORD   bitwisecaller= 1 << caller;
    DWORD   bitwisePrimitive = 1 << (DWORD)dwPrimitive;
    DWORD   bitwiseVertex1 = 1 << (dwVertex & 0x001F);
    DWORD   bitwiseVertex2 = 1 << ((dwVertex & 0x03E0) >> 5);
    char    str[256];
    DDASSERT(PROF_DRAWINDEXEDPRIMITIVEVB >= caller);
    DDASSERT(D3DPT_TRIANGLEFAN >= dwPrimitive && D3DPT_POINTLIST<= dwPrimitive);
    if (dwCaller & bitwisecaller)
    {
        if (dwPrimitiveType[caller] & bitwisePrimitive)
        {
            if ((dwVertexType1[caller] & bitwiseVertex1) &&
                (dwVertexType2[caller] & bitwiseVertex2))
            {
                return; //matching a previous api call, no spew, could count stat though
            }
            else
            {
                dwVertexType1[caller] |= bitwiseVertex1;
                dwVertexType2[caller] |= bitwiseVertex2;
            }
        }
        else
        {
            dwPrimitiveType[caller] |= bitwisePrimitive;
            dwVertexType1[caller] |= bitwiseVertex1;
            dwVertexType2[caller] |= bitwiseVertex2;
        }
    }
    else
    {
        this->dwCaller |= bitwisecaller;
        dwPrimitiveType[caller] |= bitwisePrimitive;
        dwVertexType1[caller] |= bitwiseVertex1;
        dwVertexType2[caller] |= bitwiseVertex2;
    }
    wsprintf( (LPSTR) str, ProfileStr[caller]);
    strcat(str,":");
    strcat(str,PrimitiveStr[dwPrimitive-1]);
    if (dwVertex > D3DVT_TLVERTEX)
    {
        if (dwVertex == D3DFVF_VERTEX)
        {
            dwVertex = D3DVT_VERTEX;
        }
        else
        if (dwVertex == D3DFVF_TLVERTEX)
        {
            dwVertex = D3DVT_TLVERTEX;
        }
        else
        {
            D3D_INFO(PROFILE_LEVEL,"Profile:%s FVFType=%08lx",str,dwVertex);
            return;
        }
    }
    else
    {
        DDASSERT(dwVertex >= D3DVT_VERTEX);
    }
    strcat(str,":");
    strcat(str,VertexStr[dwVertex-1]);
    D3D_INFO(PROFILE_LEVEL,"Profile:%s",str);
}

#endif // DBG
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::MultiplyTransformI"

//    MultiplyTransform -- this preconcatenates the new matrix to the specified
//    transform matrix
//
//        this really screams for overloaded matrix ops...
//
void
CD3DHal::MultiplyTransformI(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat)
{
    D3DMATRIXI mResult;
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < (__WORLDMATRIXBASE + __MAXWORLDMATRICES))
    {
        // World matrix is set
        UINT index = (DWORD)state - __WORLDMATRIXBASE;
        MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &m_pv->world[index]);
        m_pv->world[index] = mResult;
        if (index == 0)
            this->dwFEFlags |= D3DFE_WORLDMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
    }
    else
    switch (state)
    {
    case D3DTS_VIEW       :
        MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &m_pv->view);
        m_pv->view = mResult;
        this->dwFEFlags |= D3DFE_VIEWMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTS_PROJECTION :
        MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->transform.proj);
        this->transform.proj = mResult;
        this->dwFEFlags |= D3DFE_PROJMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTS_TEXTURE0:
    case D3DTS_TEXTURE1:
    case D3DTS_TEXTURE2:
    case D3DTS_TEXTURE3:
    case D3DTS_TEXTURE4:
    case D3DTS_TEXTURE5:
    case D3DTS_TEXTURE6:
    case D3DTS_TEXTURE7:
        {
            DWORD dwIndex = state - D3DTS_TEXTURE0;
            MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &m_pv->mTexture[dwIndex]);
            m_pv->mTexture[dwIndex] = mResult;
            break;
        }
    default :
        D3D_THROW_FAIL("Invalid state value passed to MultiplyTransform");
    }
    m_pv->MatrixStateCount++;
    if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
        this->pMatrixDirtyForDDI->SetBit(state);
    else
        m_pDDI->SetTransform(state, (LPD3DMATRIX)&mResult);
    // W range should always be updated
    if (state == D3DTS_PROJECTION)
        m_pDDI->UpdateWInfo((LPD3DMATRIX)&mResult);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::BeginStateBlock"

HRESULT D3DAPI CD3DBase::BeginStateBlock()
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        if (this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            D3D_ERR("Already in the state record mode. BeginStateBlock failed.");
            return D3DERR_INVALIDCALL;
        }
        if (m_pStateSets->StartNewSet() != D3D_OK)
        {
            D3D_ERR("Could not allocate memory for new state block. BeginStateBlock failed.");
            return E_OUTOFMEMORY;
        }

        this->m_dwRuntimeFlags |= D3DRT_RECORDSTATEMODE;
#ifdef FAST_PATH
        FastPathSetRenderStateRecord();
        FastPathSetTextureStageStateRecord();
        FastPathApplyStateBlockRecord();
        FastPathSetTextureRecord();
        FastPathSetVertexShaderSlow();
        FastPathSetStreamSourceSlow();
        FastPathSetIndicesSlow();
        FastPathSetMaterialRecord();
        FastPathMultiplyTransformRecord();
        FastPathSetTransformRecord();
        FastPathSetPixelShaderRecord();
        FastPathSetPixelShaderConstantRecord();
        FastPathSetVertexShaderConstantRecord();
#endif // FAST_PATH
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        D3D_ERR("BeginStateBlock failed.");
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::EndStateBlock"

HRESULT D3DAPI CD3DBase::EndStateBlock(LPDWORD pdwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_WRITEPTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer. EndStateBlock failed." );
        return D3DERR_INVALIDCALL;
    }
    try
    {
        if (!(this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE))
        {
            D3D_ERR("Not in state record mode. EndStateBlock failed.");
            return D3DERR_INVALIDCALL;
        }
        this->m_dwRuntimeFlags &= ~D3DRT_RECORDSTATEMODE;
        m_pStateSets->EndSet();
#ifdef FAST_PATH
        FastPathSetRenderStateExecute();
        FastPathSetTextureStageStateExecute();
        FastPathSetMaterialExecute();
        FastPathSetVertexShaderFast();
        FastPathSetStreamSourceFast();    
        FastPathSetIndicesFast();    
        FastPathApplyStateBlockExecute();
        FastPathSetTextureExecute();
        FastPathSetTransformExecute();
        FastPathMultiplyTransformExecute();
        FastPathSetPixelShaderExecute();
        FastPathSetPixelShaderConstantExecute();
        FastPathSetVertexShaderConstantExecute();
#endif // FAST_PATH
        this->m_pDDI->WriteStateSetToDevice((D3DSTATEBLOCKTYPE)0);
        *pdwHandle = m_pStateSets->GetCurrentHandle();
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        D3D_ERR("EndStateBlock failed.");
        m_pStateSets->Cleanup(m_pStateSets->GetCurrentHandle());
        *pdwHandle = 0xFFFFFFFF;
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DeleteStateBlock"

HRESULT D3DAPI CD3DBase::DeleteStateBlock(DWORD dwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        if (this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            D3D_ERR("We are in state record mode. DeleteStateBlock failed.");
            return D3DERR_INVALIDCALL;
        }
        m_pStateSets->DeleteStateSet(this, dwHandle);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        D3D_ERR("DeleteStateBlock failed.");
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::ApplyStateBlock"

HRESULT D3DAPI CD3DBase::ApplyStateBlock(DWORD dwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        if (this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            D3D_ERR("We are in state record mode. ApplyStateBlock failed.");
            return D3DERR_INVALIDCALL;
        }
        return ApplyStateBlockFast(dwHandle);
    }
    catch(HRESULT ret)
    {
        D3D_ERR("ApplyStateBlock failed.");
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::ApplyStateBlockFast"

HRESULT D3DAPI CD3DBase::ApplyStateBlockFast(DWORD dwHandle)
{
    // NOTE: This can become a public API through the
    // v-table hack. This should only happen for
    // single-threaded apps; so we don't need
    // to take the critical section.
    // API_ENTER(this); // Takes D3D Lock if necessary
    try
    {
        m_pStateSets->Execute(this, dwHandle);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        D3D_ERR("ApplyStateBlock failed.");
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CaptureStateBlock"

HRESULT D3DAPI CD3DBase::CaptureStateBlock(DWORD dwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        if (this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            D3D_ERR("Cannot capture when in the state record mode. CaptureStateBlock failed.");
            return D3DERR_INVALIDCALL;
        }
        m_pStateSets->Capture(this, dwHandle);
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        D3D_ERR("CaptureStateBlock failed.");
        return ret;
    }
}
//---------------------------------------------------------------------
// Input:
//    type      - FVF control dword
//
// Returns D3D_OK, if the control dword is valid.
// D3DERR_INVALIDCALL otherwise
//
#undef  DPF_MODNAME
#define DPF_MODNAME "CD3DBase::ValidateFVF"

HRESULT __declspec(nothrow) CD3DBase::ValidateFVF(DWORD type)
{
    DWORD dwTexCoord = FVF_TEXCOORD_NUMBER(type);
    DWORD vertexType = type & D3DFVF_POSITION_MASK;
    // Texture format bits above texture count should be zero
    // Reserved field 0 and 2 should be 0
    // Reserved 1 should be set only for LVERTEX
    // Only two vertex position types allowed
    if (type & g_TextureFormatMask[dwTexCoord])
    {
        D3D_ERR("FVF Validation error: FVF has incorrect texture format");
        goto error;
    }
    if (type & 0xFFFF0000 && vertexType == D3DFVF_XYZRHW &&
        m_dwRuntimeFlags & D3DRT_ONLY2FLOATSPERTEXTURE)
    {
        D3D_ERR("FVF Validation error: The D3D device supports only two floats per texture coordinate set");
        goto error;
    }
    if (type & D3DFVF_RESERVED0)
    {
        D3D_ERR("FVF has reserved bit(s) set");
        goto error;
    }
    if (!(vertexType == D3DFVF_XYZRHW ||
          vertexType == D3DFVF_XYZ ||
          vertexType == D3DFVF_XYZB1 ||
          vertexType == D3DFVF_XYZB2 ||
          vertexType == D3DFVF_XYZB3 ||
          vertexType == D3DFVF_XYZB4 ||
          vertexType == D3DFVF_XYZB5))
    {
        D3D_ERR("FVF Validation error: FVF has incorrect position type");
        goto error;
    }

    if (vertexType == D3DFVF_XYZRHW && type & D3DFVF_NORMAL)
    {
        D3D_ERR("FVF Validation error: Normal should not be used with XYZRHW position type");
        goto error;
    }
    return D3D_OK;
error:
    return D3DERR_INVALIDCALL;
}
//---------------------------------------------------------------------
// Returns TRUE, if driver state should not be updated
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::UpdateInternalTextureStageState"

BOOL CD3DHal::UpdateInternalTextureStageState
        (DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD* pValue)
{
    DWORD dwValue = *pValue;
    BOOL ret = FALSE; // return TRUE if TSS should NOT be batched
    if(dwState == D3DTSS_COLOROP)
    {
        if(dwValue == D3DTOP_DISABLE || tsstates[dwStage][D3DTSS_COLOROP] == D3DTOP_DISABLE)
            ForceFVFRecompute();
    }
    else
    if (dwState == D3DTSS_TEXCOORDINDEX)
    {
        if (TextureTransformEnabled(this))
        {
            ForceFVFRecompute();
        }
        DWORD dwTexGenMode = 0;
        if (dwValue >= D3DDP_MAXTEXCOORD)
        {
            dwTexGenMode = dwValue & ~0xFFFF;
            if(!m_pDDI->CanDoTL())
                ret = TRUE;
#if DBG
            DWORD dwTexIndex   = dwValue & 0xFFFF;
            if (!(dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL ||
                  dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION ||
                  dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR) ||
                  dwTexIndex > D3DDP_MAXTEXCOORD)
            {
                D3D_ERR("Incorrect texture coordinate set index");
                throw D3DERR_INVALIDCALL;
            }
#endif
        }
        // Now we need to update internal flag (dwFlags2) which says whether
        // texture generation for the stage is enabled
        DWORD dwTexGenBit = __FLAGS2_TEXGEN0 << dwStage;
        if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
        {
            // We need to update internal flags when tex gen mode is changed,
            // so always call ForceFVFRecompute
            ForceFVFRecompute();
            m_pv->dwFlags2 |= dwTexGenBit;
        }
        else
        {
            // As optimization, recompute FVF only if texture generation for 
            // the stage was enabled 
            if (m_pv->dwFlags2 & dwTexGenBit)
            {
                ForceFVFRecompute();
                m_pv->dwFlags2 &= ~dwTexGenBit;
            }
        }
    }
    else
    if (dwState == D3DTSS_TEXTURETRANSFORMFLAGS)
    {
        DWORD dwEnableBit = 1 << dwStage;   // To check internal "enable" dword
        // Force to re-compute FVF only if enable state is changed
        if ((dwValue & ~D3DTTFF_PROJECTED) == D3DTTFF_DISABLE)
        {
            if (m_pv->dwFlags2 & dwEnableBit)
            {
                ForceFVFRecompute();
                m_pv->dwFlags2 &= ~dwEnableBit;
            }
        }
        else
        {
            if (!(m_pv->dwFlags2 & dwEnableBit))
            {
                ForceFVFRecompute();
                m_pv->dwFlags2 |= dwEnableBit;
            }
        }

        // Do not pass texture transform flags to DX6 devices
        if(GetDDIType() == D3DDDITYPE_DX6)
            ret = TRUE;

        // When we need to emulate projected textures we do not pass "projected"
        // bit to the device. We also decrease the float count.
        if (m_dwRuntimeFlags & D3DRT_EMULATEPROJECTEDTEXTURE)
        {
            // Compute projected bit
            DWORD dwEnableBit = __FLAGS2_TEXPROJ0 << dwStage;
            if (dwValue & D3DTTFF_PROJECTED)
            {
                // Remove projected bit. Note that tsstates will keep the
                // original value
                *pValue &= ~D3DTTFF_PROJECTED;
                // Reduce float count
                if (*pValue != D3DTTFF_DISABLE)
                    (*pValue)--;
                if (!(m_pv->dwFlags2 & dwEnableBit))
                {
                    ForceFVFRecompute();
                    m_pv->dwFlags2 |= dwEnableBit;
                }
            }
            else
            {
                // Just clear projection enabled bit and recompute FVF
                if (m_pv->dwFlags2 & dwEnableBit)
                {
                    ForceFVFRecompute();
                    m_pv->dwFlags2 &= ~dwEnableBit;
                }
            }
        }
    }
    else
    if(dwState > D3DTSS_TEXTURETRANSFORMFLAGS)
    {
        if(GetDDIType() == D3DDDITYPE_DX6)
            ret = TRUE;
    }
    // Update runtime copy of state.
    tsstates[dwStage][dwState] = dwValue;
    return ret;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetClipPlaneI"

void CD3DHal::SetClipPlaneI(DWORD dwPlaneIndex, CONST D3DVALUE* pPlaneEquation)
{
    D3DVALUE *p = &this->transform.userClipPlane[dwPlaneIndex].x;
    p[0] = pPlaneEquation[0];
    p[1] = pPlaneEquation[1];
    p[2] = pPlaneEquation[2];
    p[3] = pPlaneEquation[3];
    this->dwFEFlags |= D3DFE_CLIPPLANES_DIRTY | D3DFE_FRONTEND_DIRTY;
    if (!(m_dwRuntimeFlags & (D3DRT_EXECUTESTATEMODE |
                              D3DRT_RSSOFTWAREPROCESSING)))
    {
        m_pDDI->SetClipPlane(dwPlaneIndex,
                             pPlaneEquation);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetClipPlane"

HRESULT D3DAPI
CD3DHal::GetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (dwPlaneIndex >= __MAXUSERCLIPPLANES)
    {
        D3D_ERR("Plane index is too big. GetClipPlane failed.");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_WRITEPTR(pPlaneEquation, sizeof(D3DVALUE)*4))
    {
        D3D_ERR( "Invalid plane pointer. GetClipPlane failed." );
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        D3DVALUE *p = &this->transform.userClipPlane[dwPlaneIndex].x;
        pPlaneEquation[0] = p[0];
        pPlaneEquation[1] = p[1];
        pPlaneEquation[2] = p[2];
        pPlaneEquation[3] = p[3];
    }
    catch(HRESULT ret)
    {
        D3D_ERR("GetClipPlane failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CreateStateBlock"

HRESULT D3DAPI
CD3DBase::CreateStateBlock(D3DSTATEBLOCKTYPE sbt,
                           LPDWORD pdwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_WRITEPTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer. CreateStateBlock failed." );
        return D3DERR_INVALIDCALL;
    }
    try
    {
        if (this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            D3D_ERR("Cannot create state block when in the state record mode. CreateStateBlock failed.");
            return D3DERR_INVALIDCALL;
        }

        m_pStateSets->CreatePredefined(this, sbt);

        *pdwHandle = m_pStateSets->GetCurrentHandle();
    }
    catch (HRESULT ret)
    {
        D3D_ERR("CreateStateBlock failed.");
        m_pStateSets->Cleanup(m_pStateSets->GetCurrentHandle());
        *pdwHandle = 0xFFFFFFFF;
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// Restore indices in the texture stages which were re-mapped for texture
// transforms
// We have to do restore if
//  - Set or Get render state is issued with _WRAP parameter
//  - Set or Get texture stage is issued with TEXCOORDINDEX as a parameter
//
void RestoreTextureStages(LPD3DHAL pDevI)
{
    D3DFE_PROCESSVERTICES* pv = pDevI->m_pv;
    // dwVIDIn is used to force re-compute FVF in the
    // SetTextureStageState. so we save and restore it.
    DWORD dwVIDInSaved = pv->dwVIDIn;
    pv->dwDeviceFlags &= ~D3DDEV_REMAPTEXTUREINDICES;
    for (DWORD i=0; i < pDevI->dwNumTextureStagesToRemap; i++)
    {
        LPD3DFE_TEXTURESTAGE pStage = &pDevI->textureStageToRemap[i];
        // Texture generation mode was stripped out of pStage->dwInpCoordIndex
        DWORD dwInpIndex = pStage->dwInpCoordIndex + pStage->dwTexGenMode;
        if (dwInpIndex != pStage->dwOutCoordIndex)
        {
            // We do not call UpdateInternalTextureStageState because it
            // will call ForceRecomputeFVF and we do not want this.
            pDevI->tsstates[pStage->dwOrgStage][D3DTSS_TEXCOORDINDEX] = dwInpIndex;

            // Filter texgen modes for non-TL drivers
            if (pDevI->m_pDDI->CanDoTL() || dwInpIndex < D3DDP_MAXTEXCOORD)
            {
                pDevI->m_pDDI->SetTSS(pStage->dwOrgStage, D3DTSS_TEXCOORDINDEX, dwInpIndex);
            }
        }
        DWORD dwState = D3DRENDERSTATE_WRAP0 + pStage->dwOutCoordIndex;
        if (pStage->dwOrgWrapMode != pDevI->rstates[dwState])
        {
            // We do not call UpdateInternaState because it
            // will call ForceRecomputeFVF and we do not want this.
            pDevI->rstates[dwState] = pStage->dwOrgWrapMode;

            pDevI->m_pDDI->SetRenderState((D3DRENDERSTATETYPE)dwState,
                                          pStage->dwOrgWrapMode);
        }
    }
    pv->dwVIDIn = dwVIDInSaved;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\debugmon.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// debugmon.cpp
//
// Direct3D Debug Monitor
//
//
// MUST BE KEPT IN SYNC WITH debugmon.cpp IN REF8\RAST
//
///////////////////////////////////////////////////////////////////////////////
/*

WORKLIST

- vertex shader source <-> debugger

*/

#include "pch.cpp"
#pragma hdrstop

#include <process.h>
#include "debugmon.hpp"

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
D3DDebugMonitor::D3DDebugMonitor( void )
{

    // get pid and create DebugTargetContext sharedmem
    int pid = _getpid();
    m_pTgtCtxSM = new D3DSharedMem( sizeof(DebugTargetContext), D3DDM_TGTCTX_SM "%d", pid );
    m_pTgtCtx = (DebugTargetContext*)(m_pTgtCtxSM->GetPtr());
    memset( m_pTgtCtx, 0x0, sizeof(DebugTargetContext) );
    m_pTgtCtx->Version = D3DDM_VERSION;
    m_pTgtCtx->ProcessID = pid;

    // create target events
    char name[128];
    _snprintf( name, 128, D3DDM_TGT_EVENTBP "%d", m_pTgtCtx->ProcessID );
    m_hTgtEventBP = CreateEvent( NULL, FALSE, FALSE, name );
    DDASSERT( m_hTgtEventBP );
    _snprintf( name, 128, D3DDM_TGT_EVENTACK "%d", m_pTgtCtx->ProcessID );
    m_hTgtEventAck = CreateEvent( NULL, FALSE, FALSE, name );
    DDASSERT( m_hTgtEventAck );

    // null out monitor connections
    m_pMonCtx = NULL;
    m_pMonCtxSM = NULL;
    m_pCmdData = NULL;
    m_pCmdDataSM = NULL;
    m_hMonEventCmd = 0;
}
//-----------------------------------------------------------------------------
D3DDebugMonitor::~D3DDebugMonitor( void )
{
    // send disconnect event to monitor
    m_pTgtCtx->EventStatus = D3DDM_EVENT_TARGETEXIT;
    SetEvent( m_hTgtEventBP );

    DetachMonitorConnection();
    CloseHandle( m_hTgtEventBP );
    CloseHandle( m_hTgtEventAck );
    delete m_pTgtCtxSM;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
HRESULT
D3DDebugMonitor::AttachToMonitor( int iMon )
{
#if(D3D_DEBUGMON>0x00)
    if (iMon < 1) return E_FAIL;
    if (MonitorConnected() || !m_bDbgMonConnectionEnabled)
    {
        return E_FAIL;
    }

    // attach to monitor context
    m_pMonCtxSM = new D3DSharedMem( sizeof(DebugMonitorContext), D3DDM_MONCTX_SM "%d", iMon );
    if ( !m_pMonCtxSM->AlreadyExisted() ) goto _fail_return; // monitor not there

    // get pointer to monitor context bits
    m_pMonCtx = (const DebugMonitorContext*)m_pMonCtxSM->GetPtr();
    if (m_pMonCtx->TargetID) goto _fail_return; // monitor already taken

    // request attachment to this context (cast to non-const just this once...)
    ((DebugMonitorContext*)m_pMonCtx)->TargetIDRequest = m_pTgtCtx->ProcessID;

    // attach to monitor event acknowledge
    char name[128];
    _snprintf( name, 128, D3DDM_MON_EVENTCMD "%d", iMon );
    m_hMonEventCmd = OpenEvent( EVENT_ALL_ACCESS, NULL, name );

    // signal monitor via it's own event (just this once) and wait for reply on our ack
    D3D_INFO(0, "D3DDebugTarget - attempting to attach to monitor");
    SignalObjectAndWait( m_hMonEventCmd, m_hTgtEventAck, INFINITE, FALSE );
    if ( m_pMonCtx->TargetID != m_pTgtCtx->ProcessID ) goto _fail_return;

    // monitor is attached to this target
    m_pTgtCtx->MonitorID = iMon;

    // attach to command data SM
    m_pCmdDataSM = new D3DSharedMem( D3DDM_CMDDATA_SIZE,
        D3DDM_CMDDATA_SM "%d", m_pTgtCtx->MonitorID );
    m_pCmdData = (DebugMonitorContext*)(m_pCmdDataSM->GetPtr());

    // tell monitor that we are done attaching
    SetEvent( m_hTgtEventBP );
    D3D_INFO(0, "D3DDebugTarget - debug monitor attached");

    return S_OK;

_fail_return:
    if (m_pMonCtxSM) delete m_pMonCtxSM;
    m_pMonCtxSM = NULL;
    m_pMonCtx = NULL;
    if (m_hMonEventCmd) CloseHandle( m_hMonEventCmd ); m_hMonEventCmd = 0;
    return E_FAIL;
#else
    return E_FAIL;
#endif
}

//-----------------------------------------------------------------------------
// drop connection
//-----------------------------------------------------------------------------
void
D3DDebugMonitor::DetachMonitorConnection( void )
{
#if(D3D_DEBUGMON>0x00)
#ifdef DBG
    // SD build complains in free build about empty statement in this if
    // so only do this in debug (MonitorConnected has no evil side effects)
    if (MonitorConnected())
        D3D_INFO(0, "D3DDebugTarget - debug monitor detached");
#endif // DBG

    // drop attachment to monitor and delete monitor context attachment
    m_pTgtCtx->MonitorID = 0;   // let monitor know it is being dropped
    if (NULL != m_pMonCtxSM) delete m_pMonCtxSM; m_pMonCtxSM = NULL;
    m_pMonCtx = NULL;
    if (NULL != m_pCmdDataSM) delete m_pCmdDataSM; m_pCmdDataSM = NULL;
    m_pCmdData = NULL;
    ResetEvent( m_hMonEventCmd );
    if (m_hMonEventCmd) CloseHandle( m_hMonEventCmd ); m_hMonEventCmd = NULL;
#endif
}

//-----------------------------------------------------------------------------
// check for lost monitor connection, and clean up if necessary
//-----------------------------------------------------------------------------
BOOL
D3DDebugMonitor::CheckLostMonitorConnection( void )
{
#if(D3D_DEBUGMON>0x00)
    if ( !m_pMonCtx )
    {
        // not connected
        return TRUE;
    }

    if ( m_pMonCtx->TargetID != m_pTgtCtx->ProcessID )
    {
        // we have been disconnected
        DetachMonitorConnection();
        return TRUE;
    }
    return FALSE;
#else
    return TRUE;
#endif
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
BOOL
D3DDebugMonitor::IsEventBreak( UINT32 EventType )
{
    BOOL bReturn = FALSE;

#define _D3DDM_EVENT_CASE( _Event) \
    case D3DDM_EVENT_##_Event: if (MonitorEventBP() & D3DDM_EVENT_##_Event) { bReturn = TRUE; } break

    // keep this as single line per event - convenient place to set debugger breakpoints
    switch ( EventType )
    {

    _D3DDM_EVENT_CASE(RSTOKEN);
    _D3DDM_EVENT_CASE(BEGINSCENE);
    _D3DDM_EVENT_CASE(ENDSCENE);

    _D3DDM_EVENT_CASE(VERTEX);
    _D3DDM_EVENT_CASE(VERTEXSHADERINST);

    _D3DDM_EVENT_CASE(PRIMITIVE);
    _D3DDM_EVENT_CASE(PIXEL);
    _D3DDM_EVENT_CASE(PIXELSHADERINST);

    default: break;
    }
    return bReturn;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
HRESULT
D3DDebugMonitor::MonitorBreakpoint( void )
{
    CheckLostMonitorConnection();

    if ( !MonitorConnected() ) return S_OK;

    // tell monitor that we are at an event breakpoint
    SetEvent( m_hTgtEventBP );
    D3D_INFO(0, "D3DDebugTarget - stopped in debug monitor");

    // spin here responding to commands until command given to go
    BOOL bResume = FALSE;
    while ( !bResume )
    {
        // wait for command to be issued (or monitor dropped)
        WaitForSingleObject( m_hMonEventCmd, INFINITE );
        if ( CheckLostMonitorConnection() )
        {
            bResume = TRUE;
            break;
        }

        // process command
        switch ( m_pMonCtx->Command & D3DDM_CMD_MASK )
        {
        case D3DDM_CMD_GO:
            m_pTgtCtx->CommandBufferSize = 0;
            bResume = TRUE;
            break;
        default:
            ProcessMonitorCommand();
            break;
        }
        // acknowledge command processing done
        SetEvent( m_hTgtEventAck );
    }
    D3D_INFO(0, "D3DDebugTarget - resumed");

    return S_OK;
}

//-----------------------------------------------------------------------------
//
//  Generic shared memory object, implemented using Win32 file mapping.
//  _snprintf interface for name.
//
//  6/20/2000(RichGr) - IA64: Change first parameter from int to INT_PTR so that
//     all parameters are the same length.  This is needed to make the va_start 
//     macro work correctly.
//
//-----------------------------------------------------------------------------
D3DSharedMem::D3DSharedMem( INT_PTR cbSize, const char* pszFormat, ... )
{
    m_pMem = NULL;

    char pszName[1024] = "\0";
    va_list marker;
    va_start(marker, pszFormat);
    _vsnprintf(pszName+lstrlen(pszName), 1024-lstrlen(pszName), pszFormat, marker);

//  6/20/2000(RichGr) - IA64: Change file handle from (HANDLE)0xFFFFFFF to INVALID_HANDLE_VALUE.
//     This generates the correct -1 value for both 32-bit and 64-bit builds. 
    m_hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE,
            NULL, PAGE_READWRITE, 0, (DWORD)cbSize, pszName);

    // check if it existed already
    m_bAlreadyExisted = (m_hFileMap != NULL) && (GetLastError() == ERROR_ALREADY_EXISTS);

    if (NULL == m_hFileMap)
    {
        DDASSERT(0);
    }
    else
    {
        // Map a view of the file into the address space.
        m_pMem = (void *)MapViewOfFile(m_hFileMap, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
        if (NULL == m_pMem)
        {
            DDASSERT(0);
            if (NULL != m_hFileMap)  CloseHandle(m_hFileMap);
        }
    }
}
D3DSharedMem::~D3DSharedMem(void)
{
    if (NULL != m_pMem)  UnmapViewOfFile((LPVOID) m_pMem);
    if (NULL != m_hFileMap)  CloseHandle(m_hFileMap);
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\dlld3d.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   dlld3d.cpp
 *  Content:    Direct3D startup
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//---------------------------------------------------------------------
//
// Flags to identify CPUs and CPU features
//
//---------------------------------------------------------------------

// MMX available
#define D3DCPU_MMX          0x00000001L

// FCOMI and CMOV are both supported
#define D3DCPU_FCOMICMOV    0x00000002L

// Reads block until satisfied
#define D3DCPU_BLOCKINGREAD 0x00000004L

// Extended 3D support available
#define D3DCPU_X3D          0x00000008L

// Pentium II CPU
#define D3DCPU_PII          0x000000010L

// Streaming SIMD Extensions (aka Katmai) CPU
#define D3DCPU_SSE          0x000000020L

//#define __D3D_PSGP_DLL__

//---------------------------------------------------------------------
//
// Global variables
//
//---------------------------------------------------------------------

HINSTANCE hGeometryDLL = NULL;
LPD3DFE_CONTEXTCREATE pfnFEContextCreate = NULL;    // Used when PSGP is DLL
char szCPUString[13];

DWORD dwCPUFamily, dwCPUFeatures;

void SetMostRecentApp(void);

#ifdef _X86_
// --------------------------------------------------------------------------
// Here's a routine helps us determine if we should try MMX or not
// --------------------------------------------------------------------------
BOOL _asm_isMMX()
{
    DWORD retval;
    _asm
        {
            xor         eax,eax         ; Clear out eax for return value
            pushad              ; CPUID trashes lots - save everything
            mov     eax,1           ; Check for MMX support
            ;;; We need to upgrade our compiler
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2
            test    edx,00800000h   ; Set flags before restoring registers
            popad               ; Restore everything
            setnz    al             ; Set return value
            mov     retval, eax
         };
    return retval;
}
#endif

static int isMMX = -1;

BOOL
isMMXprocessor(void)
{
    HKEY hKey;
    if ( RegOpenKey( HKEY_LOCAL_MACHINE,
                     RESPATH_D3D,
                     &hKey) == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = 4;
        if ( RegQueryValueEx( hKey, "DisableMMX", NULL, &dwType,
                              (LPBYTE) &dwValue, &dwSize) == ERROR_SUCCESS &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            RegCloseKey( hKey );
            isMMX = 0;
            return FALSE;
        }
        RegCloseKey( hKey );
    }

    if (isMMX < 0)
    {
        isMMX = FALSE;
#ifdef _X86_
        D3D_WARN(4, "Executing processor detection code (benign first-chance exception possible)" );
#ifndef WIN95
        {
            // GetSystemInfo is not broken on WinNT.
            SYSTEM_INFO si;

            GetSystemInfo(&si);
            if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL &&
                si.wProcessorLevel >= 5)
            {
#endif
                __try
                    {
                        if( _asm_isMMX() )
                        {

                            // Emit an emms instruction.
                            // This file needs to compile for non-Pentium
                            // processors
                            // so we can't use use inline asm since we're in the
                            // wrong
                            // processor mode.
                            __asm __emit 0xf;
                            __asm __emit 0x77;
                            isMMX = TRUE;
                            D3D_INFO(4, "MMX detected");
                        }
                    }
                __except(GetExceptionCode() == STATUS_ILLEGAL_INSTRUCTION ?
                         EXCEPTION_EXECUTE_HANDLER :
                         EXCEPTION_CONTINUE_SEARCH)
                    {
                    }
#ifndef WIN95
            }
        }
#endif
#endif
    }
    return isMMX;
}

#ifdef _X86_

//---------------------------------------------------------------------
BOOL IsWin95(void)
{
#ifdef WIN95 // and Win98...
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx(&osvi))
    {
        D3D_INFO(1,"GetVersionEx failed - assuming Win95");
        return TRUE;
    }

    if ( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
    {

        if( ( osvi.dwMajorVersion > 4UL ) ||
            ( ( osvi.dwMajorVersion == 4UL ) &&
              ( osvi.dwMinorVersion >= 10UL ) &&
              ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
        {
            // is Win98
            D3D_INFO(2,"Detected Win98");
            return FALSE;
        }
        else
        {
            // is Win95
            D3D_INFO(2,"Detected Win95");
            return TRUE;
        }
    }
    else if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        D3D_INFO(2,"Detected WinNT");
        return FALSE;
    }
    D3D_INFO(2,"OS Detection failed");
    return TRUE;
#else
    return FALSE;
#endif  // WIN95
}
//---------------------------------------------------------------------
//
//  void GetProcessorFamily(LPDWORD lpdwFamily);
//
//      Passes back 3, 4, 5, 6 for 386, 486, Pentium, PPro class machines
//
#pragma optimize("", off)
void
GetProcessorFamily(LPDWORD lpdwFamily, LPDWORD lpdwCPUFeatures)
{
    SYSTEM_INFO si;
    __int64     start, end, freq;
    int         flags,family;
    int         time;
    int         clocks;
    DWORD       oldclass;
    HANDLE      hprocess;

    // guilty until proven otherwise
    *lpdwCPUFeatures = D3DCPU_BLOCKINGREAD;

    if ( isMMXprocessor() )
    {
        *lpdwCPUFeatures |= D3DCPU_MMX;
    }

    ZeroMemory(&si, sizeof(si));
    GetSystemInfo(&si);

    //Set the family. If wProcessorLevel is not specified, dig it out of dwProcessorType
    //Because wProcessor level is not implemented on Win95
    if (si.wProcessorLevel)
    {
        *lpdwFamily=si.wProcessorLevel;
    }
    else
    {
        //Ok, we're on Win95
        switch (si.dwProcessorType)
        {
        case PROCESSOR_INTEL_386:
            *lpdwFamily=3;
            break;

        case PROCESSOR_INTEL_486:
            *lpdwFamily=4;
            break;
        default:
            *lpdwFamily=0;
            break;
        }
    }

    //
    // make sure this is a INTEL Pentium (or clone) or higher.
    //
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
        return;

    if (si.dwProcessorType < PROCESSOR_INTEL_PENTIUM)
        return;

    //
    // see if this chip supports rdtsc before using it.
    //
    __try
        {
            _asm
            {
                 xor     eax,eax
                 _emit   00fh    ;; CPUID
                 _emit   0a2h
                 mov     dword ptr szCPUString,ebx
                 mov     dword ptr szCPUString+8,ecx
                 mov     dword ptr szCPUString+4,edx
                 mov     byte ptr szCPUString+12,0
                 mov     eax,1
                 _emit   00Fh     ;; CPUID
                 _emit   0A2h
                 mov     flags,edx
                 mov     family,eax
            }
        }
    __except(1)
        {
            flags = 0;
        }

    //check for support of CPUID and fail
    if (!(flags & 0x10))
        return;

    // fcomi and FPU features both set
    if ( (flags&(1<<15)) && (flags & (1<<0)) )
    {
        D3D_INFO(2, "Pentium Pro CPU features (fcomi, cmov) detected");
        *lpdwCPUFeatures |= D3DCPU_FCOMICMOV;
    }

    //If we don't have a family, set it now
    //Family is bits 11:8 of eax from CPU, with eax=1
    if (!(*lpdwFamily))
    {
        *lpdwFamily=(family& 0x0F00) >> 8;
    }
    // not aware of any non-Intel processors w/non blocking reads
    if ( (! strcmp(szCPUString, "GenuineIntel")) &&
         *lpdwFamily > 5)
    {
        *lpdwCPUFeatures &= ~D3DCPU_BLOCKINGREAD;
    }

    return;
}
#pragma optimize("", on)

#endif // _X86_

#ifndef WIN95 // and Win98, WinME
//---------------------------------------------------------------------

BOOL bVBSwapEnabled = TRUE, bVBSwapWorkaround = FALSE;

void SetVBSwapStatus(void)
{
    OSVERSIONINFOEX osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx((LPOSVERSIONINFO)&osvi))
    {
        D3D_INFO(1,"GetVersionEx failed - turning off VB swapping");
        bVBSwapEnabled = FALSE;
        return;
    }

    if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0) // Check if Win2K Gold (2195)
        {
            if (osvi.wServicePackMajor == 0) // No service pack
            {
                D3D_INFO(1, "Win2K Gold detected - turning off VB swapping");
                bVBSwapEnabled = FALSE;
            }
            else
            {
                D3D_INFO(1, "Win2K SP1 or above detected - enabling VB swap workaround");
                bVBSwapEnabled = FALSE;
                bVBSwapWorkaround = TRUE;
            }
        }
        else // Whistler and above
        {
            /* ASSUMPTION: NO WORKAROUND NEEDED */
        }
    }
    else
    {
        // Should never get here
        DPF_ERR("OS Detection failed - turning off VB swapping");
        bVBSwapEnabled = FALSE;
        return;
    }
}
#endif // WIN95

extern "C" BOOL APIENTRY D3DDllMain( HMODULE hModule,
                                     DWORD ul_reason_for_call,
                                     LPVOID lpReserved );

BOOL APIENTRY
D3DDllMain( HMODULE hModule,
            DWORD ul_reason_for_call,
            LPVOID lpReserved )
{
    HKEY hKey;
    LONG lRet;
    DWORD dwType, dwSize;
    char filename[_MAX_PATH];

    switch( ul_reason_for_call )
    {
    case DLL_PROCESS_ATTACH:
#ifdef _X86_
        GetProcessorFamily(&dwCPUFamily, &dwCPUFeatures);
        D3D_INFO(3, "dwCPUFamily = %d, dwCPUFeatures = %d",
                 dwCPUFamily, dwCPUFeatures);
        D3D_INFO(3, "szCPUString = %s", szCPUString);
#endif

    // SSE (aka Katmai) does not work on Win95, so see if we are on
    // Win95 and disable
#ifdef WIN95
    {
        BOOL bIsWin95 = IsWin95();
        if ((dwCPUFeatures & D3DCPU_SSE) && bIsWin95)
        {
            D3D_INFO(1,"Disabling <Streaming SIMD Extension> support on Win95");
            dwCPUFeatures &= ~D3DCPU_SSE;
        }
    }
        // We need to workaround VB problems on Win2K
#else
        SetVBSwapStatus();
#endif

#ifdef __D3D_PSGP_DLL__
    lRet = RegOpenKey( HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey );
    if ( lRet == ERROR_SUCCESS )
    {
        dwSize = sizeof(filename);
        lRet = RegQueryValueEx(hKey,
                               "GeometryDriver",
                               NULL,
                               &dwType,
                               (LPBYTE) filename,
                               &dwSize);
        if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
        {
            hGeometryDLL = LoadLibrary(filename);
            if (hGeometryDLL)
            {
                pfnFEContextCreate = (LPD3DFE_CONTEXTCREATE) GetProcAddress(hGeometryDLL, "FEContextCreate");
            }
        }

        RegCloseKey( hKey );
    }
#endif //__D3D_PSGP_DLL__

    // Set the app name to reg.
    SetMostRecentApp();
    break;
    case DLL_PROCESS_DETACH:
        if (NULL != hGeometryDLL)
            FreeLibrary(hGeometryDLL);
        break;
    default:
        ;
    }
    return TRUE;
}

// --------------------------------------------------------------------------
// This function is called at process attach time to put the name of current
// app to registry.
// --------------------------------------------------------------------------
void SetMostRecentApp(void)
{
    char    fname[_MAX_PATH] = "\0";
    char    name[_MAX_PATH] = "\0";
    int     i;
    HKEY    hKey;
    HANDLE  hFile;

    // Find out what process we are dealing with
    hFile =  GetModuleHandle( NULL );
    GetModuleFileName( (HINSTANCE)hFile, fname, sizeof( fname ) );
    //DPF( 3, "full name  = %s", fname );
    i = strlen( fname )-1;
    while( i >=0 && fname[i] != '\\' )
    {
        i--;
    }
    i++;
    strcpy( name, &fname[i] );
    //DPF( 3, "name       = %s", name );

    // Now write the name into some known place
    if( !RegCreateKey( HKEY_LOCAL_MACHINE,
                       RESPATH_D3D "\\" REGSTR_KEY_LASTAPP, &hKey ) )
    {
        RegSetValueEx(hKey, REGSTR_VAL_DDRAW_NAME, 0, REG_SZ, (LPBYTE)name, strlen(name)+1);
        RegCloseKey(hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\helxfrm.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       helxfrm.c
 *  Content:    Direct3D front-end transform and process vertices
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "fe.h"

void MatrixProduct2(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b);

//---------------------------------------------------------------------
void CheckWorldViewMatrix(LPD3DFE_PROCESSVERTICES pv)
{
    D3DMATRIXI *m = &pv->mWV[0];
    D3DMATRIXI res;
    res._11 = m->_11*m->_11 + m->_12*m->_12 + m->_13*m->_13;
    res._12 = m->_11*m->_21 + m->_12*m->_22 + m->_13*m->_23;
    res._13 = m->_11*m->_31 + m->_12*m->_32 + m->_13*m->_33;

    res._21 = m->_21*m->_11 + m->_22*m->_12 + m->_23*m->_13;
    res._22 = m->_21*m->_21 + m->_22*m->_22 + m->_23*m->_23;
    res._23 = m->_21*m->_31 + m->_22*m->_32 + m->_23*m->_33;

    res._31 = m->_31*m->_11 + m->_32*m->_12 + m->_33*m->_13;
    res._32 = m->_31*m->_21 + m->_32*m->_22 + m->_33*m->_23;
    res._33 = m->_31*m->_31 + m->_32*m->_32 + m->_33*m->_33;

    const D3DVALUE eps = 0.0001f;
    if (m->_14 == 0.0f && 
        m->_24 == 0.0f && 
        m->_34 == 0.0f && 
        m->_44 == 1.0f && 
        ABSF(res._12) < eps && 
        ABSF(res._13) < eps &&
        ABSF(res._21) < eps && 
        ABSF(res._23) < eps &&
        ABSF(res._31) < eps && 
        ABSF(res._32) < eps &&
        ABSF(1.0f - res._11) < eps && 
        ABSF(1.0f - res._22) < eps && 
        ABSF(1.0f - res._33) < eps)
    {
        pv->dwDeviceFlags |= D3DDEV_MODELSPACELIGHTING;
    }
    else
    {
        pv->dwDeviceFlags &= ~D3DDEV_MODELSPACELIGHTING;
    }
}
//---------------------------------------------------------------------
void setIdentity(D3DMATRIXI * m)
{
    m->_11 = D3DVAL(1.0); m->_12 = D3DVAL(0.0); m->_13 = D3DVAL(0.0); m->_14 = D3DVAL(0.0);
    m->_21 = D3DVAL(0.0); m->_22 = D3DVAL(1.0); m->_23 = D3DVAL(0.0); m->_24 = D3DVAL(0.0);
    m->_31 = D3DVAL(0.0); m->_32 = D3DVAL(0.0); m->_33 = D3DVAL(1.0); m->_34 = D3DVAL(0.0);
    m->_41 = D3DVAL(0.0); m->_42 = D3DVAL(0.0); m->_43 = D3DVAL(0.0); m->_44 = D3DVAL(1.0);
}
//---------------------------------------------------------------------
/*
 * Combine all matrices.
 */
const DWORD __VPC_DIRTY = D3DFE_VIEWMATRIX_DIRTY |
                          D3DFE_PROJMATRIX_DIRTY;

void updateTransform(LPD3DHAL lpDevI)
{
    D3DFE_PROCESSVERTICES* pv = lpDevI->m_pv;
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;
    if (lpDevI->dwFEFlags & D3DFE_PROJMATRIX_DIRTY)
    { 
      // We modify the projection matrix to make the clipping rules to be
      // 0 < x,y,z < w
        TRANSFORM.mPC._11 = (TRANSFORM.proj._11 + TRANSFORM.proj._14) * D3DVAL(0.5);
        TRANSFORM.mPC._12 = (TRANSFORM.proj._12 + TRANSFORM.proj._14) * D3DVAL(0.5);
        TRANSFORM.mPC._13 = TRANSFORM.proj._13;
        TRANSFORM.mPC._14 = TRANSFORM.proj._14;
        TRANSFORM.mPC._21 = (TRANSFORM.proj._21 + TRANSFORM.proj._24) * D3DVAL(0.5);
        TRANSFORM.mPC._22 = (TRANSFORM.proj._22 + TRANSFORM.proj._24) * D3DVAL(0.5);
        TRANSFORM.mPC._23 = TRANSFORM.proj._23;
        TRANSFORM.mPC._24 = TRANSFORM.proj._24;
        TRANSFORM.mPC._31 = (TRANSFORM.proj._31 + TRANSFORM.proj._34) * D3DVAL(0.5);
        TRANSFORM.mPC._32 = (TRANSFORM.proj._32 + TRANSFORM.proj._34) * D3DVAL(0.5);
        TRANSFORM.mPC._33 = TRANSFORM.proj._33;
        TRANSFORM.mPC._34 = TRANSFORM.proj._34;
        TRANSFORM.mPC._41 = (TRANSFORM.proj._41 + TRANSFORM.proj._44) * D3DVAL(0.5);
        TRANSFORM.mPC._42 = (TRANSFORM.proj._42 + TRANSFORM.proj._44) * D3DVAL(0.5);
        TRANSFORM.mPC._43 = TRANSFORM.proj._43;
        TRANSFORM.mPC._44 = TRANSFORM.proj._44;
    }
    if (lpDevI->dwFEFlags & (D3DFE_VIEWMATRIX_DIRTY |
                             D3DFE_PROJMATRIX_DIRTY))
    { // Update Mview*Mproj*Mclip
        MatrixProduct(&pv->mVPC, &pv->view, &TRANSFORM.mPC);
        lpDevI->dwFEFlags |= D3DFE_CLIPMATRIX_DIRTY | D3DFE_CLIPPLANES_DIRTY;
    }

    MatrixProduct(&pv->mCTM[0], &pv->world[0], &pv->mVPC);

    // Set dirty bit for world*view matrix (needed for fog and lighting)
    if (lpDevI->dwFEFlags & (D3DFE_VIEWMATRIX_DIRTY |
                             D3DFE_WORLDMATRIX_DIRTY))
    {
        lpDevI->dwFEFlags |= D3DFE_WORLDVIEWMATRIX_DIRTY | 
                             D3DFE_INVWORLDVIEWMATRIX_DIRTY |
                             D3DFE_NEEDCHECKWORLDVIEWVMATRIX;
    }

    // All matrices are set up
    lpDevI->dwFEFlags &= ~D3DFE_TRANSFORM_DIRTY;

    // Set dirty bit for lighting
    lpDevI->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS |
                         D3DFE_FRUSTUMPLANES_DIRTY;

    pv->dwDeviceFlags |= D3DDEV_TRANSFORMDIRTY;
    
    // Set this to not to re-compute the matrices
    pv->WVCount[0] = pv->MatrixStateCount;
    pv->CTMCount[0] = pv->MatrixStateCount;
}
//----------------------------------------------------------------------------
#ifdef DEBUG_PIPELINE

extern DWORD g_DebugFlags;

#endif
//-----------------------------------------------------------------------------
// DoUpdateState should be called for every DrawPrimitive call in the slow path,
// because it sets some internal pipeline flags. These flags are persistent for the
// fast path
//
void DoUpdateState(LPD3DHAL lpDevI)
{
    D3DFE_PROCESSVERTICES* pv = lpDevI->m_pv;
    pv->dwFlags = 0;
    
    if (lpDevI->m_pv->dwDeviceFlags & D3DDEV_VERTEXSHADERS)
    {
        // For vertex shaders we need update clip planes only 
        if (lpDevI->dwFEFlags & D3DFE_CLIPPLANES_DIRTY)
        {
            DWORD dwMaxUserClipPlanes = 0;
            DWORD dwPlanes = lpDevI->rstates[D3DRENDERSTATE_CLIPPLANEENABLE];
            for (DWORD i=0; i < __MAXUSERCLIPPLANES; i++)
            {
                if (dwPlanes & (1 << i))
                {
                    // Clipping planes are transformed by inverse transposed
                    // view-projection-clip matrix
                    // For vertex shaders view-projection matrix is identity.
                    // Inverse transposed clip matrix is 
                    //      2 0 0 -1
                    //      0 2 0 -1
                    //      0 0 1  0
                    //      0 0 0  1
                    //
                    float* pOut = (float*)&pv->userClipPlane[dwMaxUserClipPlanes];
                    float* pIn = (float*)&lpDevI->transform.userClipPlane[i];
                    pOut[0] = pIn[0]*2;
                    pOut[1] = pIn[1]*2;
                    pOut[2] = pIn[2];
                    pOut[3] = pIn[3] - pIn[0] - pIn[1];
                    dwMaxUserClipPlanes++;
                }
            }
            pv->dwMaxUserClipPlanes = dwMaxUserClipPlanes;
            lpDevI->dwFEFlags &= ~D3DFE_CLIPPLANES_DIRTY;
        }
        // For PSGP we need to set DONOTCOPY bits
        if (!(pv->dwVIDOut & D3DFVF_DIFFUSE))
            pv->dwFlags |= D3DPV_DONOTCOPYDIFFUSE;
        if (!(pv->dwVIDOut & D3DFVF_SPECULAR))
            pv->dwFlags |= D3DPV_DONOTCOPYSPECULAR;
        return;
    }

    UpdateFlagsForOutputFVF(pv);

    // only set up lights if something has changed
    if (lpDevI->dwFEFlags & D3DFE_LIGHTS_DIRTY) 
    {
        lpDevI->m_dwRuntimeFlags &= ~(D3DRT_DIRECTIONALIGHTPRESENT | 
                                      D3DRT_POINTLIGHTPRESENT);
        LPDIRECT3DLIGHTI    lpD3DLightI;
        lpD3DLightI = (LPDIRECT3DLIGHTI)LIST_FIRST(&lpDevI->m_ActiveLights);
        pv->lighting.activeLights = NULL;

        // Set lights in the device
        while (lpD3DLightI)
        {
            if (lpD3DLightI->m_Light.Type == D3DLIGHT_DIRECTIONAL)
                lpDevI->m_dwRuntimeFlags |= D3DRT_DIRECTIONALIGHTPRESENT;
            else
                lpDevI->m_dwRuntimeFlags |= D3DRT_POINTLIGHTPRESENT;

            if (lpD3DLightI->m_LightI.flags & D3DLIGHTI_DIRTY)
                lpD3DLightI->SetInternalData();
            lpD3DLightI->m_LightI.next = pv->lighting.activeLights;
            pv->lighting.activeLights = &lpD3DLightI->m_LightI;
            lpD3DLightI = (LPDIRECT3DLIGHTI)LIST_NEXT(lpD3DLightI, m_List);
        }
    }

// Process vertex blending and tweening settings

    if (lpDevI->dwFEFlags & D3DFE_VERTEXBLEND_DIRTY)
    {
        pv->dwNumVerBlends = lpDevI->rstates[D3DRS_VERTEXBLEND];
        pv->dwNumWeights = 0;
        if (pv->dwNumVerBlends && (pv->dwNumVerBlends != D3DVBF_TWEENING))
        {
            if (pv->dwNumVerBlends == D3DVBF_0WEIGHTS)
                pv->dwNumVerBlends = 1;
            else
                pv->dwNumVerBlends++;
            // Compute number of floats in a vertex
            int nFloats = ((pv->dwVIDIn & D3DFVF_POSITION_MASK) >> 1) - 2;
            // Compute number of needed floats 
            int nFloatsNeeded;
            if (pv->dwDeviceFlags & D3DDEV_INDEXEDVERTEXBLENDENABLE)
            {
#if DBG
                if (D3DVSD_ISLEGACY(lpDevI->m_dwCurrentShaderHandle) &&
                    ((pv->dwVIDIn & D3DFVF_LASTBETA_UBYTE4) == 0))
                {
                    D3D_THROW_FAIL("D3DFVF_LASTBETA_UBYTE4 must be set for index vertex blending");
                }
#endif // DBG
                nFloatsNeeded = pv->dwNumVerBlends;
            }
            else
            {
                nFloatsNeeded = pv->dwNumVerBlends - 1;
            }
            if (nFloats < nFloatsNeeded)
            {
                D3D_THROW_FAIL("Vertex does not have enough data for vertex blending");
            }
            pv->dwNumWeights = pv->dwNumVerBlends - 1; 
            // Lighting is done in the camera space when there is vertex blending
            if (pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)
            {
                pv->dwDeviceFlags &= ~(D3DDEV_MODELSPACELIGHTING | D3DFE_NEEDCHECKWORLDVIEWVMATRIX);
                // We have to transform lights to the camera space
                lpDevI->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS;
            }
        }
        else
        {
            // Vertex blending is disabled, so we may be able to do lighting 
            // in model space. We need to to re-check matrices
            if (!(pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                lpDevI->dwFEFlags |= D3DFE_NEEDCHECKWORLDVIEWVMATRIX;
        }
        lpDevI->dwFEFlags &= ~D3DFE_VERTEXBLEND_DIRTY;
    }

    if (lpDevI->rstates[D3DRS_VERTEXBLEND] == D3DVBF_TWEENING)
    {
        if (pv->position2.lpvData)
            pv->dwFlags |= D3DPV_POSITION_TWEENING;
        if (pv->normal2.lpvData)
            pv->dwFlags |= D3DPV_NORMAL_TWEENING;
        pv->dwNumVerBlends = 0;     // Disable vertex blending when tweening
#if DBG
        if (!(pv->dwFlags & (D3DPV_POSITION_TWEENING | D3DPV_NORMAL_TWEENING)))
        {
            D3D_THROW_FAIL("Position2 or Normal2 must be set when tweening is enabled");
        }
#endif
    }

#if DBG
    if (!(pv->dwDeviceFlags & D3DDEV_INDEXEDVERTEXBLENDENABLE))
    {
        if (D3DVSD_ISLEGACY(lpDevI->m_dwCurrentShaderHandle) &&
            ((pv->dwVIDIn & D3DFVF_LASTBETA_UBYTE4) != 0))
        {
            D3D_THROW_FAIL("D3DFVF_LASTBETA_UBYTE4 must be set only when index vertex blending is used");
        }
    }
#endif // DBG

    if (lpDevI->dwFEFlags & D3DFE_TRANSFORM_DIRTY)
    {
        updateTransform(lpDevI);
    }
    // We need World-View matrix for lighting, fog, point sprites and when 
    // texture coordinates are taken from the vertex data in the camera space
    if (lpDevI->dwFEFlags & D3DFE_WORLDVIEWMATRIX_DIRTY &&
        (pv->dwDeviceFlags & (D3DDEV_LIGHTING | D3DDEV_FOG) ||
        lpDevI->rstates[D3DRS_POINTSCALEENABLE] ||
        pv->dwDeviceFlags & (D3DDEV_NORMALINCAMERASPACE | D3DDEV_POSITIONINCAMERASPACE)))
    {
        MatrixProduct(&pv->mWV[0], &pv->world[0],
                                    &pv->view);
        lpDevI->dwFEFlags &= ~D3DFE_WORLDVIEWMATRIX_DIRTY;
    }
// Detect where to do lighting: in model or eye space 
    if (lpDevI->dwFEFlags & D3DFE_NEEDCHECKWORLDVIEWVMATRIX &&
        pv->dwDeviceFlags & D3DDEV_LIGHTING)
    {
        // We try to do lighting in the model space if
        // 1. we do not have to normalize normals 
        // 2. we do not need to do vertex blending
        pv->dwDeviceFlags &= ~D3DDEV_MODELSPACELIGHTING;
        if (pv->dwNumVerBlends == 0 &&
            !(pv->dwDeviceFlags & D3DDEV_NORMALIZENORMALS))
        {
#ifdef DEBUG_PIPELINE
            if (!(g_DebugFlags & __DEBUG_MODELSPACE))
#endif
            {
                CheckWorldViewMatrix(pv);
                lpDevI->dwFEFlags &= ~D3DFE_NEEDCHECKWORLDVIEWVMATRIX;
            }
        }
        // If D3DDEV_MODELSPACELIGHTING has been changed we need to re-transform lights
        lpDevI->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS;
    }
    
    // Updating inverse World-View matrix.
    // It is needed when we do lighting in the model space or we need normals
    // in the camera space
    if (lpDevI->dwFEFlags & D3DFE_INVWORLDVIEWMATRIX_DIRTY &&
        ((pv->dwDeviceFlags & D3DDEV_LIGHTING && 
          !(pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)) || 
         pv->dwDeviceFlags & D3DDEV_NORMALINCAMERASPACE))
    {
        Inverse4x4((D3DMATRIX*)&pv->mWV[0], (D3DMATRIX*)&pv->mWVI);
        lpDevI->dwFEFlags &= ~D3DFE_INVWORLDVIEWMATRIX_DIRTY;
        pv->WVICount[0] = pv->MatrixStateCount;
    }

    // Update clipping planes if there are any
    if (lpDevI->dwFEFlags & D3DFE_CLIPPLANES_DIRTY)
    {
        if (lpDevI->dwFEFlags & D3DFE_CLIPMATRIX_DIRTY)
        {
            // View and projection matrix are inversed separately, because it 
            // is possible that combined matrix cannot be inverted. This could happend
            // when the view matrix has huge _43 value (> 10^7). Floating point precision
            // is not enough in this case
            D3DMATRIXI mPCInverse;
            if (Inverse4x4((D3DMATRIX*)&lpDevI->transform.mPC, (D3DMATRIX*)&mPCInverse))
            {
                D3D_ERR("Cannot invert projection matrix");
                setIdentity((D3DMATRIXI*)&mPCInverse);
            }
            D3DMATRIXI mViewInverse;
            if (Inverse4x4((D3DMATRIX*)&pv->view, (D3DMATRIX*)&mViewInverse))
            {
                D3D_ERR("Cannot invert view matrix");
                setIdentity((D3DMATRIXI*)&mViewInverse);
            }
            MatrixProduct(&lpDevI->transform.mVPCI, &mPCInverse, &mViewInverse);
            lpDevI->dwFEFlags &= ~D3DFE_CLIPMATRIX_DIRTY;
        }
        DWORD dwMaxUserClipPlanes = 0;
        DWORD dwPlanes = lpDevI->rstates[D3DRENDERSTATE_CLIPPLANEENABLE];
        for (DWORD i=0; i < __MAXUSERCLIPPLANES; i++)
        {
            if (dwPlanes & (1 << i))
            {
                // Clipping planes are transformed by inverse transposed
                // view-projection-clip matrix
                VecMatMul4HT(&lpDevI->transform.userClipPlane[i], 
                             (D3DMATRIX*)&lpDevI->transform.mVPCI, 
                             &pv->userClipPlane[dwMaxUserClipPlanes]);
                dwMaxUserClipPlanes++;
            }
        }
        pv->dwMaxUserClipPlanes = dwMaxUserClipPlanes;
        lpDevI->dwFEFlags &= ~D3DFE_CLIPPLANES_DIRTY;
    }

    if (lpDevI->dwFEFlags & (D3DFE_NEED_TRANSFORM_LIGHTS |
                             D3DFE_LIGHTS_DIRTY |
                             D3DFE_MATERIAL_DIRTY))
    {
        D3DFE_UpdateLights(lpDevI);
        // Set a flag for PSGP
        pv->dwDeviceFlags |= D3DDEV_LIGHTSDIRTY;
    }

    // In case if COLORVERTEX is TRUE, the vertexAlpha could be overriden 
    // by vertex alpha
    pv->lighting.alpha = (DWORD)pv->lighting.materialAlpha;
    pv->lighting.alphaSpecular = (DWORD)pv->lighting.materialAlphaS;

    // This is a hint that only the inPosition pointer needs to be updated
    // for speed reasons.
    if (((pv->dwVIDIn & ( D3DFVF_DIFFUSE | D3DFVF_SPECULAR | D3DFVF_NORMAL)) == 0) && 
        (pv->nTexCoord == 0))
        pv->dwFlags |= D3DPV_TRANSFORMONLY;

    if (pv->nOutTexCoord == 0)
        pv->dwFlags |= D3DPV_DONOTCOPYTEXTURE;

    lpDevI->dwFEFlags &= ~D3DFE_FRONTEND_DIRTY;

    // Decide whether we always need position and normal in the camera space

    if (!(pv->dwFlags2 & __FLAGS2_TEXGEN))
    {
        // When texture generation is disabled we can recompute NORMAL and 
        // POSITION flags
        pv->dwDeviceFlags &= ~(D3DDEV_NORMALINCAMERASPACE |
                               D3DDEV_POSITIONINCAMERASPACE);
    }
    if ((pv->dwDeviceFlags & (D3DDEV_LIGHTING | D3DDEV_MODELSPACELIGHTING)) == D3DDEV_LIGHTING)
    {
        // We do lighting in camera space
        if (lpDevI->m_dwRuntimeFlags & D3DRT_DIRECTIONALIGHTPRESENT &&
            lpDevI->m_pv->dwVIDIn & D3DFVF_NORMAL)
            pv->dwDeviceFlags |= D3DDEV_NORMALINCAMERASPACE;

        if (lpDevI->m_dwRuntimeFlags & D3DRT_POINTLIGHTPRESENT)
            pv->dwDeviceFlags |= D3DDEV_POSITIONINCAMERASPACE;
    }
    if (pv->dwFlags & D3DPV_FOG)
    {
        pv->dwDeviceFlags |= D3DDEV_POSITIONINCAMERASPACE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\drawprim.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drawprim.hpp
 *  Content:    DrawPrimitive common defines
 *
 ***************************************************************************/

#ifndef _DRAWPRIM_H_
#define _DRAWPRIM_H_

#define MAX_DX6_VERTICES    ((1<<16) - 1)
#ifdef WIN95
#define LOWVERTICESNUMBER 128
#else
#define LOWVERTICESNUMBER 96
#endif
#define D3D_MAX_TLVBUF_CHANGES 5

// All vertices from lpDevI->lpVout are copied to the output buffer, expanding
// to D3DTLVERTEX.
// The output buffer is lpAddress if it is not NULL, otherwise it is TLVbuf
//
//---------------------------------------------------------------------
#define FVF_TRANSFORMED(dwFVF) ((dwFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
#define FVF_TEXCOORD_NUMBER(dwFVF) \
    (((dwFVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT)
//---------------------------------------------------------------------
// Computes size in bytes of the position component of a vertex
//
__inline DWORD GetPositionSizeFVF(DWORD fvf)
{
    DWORD size = 3 << 2;
    switch (fvf & D3DFVF_POSITION_MASK)
    {
    case D3DFVF_XYZRHW: size += 4;      break;
    case D3DFVF_XYZB1:  size += 1*4;    break;
    case D3DFVF_XYZB2:  size += 2*4;    break;
    case D3DFVF_XYZB3:  size += 3*4;    break;
    case D3DFVF_XYZB4:  size += 4*4;    break;
    case D3DFVF_XYZB5:  size += 5*4;    break;
    }
    return size;
}
//---------------------------------------------------------------------
// Computes vertex size in bytes for a the vertex ID excluding size of
// texture oordinates
//
__inline DWORD GetVertexSizeFVF(DWORD fvf)
{
    DWORD size = GetPositionSizeFVF(fvf);
    if (fvf & D3DFVF_NORMAL)
        size += 3*4;
    if (fvf & D3DFVF_PSIZE)
        size += 4;

    if (fvf & D3DFVF_DIFFUSE)
        size+= 4;
    if (fvf & D3DFVF_SPECULAR)
        size += 4;

    if (fvf & D3DFVF_FOG)
        size += 4;

    return size;
}
//---------------------------------------------------------------------
// Entry is texture count. Clears all texture format bits in the FVF DWORD,
// that correspond to the texture count
// for this count
const DWORD g_TextureFormatMask[9] = {
    ~0x0000FFFF,
    ~0x0003FFFF,
    ~0x000FFFFF,
    ~0x003FFFFF,
    ~0x00FFFFFF,
    ~0x03FFFFFF,
    ~0x0FFFFFFF,
    ~0x3FFFFFFF,
    ~0xFFFFFFFF
};
//---------------------------------------------------------------------
// Computes vertex size in bytes from the vertex ID
//
// Texture formats size        00   01   10   11
const BYTE g_TextureSize[4] = {2*4, 3*4, 4*4, 4};

//---------------------------------------------------------------------
// Index is number of floats in a texture coordinate set.
// Value is texture format bits
//
const DWORD g_dwTextureFormat[5] = {0, 3, 0, 1, 2};

//---------------------------------------------------------------------
// Returns total size of texture coordinates
// Computes dwTextureCoordSize[] array - size of every texture coordinate set
//
inline DWORD ComputeTextureCoordSize(DWORD dwFVF, DWORD *dwTextureCoordSize)
{
    DWORD dwNumTexCoord = FVF_TEXCOORD_NUMBER(dwFVF);
    DWORD dwTextureCoordSizeTotal;

    // Compute texture coordinate size
    DWORD dwTextureFormats = dwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        dwTextureCoordSizeTotal = (BYTE)dwNumTexCoord * 2 * 4;
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            dwTextureCoordSize[i] = 4*2;
        }
    }
    else
    {
        DWORD dwOffset = 0;
        dwTextureCoordSizeTotal = 0;
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            BYTE dwSize = g_TextureSize[dwTextureFormats & 3];
            dwTextureCoordSize[i] = dwSize;
            dwTextureCoordSizeTotal += dwSize;
            dwTextureFormats >>= 2;
        }
    }
    return dwTextureCoordSizeTotal;
}
//---------------------------------------------------------------------
// Computes vertex in bytes for the given FVF
//
inline DWORD ComputeVertexSizeFVF(DWORD dwFVF)
{
    DWORD dwTextureFormats = dwFVF >> 16;
    DWORD dwNumTexCoord = FVF_TEXCOORD_NUMBER(dwFVF);
    DWORD size = GetVertexSizeFVF(dwFVF);
    if (dwTextureFormats == 0)
    {
        size += (BYTE)dwNumTexCoord * 2 * 4;
    }
    else
    {
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            size += g_TextureSize[dwTextureFormats & 3];
            dwTextureFormats >>= 2;
        }
    }
    return size;
}
//---------------------------------------------------------------------
// Computes the number of primtives and also updates the stats accordingly
// Input:  lpDevI->primType
//         dwNumVertices
// Output: lpDevI->dwNumPrimitives
//         return value = dwNumPrimitives
#undef DPF_MODNAME
#define DPF_MODNAME "GetNumPrim"

inline __declspec(nothrow) void GetNumPrim(LPD3DHAL lpDevI, DWORD dwNumVertices)
{
    D3DFE_PROCESSVERTICES* pv = lpDevI->m_pv;
    pv->dwNumPrimitives = 0;
    switch (pv->primType)
    {
    case D3DPT_POINTLIST:
        pv->dwNumPrimitives = dwNumVertices;
        break;
    case D3DPT_LINELIST:
        pv->dwNumPrimitives = dwNumVertices >> 1;
        break;
    case D3DPT_LINESTRIP:
        if (dwNumVertices < 2)
            return;
        pv->dwNumPrimitives = dwNumVertices - 1;
        break;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (dwNumVertices < 3)
            return;
        pv->dwNumPrimitives = dwNumVertices - 2;
        break;
    case D3DPT_TRIANGLELIST:
#ifdef _X86_
        {
            DWORD tmp;
            __asm
            {
                mov  eax, 0x55555555    // fractional part of 1.0/3.0
                mul  dwNumVertices
                add  eax, 0x80000000    // Rounding
                adc  edx, 0
                mov  tmp, edx
            }
            pv->dwNumPrimitives = tmp;
        }
#else
        pv->dwNumPrimitives = dwNumVertices / 3;
#endif
        break;
    }
}
//---------------------------------------------------------------------
// Sets front-end flags every time fog state is changed
//
inline void CD3DHal::SetFogFlags(void)
{
    // Call ForceFVFRecompute only if fog enable state has been changed
    BOOL bFogWasEnabled = m_pv->dwDeviceFlags & D3DDEV_FOG;
    if (m_pv->lighting.fog_mode != D3DFOG_NONE &&
        this->rstates[D3DRENDERSTATE_FOGENABLE])
    {
        m_pv->dwDeviceFlags |= D3DDEV_FOG;
        if (!bFogWasEnabled)
            ForceFVFRecompute();
    }
    else
    {
        m_pv->dwDeviceFlags &= ~D3DDEV_FOG;
        if (bFogWasEnabled)
            ForceFVFRecompute();
    }
}
//-----------------------------------------------------------------------------
// Computes dwFlags bits which depend on the output FVF
//
inline void UpdateFlagsForOutputFVF(D3DFE_PROCESSVERTICES* lpDevI)
{
    if (lpDevI->dwDeviceFlags & D3DDEV_LIGHTING &&
        lpDevI->dwVIDOut & (D3DFVF_DIFFUSE | D3DFVF_SPECULAR))
    {
        lpDevI->dwFlags |= D3DPV_LIGHTING;
    }
    if (lpDevI->dwDeviceFlags & D3DDEV_FOG && lpDevI->dwVIDOut & D3DFVF_SPECULAR)
    {
        lpDevI->dwFlags |= D3DPV_FOG;
    }
    if (!(lpDevI->dwVIDOut & D3DFVF_DIFFUSE))
        lpDevI->dwFlags |= D3DPV_DONOTCOPYDIFFUSE;
    if (!(lpDevI->dwVIDOut & D3DFVF_SPECULAR))
        lpDevI->dwFlags |= D3DPV_DONOTCOPYSPECULAR;
}

//---------------------------------------------------------------------
// Restore indices in the texture stages which were re-mapped for texture
// transforms
// We have to do restore if
//  - Set or Get render state is issued with _WRAP parameter
//  - Set or Get texture stage is issued with TEXCOORDINDEX as a parameter
//
extern void RestoreTextureStages(LPD3DHAL pDevI);
//---------------------------------------------------------------------
// the function works when there are texture transforms.
// It computes number of output texture coordinates, texture coordinate size and format.
// It prepares texture stages to re-map texture coordinates
//
void EvalTextureTransforms(LPD3DHAL pDevI, DWORD dwTexTransform,
                           DWORD *pdwOutTextureSize, DWORD *pdwOutTextureFormat);
//----------------------------------------------------------------------
// Sets texture transform pointer for every input texture coordinate set
//
void SetupTextureTransforms(LPD3DHAL pDevI);
//----------------------------------------------------------------------
inline BOOL TextureTransformEnabled(LPD3DHAL pDevI)
{
    return __TEXTURETRANSFORMENABLED(pDevI->m_pv);
}
//-----------------------------------------------------------------------------
// Having primitive type as index, this array returns two coefficients("a" and
// "b") to compute number of vertices as NumPrimitives*a + b
//
extern DWORD g_PrimToVerCount[7][2];
//-----------------------------------------------------------------------------
inline UINT GETVERTEXCOUNT(D3DPRIMITIVETYPE primType, UINT dwNumPrimitives)
{
    return g_PrimToVerCount[primType][0] * dwNumPrimitives +
           g_PrimToVerCount[primType][1];
}
extern void setIdentity(D3DMATRIXI * m);
extern void MatrixProduct(D3DMATRIXI *d, D3DMATRIXI *a, D3DMATRIXI *b);
extern LIGHT_VERTEX_FUNC_TABLE lightVertexTable;
extern void MatrixProduct(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b);
void D3DFE_UpdateLights(LPD3DHAL lpDevI);
//---------------------------------------------------------------------
// Updates lighting and computes process vertices flags
//
extern void DoUpdateState(LPD3DHAL lpDevI);
//----------------------------------------------------------------------
inline void UpdateClipStatus(CD3DHal* pDev)
{
    pDev->m_ClipStatus.ClipUnion |= pDev->m_pv->dwClipUnion;
    pDev->m_ClipStatus.ClipIntersection &= pDev->m_pv->dwClipIntersection;
}
//----------------------------------------------------------------------
// This is a list of all rstates that which are for the vertex processing only.
// In the software vertex processing mode these render states are not passed
// to the driver. The are passed when we switch to the hardware vertex processing mode
//
const D3DRENDERSTATETYPE rsVertexProcessingList[] = {
    D3DRS_RANGEFOGENABLE,
    D3DRS_LIGHTING,
    D3DRS_AMBIENT,
    D3DRS_FOGVERTEXMODE,
    D3DRS_COLORVERTEX,
    D3DRS_LOCALVIEWER,
    D3DRS_NORMALIZENORMALS,
    D3DRS_DIFFUSEMATERIALSOURCE,
    D3DRS_SPECULARMATERIALSOURCE,
    D3DRS_AMBIENTMATERIALSOURCE,
    D3DRS_EMISSIVEMATERIALSOURCE,
    D3DRS_VERTEXBLEND,
    D3DRS_CLIPPLANEENABLE,
    D3DRS_SOFTWAREVERTEXPROCESSING,
    D3DRS_POINTSCALEENABLE,
    D3DRS_POINTSCALE_A,
    D3DRS_POINTSCALE_B,
    D3DRS_POINTSCALE_C,
    D3DRS_INDEXEDVERTEXBLENDENABLE,
    D3DRS_TWEENFACTOR
};

#endif _DRAWPRIM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\drawprim.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphal.c
 *  Content:    DrawPrimitive implementation for DrawPrimitive HALs
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "drawprim.hpp"
#include "clipfunc.h"

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::ProcessVertices"

HRESULT D3DAPI
CD3DHal::ProcessVertices(UINT SrcStartIndex, UINT DestIndex, UINT VertexCount,
                         IDirect3DVertexBuffer8 *DestBuffer,
                         DWORD dwFlags)
{
    API_ENTER(this); // Takes D3D Lock if necessary
    HRESULT hr = D3D_OK;
    CVertexBuffer* pVB = static_cast<CVertexBuffer*>(DestBuffer);
    const D3DBUFFER_DESC* pDesc = pVB->GetBufferDesc();
    UINT vbVertexSize = pVB->GetVertexSize();
    UINT vbNumVertices = pVB->GetNumVertices();
#if DBG
    if (pVB->Device() != this)
    {
        D3D_ERR("VertexBuffer not created with this device. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    if (m_dwCurrentShaderHandle == 0)
    {
        D3D_ERR("Current vertex shader is not set. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    if (D3DVSD_ISLEGACY(m_dwCurrentShaderHandle) &&
        FVF_TRANSFORMED(m_dwCurrentShaderHandle))
    {
        D3D_ERR("Invalid vertex shader for ProcessVertices. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    if (!(m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING))
    {
        D3D_ERR("D3D Device should be in software mode for ProcessVertices. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    if (dwFlags & ~D3DPV_DONOTCOPYDATA)
    {
        D3D_ERR( "Invalid dwFlags set. ProcessVertices failed." );
        return D3DERR_INVALIDCALL;
    }

    if (pDesc->Usage & D3DUSAGE_DONOTCLIP &&
        !(m_pv->dwDeviceFlags & D3DDEV_DONOTCLIP))
    {
        D3D_ERR("Vertex buffer has D3D_DONOTCLIP usage, but clipping is enabled. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    if (pVB->GetFVF() == 0)
    {
        D3D_ERR("Destination buffer has no FVF associated with it. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((pVB->GetFVF() & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW)
    {
        D3D_ERR("Destination vertex buffer should have D3DFVF_XYZRHW position. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    if (VertexCount + DestIndex > vbNumVertices)
    {
        D3D_ERR("Destination vertex buffer has not enough space. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        DWORD vbFVF = pVB->GetFVF();
        m_pv->dwNumVertices = VertexCount;
        m_pv->dwFlags = D3DPV_VBCALL;
#if DBG
        ValidateDraw2(D3DPT_TRIANGLELIST, SrcStartIndex, 1, VertexCount, FALSE);
#endif
        // Internal flags and output vertex offsets could be different for
        // ProcessVertices
        ForceFVFRecompute();

        (this->*m_pfnPrepareToDraw)(SrcStartIndex);

        if (!(m_pv->dwDeviceFlags & D3DDEV_DONOTCLIP))
        {
            if (pVB->GetClipCodes() == NULL)
            {
                pVB->AllocateClipCodes();
            }
            m_pv->lpClipFlags = pVB->GetClipCodes();
#if DBG
            if (m_pv->lpClipFlags == NULL)
            {
                D3D_THROW_FAIL("Failed to allocate clip code for the dest VB");
            }
#endif
            m_pv->lpClipFlags += DestIndex;
        }

        // Check number of texture coordinates and texture formats in the
        // destination VB are the same as in the computed FVF
        DWORD dwComputedTexFormats = m_pv->dwVIDOut & 0xFFFF0000;
        DWORD dwNumTexCoordVB = FVF_TEXCOORD_NUMBER(vbFVF);
        if (m_pv->nOutTexCoord > dwNumTexCoordVB ||
            ((vbFVF & dwComputedTexFormats) != dwComputedTexFormats))
        {
            D3D_ERR("Number of output texture coordinates and their format should be");
            D3D_ERR("the same in the destination vertex buffer and as computed for current D3D settings.");
            D3D_ERR("Computed output FVF is 0x%08X", m_pv->dwVIDOut);
            D3D_THROW_FAIL("");
        }
        // Check if the computed output FVF is a subset of the VB's FVF.
        // Number of texture coordinates should be cleared.
        DWORD dwComputedFVF = m_pv->dwVIDOut & 0x000000FF;
        // Specularand diffuse colors could be omitted, as well as psize
        dwComputedFVF &= ~(D3DFVF_PSIZE | D3DFVF_DIFFUSE | D3DFVF_SPECULAR | D3DFVF_FOG);
        if((dwComputedFVF & vbFVF) != dwComputedFVF)
        {
            D3D_ERR("Dest vertex buffer's FVF should be a superset of the FVF, computed for");
            D3D_ERR("the current D3D settings");
            D3D_ERR("Computed output FVF is 0x%08X", m_pv->dwVIDOut);
            D3D_THROW_FAIL("");
        }

        BYTE* p;
        hr = pVB->Lock(0, pDesc->Size, &p, D3DLOCK_NOSYSLOCK);
        if (FAILED(hr))
        {
            D3D_THROW_FAIL("Cannot lock destination buffer");
        }

        if (this->dwFEFlags & D3DFE_FRONTEND_DIRTY)
            DoUpdateState(this);

        // Replace output FVF and vertex size
        m_pv->dwOutputSize = vbVertexSize;
        m_pv->dwVIDOut = vbFVF;
        m_pv->lpvOut = p + DestIndex * vbVertexSize;

        // Vertex shaders don't write to the output unless shader writes to it
        // explicitely. So we do not bother setting any flags
        if (dwFlags & D3DPV_DONOTCOPYDATA)
        {
            if (m_pv->dwDeviceFlags & D3DDEV_VERTEXSHADERS)
            {
                m_pv->dwFlags |= D3DPV_DONOTCOPYDIFFUSE |
                                 D3DPV_DONOTCOPYSPECULAR |
                                 D3DPV_DONOTCOPYTEXTURE;
            }
            else
            {
                m_pv->dwFlags |= D3DPV_DONOTCOPYDIFFUSE |
                                 D3DPV_DONOTCOPYSPECULAR |
                                 D3DPV_DONOTCOPYTEXTURE;
                // If D3DIM generates colors or texture, we should clear
                // DONOTCOPY bits
                if (m_pv->dwFlags & D3DPV_LIGHTING)
                {
                    m_pv->dwFlags &= ~D3DPV_DONOTCOPYDIFFUSE;
                    if (m_pv->dwDeviceFlags & D3DDEV_SPECULARENABLE)
                        m_pv->dwFlags &= ~D3DPV_DONOTCOPYSPECULAR;
                }
                if (m_pv->dwFlags & D3DPV_FOG)
                    m_pv->dwFlags &= ~D3DPV_DONOTCOPYSPECULAR;
                // If front-end is asked to do something with texture
                // coordinates  we disable DONOTCOPYTEXTURE
                if (__TEXTURETRANSFORMENABLED(m_pv) ||
                    m_pv->dwFlags2 & __FLAGS2_TEXGEN)
                {
                    m_pv->dwFlags &= ~D3DPV_DONOTCOPYTEXTURE;
                }
            }
        }

        // Compute flags based on the vertex buffer FVF
        UpdateFlagsForOutputFVF(m_pv);

        // Update output vertex offsets for the new FVF
        ComputeOutputVertexOffsets(m_pv);

        m_pv->pGeometryFuncs->ProcessVertices(m_pv);

        if (!(m_pv->dwDeviceFlags & D3DDEV_DONOTCLIP))
            UpdateClipStatus(this);

        // When ProcessVertices is used, user must re-program texture
        // stage indices and wrap modes himself
        m_pv->dwDeviceFlags &= ~D3DDEV_REMAPTEXTUREINDICES;
    }
    catch(HRESULT ret)
    {
        D3D_ERR("ProcessVertices failed.");
        hr = ret;
    }
    ForceFVFRecompute();
    pVB->Unlock();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\hmgr.cpp ===
#include "pch.cpp"
#pragma hdrstop


CHandleFactory::CHandleFactory() : m_Handles()
{ 
    m_Free = __INVALIDHANDLE;
}

CHandleFactory::CHandleFactory(DWORD dwGrowSize) : m_Handles()
{
    m_Free = __INVALIDHANDLE;
    m_Handles.SetGrowSize(dwGrowSize);
}


DWORD 
CHandleFactory::CreateNewHandle( LPD3DBASEOBJ pObj )
{
    DWORD handle = m_Free;
    if (m_Free != __INVALIDHANDLE)
    {
        m_Free = m_Handles[m_Free].m_Next;
    }
    else
    {
        handle = m_Handles.GetSize();
        m_Free = handle + 1;
        if( FAILED(m_Handles.Grow( m_Free )) )
            return __INVALIDHANDLE;
        
        DWORD dwSize = m_Handles.GetSize();
        for( DWORD i = handle; i<dwSize; i++ )
        {
            m_Handles[i].m_Next = i+1;
        }
        m_Handles[dwSize-1].m_Next = __INVALIDHANDLE;
        
    }

#if DBG
    DDASSERT(m_Handles[handle].m_tag == 0);
    m_Handles[handle].m_tag = 1;
#endif
    DDASSERT(m_Handles[handle].m_pObj == NULL);
    m_Handles[handle].m_pObj = pObj;
    
    return handle;
}

LPD3DBASEOBJ 
CHandleFactory::GetObject( DWORD dwHandle ) const
{
    if( m_Handles.Check( dwHandle ) )
    {
        return m_Handles[dwHandle].m_pObj;
    }
    else
    {
        // The handle doesnt exist
        return NULL;
    }
}

BOOL
CHandleFactory::SetObject( DWORD dwHandle, LPD3DBASEOBJ pObject)
{
    if( m_Handles.Check( dwHandle ) )
    {
        m_Handles[dwHandle].m_pObj = pObject;
        return TRUE;
    }
    else
    {
        // The handle doesnt exist
        return FALSE;
    }
}

void 
CHandleFactory::ReleaseHandle(DWORD handle, BOOL bDeleteObject)
{
    DDASSERT(handle < m_Handles.GetSize());
#if DBG
    DDASSERT(m_Handles[handle].m_tag != 0);
    m_Handles[handle].m_tag = 0;
#endif

    if( m_Handles[handle].m_pObj)
    {
        if (bDeleteObject)
            delete m_Handles[handle].m_pObj;
        m_Handles[handle].m_pObj = NULL;
    }

    m_Handles[handle].m_Next = m_Free;
    m_Free = handle;
}

//////////////////////////////////////////////////////////////////////////////

DWORD 
CVShaderHandleFactory::CreateNewHandle( LPVSHADER pVShader )
{
    DWORD dwHandle = CHandleFactory::CreateNewHandle( (LPD3DBASEOBJ)pVShader );
    
    // Now munge the handle. The algorithm is to shift left by one and
    // set the LSB to 1.

    dwHandle <<= 1;
    return (dwHandle | 0x1);
}

LPD3DBASEOBJ
CVShaderHandleFactory::GetObject( DWORD dwHandle ) const
{
    DWORD dwIndex = dwHandle >> 1;
    return CHandleFactory::GetObject( dwIndex );
}

BOOL
CVShaderHandleFactory::SetObject( DWORD dwHandle, LPD3DBASEOBJ pObject)
{
    DWORD dwIndex = dwHandle >> 1;
    return CHandleFactory::SetObject( dwIndex, pObject );
}

void 
CVShaderHandleFactory::ReleaseHandle(DWORD dwHandle, BOOL bDeleteObject)
{
    DWORD dwIndex = dwHandle >> 1;
    CHandleFactory::ReleaseHandle( dwIndex, bDeleteObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\lighting.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        lighting.cpp
 *  Content:     Direct3D material/light management
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "ddibase.h"

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CheckLightParams"

void CheckLightParams(CONST D3DLIGHT8* lpData)
{
    if (lpData->Type != D3DLIGHT_POINT &&
        lpData->Type != D3DLIGHT_SPOT &&
        lpData->Type != D3DLIGHT_DIRECTIONAL)
    {
        D3D_ERR( "Invalid D3DLIGHT type" );
        throw D3DERR_INVALIDCALL;
    }

    if (lpData->Range < 0.0f || lpData->Range > D3DLIGHT_RANGE_MAX)
    {
        D3D_ERR( "Invalid D3DLIGHT range" );
        throw D3DERR_INVALIDCALL;
    }
    if (lpData->Type == D3DLIGHT_SPOT || lpData->Type == D3DLIGHT_DIRECTIONAL)
    {
        float   magnitude;
        magnitude = lpData->Direction.x * lpData->Direction.x +
            lpData->Direction.y * lpData->Direction.y +
            lpData->Direction.z * lpData->Direction.z;
        if (magnitude < 0.00001f)
        {
            D3D_ERR( "Invalid D3DLIGHT direction" );
            throw D3DERR_INVALIDCALL;
        }
        if (lpData->Type == D3DLIGHT_SPOT)
        {
            if (lpData->Phi < 0.0f)
            {
                D3D_ERR( "Invalid D3DLIGHT Phi angle, must be >= 0" );
                throw D3DERR_INVALIDCALL;
            }
            if (lpData->Phi > 3.1415927f)
            {
                D3D_ERR( "Invalid D3DLIGHT Phi angle, must be <= pi" );
                throw D3DERR_INVALIDCALL;
            }
            if (lpData->Theta < 0.0f)
            {
                D3D_ERR( "Invalid D3DLIGHT Theta angle, must be >= 0" );
                throw D3DERR_INVALIDCALL;
            }
            if (lpData->Theta > lpData->Phi)
            {
                D3D_ERR( "Invalid D3DLIGHT Theta angle, must be <= Phi" );
                throw D3DERR_INVALIDCALL;
            }
        }
    }
    if (lpData->Type != D3DLIGHT_DIRECTIONAL)
    {
        if (lpData->Attenuation0 < 0 ||
            lpData->Attenuation1 < 0 ||
            lpData->Attenuation2 < 0)
        {
            D3D_ERR( "Attenuation factor can not be negative" );
            throw D3DERR_INVALIDCALL;
        }
        if (lpData->Attenuation0 == 0 &&
            lpData->Attenuation1 == 0 &&
            lpData->Attenuation2 == 0)
        {
            D3D_ERR("All attenuation factors are 0 for non-directional light");
            throw D3DERR_INVALIDCALL;
        }
    }
    return;
}
//=====================================================================
//
//         CD3DHal interface
//
//=====================================================================
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetMaterialFast"

HRESULT D3DAPI
CD3DHal::SetMaterialFast(CONST D3DMATERIAL8* lpData)
{
#if DBG
    if (!VALID_PTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR("Invalid D3DMATERIAL pointer. SetMaterial failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    m_pv->lighting.material = *lpData;
    this->dwFEFlags |= D3DFE_MATERIAL_DIRTY | D3DFE_FRONTEND_DIRTY;
    if (!(m_dwRuntimeFlags & (D3DRT_EXECUTESTATEMODE | 
                              D3DRT_RSSOFTWAREPROCESSING)))
    {
        try
        {
            m_pDDI->SetMaterial(lpData);
        }
        catch(HRESULT ret)
        {
            D3D_ERR("SetMaterial failed.");
            return ret;
        }
    }
    return S_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetMaterial"

HRESULT D3DAPI CD3DHal::GetMaterial(D3DMATERIAL8* lpData)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_WRITEPTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR( "Invalid D3DMATERIAL pointer. GetMaterial failed." );
        return D3DERR_INVALIDCALL;
    }

    *lpData = m_pv->lighting.material;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetLightI"

void CD3DHal::SetLightI(DWORD dwLightIndex, CONST D3DLIGHT8* lpData)
{
    if( m_pLightArray->Check( dwLightIndex ) == FALSE )
    {

        if( FAILED( m_pLightArray->Grow( dwLightIndex ) ) )
        {
            D3D_ERR("Not enough memory to grow light array");
            throw E_OUTOFMEMORY;
        }
    
        LIST_INITIALIZE(&m_ActiveLights);       // Clear active light list
        for (DWORD i = 0; i < m_pLightArray->GetSize(); i++)
        {
            if ((*m_pLightArray)[i].m_pObj)
            {
                DIRECT3DLIGHTI* pLight =
                    static_cast<DIRECT3DLIGHTI *>((*m_pLightArray)[i].m_pObj);
                if (pLight->Enabled())
                {
                    LIST_INSERT_ROOT(&m_ActiveLights, pLight, m_List);
                }
            }
        }
    }

    if( (*m_pLightArray)[dwLightIndex].m_pObj == NULL )
    {
        // Create light has been already sent to the driver 

        (*m_pLightArray)[dwLightIndex].m_pObj = 
            (CD3DBaseObj *)new DIRECT3DLIGHTI;
        if( (*m_pLightArray)[dwLightIndex].m_pObj == NULL )
        {
            D3D_ERR("Not enough memory to grow light array");
            throw E_OUTOFMEMORY;
        }
    }

    LPDIRECT3DLIGHTI pLight =
        static_cast<DIRECT3DLIGHTI *>((*m_pLightArray)[dwLightIndex].m_pObj);

    pLight->m_Light = *lpData;
    if (!(this->m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
    {
        if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
            pLight->SetDirtyForDDI();
        else
            m_pDDI->SetLight(dwLightIndex, &pLight->m_Light);
    }

    dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
    pLight->m_LightI.flags |= D3DLIGHTI_DIRTY;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetLight"

HRESULT D3DAPI CD3DHal::GetLight(DWORD dwLightIndex, D3DLIGHT8* lpData)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_WRITEPTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR( "Invalid D3DLIGHT pointer. GetLight failed." );
        return D3DERR_INVALIDCALL;
    }

    if (m_pLightArray->Check( dwLightIndex ) == FALSE )
    {
        D3D_ERR( "Invalid light index. GetLight failed." );
        return D3DERR_INVALIDCALL;
    }
    LPDIRECT3DLIGHTI pLight =
        static_cast<DIRECT3DLIGHTI *>((*m_pLightArray)[dwLightIndex].m_pObj);
    if (pLight == NULL)
    {
        D3D_ERR( "Invalid light index. GetLight failed." );
        return D3DERR_INVALIDCALL;
    }

    *lpData = pLight->m_Light;

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::LightEnableI"

void CD3DHal::LightEnableI(DWORD dwLightIndex, BOOL bEnable)
{
    LPDIRECT3DLIGHTI pLight = 
        static_cast<DIRECT3DLIGHTI *>((*m_pLightArray)[dwLightIndex].m_pObj);
    if (bEnable)
    {
        if (!pLight->Enabled())
        {

            LIST_INSERT_ROOT(&m_ActiveLights, pLight, m_List);
            pLight->m_LightI.flags |= D3DLIGHTI_ENABLED;
            dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
        }
    }
    else
    {
        if (pLight->Enabled())
        {
            LIST_DELETE(pLight, m_List);
            pLight->m_LightI.flags &= ~D3DLIGHTI_ENABLED;
            dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
        }
    }
    // Update driver state
    if (!(this->m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
    {
        if (this->m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
            pLight->SetEnableDirtyForDDI();
        else
            m_pDDI->LightEnable(dwLightIndex, bEnable);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::LightEnable"

HRESULT D3DAPI CD3DHal::GetLightEnable(DWORD dwLightIndex, BOOL *pbEnable)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_WRITEPTR(pbEnable, sizeof(BOOL)))
    {
        D3D_ERR( "Invalid enable pointer. GetLightEnable failed." );
        throw D3DERR_INVALIDCALL;
    }

    if ((m_pLightArray->Check( dwLightIndex ) == FALSE)
        ||
        ((*m_pLightArray)[dwLightIndex].m_pObj == NULL))
    {
        D3D_ERR("Invalid light index OR light is not initialized. GetLightEnable failed.");
        return D3DERR_INVALIDCALL;
    }
    LPDIRECT3DLIGHTI pLight =
        static_cast<DIRECT3DLIGHTI *>((*m_pLightArray)[dwLightIndex].m_pObj);
    *pbEnable = pLight->Enabled();
    return D3D_OK;
}
//---------------------------------------------------------------------
// Update internal light state
//
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DLIGHTI::SetInternalData"

HRESULT DIRECT3DLIGHTI::SetInternalData()
{
    m_LightI.type   = m_Light.Type;
    m_LightI.flags &= ~D3DLIGHTI_OPTIMIZATIONFLAGS;

    if (FLOAT_EQZ(m_Light.Specular.r) &&
        FLOAT_EQZ(m_Light.Specular.g) &&
        FLOAT_EQZ(m_Light.Specular.b))
    {
        m_LightI.flags |= D3DLIGHTI_SPECULAR_IS_ZERO;
    }

    if (FLOAT_EQZ(m_Light.Ambient.r) &&
        FLOAT_EQZ(m_Light.Ambient.g) &&
        FLOAT_EQZ(m_Light.Ambient.b))
    {
        m_LightI.flags |= D3DLIGHTI_AMBIENT_IS_ZERO;
    }

    m_LightI.ambient.r = m_Light.Ambient.r;
    m_LightI.ambient.g = m_Light.Ambient.g;
    m_LightI.ambient.b = m_Light.Ambient.b;

    m_LightI.specular.r = m_Light.Specular.r;
    m_LightI.specular.g = m_Light.Specular.g;
    m_LightI.specular.b = m_Light.Specular.b;

    m_LightI.diffuse.r = m_Light.Diffuse.r;
    m_LightI.diffuse.g = m_Light.Diffuse.g;
    m_LightI.diffuse.b = m_Light.Diffuse.b;

    m_LightI.position.x = m_Light.Position.x;
    m_LightI.position.y = m_Light.Position.y;
    m_LightI.position.z = m_Light.Position.z;
    m_LightI.direction.x = m_Light.Direction.x;
    m_LightI.direction.y = m_Light.Direction.y;
    m_LightI.direction.z = m_Light.Direction.z;
    m_LightI.attenuation0 = m_Light.Attenuation0;
    m_LightI.attenuation1 = m_Light.Attenuation1;
    m_LightI.attenuation2 = m_Light.Attenuation2;

    m_LightI.range = m_Light.Range;
    m_LightI.range_squared = m_Light.Range * m_Light.Range;

    if (m_Light.Type == D3DLIGHT_SPOT)
    {
        m_LightI.cos_theta_by_2 = (float)cos(m_Light.Theta / 2.0);
        m_LightI.cos_phi_by_2 = (float)cos(m_Light.Phi / 2.0);

        m_LightI.falloff = m_Light.Falloff;
        m_LightI.inv_theta_minus_phi = m_LightI.cos_theta_by_2 -
            m_LightI.cos_phi_by_2;
        if (m_LightI.inv_theta_minus_phi != 0.0)
        {
            m_LightI.inv_theta_minus_phi = 1.0f/m_LightI.inv_theta_minus_phi;
        }
        else
        {
            m_LightI.inv_theta_minus_phi = 1.0f;
        }
    }
    if (m_Light.Type == D3DLIGHT_DIRECTIONAL ||
        m_Light.Type == D3DLIGHT_SPOT)
    {
        VecNormalize(m_LightI.direction);
    }

    // set internal flags
    if (m_LightI.attenuation0 != 0.0)
    {
        m_LightI.flags |= D3DLIGHTI_ATT0_IS_NONZERO;
    }
    if (m_LightI.attenuation1 != 0.0)
    {
        m_LightI.flags |= D3DLIGHTI_ATT1_IS_NONZERO;
    }
    if (m_LightI.attenuation2 != 0.0)
    {
        m_LightI.flags |= D3DLIGHTI_ATT2_IS_NONZERO;
    }
    if (m_LightI.falloff == 1.0)
    {
        m_LightI.flags |= D3DLIGHTI_LINEAR_FALLOFF;
    }
    m_LightI.flags &= ~D3DLIGHTI_DIRTY;
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\pch.cpp ===
#include "ddrawpr.h"
#include "dxgint.h"
#include "resource.hpp"
#include "texture.hpp"
#include "volume.hpp"
#include "mipmap.hpp"
#include "mipvol.hpp"
#include "cubemap.hpp"
#include "surface.hpp"
#include "d3d8ddi.h"
#include <windows.h>
#include <assert.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "dpf.h"
#include "d3di.hpp"
#include "ddi.h"
#include "d3dpr.hpp"
#include "ddrawp.h"
#include "memalloc.h"
#include "fltval.h"
#include "stateset.hpp"
#include "hmgr.hpp"
#include "d3dexcept.hpp"
#include "drawprim.hpp"
#include "resource.inl"
#include "pipeln.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\npatch.cpp ===
/*============================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       npatch.cpp
 *  Content:    Consersion of NPatches to Rect-Patches
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
UINT CVertexPointer::Stride[__NUMELEMENTS];
UINT CVertexPointer::NumUsedElements;
UINT CVertexPointer::DataType[__NUMELEMENTS];
//-----------------------------------------------------------------------------
static const float Tension  = 1.0f/3.0f;
static const float OneOver3 = 1.0f/3.0f;
//-----------------------------------------------------------------------------
struct UVW
{
    float u, v, w, uu, vv, ww, uv, uw, vw;
};
static UVW g_uvw[10];
//-----------------------------------------------------------------------------
CNPatch2TriPatch::CNPatch2TriPatch()
{
    memset(this, 0, sizeof(this));
   // Write only streams with RTPatches usage
    for (int i=0; i < __NUMELEMENTS; i++)
        m_pOutStream[i] = new CTLStream(TRUE, D3DUSAGE_RTPATCHES); 
    int k = 0;
    for(int vv = 3; vv >= 0; --vv)
    for(int uu = 0; uu < 4 - vv; ++uu)
    {
        int ww = 3 - uu - vv;
        float u = uu * OneOver3;
        float v = vv * OneOver3;
        float w = ww * OneOver3;
        g_uvw[k].u = u;
        g_uvw[k].v = v;
        g_uvw[k].w = w;
        g_uvw[k].uu = u*u;
        g_uvw[k].vv = v*v;
        g_uvw[k].ww = w*w;
        g_uvw[k].uv = u*v;
        g_uvw[k].uw = u*w;
        g_uvw[k].vw = v*w;
        k++;
    }
}
//-----------------------------------------------------------------------------
void ComputeNormalControlPoint(D3DVECTOR* cp, 
                               float* pVi, float* pVj, 
                               float* pNi, float* pNj)
{
    D3DVECTOR Pji;
    D3DVECTOR Nij;
    VecSub(*(D3DVECTOR*)pVj, *(D3DVECTOR*)pVi, Pji);
    VecAdd(*(D3DVECTOR*)pNj, *(D3DVECTOR*)pNi, Nij);
    FLOAT v = 2.0f * VecDot(Pji, Nij) / VecDot(Pji, Pji);
    Pji.x *= v;
    Pji.y *= v;
    Pji.z *= v;
    VecSub(Nij, Pji, *cp);

    // Now go from polynomial coefficients to Bezier control points

    cp->x *= 0.5f;
    cp->y *= 0.5f;
    cp->z *= 0.5f;
}
//-----------------------------------------------------------------------------
CNPatch2TriPatch::~CNPatch2TriPatch()
{
    for (int i=0; i < __NUMELEMENTS; i++)
        delete m_pOutStream[i];
}
//-----------------------------------------------------------------------------
// Convert NPatch to Rect-Patch:
// 
void CNPatch2TriPatch::MakeRectPatch(const CVertexPointer& pV0, 
                                     const CVertexPointer& pV2, 
                                     const CVertexPointer& pV1)
{
    float t, Edge[3], B[10][3];
    float n0[3];
    float n1[3];
    float n2[3];

    float *p0 = (float*)pV0.pData[m_PositionIndex];
    float *p1 = (float*)pV1.pData[m_PositionIndex];
    float *p2 = (float*)pV2.pData[m_PositionIndex];
    n0[0] = ((float*)pV0.pData[m_NormalIndex])[0];
    n0[1] = ((float*)pV0.pData[m_NormalIndex])[1];
    n0[2] = ((float*)pV0.pData[m_NormalIndex])[2];
    n1[0] = ((float*)pV1.pData[m_NormalIndex])[0];
    n1[1] = ((float*)pV1.pData[m_NormalIndex])[1];
    n1[2] = ((float*)pV1.pData[m_NormalIndex])[2];
    n2[0] = ((float*)pV2.pData[m_NormalIndex])[0];
    n2[1] = ((float*)pV2.pData[m_NormalIndex])[1];
    n2[2] = ((float*)pV2.pData[m_NormalIndex])[2];
    
    // Coefficients to interpolate quadratic normals
    D3DVECTOR N002;
    D3DVECTOR N020;
    D3DVECTOR N200;
    D3DVECTOR N110;
    D3DVECTOR N101;
    D3DVECTOR N011;

    // Convert NPatch to Tri-Patch first

    if (m_PositionOrder == D3DORDER_CUBIC)
    {
        B[0][0] = p0[0];
        B[0][1] = p0[1];
        B[0][2] = p0[2];
        B[6][0] = p1[0];
        B[6][1] = p1[1];
        B[6][2] = p1[2];
        B[9][0] = p2[0];
        B[9][1] = p2[1];
        B[9][2] = p2[2];
    
        Edge[0] = p1[0] - p0[0];
        Edge[1] = p1[1] - p0[1];
        Edge[2] = p1[2] - p0[2];
        t = Edge[0] * n0[0] + Edge[1] * n0[1] + Edge[2] * n0[2];
        B[1][0] = p0[0] + (Edge[0] - n0[0] * t) * Tension;
        B[1][1] = p0[1] + (Edge[1] - n0[1] * t) * Tension;
        B[1][2] = p0[2] + (Edge[2] - n0[2] * t) * Tension;
        Edge[0] = p0[0] - p1[0];
        Edge[1] = p0[1] - p1[1];
        Edge[2] = p0[2] - p1[2];
        t = Edge[0] * n1[0] + Edge[1] * n1[1] + Edge[2] * n1[2];
        B[3][0] = p1[0] + (Edge[0] - n1[0] * t) * Tension;
        B[3][1] = p1[1] + (Edge[1] - n1[1] * t) * Tension;
        B[3][2] = p1[2] + (Edge[2] - n1[2] * t) * Tension;
        Edge[0] = p2[0] - p1[0];
        Edge[1] = p2[1] - p1[1];
        Edge[2] = p2[2] - p1[2];
        t = Edge[0] * n1[0] + Edge[1] * n1[1] + Edge[2] * n1[2];
        B[7][0] = p1[0] + (Edge[0] - n1[0] * t) * Tension;
        B[7][1] = p1[1] + (Edge[1] - n1[1] * t) * Tension;
        B[7][2] = p1[2] + (Edge[2] - n1[2] * t) * Tension;
        Edge[0] = p1[0] - p2[0];
        Edge[1] = p1[1] - p2[1];
        Edge[2] = p1[2] - p2[2];
        t = Edge[0] * n2[0] + Edge[1] * n2[1] + Edge[2] * n2[2];
        B[8][0] = p2[0] + (Edge[0] - n2[0] * t) * Tension;
        B[8][1] = p2[1] + (Edge[1] - n2[1] * t) * Tension;
        B[8][2] = p2[2] + (Edge[2] - n2[2] * t) * Tension;
        Edge[0] = p2[0] - p0[0];
        Edge[1] = p2[1] - p0[1];
        Edge[2] = p2[2] - p0[2];
        t = Edge[0] * n0[0] + Edge[1] * n0[1] + Edge[2] * n0[2];
        B[2][0] = p0[0] + (Edge[0] - n0[0] * t) * Tension;
        B[2][1] = p0[1] + (Edge[1] - n0[1] * t) * Tension;
        B[2][2] = p0[2] + (Edge[2] - n0[2] * t) * Tension;
        Edge[0] = p0[0] - p2[0];
        Edge[1] = p0[1] - p2[1];
        Edge[2] = p0[2] - p2[2];
        t = Edge[0] * n2[0] + Edge[1] * n2[1] + Edge[2] * n2[2];
        B[5][0] = p2[0] + (Edge[0] - n2[0] * t) * Tension;
        B[5][1] = p2[1] + (Edge[1] - n2[1] * t) * Tension;
        B[5][2] = p2[2] + (Edge[2] - n2[2] * t) * Tension;

        B[4][0] = (B[1][0] + B[2][0] + B[3][0] + B[5][0] + B[7][0] + B[8][0]) / 4.0f - (B[0][0] + B[6][0] + B[9][0]) / 6.0f;
        B[4][1] = (B[1][1] + B[2][1] + B[3][1] + B[5][1] + B[7][1] + B[8][1]) / 4.0f - (B[0][1] + B[6][1] + B[9][1]) / 6.0f;
        B[4][2] = (B[1][2] + B[2][2] + B[3][2] + B[5][2] + B[7][2] + B[8][2]) / 4.0f - (B[0][2] + B[6][2] + B[9][2]) / 6.0f;
    }
    if (m_NormalOrder == D3DORDER_QUADRATIC)
    {
        // Compute central control point
        if (m_bNormalizeNormals)
        {
            VecNormalizeFast(*n0);
            VecNormalizeFast(*n1);
            VecNormalizeFast(*n2);
        }
        N002 = *(D3DVECTOR*)n1;
        N020 = *(D3DVECTOR*)n0;
        N200 = *(D3DVECTOR*)n2;

        // Compute edge control points

        ComputeNormalControlPoint(&N110, p0, p2, n0, n2);
        ComputeNormalControlPoint(&N101, p2, p1, n2, n1);
        ComputeNormalControlPoint(&N011, p1, p0, n1, n0);
    }

    float CP[__NUMELEMENTS*4][10];      // Computed tri-patch control pointes
    int iCP;                            // Float value index in the control point array
    for(int k = 0; k < 10; k++)
    {
        iCP = 0;                        
        const float U = g_uvw[k].u;
        const float V = g_uvw[k].v;
        const float W = g_uvw[k].w;

        for (UINT iElement=0; iElement < CVertexPointer::NumUsedElements; iElement++)
        {
            if (iElement == m_PositionIndex)
            {
                if (m_PositionOrder == D3DORDER_CUBIC)
                {
                    CP[iCP++][k] = B[k][0];
                    CP[iCP++][k] = B[k][1];
                    CP[iCP++][k] = B[k][2];
                }
                else
                {
                    CP[iCP++][k] = p2[0] * U + p0[0] * V + p1[0] * W;
                    CP[iCP++][k] = p2[1] * U + p0[1] * V + p1[1] * W;
                    CP[iCP++][k] = p2[2] * U + p0[2] * V + p1[2] * W;
                }
            }
            else
            if (iElement == m_NormalIndex)
            {
                if (m_NormalOrder == D3DORDER_QUADRATIC)
                {
                    D3DVECTOR Q;
                    // Do degree elevation from quadratic to cubic
                    switch (k)
                    {
                    case 0:
                        Q.x = N020.x;
                        Q.y = N020.y;
                        Q.z = N020.z;
                        break;
                    case 1:
                        Q.x = (2.0f*N011.x + N020.x) * OneOver3;
                        Q.y = (2.0f*N011.y + N020.y) * OneOver3;
                        Q.z = (2.0f*N011.z + N020.z) * OneOver3;
                        break;
                    case 2:
                        Q.x = (2.0f*N110.x + N020.x) * OneOver3;
                        Q.y = (2.0f*N110.y + N020.y) * OneOver3;
                        Q.z = (2.0f*N110.z + N020.z) * OneOver3;
                        break;
                    case 3:
                        Q.x = (2.0f*N011.x + N002.x) * OneOver3;
                        Q.y = (2.0f*N011.y + N002.y) * OneOver3;
                        Q.z = (2.0f*N011.z + N002.z) * OneOver3;
                        break;
                    case 4:
                        Q.x = (N011.x + N101.x + N110.x) * OneOver3;
                        Q.y = (N011.y + N101.y + N110.y) * OneOver3;
                        Q.z = (N011.z + N101.z + N110.z) * OneOver3;
                        break;
                    case 5:
                        Q.x = (2.0f*N110.x + N200.x) * OneOver3;
                        Q.y = (2.0f*N110.y + N200.y) * OneOver3;
                        Q.z = (2.0f*N110.z + N200.z) * OneOver3;
                        break;
                    case 6:
                        Q.x = N002.x;
                        Q.y = N002.y;
                        Q.z = N002.z;
                        break;
                    case 7:
                        Q.x = (2.0f*N101.x + N002.x) * OneOver3;
                        Q.y = (2.0f*N101.y + N002.y) * OneOver3;
                        Q.z = (2.0f*N101.z + N002.z) * OneOver3;
                        break;
                    case 8:
                        Q.x = (2.0f*N101.x + N200.x) * OneOver3;
                        Q.y = (2.0f*N101.y + N200.y) * OneOver3;
                        Q.z = (2.0f*N101.z + N200.z) * OneOver3;
                        break;
                    case 9:
                        Q.x = N200.x;
                        Q.y = N200.y;
                        Q.z = N200.z;
                        break;
                    }
                    CP[iCP++][k] = Q.x;
                    CP[iCP++][k] = Q.y;
                    CP[iCP++][k] = Q.z;
                }
                else
                {
                    CP[iCP++][k] = n2[0] * U + n0[0] * V + n1[0] * W;
                    CP[iCP++][k] = n2[1] * U + n0[1] * V + n1[1] * W;
                    CP[iCP++][k] = n2[2] * U + n0[2] * V + n1[2] * W;
                }
            }
            else
            {
                switch(CVertexPointer::DataType[iElement])
                {
                case D3DVSDT_FLOAT1:
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[0] * U + 
                                   ((float*)pV0.pData[iElement])[0] * V + 
                                   ((float*)pV1.pData[iElement])[0] * W;
                    break;
                case D3DVSDT_FLOAT2:
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[0] * U + 
                                   ((float*)pV0.pData[iElement])[0] * V + 
                                   ((float*)pV1.pData[iElement])[0] * W;
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[1] * U + 
                                   ((float*)pV0.pData[iElement])[1] * V + 
                                   ((float*)pV1.pData[iElement])[1] * W;
                    break;
                case D3DVSDT_FLOAT3:
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[0] * U + 
                                   ((float*)pV0.pData[iElement])[0] * V + 
                                   ((float*)pV1.pData[iElement])[0] * W;
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[1] * U + 
                                   ((float*)pV0.pData[iElement])[1] * V + 
                                   ((float*)pV1.pData[iElement])[1] * W;
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[2] * U + 
                                   ((float*)pV0.pData[iElement])[2] * V + 
                                   ((float*)pV1.pData[iElement])[2] * W;
                    break;
                case D3DVSDT_FLOAT4:
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[0] * U + 
                                   ((float*)pV0.pData[iElement])[0] * V + 
                                   ((float*)pV1.pData[iElement])[0] * W;
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[1] * U + 
                                   ((float*)pV0.pData[iElement])[1] * V + 
                                   ((float*)pV1.pData[iElement])[1] * W;
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[2] * U + 
                                   ((float*)pV0.pData[iElement])[2] * V + 
                                   ((float*)pV1.pData[iElement])[2] * W;
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[3] * U + 
                                   ((float*)pV0.pData[iElement])[3] * V + 
                                   ((float*)pV1.pData[iElement])[3] * W;
                    break;
                case D3DVSDT_D3DCOLOR:
                case D3DVSDT_UBYTE4:
                    DWORD c;
                    c = *(DWORD*)pV0.pData[iElement];
                    float r[3], g[3], b[3], a[3];
                    r[0] = float(c & 0xFF);
                    g[0] = float((c >> 8) & 0xFF);
                    b[0] = float((c >> 16) & 0xFF);
                    a[0] = float((c >> 24) & 0xFF);
                    c = *(DWORD*)pV1.pData[iElement];
                    r[1] = float(c & 0xFF);
                    g[1] = float((c >> 8) & 0xFF);
                    b[1] = float((c >> 16) & 0xFF);
                    a[1] = float((c >> 24) & 0xFF);
                    c = *(DWORD*)pV2.pData[iElement];
                    r[2] = float(c & 0xFF);
                    g[2] = float((c >> 8) & 0xFF);
                    b[2] = float((c >> 16) & 0xFF);
                    a[2] = float((c >> 24) & 0xFF);
                    CP[iCP++][k] = r[2] * U + r[0] * V + r[1] * W;
                    CP[iCP++][k] = g[2] * U + g[0] * V + g[1] * W;
                    CP[iCP++][k] = b[2] * U + b[0] * V + b[1] * W;
                    CP[iCP++][k] = a[2] * U + a[0] * V + a[1] * W;
                    break;
                case D3DVSDT_SHORT2:
                    CP[iCP++][k]= (float)(
                                        ((short*)pV2.pData[iElement])[0] * U + 
                                        ((short*)pV0.pData[iElement])[0] * V + 
                                        ((short*)pV1.pData[iElement])[0] * W);
                    CP[iCP++][k] = (float)(
                                        ((short*)pV2.pData[iElement])[1] * U + 
                                        ((short*)pV0.pData[iElement])[1] * V + 
                                        ((short*)pV1.pData[iElement])[1] * W);
                    break;
                case D3DVSDT_SHORT4:
                    CP[iCP++][k] = (float)(
                                        ((short*)pV2.pData[iElement])[0] * U + 
                                        ((short*)pV0.pData[iElement])[0] * V + 
                                        ((short*)pV1.pData[iElement])[0] * W);
                    CP[iCP++][k] = (float)(
                                        ((short*)pV2.pData[iElement])[1] * U + 
                                        ((short*)pV0.pData[iElement])[1] * V + 
                                        ((short*)pV1.pData[iElement])[1] * W);
                    CP[iCP++][k] = (float)(
                                        ((short*)pV2.pData[iElement])[2] * U + 
                                        ((short*)pV0.pData[iElement])[2] * V + 
                                        ((short*)pV1.pData[iElement])[2] * W);
                    CP[iCP++][k] = (float)(
                                        ((short*)pV2.pData[iElement])[3] * U + 
                                        ((short*)pV0.pData[iElement])[3] * V + 
                                        ((short*)pV1.pData[iElement])[3] * W);
                    break;
                default: DXGASSERT(FALSE);
                }
            }
        }
    }

    // Now convert Tri-Patch to Rect-Patch by transforming 10 tri-patch control
    // points to 16 rect-patch control points

    float CPR[16][__NUMELEMENTS*4];      // Computed rect-patch control pointes
    {
        for (int i=0; i < iCP; i++)
        {
            // First row - copy first point 4 times
            CPR[0][i] = CPR[1][i] = 
            CPR[2][i] = CPR[3][i] = CP[i][0];

            // 2nd row
            float v1 = CP[i][1];
            float v2 = CP[i][2];
            CPR[ 4][i] = v1;
            CPR[ 5][i] = (v1 * 2.0f + v2       ) * OneOver3;
            CPR[ 6][i] = (v1        + v2 * 2.0f) * OneOver3;
            CPR[ 7][i] = v2;

            // 3rd row
            CPR[ 8][i] = CP[i][3];
            CPR[ 9][i] = (CP[i][3]        + CP[i][4] * 2.0f) * OneOver3;
            CPR[10][i] = (CP[i][4] * 2.0f + CP[i][5]       ) * OneOver3;
            CPR[11][i] = CP[i][5];

            // 4th row - copy all elements
            CPR[12][i] = CP[i][6];
            CPR[13][i] = CP[i][7];
            CPR[14][i] = CP[i][8];
            CPR[15][i] = CP[i][9];
        }
    }

    // Output the result

    {
        for (int i=0; i < 16; i++)
        {
            UINT k = 0; 
            for (UINT iElement=0; iElement < CVertexPointer::NumUsedElements; iElement++)
            {
                float* pout = (float*)m_OutVertex.pData[iElement];
                switch(CVertexPointer::DataType[iElement])
                {
                case D3DVSDT_FLOAT1:
                    pout[0] = CPR[i][k++];
                    break;
                case D3DVSDT_FLOAT2:
                    pout[0] = CPR[i][k++];
                    pout[1] = CPR[i][k++];
                    break;
                case D3DVSDT_FLOAT3:
                    pout[0] = CPR[i][k++];
                    pout[1] = CPR[i][k++];
                    pout[2] = CPR[i][k++];
                    break;
                case D3DVSDT_FLOAT4:
                    pout[0] = CPR[i][k++];
                    pout[1] = CPR[i][k++];
                    pout[2] = CPR[i][k++];
                    pout[3] = CPR[i][k++];
                    break;
                case D3DVSDT_D3DCOLOR:
                case D3DVSDT_UBYTE4:
                    {
                        DWORD c;
                        float r = CPR[i][k++];
                        float g = CPR[i][k++];
                        float b = CPR[i][k++];
                        float a = CPR[i][k++];
                        c  = DWORD(r);
                        c |= DWORD(g) << 8;
                        c |= DWORD(b) << 16;
                        c |= DWORD(a) << 24;
                        *(DWORD*)pout = c;
                    }
                    break;
                case D3DVSDT_SHORT2:
                    ((short*)pout)[0] = (short)(CPR[i][k++]);
                    ((short*)pout)[1] = (short)(CPR[i][k++]);
                    break;
                case D3DVSDT_SHORT4:
                    ((short*)pout)[0] = (short)(CPR[i][k++]);
                    ((short*)pout)[1] = (short)(CPR[i][k++]);
                    ((short*)pout)[2] = (short)(CPR[i][k++]);
                    ((short*)pout)[3] = (short)(CPR[i][k++]);
                    break;
                default: DXGASSERT(FALSE);
                }
            }
            m_OutVertex++;
        }
    }
}
//-----------------------------------------------------------------------------
void DrawPatches(CD3DHal* pDevice, UINT PrimitiveCount)
{
    // Unlock output vertex buffers 
    if (D3DVSD_ISLEGACY(pDevice->m_dwCurrentShaderHandle))
    {
        pDevice->m_pConvObj->m_pOutStream[0]->m_pVB->Unlock();
    }
    else
    {
        CVDeclaration* pDecl = &pDevice->m_pCurrentShader->m_Declaration;
        CVStreamDecl* pStreamDecl = pDevice->m_pCurrentShader->m_Declaration.m_pActiveStreams;
        while (pStreamDecl)
        {
            pDevice->m_pConvObj->m_pOutStream[pStreamDecl->m_dwStreamIndex]->m_pVB->Unlock();
            pStreamDecl = (CVStreamDecl*)pStreamDecl->m_pNext;
        }
     }

    // Draw rect patches
    float numSegs[4];
    numSegs[0] = 
    numSegs[1] = 
    numSegs[2] = 
    numSegs[3] = *(float*)&pDevice->rstates[D3DRS_PATCHSEGMENTS];
    D3DRECTPATCH_INFO info;
    info.StartVertexOffsetWidth = pDevice->m_pConvObj->m_FirstVertex;
    info.StartVertexOffsetHeight = 0;
    info.Width = 4;
    info.Height = 4;
    info.Stride = 4; // verticies to next row of verticies
    info.Basis = D3DBASIS_BEZIER;
    info.Order = D3DORDER_CUBIC;

    for (UINT i = PrimitiveCount; i > 0; i--)
    {
        pDevice->DrawRectPatch(0, numSegs, &info);
        info.StartVertexOffsetWidth += 16;
    }

    // Restore input vertex streams
    if (D3DVSD_ISLEGACY(pDevice->m_dwCurrentShaderHandle))
    {
        // Always need to call SetStreamSource to decrease reference count of 
        // the internal VB buffer
        pDevice->SetStreamSource(0, pDevice->m_pConvObj->m_InpStream[0].m_pVB, 
                                 CVertexPointer::Stride[0]);
        if (pDevice->m_pConvObj->m_InpStream[0].m_pVB)
        {
            // Remove additional ref count, because the stream is set 
            // second time
            pDevice->m_pConvObj->m_InpStream[0].m_pVB->Release();
            pDevice->m_pConvObj->m_InpStream[0].m_pVB = NULL;
        }
    }
    else
    {
        CVDeclaration* pDecl = &pDevice->m_pCurrentShader->m_Declaration;
        CVStreamDecl* pStreamDecl = pDevice->m_pCurrentShader->m_Declaration.m_pActiveStreams;
        while (pStreamDecl)
        {
            UINT si = pStreamDecl->m_dwStreamIndex;
            UINT Stride = pStreamDecl->m_dwStride;
            CVStream* pStream = &pDevice->m_pConvObj->m_InpStream[si];
            // Always need to call SetStreamSource to decrease reference count 
            // of the internal VB buffer
            pDevice->SetStreamSource(si, pStream->m_pVB, Stride);
            if (pStream->m_pVB)
            {
                // Remove additional ref count, because the stream is set second 
                // time
                pStream->m_pVB->Release();
                pStream->m_pVB = NULL;
            }
            pStreamDecl = (CVStreamDecl*)pStreamDecl->m_pNext;
        }
    }
}
//-----------------------------------------------------------------------------
void CD3DHal_DrawNPatch(CD3DBase* pBaseDevice, D3DPRIMITIVETYPE PrimitiveType,
                        UINT StartVertex, UINT PrimitiveCount)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(pBaseDevice);

    // Draw as usual for non-triangle primitive types
    if (PrimitiveType < D3DPT_TRIANGLELIST)
    {
        (*pDevice->m_pfnDrawPrimFromNPatch)(pBaseDevice, PrimitiveType, 
                                            StartVertex, PrimitiveCount);
        // m_pfnDrawPrim could be switched to fast path, so we need to restore it
        pDevice->m_pfnDrawPrim = CD3DHal_DrawNPatch;
        return;
    }

#if DBG
    UINT nVer = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
    pDevice->ValidateDraw2(PrimitiveType, StartVertex, PrimitiveCount, nVer,
                           FALSE);
#endif

    pDevice->PrepareNPatchConversion(PrimitiveCount, StartVertex);

    // Go through triangles and generate tri-patches

    CNPatch2TriPatch* pConvObj = pDevice->m_pConvObj;
    switch( PrimitiveType )
    {
    case D3DPT_TRIANGLELIST:
        {
            for (UINT i = PrimitiveCount; i > 0; i--)
            {
                CVertexPointer pV0 = pConvObj->m_InpVertex; 
                pConvObj->m_InpVertex++;
                CVertexPointer pV1 = pConvObj->m_InpVertex; 
                pConvObj->m_InpVertex++;
                CVertexPointer pV2 = pConvObj->m_InpVertex; 
                pConvObj->m_InpVertex++;
                pConvObj->MakeRectPatch(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.   
            CVertexPointer pV0;
            CVertexPointer pV1 = pConvObj->m_InpVertex;
            pConvObj->m_InpVertex++;
            CVertexPointer pV2 = pConvObj->m_InpVertex;
            pConvObj->m_InpVertex++;

            for (UINT i =PrimitiveCount; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pConvObj->m_InpVertex;
                pConvObj->m_InpVertex++;
                pConvObj->MakeRectPatch(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = pConvObj->m_InpVertex;
                pConvObj->m_InpVertex++;
                pConvObj->MakeRectPatch(pV0, pV2, pV1);
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pConvObj->m_InpVertex;
                pConvObj->MakeRectPatch(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            CVertexPointer pV0;
            CVertexPointer pV1;
            CVertexPointer pV2;
            pV2 = pConvObj->m_InpVertex;
            pConvObj->m_InpVertex++;
            // Preload initial pV0.
            pV1 = pConvObj->m_InpVertex;
            pConvObj->m_InpVertex++;
            for (UINT i = PrimitiveCount; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = pConvObj->m_InpVertex;
                pConvObj->m_InpVertex++;
                pConvObj->MakeRectPatch(pV0, pV1, pV2);
            }
        }
        break;
    default:
        DXGASSERT(FALSE);
    }

    pDevice->m_pDDI->SetWithinPrimitive(TRUE);
    DrawPatches(pDevice, PrimitiveCount);
    pDevice->m_pDDI->SetWithinPrimitive(FALSE);
}
//-----------------------------------------------------------------------------
void CD3DHal_DrawIndexedNPatch(CD3DBase* pBaseDevice,
                               D3DPRIMITIVETYPE PrimitiveType,
                               UINT BaseIndex,
                               UINT MinIndex, UINT NumVertices,
                               UINT StartIndex,
                               UINT PrimitiveCount)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(pBaseDevice);

    // Draw as usual for non-triangle primitive types
    if (PrimitiveType < D3DPT_TRIANGLELIST)
    {
        (*pDevice->m_pfnDrawIndexedPrimFromNPatch)(pBaseDevice, PrimitiveType, 
                                          BaseIndex, MinIndex, NumVertices, 
                                          StartIndex, PrimitiveCount);
        // m_pfnDrawIndexedPrim could be switched to fast path, so we 
        // need to restore it
        pDevice->m_pfnDrawIndexedPrim = CD3DHal_DrawIndexedNPatch;
        return;
    }

#if DBG
    pDevice->ValidateDraw2(PrimitiveType, MinIndex + BaseIndex, PrimitiveCount, NumVertices,
                           TRUE, StartIndex);
#endif

    pDevice->PrepareNPatchConversion(PrimitiveCount, BaseIndex);

    // Go through triangles and generate tri-patches

    CNPatch2TriPatch* pConvObj = pDevice->m_pConvObj;

    if (pDevice->m_pIndexStream->m_dwStride == 2)
    {
        WORD* pIndices = (WORD*)pDevice->m_pIndexStream->Data() + StartIndex;
        switch( PrimitiveType )
        {
        case D3DPT_TRIANGLELIST:
            {
                for (UINT i = PrimitiveCount; i > 0; i--)
                {
                    CVertexPointer pV0;
                    CVertexPointer pV1;
                    CVertexPointer pV2;
                    pV0.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV1, pV2);
                }
            }
            break;
        case D3DPT_TRIANGLESTRIP:
            {
                CVertexPointer pV0;
                CVertexPointer pV1;
                CVertexPointer pV2;
                // Get initial vertex values.
                pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));

                for (UINT i = PrimitiveCount; i > 1; i -= 2)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV1, pV2);

                    pV0 = pV1;
                    pV1 = pV2;
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV2, pV1);
                }

                if (i > 0)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV1, pV2);
                }
            }
            break;
        case D3DPT_TRIANGLEFAN:
            {
                CVertexPointer pV1;
                CVertexPointer pV2;
                pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                // Preload initial pV0.
                pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                for (UINT i = PrimitiveCount; i > 0; i--)
                {
                    CVertexPointer pV0 = pV1;
                    pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV2, pV1);
                }
            }
            break;
        default:
            DXGASSERT(FALSE);
        }
    }
    else
    {
        DWORD* pIndices = (DWORD*)pDevice->m_pIndexStream->Data() + StartIndex;
        switch( PrimitiveType )
        {
        case D3DPT_TRIANGLELIST:
            {
                for (UINT i = PrimitiveCount; i > 0; i--)
                {
                    CVertexPointer pV0;
                    CVertexPointer pV1;
                    CVertexPointer pV2;
                    pV0.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV1, pV2);
                }
            }
            break;
        case D3DPT_TRIANGLESTRIP:
            {
                CVertexPointer pV0;
                CVertexPointer pV1;
                CVertexPointer pV2;
                // Get initial vertex values.
                pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));

                for (UINT i = PrimitiveCount; i > 1; i -= 2)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV1, pV2);

                    pV0 = pV1;
                    pV1 = pV2;
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV2, pV1);
                }

                if (i > 0)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV1, pV2);
                }
            }
            break;
        case D3DPT_TRIANGLEFAN:
            {
                CVertexPointer pV1;
                CVertexPointer pV2;
                pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                // Preload initial pV0.
                pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                for (UINT i = PrimitiveCount; i > 0; i--)
                {
                    CVertexPointer pV0 = pV1;
                    pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV2, pV1);
                }
            }
            break;
        default:
            DXGASSERT(FALSE);
        }
    }

    DrawPatches(pDevice, PrimitiveCount);
}
//-----------------------------------------------------------------------------
// Conversion output will have the same number of streams as input and the
// same vertex shader
//
void CD3DHal::PrepareNPatchConversion(UINT PrimitiveCount, UINT StartVertex)
{
    if (m_pConvObj == NULL)
    {
        m_pConvObj = new CNPatch2TriPatch;
     
        if (m_pConvObj == NULL)
        {
            D3D_THROW(E_OUTOFMEMORY, "Not enough memory");
        }

        // Pre-allocate output streams
        for (int i=0; i < __NUMELEMENTS; i++)
        {
            m_pConvObj->m_pOutStream[i]->Grow(512*32, m_pDDI); 
        }
    }

    m_pConvObj->m_PositionOrder = (D3DORDERTYPE)rstates[D3DRS_POSITIONORDER];
    m_pConvObj->m_NormalOrder   = (D3DORDERTYPE)rstates[D3DRS_NORMALORDER];
    m_pConvObj->m_bNormalizeNormals = rstates[D3DRS_NORMALIZENORMALS];

    // Compute number of vertices in the output. Each output patch has 16
    // control points
    UINT nOutVertices = PrimitiveCount * 16;

    if (D3DVSD_ISLEGACY(m_dwCurrentShaderHandle))
    {
        CVStream* pStream = &m_pStream[0];
        UINT Stride = pStream->m_dwStride;

        // Get memory pointer for the input stream 0
        m_pConvObj->m_pInpStreamMem[0] = pStream->Data() + StartVertex * Stride; 
        if (Stride != m_pConvObj->m_pOutStream[0]->m_dwStride &&
            m_pConvObj->m_pOutStream[0]->GetPrimitiveBase() != 0)
        {
            m_pDDI->FlushStates();
            m_pConvObj->m_pOutStream[0]->Reset();
            m_pConvObj->m_FirstVertex = 0;
        }
        // Allocate space in the corresponding output stream and get its
        // memory pointer
        m_pConvObj->m_pOutStreamMem[0] = m_pConvObj->m_pOutStream[0]->Lock(nOutVertices * Stride, m_pDDI);
        m_pConvObj->m_pOutStream[0]->SetVertexSize(Stride);
        m_pConvObj->m_FirstVertex = m_pConvObj->m_pOutStream[0]->GetPrimitiveBase();
        m_pConvObj->m_FirstVertex /= Stride;
        m_pConvObj->m_pOutStream[0]->SkipVertices(nOutVertices);
       // Save the old vertex buffer
        UINT tmp;
        GetStreamSource(0, (IDirect3DVertexBuffer8**)&m_pConvObj->m_InpStream[0].m_pVB, &tmp);
        // Set new vertex buffer as input stream
        SetStreamSource(0, m_pConvObj->m_pOutStream[0]->m_pVB, Stride);

        // Initialize vertex elements pointers based on the FVF handle

        UINT VertexOffset = 0;
        CVertexPointer::NumUsedElements = 0;
        BYTE* pinp = m_pConvObj->m_pInpStreamMem[0];
        BYTE* pout = m_pConvObj->m_pOutStreamMem[0];
        // Position
        m_pConvObj->m_PositionIndex = CVertexPointer::NumUsedElements;
        m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
        m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp;
        m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout;
        VertexOffset += 3*sizeof(float);
        CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT3;
        CVertexPointer::NumUsedElements++;
        // Data after position
        switch (m_dwCurrentShaderHandle & D3DFVF_POSITION_MASK)
        {
        case D3DFVF_XYZB1:  
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(float);
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT1;
            CVertexPointer::NumUsedElements++;
            break;
        case D3DFVF_XYZB2:  
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(float) * 2;
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT2;
            CVertexPointer::NumUsedElements++;
            break;
        case D3DFVF_XYZB3:  
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(float) * 3;
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT3;
            CVertexPointer::NumUsedElements++;
            break;
        case D3DFVF_XYZB4:  
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(float) * 4;
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT4;
            CVertexPointer::NumUsedElements++;
            break;
        case D3DFVF_XYZB5:  
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(float) * 4;
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT4;
            CVertexPointer::NumUsedElements++;
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(float) * 1;
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT1;
            CVertexPointer::NumUsedElements++;
            break;
        }
        //Normal
        m_pConvObj->m_NormalIndex = CVertexPointer::NumUsedElements;
        m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
        m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
        m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
        VertexOffset += 3*sizeof(float);
        CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT3;
        CVertexPointer::NumUsedElements++;
        if (m_dwCurrentShaderHandle & D3DFVF_PSIZE)
        {
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(float);
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT1;
            CVertexPointer::NumUsedElements++;
        }
        if (m_dwCurrentShaderHandle & D3DFVF_DIFFUSE)
        {
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(DWORD);
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_D3DCOLOR;
            CVertexPointer::NumUsedElements++;
        }
        if (m_dwCurrentShaderHandle & D3DFVF_SPECULAR)
        {
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(DWORD);
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_D3DCOLOR;
            CVertexPointer::NumUsedElements++;
        }
        UINT iTexCount = FVF_TEXCOORD_NUMBER(m_dwCurrentShaderHandle);
        for (UINT i = 0; i < iTexCount; i++)
        {
            switch (D3DFVF_GETTEXCOORDSIZE(m_dwCurrentShaderHandle, i))
            {
            case D3DFVF_TEXTUREFORMAT2: 
                m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
                m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
                m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
                VertexOffset += sizeof(float) * 2;
                CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT2;
                CVertexPointer::NumUsedElements++;
                break;
            case D3DFVF_TEXTUREFORMAT1:
                m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
                m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
                m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
                VertexOffset += sizeof(float);
                CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT1;
                CVertexPointer::NumUsedElements++;
                break;
            case D3DFVF_TEXTUREFORMAT3:
                m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
                m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
                m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
                VertexOffset += sizeof(float) * 3;
                CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT3;
                CVertexPointer::NumUsedElements++;
                break;
            case D3DFVF_TEXTUREFORMAT4:
                m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
                m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
                m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
                VertexOffset += sizeof(float) * 4;
                CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT4;
                CVertexPointer::NumUsedElements++;
                break;
            }
        }
    }
    else
    {
        // Check if we can batch to the same output vertex streams.
        // All output streams must have the same stride as declaration, the 
        // same primitive base and enough space to store output vertices
        CVStreamDecl* pStreamDecl = m_pCurrentShader->m_Declaration.m_pActiveStreams;
        BOOL bFirstStream = TRUE;
        UINT FirstVertexIndex = 0;
        while (pStreamDecl)
        {
            UINT si = pStreamDecl->m_dwStreamIndex;
            UINT Stride = pStreamDecl->m_dwStride;
            UINT PrimitiveBase = m_pConvObj->m_pOutStream[si]->GetPrimitiveBase();
            PrimitiveBase /= Stride;
            if (bFirstStream)
            {
                FirstVertexIndex = PrimitiveBase;
                m_pConvObj->m_FirstVertex = FirstVertexIndex;
            }
            if ((m_pConvObj->m_pOutStream[si]->m_dwStride != Stride &&
                 PrimitiveBase !=  0) || FirstVertexIndex != PrimitiveBase ||
                 !m_pConvObj->m_pOutStream[si]->CheckFreeSpace(nOutVertices * Stride))
            {
                m_pDDI->FlushStates();
                for (int i=0; i < __NUMELEMENTS; i++)
                {
                    m_pConvObj->m_pOutStream[i]->Reset();
                }
                m_pConvObj->m_FirstVertex = 0;
            }
            bFirstStream = FALSE;
            pStreamDecl = (CVStreamDecl*)pStreamDecl->m_pNext;
        }

        // Build an array of all vertex elements used in the shader by going
        // through all streams and elements inside each stream.

        CVDeclaration* pDecl = &m_pCurrentShader->m_Declaration;
        pStreamDecl = m_pCurrentShader->m_Declaration.m_pActiveStreams;
        UINT ve = 0;    // Vertex element index
        bFirstStream = TRUE;
        while (pStreamDecl)
        {
            UINT si = pStreamDecl->m_dwStreamIndex;
            UINT Stride = pStreamDecl->m_dwStride;
            CVStream * pStream = &m_pStream[si];
            m_pConvObj->m_pInpStreamMem[si] = pStream->Data() + StartVertex * Stride;
            // Allocate space in the corresponding output stream and get 
            // memory pointer
            m_pConvObj->m_pOutStreamMem[si] = m_pConvObj->m_pOutStream[si]->Lock(nOutVertices * Stride, m_pDDI);
            m_pConvObj->m_pOutStream[si]->SetVertexSize(Stride);
            m_pConvObj->m_pOutStream[si]->SkipVertices(nOutVertices);
            // Save the old vertex buffer
            UINT tmp;
            GetStreamSource(si, (IDirect3DVertexBuffer8**)&m_pConvObj->m_InpStream[si].m_pVB, &tmp);
            // Set new vertex buffer as input
            SetStreamSource(si, m_pConvObj->m_pOutStream[si]->m_pVB, Stride);

            for (DWORD i=0; i < pStreamDecl->m_dwNumElements; i++)
            {
                if (i >= __NUMELEMENTS)
                {
                    D3D_THROW_FAIL("Declaration is using too many elements");
                }
                // This is the array we build
                CVElement* pVerElem = &pStreamDecl->m_Elements[i];
                CVertexPointer::Stride[ve] =  Stride;
                CVertexPointer::DataType[ve] = pVerElem->m_dwDataType;
                m_pConvObj->m_InpVertex.pData[ve]  =  m_pConvObj->m_pInpStreamMem[si] + pVerElem->m_dwOffset;
                m_pConvObj->m_OutVertex.pData[ve]  =  m_pConvObj->m_pOutStreamMem[si] + pVerElem->m_dwOffset;
                if (pVerElem->m_dwRegister == D3DVSDE_POSITION)
                    m_pConvObj->m_PositionIndex = ve;
                else
                if (pVerElem->m_dwRegister == D3DVSDE_NORMAL)
                    m_pConvObj->m_NormalIndex = ve;
                ve++;
            }
            pStreamDecl = (CVStreamDecl*)pStreamDecl->m_pNext;
        }
        pDecl->m_dwNumElements = ve;
        CVertexPointer::NumUsedElements = ve;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\pshader.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pshader.cpp
 *  Content:    pixel shader runtime object init, including basic parsing
 *              of pixel shader instructions
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "fe.h"
#include "ddibase.h"
#include "vvm.h"

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreatePixelShader"

HRESULT
CPShader::Initialize(CONST DWORD* pCode, D3DDEVTYPE DevType)
{
    // get shader code sizes
    DWORD dwCodeAndCommentSize;
    DWORD dwCodeOnlySize;
    HRESULT hr = ComputeShaderCodeSize(pCode, &dwCodeOnlySize, &dwCodeAndCommentSize,
                                        &m_dwNumConstDefs);
    if (hr != S_OK)
        return hr;

    // copy original code
    m_dwCodeSizeOrig = dwCodeAndCommentSize;
    m_pCodeOrig = new DWORD[m_dwCodeSizeOrig >> 2];
    if (NULL == m_pCodeOrig)
    {
        D3D_ERR("Cannot allocate memory for shader");
        return E_OUTOFMEMORY;
    }
    memcpy( m_pCodeOrig, pCode, m_dwCodeSizeOrig );

    if( m_dwNumConstDefs )
    {
        m_pConstDefs = new CONST_DEF[m_dwNumConstDefs];
        if (NULL == m_pConstDefs)
        {
            D3D_ERR("Cannot allocate memory for shader");
            return E_OUTOFMEMORY;
        }
    }

    // strip comments before sending on if (not CHECKED) or HAL.
    // Also, store def declarations in CPShader, and strip them.
    BOOL bIsCheckedBuild =
#if DBG
        TRUE;
#else
        FALSE;
#endif
    BOOL  bStripComments = (!bIsCheckedBuild) || (DevType == D3DDEVTYPE_HAL);
    if ( bStripComments )
    {
        // strip comments from version to pass on to DDI
        m_dwCodeSize = dwCodeOnlySize;
    }
    else
    {
        // pass comments through
        m_dwCodeSize = m_dwCodeSizeOrig;
    }
    m_pCode = new DWORD[m_dwCodeSize >> 2];
    if (NULL == m_pCode)
    {
        D3D_ERR("Cannot allocate memory for shader");
        return E_OUTOFMEMORY;
    }
    DWORD* pDst = m_pCode;
    CONST DWORD* pSrc = pCode;
    DWORD dwCurrConstDef = 0;
    *pDst++ = *pSrc++; // copy version
    while (*pSrc != 0x0000FFFF)
    {
        if(IsInstructionToken(*pSrc))
        {
            DWORD opCode = (*pSrc) & D3DSI_OPCODE_MASK;
            if (opCode == D3DSIO_COMMENT )
            {
                UINT DWordSize = ((*pSrc)&D3DSI_COMMENTSIZE_MASK)>>D3DSI_COMMENTSIZE_SHIFT;
                // strip comments from version to pass on to DDI
                if( !bStripComments )
                {
                    memcpy( pDst, pSrc, (DWordSize + 1)*sizeof(DWORD) );
                    pDst += (DWordSize+1);
                }
                pSrc += (DWordSize+1);  // comment + instruction token
            }
            else if (opCode == D3DSIO_DEF)
            {
                *pDst++ = *pSrc++;
                DXGASSERT(m_pConstDefs && dwCurrConstDef < m_dwNumConstDefs);

                // Store reg. number
                m_pConstDefs[dwCurrConstDef].RegNum = (*pSrc & D3DSP_REGNUM_MASK);
                *pDst++ = *pSrc++;

                // Store the const vector
                memcpy( m_pConstDefs[dwCurrConstDef].f,pSrc,4*sizeof(DWORD) );
                memcpy( pDst,pSrc,4*sizeof(DWORD) );
                pSrc += 4;
                pDst += 4;
                dwCurrConstDef++;
            }
            else
            {
                *pDst++ = *pSrc++;
            }
        }
        else
        {
             *pDst++ = *pSrc++;
        }
    }
    *pDst++ = *pSrc++; // copy END

    DXGASSERT(dwCurrConstDef == m_dwNumConstDefs);

    return S_OK;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetPixelShaderConstant"

HRESULT D3DAPI
CD3DHal::GetPixelShaderConstant(DWORD dwRegisterAddress,
                                LPVOID lpvConstantData,
                                DWORD dwConstantCount)
{
    API_ENTER(this);
#if DBG
    // Validate Parameters
    if (!VALID_WRITEPTR(lpvConstantData, 4*sizeof(D3DVALUE)*dwConstantCount))
    {
        D3D_ERR("Invalid constant data pointer. GetPixelShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    GetPixelShaderConstantI( dwRegisterAddress, dwConstantCount,
                             lpvConstantData );
    return S_OK;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetPixelShaderFast"

HRESULT D3DAPI
CD3DHal::SetPixelShaderFast(DWORD dwHandle)
{
    try
    {
#if DBG
        CheckPixelShaderHandle(dwHandle);
#endif
        // Update constants (if any were defined in the shader code)
        if( dwHandle )
        {
            CPShader* pShader = (CPShader*)m_pPShaderArray->GetObject(dwHandle);
            for(UINT i = 0; i < pShader->m_dwNumConstDefs; i++ )
            {
                CONST_DEF* pConstDef = &pShader->m_pConstDefs[i];
                memcpy(&(m_PShaderConstReg[pConstDef->RegNum]), pConstDef->f, 4*sizeof(D3DVALUE));
            }
        }

        // No redundant handle check because shader may have embedded constant definitions which
        // must always be applied.
        if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
            m_pDDI->SetPixelShader(dwHandle);

        m_dwCurrentPixelShaderHandle = dwHandle;
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetPixelShader failed.");
        m_dwCurrentPixelShaderHandle = 0;
        return hr;
    }
   return S_OK;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetPixelShaderConstantFast"

HRESULT D3DAPI
CD3DHal::SetPixelShaderConstantFast(DWORD Register, CONST VOID* pData,
                                    DWORD count)
{

#if DBG
    // Validate Parameters
    if (!VALID_PTR(pData, sizeof(DWORD) * count))
    {
        D3D_ERR("Invalid constant data pointer. SetPixelShader failed.");
        return D3DERR_INVALIDCALL;
    }
    if(Register >= D3DPS_CONSTREG_MAX_DX8)
    {
        D3D_ERR("Invalid Constant Register number. SetPixelShader failed.");
        return D3DERR_INVALIDCALL;
    }
    if( (Register + count) > D3DPS_CONSTREG_MAX_DX8 )
    {
        D3D_ERR("Not that many constant registers in the pixel machine. SetPixelShader failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    // Cache the constants in the CPShader structure.
    memcpy(&(m_PShaderConstReg[Register]),  pData, count*4*sizeof(D3DVALUE));
    if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
    {
        try
        {
            m_pDDI->SetPixelShaderConstant(Register, pData, count);
        }
        catch(HRESULT hr)
        {
            D3D_ERR("SetPixelShaderConstant failed.");
            return hr;
        }
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetPixelShaderConstantI"

void
CD3DHal::GetPixelShaderConstantI(DWORD Register, DWORD count, LPVOID pData )
{
    // Cache the constants in the CPShader structure.
    memcpy( pData, &(m_PShaderConstReg[Register]), count*4*sizeof(D3DVALUE) );
}
//-----------------------------------------------------------------------------
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\sources.inc ===
TARGETPATH=obj
TARGETNAME=d3dfe

TARGETTYPE=LIBRARY

INCLUDES = ..;$(INCLUDES);$(D3DDX8)\tnl
C_DEFINES = -DBUILD_D3D_LAYER $(C_DEFINES)

SOURCES=\
    ..\npatch.cpp   \
    ..\d3dbase.cpp  \
    ..\d3ddev.cpp   \
    ..\devstate.cpp \
    ..\ddi.cpp      \
    ..\ddidx8.cpp   \
    ..\dlld3d.cpp   \
    ..\drawprim.cpp \
    ..\hmgr.cpp     \
    ..\helxfrm.cpp  \
    ..\lighting.cpp \
    ..\rgblt.cpp    \
    ..\stateset.cpp \
    ..\vshader.cpp  \
    ..\pshader.cpp  \
    ..\vwport.cpp   \
    ..\debugmon.cpp \
    ..\rtdmon.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\rtdmon.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// rtdmon.cpp
//
// RunTime Debug Monitor
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

#include "rtdmon.hpp"

#include "fe.h"

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
RTDebugMonitor::RTDebugMonitor( CD3DBase* pD3DBase, BOOL bDbgMonConnectionEnabled )
{
    m_pD3DBase = pD3DBase;
    m_bDbgMonConnectionEnabled = bDbgMonConnectionEnabled;
}
//-----------------------------------------------------------------------------
RTDebugMonitor::~RTDebugMonitor( void )
{
}

//-----------------------------------------------------------------------------
void
RTDebugMonitor::NextEvent( UINT32 EventType )
{
    CheckLostMonitorConnection();

    BOOL bBreakpoint = D3DDebugMonitor::IsEventBreak( EventType );

    // do event-specific stuff (state update; actions; check for breakpoints)
    UINT i;
    switch ( EventType )
    {
    case D3DDM_EVENT_RSTOKEN:
        switch( ((CD3DHal*)m_pD3DBase)->rstates[D3DRS_DEBUGMONITORTOKEN] )
        {
        case D3DDMT_ENABLE:
            m_bDbgMonConnectionEnabled = TRUE;
            break;
        case D3DDMT_DISABLE:
            if( m_pTgtCtx )
            {
                DetachMonitorConnection();
            }
            D3D_INFO(0, "D3DDebugTarget - debug monitor connection disabled by target");
            m_bDbgMonConnectionEnabled = FALSE;
            break;
        }
        break;

    case D3DDM_EVENT_BEGINSCENE:
        // try to attach if not attached
        if (!MonitorConnected())  AttachToMonitor(1);
        break;

    case D3DDM_EVENT_ENDSCENE:
        m_pTgtCtx->SceneCount++;
        break;

    case D3DDM_EVENT_PRIMITIVE:
        m_pTgtCtx->PrimitiveCount++;
        if (m_pMonCtx && m_pMonCtx->PrimitiveCountBP)
        {
            if ( m_pTgtCtx->PrimitiveCount == m_pMonCtx->PrimitiveCountBP )
                bBreakpoint = TRUE;
        }
        break;
    }

    // invoke base class to talk to monitor and issue commands
    if (bBreakpoint)
    {
        m_pTgtCtx->EventStatus = EventType;
        D3DDebugMonitor::MonitorBreakpoint();
        m_pTgtCtx->EventStatus = 0x0;
    }
    return;
}

HRESULT
RTDebugMonitor::ProcessMonitorCommand( void )
{
    UINT32 Command = m_pMonCtx->Command;
    UINT i;

    // default case - no data return
    m_pTgtCtx->CommandBufferSize = 0;

    CD3DHal* pHal = (CD3DHal*)m_pD3DBase;
    D3DFE_PVFUNCSI* pPVF = (D3DFE_PVFUNCSI*)pHal->m_pv->pGeometryFuncs;
    CVertexVM* pVVM = &(pPVF->m_VertexVM);

    switch ( Command & D3DDM_CMD_MASK )
    {

    case D3DDM_CMD_GETVERTEXSTATE:
        {
            D3DDMVertexState* pVSS = (D3DDMVertexState*)m_pCmdData;
            pVVM->GetData( D3DSPR_INPUT, 0, D3DDM_MAX_VSINPUTREG, (void*)(pVSS->InputRegs) );
            m_pTgtCtx->CommandBufferSize = sizeof(D3DDMVertexState);
        }
        break;

    case D3DDM_CMD_GETVERTEXSHADERSTATE:
        {
            D3DDMVertexShaderState* pVSS = (D3DDMVertexShaderState*)m_pCmdData;
            if (!m_pD3DBase->m_dwCurrentShaderHandle) break;

            pVSS->CurrentInst = pVVM->GetCurInstIndex();
            pVVM->GetData( D3DSPR_TEMP, 0, D3DDM_MAX_VSTEMPREG, (void*)(pVSS->TempRegs) );
            pVVM->GetData( D3DSPR_RASTOUT, 0, D3DDM_MAX_VSRASTOUTREG, (void*)(pVSS->RastOutRegs) );
            pVVM->GetData( D3DSPR_ATTROUT, 0, D3DDM_MAX_VSATTROUTREG, (void*)(pVSS->AttrOutRegs) );
            pVVM->GetData( D3DSPR_TEXCRDOUT, 0, D3DDM_MAX_VSTEXCRDOUTREG, (void*)(pVSS->TexCrdOutRegs) );
            pVVM->GetData( D3DSPR_ADDR, 0, 1, (void*)(pVSS->AddressReg) );
            m_pTgtCtx->CommandBufferSize = sizeof(D3DDMVertexShaderState);
        }
        break;

    case D3DDM_CMD_GETVERTEXSHADERCONST:
        {
            D3DDMVertexShaderConst* pVSC = (D3DDMVertexShaderConst*)m_pCmdData;
            pVVM->GetData( D3DSPR_CONST, 0, 96, (void*)(pVSC->ConstRegs) );
            m_pTgtCtx->CommandBufferSize = 96*4*sizeof(FLOAT);
        }
        break;

    case D3DDM_CMD_GETVERTEXSHADER:
        {
            DWORD Handle = *(DWORD*)m_pCmdData;
            if (D3DVSD_ISLEGACY(Handle)) break;
            CVShader* pShader = (CVShader*)(pHal->m_pVShaderArray->GetObject(Handle));
            if ( NULL == pShader )  break;
            D3DDMVertexShader* pVS = (D3DDMVertexShader*)m_pCmdData;
            DXGASSERT( pShader->m_OrgDeclSize <= (D3DDM_MAX_VSDECL*4) );
            memcpy( pVS->Decl, pShader->m_pOrgDeclaration, pShader->m_OrgDeclSize );
            char* pUserData = (char*)(pVS+1);
            m_pTgtCtx->CommandBufferSize = sizeof(D3DDMVertexShader);
        }
        break;

    case D3DDM_CMD_GETVERTEXSHADERINST:
        {
            DWORD Handle = *(DWORD*)m_pCmdData;
            if (D3DVSD_ISLEGACY(Handle)) break;
            UINT Inst = (Command & 0xffff);
            CVShader* pShader = (CVShader*)(pHal->m_pVShaderArray->GetObject(Handle));
            if ( NULL == pShader )  break;
            CVShaderCode* pSC = pShader->m_pCode;
            if (pSC && (Inst < pSC->InstCount()))
            {
                D3DDMVertexShaderInst* pVSI = (D3DDMVertexShaderInst*)m_pCmdData;
                memcpy( pVSI->Inst, pSC->InstTokens(Inst), D3DDM_MAX_VSINSTDWORD*4 );
                memcpy( pVSI->InstString, pSC->InstDisasm(Inst), D3DDM_MAX_VSINSTSTRING );
                m_pTgtCtx->CommandBufferSize = sizeof(D3DDMVertexShaderInst);
                if ( pSC->InstCommentSize(Inst) )
                {
                    memcpy( (void*)(pVSI+1), pSC->InstComment(Inst), 4*pSC->InstCommentSize(Inst) );
                    m_pTgtCtx->CommandBufferSize += 4*pSC->InstCommentSize(Inst);
                }
            }
        }
        break;

    case D3DDM_CMD_GETDEVICESTATE:
        {
            D3DDMDeviceState* pDS = (D3DDMDeviceState*)m_pCmdData;
            memcpy( pDS->RenderState, pHal->rstates, 4*D3DHAL_MAX_RSTATES );
            for (i=0; i<D3DHAL_TSS_MAXSTAGES; i++)
            {
                memcpy( pDS->TextureStageState[i],
                    pHal->tsstates[i], 4*D3DHAL_TSS_STATESPERSTAGE );
            }
            pDS->VertexShaderHandle = m_pD3DBase->m_dwCurrentShaderHandle;
            pDS->PixelShaderHandle = m_pD3DBase->m_dwCurrentPixelShaderHandle;

            pDS->MaxVShaderHandle = (UINT)(pHal->m_pVShaderArray->GetSize());
            while ( ( pDS->MaxVShaderHandle > 0 ) &&
                    ( NULL == pHal->m_pVShaderArray->GetObject(pDS->MaxVShaderHandle) ) )
            {
                pDS->MaxVShaderHandle--;
            }
            pDS->MaxPShaderHandle = 0;
            m_pTgtCtx->CommandBufferSize = sizeof(D3DDMDeviceState);
        }
        break;
    }
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\vshader.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vshader.cpp
 *  Content:    SetStreamSource and VertexShader
 *              software implementation.
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "ibuffer.hpp"
#include "fe.h"
#include "ddibase.h"
#include "pvvid.h"

void __Transpose(D3DMATRIXI* m, D3DMATRIX* res)
{
    res->_11 = m->_11;
    res->_12 = m->_21;
    res->_13 = m->_31;
    res->_14 = m->_41;
    res->_21 = m->_12;
    res->_22 = m->_22;
    res->_23 = m->_32;
    res->_24 = m->_42;
    res->_31 = m->_13;
    res->_32 = m->_23;
    res->_33 = m->_33;
    res->_34 = m->_43;
    res->_41 = m->_14;
    res->_42 = m->_24;
    res->_43 = m->_34;
    res->_44 = m->_44;
}
//-----------------------------------------------------------------------------
// Forward definitions
//
void CD3DHal_DrawPrimitive(CD3DBase* pBaseDevice, D3DPRIMITIVETYPE PrimitiveType,
                           UINT StartVertex, UINT PrimitiveCount);
void CD3DHal_DrawIndexedPrimitive(CD3DBase* pBaseDevice,
                                  D3DPRIMITIVETYPE PrimitiveType,
                                  UINT BaseIndex,
                                  UINT MinIndex, UINT NumVertices,
                                  UINT StartIndex,
                                  UINT PrimitiveCount);
void CD3DHal_DrawNPatch(CD3DBase* pBaseDevice, D3DPRIMITIVETYPE PrimitiveType,
                           UINT StartVertex, UINT PrimitiveCount);
void CD3DHal_DrawIndexedNPatch(CD3DBase* pBaseDevice,
                               D3DPRIMITIVETYPE PrimitiveType,
                               UINT BaseIndex,
                               UINT MinIndex, UINT NumVertices,
                               UINT StartIndex,
                               UINT PrimitiveCount);
//-----------------------------------------------------------------------------
void __declspec(nothrow) CD3DHal::PickDrawPrimFn()
{
    if (!(m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING))
    {
        m_pfnDrawPrim = m_pDDI->GetDrawPrimFunction();
        m_pfnDrawIndexedPrim = m_pDDI->GetDrawIndexedPrimFunction();
        if (m_dwRuntimeFlags & D3DRT_DONPATCHCONVERSION)
        {
            m_pfnDrawPrimFromNPatch = m_pfnDrawPrim;
            m_pfnDrawIndexedPrimFromNPatch = m_pfnDrawIndexedPrim;
            m_pfnDrawPrim = CD3DHal_DrawNPatch;
            m_pfnDrawIndexedPrim = CD3DHal_DrawIndexedNPatch;
        }
    }
    else
    {
        DWORD dwDeviceFlags = m_pv->dwDeviceFlags;
        BOOL bCallDriver;
        if (Enum()->GetAppSdkVersion() == D3D_SDK_VERSION_DX8)
        {
            bCallDriver = dwDeviceFlags & D3DDEV_TRANSFORMEDFVF &&
                         (dwDeviceFlags & D3DDEV_DONOTCLIP ||
                         !(dwDeviceFlags & D3DDEV_VBPROCVER));
        }
        else
        {
            bCallDriver = dwDeviceFlags & D3DDEV_TRANSFORMEDFVF &&
                          dwDeviceFlags & D3DDEV_DONOTCLIP;
        }
        if (bCallDriver)
        {
            m_pfnDrawPrim = m_pDDI->GetDrawPrimFunction();
            m_pfnDrawIndexedPrim = m_pDDI->GetDrawIndexedPrimFunction();
        }
        else
        {
            m_pfnDrawPrim = CD3DHal_DrawPrimitive;
            m_pfnDrawIndexedPrim = CD3DHal_DrawIndexedPrimitive;
        }
    }
}
//-----------------------------------------------------------------------------
// Checks if we can call driver directly to draw the current primitive
//
inline BOOL CanCallDriver(CD3DHal* pDev, D3DPRIMITIVETYPE PrimType)
{
    DWORD dwDeviceFlags = pDev->m_pv->dwDeviceFlags;
    if (PrimType != D3DPT_POINTLIST)
        return dwDeviceFlags & D3DDEV_TRANSFORMEDFVF &&
               (dwDeviceFlags & D3DDEV_DONOTCLIP || 
                pDev->Enum()->GetAppSdkVersion() == D3D_SDK_VERSION_DX8);
    else
        // This function could be called from DrawPointsI, which could be
        // called from other Draw() function than DrawPrimitiveUP, so we need
        // to check for D3DDEV_VBPROCVER. We cannot pass vertices, which are
        // result of ProcessVertices(), to the driver directly
        return dwDeviceFlags & D3DDEV_TRANSFORMEDFVF &&
               !(pDev->m_dwRuntimeFlags & D3DRT_DOPOINTSPRITEEMULATION) &&
               (dwDeviceFlags & D3DDEV_DONOTCLIP || 
                (pDev->Enum()->GetAppSdkVersion() == D3D_SDK_VERSION_DX8 &&
                !(dwDeviceFlags & D3DDEV_VBPROCVER)));
}
//-----------------------------------------------------------------------------
//                              API calls
//-----------------------------------------------------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetStreamSourceI"

void
CD3DHal::SetStreamSourceI(CVStream* pStream)
{
    if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
    {
        CVertexBuffer * pVB = pStream->m_pVB;
        m_pv->dwDeviceFlags &= ~D3DDEV_VBPROCVER;
        DWORD dwFVF = pVB->GetFVF();
        if (pVB->GetClipCodes() != NULL)
        {
            // This vertex buffer is the output of ProcessVertices
            DXGASSERT(FVF_TRANSFORMED(dwFVF));
            m_pv->dwDeviceFlags |= D3DDEV_VBPROCVER;
        }
        if (D3DVSD_ISLEGACY(m_dwCurrentShaderHandle))
        {
            SetupStrides(m_pv, m_pStream[0].m_dwStride);
        }
    }   
    PickDrawPrimFn();
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetIndicesI"

void
CD3DHal::SetIndicesI(CVIndexStream* pStream)
{
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::CreateVertexShaderI"

void
CD3DHal::CreateVertexShaderI(CONST DWORD* pdwDeclaration, DWORD dwDeclSize,
                             CONST DWORD* pdwFunction, DWORD dwCodeSize,
                             DWORD dwHandle)
{
    BOOL bIsCheckedBuild =
#if DBG
        TRUE;
#else
        FALSE;
#endif
    CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
    if (pShader->m_dwFlags & CVShader::SOFTWARE)
    {

        // Build the array of all vertex elements used in the shader by going
        // through all streams and elements inside each stream.

        CVDeclaration* pDecl = &pShader->m_Declaration;
        CVStreamDecl* pStream = pShader->m_Declaration.m_pActiveStreams;
        // This is the array we build
        CVElement* pVerElem = pShader->m_Declaration.m_VertexElements;
        pDecl->m_dwNumElements = 0;
        while (pStream)
        {
            for (DWORD i=0; i < pStream->m_dwNumElements; i++)
            {
                if (pDecl->m_dwNumElements >= __NUMELEMENTS)
                {
                    D3D_THROW_FAIL("Declaration is using too many elements");
                }
                *pVerElem = pStream->m_Elements[i];
                pVerElem->m_dwStreamIndex = pStream->m_dwStreamIndex;
                pVerElem++;
                pDecl->m_dwNumElements++;
            }
            pStream = (CVStreamDecl*)pStream->m_pNext;
        }

        if (pdwFunction != NULL)
        {
            // compute adjusted function pointer depending on FREE/CHECKED and PSGP
            LPDWORD pdwFunctionAdj = pShader->m_pStrippedFuncCode;
            if ( bIsCheckedBuild &&
                 ((LPVOID)m_pv->pGeometryFuncs == (LPVOID)GeometryFuncsGuaranteed) ) // !PSGP
            {
                pdwFunctionAdj = pShader->m_pOrgFuncCode;
            }
            // Microsoft shader is always created.
            // It is used for validation and to compute the output FVF in case
            // when PSGP is present
            HRESULT hr;
            hr = GeometryFuncsGuaranteed->CreateShader(
                            pDecl->m_VertexElements,
                            pDecl->m_dwNumElements,
                            pdwFunctionAdj, 0,
                            (CPSGPShader**)&pShader->m_pCode);
            if(FAILED(hr))
            {
                D3D_THROW_FAIL("Failed to create vertex shader code");
            }
            // When device driver can not handle separate fog value in the FVF,
            // we should use specular alpha as the fog factor
            if (pShader->m_pCode->m_dwOutFVF & D3DFVF_FOG &&
                !(GetD3DCaps()->PrimitiveMiscCaps & D3DPMISCCAPS_FOGINFVF))
            {
                pShader->m_pCode->m_dwOutFVF &= ~D3DFVF_FOG;
                // Assume that texture coordinates follow fog value
                // No need to adjust offsets when specular is already present
                if (pShader->m_pCode->m_dwOutFVF & D3DFVF_SPECULAR)
                {
                    pShader->m_pCode->m_dwOutVerSize -= 4;
                    pShader->m_pCode->m_dwTextureOffset -= 4;
                }
                pShader->m_pCode->m_dwOutFVF |= D3DFVF_SPECULAR;
            }
            // Clear texture format bits if device can handle only 2 floats per
            // texture coordinate
            if (m_dwRuntimeFlags & D3DRT_ONLY2FLOATSPERTEXTURE &&
                pShader->m_pCode->m_dwOutFVF & 0xFFFF0000)
            {
                CVShaderCode * pCode = pShader->m_pCode;
                pCode->m_dwOutFVF &= 0x0000FFFF;
                pCode->m_dwOutVerSize = ComputeVertexSizeFVF(pCode->m_dwOutFVF);
                for (DWORD i=0; i < pCode->m_nOutTexCoord; i++)
                {
                    pCode->m_dwOutTexCoordSize[i] = 2 * 4;
                }
            }
            if ((LPVOID)m_pv->pGeometryFuncs != (LPVOID)GeometryFuncsGuaranteed)
            {
                DWORD dwOutputFVF = pShader->m_pCode->m_dwOutFVF;
                CVShaderCode* pCodeMs = pShader->m_pCode;
                // Now we can create PSGP shader
                hr = m_pv->pGeometryFuncs->CreateShader(pDecl->m_VertexElements,
                                                  pDecl->m_dwNumElements,
                                                  pdwFunctionAdj, dwOutputFVF,
                                                  (CPSGPShader**)&pShader->m_pCode);
                if(FAILED(hr))
                {
                    delete pCodeMs;
                    D3D_THROW_FAIL("Failed to create vertex shader code");
                }
                // Copy pre-computed data from Microsoft's shader to the PSGP
                CPSGPShader * pCode = pShader->m_pCode;
                CPSGPShader * pMsShader = pCodeMs;
                pCode->m_dwOutRegs        = pMsShader->m_dwOutRegs;
                pCode->m_dwOutFVF         = pMsShader->m_dwOutFVF;
                pCode->m_dwPointSizeOffset = pMsShader->m_dwPointSizeOffset;
                pCode->m_dwDiffuseOffset  = pMsShader->m_dwDiffuseOffset;
                pCode->m_dwSpecularOffset = pMsShader->m_dwSpecularOffset;
                pCode->m_dwFogOffset      = pMsShader->m_dwFogOffset;
                pCode->m_dwTextureOffset  = pMsShader->m_dwTextureOffset;
                pCode->m_nOutTexCoord     = pMsShader->m_nOutTexCoord;
                pCode->m_dwOutVerSize     = pMsShader->m_dwOutVerSize;
                for (DWORD i=0; i < pCode->m_nOutTexCoord; i++)
                {
                    pCode->m_dwOutTexCoordSize[i] = pMsShader->m_dwOutTexCoordSize[i];
                }
                // Microsoft shader is not needed any more
                 delete pCodeMs;
            }
        }
    }
    else
    {
        if ( bIsCheckedBuild && (GetDeviceType() != D3DDEVTYPE_HAL ) )
        {
            // pass non-stripped version
            m_pDDI->CreateVertexShader(
                pdwDeclaration, dwDeclSize,
                pShader->m_pOrgFuncCode, 
                pShader->m_OrgFuncCodeSize, dwHandle,
                pShader->m_Declaration.m_bLegacyFVF);
        }
        else
        {
            // pass stripped version
            m_pDDI->CreateVertexShader(
                pdwDeclaration, dwDeclSize,
                pShader->m_pStrippedFuncCode, 
                pShader->m_StrippedFuncCodeSize, dwHandle,
                pShader->m_Declaration.m_bLegacyFVF);
        }
    }
    DebugStateChanged( D3DDM_SC_VSMODIFYSHADERS );
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetVertexShaderI"

void CD3DHal::SetVertexShaderI(DWORD dwHandle)
{
#if DBG
    // We need to validate shader handle here, because the shader could be
    // deleted by user after creating a state block with the shader handle.
    CheckVertexShaderHandle(dwHandle);
#endif
    
    CVConstantData* pConst = NULL;
    if (!D3DVSD_ISLEGACY(dwHandle))
    {
        CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
        pConst = pShader->m_Declaration.m_pConstants;
    }
    // Ignore redundant handle when we do not need to update constantes
    if(pConst == NULL)
    {
        if(dwHandle == m_dwCurrentShaderHandle)
            return;
    }
    else
    {
        // Load constants
        while (pConst)
        {
            HRESULT hr;
            hr = m_pv->pGeometryFuncs->LoadShaderConstants(pConst->m_dwAddress,
                                                           pConst->m_dwCount,
                                                           pConst->m_pData);
            if (FAILED(hr))
            {
                D3D_THROW_FAIL("Failed to load vertex shader constants");
            }
            pConst =  (CVConstantData*)pConst->m_pNext;
            m_dwRuntimeFlags |= D3DRT_NEED_VSCONST_UPDATE;
        }
    }

    ForceFVFRecompute();
    // When we switch from FVF shaders to programmable we need to re-compute 
    // clipping planes, because they are transformed by different matrix
    if (this->rstates[D3DRENDERSTATE_CLIPPLANEENABLE])
    {
        this->dwFEFlags |= D3DFE_CLIPPLANES_DIRTY;
    }

    m_dwCurrentShaderHandle = dwHandle;
    if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
    {
        m_dwRuntimeFlags &= ~D3DRT_POINTSIZEINVERTEX;
        m_dwRuntimeFlags |= D3DRT_SHADERDIRTY;
        m_pv->dwDeviceFlags &= ~D3DDEV_TRANSFORMEDFVF;

        if (D3DVSD_ISLEGACY(dwHandle))
        {
            if (dwHandle & D3DFVF_PSIZE)
                m_dwRuntimeFlags |= D3DRT_POINTSIZEINVERTEX;

            m_pCurrentShader = NULL;
            m_pv->dwDeviceFlags &= ~(D3DDEV_STRIDE | D3DDEV_VERTEXSHADERS);

            if (FVF_TRANSFORMED(dwHandle))
            {
                if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
                {
                    m_pDDI->SetVertexShader(dwHandle);
                }
                m_pv->dwDeviceFlags |= D3DDEV_TRANSFORMEDFVF;
            }

            m_pfnPrepareToDraw = PrepareToDrawLegacy;
            m_pv->dwVIDIn  = dwHandle;
            SetupStrides(m_pv, m_pStream[0].m_dwStride);
        }
        else
        {
            CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
            m_pCurrentShader = pShader;
            if(!(pShader->m_dwFlags & CVShader::FIXEDFUNCTION))
            {
                // Programmable vertex shaders are used
                m_pv->dwDeviceFlags |= D3DDEV_VERTEXSHADERS;
                m_pfnPrepareToDraw = PrepareToDrawVVM;
                if (m_pCurrentShader->m_pCode->m_dwOutFVF & D3DFVF_PSIZE)
                    m_dwRuntimeFlags |= D3DRT_POINTSIZEINVERTEX;

                // Pre-compute as much info as possible and keep it
                // in the vertex descriptors. This information is constant
                // unless shader is changed
                CVDeclaration* pDecl = &m_pCurrentShader->m_Declaration;
                CVertexDesc* pVD = m_pv->VertexDesc;
                CVElement *pElem = pDecl->m_VertexElements;
                m_pv->dwNumUsedVertexDescs = pDecl->m_dwNumElements;
                for (DWORD i = pDecl->m_dwNumElements; i; i--)
                {
                    pVD->pfnCopy = pElem->m_pfnCopy;
                    pVD->dwRegister = pElem->m_dwRegister;
                    pVD->dwVertexOffset = pElem->m_dwOffset;
                    pVD->pStream = &m_pStream[pElem->m_dwStreamIndex];
                    pVD++;
                    pElem++;
                }
            }
            else
            {
                // Fixed-function pipeline is used with declarations
                // We draw primitives using strided code path
                m_pv->dwDeviceFlags |= D3DDEV_STRIDE;
                m_pv->dwDeviceFlags &= ~D3DDEV_VERTEXSHADERS;

                m_pfnPrepareToDraw = PrepareToDraw;

                if (pShader->m_dwInputFVF & D3DFVF_PSIZE)
                    m_dwRuntimeFlags |= D3DRT_POINTSIZEINVERTEX;

                // Go through the elements in the current declaration and
                // initialize vertex descriptors. They are used to quickly
                // initialize strided data pointers.
                CVDeclaration* pDecl = &m_pCurrentShader->m_Declaration;
                CVertexDesc* pVD = m_pv->VertexDesc;
                CVElement *pElem = pDecl->m_VertexElements;
                m_pv->dwNumUsedVertexDescs = pDecl->m_dwNumElements;
                for (DWORD i = pDecl->m_dwNumElements; i; i--)
                {
                    pVD->pElement = &m_pv->elements[pElem->m_dwRegister];
                    pVD->pStream = &m_pStream[pElem->m_dwStreamIndex];
                    pVD->dwVertexOffset = pElem->m_dwOffset;
                    pVD++;
                    pElem++;
                }
                m_pv->dwVIDIn  = pDecl->m_dwInputFVF;
                if (pDecl->m_dwInputFVF & D3DFVF_PSIZE)
                    m_dwRuntimeFlags |= D3DRT_POINTSIZEINVERTEX;
            }
            HRESULT hr = m_pv->pGeometryFuncs->SetActiveShader(pShader->m_pCode);
            if (FAILED(hr))
            {
                D3D_THROW_FAIL("Failed to set active vertex shader");
            }
        }
        m_pDDI->PickProcessPrimitive();
    }
    else
    {
#if DBG
        // For the validation we need to set the m_pCurrentShader even for
        // hardware mode
        m_pv->dwDeviceFlags &= ~D3DDEV_VERTEXSHADERS;
        if (D3DVSD_ISLEGACY(dwHandle))
        {
            m_pCurrentShader = NULL;
        }
        else
        {
            m_pCurrentShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
            if(!(m_pCurrentShader->m_dwFlags & CVShader::FIXEDFUNCTION))
            {
                // Programmable pipeline is used
                m_pv->dwDeviceFlags |= D3DDEV_VERTEXSHADERS;
            }
        }
#endif
        if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
        {
            m_pDDI->SetVertexShaderHW(dwHandle);
        }
    }
    PickDrawPrimFn();
    DebugStateChanged( D3DDM_SC_VSSETSHADER );
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::DeleteVertexShaderI"

void CD3DHal::DeleteVertexShaderI(DWORD dwHandle)
{
#if DBG
    for(unsigned Handle = 0; Handle < m_pRTPatchValidationInfo->GetSize(); ++Handle)
    {
        if ((*m_pRTPatchValidationInfo)[Handle].m_pObj != 0)
        {
            if (static_cast<CRTPatchValidationInfo*>((*m_pRTPatchValidationInfo)[Handle].m_pObj)->m_ShaderHandle == dwHandle)
            {
                static_cast<CRTPatchValidationInfo*>((*m_pRTPatchValidationInfo)[Handle].m_pObj)->m_ShaderHandle = 0;
                D3D_INFO(0, "Found this vertex shader in a cached patch. Will invalidate the cached patch.");
            }
        }
    }
#endif // DBG
    if (dwHandle == m_dwCurrentShaderHandle)
    {
        m_pCurrentShader = NULL;
        m_dwCurrentShaderHandle = 0;
    }
    if (!D3DVSD_ISLEGACY(dwHandle))
    {
        CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
#if DBG
        if (pShader == NULL)
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid vertex shader handle");
        }
#endif
        if (!(pShader->m_dwFlags & CVShader::SOFTWARE))
        {
            m_pDDI->DeleteVertexShader(dwHandle);
        }
    }
    DebugStateChanged( D3DDM_SC_VSMODIFYSHADERS );
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetVertexShaderConstantI"

void
CD3DHal::SetVertexShaderConstantI(DWORD Register, CONST VOID* pData, DWORD count)
{
    HRESULT hr;
    if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING ||
        ((count + Register) <= D3DVS_CONSTREG_MAX_V1_1))
    {
        // For software vertex processing we store constant registers in PSGP if
        // possible
        hr = m_pv->pGeometryFuncs->LoadShaderConstants(Register, count, 
                                                       const_cast<VOID*>(pData));
    }
    else
    {
        if (Register >= D3DVS_CONSTREG_MAX_V1_1)
        {
            // When all modified registers are above software limit, we use Microsoft 
            // internal array
            hr = GeometryFuncsGuaranteed->LoadShaderConstants(Register, count, 
                                                              const_cast<VOID*>(pData));
        }
        else
        {
            // Part of constant data is stores in the PSGP array and part in the
            // Microsoft's array
            UINT FirstCount = D3DVS_CONSTREG_MAX_V1_1 - Register;
            hr = m_pv->pGeometryFuncs->LoadShaderConstants(Register, FirstCount, 
                                                           const_cast<VOID*>(pData));
            if (FAILED(hr))
            {
                D3D_THROW(hr, "Failed to set vertex shader constants");
            }
            hr = GeometryFuncsGuaranteed->LoadShaderConstants(D3DVS_CONSTREG_MAX_V1_1, 
                                                              Register + count - D3DVS_CONSTREG_MAX_V1_1,
                                                              &((DWORD*)pData)[FirstCount*4]);
        }
    }
    if (FAILED(hr))
    {
        D3D_THROW(hr, "Failed to set vertex shader constants");
    }

    if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
    {
        if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
            m_dwRuntimeFlags |= D3DRT_NEED_VSCONST_UPDATE;
        else
            m_pDDI->SetVertexShaderConstant(Register, 
                                            pData, 
                                            count);
    }
    DebugStateChanged( D3DDM_SC_VSCONSTANTS );
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::ValidateDraw2"

void CD3DHal::ValidateDraw2(D3DPRIMITIVETYPE primType,
                            UINT StartVertex,
                            UINT PrimitiveCount,
                            UINT NumVertices,
                            BOOL bIndexPrimitive,
                            UINT StartIndex)
{
#if DBG
    if (this->rstates[D3DRS_FILLMODE] == D3DFILL_POINT &&
        m_dwRuntimeFlags & D3DRT_POINTSIZEPRESENT &&
        primType != D3DPT_POINTLIST)
    {
        D3D_INFO(0, "Result of drawing primitives with D3DFILL_POINT fill mode "
                    "and point size not equal 1.0f could be different on "
                    "different devices");
    }
    if ((m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE) == 0 &&
        !(m_pv->dwFlags & D3DPV_VBCALL))
    {
        D3D_THROW_FAIL("Need to call BeginScene before rendering.");
    }
    if (m_dwCurrentShaderHandle == 0)
    {
        D3D_THROW_FAIL("Invalid vertex shader handle (0x0)");
    }
    if (bIndexPrimitive && primType == D3DPT_POINTLIST)
    {
        D3D_THROW_FAIL("Indexed point lists are not supported");
    }
    if (*(FLOAT*)&rstates[D3DRS_PATCHSEGMENTS] > 1.f)
    {
        if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
        {
            D3D_THROW_FAIL("N-Patches are not supported with software vertex processing");
        }
        else
        if ((GetD3DCaps()->DevCaps & (D3DDEVCAPS_NPATCHES | D3DDEVCAPS_RTPATCHES)) == 0)
        {
            D3D_THROW_FAIL("N-Patches are not supported");
        }
    }
    BOOL bUserMemPrimitive = this->m_dwRuntimeFlags & D3DRT_USERMEMPRIMITIVE;
    if (D3DVSD_ISLEGACY(m_dwCurrentShaderHandle))
    {
        // DX7 FVF handles can work only from stream zero
        if (!bUserMemPrimitive)
        {
            if (m_pStream[0].m_pVB == NULL)
            {
                D3D_THROW_FAIL("Stream 0 should be initialized for FVF shaders");
            }
            DWORD dwFVF = m_pStream[0].m_pVB->GetFVF();
            if (dwFVF != 0 && dwFVF != m_dwCurrentShaderHandle)
            {
                D3D_THROW_FAIL("Current vertex shader doesn't match VB's FVF");
            }
            if (FVF_TRANSFORMED(m_dwCurrentShaderHandle))
            {
                if (!(m_pv->dwDeviceFlags & D3DDEV_DONOTCLIP) &&
                    m_pStream[0].m_pVB->GetBufferDesc()->Usage & D3DUSAGE_DONOTCLIP)
                {
                    D3D_THROW_FAIL("Vertex buffer with D3DUSAGE_DONOTCLIP is used with clipping");
                }
            }
            else
            {
                D3DVERTEXBUFFER_DESC Desc;
                static_cast<IDirect3DVertexBuffer8*>(m_pStream[0].m_pVB)->GetDesc(&Desc);
                if ((BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING) != 0 &&
                    (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) != 0 &&
                    (Desc.Usage & D3DUSAGE_SOFTWAREPROCESSING) == 0 &&
                    Desc.Pool != D3DPOOL_SYSTEMMEM)
                {
                    D3D_THROW_FAIL("Vertex buffer should have software usage or should be managed or should be in system memory");
                }
            }
            if (m_pStream[0].m_pVB->IsLocked())
            {
                D3D_THROW_FAIL("Vertex buffer must be unlocked during DrawPrimitive call");
            }
            if (*((FLOAT*)&rstates[D3DRS_PATCHSEGMENTS]) > 1.f && (m_pStream[0].m_pVB->GetBufferDesc()->Usage & D3DUSAGE_NPATCHES) == 0)
            {
                D3D_THROW_FAIL("Vertex buffers used for rendering N-Patches should have D3DUSAGE_NPATCHES set");
            }
        }
        // DX7 drivers cannot handle case when vertex size, computed from FVF, 
        // is different from the stream stride
        if (m_pStream[0].m_dwStride != ComputeVertexSizeFVF(m_dwCurrentShaderHandle))
        {
            D3D_THROW_FAIL("Stream 0 stride should match the stride, implied by the current vertex shader");
        }
        if (m_pStream[0].m_dwNumVertices < (StartVertex + NumVertices))
        {
            D3D_THROW_FAIL("Streams do not have required number of vertices");
        }
    }
    else
    {
        if (m_pv->dwDeviceFlags & D3DDEV_VERTEXSHADERS)
        {
            CVShaderCode * pCode = m_pCurrentShader->m_pCode;
            for (DWORD i=0; i < D3DHAL_TSS_MAXSTAGES; i++)
            {
                if (this->tsstates[i][D3DTSS_TEXCOORDINDEX] != i)
                {
                    D3D_ERR("Stage %d - Texture coordinate index in the stage "
                            "must be equal to the stage index when programmable"
                            " vertex pipeline is used", i);
                    D3D_THROW_FAIL("");
                }
                DWORD TexTransformFlags = tsstates[i][D3DTSS_TEXTURETRANSFORMFLAGS];
                if (pCode)
                {
                    if (TexTransformFlags & D3DTTFF_PROJECTED && 
                        !(m_dwRuntimeFlags & D3DRT_ONLY2FLOATSPERTEXTURE) &&
                        pCode->m_dwOutTexCoordSize[i] != 16)
                    {
                        D3D_ERR("Stage %d - Vertex shader must write XYZW to the "
                                "output texture register when texture projection is enabled", i);
                        D3D_THROW_FAIL("");
                    }
                }
                if ((TexTransformFlags & ~D3DTTFF_PROJECTED) != D3DTTFF_DISABLE)
                {
                    D3D_ERR("Stage %d - Count in D3DTSS_TEXTURETRANSFORMFLAGS "
                            "must be 0 when programmable pipeline is used", i);
                    D3D_THROW_FAIL("");
                }
            }
        }

        if (m_pCurrentShader->m_Declaration.m_bStreamTessPresent)
        {
            D3D_THROW_FAIL("Declaration with tesselator stream cannot be used with DrawPrimitive API");
        }
        if (((GetDDIType() < D3DDDITYPE_DX8)&&
              (m_pCurrentShader->m_Declaration.m_bLegacyFVF == FALSE))
             &&
             !(m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
            )
        {
            D3D_THROW_FAIL("Device does not support declarations");
        }
        // Check if
        // 1. streams, referenced by the current shader, are valid
        // 2. stride in the current shader and in the stream matches
        // 3. Compute max number of vertices the streams can contain
        CVStreamDecl* pStream;
        pStream = m_pCurrentShader->m_Declaration.m_pActiveStreams;
        while(pStream)
        {
            UINT index = pStream->m_dwStreamIndex;
            CVStream* pDeviceStream = &m_pStream[index];
            if (bUserMemPrimitive)
            {
                DXGASSERT(pDeviceStream->m_pData != NULL);
                if (index != 0)
                {
                    D3D_THROW_FAIL("DrawPrimitiveUP can use declaration only with stream 0");
                }
            }
            else
            {
                if (pDeviceStream->m_pVB == NULL)
                {
                    D3D_ERR("Stream %d is not set, but used by current declaration", index);
                    D3D_THROW_FAIL("");
                }
                if (pDeviceStream->m_pVB->IsLocked())
                {
                    D3D_ERR("Vertex buffer in stream %d must be unlocked during drawing", index);
                    D3D_THROW_FAIL("");
                }
                D3DVERTEXBUFFER_DESC Desc;
                static_cast<IDirect3DVertexBuffer8*>(pDeviceStream->m_pVB)->GetDesc(&Desc);
                if ((BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING) != 0 &&
                    (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) != 0 &&
                    (Desc.Usage & D3DUSAGE_SOFTWAREPROCESSING) == 0 &&
                    Desc.Pool != D3DPOOL_SYSTEMMEM)
                {
                    D3D_INFO(0, "In stream %d vertex buffer should have software usage or should be managed or should be in system memory", pStream->m_dwStreamIndex);
                    D3D_THROW_FAIL("");
                }
                if (*((FLOAT*)&rstates[D3DRS_PATCHSEGMENTS]) > 1.f && (pDeviceStream->m_pVB->GetBufferDesc()->Usage & D3DUSAGE_NPATCHES) == 0)
                {
                    D3D_THROW_FAIL("Vertex buffers used for rendering N-Patches should have D3DUSAGE_NPATCHES set");
                }
                // Validate matching of FVF in the vertex buffer and stream 
                // declaration
                if (m_pv->dwDeviceFlags & D3DDEV_VERTEXSHADERS)
                {
                    if (pDeviceStream->m_pVB->GetFVF() != 0)
                    {
                        D3D_INFO(1, "In stream %d vertex buffer with FVF is "
                                 "used with programmable vertex shader",
                                 pStream->m_dwStreamIndex);
                    }
                }
                else
                {
                    // Fixed function pipeline case
                    DWORD vbFVF = pDeviceStream->m_pVB->GetFVF();
                    DWORD streamFVF = pStream->m_dwFVF;
                    // VB FVF should be a superset of the stream FVF
                    if (vbFVF && ((vbFVF & streamFVF) != streamFVF))
                    {
                        D3D_INFO(0, "In stream %d vertex buffer FVF and declaration FVF do not match", 
                                 pStream->m_dwStreamIndex);
                    }
                }
            }
            // Stride 0 is allowed
            if (pDeviceStream->m_dwStride)
            {
                if (pDeviceStream->m_dwStride < pStream->m_dwStride)
                {
                    D3D_ERR("Vertex strides in stream %d is less than in the declaration", index);
                    D3D_THROW_FAIL("");
                }
                if (pDeviceStream->m_dwNumVertices < (StartVertex + NumVertices))
                {
                    D3D_ERR("Stream %d does not have required number of vertices",
                            pStream->m_dwStreamIndex);
                    D3D_THROW_FAIL("");
                }
            }
            pStream = (CVStreamDecl*)pStream->m_pNext;
        }
    }
    if (bIndexPrimitive)
    {
        if (!bUserMemPrimitive)
        {
            if (m_pIndexStream->m_pVBI == NULL)
            {
                D3D_THROW_FAIL("Index stream is not set");
            }
            if (m_pIndexStream->m_pVBI->IsLocked())
            {
                D3D_THROW_FAIL("Index buffer must be unlocked during drawing");
            }
            UINT NumIndices = GETVERTEXCOUNT(primType, PrimitiveCount);
            if (m_pIndexStream->m_dwNumVertices < (StartIndex + NumIndices))
            {
                D3D_THROW_FAIL("Index stream does not have required number of indices");
            }
            if (FVF_TRANSFORMED(m_dwCurrentShaderHandle) &&
                D3DVSD_ISLEGACY(m_dwCurrentShaderHandle))
            {
                if (!(m_pv->dwDeviceFlags & D3DDEV_DONOTCLIP) &&
                    (m_pIndexStream->m_pVBI->GetBufferDesc()->Usage & D3DUSAGE_DONOTCLIP))
                {
                    D3D_THROW_FAIL("Index buffer with D3DUSAGE_DONOTCLIP is used with clipping");
                }
            }
            else
            {
                D3DINDEXBUFFER_DESC Desc;
                static_cast<IDirect3DIndexBuffer8*>(m_pIndexStream->m_pVBI)->GetDesc(&Desc);
                if ((BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING) != 0 &&
                    (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) != 0 &&
                    (Desc.Usage & D3DUSAGE_SOFTWAREPROCESSING) == 0 &&
                    Desc.Pool != D3DPOOL_SYSTEMMEM)
                {
                    D3D_THROW_FAIL("Index buffer should have software usage or should be managed or should be in system memory");
                }
            }
            if (*((FLOAT*)&rstates[D3DRS_PATCHSEGMENTS]) > 1.f && (m_pIndexStream->m_pVBI->GetBufferDesc()->Usage & D3DUSAGE_NPATCHES) == 0)
            {
                D3D_THROW_FAIL("Index buffers used for rendering N-Patches should have D3DUSAGE_NPATCHES set");
            }
        }
        else
        {
            DXGASSERT(m_pIndexStream->m_pData != NULL);
        }
    }
#endif //DBG
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::DrawPoints"

void CD3DHal::DrawPoints(UINT StartVertex)
{
    BOOL bRecomputeOutputFVF = FALSE;
    // If point scale is enabled and device supports point sprites
    // we may need to add the point size to the output FVF
    if (rstates[D3DRS_POINTSCALEENABLE] &&
        !(m_dwRuntimeFlags & D3DRT_POINTSIZEINVERTEX) &&
        !(m_pv->dwDeviceFlags & D3DDEV_TRANSFORMEDFVF))
    {
        ForceFVFRecompute();
        bRecomputeOutputFVF = TRUE;
    }
    if (m_dwRuntimeFlags & D3DRT_DOPOINTSPRITEEMULATION)
    {
        // We do point sprite expansion when point size is not 1.0 in the
        // render state or it is present in vertices or we need to do point
        // scaling for untransformed vertices
        if ((m_dwRuntimeFlags & D3DRT_POINTSIZEPRESENT ||
            (rstates[D3DRS_POINTSCALEENABLE] &&
            !(m_pv->dwDeviceFlags & D3DDEV_TRANSFORMEDFVF))) &&
            // We do not do emulation for devices which supports point sprites,
            // but only when there is no point size in the FVF
            !(bRecomputeOutputFVF == FALSE &&
             (m_dwRuntimeFlags & D3DRT_POINTSIZEINVERTEX) == 0 &&
             m_dwRuntimeFlags & D3DRT_SUPPORTSPOINTSPRITES))
        {
            m_pv->dwDeviceFlags |= D3DDEV_DOPOINTSPRITEEMULATION;
            m_pDDI->PickProcessPrimitive();
        }
        else
        {
            if (m_pv->dwDeviceFlags & D3DDEV_TRANSFORMEDFVF &&
                (m_pv->dwDeviceFlags & D3DDEV_DONOTCLIP ||
                !(m_pv->dwDeviceFlags & D3DDEV_VBPROCVER)))
            {
                // Now we can call DDI directly, because no emulation is
                // necessary
                if (m_pStream[0].m_pVB)
                {
                    (*m_pDDI->GetDrawPrimFunction())(this, m_pv->primType,
                                                     StartVertex,
                                                     m_pv->dwNumPrimitives);
                }
                else
                {
                    m_pDDI->SetVertexShader(m_dwCurrentShaderHandle);
                    m_pDDI->SetStreamSource(0, &m_pStream[0]);
                    m_pDDI->DrawPrimitiveUP(m_pv->primType, m_pv->dwNumPrimitives);
                }
                return;
            }
        }
    }

    (this->*m_pfnPrepareToDraw)(StartVertex);
    (m_pDDI->*m_pDDI->m_pfnProcessPrimitive)(m_pv, StartVertex);

    if (bRecomputeOutputFVF)
    {
        ForceFVFRecompute();
    }
    m_pv->dwDeviceFlags &= ~D3DDEV_DOPOINTSPRITEEMULATION;
    m_pDDI->PickProcessPrimitive();
}
//-----------------------------------------------------------------------------
// Draw all primitive types except points
//
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveHal"

void CD3DHal_DrawPrimitive(CD3DBase* pBaseDevice, D3DPRIMITIVETYPE PrimitiveType,
                           UINT StartVertex, UINT PrimitiveCount)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(pBaseDevice);
    CD3DDDIDX6* pDDI = pBaseDevice->m_pDDI;

#if DBG
    UINT nVer = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
    pDevice->ValidateDraw2(PrimitiveType, StartVertex, PrimitiveCount, nVer,
                           FALSE);
#endif
    D3DFE_PROCESSVERTICES* pv = pDevice->m_pv;
    pv->primType = PrimitiveType;
    pv->dwNumPrimitives = PrimitiveCount;
    pv->dwNumVertices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
    pv->dwFlags &= D3DPV_PERSIST;
    (pDevice->*pDevice->m_pfnPrepareToDraw)(StartVertex);
    (pDDI->*pDDI->m_pfnProcessPrimitive)(pv, StartVertex);
}
//-----------------------------------------------------------------------------
// Draw only points
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::DrawPointsI"

void CD3DHal::DrawPointsI(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex,
                          UINT PrimitiveCount)
{
#if DBG
    UINT nVer = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
    ValidateDraw2(PrimitiveType, StartVertex, PrimitiveCount, nVer, FALSE);
#endif
    if (!(m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) ||
        CanCallDriver(this, PrimitiveType))
    {
        (*m_pfnDrawPrim)(this, PrimitiveType, StartVertex, PrimitiveCount);
    }
    else
    {
        m_pv->primType = PrimitiveType;
        m_pv->dwNumPrimitives = PrimitiveCount;
        m_pv->dwNumVertices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
        m_pv->dwFlags &= D3DPV_PERSIST;
        DrawPoints(StartVertex);
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal_DrawIndexedPrimitive"

void CD3DHal_DrawIndexedPrimitive(CD3DBase* pBaseDevice,
                                  D3DPRIMITIVETYPE PrimitiveType,
                                  UINT BaseIndex,
                                  UINT MinIndex, UINT NumVertices,
                                  UINT StartIndex,
                                  UINT PrimitiveCount)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(pBaseDevice);
    CVIndexStream* pIndexStream = pBaseDevice->m_pIndexStream;
    CD3DDDIDX6* pDDI = pBaseDevice->m_pDDI;

#if DBG
    pDevice->ValidateDraw2(PrimitiveType, MinIndex + pIndexStream->m_dwBaseIndex,
                           PrimitiveCount, NumVertices, TRUE, StartIndex);
#endif
    D3DFE_PROCESSVERTICES* pv = pDevice->m_pv;
    pIndexStream->m_pData = NULL;
    pv->primType = PrimitiveType;
    pv->dwNumPrimitives = PrimitiveCount;
    pv->dwFlags &= D3DPV_PERSIST;

    pv->dwNumVertices = NumVertices;
    pv->dwNumIndices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
    pv->dwIndexSize = pIndexStream->m_dwStride;
    UINT StartVertex = MinIndex + pIndexStream->m_dwBaseIndex;
    pDDI->SetIndexedPrimParams(StartIndex, MinIndex, NumVertices,
                               pIndexStream->m_dwBaseIndex);
    (pDevice->*pDevice->m_pfnPrepareToDraw)(StartVertex);
    (pDDI->*pDDI->m_pfnProcessIndexedPrimitive)(pv, StartVertex);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::DrawPrimitiveUPI"

void CD3DHal::DrawPrimitiveUPI(D3DPRIMITIVETYPE PrimType, UINT PrimCount)

{
#if DBG
    UINT nVer = GETVERTEXCOUNT(PrimType, PrimCount);
    ValidateDraw2(PrimType, 0, PrimCount, nVer, FALSE);
#endif
    m_pv->dwDeviceFlags &= ~D3DDEV_VBPROCVER;
    if (!(m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING))
    {
        if (m_dwRuntimeFlags & D3DRT_DONPATCHCONVERSION &&
            PrimType >= D3DPT_TRIANGLELIST)
        {
            CD3DHal_DrawNPatch(this, PrimType, 0, PrimCount);
        }
        else
        {
            m_pDDI->DrawPrimitiveUP(PrimType, PrimCount);
        }
    }
    else
    if (CanCallDriver(this, PrimType))
    {
        m_pDDI->SetVertexShader(m_dwCurrentShaderHandle);
        m_pDDI->SetStreamSource(0, &m_pStream[0]);
        m_pDDI->DrawPrimitiveUP(PrimType, PrimCount);
    }
    else
    {
        SetupStrides(m_pv, m_pStream[0].m_dwStride);
        m_pv->primType = PrimType;
        m_pv->dwNumPrimitives = PrimCount;
        m_pv->dwNumVertices = GETVERTEXCOUNT(PrimType, PrimCount);
        m_pv->dwFlags &= D3DPV_PERSIST;
        if (PrimType != D3DPT_POINTLIST)
        {
            (this->*m_pfnPrepareToDraw)(0);
            (m_pDDI->*m_pDDI->m_pfnProcessPrimitive)(m_pv, 0);
        }
        else
            DrawPoints(0);
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::DrawIndexedPrimitiveUPI"

void
CD3DHal::DrawIndexedPrimitiveUPI(D3DPRIMITIVETYPE PrimType,
                                 UINT MinVertexIndex,
                                 UINT NumVertices,
                                 UINT PrimCount)
{
#if DBG
    ValidateDraw2(PrimType, 0, PrimCount, NumVertices, TRUE);
#endif
    m_pv->dwDeviceFlags &= ~D3DDEV_VBPROCVER;
    if (!(m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING))
    {
        if (m_dwRuntimeFlags & D3DRT_DONPATCHCONVERSION &&
            PrimType >= D3DPT_TRIANGLELIST)
        {
            CD3DHal_DrawIndexedNPatch(this, PrimType, 0, MinVertexIndex, 
                                      NumVertices, 0, PrimCount);
        }
        else
        {
            m_pDDI->DrawIndexedPrimitiveUP(PrimType, MinVertexIndex, NumVertices,
                                           PrimCount);
        }
    }
    else
    if (CanCallDriver(this, PrimType))
    {
        m_pDDI->SetVertexShader(m_dwCurrentShaderHandle);
        m_pDDI->SetStreamSource(0, &m_pStream[0]);
        m_pDDI->SetIndices(m_pIndexStream);
        m_pDDI->DrawIndexedPrimitiveUP(PrimType, MinVertexIndex, NumVertices,
                                       PrimCount);
    }
    else
    {
        SetupStrides(m_pv, m_pStream[0].m_dwStride);
        m_pv->primType = PrimType;
        m_pv->dwNumPrimitives = PrimCount;
        m_pv->dwFlags &= D3DPV_PERSIST;

        m_pv->dwNumVertices = NumVertices;
        m_pv->dwNumIndices = GETVERTEXCOUNT(PrimType, PrimCount);
        m_pv->lpwIndices = (WORD*)m_pIndexStream->m_pData;
        m_pv->dwIndexSize = m_pIndexStream->m_dwStride;
        m_pDDI->SetIndexedPrimParams(0, MinVertexIndex,
                                     MinVertexIndex + NumVertices, 0);
        (this->*m_pfnPrepareToDraw)(MinVertexIndex);
        (m_pDDI->*m_pDDI->m_pfnProcessIndexedPrimitive)(m_pv, MinVertexIndex);
    }
}
//-----------------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "SetupFVFDataVVM"

void SetupFVFDataVVM(CD3DHal* pDev)
{
    D3DFE_PROCESSVERTICES* pv = pDev->m_pv;
// We have to restore texture stage indices if previous primitive
// re-mapped them
    if (pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(pDev);
    }

	// Input FVF has no meaning for vertex shaders, but it is used for validaion
    pv->dwVIDIn = 0;

// Compute output FVF

    CVShaderCode * pCode = pDev->m_pCurrentShader->m_pCode;

    pv->dwVIDOut          = pCode->m_dwOutFVF;
    pv->dwOutputSize      = pCode->m_dwOutVerSize;
    pv->nOutTexCoord      = pCode->m_nOutTexCoord;
    // We use offsets, computed by the vertex shader
    pv->pointSizeOffsetOut = pCode->m_dwPointSizeOffset;
    pv->diffuseOffsetOut = pCode->m_dwDiffuseOffset;
    pv->specularOffsetOut = pCode->m_dwSpecularOffset;
    pv->fogOffsetOut = pCode->m_dwFogOffset;
    pv->texOffsetOut = pCode->m_dwTextureOffset;
    pv->dwTextureCoordSizeTotal = 0;
    for (DWORD i=0; i < pv->nOutTexCoord; i++)
    {
        DWORD dwSize = pCode->m_dwOutTexCoordSize[i];
        pv->dwTextureCoordSize[i] = dwSize;
        pv->dwTextureCoordSizeTotal += dwSize;
    }
}
//----------------------------------------------------------------------
void CD3DHal::SetupFVFData()
{
    CD3DHal::SetupFVFDataCommon();
    if (!(m_pv->dwVIDIn & D3DFVF_NORMAL))
        m_pv->dwDeviceFlags &= ~D3DDEV_NORMALINCAMERASPACE;
}
//---------------------------------------------------------------------
// Computes the following data
//  - dwTextureCoordOffset[] offset of every input texture coordinates

static __inline void ComputeInpTexCoordOffsets(DWORD dwNumTexCoord,
                                               DWORD dwFVF,
                                               DWORD *pdwTextureCoordOffset)
{
    // Compute texture coordinate size
    DWORD dwTextureFormats = dwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            pdwTextureCoordOffset[i] = i << 3;
        }
    }
    else
    {
        DWORD dwOffset = 0;
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            pdwTextureCoordOffset[i] = dwOffset;
            dwOffset += g_TextureSize[dwTextureFormats & 3];
            dwTextureFormats >>= 2;
        }
    }
    return;
}
//---------------------------------------------------------------------
// Returns 2 bits of FVF texture format for the texture index
//
static inline DWORD FVFGetTextureFormat(DWORD dwFVF, DWORD dwTextureIndex)
{
    return (dwFVF >> (dwTextureIndex*2 + 16)) & 3;
}
//---------------------------------------------------------------------
// Returns texture format bits shifted to the right place
//
static inline DWORD FVFMakeTextureFormat(DWORD dwNumberOfCoordinates, DWORD dwTextureIndex)
{
    return g_dwTextureFormat[dwNumberOfCoordinates] << ((dwTextureIndex << 1) + 16);
}
//---------------------------------------------------------------------
inline DWORD GetOutTexCoordSize(DWORD *pdwStage, DWORD dwInpTexCoordSize)
{
    // Low byte has texture coordinate count
    const DWORD dwTextureTransformFlags = pdwStage[D3DTSS_TEXTURETRANSFORMFLAGS] & 0xFF;
    if (dwTextureTransformFlags == 0)
        return dwInpTexCoordSize;
    else
        return (dwTextureTransformFlags << 2);
}
//----------------------------------------------------------------------
// pDevI->nOutTexCoord should be initialized to the number of input texture coord sets
//
void EvalTextureTransforms(LPD3DHAL pDevI, DWORD dwTexTransform,
                           DWORD *pdwOutTextureSize, DWORD *pdwOutTextureFormat)
{
    D3DFE_PROCESSVERTICES* pv = pDevI->m_pv;
    DWORD dwOutTextureSize = 0;         // Used to compute output vertex size
    DWORD dwOutTextureFormat = 0;       // Used to compute output texture FVF
    // The bits are used to find out how the texture coordinates are used.
    const DWORD __USED_BY_TRANSFORM  = 1;
    const DWORD __USED               = 2;
    const DWORD __USED_TEXTURE_PROJECTION   = 4;
    // The low 16 bits are for _USED bits. The high 16 bits will hold
    // re-mapped texture index for a stage
    DWORD dwTexCoordUsage[D3DDP_MAXTEXCOORD];
    memset(dwTexCoordUsage, 0, sizeof(dwTexCoordUsage));

    // Re-mapping buffer will contain only stages that use texture
    // This variable is used to count them
    pDevI->dwNumTextureStagesToRemap = 0;
    DWORD dwNewIndex = 0;           // Used to generate output index
    // We need offsets for every input texture coordinate, because
    // we could access them in random order.
    // Offsets are not needed for strided input
    DWORD   dwTextureCoordOffset[D3DDP_MAXTEXCOORD];
    if (!(pv->dwDeviceFlags & D3DDEV_STRIDE))
    {
        ComputeInpTexCoordOffsets(pv->nTexCoord, pv->dwVIDIn, dwTextureCoordOffset);
    }
    DWORD dwOutTextureCoordSize[D3DDP_MAXTEXCOORD];
    // TRUE, if we do not do texture projection and transform for a stage, 
    // because the stage does not have corresponding texture coordinates in the
    // input
    BOOL bIgnoreTexCoord = FALSE;
    // Go through all texture stages and find those wich use texture coordinates
    for (DWORD i=0; i < D3DDP_MAXTEXCOORD; i++)
    {
        if (pDevI->tsstates[i][D3DTSS_COLOROP] == D3DTOP_DISABLE)
            break;

        DWORD dwIndex = pDevI->tsstates[i][D3DTSS_TEXCOORDINDEX];
        DWORD dwInpTextureFormat;
        DWORD dwInpTexSize;
        LPD3DFE_TEXTURESTAGE pStage = &pDevI->textureStageToRemap[pDevI->dwNumTextureStagesToRemap];
        DWORD dwTexGenMode = dwIndex & ~0xFFFF;
        pStage->dwInpOffset = 0;
        dwIndex = dwIndex & 0xFFFF; // Remove texture generation mode
        if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
        {
            dwInpTextureFormat = D3DFVF_TEXCOORDSIZE3(dwIndex);
            dwInpTexSize = 3*sizeof(D3DVALUE);
            pv->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
                pv->dwDeviceFlags |= D3DDEV_NORMALINCAMERASPACE | D3DDEV_POSITIONINCAMERASPACE;
            else
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL)
                pv->dwDeviceFlags |= D3DDEV_NORMALINCAMERASPACE;
            else
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION)
                pv->dwDeviceFlags |= D3DDEV_POSITIONINCAMERASPACE;
        }
        else
        {
            if (dwIndex >= pv->nTexCoord)
            {
                // This could happen when input vertex does not have texture 
                // coordinates, but it is OK, because texture pointer in the 
                // stage could be  NULL, or the stage does not use texture, or 
                // pixel shader is used.
                // It is too complex and error prone to check all cases when 
                // this is an user error, so we just make this case to work.
                dwIndex = 0;
                dwInpTexSize = sizeof(float)*2; 
                dwInpTextureFormat = 0;
                // Ignore special texture coordinate processing for this stage
                bIgnoreTexCoord = TRUE; 
                // Disable texture transform for the stage
                dwTexTransform &= ~1;
                pStage->dwInpOffset = 0;
            }
            else
            {
                dwInpTexSize = pv->dwTextureCoordSize[dwIndex];
                dwInpTextureFormat = FVFGetTextureFormat(pv->dwVIDIn, dwIndex);
                pStage->dwInpOffset = dwTextureCoordOffset[dwIndex];
            }
        }
        pStage->dwInpCoordIndex = dwIndex;
        pStage->dwTexGenMode = dwTexGenMode;
        pStage->dwOrgStage = i;
        pStage->bDoTextureProjection = FALSE;
        DWORD dwOutTexCoordSize;    // Size of the texture coord set in bytes for this stage
        if (dwTexTransform & 1)
        {
            pv->dwDeviceFlags |= D3DDEV_TEXTURETRANSFORM;
            pStage->pmTextureTransform = &pv->mTexture[i];
            dwOutTexCoordSize = GetOutTexCoordSize((DWORD*)&pDevI->tsstates[i], dwInpTexSize);
            // If we have to add or remove some coordinates we go through
            // the re-mapping path
            if (dwOutTexCoordSize != dwInpTexSize)
                pv->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
            pStage->dwTexTransformFuncIndex = MakeTexTransformFuncIndex
                                             (dwInpTexSize >> 2, dwOutTexCoordSize >> 2);
        }
        else
        {
            pStage->pmTextureTransform = NULL;
            dwOutTexCoordSize = dwInpTexSize;
            pStage->dwTexTransformFuncIndex = 0;
        }
        if (NeedTextureProjection(pv, i) && !bIgnoreTexCoord)
        {
            // Remove one float from the output
            dwOutTexCoordSize -= 4; 
            // Set re-mapping so we do not complicate simple case
            pv->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
            // Texture projection is required for the stage
            pStage->bDoTextureProjection = TRUE;
        }
        if ((dwTexCoordUsage[dwIndex] & 0xFFFF) == 0)
        {
            // Texture coordinate set is used first time
            if (dwTexTransform & 1)
                dwTexCoordUsage[dwIndex] |= __USED_BY_TRANSFORM;
            dwTexCoordUsage[dwIndex] |= __USED;
            if (pStage->bDoTextureProjection)
                dwTexCoordUsage[dwIndex] |= __USED_TEXTURE_PROJECTION;
        }
        else
        {
            // Texture coordinate set is used second or more time
            if (dwTexTransform & 1)
            {
                // This set is used by two texture transforms or a
                // texture transform and without it, so we have to
                // generate an additional output texture coordinate
                dwTexCoordUsage[dwIndex] |= __USED_BY_TRANSFORM;
                pv->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
            }
            else
            {
                if (dwTexCoordUsage[dwIndex] & __USED_BY_TRANSFORM)
                {
                    // This set is used by two texture transforms or a
                    // texture transform and without it, so we have to
                    // generate an additional output texture coordinate
                    pv->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
                }
                else
                // We can re-use the same input texture coordinate if there is no 
                // texture generation and texture projection flag is the same for both 
                // stages
                if (dwTexGenMode == 0 && 
                    (pStage->bDoTextureProjection == ((dwTexCoordUsage[dwIndex] & __USED_TEXTURE_PROJECTION) != 0)))
                {
                    DWORD dwOutIndex = dwTexCoordUsage[dwIndex] >> 16;
                    pStage->dwOutCoordIndex = dwOutIndex;
                    // Mark the stage as not to be used in the vertex processing loop
                    pStage->dwInpOffset = 0xFFFFFFFF;
                    goto l_NoNewOutTexCoord;
                }
            }
        }
        // If we are here, we have to generate new output texture coordinate set
        pStage->dwOutCoordIndex = dwNewIndex;
        dwTexCoordUsage[dwIndex] |= dwNewIndex << 16;
        dwOutTextureSize += dwOutTexCoordSize;
        dwOutTextureCoordSize[dwNewIndex] = dwOutTexCoordSize;
        dwOutTextureFormat |= FVFMakeTextureFormat(dwOutTexCoordSize >> 2, dwNewIndex);
        dwNewIndex++;
l_NoNewOutTexCoord:
        pDevI->dwNumTextureStagesToRemap++;
        dwTexTransform >>= 1;
    }
    if (pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        // Now, when we have to do re-mapping, we have to set new output texture
        // coordinate set sizes and we need to remove stages, which do not produce
        // output texture coordinates.
        DWORD dwNumTextureStages = 0;
        for (DWORD i=0; i < pDevI->dwNumTextureStagesToRemap; i++)
        {
            if (pDevI->textureStageToRemap[i].dwInpOffset != 0xFFFFFFFF)
            {
                pv->textureStage[dwNumTextureStages] = pDevI->textureStageToRemap[i];
                pv->dwTextureCoordSize[dwNumTextureStages] = dwOutTextureCoordSize[dwNumTextureStages];
                dwNumTextureStages++;
            }
            pv->dwNumTextureStages = dwNumTextureStages;
        }
        pv->nOutTexCoord = dwNewIndex;
    }
    *pdwOutTextureSize = dwOutTextureSize;
    *pdwOutTextureFormat = dwOutTextureFormat;
}
//----------------------------------------------------------------------
// Sets texture transform pointer for every input texture coordinate set
//
void SetupTextureTransforms(LPD3DHAL pDevI)
{
    D3DFE_PROCESSVERTICES* pv = pDevI->m_pv;
    // Set texture transforms to NULL in case when some texture coordinates
    // are not used by texture stages
    memset(pv->pmTexture, 0, sizeof(pv->pmTexture));

    for (DWORD i=0; i < pDevI->dwNumTextureStagesToRemap; i++)
    {
        LPD3DFE_TEXTURESTAGE pStage = &pDevI->textureStageToRemap[i];
        pv->pmTexture[pStage->dwInpCoordIndex] = pStage->pmTextureTransform;
    }
}
//----------------------------------------------------------------------
// Computes the following device data
//  - dwVIDOut, based on input FVF id and device settings
//  - nTexCoord
//  - dwTextureCoordSizeTotal
//  - dwTextureCoordSize[] array, based on the input FVF id
//  - dwOutputSize, based on the output FVF id
//
// The function is called from ProcessVertices and DrawPrimitives code paths
//
// The following variables should be set in the pDevI:
//  - dwVIDIn
//
// Number of texture coordinates is set based on dwVIDIn. ValidateFVF should
// make sure that it is not greater than supported by the driver
// Last settings for dwVIDOut and dwVIDIn are saved to speed up processing
//
#undef  DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetupFVFDataCommon"

void CD3DHal::SetupFVFDataCommon()
{
    HRESULT ret;
    this->dwFEFlags &= ~D3DFE_FVF_DIRTY;
    // We have to restore texture stage indices if previous primitive
    // re-mapped them
    if (m_pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(this);
    }

    // Compute number of the input texture coordinates
    m_pv->nTexCoord = FVF_TEXCOORD_NUMBER(m_pv->dwVIDIn);

    // Compute size of input texture coordinates

    m_pv->dwTextureCoordSizeTotal = ComputeTextureCoordSize(m_pv->dwVIDIn,
                                        m_pv->dwInpTextureCoordSize);

    // This size is the same for input and output FVFs in case when we do not have to
    // expand number of texture coordinates
    for (DWORD i=0; i < m_pv->nTexCoord; i++)
        m_pv->dwTextureCoordSize[i] = m_pv->dwInpTextureCoordSize[i];

    m_pv->nOutTexCoord = m_pv->nTexCoord;

    // Setup input vertex offsets
    UpdateGeometryLoopData(m_pv);

    if (FVF_TRANSFORMED(m_pv->dwVIDIn))
    {
        // Set up vertex pointers
        m_pv->dwVIDOut = m_pv->dwVIDIn;
        ComputeOutputVertexOffsets(m_pv);
        m_pv->dwOutputSize = ComputeVertexSizeFVF(m_pv->dwVIDOut);
        return;
    }

    // Compute output FVF

    m_pv->dwVIDOut = D3DFVF_XYZRHW;
    if (m_pv->dwDeviceFlags & D3DDEV_DONOTSTRIPELEMENTS &&
        !(m_pv->dwFlags & D3DPV_VBCALL))
    {
        m_pv->dwVIDOut |= D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
    }
    else
    {
        // If normal present we have to compute specular and duffuse
        // Otherwise set these bits the same as input.
        // Not that normal should not be present for XYZRHW position type
        if (m_pv->dwDeviceFlags & D3DDEV_LIGHTING)
            m_pv->dwVIDOut |= D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
        else
            m_pv->dwVIDOut |= m_pv->dwVIDIn &
                              (D3DFVF_DIFFUSE | D3DFVF_SPECULAR);
        // Always set specular flag if vertex fog is enabled
        if (this->rstates[D3DRENDERSTATE_FOGENABLE] &&
            m_pv->lighting.fog_mode != D3DFOG_NONE)
        {
            m_pv->dwVIDOut |= D3DFVF_SPECULAR;
        }
        else
        // Clear specular flag if specular disabled and we do not have
        // specular in the input
        if (!this->rstates[D3DRENDERSTATE_SPECULARENABLE] &&
            !(m_pv->dwVIDIn & D3DFVF_SPECULAR))
        {
            m_pv->dwVIDOut &= ~D3DFVF_SPECULAR;
        }
    }
    if (m_pv->dwVIDIn & D3DFVF_PSIZE ||
        m_pv->primType == D3DPT_POINTLIST &&
        this->rstates[D3DRS_POINTSCALEENABLE])
    {
        m_pv->dwVIDOut |= D3DFVF_PSIZE;
    }

    // Compute number of the output texture coordinates

    // Transform enable bits
    m_pv->dwDeviceFlags &= ~D3DDEV_TEXTURETRANSFORM;

    DWORD dwTexTransform = m_pv->dwFlags2 & __FLAGS2_TEXTRANSFORM;

    // When texture transform is enabled or we need to do projected texture 
    // emulation or texture coordinates are taken from the vertex data (texgen),
    // output texture coordinates could be generated.
    // So we go and evaluate texture stages
    if ((m_pv->dwFlags2 & (__FLAGS2_TEXTRANSFORM | __FLAGS2_TEXPROJ) 
        && (m_pv->nTexCoord > 0)) ||
        m_pv->dwFlags2 & __FLAGS2_TEXGEN)
    {
        DWORD dwOutTextureSize;     // Used to compute output vertex size
        DWORD dwOutTextureFormat;   // Used to compute output texture FVF
        // There are texture transforms.
        // Now we find out if some of the texture coordinates are used two
        // or more times and used by a texture transform. In this case we
        // have expand number of output texture coordinates.
        EvalTextureTransforms(this, dwTexTransform,
                                    &dwOutTextureSize,
                                    &dwOutTextureFormat);
        if (m_pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
        {
            // For ProcessVertices calls user should set texture stages and
            // wrap modes himself
            if (!(m_pv->dwFlags & D3DPV_VBCALL))
            {
                // dwVIDIn is used to force re-compute FVF in the
                // SetTextureStageState. so we save and restore it.
                DWORD dwVIDInSaved = m_pv->dwVIDIn;
                // Re-map indices in the texture stages and wrap modes
                DWORD dwOrgWrapModes[D3DDP_MAXTEXCOORD];
                memcpy(dwOrgWrapModes, &this->rstates[D3DRENDERSTATE_WRAP0],
                       sizeof(dwOrgWrapModes));
                for (DWORD i=0; i < this->dwNumTextureStagesToRemap; i++)
                {
                    LPD3DFE_TEXTURESTAGE pStage = &this->textureStageToRemap[i];
                    DWORD dwOutIndex = pStage->dwOutCoordIndex;
                    DWORD dwInpIndex = pStage->dwInpCoordIndex;
                    if (dwOutIndex != dwInpIndex || pStage->dwTexGenMode)
                    {
                        DWORD dwState = D3DRENDERSTATE_WRAP0 + dwOutIndex;
                        pStage->dwOrgWrapMode = dwOrgWrapModes[dwOutIndex];
                        DWORD dwValue = dwOrgWrapModes[dwInpIndex];
                        // We do not call UpdateInternaState because it
                        // will call ForceRecomputeFVF and we do not want this.
                        this->rstates[dwState] = dwValue;

                        m_pDDI->SetRenderState((D3DRENDERSTATETYPE)dwState, dwValue);

                        // We do not call UpdateInternalTextureStageState because it
                        // will call ForceRecomputeFVF and we do not want this.
                        m_pDDI->SetTSS(pStage->dwOrgStage, D3DTSS_TEXCOORDINDEX, dwOutIndex);
                        // We do not call UpdateInternalTextureStageState because it
                        // will call ForceRecomputeFVF and we do not want this.
                        // We set some invalid value to the internal array, because otherwise
                        // a new SetTextureStageState could be filtered as redundant
                        tsstates[pStage->dwOrgStage][D3DTSS_TEXCOORDINDEX] = 0xFFFFFFFF;
                    }
                }
                m_pv->dwVIDIn = dwVIDInSaved;
            }
            else
            {
            }
            m_pv->dwVIDOut |= dwOutTextureFormat;
            m_pv->dwTextureCoordSizeTotal = dwOutTextureSize;
        }
        else
        {   // We do not do re-mapping but we have to make correspondence between
            // texture sets and texture transforms
            SetupTextureTransforms(this);

            //  Copy input texture formats
            m_pv->dwVIDOut |= m_pv->dwVIDIn & 0xFFFF0000;
        }
    }
    else
    {
        //  Copy input texture formats
        m_pv->dwVIDOut |= m_pv->dwVIDIn & 0xFFFF0000;
        // When we have texture coordinate set with number of floats different
        // from 2 and device does not support them, we "fix" the texture format
        if (m_pv->dwVIDOut & 0xFFFF0000)
        {
            if (m_dwRuntimeFlags & D3DRT_ONLY2FLOATSPERTEXTURE)
            {
                m_pv->dwVIDOut &= ~0xFFFF0000;
                for (DWORD i=0; i < m_pv->nOutTexCoord; i++)
                    m_pv->dwTextureCoordSize[i] = 8;
                m_pv->dwTextureCoordSizeTotal = m_pv->nTexCoord * 8;
            }
        }
    }

    if (m_pv->dwDeviceFlags & D3DDEV_DONOTSTRIPELEMENTS)
    {
        if (m_pv->nOutTexCoord == 0 && !(m_pv->dwFlags & D3DPV_VBCALL))
        {
            m_pv->dwTextureCoordSize[0] = 0;
            m_pv->dwVIDOut |= (1 << D3DFVF_TEXCOUNT_SHIFT);
        }
    }
    // Set up number of output texture coordinates
    m_pv->dwVIDOut |= (m_pv->nOutTexCoord << D3DFVF_TEXCOUNT_SHIFT);
    if ((m_pv->dwVIDOut & 0xFFFF0000) &&
        (GetDDIType() < D3DDDITYPE_DX7))
    {
        D3D_THROW_FAIL("Texture format bits in the output FVF for this device should be 0");
    }

    if (!(m_pv->dwFlags & D3DPV_VBCALL))
    {
        m_pv->dwOutputSize = ComputeVertexSizeFVF(m_pv->dwVIDOut);
        ComputeOutputVertexOffsets(m_pv);
    }


    // In case if COLORVERTEX is TRUE, the vertexAlpha could be overriden
    // by vertex alpha
    m_pv->lighting.alpha = (DWORD)m_pv->lighting.materialAlpha;
    m_pv->lighting.alphaSpecular = (DWORD)m_pv->lighting.materialAlphaS;

    this->dwFEFlags |= D3DFE_VERTEXBLEND_DIRTY | D3DFE_FRONTEND_DIRTY;
}
//-----------------------------------------------------------------------------
// Sets input vertex pointers and output offsets for legacy vertex shaders for
// the programmable vertex shaders
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::PrepareToDrawVVM"

void CD3DHal::PrepareToDrawVVM(UINT StartVertex)
{
    if (m_dwRuntimeFlags & D3DRT_SHADERDIRTY)
    {
        SetupFVFDataVVM(this);
        m_dwRuntimeFlags &= ~D3DRT_SHADERDIRTY;
        m_pDDI->SetVertexShader(m_pv->dwVIDOut);
    }
    // Initialize vertex pointers used in the vertex loop
    CVertexDesc* pVD = m_pv->VertexDesc;
    for (DWORD i = m_pv->dwNumUsedVertexDescs; i; i--)
    {
        CVStream* pStream = pVD->pStream;
        DWORD dwStride = pStream->m_dwStride;
        pVD->pMemory = pStream->Data() + pVD->dwVertexOffset +
                       StartVertex * dwStride;
        pVD->dwStride = dwStride;
        pVD++;
    }
}
//-----------------------------------------------------------------------------
// Sets input vertex pointers and output offsets for legacy vertex shaders
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::PrepareToDrawLegacy"

void CD3DHal::PrepareToDrawLegacy(UINT StartVertex)
{
    // For legacy FVFs we draw using Stream[0]
    m_pv->position.lpvData = m_pStream[0].Data() +
                             m_pStream[0].m_dwStride * StartVertex;
    if (m_dwRuntimeFlags & D3DRT_SHADERDIRTY)
    {
        SetupFVFData();
        m_pDDI->SetVertexShader(m_pv->dwVIDOut);
        m_dwRuntimeFlags &= ~D3DRT_SHADERDIRTY;
    }
}
//-----------------------------------------------------------------------------
// Sets input vertex pointers and output offsets for the fixed-function pipeline
// and non-legacy vertex declarations
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::PrepareToDraw"

void CD3DHal::PrepareToDraw(UINT StartVertex)
{
    // Initialize strided data pointers used in the vertex loop
#if DBG
    {
        // Set all NULL pointers to check if they are initialized by the 
        // declaration
        for (DWORD i=0; i < __NUMELEMENTS; i++)
        {
            m_pv->elements[i].lpvData = NULL;
        }
    }
#endif
    CVertexDesc* pVD = m_pv->VertexDesc;
    for (DWORD i = m_pv->dwNumUsedVertexDescs; i; i--)
    {
        CVStream* pStream = pVD->pStream;
        DWORD dwStride = pStream->m_dwStride;
        pVD->pElement->lpvData  = pStream->Data() +
                                  pVD->dwVertexOffset +
                                  StartVertex * dwStride;
        pVD->pElement->dwStride = dwStride;
        pVD++;
    }
    if (m_dwRuntimeFlags & D3DRT_SHADERDIRTY)
    {
        SetupFVFData();
        m_pDDI->SetVertexShader(m_pv->dwVIDOut);
        m_dwRuntimeFlags &= ~D3DRT_SHADERDIRTY;
    }
}
//-----------------------------------------------------------------------------
//
//          Object implementations
//
//---------------------------------------------------------------------
const DWORD CVShader::FIXEDFUNCTION = 1;
const DWORD CVShader::SOFTWARE      = 2;

void CheckForNull(LPVOID p, DWORD line, char* file)
{
    if (p == NULL)
        D3D_THROW_LINE(E_OUTOFMEMORY, "Not enough memory", line, file);
}

//-----------------------------------------------------------------------------
void Copy_FLOAT1(LPVOID pInputStream, UINT stride, UINT count,
                      VVM_WORD * pVertexRegister)
{
    for (UINT i=0; i < count; i++)
    {
        pVertexRegister->x = *(float*)pInputStream;
        pVertexRegister->y = 0;
        pVertexRegister->z = 0;
        pVertexRegister->w = 1;
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}

void Copy_FLOAT2(LPVOID pInputStream, UINT stride, UINT count,
                      VVM_WORD * pVertexRegister)
{
    for (UINT i=0; i < count; i++)
    {
        pVertexRegister->x = ((float*)pInputStream)[0];
        pVertexRegister->y = ((float*)pInputStream)[1];
        pVertexRegister->z = 0;
        pVertexRegister->w = 1;
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}

void Copy_FLOAT3(LPVOID pInputStream, UINT stride, UINT count,
                      VVM_WORD * pVertexRegister)
{
    for (UINT i=0; i < count; i++)
    {
        pVertexRegister->x = ((float*)pInputStream)[0];
        pVertexRegister->y = ((float*)pInputStream)[1];
        pVertexRegister->z = ((float*)pInputStream)[2];
        pVertexRegister->w = 1;
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}

void Copy_FLOAT4(LPVOID pInputStream, UINT stride, UINT count,
                      VVM_WORD * pVertexRegister)
{
    for (UINT i=0; i < count; i++)
    {
        pVertexRegister->x = ((float*)pInputStream)[0];
        pVertexRegister->y = ((float*)pInputStream)[1];
        pVertexRegister->z = ((float*)pInputStream)[2];
        pVertexRegister->w = ((float*)pInputStream)[3];
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}

void Copy_D3DCOLOR(LPVOID pInputStream, UINT stride, UINT count,
                          VVM_WORD * pVertexRegister)
{
    const float scale = 1.0f/255.f;
    for (UINT i=0; i < count; i++)
    {
        const DWORD v = ((DWORD*)pInputStream)[0];
        pVertexRegister->x = scale * RGBA_GETRED(v);
        pVertexRegister->y = scale * RGBA_GETGREEN(v);
        pVertexRegister->z = scale * RGBA_GETBLUE(v);
        pVertexRegister->w = scale * RGBA_GETALPHA(v);
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}

void Copy_UBYTE4(LPVOID pInputStream, UINT stride, UINT count,
                 VVM_WORD * pVertexRegister)
{
    for (UINT i=0; i < count; i++)
    {
        const BYTE* v = (BYTE*)pInputStream;
        pVertexRegister->x = v[0];
        pVertexRegister->y = v[1];
        pVertexRegister->z = v[2];
        pVertexRegister->w = v[3];
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}

void Copy_SHORT2(LPVOID pInputStream, UINT stride, UINT count,
                 VVM_WORD * pVertexRegister)
{
    for (UINT i=0; i < count; i++)
    {
        const short* v = (short*)pInputStream;
        pVertexRegister->x = v[0];
        pVertexRegister->y = v[1];
        pVertexRegister->z = 0;
        pVertexRegister->w = 1;
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}

void Copy_SHORT4(LPVOID pInputStream, UINT stride, UINT count,
                 VVM_WORD * pVertexRegister)
{
    for (UINT i=0; i < count; i++)
    {
        const short* v = (short*)pInputStream;
        pVertexRegister->x = v[0];
        pVertexRegister->y = v[1];
        pVertexRegister->z = v[2];
        pVertexRegister->w = v[3];
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}
//-----------------------------------------------------------------------------
// Based on register and data type the function computes FVF dword and presence 
// bits:
// - Bits in the dwFVF2 are used to detect that some field is not entered twice
// - pnFloats is used to compute number of floats with position
//

// Bits for dwFVF2. Order is the same as in the FVF!!!
//
static const DWORD __POSITION_PRESENT       = 1 << 0;
static const DWORD __BLENDWEIGHT_PRESENT    = 1 << 1;
static const DWORD __BLENDINDICES_PRESENT   = 1 << 2;
static const DWORD __NORMAL_PRESENT         = 1 << 3;
static const DWORD __PSIZE_PRESENT          = 1 << 4;
static const DWORD __DIFFUSE_PRESENT        = 1 << 5;
static const DWORD __SPECULAR_PRESENT       = 1 << 6;
// __TEXTURE0_PRESENT must start from 8th bit
static const DWORD __TEXTURE0_PRESENT       = 1 << 8;   
static const DWORD __TEXTURE1_PRESENT       = 1 << 9;
static const DWORD __TEXTURE2_PRESENT       = 1 << 10;
static const DWORD __TEXTURE3_PRESENT       = 1 << 11;
static const DWORD __TEXTURE4_PRESENT       = 1 << 12;
static const DWORD __TEXTURE5_PRESENT       = 1 << 13;
static const DWORD __TEXTURE6_PRESENT       = 1 << 14;
static const DWORD __TEXTURE7_PRESENT       = 1 << 15;
static const DWORD __POSITION2_PRESENT      = 1 << 16;
static const DWORD __NORMAL2_PRESENT        = 1 << 17;

// Check if any bit left from the CurrentBit is set in PresenceBits
// PresenceBits are updated by CurrentBit.
//
inline void CheckOrder(
    DWORD* pPresenceBits,       // Presence bits for the declaration
    DWORD CurrentBit, 
    BOOL* pFlag,                // Out of order flag for the declaration
    char* s)                    // Name of the field
{
    if (*pPresenceBits & CurrentBit)
    {
        char msg[80];
        sprintf(msg, "%s specified twice in the declaration", s);
        D3D_THROW_FAIL(msg);
    }
    if (*pPresenceBits & ~(CurrentBit | (CurrentBit-1)))
    {
        *pFlag = FALSE;
    }
    *pPresenceBits |= CurrentBit;
}

void UpdateFVF(DWORD dwRegister, DWORD dwDataType,
               DWORD* pdwFVF,       // FVF for the current declaration
               DWORD* pdwFVF2,      // Presence bits for the current stream
               DWORD* pnFloats, 
               BOOL* pbLegacyFVF)
{
    switch (dwRegister)
    {
    case D3DVSDE_POSITION:
        if (dwDataType != D3DVSDT_FLOAT3)
            D3D_THROW_FAIL("Position register must be FLOAT3 for fixed-function pipeline");

        CheckOrder(pdwFVF2, __POSITION_PRESENT, pbLegacyFVF, "Position");
        *pdwFVF |= D3DFVF_XYZ;
        break;
    case D3DVSDE_POSITION2:
        if (dwDataType != D3DVSDT_FLOAT3)
            D3D_THROW_FAIL("Position2 register must be FLOAT3 for fixed-function pipeline");
        CheckOrder(pdwFVF2, __POSITION2_PRESENT, pbLegacyFVF, "Position2");
        break;
    case D3DVSDE_BLENDWEIGHT:
        {
            CheckOrder(pdwFVF2, __BLENDWEIGHT_PRESENT, pbLegacyFVF, "Blend weight");
            switch (dwDataType)
            {
            case D3DVSDT_FLOAT1:
                (*pnFloats)++;
                break;
            case D3DVSDT_FLOAT2:
                (*pnFloats) += 2;
                break;
            case D3DVSDT_FLOAT3:
                (*pnFloats) += 3;
                break;
            case D3DVSDT_FLOAT4:
                (*pnFloats) += 4;
                break;
            default:
                D3D_THROW_FAIL("Invalid data type set for vertex blends");
                break;
            }
            break;
        }
    case D3DVSDE_NORMAL:
        CheckOrder(pdwFVF2, __NORMAL_PRESENT, pbLegacyFVF, "Normal");
        if (dwDataType != D3DVSDT_FLOAT3)
            D3D_THROW_FAIL("Normal register must be FLOAT3 for fixed-function pipeline");
        *pdwFVF |= D3DFVF_NORMAL;
        break;
    case D3DVSDE_NORMAL2:
        CheckOrder(pdwFVF2, __NORMAL2_PRESENT, pbLegacyFVF, "Normal2");
        if (dwDataType != D3DVSDT_FLOAT3)
            D3D_THROW_FAIL("Normal2 register must be FLOAT3 for fixed-function pipeline");
        break;
    case D3DVSDE_PSIZE:
        CheckOrder(pdwFVF2, __PSIZE_PRESENT, pbLegacyFVF, "Point size");
        if (dwDataType != D3DVSDT_FLOAT1)
            D3D_THROW_FAIL("Point size register must be FLOAT1 for fixed-function pipeline");
        *pdwFVF |= D3DFVF_PSIZE;
        break;
    case D3DVSDE_DIFFUSE:
        CheckOrder(pdwFVF2, __DIFFUSE_PRESENT, pbLegacyFVF, "Diffuse");
        if (dwDataType != D3DVSDT_D3DCOLOR)
            D3D_THROW_FAIL("Diffuse register must be D3DCOLOR for fixed-function pipeline");
        *pdwFVF |= D3DFVF_DIFFUSE;
        break;
    case D3DVSDE_SPECULAR:
        CheckOrder(pdwFVF2, __SPECULAR_PRESENT, pbLegacyFVF, "Specular");
        if (dwDataType != D3DVSDT_D3DCOLOR)
            D3D_THROW_FAIL("Specular register must be D3DCOLOR for fixed-function pipeline");
        *pdwFVF |= D3DFVF_SPECULAR;
        break;
    case D3DVSDE_BLENDINDICES:
        CheckOrder(pdwFVF2, __BLENDINDICES_PRESENT, pbLegacyFVF, "Blend indices");
        if (dwDataType != D3DVSDT_UBYTE4)
            D3D_THROW_FAIL("Blend indices register must be D3DVSDT_UBYTE4 for fixed-function pipeline");
        // Update number of floats after position
        (*pnFloats)++;
        break;
    case D3DVSDE_TEXCOORD0:
    case D3DVSDE_TEXCOORD1:
    case D3DVSDE_TEXCOORD2:
    case D3DVSDE_TEXCOORD3:
    case D3DVSDE_TEXCOORD4:
    case D3DVSDE_TEXCOORD5:
    case D3DVSDE_TEXCOORD6:
    case D3DVSDE_TEXCOORD7:
        {
            DWORD dwTextureIndex = dwRegister - D3DVSDE_TEXCOORD0;
            DWORD dwBit = __TEXTURE0_PRESENT  << dwTextureIndex;
            CheckOrder(pdwFVF2, dwBit, pbLegacyFVF, "Texture");
            switch (dwDataType)
            {
            case D3DVSDT_FLOAT1:
                *pdwFVF |= D3DFVF_TEXCOORDSIZE1(dwTextureIndex);
                break;
            case D3DVSDT_FLOAT2:
                *pdwFVF |= D3DFVF_TEXCOORDSIZE2(dwTextureIndex);
                break;
            case D3DVSDT_FLOAT3:
                *pdwFVF |= D3DFVF_TEXCOORDSIZE3(dwTextureIndex);
                break;
            case D3DVSDT_FLOAT4:
                *pdwFVF |= D3DFVF_TEXCOORDSIZE4(dwTextureIndex);
                break;
            default:
                D3D_THROW_FAIL("Invalid data type set for texture register");
                break;
            }
            break;
        }
    default:
        D3D_THROW_FAIL("Invalid register set for fixed-function pipeline");
        break;
    }
}
//-----------------------------------------------------------------------------
void CVStreamDecl::Parse(CD3DBase* pDevice,
                         DWORD CONST ** ppToken, BOOL bFixedFunction,
                         DWORD* pdwFVF, DWORD* pdwFVF2, DWORD* pnFloats, 
                         BOOL* pbLegacyFVF, UINT usage, BOOL bTessStream)
{
    CONST DWORD* pToken = *ppToken;
    // Used to compute stream stride and offset in bytes for each stream element
    DWORD dwCurrentOffset = 0;
    // FVF and FVF2 for this stream only. Used to check if data in the stream 
    // form a FVF subset
    DWORD dwFVF2 = 0;
    DWORD dwFVF  = 0;
    DWORD nFloats = 0;
    // Set to TRUE, if data in the stream is an FVF subset
    BOOL  bFVFSubset = TRUE;
    
    while (TRUE)
    {
        DWORD dwToken = *pToken++;
        const DWORD dwTokenType = D3DVSD_GETTOKENTYPE(dwToken);
        switch (dwTokenType)
        {
        case D3DVSD_TOKEN_NOP:  break;
        case D3DVSD_TOKEN_TESSELLATOR:
            {
                *pbLegacyFVF = FALSE;
                bFVFSubset = FALSE;
                const DWORD dwDataType = D3DVSD_GETDATATYPE(dwToken);
                switch (dwDataType)
                {
                case D3DVSDT_FLOAT2:
                case D3DVSDT_FLOAT3:
                    break;
                }
                break;
            }
        case D3DVSD_TOKEN_STREAMDATA:
            {
                switch (D3DVSD_GETDATALOADTYPE(dwToken))
                {
                case D3DVSD_LOADREGISTER:
                    {
#if DBG
                        if (m_dwNumElements >= __NUMELEMENTS)
                        {
                            D3D_ERR("D3DVSD_TOKEN_STREAMDATA:");
                            D3D_ERR("   Number of vertex elements in a stream is greater than max supported");
                            D3D_ERR("   Max supported number of elements is %d", __NUMELEMENTS);
                            D3D_THROW_FAIL("");
                        }
#endif
                        CVElement* pElement = &m_Elements[m_dwNumElements++];
                        const DWORD dwDataType = D3DVSD_GETDATATYPE(dwToken);
                        const DWORD dwRegister = D3DVSD_GETVERTEXREG(dwToken);
                        pElement->m_dwOffset = dwCurrentOffset;
                        pElement->m_dwRegister = dwRegister;
                        pElement->m_dwDataType = dwDataType;
                        switch (dwDataType)
                        {
                        case D3DVSDT_FLOAT1:
                            dwCurrentOffset += sizeof(float);
                            pElement->m_pfnCopy = (LPVOID)Copy_FLOAT1;
                            break;
                        case D3DVSDT_FLOAT2:
                            dwCurrentOffset += sizeof(float) * 2;
                            pElement->m_pfnCopy = (LPVOID)Copy_FLOAT2;
                            break;
                        case D3DVSDT_FLOAT3:
                            dwCurrentOffset += sizeof(float) * 3;
                            pElement->m_pfnCopy = (LPVOID)Copy_FLOAT3;
                            break;
                        case D3DVSDT_FLOAT4:
                            dwCurrentOffset += sizeof(float) * 4;
                            pElement->m_pfnCopy = (LPVOID)Copy_FLOAT4;
                            break;
                        case D3DVSDT_D3DCOLOR:
                            dwCurrentOffset += sizeof(DWORD);
                            pElement->m_pfnCopy = (LPVOID)Copy_D3DCOLOR;
                            break;
                        case D3DVSDT_UBYTE4:
#if DBG
                            // Do not fail when software processing will be used                       
                            if (pDevice->GetD3DCaps()->VertexProcessingCaps & D3DVTXPCAPS_NO_VSDT_UBYTE4 &&
                                !((usage & D3DUSAGE_SOFTWAREPROCESSING &&
                                  pDevice->BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING)  ||
                                  (pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING)))
                            {
                                D3D_THROW_FAIL("Device does not support UBYTE4 data type");
                            }
#endif // DBG
                            dwCurrentOffset += sizeof(DWORD);
                            pElement->m_pfnCopy = (LPVOID)Copy_UBYTE4;
                            break;
                        case D3DVSDT_SHORT2:
                            dwCurrentOffset += sizeof(short) * 2;
                            pElement->m_pfnCopy = (LPVOID)Copy_SHORT2;
                            break;
                        case D3DVSDT_SHORT4:
                            dwCurrentOffset += sizeof(short) * 4;
                            pElement->m_pfnCopy = (LPVOID)Copy_SHORT4;
                            break;
                        default:
                            D3D_ERR("D3DVSD_TOKEN_STREAMDATA: Invalid element data type: %10x", dwToken);
                            D3D_THROW_FAIL("");
                        }
                        // Compute input FVF for fixed-function pipeline
                        if (bFixedFunction)
                        {
                            // Update FVF for the declaration
                            UpdateFVF(dwRegister, dwDataType, pdwFVF, pdwFVF2,
                                      pnFloats, pbLegacyFVF);
                            // Update FVF for the stream
                            UpdateFVF(dwRegister, dwDataType, &dwFVF, &dwFVF2,
                                      &nFloats, &bFVFSubset);
                        }
                        else
                            if (dwRegister >= D3DVS_INPUTREG_MAX_V1_1)
                                D3D_THROW_FAIL("D3DVSD_TOKEN_STREAMDATA: Invalid register number");
                        break;
                    }
                case D3DVSD_SKIP:
                    {
                        if (bFixedFunction)
                        {
                            D3D_THROW_FAIL("D3DVSD_SKIP is not allowed for fixed-function pipeline");
                        }
                        const DWORD dwCount = D3DVSD_GETSKIPCOUNT(dwToken);
                        dwCurrentOffset += dwCount * sizeof(DWORD);
                        break;
                    }
                default:
                    D3D_ERR("Invalid data load type: %10x", dwToken);
                    D3D_THROW_FAIL("");
                }
                break;
            }
        default:
            {
                *ppToken = pToken - 1;
                m_dwStride = dwCurrentOffset;
                goto l_exit;
            }
        } // switch
    } // while
l_exit:
    if (bFixedFunction && !bTessStream)
    {
#if DBG
        m_dwFVF = dwFVF;
#endif
        if (!bFVFSubset)
        {
            D3D_THROW_FAIL("For fixed-function pipeline each stream has to be an FVF subset");
        }
        if (dwFVF2 & (__POSITION2_PRESENT   | __NORMAL2_PRESENT | 
                      __PSIZE_PRESENT       | __BLENDINDICES_PRESENT))
        {
            *pbLegacyFVF = FALSE;
        }
    }
}
//-----------------------------------------------------------------------------
CVDeclaration::CVDeclaration(DWORD dwNumStreams)
{
    m_pConstants = NULL;
    m_pConstantsTail = NULL;
    m_pActiveStreams = NULL;
    m_pActiveStreamsTail = NULL;
    m_dwInputFVF = 0;
    m_bLegacyFVF = TRUE;
    m_dwNumStreams = dwNumStreams;
    m_bStreamTessPresent = FALSE;
}
//-----------------------------------------------------------------------------
CVDeclaration::~CVDeclaration()
{
    delete m_pActiveStreams;
    delete m_pConstants;
}
//-----------------------------------------------------------------------------
void CVDeclaration::Parse(CD3DBase* pDevice, CONST DWORD* pTok, BOOL bFixedFunction, 
                          DWORD* pDeclSize, UINT usage)
{
    DWORD dwFVF  = 0;   // FVF for fixed-function pipeline
    DWORD dwFVF2 = 0;   // Texture presence bits (8 bits)
    DWORD nFloats = 0;  // Number of floats after position

    DWORD   dwStreamPresent = 0;    // Bit is set if a stream is used
    m_bLegacyFVF = TRUE;

    CONST DWORD* pToken = pTok;
    while (TRUE)
    {
        DWORD dwToken = *pToken++;
        const DWORD dwTokenType = D3DVSD_GETTOKENTYPE(dwToken);
        switch (dwTokenType)
        {
        case D3DVSD_TOKEN_NOP:  break;
        case D3DVSD_TOKEN_STREAM:
            {
                CVStreamDecl StreamTess;

                if( D3DVSD_ISSTREAMTESS(dwToken) )
                {
                    m_bLegacyFVF = FALSE;
                    if( m_bStreamTessPresent )
                    {
                        D3D_THROW(D3DERR_INVALIDCALL, "Tesselator Stream has already been defined in the declaration");
                    }

                    m_bStreamTessPresent = TRUE;
                    // 
                    // For now simply skip over the Tess tokens in the
                    // Runtime.
                    StreamTess.Parse(pDevice, &pToken, bFixedFunction, &dwFVF, &dwFVF2,
                                     &nFloats, &m_bLegacyFVF, usage, TRUE);
                }
                else
                {
                    DWORD dwStream = D3DVSD_GETSTREAMNUMBER(dwToken);
                    if (dwStream >= m_dwNumStreams)
                    {
                        D3D_THROW_FAIL("Stream number is too big");
                    }

                    if (dwStreamPresent & (1 << dwStream))
                    {
                        D3D_THROW(D3DERR_INVALIDCALL, "Stream is already defined"
                                  "in the declaration");
                    }

                    dwStreamPresent |= 1 << dwStream;

                    // There are more than one stream present, so cant be
                    // handled by legacy FVF.
                    if( dwStreamPresent & (dwStreamPresent - 1) )
                        m_bLegacyFVF = FALSE;


                    CVStreamDecl* pStream = new CVStreamDecl;
                    if (pStream == NULL)
                    {
                        D3D_THROW(E_OUTOFMEMORY, "Not enough memory");
                    }
                    try
                    {
                        pStream->Parse(pDevice, &pToken, bFixedFunction, &dwFVF, &dwFVF2,
                                       &nFloats, &m_bLegacyFVF, usage);
                        pStream->m_dwStreamIndex = dwStream;
                        if (m_pActiveStreams == NULL)
                        {
                            m_pActiveStreams = pStream;
                            m_pActiveStreamsTail = pStream;
                        }
                        else
                        {
                            m_pActiveStreamsTail->Append(pStream);
                            m_pActiveStreamsTail = pStream;
                        }
                    }
                    catch (HRESULT e)
                    {
                        delete pStream;
                        throw e;
                    }
                }
                break;
            }
        case D3DVSD_TOKEN_STREAMDATA:
            {
                D3D_THROW_FAIL("D3DVSD_TOKEN_STREAMDATA could only be used after D3DVSD_TOKEN_STREAM");
            }
        case D3DVSD_TOKEN_CONSTMEM:
            {
                CVConstantData * cd = new CVConstantData;
                CheckForNull(cd, __LINE__, __FILE__);

                cd->m_dwCount = D3DVSD_GETCONSTCOUNT(dwToken);
                cd->m_dwAddress = D3DVSD_GETCONSTADDRESS(dwToken);

                UINT ValidationCount;
                if (usage & D3DUSAGE_SOFTWAREPROCESSING)
                    ValidationCount = D3DVS_CONSTREG_MAX_V1_1;
                else
                    ValidationCount = pDevice->GetD3DCaps()->MaxVertexShaderConst;

                if ((cd->m_dwCount + cd->m_dwAddress) > ValidationCount)
                    D3D_THROW_FAIL("D3DVSD_TOKEN_CONSTMEM writes outside constant memory");

                const DWORD dwSize = cd->m_dwCount << 2;    // number of DWORDs
                cd->m_pData = new DWORD[dwSize];
                CheckForNull(cd->m_pData, __LINE__, __FILE__);

                memcpy(cd->m_pData, pToken, dwSize << 2);
                if (m_pConstants == NULL)
                {
                    m_pConstants = cd;
                    m_pConstantsTail = cd;
                }
                else
                {
                    m_pConstantsTail->Append(cd);
                    m_pConstantsTail = cd;
                }
                pToken += dwSize;
                break;
            }
        case D3DVSD_TOKEN_EXT:
            {
                // Skip extension info
                DWORD dwCount = D3DVSD_GETEXTCOUNT(dwToken);
                pToken += dwCount;
                break;
            }
        case D3DVSD_TOKEN_END:
            {
                goto l_End;
            }
        default:
            {
                D3D_ERR("Invalid declaration token: %10x", dwToken);
                D3D_THROW_FAIL("");
            }
        }
    }
l_End:
    // Validate input for the fixed-function pipeline
    if (bFixedFunction && !m_bStreamTessPresent)
    {
        m_dwInputFVF = dwFVF & 0xFFFF0FFF;   // Remove float count
        switch (nFloats)
        {
        case 0: m_dwInputFVF |= D3DFVF_XYZ;     break;
        case 1: m_dwInputFVF |= D3DFVF_XYZB1;   break;
        case 2: m_dwInputFVF |= D3DFVF_XYZB2;   break;
        case 3: m_dwInputFVF |= D3DFVF_XYZB3;   break;
        case 4: m_dwInputFVF |= D3DFVF_XYZB4;   break;
        case 5: m_dwInputFVF |= D3DFVF_XYZB5;   break;
        default:
            D3D_THROW_FAIL("Too many floats after position");
        }
        // Compute number of texture coordinates
        DWORD nTexCoord = 0;
        DWORD dwTexturePresenceBits = (dwFVF2 >> 8) & 0xFF;
        while (dwTexturePresenceBits & 1)
        {
            dwTexturePresenceBits >>= 1;
            nTexCoord++;
        }
        // There should be no gaps in texture coordinates
        if (dwTexturePresenceBits)
            D3D_THROW_FAIL("Texture coordinates should have no gaps");

        m_dwInputFVF |= nTexCoord << D3DFVF_TEXCOUNT_SHIFT;

        // Position must be set
        if ((dwFVF & D3DFVF_POSITION_MASK) != D3DFVF_XYZ)
            D3D_THROW_FAIL("Position register must be set");
    }
    if (pDeclSize != NULL)
    {
        *pDeclSize = (DWORD) (pToken - pTok) << 2;
    }
}
//---------------------------------------------------------------------
CVStream::~CVStream()
{
    if (m_pVB)
        m_pVB->DecrementUseCount();
}
//---------------------------------------------------------------------
CVIndexStream::~CVIndexStream()
{
    if (m_pVBI)
        m_pVBI->DecrementUseCount();
}
//---------------------------------------------------------------------
DWORD g_PrimToVerCount[7][2] =
{
    {0, 0},         // Illegal
    {1, 0},         // D3DPT_POINTLIST     = 1,
    {2, 0},         // D3DPT_LINELIST      = 2,
    {1, 1},         // D3DPT_LINESTRIP     = 3,
    {3, 0},         // D3DPT_TRIANGLELIST  = 4,
    {1, 2},         // D3DPT_TRIANGLESTRIP = 5,
    {1, 2},         // D3DPT_TRIANGLEFAN   = 6,
};
//-----------------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::CreateShader(CVElement* pElements, DWORD dwNumElements,
                                     DWORD* pdwShaderCode, DWORD dwOutputFVF,
                                     CPSGPShader** ppPSGPShader)
{
    *ppPSGPShader = NULL;
    try
    {
        *ppPSGPShader = m_VertexVM.CreateShader(pElements, dwNumElements,
                                                pdwShaderCode);
        if (*ppPSGPShader == NULL)
            return D3DERR_INVALIDCALL;
    }
    D3D_CATCH;
    return D3D_OK;
}
//-----------------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::SetActiveShader(CPSGPShader* pPSGPShader)
{
    return m_VertexVM.SetActiveShader((CVShaderCode*)pPSGPShader);
}
//-----------------------------------------------------------------------------
// Load vertex shader constants
HRESULT
D3DFE_PVFUNCSI::LoadShaderConstants(DWORD start, DWORD count, LPVOID buffer)
{
    return m_VertexVM.SetData(D3DSPR_CONST, start, count, buffer);
}
//-----------------------------------------------------------------------------
// Get vertex shader constants
HRESULT
D3DFE_PVFUNCSI::GetShaderConstants(DWORD start, DWORD count, LPVOID buffer)
{
    return m_VertexVM.GetData(D3DSPR_CONST, start, count, buffer);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetVertexShaderConstant"

HRESULT D3DAPI
CD3DHal::GetVertexShaderConstant(DWORD Register, LPVOID pData, DWORD count)
{
    API_ENTER(this);
#if DBG
    // Validate Parameters
    if (!VALID_WRITEPTR(pData, 4 * sizeof(DWORD) * count))
    {
        D3D_ERR("Invalid constant data pointer. GetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
	if ((GetD3DCaps()->VertexShaderVersion == D3DVS_VERSION(0,0)) && 
		(BehaviorFlags() & (D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE)))
	{
        D3D_ERR("No programmable vertex shaders are supported by this device. GetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
	}
    UINT ValidationCount;
    if (BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING)
        ValidationCount = max(m_MaxVertexShaderConst, D3DVS_CONSTREG_MAX_V1_1);
    else
    if (BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING)
        ValidationCount = D3DVS_CONSTREG_MAX_V1_1;
    else
        ValidationCount = m_MaxVertexShaderConst;
    if((Register + count) > ValidationCount)
    {
        D3D_ERR("Not that many constant registers in the vertex machine. GetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    HRESULT hr;
    if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING ||
        ((count + Register) <= D3DVS_CONSTREG_MAX_V1_1))
    {
        // For software vertex processing we store constant registers in PSGP if
        // possible
        return m_pv->pGeometryFuncs->GetShaderConstants(Register, count, 
                                                        const_cast<VOID*>(pData));
    }
    else
    {
        if (Register >= D3DVS_CONSTREG_MAX_V1_1)
        {
            // When all modified registers are above software limit, we use Microsoft 
            // internal array
            hr = GeometryFuncsGuaranteed->GetShaderConstants(Register, count, 
                                                              const_cast<VOID*>(pData));
        }
        else
        {
            // Part of constant data is taken from PSGP array and part from 
            // Microsoft's array
            UINT FirstCount = D3DVS_CONSTREG_MAX_V1_1 - Register;
            hr = m_pv->pGeometryFuncs->GetShaderConstants(Register, FirstCount, 
                                                           const_cast<VOID*>(pData));
            if (FAILED(hr))
            {
                return hr;
            }
            return GeometryFuncsGuaranteed->GetShaderConstants(D3DVS_CONSTREG_MAX_V1_1, 
                                                               Register + count - D3DVS_CONSTREG_MAX_V1_1,
                                                               &((DWORD*)pData)[FirstCount*4]);
        }
        return hr;
    }
    return m_pv->pGeometryFuncs->GetShaderConstants(Register, count, pData);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetVertexShader"

HRESULT D3DAPI
CD3DHal::GetVertexShader(LPDWORD pdwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    HRESULT        ret = D3D_OK;
#if DBG
    // Validate Parameters
    if (!VALID_WRITEPTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR("Invalid handle pointer. GetVertexShader failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    *pdwHandle = m_dwCurrentShaderHandle;
    return ret;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetPixelShader"

HRESULT D3DAPI
CD3DHal::GetPixelShader(LPDWORD pdwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    HRESULT        ret = D3D_OK;

#if DBG
    // Validate Parameters
    if (!VALID_WRITEPTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR("Invalid handle pointer. GetPixelShader failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    *pdwHandle = m_dwCurrentPixelShaderHandle;
    return ret;
}
#if DBG
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::ValidateRTPatch"

void CD3DHal::ValidateRTPatch()
{
    if (D3DVSD_ISLEGACY(m_dwCurrentShaderHandle))
    {
        if (m_pStream[0].m_pVB == 0)
        {
            D3D_THROW_FAIL("Draw[RT]Patch should have streams set");
        }
        if ((m_pStream[0].m_pVB->GetBufferDesc()->Usage & D3DUSAGE_RTPATCHES) == 0)
        {
            D3D_THROW_FAIL("Vertex buffers used for rendering RT-Patches should have D3DUSAGE_RTPATCHES set");
        }
    }
    else
    {
        CVStreamDecl* pStream;
        pStream = m_pCurrentShader->m_Declaration.m_pActiveStreams;
        while(pStream)
        {
            UINT index = pStream->m_dwStreamIndex;
            CVStream* pDeviceStream = &m_pStream[index];
            if (pDeviceStream->m_pVB == 0)
            {
                D3D_THROW_FAIL("Draw[RT]Patch should have streams set");
            }
            if ((pDeviceStream->m_pVB->GetBufferDesc()->Usage & D3DUSAGE_RTPATCHES) == 0)
            {
                D3D_THROW_FAIL("Vertex buffers used for rendering RT-Patches should have D3DUSAGE_RTPATCHES set");
            }
            pStream = (CVStreamDecl*)pStream->m_pNext;
        }
    }
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\rgblt.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   rgblt.cpp
 *  Content:    Direct3D lighting
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "light.h"
#include "drawprim.hpp"

// Functions to use when lighting is done in the camera space
LIGHT_VERTEX_FUNC_TABLE lightVertexTable =
{
    Directional7,
    PointSpot7,
    DirectionalFirst,
    DirectionalNext,
    PointSpotFirst,
    PointSpotNext
};

// Functions to use when lighting is done in the model space
static LIGHT_VERTEX_FUNC_TABLE lightVertexTableModel =
{
    Directional7Model,
    PointSpot7Model,
    DirectionalFirstModel,
    DirectionalNextModel,
    PointSpotFirstModel,
    PointSpotNextModel
};
//-------------------------------------------------------------------------
SpecularTable* CreateSpecularTable(D3DVALUE power)
{
    SpecularTable* spec;
    int     i;
    float  delta = 1.0f/255.0f;
    float  v;

    D3DMalloc((void**)&spec, sizeof(SpecularTable));

    if (spec == NULL)
        return NULL;

    spec->power = power;

    v = 0.0;
    for (i = 0; i < 256; i++)
    {
        spec->table[i] = powf(v, power);
        v += delta;
    }

    for (; i < 260; i++)
        spec->table[i] = 1.0f;

    return spec;
}
//-------------------------------------------------------------------------
static void inverseRotateVector(D3DVECTOR* d,
                                D3DVECTOR* v, D3DMATRIXI* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    d->x = RLDDIFMul16(vx, M->_11) + RLDDIFMul16(vy, M->_12) + RLDDIFMul16(vz, M->_13);
    d->y = RLDDIFMul16(vx, M->_21) + RLDDIFMul16(vy, M->_22) + RLDDIFMul16(vz, M->_23);
    d->z = RLDDIFMul16(vx, M->_31) + RLDDIFMul16(vy, M->_32) + RLDDIFMul16(vz, M->_33);
}

static void inverseTransformVector(D3DVECTOR* result,
                                   D3DVECTOR* v, D3DMATRIXI* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    vx -= M->_41; vy -= M->_42; vz -= M->_43;
    result->x = RLDDIFMul16(vx, M->_11) + RLDDIFMul16(vy, M->_12) + RLDDIFMul16(vz, M->_13);
    result->y = RLDDIFMul16(vx, M->_21) + RLDDIFMul16(vy, M->_22) + RLDDIFMul16(vz, M->_23);
    result->z = RLDDIFMul16(vx, M->_31) + RLDDIFMul16(vy, M->_32) + RLDDIFMul16(vz, M->_33);
}
//-----------------------------------------------------------------------
// Every time the world matrix is modified or lights data is changed the
// lighting vectors have to change to match the model space of the new data
// to be rendered.
// Every time light data is changed or material data is changed or lighting
// state is changed, some pre-computed lighting values sould be updated
//
void D3DFE_UpdateLights(LPD3DHAL lpDevI)
{
    D3DFE_PROCESSVERTICES* pv = lpDevI->m_pv;
    D3DFE_LIGHTING& LIGHTING = pv->lighting;
    D3DI_LIGHT  *light = LIGHTING.activeLights;
    D3DVECTOR   t;
    BOOL        specular;       // TRUE, if specular component sould be computed
    D3DMATERIAL8 *mat = &LIGHTING.material;

    if (lpDevI->dwFEFlags & (D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY))
    {

        SpecularTable* spec;

        for (spec = LIST_FIRST(&lpDevI->specular_tables);
             spec;
             spec = LIST_NEXT(spec,list))
        {
            if (spec->power == pv->lighting.material.Power)
                break;
        }
        if (spec == NULL)
        {
            spec = CreateSpecularTable(pv->lighting.material.Power);
            if (spec == NULL)
            {
                D3D_ERR("Failed to allocate internal specular table");
                throw E_OUTOFMEMORY;
            }
            LIST_INSERT_ROOT(&lpDevI->specular_tables, spec, list);
        }
        lpDevI->specular_table = spec;

        if (pv->lighting.material.Power > D3DVAL(0.001))
            pv->lighting.specThreshold = D3DVAL(pow(0.001, 1.0/pv->lighting.material.Power));
        else
            pv->lighting.specThreshold = 0;

        if (lpDevI->specular_table && pv->dwDeviceFlags & D3DDEV_SPECULARENABLE)
            specular = TRUE;
        else
            specular = FALSE;

        LIGHTING.materialAlpha = FTOI(D3DVAL(255) * mat->Diffuse.a);
        if (LIGHTING.materialAlpha < 0)
            LIGHTING.materialAlpha = 0;
        else
            if (LIGHTING.materialAlpha > 255)
                LIGHTING.materialAlpha = 255 << 24;
            else LIGHTING.materialAlpha <<= 24;

        LIGHTING.materialAlphaS = FTOI(D3DVAL(255) * mat->Specular.a);
        if (LIGHTING.materialAlphaS < 0)
            LIGHTING.materialAlphaS = 0;
        else
            if (LIGHTING.materialAlphaS > 255)
                LIGHTING.materialAlphaS = 255 << 24;
            else LIGHTING.materialAlphaS <<= 24;

        LIGHTING.currentSpecTable = lpDevI->specular_table->table;

        LIGHTING.diffuse0.r = LIGHTING.ambientSceneScaled.r * mat->Ambient.r;
        LIGHTING.diffuse0.g = LIGHTING.ambientSceneScaled.g * mat->Ambient.g;
        LIGHTING.diffuse0.b = LIGHTING.ambientSceneScaled.b * mat->Ambient.b;
        LIGHTING.diffuse0.r += mat->Emissive.r * D3DVAL(255);
        LIGHTING.diffuse0.g += mat->Emissive.g * D3DVAL(255);
        LIGHTING.diffuse0.b += mat->Emissive.b * D3DVAL(255);
        int r,g,b;
        r = (int)FTOI(LIGHTING.diffuse0.r);
        g = (int)FTOI(LIGHTING.diffuse0.g);
        b = (int)FTOI(LIGHTING.diffuse0.b);
        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;
        LIGHTING.dwDiffuse0 = (r << 16) + (g << 8) + b;
    }

    pv->lighting.model_eye.x = (D3DVALUE)0;
    pv->lighting.model_eye.y = (D3DVALUE)0;
    pv->lighting.model_eye.z = (D3DVALUE)0;
    pv->lighting.directionToCamera.x =  0;
    pv->lighting.directionToCamera.y =  0;
    pv->lighting.directionToCamera.z = -1;
    if (pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)
    {
        inverseTransformVector(&pv->lighting.model_eye,
                               &pv->lighting.model_eye,
                               &pv->mWV[0]);
        lpDevI->lightVertexFuncTable = &lightVertexTableModel;
        inverseRotateVector(&pv->lighting.directionToCamera,
                            &pv->lighting.directionToCamera,
                            &pv->mWV[0]);
    }
    else
    {
        lpDevI->lightVertexFuncTable = &lightVertexTable;
    }
    while (light)
    {
        // Whenever light type is changed the D3DFE_NEED_TRANSFORM_LIGHTS should be set
        if (lpDevI->dwFEFlags & D3DFE_NEED_TRANSFORM_LIGHTS)
        {
            if (light->type != D3DLIGHT_DIRECTIONAL)
            { // Point and Spot lights
                light->lightVertexFunc = lpDevI->lightVertexFuncTable->pfnPointSpot;
                light->pfnLightFirst = lpDevI->lightVertexFuncTable->pfnPointSpotFirst;
                light->pfnLightNext  = lpDevI->lightVertexFuncTable->pfnPointSpotNext;
                if (!(pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                {
                    // Transform light position to the camera space
                    VecMatMul(&light->position,
                              (D3DMATRIX*)&pv->view,
                              &light->model_position);
                }
                else
                {
                    inverseTransformVector(&light->model_position, &light->position,
                                           &pv->world[0]);
                }
            }
            else
            { // Directional light
                light->lightVertexFunc = lpDevI->lightVertexFuncTable->pfnDirectional;
                light->pfnLightFirst = lpDevI->lightVertexFuncTable->pfnDirectionalFirst;
                light->pfnLightNext  = lpDevI->lightVertexFuncTable->pfnDirectionalNext;
            }

            if (light->type != D3DLIGHT_POINT)
            {
                // Light direction is flipped to be the direction TO the light
                if (!(pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                {
                    // Transform light direction to the camera space
                    VecMatMul3(&light->direction,
                               (D3DMATRIX*)&pv->view,
                               &light->model_direction);
                    VecNormalizeFast(light->model_direction);
                }
                else
                {
                    inverseRotateVector(&light->model_direction, &light->direction,
                                           &pv->world[0]);
                }
                VecNeg(light->model_direction, light->model_direction);
                // For the infinite viewer the half vector is constant
                if (!(pv->dwDeviceFlags & D3DDEV_LOCALVIEWER))
                {
                    VecAdd(light->model_direction, pv->lighting.directionToCamera,
                           light->halfway);
                    VecNormalizeFast(light->halfway);
                }
            }
        }

        if (lpDevI->dwFEFlags & (D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY))
        {
            light->diffuseMat.r = D3DVAL(255) * mat->Diffuse.r * light->diffuse.r;
            light->diffuseMat.g = D3DVAL(255) * mat->Diffuse.g * light->diffuse.g;
            light->diffuseMat.b = D3DVAL(255) * mat->Diffuse.b * light->diffuse.b;


            if (!(light->flags & D3DLIGHTI_AMBIENT_IS_ZERO))
            {
                light->ambientMat.r = D3DVAL(255) * mat->Ambient.r * light->ambient.r;
                light->ambientMat.g = D3DVAL(255) * mat->Ambient.g * light->ambient.g;
                light->ambientMat.b = D3DVAL(255) * mat->Ambient.b * light->ambient.b;
            }

            if (specular && !(light->flags & D3DLIGHTI_SPECULAR_IS_ZERO))
            {
                light->flags |= D3DLIGHTI_COMPUTE_SPECULAR;
                light->specularMat.r = D3DVAL(255) * mat->Specular.r * light->specular.r;
                light->specularMat.g = D3DVAL(255) * mat->Specular.g * light->specular.g;
                light->specularMat.b = D3DVAL(255) * mat->Specular.b * light->specular.b;
            }
            else
                light->flags &= ~D3DLIGHTI_COMPUTE_SPECULAR;
        }
        light = light->next;
    }

    lpDevI->dwFEFlags &= ~(D3DFE_MATERIAL_DIRTY |
                    D3DFE_NEED_TRANSFORM_LIGHTS |
                    D3DFE_LIGHTS_DIRTY);
}   // end of updateLights()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\stateset.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       stateset.cpp
 *  Content:    State sets handling
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

#include "fe.h"

//=====================================================================
//      CStateSets interface
//
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::CStateSets"

CStateSets::CStateSets(): m_SetHandles(10), m_DeviceHandles(10), m_GrowSize(10)
{
    m_dwMaxSets = 0;
    m_dwCurrentHandle = __INVALIDHANDLE;
    m_pStateSets = NULL;
    // Init handle factory
    // m_SetHandles.Init(m_GrowSize, m_GrowSize);
    m_SetHandles.CreateNewHandle( NULL ); // Reserve handle 0
    // m_DeviceHandles.Init(m_GrowSize, m_GrowSize);
    m_DeviceHandles.CreateNewHandle( NULL ); // Reserve handle 0
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::~CStateSets"

CStateSets::~CStateSets()
{
    delete m_pBufferSet;
    delete [] m_pStateSets;
    m_SetHandles.ReleaseHandle(0);
    m_DeviceHandles.ReleaseHandle(0);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Init"

HRESULT CStateSets::Init(CD3DBase *pDev)
{
    m_bPure = (pDev->BehaviorFlags() & D3DCREATE_PUREDEVICE) != 0;
    m_bTLHal = (pDev->GetDDIType() == D3DDDITYPE_DX7TL) || (pDev->GetDDIType() == D3DDDITYPE_DX8TL);
    m_bDX8Dev = (pDev->GetDDIType() >= D3DDDITYPE_DX8);
    m_bHardwareVP = (pDev->BehaviorFlags() &
                     D3DCREATE_HARDWARE_VERTEXPROCESSING);
    if(pDev->GetDDIType() > D3DDDITYPE_DX7TL)
    {
        DWORD value = 0;
        GetD3DRegValue(REG_DWORD, "EmulateStateBlocks", &value, sizeof(DWORD));
        if(value == 0)
        {
            m_bEmulate = FALSE;
        }
        else
        {
            m_bEmulate = TRUE;
        }
    }
    else
    {
        m_bEmulate = TRUE;
    }
    if(m_bPure)
    {
        m_pBufferSet = new CPureStateSet;
    }
    else
    {
        m_pBufferSet = new CStateSet;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::StartNewSet"

HRESULT CStateSets::StartNewSet()
{
    m_dwCurrentHandle = m_SetHandles.CreateNewHandle( NULL );
    if (m_dwCurrentHandle == __INVALIDHANDLE)
        return E_OUTOFMEMORY;
    if (m_dwCurrentHandle >= m_dwMaxSets)
    {
        // Time to grow the array
        CStateSet *pNew;
        if(m_bPure)
        {
            pNew = new CPureStateSet[m_dwMaxSets + m_GrowSize];
        }
        else
        {
            pNew = new CStateSet[m_dwMaxSets + m_GrowSize];
        }
        if (pNew == NULL)
        {
            m_SetHandles.ReleaseHandle(m_dwCurrentHandle);
            return E_OUTOFMEMORY;
        }
        for (DWORD i=0; i < m_dwMaxSets; i++)
            pNew[i] = m_pStateSets[i];
        delete [] m_pStateSets;
        m_pStateSets = pNew;
        m_dwMaxSets += m_GrowSize;
    }
    m_pBufferSet->m_FEOnlyBuffer.Reset();
    m_pBufferSet->m_DriverBuffer.Reset();
    m_pCurrentStateSet = m_pBufferSet;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::EndSet"

void CStateSets::EndSet()
{
    m_pStateSets[m_dwCurrentHandle] = *m_pCurrentStateSet;
    m_pCurrentStateSet = &m_pStateSets[m_dwCurrentHandle];
    m_pCurrentStateSet->m_dwStateSetFlags |= __STATESET_INITIALIZED;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::DeleteStateSet"

void CStateSets::DeleteStateSet(CD3DBase *pDevI, DWORD dwHandle)
{
    if (dwHandle >= m_dwMaxSets)
    {
        D3D_ERR("State block handle is greater than available number of blocks");
        throw D3DERR_INVALIDCALL;
    }
    CStateSet *pStateSet = &m_pStateSets[dwHandle];
    if (!(pStateSet->m_dwStateSetFlags & __STATESET_INITIALIZED))
    {
        D3D_ERR("State block is not initialized");
        throw D3DERR_INVALIDCALL;
    }

    // Pass delete instruction to the driver only if there was some data recorded
    if (pStateSet->m_dwDeviceHandle != __INVALIDHANDLE)
        pDevI->m_pDDI->InsertStateSetOp(D3DHAL_STATESETDELETE,
                                        pStateSet->m_dwDeviceHandle,
                                        (D3DSTATEBLOCKTYPE)0);

    Cleanup(dwHandle);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Cleanup"

void CStateSets::Cleanup(DWORD dwHandle)
{
    CStateSet &pStateSet = m_pStateSets[dwHandle];
    m_SetHandles.ReleaseHandle(dwHandle);
    if (pStateSet.m_dwDeviceHandle != __INVALIDHANDLE)
        m_DeviceHandles.ReleaseHandle(pStateSet.m_dwDeviceHandle);
    pStateSet.Release();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Capture"

void CStateSets::Capture(CD3DBase *pDevI, DWORD dwHandle)
{
    if (dwHandle >= m_dwMaxSets)
    {
        D3D_ERR("Invalid state block handle");
        throw D3DERR_INVALIDCALL;
    }
    CStateSet *pStateSet = &m_pStateSets[dwHandle];
    if (!(pStateSet->m_dwStateSetFlags & __STATESET_INITIALIZED))
    {
        D3D_ERR("State block not initialized");
        throw D3DERR_INVALIDCALL;
    }
    pStateSet->Capture(pDevI, TRUE);
    if (pStateSet->m_dwDeviceHandle != __INVALIDHANDLE)
    {
        pStateSet->Capture(pDevI, FALSE);
        pDevI->m_pDDI->InsertStateSetOp(D3DHAL_STATESETCAPTURE,
                                        pStateSet->m_dwDeviceHandle,
                                        (D3DSTATEBLOCKTYPE)0);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::CreatePredefined"

void CStateSets::CreatePredefined(CD3DBase *pDevI, D3DSTATEBLOCKTYPE sbt)
{
    if (StartNewSet() != D3D_OK)
        throw E_OUTOFMEMORY;
    m_pCurrentStateSet->CreatePredefined(pDevI, sbt);
}
//---------------------------------------------------------------------
// Allocates device handle if necessary
// And returns information of the device buffer
//
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::GetDeviceBufferInfo"

void CStateSets::GetDeviceBufferInfo(DWORD* dwStateSetHandle,
                                     LPVOID *pBuffer,
                                     DWORD* dwBufferSize)
{
    if (m_pCurrentStateSet->m_DriverBuffer.m_dwCurrentSize != 0)
    {
        // Allocate  a handle for the device
        m_pCurrentStateSet->m_dwDeviceHandle = m_DeviceHandles.CreateNewHandle( NULL );
        if (m_pCurrentStateSet->m_dwDeviceHandle == __INVALIDHANDLE)
        {
            D3D_ERR("Cannot allocate device handle for a state block");
            throw E_OUTOFMEMORY;
        }
    }
    *dwStateSetHandle = m_pCurrentStateSet->m_dwDeviceHandle;
    *pBuffer = (LPVOID)m_pCurrentStateSet->m_DriverBuffer.m_pBuffer;
    *dwBufferSize = m_pCurrentStateSet->m_DriverBuffer.m_dwCurrentSize;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::GetDeviceBufferInfo"

void CStateSets::CreateNewDeviceHandle(DWORD* dwStateSetHandle)
{
    // Allocate  a handle for the device
    m_pCurrentStateSet->m_dwDeviceHandle = m_DeviceHandles.CreateNewHandle( NULL );
    if (m_pCurrentStateSet->m_dwDeviceHandle == __INVALIDHANDLE)
    {
        D3D_ERR("Cannot allocate device handle for a state block");
        throw E_OUTOFMEMORY;
    }
        *dwStateSetHandle = m_pCurrentStateSet->m_dwDeviceHandle;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::TranslateDeviceBufferToDX7DDI"

void CStateSets::TranslateDeviceBufferToDX7DDI( DWORD* p, DWORD dwSize )
{
    DWORD* pEnd = (DWORD*)((BYTE*)p + dwSize);
    while (p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
        switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
        {
        case D3DDP2OP_RENDERSTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    D3DRENDERSTATETYPE dwState = (D3DRENDERSTATETYPE)*p++;
                    DWORD dwValue = *p++;
                }
            }
            break;
        case D3DDP2OP_SETLIGHT:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETLIGHT));
                    switch (pData->dwDataType)
                    {
                    case D3DHAL_SETLIGHT_ENABLE:
                    case D3DHAL_SETLIGHT_DISABLE:
                        break;
                    case D3DHAL_SETLIGHT_DATA:
                        p = (LPDWORD)((LPBYTE)p + sizeof(D3DLIGHT8));
                        break;
                    }
                }
                break;
            }
        case D3DDP2OP_SETMATERIAL:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETMATERIAL));
                }
                break;
            }
        case D3DDP2OP_SETTRANSFORM:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETTRANSFORM));
                }
                break;
            }
        case D3DDP2OP_TEXTURESTAGESTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2TEXTURESTAGESTATE));

                    // Map DX8 filter enums to DX6/7 enums
                    switch (pData->TSState)
                    {
                    case D3DTSS_MAGFILTER: pData->dwValue = texf2texfg[min(D3DTEXF_GAUSSIANCUBIC,pData->dwValue)]; break;
                    case D3DTSS_MINFILTER: pData->dwValue = texf2texfn[min(D3DTEXF_GAUSSIANCUBIC,pData->dwValue)]; break;
                    case D3DTSS_MIPFILTER: pData->dwValue = texf2texfp[min(D3DTEXF_GAUSSIANCUBIC,pData->dwValue)]; break;
                    }
                }
                break;
            }
        case D3DDP2OP_VIEWPORTINFO:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2VIEWPORTINFO));
                    // The next command has to be D3DDP2OP_ZRANGE
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2ZRANGE));
                }
                break;
            }
        case D3DDP2OP_SETCLIPPLANE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETCLIPPLANE));
                }
                break;
            }
#ifdef DBG
        default:
            DXGASSERT(FALSE);
#endif
        }
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertRenderState"

void CStateSets::InsertRenderState(D3DRENDERSTATETYPE state, DWORD dwValue,
                                      BOOL bDriverCanHandle)
{
    struct
    {
        D3DRENDERSTATETYPE state;
        DWORD dwValue;
    } data = {state, dwValue};
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_RENDERSTATE,
                                      &data, sizeof(data),
                                      !m_bEmulate && bDriverCanHandle);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertLight"

void CStateSets::InsertLight(DWORD dwLightIndex, CONST D3DLIGHT8* pData)
{
    struct
    {
        D3DHAL_DP2SETLIGHT header;
        D3DLIGHT8   light;
    } data;
    data.header.dwIndex = dwLightIndex;
    data.header.dwDataType = D3DHAL_SETLIGHT_DATA;
    data.light= *pData;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETLIGHT, &data, sizeof(data),
                                      !m_bEmulate && m_bTLHal);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertLightEnable"

void CStateSets::InsertLightEnable(DWORD dwLightIndex, BOOL bEnable)
{
    D3DHAL_DP2SETLIGHT data;
    data.dwIndex = dwLightIndex;
    if (bEnable)
        data.dwDataType = D3DHAL_SETLIGHT_ENABLE;
    else
        data.dwDataType = D3DHAL_SETLIGHT_DISABLE;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETLIGHT, &data, sizeof(data),
                                      !m_bEmulate && m_bTLHal);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertViewport"

void CStateSets::InsertViewport(CONST D3DVIEWPORT8* lpVwpData)
{
    D3DHAL_DP2VIEWPORTINFO data2;
    data2.dwX = lpVwpData->X;
    data2.dwY = lpVwpData->Y;
    data2.dwWidth = lpVwpData->Width;
    data2.dwHeight = lpVwpData->Height;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_VIEWPORTINFO, &data2, sizeof(data2),
                                      !m_bEmulate && m_bTLHal);

    D3DHAL_DP2ZRANGE data1;
    data1.dvMinZ = lpVwpData->MinZ;
    data1.dvMaxZ = lpVwpData->MaxZ;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_ZRANGE, &data1, sizeof(data1),
                                      !m_bEmulate && m_bTLHal);

    m_pCurrentStateSet->ResetCurrentCommand();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertMaterial"

void CStateSets::InsertMaterial(CONST D3DMATERIAL8* pData)
{
    D3DMATERIAL8 mat = *pData;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETMATERIAL,
                                      &mat,
                                      sizeof(D3DMATERIAL8),
                                      !m_bEmulate && m_bTLHal);

    m_pCurrentStateSet->ResetCurrentCommand();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertClipPlane"

void CStateSets::InsertClipPlane(DWORD dwPlaneIndex,
                                 CONST D3DVALUE* pPlaneEquation)
{
    D3DHAL_DP2SETCLIPPLANE data;
    data.dwIndex = dwPlaneIndex;
    data.plane[0] = pPlaneEquation[0];
    data.plane[1] = pPlaneEquation[1];
    data.plane[2] = pPlaneEquation[2];
    data.plane[3] = pPlaneEquation[3];
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETCLIPPLANE,
                                      &data, sizeof(data),
                                      !m_bEmulate && m_bTLHal);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertTransform"

void CStateSets::InsertTransform(D3DTRANSFORMSTATETYPE state,
                                 CONST D3DMATRIX* lpMat)
{
    D3DHAL_DP2SETTRANSFORM data;
    data.xfrmType = state;
    data.matrix = *lpMat;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETTRANSFORM,
                                      &data, sizeof(data),
                                      !m_bEmulate && m_bTLHal);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertTextureStageState"

void CStateSets::InsertTextureStageState(DWORD dwStage,
                                            D3DTEXTURESTAGESTATETYPE type,
                                            DWORD dwValue)
{
    D3DHAL_DP2TEXTURESTAGESTATE data = {(WORD)dwStage, type, dwValue};
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_TEXTURESTAGESTATE,
                                      &data, sizeof(data),
                                      !m_bEmulate);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertTexture"

void CStateSets::InsertTexture(DWORD dwStage, IDirect3DBaseTexture8 *pTex)
{
    D3DHAL_DP2FRONTENDDATA data = {(WORD)dwStage, pTex};

    // Up the internal refcount of this texture.
    CBaseTexture *lpTexI = CBaseTexture::SafeCast(pTex);
    if (lpTexI)
        lpTexI->IncrementUseCount();

    // Only the front-end will parse this instruction
    m_pCurrentStateSet->InsertCommand((D3DHAL_DP2OPERATION)D3DDP2OP_FRONTENDDATA, &data, sizeof(data), FALSE);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertCurrentTexturePalette"

void CStateSets::InsertCurrentTexturePalette(DWORD PaletteNumber)
{
    D3DHAL_DP2FESETPAL data = {PaletteNumber};
    // Only the front-end will parse this instruction
    m_pCurrentStateSet->InsertCommand((D3DHAL_DP2OPERATION)D3DDP2OP_FESETPAL, &data, sizeof(data), FALSE);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertVertexShader"

void CStateSets::InsertVertexShader(DWORD dwShaderHandle, BOOL bHardware)
{
    D3DHAL_DP2VERTEXSHADER data = {dwShaderHandle};
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETVERTEXSHADER,
                                      &data, sizeof(data),
                                      !m_bEmulate && m_bHardwareVP &&
                                      m_bDX8Dev && bHardware);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertPixelShader"

void CStateSets::InsertPixelShader(DWORD dwShaderHandle)
{
    D3DHAL_DP2PIXELSHADER data = {dwShaderHandle};
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETPIXELSHADER,
                                      &data, sizeof(data),
                                      !m_bEmulate && m_bDX8Dev);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertStreamSource"

void CStateSets::InsertStreamSource(DWORD dwStream, CVertexBuffer *pBuf, DWORD dwStride)
{
    D3DHAL_DP2FESETVB data = {(WORD)dwStream, pBuf, dwStride};
    // Only the front-end will parse this instruction
    CVertexBuffer* pVB = static_cast<CVertexBuffer*>(pBuf);
    if (pVB)
        pVB->IncrementUseCount();

    m_pCurrentStateSet->InsertCommand((D3DHAL_DP2OPERATION)D3DDP2OP_FESETVB, &data, sizeof(data), FALSE);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertIndices"

void CStateSets::InsertIndices(CIndexBuffer *pBuf, DWORD dwBaseVertex)
{
    D3DHAL_DP2FESETIB data = {pBuf, dwBaseVertex};
    // Only the front-end will parse this instruction
    CIndexBuffer* pIB = static_cast<CIndexBuffer*>(pBuf);
    if (pIB)
        pIB->IncrementUseCount();

    m_pCurrentStateSet->InsertCommand((D3DHAL_DP2OPERATION)D3DDP2OP_FESETIB, &data, sizeof(data), FALSE);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertVertexShaderConstant"

void CStateSets::InsertVertexShaderConstant(DWORD Register, CONST VOID* pConstantData, DWORD ConstantCount)
{
    LPVOID pData = new BYTE[sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) + ConstantCount * 16];
    if(pData == 0)
    {
        throw E_OUTOFMEMORY;
    }
    ((LPD3DHAL_DP2SETVERTEXSHADERCONST)pData)->dwRegister = Register;
    ((LPD3DHAL_DP2SETVERTEXSHADERCONST)pData)->dwCount = ConstantCount;
    memcpy((LPD3DHAL_DP2SETVERTEXSHADERCONST)pData + 1, pConstantData, ConstantCount * 16);
    try
    {
        m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETVERTEXSHADERCONST,
                                          pData,
                                          sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) + ConstantCount * 16,
                                          !m_bEmulate && m_bDX8Dev && m_bTLHal);
    }
    catch(HRESULT hr)
    {
        delete[] pData;
        throw hr;
    }
    delete[] pData;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertPixelShaderConstant"

void CStateSets::InsertPixelShaderConstant(DWORD Register,
                                           CONST VOID* pConstantData,
                                           DWORD ConstantCount)
{
    LPVOID pData = new BYTE[sizeof(D3DHAL_DP2SETPIXELSHADERCONST) + ConstantCount * 16];
    if(pData == 0)
    {
        throw E_OUTOFMEMORY;
    }
    ((LPD3DHAL_DP2SETPIXELSHADERCONST)pData)->dwRegister = Register;
    ((LPD3DHAL_DP2SETPIXELSHADERCONST)pData)->dwCount = ConstantCount;
    memcpy((LPD3DHAL_DP2SETPIXELSHADERCONST)pData + 1, pConstantData, ConstantCount * 16);
    try
    {
        m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETPIXELSHADERCONST,
                                          pData,
                                          sizeof(D3DHAL_DP2SETPIXELSHADERCONST) + ConstantCount * 16,
                                          !m_bEmulate && m_bDX8Dev);
    }
    catch(HRESULT hr)
    {
        delete[] pData;
        throw hr;
    }
    delete[] pData;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Execute"

void CStateSets::Execute(CD3DBase *pDevI, DWORD dwHandle)
{
#if DBG
    if (dwHandle >= m_dwMaxSets)
    {
        D3D_ERR("Invalid state block handle");
        throw D3DERR_INVALIDCALL;
    }
#endif
    CStateSet *pStateSet = &m_pStateSets[dwHandle];
#if DBG
    if (!(pStateSet->m_dwStateSetFlags & __STATESET_INITIALIZED))
    {
        D3D_ERR("State block not initialized");
        throw D3DERR_INVALIDCALL;
    }
#endif
    // Parse recorded data first
    pStateSet->Execute(pDevI, TRUE);
    // If the hardware buffer is not empty, we pass recorded data to it
    if (pStateSet->m_dwDeviceHandle != __INVALIDHANDLE)
    {
        pStateSet->Execute(pDevI, FALSE);
        if((pDevI->m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) == 0 || (pStateSet->m_dwStateSetFlags & __STATESET_HASONLYVERTEXSTATE) == 0)
        {
            pDevI->m_pDDI->InsertStateSetOp(D3DHAL_STATESETEXECUTE, pStateSet->m_dwDeviceHandle, (D3DSTATEBLOCKTYPE)0);
        }
        else
        {
            pStateSet->m_dwStateSetFlags &= ~__STATESET_HASONLYVERTEXSTATE;
        }
    }
}
//=====================================================================
//      CStateSet interface
//
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::Release"

HRESULT CStateSet::Release()
{
     if (!(m_dwStateSetFlags & __STATESET_INITIALIZED))
        return D3DERR_INVALIDCALL;
    m_dwStateSetFlags &= ~__STATESET_INITIALIZED;

    // Parse the FEOnly buffer and release all the VB/IB/Texture handles.
    DWORD *p;
    DWORD dwSize;
    DWORD *pEnd;

    p = (DWORD*)m_FEOnlyBuffer.m_pBuffer;
    dwSize = m_FEOnlyBuffer.m_dwCurrentSize;
    pEnd = (DWORD*)((BYTE*)p + dwSize);
    while (p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
        switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
        {
        case D3DDP2OP_RENDERSTATE:
            p = (DWORD *)((D3DHAL_DP2RENDERSTATE *)p + pCommand->wStateCount);
            break;
        case D3DDP2OP_SETLIGHT:
            for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETLIGHT));
                switch (pData->dwDataType)
                {
                case D3DHAL_SETLIGHT_ENABLE:
                case D3DHAL_SETLIGHT_DISABLE:
                    break;
                case D3DHAL_SETLIGHT_DATA:
                    p = (DWORD *)((BYTE *)p + sizeof(D3DLIGHT8));
                    break;
                }
            }
            break;
        case D3DDP2OP_SETMATERIAL:
            p = (DWORD *)((D3DHAL_DP2SETMATERIAL *)p + pCommand->wStateCount);
            break;
        case D3DDP2OP_SETTRANSFORM:
            p = (DWORD *)((D3DHAL_DP2SETTRANSFORM *)p + pCommand->wStateCount);
            break;
        case D3DDP2OP_TEXTURESTAGESTATE:
            p = (DWORD *)((D3DHAL_DP2TEXTURESTAGESTATE *)p +
                          pCommand->wStateCount);
            break;
        case D3DDP2OP_FRONTENDDATA:
        {
            CBaseTexture* pTexOld = NULL;
            for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
            {
                LPD3DHAL_DP2FRONTENDDATA pData = (LPD3DHAL_DP2FRONTENDDATA)p;
                pTexOld = CBaseTexture::SafeCast(pData->pTexture);
                if( pTexOld )
                    pTexOld->DecrementUseCount();
                p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FRONTENDDATA));
            }
            break;
        }
        case D3DDP2OP_FESETVB:
            for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
            {
                LPD3DHAL_DP2FESETVB pData = (LPD3DHAL_DP2FESETVB)p;
                if( pData->pBuf )
                    pData->pBuf->DecrementUseCount();
                p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETVB));
            }
            break;
        case D3DDP2OP_FESETIB:
            for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
            {
                LPD3DHAL_DP2FESETIB pData = (LPD3DHAL_DP2FESETIB)p;
                if( pData->pBuf )
                    pData->pBuf->DecrementUseCount();
                p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETIB));
            }
            break;
        case D3DDP2OP_FESETPAL:
            p = (DWORD *)((D3DHAL_DP2FESETPAL *)p + pCommand->wStateCount);
            break;
        case D3DDP2OP_VIEWPORTINFO:
            // The next command has to be D3DDP2OP_ZRANGE
            p = (DWORD *)((BYTE *)p +
                          ( sizeof(D3DHAL_DP2VIEWPORTINFO) +
                            sizeof(D3DHAL_DP2COMMAND)      +
                            sizeof(D3DHAL_DP2ZRANGE ) ) *
                          pCommand->wStateCount );
            break;
        case D3DDP2OP_SETCLIPPLANE:
            p = (DWORD *)((D3DHAL_DP2SETCLIPPLANE *)p + pCommand->wStateCount);
            break;
        case D3DDP2OP_SETVERTEXSHADER:
            p = (DWORD *)((D3DHAL_DP2VERTEXSHADER *)p + pCommand->wStateCount);
            break;
        case D3DDP2OP_SETPIXELSHADER:
            p = (DWORD *)((D3DHAL_DP2PIXELSHADER *)p + pCommand->wStateCount);
            break;
        case D3DDP2OP_SETVERTEXSHADERCONST:
            for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETVERTEXSHADERCONST pData = (LPD3DHAL_DP2SETVERTEXSHADERCONST)p;
                p = (DWORD*)((BYTE*)p +
                             sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) +
                             pData->dwCount * 16);

            }
            break;
        case D3DDP2OP_SETPIXELSHADERCONST:
            for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETPIXELSHADERCONST pData = (LPD3DHAL_DP2SETPIXELSHADERCONST)p;
                p = (DWORD*)((BYTE*)p +
                             sizeof(D3DHAL_DP2SETPIXELSHADERCONST) +
                             pData->dwCount * 16);
            }
            break;
#ifdef DBG
        default:
            DXGASSERT(FALSE);
#endif
        }
    }

    m_FEOnlyBuffer.Reset();
    m_DriverBuffer.Reset();
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::InsertCommand"

void CStateSet::InsertCommand(D3DHAL_DP2OPERATION op, LPVOID pData,
                                 DWORD dwDataSize,
                                 BOOL bDriverCanHandle)
{
    if (op == D3DDP2OP_TEXTURESTAGESTATE ||
        (op == D3DDP2OP_RENDERSTATE &&
        ((LPD3DHAL_DP2RENDERSTATE)pData)->RenderState >= D3DRENDERSTATE_WRAP0 &&
        ((LPD3DHAL_DP2RENDERSTATE)pData)->RenderState <= D3DRENDERSTATE_WRAP7))
    {
        m_dwStateSetFlags |= __STATESET_NEEDCHECKREMAPPING;
    }
    if (bDriverCanHandle)
        m_DriverBuffer.InsertCommand(op, pData, dwDataSize);
    else
        m_FEOnlyBuffer.InsertCommand(op, pData, dwDataSize);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::Execute"

void CStateSet::Execute(CD3DBase *pBaseDev, BOOL bFrontEndBuffer)
{
    DWORD *p;
    DWORD dwSize;
    DWORD *pEnd;
    // The device is not pure, so we can cast
    DXGASSERT((pBaseDev->BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0);
    CD3DHal *pDevI = static_cast<CD3DHal*>(pBaseDev);
    D3DFE_PROCESSVERTICES* pv = pDevI->m_pv;
    try
    {
        // Texture stages could be re-mapped during texture transform processing.
        // Before we set new values we have to restore original ones
        if (pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES &&
            m_dwStateSetFlags & __STATESET_NEEDCHECKREMAPPING)
        {
            RestoreTextureStages(pDevI);
            pDevI->ForceFVFRecompute();
        }

        if (bFrontEndBuffer)
        {
            p = (DWORD*)m_FEOnlyBuffer.m_pBuffer;
            dwSize = m_FEOnlyBuffer.m_dwCurrentSize;
        }
        else
        {
            p = (DWORD*)m_DriverBuffer.m_pBuffer;
            dwSize = m_DriverBuffer.m_dwCurrentSize;
            pDevI->m_dwRuntimeFlags |= D3DRT_EXECUTESTATEMODE;
            m_dwStateSetFlags |= __STATESET_HASONLYVERTEXSTATE;
        }
        pEnd = (DWORD*)((BYTE*)p + dwSize);
        while (p < pEnd)
        {
            LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
            p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
            switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
            {
            case D3DDP2OP_RENDERSTATE:
                {
                    if(pDevI->m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE)
                    {
                        m_dwStateSetFlags &= ~__STATESET_HASONLYVERTEXSTATE;
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            D3DRENDERSTATETYPE dwState = (D3DRENDERSTATETYPE)*p++;
                            DWORD dwValue = *p++;
                            if ( (pDevI->rstates[dwState] != dwValue)
#if DBG
                                  && (dwState != D3DRS_DEBUGMONITORTOKEN) // don't filter these
#endif
                               )
                            {
                                if (!pDevI->rsVec.IsBitSet(dwState))
                                { // Fast path. We do not need any processing done in UpdateInternalState other than updating rstates array
                                    pDevI->rstates[dwState] = dwValue;
                                }
                                else
                                {
                                    pDevI->UpdateInternalState(dwState, dwValue);
                                }
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetRenderState %d", dwState);
                            }
                        }
                    }
                    else
                    {
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            D3DRENDERSTATETYPE dwState = (D3DRENDERSTATETYPE)*p++;
                            DWORD dwValue = *p++;
                            if ( (pDevI->rstates[dwState] != dwValue)
#if DBG
                                  && (dwState != D3DRS_DEBUGMONITORTOKEN) // don't filter these
#endif
                               )
                            {
                                if (!pDevI->rsVec.IsBitSet(dwState))
                                { // Fast path. We do not need any processing done in UpdateInternalState other than updating rstates array
                                    pDevI->rstates[dwState] = dwValue;

                                    pDevI->m_pDDI->SetRenderState(dwState, dwValue);
                                }
                                else
                                {
                                    pDevI->UpdateInternalState(dwState, dwValue);
                                    // Vertex processing only render states will be passed to the
                                    // driver when we switch to the hardware vertex processing mode
                                    if ((!(pDevI->rsVertexProcessingOnly.IsBitSet(dwState) &&
                                           pDevI->m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)))
                                    {
                                        if (pDevI->CanHandleRenderState(dwState))
                                        {
                                            pDevI->m_pDDI->SetRenderState(dwState, dwValue);
                                        }
                                    }
                                }
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetRenderState %d", dwState);
                            }
                        }
                    }
                    break;
                }
            case D3DDP2OP_SETLIGHT:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETLIGHT));
                        switch (pData->dwDataType)
                        {
                        case D3DHAL_SETLIGHT_ENABLE:
                            pDevI->LightEnableI( pData->dwIndex, TRUE );
                            break;
                        case D3DHAL_SETLIGHT_DISABLE:
                            pDevI->LightEnableI( pData->dwIndex, FALSE );
                            break;
                        case D3DHAL_SETLIGHT_DATA:
                            pDevI->SetLightI(pData->dwIndex, (D3DLIGHT8 *)p);
                            p = (LPDWORD)((LPBYTE)p + sizeof(D3DLIGHT8));
                            break;
                        }
                    }
                    break;
                }
            case D3DDP2OP_SETMATERIAL:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2SETMATERIAL pData = (LPD3DHAL_DP2SETMATERIAL)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETMATERIAL));
                        pDevI->SetMaterialFast((D3DMATERIAL8*)pData);
                    }
                    break;
                }
            case D3DDP2OP_SETTRANSFORM:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        D3DHAL_DP2SETTRANSFORM *pData = (D3DHAL_DP2SETTRANSFORM*)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETTRANSFORM));
                        pDevI->SetTransformI(pData->xfrmType, &pData->matrix);
                    }
                    break;
                }
            case D3DDP2OP_TEXTURESTAGESTATE:
                {
                    if (pDevI->m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE)
                    {
                        m_dwStateSetFlags &= ~__STATESET_HASONLYVERTEXSTATE;
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                            p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2TEXTURESTAGESTATE));
                            DWORD dwStage = pData->wStage;
                            DWORD dwState = pData->TSState;
                            DWORD dwValue = pData->dwValue;
                            if (pDevI->tsstates[dwStage][dwState] != dwValue)
                            {
                                // Fast path. We do not need any processing done in UpdateInternalTSS other than updating tsstates array
                                if (pDevI->NeedInternalTSSUpdate(dwState))
                                {
                                    pDevI->UpdateInternalTextureStageState(dwStage, (D3DTEXTURESTAGESTATETYPE)dwState, &dwValue);
                                }
                                else
                                {
                                    pDevI->tsstates[dwStage][dwState] = dwValue;
                                }
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetTextureStageState Stage: %d, State: %d", dwStage, dwState);
                            }
                        }
                    }
                    else
                    {
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                            p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2TEXTURESTAGESTATE));
                            DWORD dwStage = pData->wStage;
                            DWORD dwState = pData->TSState;
                            DWORD dwValue = pData->dwValue;
                            if (pDevI->tsstates[dwStage][dwState] != dwValue)
                            {
                                // Fast path. We do not need any processing done in UpdateInternalTSS other than updating tsstates array
                                if (pDevI->NeedInternalTSSUpdate(dwState))
                                {
                                    if(pDevI->UpdateInternalTextureStageState(dwStage, (D3DTEXTURESTAGESTATETYPE)dwState, &dwValue))
                                        continue;
                                }
                                else
                                {
                                    pDevI->tsstates[dwStage][dwState] = dwValue;
                                }
                                if (dwStage >= pDevI->m_dwMaxTextureBlendStages)
                                    continue;
                                pDevI->m_pDDI->SetTSS(dwStage, (D3DTEXTURESTAGESTATETYPE)dwState, dwValue);
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetTextureStageState Stage: %d, State: %d", dwStage, dwState);
                            }
                        }
                    }
                    break;
                }
            case D3DDP2OP_FRONTENDDATA:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2FRONTENDDATA pData = (LPD3DHAL_DP2FRONTENDDATA)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FRONTENDDATA));
                        HRESULT ret = pDevI->SetTexture(pData->wStage, pData->pTexture);
                        if (ret != D3D_OK)
                            throw ret;
                    }
                    break;
                }
            case D3DDP2OP_FESETVB:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2FESETVB pData = (LPD3DHAL_DP2FESETVB)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETVB));
                        HRESULT ret = pDevI->SetStreamSource(pData->wStream, pData->pBuf, pData->dwStride);
                        if (ret != D3D_OK)
                            throw ret;
                    }
                    break;
                }
            case D3DDP2OP_FESETIB:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2FESETIB pData = (LPD3DHAL_DP2FESETIB)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETIB));
                        HRESULT ret = pDevI->SetIndices(pData->pBuf, pData->dwBase);
                        if (ret != D3D_OK)
                            throw ret;
                    }
                    break;
                }
            case D3DDP2OP_FESETPAL:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETPAL pData = (LPD3DHAL_DP2FESETPAL)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETPAL));
                    if(  pData->dwPaletteNumber != __INVALIDPALETTE )
                    {
                        HRESULT ret = pDevI->SetCurrentTexturePalette(pData->dwPaletteNumber);
                        if (ret != D3D_OK)
                            throw ret;
                    }
                }
                break;
            }
            case D3DDP2OP_VIEWPORTINFO:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        D3DVIEWPORT8 viewport;
                        LPD3DHAL_DP2VIEWPORTINFO lpVwpData = (LPD3DHAL_DP2VIEWPORTINFO)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2VIEWPORTINFO));
                        viewport.X      = lpVwpData->dwX;
                        viewport.Y      = lpVwpData->dwY;
                        viewport.Width  = lpVwpData->dwWidth;
                        viewport.Height = lpVwpData->dwHeight;

                        // The next command has to be D3DDP2OP_ZRANGE
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
                        LPD3DHAL_DP2ZRANGE pData = (LPD3DHAL_DP2ZRANGE)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2ZRANGE));
                        viewport.MinZ      = pData->dvMinZ;
                        viewport.MaxZ      = pData->dvMaxZ;

                        pDevI->SetViewportI(&viewport);
                    }
                    break;
                }
            case D3DDP2OP_SETCLIPPLANE:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        D3DHAL_DP2SETCLIPPLANE *pData = (D3DHAL_DP2SETCLIPPLANE*)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETCLIPPLANE));
                        pDevI->SetClipPlaneI(pData->dwIndex, pData->plane);
                    }
                    break;
                }
            case D3DDP2OP_SETVERTEXSHADER:
                {
                    // Optimization, dont loop, use the last one.
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2VERTEXSHADER pData = (LPD3DHAL_DP2VERTEXSHADER)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2VERTEXSHADER));
                        if( pData->dwHandle != 0 )
                        {
                            pDevI->SetVertexShader(pData->dwHandle);
                        }
                        else
                        {
                            pDevI->m_dwCurrentShaderHandle = 0;
                        }
                    }
                    pDevI->m_pDDI->ResetVertexShader();
                    break;
                }
            case D3DDP2OP_SETPIXELSHADER:
                {
                    m_dwStateSetFlags &= ~__STATESET_HASONLYVERTEXSTATE;
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2PIXELSHADER pData = (LPD3DHAL_DP2PIXELSHADER)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2PIXELSHADER));
                        pDevI->SetPixelShaderFast(pData->dwHandle);
                    }
                    break;
                }
            case D3DDP2OP_SETVERTEXSHADERCONST:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2SETVERTEXSHADERCONST pData = (LPD3DHAL_DP2SETVERTEXSHADERCONST)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) + pData->dwCount * 16);
                        pDevI->SetVertexShaderConstantI(pData->dwRegister, pData + 1, pData->dwCount);
                    }
                    break;
                }
            case D3DDP2OP_SETPIXELSHADERCONST:
                {
                    m_dwStateSetFlags &= ~__STATESET_HASONLYVERTEXSTATE;
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2SETPIXELSHADERCONST pData = (LPD3DHAL_DP2SETPIXELSHADERCONST)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETPIXELSHADERCONST) + pData->dwCount * 16);
                        pDevI->SetPixelShaderConstantFast(pData->dwRegister, pData + 1, pData->dwCount);
                    }
                    break;
                }
#ifdef DBG
            default:
                DXGASSERT(FALSE);
#endif
            }
        }
        pDevI->m_dwRuntimeFlags &= ~D3DRT_EXECUTESTATEMODE;
    }
    catch(HRESULT ret)
    {
        pDevI->m_dwRuntimeFlags &= ~D3DRT_EXECUTESTATEMODE;
        m_dwStateSetFlags &= ~__STATESET_HASONLYVERTEXSTATE;
        throw ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::Capture"

void CStateSet::Capture(CD3DBase *pBaseDev, BOOL bFrontEndBuffer)
{
    DWORD *p;
    DWORD dwSize;
    DWORD *pEnd;
    // The device is not pure, so we can cast
    DXGASSERT((pBaseDev->BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0);
    CD3DHal *pDevI = static_cast<CD3DHal*>(pBaseDev);
    D3DFE_PROCESSVERTICES* pv = pDevI->m_pv;
    // Texture coordinate indices must be restored before capturing, because 
    // we do not call GetTextureStageState but access tsstates directly
    if (pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(pDevI);
        pDevI->ForceFVFRecompute();
    }
    if (bFrontEndBuffer)
    {
        p = (DWORD*)m_FEOnlyBuffer.m_pBuffer;
        dwSize = m_FEOnlyBuffer.m_dwCurrentSize;
    }
    else
    {
        p = (DWORD*)m_DriverBuffer.m_pBuffer;
        dwSize = m_DriverBuffer.m_dwCurrentSize;
    }
    pEnd = (DWORD*)((BYTE*)p + dwSize);
    while (p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
        switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
        {
        case D3DDP2OP_RENDERSTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    const D3DRENDERSTATETYPE state = (D3DRENDERSTATETYPE)*p++;
                    *p++ = pDevI->rstates[state];
                }
                break;
            }
        case D3DDP2OP_SETLIGHT:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETLIGHT));
                    LPDIRECT3DLIGHTI pLight =
                        static_cast<DIRECT3DLIGHTI *>
                        ((*pDevI->m_pLightArray)[pData->dwIndex].m_pObj);
                    if(pData->dwIndex >= pDevI->m_pLightArray->GetSize())
                    {
                        D3D_ERR("Unable to capture light state (light not set?)");
                        throw D3DERR_INVALIDCALL;
                    }
                    switch (pData->dwDataType)
                    {
                    case D3DHAL_SETLIGHT_ENABLE:
                        if(!pLight->Enabled())
                            pData->dwDataType = D3DHAL_SETLIGHT_DISABLE;
                        break;
                    case D3DHAL_SETLIGHT_DISABLE:
                        if(pLight->Enabled())
                            pData->dwDataType = D3DHAL_SETLIGHT_ENABLE;
                        break;
                    case D3DHAL_SETLIGHT_DATA:
                        *((D3DLIGHT8*)p) = pLight->m_Light;
                        p = (LPDWORD)((LPBYTE)p + sizeof(D3DLIGHT8));
                        break;
                    }
                }
                break;
            }
        case D3DDP2OP_SETMATERIAL:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETMATERIAL pData = (LPD3DHAL_DP2SETMATERIAL)p;
                    *pData = *((LPD3DHAL_DP2SETMATERIAL)&pv->lighting.material);
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETMATERIAL));
                }
                break;
            }
        case D3DDP2OP_SETTRANSFORM:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETTRANSFORM pData = (LPD3DHAL_DP2SETTRANSFORM)p;
                    DWORD state = pData->xfrmType;
                    if ((DWORD)state >= __WORLDMATRIXBASE &&
                        (DWORD)state < __WORLDMATRIXBASE + __MAXWORLDMATRICES)
                    {
                        UINT index = (DWORD)state - __WORLDMATRIXBASE;
                        pData->matrix = *((LPD3DMATRIX)&pv->world[index]);
                    }
                    else
                    switch(pData->xfrmType)
                    {
                    case D3DTRANSFORMSTATE_VIEW:
                        pData->matrix = *((LPD3DMATRIX)&pv->view);
                        break;
                    case D3DTRANSFORMSTATE_PROJECTION:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->transform.proj);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE0:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[0]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE1:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[1]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE2:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[2]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE3:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[3]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE4:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[4]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE5:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[5]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE6:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[6]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE7:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[7]);
                        break;
                    }
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETTRANSFORM));
                }
                break;
            }
        case D3DDP2OP_TEXTURESTAGESTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                    pData->dwValue = pDevI->tsstates[pData->wStage][pData->TSState];
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2TEXTURESTAGESTATE));
                }
                break;
            }
        case D3DDP2OP_FRONTENDDATA:
            {
                CBaseTexture* pTexOld = NULL;
                CBaseTexture* pTexNew = NULL;

                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FRONTENDDATA pData = (LPD3DHAL_DP2FRONTENDDATA)p;
                    pTexOld = CBaseTexture::SafeCast(pData->pTexture);
                    if( pTexOld )
                        pTexOld->DecrementUseCount();
                    pTexNew = pDevI->m_lpD3DMappedTexI[pData->wStage];
                    if( pTexNew )
                        pTexNew->IncrementUseCount();
                    if (pDevI->m_lpD3DMappedTexI[pData->wStage] != 0)
                    {
                        switch(pDevI->m_lpD3DMappedTexI[pData->wStage]->GetBufferDesc()->Type)
                        {
                        case D3DRTYPE_TEXTURE:
                            pData->pTexture = static_cast<IDirect3DTexture8*>(static_cast<CMipMap*>(pTexNew));
                            break;
                        case D3DRTYPE_CUBETEXTURE:
                            pData->pTexture = static_cast<IDirect3DCubeTexture8*>(static_cast<CCubeMap*>(pTexNew));
                            break;
                        case D3DRTYPE_VOLUMETEXTURE:
                            pData->pTexture = static_cast<IDirect3DVolumeTexture8*>(static_cast<CMipVolume*>(pTexNew));
                            break;
                        }
                    }
                    else
                    {
                        pData->pTexture = 0;
                    }
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FRONTENDDATA));
                }
                break;
            }
        case D3DDP2OP_FESETVB:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETVB pData = (LPD3DHAL_DP2FESETVB)p;
                    if( pData->pBuf )
                        pData->pBuf->DecrementUseCount();
                    pData->pBuf = pDevI->m_pStream[pData->wStream].m_pVB;
                    if( pData->pBuf )
                        pData->pBuf->IncrementUseCount();
                    pData->dwStride = pDevI->m_pStream[pData->wStream].m_dwStride;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETVB));
                }
                break;
            }
        case D3DDP2OP_FESETIB:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETIB pData = (LPD3DHAL_DP2FESETIB)p;
                    if( pData->pBuf )
                        pData->pBuf->DecrementUseCount();
                    pData->pBuf = pDevI->m_pIndexStream->m_pVBI;
                    if( pData->pBuf )
                        pData->pBuf->IncrementUseCount();
                    pData->dwBase = pDevI->m_pIndexStream->m_dwBaseIndex;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETIB));
                }
                break;
            }
        case D3DDP2OP_FESETPAL:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETPAL pData = (LPD3DHAL_DP2FESETPAL)p;
                    pData->dwPaletteNumber = pDevI->m_dwPalette;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETPAL));
                }
                break;
            }
        case D3DDP2OP_VIEWPORTINFO:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    D3DVIEWPORT8 viewport;
                    LPD3DHAL_DP2VIEWPORTINFO lpVwpData = (LPD3DHAL_DP2VIEWPORTINFO)p;
                    lpVwpData->dwX      = pDevI->m_Viewport.X;
                    lpVwpData->dwY      = pDevI->m_Viewport.Y;
                    lpVwpData->dwWidth  = pDevI->m_Viewport.Width;
                    lpVwpData->dwHeight = pDevI->m_Viewport.Height;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2VIEWPORTINFO));
                    // The next command has to be D3DDP2OP_ZRANGE
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
                    LPD3DHAL_DP2ZRANGE pData = (LPD3DHAL_DP2ZRANGE)p;
                    pData->dvMinZ = pDevI->m_Viewport.MinZ;
                    pData->dvMaxZ = pDevI->m_Viewport.MaxZ;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2ZRANGE));
                }
                break;
            }
        case D3DDP2OP_SETCLIPPLANE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETCLIPPLANE pData = (LPD3DHAL_DP2SETCLIPPLANE)p;
                    *((LPD3DVECTORH)pData->plane) = pDevI->transform.userClipPlane[pData->dwIndex];
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETCLIPPLANE));
                }
                break;
            }
        case D3DDP2OP_SETVERTEXSHADER:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2VERTEXSHADER pData = (LPD3DHAL_DP2VERTEXSHADER)p;
                    pData->dwHandle = pDevI->m_dwCurrentShaderHandle;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2VERTEXSHADER));
                }
                break;
            }
        case D3DDP2OP_SETPIXELSHADER:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2PIXELSHADER pData = (LPD3DHAL_DP2PIXELSHADER)p;
                    pData->dwHandle = pDevI->m_dwCurrentPixelShaderHandle;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2PIXELSHADER));

                }
                break;
            }
        case D3DDP2OP_SETVERTEXSHADERCONST:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETVERTEXSHADERCONST pData = (LPD3DHAL_DP2SETVERTEXSHADERCONST)p;
                    pDevI->m_pv->pGeometryFuncs->GetShaderConstants(pData->dwRegister, pData->dwCount, pData + 1);
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) + pData->dwCount * 16);

                }
                break;
            }
        case D3DDP2OP_SETPIXELSHADERCONST:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETPIXELSHADERCONST pData = (LPD3DHAL_DP2SETPIXELSHADERCONST)p;
                    pDevI->GetPixelShaderConstantI(pData->dwRegister,
                                                   pData->dwCount,
                                                   pData + 1);
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETPIXELSHADERCONST) + pData->dwCount * 16);
                }
                break;
            }
#ifdef DBG
        default:
            DXGASSERT(FALSE);
#endif
        }
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::CreatePredefined"

void CStateSet::CreatePredefined(CD3DBase *pBaseDev, D3DSTATEBLOCKTYPE sbt)
{
    static D3DRENDERSTATETYPE ALLrstates[] =
    {
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE,
        D3DRS_SOFTWAREVERTEXPROCESSING,
        D3DRS_POINTSIZE,
        D3DRS_POINTSIZE_MIN,
        D3DRS_POINTSPRITEENABLE,
        D3DRS_POINTSCALEENABLE,
        D3DRS_POINTSCALE_A,
        D3DRS_POINTSCALE_B,
        D3DRS_POINTSCALE_C,
        D3DRS_MULTISAMPLEANTIALIAS,
        D3DRS_MULTISAMPLEMASK,
        D3DRS_PATCHEDGESTYLE,
        D3DRS_PATCHSEGMENTS,
        D3DRS_POINTSIZE_MAX,
        D3DRS_INDEXEDVERTEXBLENDENABLE,
        D3DRS_COLORWRITEENABLE,
        D3DRS_TWEENFACTOR,
        D3DRS_BLENDOP,
        D3DRS_POSITIONORDER,
        D3DRS_NORMALORDER,
    };
    static D3DTEXTURESTAGESTATETYPE ALLtsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS,
        D3DTSS_ADDRESSW,
        D3DTSS_COLORARG0,
        D3DTSS_ALPHAARG0,
        D3DTSS_RESULTARG,
    };
    static D3DRENDERSTATETYPE PIXELrstates[] =
    {
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRS_COLORWRITEENABLE,
        D3DRS_BLENDOP,
    };
    static D3DTEXTURESTAGESTATETYPE PIXELtsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS,
        D3DTSS_ADDRESSW,
        D3DTSS_COLORARG0,
        D3DTSS_ALPHAARG0,
        D3DTSS_RESULTARG,
    };
    static D3DRENDERSTATETYPE VERTEXrstates[] =
    {
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE,
        D3DRS_SOFTWAREVERTEXPROCESSING,
        D3DRS_POINTSIZE,
        D3DRS_POINTSIZE_MIN,
        D3DRS_POINTSPRITEENABLE,
        D3DRS_POINTSCALEENABLE,
        D3DRS_POINTSCALE_A,
        D3DRS_POINTSCALE_B,
        D3DRS_POINTSCALE_C,
        D3DRS_MULTISAMPLEANTIALIAS,
        D3DRS_MULTISAMPLEMASK,
        D3DRS_PATCHEDGESTYLE,
        D3DRS_PATCHSEGMENTS,
        D3DRS_POINTSIZE_MAX,
        D3DRS_INDEXEDVERTEXBLENDENABLE,
        D3DRS_TWEENFACTOR,
        D3DRS_POSITIONORDER,
        D3DRS_NORMALORDER,
    };
    static D3DTEXTURESTAGESTATETYPE VERTEXtsstates[] =
    {
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_TEXTURETRANSFORMFLAGS
    };

    DWORD i;
    BOOL  bCapturePixelShaderState = TRUE;

    // The device is not pure, so we can cast
    DXGASSERT((pBaseDev->BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0);
    CD3DHal *pDevI = static_cast<CD3DHal*>(pBaseDev);
    D3DFE_PROCESSVERTICES* pv = pDevI->m_pv;
    // Texture coordinate indices must be restored before capturing, because 
    // we do not call GetTextureStageState but access tsstates directly
    if (pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(pDevI);
        pDevI->ForceFVFRecompute();
    }
    switch(sbt)
    {
    case (D3DSTATEBLOCKTYPE)0:
        break;
    case D3DSBT_ALL:
        for(i = 0; i < sizeof(ALLrstates) / sizeof(D3DRENDERSTATETYPE); ++i)
            pDevI->m_pStateSets->InsertRenderState(ALLrstates[i], pDevI->rstates[ALLrstates[i]], pDevI->CanHandleRenderState(ALLrstates[i]));

        for (i = 0; i < pDevI->m_dwMaxTextureBlendStages; i++)
            for(DWORD j = 0; j < sizeof(ALLtsstates) / sizeof(D3DTEXTURESTAGESTATETYPE); ++j)
                pDevI->m_pStateSets->InsertTextureStageState(i, ALLtsstates[j], pDevI->tsstates[i][ALLtsstates[j]]);

        // Capture textures
        for (i = 0; i < pDevI->m_dwMaxTextureBlendStages; i++)
        {
            IDirect3DBaseTexture8 *pTex;
            if (pDevI->m_lpD3DMappedTexI[i] != 0)
            {
                switch(pDevI->m_lpD3DMappedTexI[i]->GetBufferDesc()->Type)
                {
                case D3DRTYPE_TEXTURE:
                    pTex = static_cast<IDirect3DTexture8*>(static_cast<CMipMap*>(pDevI->m_lpD3DMappedTexI[i]));
                    break;
                case D3DRTYPE_CUBETEXTURE:
                    pTex = static_cast<IDirect3DCubeTexture8*>(static_cast<CCubeMap*>(pDevI->m_lpD3DMappedTexI[i]));
                    break;
                case D3DRTYPE_VOLUMETEXTURE:
                    pTex = static_cast<IDirect3DVolumeTexture8*>(static_cast<CMipVolume*>(pDevI->m_lpD3DMappedTexI[i]));
                    break;
                }
            }
            else
            {
                pTex = 0;
            }
            pDevI->m_pStateSets->InsertTexture(i, pTex);
        }

        // Capture current palette
        pDevI->m_pStateSets->InsertCurrentTexturePalette(pDevI->m_dwPalette);

        // Capture streams
        for (i = 0; i < pDevI->m_dwNumStreams; i++)
        {
            pDevI->m_pStateSets->InsertStreamSource(i, pDevI->m_pStream[i].m_pVB, pDevI->m_pStream[i].m_dwStride);
        }
        pDevI->m_pStateSets->InsertIndices(pDevI->m_pIndexStream->m_pVBI, pDevI->m_pIndexStream->m_dwBaseIndex);

        // Capture current viewport
        pDevI->m_pStateSets->InsertViewport(&pDevI->m_Viewport);

        // Capture current transforms
        for (i = 0; i < __MAXWORLDMATRICES; i++)
        {
            pDevI->m_pStateSets->InsertTransform(D3DTS_WORLDMATRIX(i), (LPD3DMATRIX)&pv->world[i]);
        }
        pDevI->m_pStateSets->InsertTransform(D3DTRANSFORMSTATE_VIEW, (LPD3DMATRIX)&pv->view);
        pDevI->m_pStateSets->InsertTransform(D3DTRANSFORMSTATE_PROJECTION, (LPD3DMATRIX)&pDevI->transform.proj);
        for (i = 0; i < pDevI->m_dwMaxTextureBlendStages; i++)
        {
            pDevI->m_pStateSets->InsertTransform((D3DTRANSFORMSTATETYPE)(D3DTRANSFORMSTATE_TEXTURE0 + i), (LPD3DMATRIX)&pv->mTexture[i]);
        }

        // Capture current clip-planes
        for (i = 0; i < pDevI->m_dwMaxUserClipPlanes; i++)
        {
            pDevI->m_pStateSets->InsertClipPlane(i, (LPD3DVALUE)&pDevI->transform.userClipPlane[i]);
        }

        // Capture current material
        pDevI->m_pStateSets->InsertMaterial(&pv->lighting.material);

        // Capture current lights
        for (i = 0; i < pDevI->m_pLightArray->GetSize(); i++)
        {
            LPDIRECT3DLIGHTI pLight =
                static_cast<DIRECT3DLIGHTI *>((*pDevI->m_pLightArray)[i].m_pObj);
            if( pLight)
            {
                pDevI->m_pStateSets->InsertLight(i, &pLight->m_Light);
                if(pLight->Enabled())
                {
                    pDevI->m_pStateSets->InsertLightEnable(i, TRUE);
                }
                else
                {
                    pDevI->m_pStateSets->InsertLightEnable(i, FALSE);
                }
            }
        }

        // Capture current shaders
        if (D3DVSD_ISLEGACY(pDevI->m_dwCurrentShaderHandle))
        {
            pDevI->m_pStateSets->InsertVertexShader(pDevI->m_dwCurrentShaderHandle, TRUE);
        }
        else
        {
            CVShader* pShader = (CVShader*)pDevI->m_pVShaderArray->GetObject(pDevI->m_dwCurrentShaderHandle);
            if (pShader->m_dwFlags & CVShader::SOFTWARE)
            {
                pDevI->m_pStateSets->InsertVertexShader(pDevI->m_dwCurrentShaderHandle, FALSE);
            }
            else
            {
                pDevI->m_pStateSets->InsertVertexShader(pDevI->m_dwCurrentShaderHandle, TRUE);
            }
        }

        if( bCapturePixelShaderState )
            pDevI->m_pStateSets->InsertPixelShader(pDevI->m_dwCurrentPixelShaderHandle);

        // Capture shader constants. Use Microsoft's constants as a temp buffer
        {
            const UINT count = pDevI->m_MaxVertexShaderConst;
            pDevI->GetVertexShaderConstant(0, pDevI->GeometryFuncsGuaranteed->m_VertexVM.GetRegisters()->m_c, count);
            pDevI->m_pStateSets->InsertVertexShaderConstant(0, pDevI->GeometryFuncsGuaranteed->m_VertexVM.GetRegisters()->m_c, count);
        }

        // Capture pixel shader constants
        if( bCapturePixelShaderState )
        {
            // Note this is hardcoded to 8. ff.ff supports 16 but here we capture only 8.
            pDevI->m_pStateSets->InsertPixelShaderConstant(0, pDevI->m_PShaderConstReg, 8 );
        }
        
        break;

    case D3DSBT_PIXELSTATE:
        for(i = 0; i < sizeof(PIXELrstates) / sizeof(D3DRENDERSTATETYPE); ++i)
            pDevI->m_pStateSets->InsertRenderState(PIXELrstates[i], pDevI->rstates[PIXELrstates[i]], pDevI->CanHandleRenderState(PIXELrstates[i]));

        for (i = 0; i < pDevI->m_dwMaxTextureBlendStages; i++)
            for(DWORD j = 0; j < sizeof(PIXELtsstates) / sizeof(D3DTEXTURESTAGESTATETYPE); ++j)
                pDevI->m_pStateSets->InsertTextureStageState(i, PIXELtsstates[j], pDevI->tsstates[i][PIXELtsstates[j]]);

        // Capture pixel shader constants
        if( bCapturePixelShaderState )
            pDevI->m_pStateSets->InsertPixelShaderConstant(0, pDevI->m_PShaderConstReg,
                                                           D3DPS_CONSTREG_MAX_DX8);

        // Capture current pixel shader
        if( bCapturePixelShaderState )
            pDevI->m_pStateSets->InsertPixelShader(pDevI->m_dwCurrentPixelShaderHandle);
        break;

    case D3DSBT_VERTEXSTATE:
        for(i = 0; i < sizeof(VERTEXrstates) / sizeof(D3DRENDERSTATETYPE); ++i)
            pDevI->m_pStateSets->InsertRenderState(VERTEXrstates[i], pDevI->rstates[VERTEXrstates[i]], pDevI->CanHandleRenderState(VERTEXrstates[i]));

        for (i = 0; i < pDevI->m_dwMaxTextureBlendStages; i++)
            for(DWORD j = 0; j < sizeof(VERTEXtsstates) / sizeof(D3DTEXTURESTAGESTATETYPE); ++j)
                pDevI->m_pStateSets->InsertTextureStageState(i, VERTEXtsstates[j], pDevI->tsstates[i][VERTEXtsstates[j]]);

        // Capture current light enables
        for (i = 0; i < pDevI->m_pLightArray->GetSize(); i++)
        {
            LPDIRECT3DLIGHTI pLight =
                static_cast<DIRECT3DLIGHTI *>((*pDevI->m_pLightArray)[i].m_pObj);
            if( pLight)
            {
                pDevI->m_pStateSets->InsertLight(i, &pLight->m_Light);
                if(pLight->Enabled())
                {
                    pDevI->m_pStateSets->InsertLightEnable(i, TRUE);
                }
                else
                {
                    pDevI->m_pStateSets->InsertLightEnable(i, FALSE);
                }
            }
        }

        // Capture shader constants. Use Microsoft's constants as a temp buffer
        {
            const UINT count = pDevI->m_MaxVertexShaderConst;
            pDevI->GetVertexShaderConstant(0, pDevI->GeometryFuncsGuaranteed->m_VertexVM.GetRegisters()->m_c, count);
            pDevI->m_pStateSets->InsertVertexShaderConstant(0, pDevI->GeometryFuncsGuaranteed->m_VertexVM.GetRegisters()->m_c, count);
        }

        // Capture current vertex shader
        if (D3DVSD_ISLEGACY(pDevI->m_dwCurrentShaderHandle))
        {
            pDevI->m_pStateSets->InsertVertexShader(pDevI->m_dwCurrentShaderHandle, TRUE);
        }
        else
        {
            CVShader* pShader = (CVShader*)pDevI->m_pVShaderArray->GetObject(pDevI->m_dwCurrentShaderHandle);
            if (pShader->m_dwFlags & CVShader::SOFTWARE)
            {
                pDevI->m_pStateSets->InsertVertexShader(pDevI->m_dwCurrentShaderHandle, FALSE);
            }
            else
            {
                pDevI->m_pStateSets->InsertVertexShader(pDevI->m_dwCurrentShaderHandle, TRUE);
            }
        }

        break;

    default:
        throw D3DERR_INVALIDCALL;
   }
   pDevI->m_pStateSets->EndSet();
   pDevI->m_pDDI->WriteStateSetToDevice(sbt);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CPureStateSet::InsertCommand"

void CPureStateSet::InsertCommand(D3DHAL_DP2OPERATION op, LPVOID pData,
                                  DWORD dwDataSize,
                                  BOOL bDriverCanHandle)
{
    switch(op)
    {
    case D3DDP2OP_FRONTENDDATA:
    case D3DDP2OP_FESETVB:
    case D3DDP2OP_FESETIB:
        m_FEOnlyBuffer.InsertCommand(op, pData, dwDataSize);
        break;
    default:
        m_DriverBuffer.InsertCommand(op, pData, dwDataSize);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CPureStateSet::Execute"

void CPureStateSet::Execute(CD3DBase *pDevI, BOOL bFrontEndBuffer)
{
    DWORD *p;
    DWORD dwSize;
    DWORD *pEnd;
    if (bFrontEndBuffer)
    {
        p = (DWORD*)m_FEOnlyBuffer.m_pBuffer;
        dwSize = m_FEOnlyBuffer.m_dwCurrentSize;
    }
    else
    {
        return;
    }
    pEnd = (DWORD*)((BYTE*)p + dwSize);
    while (p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
        switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
        {
        case D3DDP2OP_FRONTENDDATA:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FRONTENDDATA pData = (LPD3DHAL_DP2FRONTENDDATA)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FRONTENDDATA));
                    HRESULT ret = pDevI->SetTexture(pData->wStage, pData->pTexture);
                    if (ret != D3D_OK)
                        throw ret;
                }
                break;
            }
        case D3DDP2OP_FESETVB:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETVB pData = (LPD3DHAL_DP2FESETVB)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETVB));
                    HRESULT ret = pDevI->SetStreamSource(pData->wStream, pData->pBuf, pData->dwStride);
                    if (ret != D3D_OK)
                        throw ret;
                }
                break;
            }
        case D3DDP2OP_FESETIB:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETIB pData = (LPD3DHAL_DP2FESETIB)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETIB));
                    HRESULT ret = pDevI->SetIndices(pData->pBuf, pData->dwBase);
                    if (ret != D3D_OK)
                        throw ret;
                }
                break;
            }
        case D3DDP2OP_FESETPAL:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETPAL pData = (LPD3DHAL_DP2FESETPAL)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETPAL));
                    if( pData->dwPaletteNumber != __INVALIDPALETTE )
                    {
                        HRESULT ret = pDevI->SetCurrentTexturePalette(pData->dwPaletteNumber);
                        if (ret != D3D_OK)
                            throw ret;
                    }
                }
                break;
            }
#ifdef DBG
        default:
            DXGASSERT(FALSE);
#endif
        }
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CPureStateSet::Capture"

void CPureStateSet::Capture(CD3DBase *pDevI, BOOL bFrontEndBuffer)
{
    DWORD *p;
    DWORD dwSize;
    DWORD *pEnd;
    if (bFrontEndBuffer)
    {
        p = (DWORD*)m_FEOnlyBuffer.m_pBuffer;
        dwSize = m_FEOnlyBuffer.m_dwCurrentSize;
    }
    else
    {
        return;
    }
    pEnd = (DWORD*)((BYTE*)p + dwSize);
    while (p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
        switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
        {
        case D3DDP2OP_FRONTENDDATA:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FRONTENDDATA pData = (LPD3DHAL_DP2FRONTENDDATA)p;
                    CBaseTexture* pTexOld = NULL;
                    CBaseTexture* pTexNew = NULL;
                    pTexOld = CBaseTexture::SafeCast(pData->pTexture);
                    if( pTexOld )
                        pTexOld->DecrementUseCount();
                    pTexNew = pDevI->m_lpD3DMappedTexI[pData->wStage];
                    if( pTexNew )
                        pTexNew->IncrementUseCount();
                    if (pDevI->m_lpD3DMappedTexI[pData->wStage] != 0)
                    {
                        switch(pDevI->m_lpD3DMappedTexI[pData->wStage]->GetBufferDesc()->Type)
                        {
                        case D3DRTYPE_TEXTURE:
                            pData->pTexture = static_cast<IDirect3DTexture8*>(static_cast<CMipMap*>(pTexNew));
                            break;
                        case D3DRTYPE_CUBETEXTURE:
                            pData->pTexture = static_cast<IDirect3DCubeTexture8*>(static_cast<CCubeMap*>(pTexNew));
                            break;
                        case D3DRTYPE_VOLUMETEXTURE:
                            pData->pTexture = static_cast<IDirect3DVolumeTexture8*>(static_cast<CMipVolume*>(pTexNew));
                            break;
                        }
                    }
                    else
                    {
                        pData->pTexture = 0;
                    }
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FRONTENDDATA));
                }
                break;
            }
        case D3DDP2OP_FESETVB:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETVB pData = (LPD3DHAL_DP2FESETVB)p;
                    if( pData->pBuf )
                    {
                        pData->pBuf->DecrementUseCount();
                    }
                    pData->pBuf = pDevI->m_pStream[pData->wStream].m_pVB;
                    if( pData->pBuf )
                    {
                        pData->pBuf->IncrementUseCount();
                    }
                    pData->dwStride = pDevI->m_pStream[pData->wStream].m_dwStride;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETVB));
                }
                break;
            }
        case D3DDP2OP_FESETIB:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETIB pData = (LPD3DHAL_DP2FESETIB)p;
                    pData->pBuf = pDevI->m_pIndexStream->m_pVBI;
                    if( pData->pBuf )
                    {
                        pData->pBuf->DecrementUseCount();
                    }
                    pData->dwBase = pDevI->m_pIndexStream->m_dwBaseIndex;
                    if( pData->pBuf )
                    {
                        pData->pBuf->IncrementUseCount();
                    }
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETIB));
                }
                break;
            }
        case D3DDP2OP_FESETPAL:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETPAL pData = (LPD3DHAL_DP2FESETPAL)p;
                    pData->dwPaletteNumber = pDevI->m_dwPalette;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETPAL));
                }
                break;
            }
#ifdef DBG
        default:
            DXGASSERT(FALSE);
#endif
        }
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CPureStateSet::CreatePredefined"

void CPureStateSet::CreatePredefined(CD3DBase *pDevI, D3DSTATEBLOCKTYPE sbt)
{
    DWORD i;
    // The device is not pure, so we can cast
    switch(sbt)
    {
    case (D3DSTATEBLOCKTYPE)0:
        break;
    case D3DSBT_ALL:
        // Capture textures
        for (i = 0; i < pDevI->m_dwMaxTextureBlendStages; i++)
        {
            IDirect3DBaseTexture8 *pTex;
            if (pDevI->m_lpD3DMappedTexI[i] != 0)
            {
                switch(pDevI->m_lpD3DMappedTexI[i]->GetBufferDesc()->Type)
                {
                case D3DRTYPE_TEXTURE:
                    pTex = static_cast<IDirect3DTexture8*>(static_cast<CMipMap*>(pDevI->m_lpD3DMappedTexI[i]));
                    break;
                case D3DRTYPE_CUBETEXTURE:
                    pTex = static_cast<IDirect3DCubeTexture8*>(static_cast<CCubeMap*>(pDevI->m_lpD3DMappedTexI[i]));
                    break;
                case D3DRTYPE_VOLUMETEXTURE:
                    pTex = static_cast<IDirect3DVolumeTexture8*>(static_cast<CMipVolume*>(pDevI->m_lpD3DMappedTexI[i]));
                    break;
                }
            }
            else
            {
                pTex = 0;
            }
            pDevI->m_pStateSets->InsertTexture(i, pTex);
        }

        // Capture streams
        for (i = 0; i < pDevI->m_dwNumStreams; i++)
        {
            pDevI->m_pStateSets->InsertStreamSource(i, pDevI->m_pStream[i].m_pVB, pDevI->m_pStream[i].m_dwStride);
        }
        pDevI->m_pStateSets->InsertIndices(pDevI->m_pIndexStream->m_pVBI, pDevI->m_pIndexStream->m_dwBaseIndex);

        break;

    case D3DSBT_PIXELSTATE:
        break;

    case D3DSBT_VERTEXSTATE:
        break;

    default:
        throw D3DERR_INVALIDCALL;
    }
    pDevI->m_pStateSets->EndSet();
        DWORD DeviceHandle;
    pDevI->m_pStateSets->CreateNewDeviceHandle(&DeviceHandle);
    pDevI->m_pDDI->InsertStateSetOp(D3DHAL_STATESETCREATE, DeviceHandle, sbt);
}
//=====================================================================
//      CStateSetBuffer interface
//
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSetBuffer::InsertCommand"

void CStateSetBuffer::InsertCommand(D3DHAL_DP2OPERATION op, LPVOID pData, DWORD dwDataSize)
{
    const DWORD GROWSIZE = 1024;
    if (m_pDP2CurrCommand != 0 && m_pDP2CurrCommand->bCommand == op)
    {
        if (dwDataSize + m_dwCurrentSize <= m_dwBufferSize)
        {
            ++m_pDP2CurrCommand->wStateCount;
            memcpy(m_pBuffer + m_dwCurrentSize, pData, dwDataSize);
            m_dwCurrentSize += dwDataSize;
            return;
        }
    }
    // Check for space
    if (sizeof(D3DHAL_DP2COMMAND) + dwDataSize + m_dwCurrentSize > m_dwBufferSize)
    {
        // We need to grow the buffer
        DWORD dwNewBufferSize = max(m_dwBufferSize + GROWSIZE, sizeof(D3DHAL_DP2COMMAND) + dwDataSize + m_dwCurrentSize);
        BYTE *pTmp = new BYTE[dwNewBufferSize];
        if (pTmp == NULL)
        {
            D3D_ERR("Not enough memory to create state block buffer");
            throw E_OUTOFMEMORY;
        }
        if (m_pBuffer)
        {
            memcpy(pTmp, m_pBuffer, m_dwCurrentSize);
            delete [] m_pBuffer;
        }
        m_pBuffer = pTmp;
        m_dwBufferSize = dwNewBufferSize;
    }
    // Add new instruction
    m_pDP2CurrCommand = (LPD3DHAL_DP2COMMAND)(m_pBuffer + m_dwCurrentSize);
    m_pDP2CurrCommand->bCommand = op;
    m_pDP2CurrCommand->bReserved = 0;
    m_pDP2CurrCommand->wStateCount = 1;
    m_dwCurrentSize += sizeof(D3DHAL_DP2COMMAND);
    memcpy(m_pBuffer + m_dwCurrentSize, pData, dwDataSize);
    m_dwCurrentSize += dwDataSize;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\buffer.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       buffer.cpp
 *  Content:    Implementation of the CBuffer class.
 *
 *
 ***************************************************************************/

#include "ddrawpr.h"

#include "buffer.hpp"


#undef DPF_MODNAME
#define DPF_MODNAME "CBuffer::CBuffer"

// Constructor returns an error code
// if the object could not be fully
// constructed
CBuffer::CBuffer(CBaseDevice       *pDevice,
                 DWORD              cbLength,
                 DWORD              dwFVF,
                 D3DFORMAT          Format,
                 D3DRESOURCETYPE    Type,
                 DWORD              dwUsage,
                 DWORD              dwActualUsage,
                 D3DPOOL            Pool,
                 D3DPOOL            ActualPool,
                 REF_TYPE           refType,
                 HRESULT           *phr
                 ) :
    CResource(pDevice, Pool, refType),
    m_pbBuffer(NULL),
#if DBG
    m_isLockable((dwActualUsage & (D3DUSAGE_LOCK | D3DUSAGE_LOADONCE)) != 0),
    m_SceneStamp(0xFFFFFFFF),
    m_TimesLocked(0),
#endif // DBG
    m_LockCount(0)
{
    // Determine if we need to allocate
    // any memory
    if (ActualPool == D3DPOOL_SYSTEMMEM ||
        IsTypeD3DManaged(pDevice, Type, ActualPool))
    {
        // cbLength must be a DWORD multiple
        cbLength = (cbLength + 3) & (DWORD) ~3;

        m_pbBuffer = new BYTE[cbLength];

        if (m_pbBuffer == NULL)
        {
            DPF_ERR("Out Of Memory allocating vertex or index buffer");
            *phr = E_OUTOFMEMORY;
            return;
        }

        DXGASSERT((cbLength & 3) == 0);
    }


    // We need to call the driver
    // to get a handle for all cases

    // Create a DDSURFACEINFO and CreateSurfaceData object
    DDSURFACEINFO SurfInfo;
    ZeroMemory(&SurfInfo, sizeof(SurfInfo));

    D3D8_CREATESURFACEDATA CreateSurfaceData;
    ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

    // Set up the basic information
    CreateSurfaceData.hDD      = pDevice->GetHandle();
    CreateSurfaceData.pSList   = &SurfInfo;
    CreateSurfaceData.dwSCnt   = 1;
    CreateSurfaceData.Type     = Type;
    CreateSurfaceData.dwUsage  = dwActualUsage;
    CreateSurfaceData.Pool     = DetermineCreationPool(Device(), Type, dwActualUsage, ActualPool);
    CreateSurfaceData.Format   = Format;
    CreateSurfaceData.MultiSampleType = D3DMULTISAMPLE_NONE;
    CreateSurfaceData.dwFVF    = dwFVF;

    if (Pool == D3DPOOL_DEFAULT &&
        CreateSurfaceData.Pool == D3DPOOL_SYSTEMMEM)
    {
        // If we are using sys-mem in cases where the
        // user asked for POOL_DEFAULT, we need to let
        // the thunk layer know so that Reset will
        // fail if this buffer hasn't been released
        CreateSurfaceData.bTreatAsVidMem = TRUE;
    }

    // Specify the surface data
    SurfInfo.cpWidth           = cbLength;
    SurfInfo.cpHeight          = 1;
    SurfInfo.pbPixels          = m_pbBuffer;
    SurfInfo.iPitch            = cbLength;

    // Call thunk to get our handles
    *phr = pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
    if (FAILED(*phr))
        return;

    // Cache away our handle
    SetKernelHandle(SurfInfo.hKernelHandle);

    return;

} // CBuffer::CBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CBuffer::~CBuffer"

// Destructor
CBuffer::~CBuffer()
{
    // Tell the thunk layer that we need to
    // be freed.
    if (CBaseObject::BaseKernelHandle())
    {
        D3D8_DESTROYSURFACEDATA DestroySurfData;
        DestroySurfData.hDD = Device()->GetHandle();
        DestroySurfData.hSurface = CBaseObject::BaseKernelHandle();
        Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
    }

    delete [] m_pbBuffer;

} // CBuffer::~CBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CBuffer::OnBufferChangeImpl"

void CBuffer::OnBufferChangeImpl(UINT cbOffsetToLock, UINT cbSizeToLock)
{
    // 0 for cbSizeToLock; means the rest of the buffer
    // We use this as a special value.
    DWORD cbOffsetMax;
    if (cbSizeToLock == 0)
        cbOffsetMax = 0;
    else
        cbOffsetMax = cbOffsetToLock + cbSizeToLock;

    if (!IsDirty())
    {
        m_cbDirtyMin    = cbOffsetToLock;
        m_cbDirtyMax    = cbOffsetMax;
        OnResourceDirty();
    }
    else
    {
        if (m_cbDirtyMin > cbOffsetToLock)
            m_cbDirtyMin = cbOffsetToLock;

        // An cbOffsetMax of zero means all the way to the
        // end of the buffer
        if (m_cbDirtyMax < cbOffsetMax || cbOffsetMax == 0)
            m_cbDirtyMax = cbOffsetMax;

        // We should already be marked as dirty
        DXGASSERT(IsDirty());
    }
    return;
} // OnBufferChangeImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CBuffer::MarkAllDirty"

void CBuffer::MarkAllDirty()
{
    // Mark our dirty bounds as being the whole
    // thing.
    m_cbDirtyMin = 0;

    // Zero for max is a special value meaning
    // all they way to the end
    m_cbDirtyMax = 0;

    // Mark ourselves as dirty
    OnResourceDirty();
} // CBuffer::MarkAllDirty

// Methods for CCommandBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CCommandBuffer::Create"

// Static class function for creating a command buffer object.
// (Because it is static; it doesn't have a this pointer.)

// Creation function for Command Buffers
HRESULT CCommandBuffer::Create(CBaseDevice *pDevice,
                               DWORD cbLength,
                               D3DPOOL Pool,
                               CCommandBuffer **ppCmdBuffer)
{
    HRESULT hr;

    // Zero-out return parameter
    *ppCmdBuffer = NULL;

    // Allocate new buffer
    CCommandBuffer *pCmdBuffer;
    DXGASSERT(Pool == D3DPOOL_SYSTEMMEM);
    pCmdBuffer = new CCommandBuffer(pDevice,
                                    cbLength,
                                    Pool,
                                    &hr);

    if (pCmdBuffer == NULL)
    {
        DPF_ERR("Out of Memory creating command buffer");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        // Command buffers are always internal and hence
        // need to be released through DecrementUseCount
        DPF_ERR("Error during initialization of command buffer");
        pCmdBuffer->DecrementUseCount();
        return hr;
    }

    // We're done; just return the object
    *ppCmdBuffer = pCmdBuffer;

    return hr;
} // static CCommandBuffer::Create

#undef DPF_MODNAME
#define DPF_MODNAME "CCommandBuffer::Clone"

HRESULT CCommandBuffer::Clone(D3DPOOL    Pool,
                              CResource **ppResource) const
{
    HRESULT hr;
    *ppResource = new CCommandBuffer(Device(), m_cbLength, Pool, &hr);
    if (*ppResource == NULL)
    {
        DPF_ERR("Failed to allocate command buffer");
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
        DPF_ERR("Failure creating command buffer");
    }
    return hr;
} // CCommandBuffer::Clone



// End of file : buffer.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\stateset.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       stateset.hpp
 *  Content:    State sets handling interfaces
 *
 ***************************************************************************/
#ifndef _STATESET_HPP_
#define _STATESET_HPP_

#include "hmgr.hpp"

extern void InsertStateSetOp(CD3DBase *pDevI, DWORD dwOperation, DWORD dwParam, D3DSTATEBLOCKTYPE sbt);

 //---------------------------------------------------------------------
// This class provides interface to the growing state set buffer
//
class CStateSetBuffer
{
public:
    CStateSetBuffer()
        {
            m_pBuffer = NULL;
            m_dwCurrentSize = 0;
            m_dwBufferSize = 0;
            m_pDP2CurrCommand = 0;
        }
    CStateSetBuffer(CStateSetBuffer& src)
        {
            m_dwCurrentSize = src.m_dwCurrentSize;
            m_dwBufferSize = src.m_dwCurrentSize;
            if(m_dwCurrentSize != 0)
            {
                m_pBuffer = new BYTE[m_dwCurrentSize];
                if(m_pBuffer == 0)
                {
                    m_dwCurrentSize = 0;
                    m_pDP2CurrCommand = 0;
                    throw E_OUTOFMEMORY;
                }
                memcpy(m_pBuffer, src.m_pBuffer, m_dwCurrentSize);
            }
            else
            {
                m_pBuffer = 0;
            }
            m_pDP2CurrCommand = 0;
        }
    ~CStateSetBuffer()
        {
            delete [] m_pBuffer;
        }
    void operator=(CStateSetBuffer& src)
        {
            m_dwCurrentSize = src.m_dwCurrentSize;
            if(m_dwBufferSize != m_dwCurrentSize)
            {
                m_dwBufferSize = m_dwCurrentSize;
                delete [] m_pBuffer;
                if(m_dwCurrentSize != 0)
                {
                    m_pBuffer = new BYTE[m_dwCurrentSize];
                    if(m_pBuffer == 0)
                    {
                        m_dwCurrentSize = 0;
                        m_pDP2CurrCommand = 0;
                        throw E_OUTOFMEMORY;
                    }
                }
                else
                {
                    m_pBuffer = 0;
                    m_pDP2CurrCommand = 0;
                    return;
                }
            }
            memcpy(m_pBuffer, src.m_pBuffer, m_dwCurrentSize);
            m_pDP2CurrCommand = 0;
        }
    // Insert a command to the buffer. Grow buffer if necessary
    void InsertCommand(D3DHAL_DP2OPERATION, LPVOID pData, DWORD dwDataSize);
    // Reset current command
    void ResetCurrentCommand()
        {
            m_pDP2CurrCommand = 0;
        }
    // Set buffer to its initial state. Memory is not freed
    void Reset()
        {
            m_dwCurrentSize = 0;
            m_pDP2CurrCommand = 0;
        }

    DWORD   m_dwCurrentSize;
    DWORD   m_dwBufferSize;
    BYTE    *m_pBuffer;
    //Pointer to the current position the CB1 buffer
    LPD3DHAL_DP2COMMAND m_pDP2CurrCommand;
};
//---------------------------------------------------------------------
// This class provides interface to a state set
//
const DWORD __STATESET_INITIALIZED          = 1;
// Set if we have to check if we need to restore texture stage indices
const DWORD __STATESET_NEEDCHECKREMAPPING   = 2;
// Set if the state set executed had purely pixel state
const DWORD __STATESET_HASONLYVERTEXSTATE   = 4;
class CStateSet
{
public:
    CStateSet()
        {
            m_dwStateSetFlags = 0;
            m_dwDeviceHandle = __INVALIDHANDLE;
        }
    virtual void InsertCommand(D3DHAL_DP2OPERATION, LPVOID pData, DWORD dwDataSize, BOOL bDriverCanHandle);
    // Mark the state set as unused. The object is not destroyed and can be
    // reused
    HRESULT Release();
    // Execute the front-end only or device state subset
    virtual void Execute(CD3DBase *pDevI, BOOL bFrontEndBuffer);
    // Capture the current device state into the state block
    virtual void Capture(CD3DBase *pDevI, BOOL bFrontEndBuffer);
    // Create a predefined state block
    virtual void CreatePredefined(CD3DBase *pDevI, D3DSTATEBLOCKTYPE sbt);
    // Reset the current command in both buffers
    void ResetCurrentCommand()
        {
            m_FEOnlyBuffer.ResetCurrentCommand();
            m_DriverBuffer.ResetCurrentCommand();
        }
protected:
    CStateSetBuffer m_FEOnlyBuffer; // Contains commands that driver can not
                                    // understand
    CStateSetBuffer m_DriverBuffer; // Contains commands that driver can
                                    // understand
    DWORD   m_dwDeviceHandle;       // Some sets could not have corresponding
                                    // device buffers, so device handle is not
                                    // equal to the user visible handle
    DWORD   m_dwStateSetFlags;
    friend class CStateSets;
};

class CPureStateSet : public CStateSet
{
public:
    void InsertCommand(D3DHAL_DP2OPERATION, LPVOID pData, DWORD dwDataSize, BOOL bDriverCanHandle);
    void Execute(CD3DBase *pDevI, BOOL bFrontEndBuffer);
    void Capture(CD3DBase *pDevI, BOOL bFrontEndBuffer);
    void CreatePredefined(CD3DBase *pDevI, D3DSTATEBLOCKTYPE sbt);
};
//---------------------------------------------------------------------
// This class encapsulates handling of array of state sets
//
class CStateSets
{
public:
    CStateSets();
    ~CStateSets();
    HRESULT Init(CD3DBase *pDev);
    HRESULT StartNewSet();
    void EndSet();
    // Returns current handle
    DWORD GetCurrentHandle() {return m_dwCurrentHandle;}
    // Delete state set
    void DeleteStateSet(CD3DBase *pDevI, DWORD dwHandle);
    // Returns information about state set data to be written to the device
    // Allocates a new handle for the device buffer
    void GetDeviceBufferInfo(DWORD* dwStateSetHandle, LPVOID *pBuffer, DWORD* dwBufferSize);
    void CreateNewDeviceHandle(DWORD* dwStateSetHandle);
    // Copy buffer and translate for DX7 DDI
    void TranslateDeviceBufferToDX7DDI( DWORD* p, DWORD dwSize );
    // Insert a render state to the current state set
    // Throws an exception in case of error
    void InsertRenderState(D3DRENDERSTATETYPE state, DWORD dwValue,
                           BOOL bDriverCanHandle);
    void InsertLight(DWORD dwLightIndex, CONST D3DLIGHT8*);
    void InsertLightEnable(DWORD dwLightIndex, BOOL bEnable);
    void InsertMaterial(CONST D3DMATERIAL8*);
    void InsertViewport(CONST D3DVIEWPORT8*);
    void InsertTransform(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat);
    void InsertTextureStageState(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD);
    void InsertTexture(DWORD dwStage, IDirect3DBaseTexture8 *pTex);
    void InsertClipPlane(DWORD dwPlaneIndex, CONST D3DVALUE* pPlaneEquation);
    void InsertVertexShader(DWORD dwShaderHandle, BOOL bHardware);
    void InsertPixelShader(DWORD dwShaderHandle);
    void InsertStreamSource(DWORD dwStream, CVertexBuffer *pBuf, DWORD dwStride);
    void InsertIndices(CIndexBuffer *pBuf, DWORD dwBaseVertex);
    void InsertVertexShaderConstant(DWORD Register, CONST VOID* pConstantData, DWORD ConstantCount);
    void InsertPixelShaderConstant(DWORD Register, CONST VOID* pConstantData, DWORD ConstantCount);
    void InsertCurrentTexturePalette(DWORD PaletteNumber);
    // Execute a state set with the specified handle
    void Execute(CD3DBase *pDevI, DWORD dwHandle);
    // Capture a state set to the the specified handle
    void Capture(CD3DBase *pDevI, DWORD dwHandle);
    // Capture predefined state
    void CreatePredefined(CD3DBase *pDevI, D3DSTATEBLOCKTYPE sbt);
    void Cleanup(DWORD dwHandle);
protected:
    const DWORD m_GrowSize;
    DWORD       m_dwMaxSets;        // Maximum number of state sets
    DWORD       m_dwCurrentHandle;
    CStateSet * m_pStateSets;       // Array of state sets
    CStateSet * m_pCurrentStateSet;
    CHandleFactory m_DeviceHandles; // Used to create device handles
    CHandleFactory m_SetHandles;    // Used to create state sets
    CStateSet * m_pBufferSet;
    DWORD       m_dwFlags;
    BOOL        m_bPure, m_bTLHal, m_bEmulate, m_bDX8Dev, m_bHardwareVP;
};

// This is RESERVED0 in d3dhal.h
#define D3DDP2OP_FRONTENDDATA   4           // Used by the front-end only
#define D3DDP2OP_FESETVB        5
#define D3DDP2OP_FESETIB        6
#define D3DDP2OP_FESETPAL       7

// This structure is used by the front-end only
typedef struct _D3DHAL_DP2FRONTENDDATA
{
    WORD                    wStage;      // texture stage
    IDirect3DBaseTexture8 * pTexture;    // Texture pointer
} D3DHAL_DP2FRONTENDDATA;
typedef D3DHAL_DP2FRONTENDDATA UNALIGNED64 * LPD3DHAL_DP2FRONTENDDATA;

typedef struct _D3DHAL_DP2FESETVB
{
    WORD                    wStream;
    CVertexBuffer * pBuf;
    DWORD                   dwStride;
} D3DHAL_DP2FESETVB;
typedef D3DHAL_DP2FESETVB UNALIGNED64 * LPD3DHAL_DP2FESETVB;

typedef struct _D3DHAL_DP2FESETIB
{
   CIndexBuffer * pBuf;
   DWORD                    dwBase;
} D3DHAL_DP2FESETIB;
typedef D3DHAL_DP2FESETIB UNALIGNED64 * LPD3DHAL_DP2FESETIB;

typedef struct _D3DHAL_DP2FESETPAL
{
    DWORD                   dwPaletteNumber;
} D3DHAL_DP2FESETPAL;
typedef D3DHAL_DP2FESETPAL UNALIGNED64 * LPD3DHAL_DP2FESETPAL;

#endif //_STATESTE_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\vwport.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   vwport.c
 *  Content:    Direct3D viewport functions
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Create an api for the Direct3DViewport object
 */

#include "drawprim.hpp"
#include "ddibase.h"

//---------------------------------------------------------------------
// Update pre-computed constants related to viewport
//
// This functions should be called every time the viewport parameters are
// changed
//
// Notes:
//      1. scaleY and offsetY are computed to flip Y axes from up to down.
//      2. Mclip matrix is computed multiplied by Mshift matrix
//
const D3DVALUE SMALL_NUMBER = 0.000001f;

void
UpdateViewportCache(LPD3DHAL device, D3DVIEWPORT8 *data)
{
#if DBG
    // Bail if we are going to cause any divide by zero exceptions.
    // The likely reason is that we have a bogus viewport set by
    // TLVertex execute buffer app.
    if (data->Width == 0 || data->Height == 0)
    {
        D3D_ERR("Viewport width or height is zero");
        throw D3DERR_INVALIDCALL;
    }
    if (data->MaxZ < 0 ||
        data->MinZ < 0 ||
        data->MaxZ > 1 ||
        data->MinZ > 1)
    {
        D3D_ERR("dvMaxZ and dvMinZ should be between 0 and 1");
        throw D3DERR_INVALIDCALL;
    }
    if (data->MaxZ < data->MinZ)
    {
        D3D_ERR("dvMaxZ should not be smaller than dvMinZ");
        throw D3DERR_INVALIDCALL;
    }
#endif // DBG
    const D3DVALUE eps = 0.001f;
    if (data->MaxZ - data->MinZ < eps)
    {
        // When we clip, we transform vertices from the screen space to the
        // clipping space. With the above condition it is impossible. So we do
        // a little hack here by setting dvMinZ and dvMaxZ to different values
        if (data->MaxZ >= 0.5f)
            data->MinZ = data->MaxZ - eps;
        else
            data->MaxZ = data->MinZ + eps;
    }
    D3DFE_VIEWPORTCACHE *cache = &device->m_pv->vcache;
    cache->dvX = D3DVAL(data->X);
    cache->dvY = D3DVAL(data->Y);
    cache->dvWidth = D3DVAL(data->Width);
    cache->dvHeight = D3DVAL(data->Height);

    cache->scaleX  = cache->dvWidth;
    cache->scaleY  = - cache->dvHeight;
    cache->scaleZ  = D3DVAL(data->MaxZ - data->MinZ);
    cache->offsetX = cache->dvX;
    cache->offsetY = cache->dvY + cache->dvHeight;
    cache->offsetZ = D3DVAL(data->MinZ);
    // Small offset is added to prevent generation of negative screen
    // coordinates (this could happen because of precision errors).
    cache->offsetX += SMALL_NUMBER;
    cache->offsetY += SMALL_NUMBER;

    cache->scaleXi = D3DVAL(1) / cache->scaleX;
    cache->scaleYi = D3DVAL(1) / cache->scaleY;
    cache->scaleZi = D3DVAL(1) / cache->scaleZ;
    cache->minX = cache->dvX;
    cache->maxX = cache->dvX + cache->dvWidth;
    cache->minY = cache->dvY;
    cache->maxY = cache->dvY + cache->dvHeight;
    cache->minXi = FTOI(cache->minX);
    cache->maxXi = FTOI(cache->maxX);
    cache->minYi = FTOI(cache->minY);
    cache->maxYi = FTOI(cache->maxY);
    if (device->m_pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        const D3DCAPS8 *pCaps = device->GetD3DCaps();

        // Because we clip by guard band window we have to use its extents
        cache->minXgb = pCaps->GuardBandLeft;
        cache->maxXgb = pCaps->GuardBandRight;
        cache->minYgb = pCaps->GuardBandTop;
        cache->maxYgb = pCaps->GuardBandBottom;

        D3DVALUE w = 2.0f / cache->dvWidth;
        D3DVALUE h = 2.0f / cache->dvHeight;
        D3DVALUE ax1 = -(pCaps->GuardBandLeft - cache->dvX)   * w + 1.0f;
        D3DVALUE ax2 =  (pCaps->GuardBandRight  - cache->dvX) * w - 1.0f;
        D3DVALUE ay1 =  (pCaps->GuardBandBottom - cache->dvY) * h - 1.0f;
        D3DVALUE ay2 = -(pCaps->GuardBandTop - cache->dvY)    * h + 1.0f;
        cache->gb11 = 2.0f / (ax1 + ax2);
        cache->gb41 = cache->gb11 * (ax1 - 1.0f) * 0.5f;
        cache->gb22 = 2.0f / (ay1 + ay2);
        cache->gb42 = cache->gb22 * (ay1 - 1.0f) * 0.5f;

        cache->Kgbx1 = 0.5f * (1.0f - ax1);
        cache->Kgbx2 = 0.5f * (1.0f + ax2);
        cache->Kgby1 = 0.5f * (1.0f - ay1);
        cache->Kgby2 = 0.5f * (1.0f + ay2);
    }
    else
    {
        cache->minXgb = cache->minX;
        cache->maxXgb = cache->maxX;
        cache->minYgb = cache->minY;
        cache->maxYgb = cache->maxY;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CheckViewport"

void CD3DBase::CheckViewport(CONST D3DVIEWPORT8* lpData)
{
    // We have to check parameters here, because viewport could be changed
    // after creating a state set
    DWORD uSurfWidth,uSurfHeight;
    D3DSURFACE_DESC desc = this->RenderTarget()->InternalGetDesc();

    uSurfWidth  = desc.Width;
    uSurfHeight = desc.Height;

    if (lpData->X > uSurfWidth ||
        lpData->Y > uSurfHeight ||
        lpData->X + lpData->Width > uSurfWidth ||
        lpData->Y + lpData->Height > uSurfHeight)
    {
        D3D_THROW(D3DERR_INVALIDCALL, "Viewport outside the render target surface");
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetViewportI"

void CD3DHal::SetViewportI(CONST D3DVIEWPORT8* lpData)
{
    // We check viewport here, because the render target could have been
    // changed after a state block is created
    CheckViewport(lpData);

    m_Viewport = *lpData;
    // Update front-end data
    UpdateViewportCache(this, &this->m_Viewport);
    if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
        m_pDDI->SetViewport(&m_Viewport);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetViewport"

HRESULT
D3DAPI CD3DHal::GetViewport(D3DVIEWPORT8* lpData)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_WRITEPTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR( "Invalid viewport pointer. GetViewport failed." );
        return D3DERR_INVALIDCALL;
    }

    *lpData = this->m_Viewport;

    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\buffer.hpp ===
#ifndef __BUFFER_HPP__
#define __BUFFER_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       buffer.hpp
 *  Content:    Class header the buffer base class; this class
 *              contains all the logic that is shared between
 *              the Index/Vertex/Command buffer types.
 *
 ***************************************************************************/

// Includes
#include "resource.hpp"

//
// The CBuffer is a base class for the index and vertex buffers
//

class CBuffer : public CResource
{
public:
    // Methods for Resource management
    virtual HRESULT UpdateDirtyPortion(CResource *pResourceTarget) { return S_OK; }
    virtual void MarkAllDirty();

    virtual BYTE* Data() const = 0;

    BOOL IsLocked() const
    {
        return m_LockCount > 0;
    } // IsLocked

protected:
    // Constructor returns an error code
    // if the object could not be fully
    // constructed
    CBuffer(CBaseDevice     *pDevice,
            DWORD            cbLength,
            DWORD            dwFVF,
            D3DFORMAT        Format,
            D3DRESOURCETYPE  Type,
            DWORD            Usage,
            DWORD            ActualUsage,
            D3DPOOL          Pool,
            D3DPOOL          ActualPool,
            REF_TYPE         refType,
            HRESULT         *phr
            );

    void LockImpl(UINT cbOffsetToLock,
                  UINT cbSizeToLock,
                  BYTE **ppbData,
                  DWORD dwFlags,
                  DWORD cbLength)
    {
        *ppbData = m_pbBuffer + cbOffsetToLock;

        // Do dirty rect stuff
        if (IsD3DManaged() && (dwFlags & D3DLOCK_READONLY) == 0)
        {
            OnBufferChangeImpl(cbOffsetToLock, cbSizeToLock);
        }
    }

    void OnBufferChangeImpl(UINT cbOffsetToLock, UINT cbSizeToLock);

    BYTE* GetPrivateDataPointer() const
    {
        return m_pbBuffer;
    }

#if DBG
    BOOL    m_isLockable;
    DWORD   m_SceneStamp;
    DWORD   m_TimesLocked;
#endif // DBG

    DWORD   m_LockCount;
    DWORD   m_cbDirtyMin;
    DWORD   m_cbDirtyMax;

    // Destructor
    virtual ~CBuffer();

private:

    BYTE   *m_pbBuffer;
}; // class CBuffer

// HACK: Ok; here's a minimal command buffer... This is probably not
// the final implementation; but hey there you go.
class CCommandBuffer : public CBuffer
{
public:
    // Static creation method
    static HRESULT Create(CBaseDevice *pDevice,
                          DWORD cbLength,
                          D3DPOOL Pool,
                          CCommandBuffer **ppIndexBuffer);

    HRESULT Clone(D3DPOOL    Pool,
                  CResource **ppResource) const;

    const D3DBUFFER_DESC * GetBufferDesc() const
    {
        return &m_desc;
    } // GetDesc

    // You must call Release to free this guy. No support for
    // addref
    UINT Release()
    {
        return ReleaseImpl();
    };

    // Lock and Unlock support

    STDMETHOD(Lock)(THIS_
                    UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags)
    {
#if DBG
        if (m_LockCount != 0)
        {
            DPF_ERR("Lock failed for command buffer; buffer was already locked.");
            return D3DERR_INVALIDCALL;
        }
#endif // DBG

        m_LockCount = 1;

        LockImpl(cbOffsetToLock,
                 cbSizeToLock,
                 ppbData,
                 dwFlags,
                 m_cbLength);
        return S_OK;
    } // Lock

    STDMETHOD(Unlock)(THIS)
    {
#if DBG
        // If we aren't locked; then something is wrong
        if (m_LockCount != 1)
        {
            DPF_ERR("Unlock failed on a command buffer; buffer wasn't locked.");
            return D3DERR_INVALIDCALL;
        }
#endif // DBG

        // Clear our locked state
        m_LockCount = 0;

        return S_OK;
    } // Unlock

    BYTE* Data() const
    {
        DXGASSERT(FALSE); // Direct access not supported
        return 0;
    }

private:
    CCommandBuffer(CBaseDevice *pDevice,
                   DWORD        cbLength,
                   D3DPOOL     Pool,
                   HRESULT     *phr)
                  :
        CBuffer(pDevice,
                cbLength,
                0,                      // dwFVF
                D3DFMT_UNKNOWN,
                D3DRTYPE_COMMANDBUFFER,
                D3DUSAGE_LOCK,          // Usage
                D3DUSAGE_LOCK,          // ActualUsage
                Pool,                   // Pool
                Pool,                   // ActualPool
                REF_INTERNAL,
                phr),
        m_cbLength(cbLength)
    {
        m_desc.Pool    = Pool;
        m_desc.Usage   = 0;
        m_desc.Format  = D3DFMT_UNKNOWN;
        m_desc.Type    = D3DRTYPE_COMMANDBUFFER;

    }; // CCommandBuffer::CCommandBuffer

    DWORD           m_cbLength;
    D3DBUFFER_DESC m_desc;
}; // class CCommandBuffer


#endif // __BUFFER_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\cubemap.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cubemap.cpp
 *  Content:    Implementation of the CCubeMap class.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "cubemap.hpp"
#include "cubesurf.hpp"
#include "d3di.hpp"
#include "resource.inl"

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::Create"

// Static class function for creating a cube-map object.
// (Because it is static; it doesn't have a this pointer.)
//
// We do all parameter checking here to reduce the overhead
// in the constructor which is called by the internal Clone
// method which is used by resource management as part of the
// performance critical download operation.


HRESULT CCubeMap::Create(CBaseDevice            *pDevice, 
                         DWORD                   cpEdge,
                         DWORD                   cLevels,
                         DWORD                   Usage,
                         D3DFORMAT               UserFormat,
                         D3DPOOL                 Pool,
                         IDirect3DCubeTexture8 **ppCubeMap)
{
    HRESULT hr;

    // Do parameter checking here
    if (!VALID_PTR_PTR(ppCubeMap))
    {
        DPF_ERR("Bad parameter passed for ppSurface for creating a cubemap");
        return D3DERR_INVALIDCALL;
    }

    // Zero-out return parameter
    *ppCubeMap = NULL;

    // Check if format is valid
    hr = Validate(pDevice, 
                  D3DRTYPE_CUBETEXTURE, 
                  Pool, 
                  Usage, 
                  UserFormat);
    if (FAILED(hr))
    {
        // VerifyFormat does it's own DPFing
        return D3DERR_INVALIDCALL;
    }

    // Infer internal usage flags
    Usage = InferUsageFlags(Pool, Usage, UserFormat);

    // Expand cLevels if necessary
    if (cLevels == 0)
    {
        // See if HW can mip
        if ( (Pool != D3DPOOL_SCRATCH) && (!(pDevice->GetD3DCaps()->TextureCaps &
                D3DPTEXTURECAPS_MIPCUBEMAP)))
        {
            // Can't mip so use 1
            cLevels = 1;
        }
        else
        {
            // Determine number of levels
            cLevels = ComputeLevels(cpEdge);
        }
    }

    // Start parameter checking

    if (cLevels > 32)
    {
        DPF_ERR("No more than 32 levels are supported for a cubemap texture");

        // This limitation is based on the number of
        // bits that we have allocated for iLevel in 
        // some of the supporting classes.
        return D3DERR_INVALIDCALL;
    }

    // Check if the device supports mipped cubemaps
    if (cLevels > 1)
    {
        if ((cpEdge >> (cLevels - 1)) == 0)
        {
            DPF_ERR("Too many levels for Cube Texture of this size.");
            return D3DERR_INVALIDCALL;
        }
    }

    D3DFORMAT RealFormat = UserFormat;

    if (Pool != D3DPOOL_SCRATCH)
    {
        // Check size constraints for cubemap
        if (pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_CUBEMAP_POW2)
        {
            if (!IsPowerOfTwo(cpEdge))
            {
                DPF_ERR("Device requires that edge must be power of two for cube-maps");
                return D3DERR_INVALIDCALL;
            }
        }

        // Check texture size restrictions
        if (cpEdge > pDevice->GetD3DCaps()->MaxTextureWidth)
        {
            DPF_ERR("Texture width is larger than what the device supports. Cube Texture creation fails.");
            return D3DERR_INVALIDCALL;
        }

        if (cpEdge > pDevice->GetD3DCaps()->MaxTextureHeight)
        {
            DPF_ERR("Texture height is larger than what the device supports. Cube Texture creation fails.");
            return D3DERR_INVALIDCALL;
        }

        // Check that the device supports cubemaps
        if (!(pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_CUBEMAP))
        {
            DPF_ERR("Device doesn't support Cube Texture; Cube Texture creation failed.");
            return D3DERR_INVALIDCALL;
        }

        // Check if the device supports mipped cubemaps
        if (cLevels > 1)
        {
            if (!(pDevice->GetD3DCaps()->TextureCaps &
                    D3DPTEXTURECAPS_MIPCUBEMAP))
            {
                DPF_ERR("Device doesn't support mipped cube textures; creation failed.");
                return D3DERR_INVALIDCALL;
            }
        }

        // Map Depth/Stencil formats; returns no change if no
        // mapping is needed
        RealFormat = pDevice->MapDepthStencilFormat(UserFormat);
    }

    // Size may need to be 4x4
    if (CPixel::Requires4X4(UserFormat))
    {
        if (cpEdge & 3)
        {
            DPF_ERR("DXT Formats require edge to be a multiples of 4. Cube Texture creation fails.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Validate against zero width/height
    if (cpEdge == 0)
    {
        DPF_ERR("Edge must be non-zero. Cube Texture creation fails."); 
        return D3DERR_INVALIDCALL;
    }

    // Allocate a new CubeMap object and return it
    CCubeMap *pCubeMap = new CCubeMap(pDevice, 
                                      cpEdge, 
                                      cLevels,
                                      Usage,
                                      UserFormat,
                                      RealFormat,
                                      Pool,
                                      REF_EXTERNAL,
                                     &hr);
    if (pCubeMap == NULL)
    {
        DPF_ERR("Out of Memory creating cubemap");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        DPF_ERR("Error during initialization of cubemap");
        pCubeMap->ReleaseImpl();
        return hr;
    }

    // We're done; just return the object
    *ppCubeMap = pCubeMap;

    return hr;
} // static Create


#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::CCubeMap"

// Constructor the cube map class
CCubeMap::CCubeMap(CBaseDevice *pDevice, 
                   DWORD        cpEdge,
                   DWORD        cLevels,
                   DWORD        Usage,
                   D3DFORMAT    UserFormat,
                   D3DFORMAT    RealFormat,    
                   D3DPOOL      UserPool,
                   REF_TYPE     refType,
                   HRESULT     *phr
                   ) :
    CBaseTexture(pDevice, cLevels, UserPool, UserFormat, refType),
    m_prgCubeSurfaces(NULL),
    m_rgbPixels(NULL),
    m_IsAnyFaceDirty(TRUE)
{
    // Sanity check
    DXGASSERT(phr);
    DXGASSERT(cLevels <= 32);

    // Initialize basic structures
    m_prgCubeSurfaces       = NULL;
    m_rgbPixels             = NULL;
    m_desc.Format           = RealFormat;
    m_desc.Pool             = UserPool;
    m_desc.Usage            = Usage;
    m_desc.Type             = D3DRTYPE_CUBETEXTURE;
    m_desc.MultiSampleType  = D3DMULTISAMPLE_NONE;
    m_desc.Width            = cpEdge;
    m_desc.Height           = cpEdge;

    // Initialize ourselves to all dirty
    for (DWORD iFace = 0; iFace < CUBEMAP_MAXFACES; iFace++)
    {
        m_IsFaceCleanArray   [iFace] = FALSE;
        m_IsFaceAllDirtyArray[iFace] = TRUE;
    }

    // We assume that we start out dirty
    DXGASSERT(IsDirty());

    // We always have 6 faces now
    DWORD cFaces = 6;

    // Allocate Pixel Data
    m_cbSingleFace = CPixel::ComputeMipMapSize(cpEdge, 
                                               cpEdge, 
                                               cLevels, 
                                               RealFormat);

    // Round up to nearest 32 for alignment
    m_cbSingleFace += 31;
    m_cbSingleFace &= ~(31);

    m_desc.Size = m_cbSingleFace * cFaces;

    // Allocate Pixel Data for SysMem or D3DManaged cases
    if (IS_D3D_ALLOCATED_POOL(UserPool) ||
        IsTypeD3DManaged(Device(), D3DRTYPE_CUBETEXTURE, UserPool))
    {
        m_rgbPixels   = new BYTE[m_desc.Size];

        if (m_rgbPixels == NULL)
        {
            *phr = E_OUTOFMEMORY;
            return;
        }
    }

    // Create the DDSURFACEINFO array and CreateSurfaceData object
    DXGASSERT(cLevels <= 32);

    DDSURFACEINFO SurfInfo[6 * 32];
    ZeroMemory(SurfInfo, sizeof(SurfInfo));

    D3D8_CREATESURFACEDATA CreateSurfaceData;
    ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

    // Set up the basic information
    CreateSurfaceData.hDD      = pDevice->GetHandle();
    CreateSurfaceData.pSList   = &SurfInfo[0];
    CreateSurfaceData.dwSCnt   = cLevels * cFaces;
    CreateSurfaceData.Type     = D3DRTYPE_CUBETEXTURE;
    CreateSurfaceData.dwUsage  = m_desc.Usage;
    CreateSurfaceData.Format   = RealFormat;
    CreateSurfaceData.MultiSampleType = D3DMULTISAMPLE_NONE;
    CreateSurfaceData.Pool     = DetermineCreationPool(Device(), 
                                                       D3DRTYPE_CUBETEXTURE, 
                                                       Usage, 
                                                       UserPool);

    // Iterate of each face/level to create the individual level
    // data
    for (iFace = 0; iFace < cFaces; iFace++)
    {
        // Start width and height at the full size
        cpEdge = m_desc.Width;
        DXGASSERT(m_desc.Width == m_desc.Height);

        for (DWORD iLevel = 0; iLevel < cLevels; iLevel++)
        {
            int index = (iFace * cLevels) + iLevel;

            // Fill in the relevant information
            DXGASSERT(cpEdge >= 1);
            SurfInfo[index].cpWidth  = cpEdge;
            SurfInfo[index].cpHeight = cpEdge;

            // If we allocated the memory, pass down
            // the sys-mem pointers
            if (m_rgbPixels)
            {
                D3DLOCKED_RECT lock;
                ComputeCubeMapOffset(iFace, 
                                     iLevel,
                                     NULL,       // pRect
                                     &lock);

                SurfInfo[index].pbPixels = (BYTE*)lock.pBits;
                SurfInfo[index].iPitch   = lock.Pitch;

            }

            // Scale width and height down for each level
            cpEdge >>= 1;
        }
    }

    // Allocate array of pointers to CubeSurfaces
    m_prgCubeSurfaces = new CCubeSurface*[cLevels*cFaces];
    if (m_prgCubeSurfaces == NULL)
    {
        *phr = E_OUTOFMEMORY;
        return;
    }

    // Zero the memory for safe cleanup
    ZeroMemory(m_prgCubeSurfaces, 
               sizeof(*m_prgCubeSurfaces) * cLevels * cFaces);

    if (UserPool != D3DPOOL_SCRATCH)
    {
        // Call the HAL to create this surface
        *phr = pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
        if (FAILED(*phr))
            return;

        // NOTE: any failures after this point needs to free up some
        // kernel handles

        // Remember what pool we really got
        m_desc.Pool = CreateSurfaceData.Pool;

        // We need to remember the handles from the top most
        // level of the mip-map
        SetKernelHandle(SurfInfo[0].hKernelHandle);
    }

    // Create and Initialize each CubeLevel
    for (iFace = 0; iFace < cFaces; iFace++)
    {
        for (DWORD iLevel = 0; iLevel < cLevels; iLevel++)
        {
            int index = (iFace * cLevels) + iLevel;

            DXGASSERT((BYTE)iFace == iFace);
            DXGASSERT((BYTE)iLevel == iLevel);

            // Create the appropriate cube-level depending on type

            // Is this a sys-mem surface; could be d3d managed
            if (IS_D3D_ALLOCATED_POOL(m_desc.Pool))
            {
                m_prgCubeSurfaces[index] = 
                            new CCubeSurface(this,
                                            (BYTE)iFace,
                                            (BYTE)iLevel,
                                            SurfInfo[index].hKernelHandle);
            }
            else
            {
                // This is driver kind of cube-map; could be driver managed
                m_prgCubeSurfaces[index] = 
                        new CDriverCubeSurface(this,
                                               (BYTE)iFace,
                                               (BYTE)iLevel,
                                               SurfInfo[index].hKernelHandle);
            }

            if (m_prgCubeSurfaces[index] == NULL)
            {
                DPF_ERR("Out of memory creating cube map level");
                *phr = E_OUTOFMEMORY;

                // Need to free handles that we got before we return; we
                // only free the ones that weren't successfully entrusted
                // to a CCubeSurf because those will be cleaned up automatically
                // at their destructor
                if (UserPool != D3DPOOL_SCRATCH)
                {
                    for (UINT i = index; i < ((cFaces * cLevels) - 1); i++)
                    {
                        DXGASSERT(SurfInfo[i].hKernelHandle);

                        D3D8_DESTROYSURFACEDATA DestroySurfData;
                        DestroySurfData.hDD = Device()->GetHandle();
                        DestroySurfData.hSurface = SurfInfo[i].hKernelHandle;
                        Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
                    }
                }

                return;
            }
        }
    }

    // If this is a D3D managed surface then we need 
    // to tell the Resource Manager to remember us. This has to happen
    // at the very end of the constructor so that the important data
    // members are built up correctly
    if (CResource::IsTypeD3DManaged(Device(), D3DRTYPE_CUBETEXTURE, UserPool))
    {
        *phr = InitializeRMHandle();
    }

} // CCubeMap::CCubeMap


#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::~CCubeMap"

// Destructor
CCubeMap::~CCubeMap()
{
    // The destructor has to handle partially
    // created objects. 

    if (m_prgCubeSurfaces)
    {
        // How many faces do we have?
        DWORD cFaces = 6;

        // Delete each CubeSurface individually
        for (DWORD iSurf = 0; iSurf < (cFaces * m_cLevels); iSurf++)
        {
            delete m_prgCubeSurfaces[iSurf];
        }
        delete [] m_prgCubeSurfaces;
    }
    delete [] m_rgbPixels;
} // CCubeMap::~CCubeMap

// Methods for the Resource Manager

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::Clone"

// Specifies a creation of a resource that
// looks just like the current one; in a new POOL
// with a new LOD.
HRESULT CCubeMap::Clone(D3DPOOL    Pool, 
                        CResource **ppResource) const

{
    // NULL out parameter
    *ppResource = NULL;

    // Determine the number of levels/width/height
    // of the clone
    DWORD cLevels  = GetLevelCountImpl();
    DWORD Edge = m_desc.Width;
    DXGASSERT(m_desc.Width == m_desc.Height);

    DWORD dwLOD = GetLODI();

    // If LOD is zero, then there are no changes
    if (dwLOD > 0)
    {
        // Clamp LOD to cLevels-1
        if (dwLOD >= cLevels)
        {
            dwLOD = cLevels - 1;
        }

        // scale down the destination texture
        // to correspond the appropiate max lod
        Edge >>= dwLOD;
        if (Edge == 0)
            Edge = 1;

        // Reduce the number based on the our max lod.
        cLevels -= dwLOD;
    }

    // Sanity checking
    DXGASSERT(cLevels  >= 1);
    DXGASSERT(Edge     >  0);

    // Create the new cube-map object now

    // Note: we treat clones as REF_INTERNAL; because
    // they are owned by the resource manager which 
    // is owned by the device. 

    // Also, we adjust the usage to disable lock-flags
    // since we don't need lockability
    DWORD Usage = m_desc.Usage;
    Usage &= ~(D3DUSAGE_LOCK | D3DUSAGE_LOADONCE);

    HRESULT hr;
    CResource *pResource = new CCubeMap(Device(),
                                        Edge,
                                        cLevels,
                                        Usage,
                                        m_desc.Format,  // UserFormat
                                        m_desc.Format,  // RealFormat
                                        Pool,
                                        REF_INTERNAL,
                                        &hr);

    if (pResource == NULL)
    {
        DPF_ERR("Failed to allocate cube-map object when copying");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        DPF(5, "Failed to create cube-map when doing texture management");
        pResource->DecrementUseCount();
        return hr;
    }

    *ppResource = pResource;

    return hr;
} // CCubeMap::Clone

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetBufferDesc"

// Provides a method to access basic structure of the
// pieces of the resource. A resource may be composed
// of one or more buffers.
const D3DBUFFER_DESC* CCubeMap::GetBufferDesc() const
{
    return (const D3DBUFFER_DESC*)&m_desc;
} // CCubeMap::GetBufferDesc


// IUnknown methods
#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::QueryInterface"

STDMETHODIMP CCubeMap::QueryInterface(REFIID riid, 
                                      LPVOID FAR * ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter to QueryInterface for Cubemap");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for Cubemap");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DCubeTexture8  || 
        riid == IID_IDirect3DBaseTexture8  ||
        riid == IID_IDirect3DResource8     ||
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DCubeTexture8*>(this));
            
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to QueryInterface for Cubemap");
    
    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::AddRef"

STDMETHODIMP_(ULONG) CCubeMap::AddRef()
{
    API_ENTER_NO_LOCK(Device());
    
    return AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::Release"

STDMETHODIMP_(ULONG) CCubeMap::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());    

    return ReleaseImpl();
} // Release

// IDirect3DResource methods

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetDevice"

STDMETHODIMP CCubeMap::GetDevice(IDirect3DDevice8 ** ppvObj)
{
    API_ENTER(Device());
    return GetDeviceImpl(ppvObj);
} // GetDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::SetPrivateData"

STDMETHODIMP CCubeMap::SetPrivateData(REFGUID   riid, 
                                      CONST VOID*    pvData, 
                                      DWORD     cbData, 
                                      DWORD     dwFlags)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // CubeMap, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)

    return SetPrivateDataImpl(riid, pvData, cbData, dwFlags, m_cLevels);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetPrivateData"

STDMETHODIMP CCubeMap::GetPrivateData(REFGUID   riid, 
                                      LPVOID    pvData, 
                                      LPDWORD   pcbData)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // CubeMap, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)
    return GetPrivateDataImpl(riid, pvData, pcbData, m_cLevels);
} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::FreePrivateData"

STDMETHODIMP CCubeMap::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // CubeMap, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)
    return FreePrivateDataImpl(riid, m_cLevels);
} // FreePrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetPriority"

STDMETHODIMP_(DWORD) CCubeMap::GetPriority()
{
    API_ENTER_RET(Device(), DWORD);

    return GetPriorityImpl();
} // GetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::SetPriority"

STDMETHODIMP_(DWORD) CCubeMap::SetPriority(DWORD dwPriority)
{
    API_ENTER_RET(Device(), DWORD);

    return SetPriorityImpl(dwPriority);
} // SetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::PreLoad"

STDMETHODIMP_(void) CCubeMap::PreLoad(void)
{
    API_ENTER_VOID(Device());

    PreLoadImpl();
    return;
} // PreLoad

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetType"
STDMETHODIMP_(D3DRESOURCETYPE) CCubeMap::GetType(void)
{
    API_ENTER_RET(Device(), D3DRESOURCETYPE);

    return m_desc.Type;
} // GetType


// IDirect3DMipTexture methods

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetLOD"

STDMETHODIMP_(DWORD) CCubeMap::GetLOD()
{
    API_ENTER_RET(Device(), DWORD);

    return GetLODImpl();
} // GetLOD

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::SetLOD"

STDMETHODIMP_(DWORD) CCubeMap::SetLOD(DWORD dwLOD)
{
    API_ENTER_RET(Device(), DWORD);

    return SetLODImpl(dwLOD);
} // SetLOD

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetLevelCount"

STDMETHODIMP_(DWORD) CCubeMap::GetLevelCount()
{
    API_ENTER_RET(Device(), DWORD);

    return GetLevelCountImpl();
} // GetLevelCount


// IDirect3DCubeMap methods

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetLevelDesc"

STDMETHODIMP CCubeMap::GetLevelDesc(UINT iLevel, D3DSURFACE_DESC *pDesc)
{
    API_ENTER(Device());

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed CCubeMap::GetLevelDesc");
        return D3DERR_INVALIDCALL;
    }

    D3DCUBEMAP_FACES FaceType = D3DCUBEMAP_FACE_POSITIVE_X;

    return GetSurface(FaceType, iLevel)->GetDesc(pDesc);

} // GetLevelDesc

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetCubeMapSurface"

STDMETHODIMP CCubeMap::GetCubeMapSurface(D3DCUBEMAP_FACES    FaceType, 
                                         UINT                iLevel,
                                         IDirect3DSurface8 **ppSurface)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppSurface))
    {
        DPF_ERR("Invalid ppSurface parameter passed to CCubeMap::GetCubeMapSurface");
        return D3DERR_INVALIDCALL;
    }

    // Null out parameter
    *ppSurface = NULL;

    // Continue parameter checking
    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed CCubeMap::OpenCubemapLevel");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_CUBEMAP_FACETYPE(FaceType))
    {
        DPF_ERR("Invalid face type passed CCubeMap::OpenCubemapLevel");
        return D3DERR_INVALIDCALL;
    }
        
    // Count bits in dwAllFaces less than dwFaceType's bit
    *ppSurface = GetSurface(FaceType, iLevel);
    (*ppSurface)->AddRef();
    return S_OK;
} // GetCubeMapSurface

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::LockRect"
STDMETHODIMP CCubeMap::LockRect(D3DCUBEMAP_FACES FaceType,
                                UINT             iLevel,
                                D3DLOCKED_RECT  *pLockedRectData, 
                                CONST RECT      *pRect, 
                                DWORD            dwFlags)
{
    API_ENTER(Device());

    if (pLockedRectData == NULL)
    {
        DPF_ERR("Invalid parameter passed to CCubeMap::LockRect");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_CUBEMAP_FACETYPE(FaceType))
    {
        DPF_ERR("Invalid face type passed CCubeMap::LockRect");
        return D3DERR_INVALIDCALL;
    }

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed CCubeMap::LockRect");
        return D3DERR_INVALIDCALL;
    }

    return GetSurface(FaceType, iLevel)->LockRect(pLockedRectData, pRect, dwFlags);
} // LockRect


#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::UnlockRect"

STDMETHODIMP CCubeMap::UnlockRect(D3DCUBEMAP_FACES FaceType, UINT iLevel)
{
    API_ENTER(Device());

    if (!VALID_CUBEMAP_FACETYPE(FaceType))
    {
        DPF_ERR("Invalid face type passed CCubeMap::UnlockRect");
        return D3DERR_INVALIDCALL;
    }
    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed CCubeMap::UnlockRect");
        return D3DERR_INVALIDCALL;
    }

    return GetSurface(FaceType, iLevel)->UnlockRect();

} // UnlockRect


#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::UpdateTexture"

// This function does type-specific parameter checking
// before calling UpdateDirtyPortion
HRESULT CCubeMap::UpdateTexture(CBaseTexture *pResourceTarget)
{
    CCubeMap *pTexSource = static_cast<CCubeMap*>(this);
    CCubeMap *pTexDest   = static_cast<CCubeMap*>(pResourceTarget);

    // Figure out how many levels in the source to skip
    DXGASSERT(pTexSource->m_cLevels >= pTexDest->m_cLevels);
    DWORD StartLevel = pTexSource->m_cLevels - pTexDest->m_cLevels;
    DXGASSERT(StartLevel < 32);

    // Compute the size of the top level of the source that is
    // going to be copied.
    UINT SrcWidth  = pTexSource->Desc()->Width;
    UINT SrcHeight = pTexSource->Desc()->Height;
    if (StartLevel > 0)
    {
        SrcWidth  >>= StartLevel;
        SrcHeight >>= StartLevel;
        if (SrcWidth == 0)
            SrcWidth = 1;
        if (SrcHeight == 0)
            SrcHeight = 1;
    }

    // Source and Dest should be the same sizes at this point
    if (SrcWidth != pTexDest->Desc()->Width)
    {
        if (StartLevel)
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since both have the same number of"
                    " levels; their widths must match. UpdateTexture"
                    " for CubeTexture fails");
        }
        else
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since they have the different numbers of"
                    " levels; the widths of the bottom-most levels of"
                    " the source must match all the corresponding levels"
                    " of the destination. UpdateTexture"
                    " for CubeTexture fails");
        }
        return D3DERR_INVALIDCALL;
    }

    if (SrcHeight != pTexDest->Desc()->Height)
    {
        if (StartLevel)
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since both have the same number of"
                    " levels; their heights must match. UpdateTexture"
                    " for CubeTexture fails");
        }
        else
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since they have the different numbers of"
                    " mip-levels; the heights of the bottom-most levels of"
                    " the source must match all the corresponding levels"
                    " of the destination. UpdateTexture"
                    " for CubeTexture fails");
        }
        return D3DERR_INVALIDCALL;
    }

    return UpdateDirtyPortion(pResourceTarget);
} // UpdateTexture


#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::UpdateDirtyPortion"

// Tells the resource that it should copy itself
// to the target. It is the caller's responsibility
// to make sure that Target is compatible with the
// Source. (The Target may have different number of mip-levels
// and be in a different pool; however, it must have the same size, 
// faces, format, etc.)
//
// This function will clear the dirty state.
HRESULT CCubeMap::UpdateDirtyPortion(CResource *pResourceTarget)
{
    // If we are clean, then do nothing
    if (!m_IsAnyFaceDirty)
    {
        if (IsDirty())
        {
            DPF_ERR("A Cube Texture has been locked with D3DLOCK_NO_DIRTY_UPDATE but "
                    "no call to AddDirtyRect was made before the texture was used. "
                    "Hardware texture was not updated.");
        }
        return S_OK;
    }

    // We are dirty; so we need to get some pointers
    CCubeMap *pTexSource = static_cast<CCubeMap*>(this);
    CCubeMap *pTexDest   = static_cast<CCubeMap*>(pResourceTarget);

    // Call TexBlt for each face
    HRESULT hr = S_OK;
    
    if (CanTexBlt(pTexDest))
    {
        CD3DBase *pDevice = static_cast<CD3DBase*>(Device());

        // Hack: go in reverse order for driver compat.
        for (INT iFace = CUBEMAP_MAXFACES-1; 
                 iFace >= 0; 
                 iFace--)
        {
            // Skip clean faces
            if (m_IsFaceCleanArray[iFace])
                continue;

            // Figure out the right handles to use for this operation
            D3DCUBEMAP_FACES Face = (D3DCUBEMAP_FACES) iFace;
            DWORD dwDest   = pTexDest->GetSurface(Face, 0 /* iLevel */)->DrawPrimHandle();                       
            DWORD dwSource = pTexSource->GetSurface(Face, 0 /* iLevel */)->DrawPrimHandle();
                      
            // Is this face all dirty?   
            if (m_IsFaceAllDirtyArray[iFace])
            {
                POINT p = {0 , 0};
                RECTL r = {0, 0, Desc()->Width, Desc()->Height};

                hr = pDevice->CubeTexBlt(pTexDest,
                                         pTexSource,
                                         dwDest, 
                                         dwSource, 
                                         &p, 
                                         &r);
            }
            else
            {
                // this face must be dirty
                DXGASSERT(!m_IsFaceCleanArray[iFace]);

                // Is this face partially dirty
                hr = pDevice->CubeTexBlt(pTexDest,
                                         pTexSource,
                                         dwDest, 
                                         dwSource, 
                                         (LPPOINT)&m_DirtyRectArray[iFace], 
                                         (LPRECTL)&m_DirtyRectArray[iFace]);
            }

            if (FAILED(hr))
            {
                DPF_ERR("Failed to update texture; not clearing dirty state for Cubemap");

                return hr;
            }
        }
    }
    else
    {
        // We can't use TexBlt, so we have to copy each level individually
        // through InternalCopyRects

        // Determine number of source levels to skip
        DXGASSERT(pTexSource->m_cLevels >= pTexDest->m_cLevels);
        DWORD StartLevel = pTexSource->m_cLevels - pTexDest->m_cLevels;
        DWORD LevelsToCopy = pTexSource->m_cLevels - StartLevel;
        DXGASSERT(StartLevel < this->m_cLevels);
        DXGASSERT(0 < pTexDest->m_cLevels);

        CBaseSurface *pSurfaceSrc;
        CBaseSurface *pSurfaceDest;

        // Iterate over each face
        for (DWORD iFace = 0; iFace < 6; iFace++)
        {
            if (m_IsFaceCleanArray[iFace])
                continue;

            if (m_IsFaceAllDirtyArray[iFace])
            {
                for (DWORD iLevel = 0; iLevel < LevelsToCopy; iLevel++)
                {
                    DWORD IndexSrc = iFace * this->m_cLevels + iLevel + StartLevel;
                    DXGASSERT(IndexSrc < (DWORD)(this->m_cLevels * 6));
                    pSurfaceSrc = this->m_prgCubeSurfaces[IndexSrc];

                    DWORD IndexDest = iFace * pTexDest->m_cLevels + iLevel;
                    DXGASSERT(IndexDest < (DWORD)(pTexDest->m_cLevels * 6));
                    pSurfaceDest = pTexDest->m_prgCubeSurfaces[IndexDest];

                    // Source and Dest should be the same
                    // or our caller made a mistake
                    DXGASSERT(pSurfaceSrc->InternalGetDesc().Width == 
                              pSurfaceDest->InternalGetDesc().Width);
                    DXGASSERT(pSurfaceSrc->InternalGetDesc().Height == 
                              pSurfaceDest->InternalGetDesc().Height);

                    // Copy the entire level
                    hr = Device()->InternalCopyRects(pSurfaceSrc, 
                                                     NULL, 
                                                     0, 
                                                     pSurfaceDest, 
                                                     NULL);
                    if (FAILED(hr))
                    {
                        DPF_ERR("Failed to update texture; not clearing dirty state for Cubemap");
                        return hr;
                    }
                }
            }
            else
            {
                if (StartLevel)
                {
                    ScaleRectDown(&m_DirtyRectArray[iFace], StartLevel);
                }

                // Use the rect for the top level; but just
                // copy the entirety of other levels
                DWORD iLevel = 0;

                DWORD IndexSrc = iFace * this->m_cLevels + iLevel + StartLevel;
                DXGASSERT(IndexSrc < (DWORD)(this->m_cLevels * 6));
                pSurfaceSrc = this->m_prgCubeSurfaces[IndexSrc];

                DWORD IndexDest = iFace * pTexDest->m_cLevels + iLevel;
                DXGASSERT(IndexDest < (DWORD)(pTexDest->m_cLevels * 6));
                pSurfaceDest = pTexDest->m_prgCubeSurfaces[IndexDest];


                DXGASSERT(pSurfaceSrc->InternalGetDesc().Width == 
                          pSurfaceDest->InternalGetDesc().Width);
                DXGASSERT(pSurfaceSrc->InternalGetDesc().Height == 
                          pSurfaceDest->InternalGetDesc().Height);

                // Passing pPoints as NULL means just do a non-translated
                // copy
                hr = Device()->InternalCopyRects(pSurfaceSrc, 
                                                 &m_DirtyRectArray[iFace], 
                                                 1, 
                                                 pSurfaceDest, 
                                                 NULL);       // pPoints

                if (FAILED(hr))
                {
                    DPF_ERR("Failed to update texture; not clearing dirty state for Cubemap");
                    return hr;
                }

                // Copy each of the levels
                for (iLevel = 1; iLevel < LevelsToCopy; iLevel++)
                {
                    // Get the next surfaces
                    DWORD IndexSrc = iFace * this->m_cLevels + iLevel + StartLevel;
                    DXGASSERT(IndexSrc < (DWORD)(this->m_cLevels * 6));
                    pSurfaceSrc = this->m_prgCubeSurfaces[IndexSrc];

                    DWORD IndexDest = iFace * pTexDest->m_cLevels + iLevel;
                    DXGASSERT(IndexDest < (DWORD)(pTexDest->m_cLevels * 6));
                    pSurfaceDest = pTexDest->m_prgCubeSurfaces[IndexDest];

                    // Check that sizes match
                    DXGASSERT(pSurfaceSrc->InternalGetDesc().Width == 
                              pSurfaceDest->InternalGetDesc().Width);
                    DXGASSERT(pSurfaceSrc->InternalGetDesc().Height == 
                              pSurfaceDest->InternalGetDesc().Height);

                    // Copy the entirety of non-top levels
                    hr = Device()->InternalCopyRects(pSurfaceSrc, 
                                                     NULL, 
                                                     0, 
                                                     pSurfaceDest, 
                                                     NULL);
                    if (FAILED(hr))
                    {
                        DPF_ERR("Failed to update texture; not clearing dirty state for Cubemap");
                        return hr;
                    }
                }
            }
        }
    }
    
    // Remember that we did the work
    m_IsAnyFaceDirty = FALSE;
    for (DWORD iFace = 0; iFace < CUBEMAP_MAXFACES; iFace++)
    {
        m_IsFaceCleanArray   [iFace] = TRUE;
        m_IsFaceAllDirtyArray[iFace] = FALSE;
    }

    // Notify Resource base class that we are now clean
    OnResourceClean();
    DXGASSERT(!IsDirty());

    return S_OK;
} // CCubeMap::UpdateDirtyPortion

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::MarkAllDirty"

// Allows the Resource Manager to mark the texture
// as needing to be completely updated on next
// call to UpdateDirtyPortion
void CCubeMap::MarkAllDirty()
{
    // Set palette to __INVALIDPALETTE so that UpdateTextures
    // calls the DDI SetPalette the next time.
    SetPalette(__INVALIDPALETTE);

    // Mark everything dirty
    m_IsAnyFaceDirty = TRUE;
    for (int iFace = 0; iFace < CUBEMAP_MAXFACES; iFace++)
    {
        m_IsFaceCleanArray   [iFace] = FALSE;
        m_IsFaceAllDirtyArray[iFace] = TRUE;
    }

    // Notify Resource base class that we are now dirty
    OnResourceDirty();

} // CCubeMap::MarkAllDirty


#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::AddDirtyRect"
STDMETHODIMP CCubeMap::AddDirtyRect(D3DCUBEMAP_FACES  FaceType, 
                                    CONST RECT       *pRect)
{
    API_ENTER(Device());

    if (pRect != NULL && !VALID_PTR(pRect, sizeof(RECT)))
    {
        DPF_ERR("Invalid Rect parameter to AddDirtyRect for Cubemap");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_CUBEMAP_FACETYPE(FaceType))
    {
        DPF_ERR("Invalid FaceType parameter to AddDirtyRect for Cubemap");
        return D3DERR_INVALIDCALL;
    }

    if (pRect)
    {
        if (!CPixel::IsValidRect(Desc()->Format,
                                 Desc()->Width, 
                                 Desc()->Height, 
                                 pRect))
        {
            DPF_ERR("AddDirtyRect for a Cube Texture failed");
            return D3DERR_INVALIDCALL;
        }
    }

    InternalAddDirtyRect((UINT)FaceType, pRect);
    return S_OK;
} // AddDirtyRect

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::InternalAddDirtyRect"
void CCubeMap::InternalAddDirtyRect(DWORD             iFace, 
                                    CONST RECT       *pRect)
{
    // If driver managed then batch token
    if (Desc()->Pool == D3DPOOL_MANAGED && !IsD3DManaged())
    {
        RECTL Rect;
        DXGASSERT((Device()->GetD3DCaps()->Caps2 & DDCAPS2_CANMANAGERESOURCE) != 0);
        if (pRect == NULL)
        {
            Rect.left = 0;
            Rect.top = 0;
            Rect.right = (LONG)Desc()->Width;
            Rect.bottom = (LONG)Desc()->Height;
        }
        else
        {
            Rect = *((CONST RECTL*)pRect);
        }
        static_cast<CD3DBase*>(Device())->AddCubeDirtyRect(this, 
                                                           GetSurface((D3DCUBEMAP_FACES)iFace, 0)->DrawPrimHandle(),
                                                           &Rect); // This will fail only due to catastrophic
                                                                   // error and we or the app can't do a
                                                                   // a whole lot about it, so return nothing
        return;
    }

    // Need to mark dirty bit in CResource so that the resource manager works correctly.
    OnResourceDirty();

    // If everything is being modified; then we're totally dirty
    if (pRect == NULL)
    {
        m_IsFaceAllDirtyArray[iFace] = TRUE;
        m_IsFaceCleanArray   [iFace] = FALSE;
        m_IsAnyFaceDirty             = TRUE;
        return;
    }

    // If we're all dirty, we can't get dirtier
    if (m_IsFaceAllDirtyArray[iFace])
    {
        return;
    }

    // If the rect is the entire surface then we're all dirty 
    DXGASSERT(pRect != NULL);
    if (pRect->left     == 0 &&
        pRect->top      == 0 &&
        pRect->right    == (LONG)Desc()->Width &&
        pRect->bottom   == (LONG)Desc()->Height)
    {
        m_IsFaceAllDirtyArray[iFace] = TRUE;
        m_IsFaceCleanArray   [iFace] = FALSE;
        m_IsAnyFaceDirty             = TRUE;
        return;
    }

    // If the face is currently clean; then just remember the
    // new rect
    if (m_IsFaceCleanArray[iFace])
    {
        m_DirtyRectArray  [iFace] = *pRect;
        m_IsFaceCleanArray[iFace] = FALSE;
        m_IsAnyFaceDirty          = TRUE;
        return;
    }

    // Union in this Rect

    // If we're unioning in rects, then we must
    // already be marked dirty but not all dirty
    DXGASSERT(!m_IsFaceAllDirtyArray[iFace]);
    DXGASSERT(m_IsAnyFaceDirty);

    if (m_DirtyRectArray[iFace].left   > pRect->left)
    {
        m_DirtyRectArray[iFace].left   = pRect->left;
    }
    if (m_DirtyRectArray[iFace].right  < pRect->right)
    {
        m_DirtyRectArray[iFace].right  = pRect->right;
    }
    if (m_DirtyRectArray[iFace].top    > pRect->top)
    {
        m_DirtyRectArray[iFace].top    = pRect->top;
    }
    if (m_DirtyRectArray[iFace].bottom < pRect->bottom)
    {
        m_DirtyRectArray[iFace].bottom = pRect->bottom;
    }

    return;
} // InternalAddDirtyRect

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::OnSurfaceLock"

// Methods for the CubeSurface to call
// Notification when a cube-surface is locked for writing
void CCubeMap::OnSurfaceLock(DWORD       iFace, 
                             DWORD       iLevel, 
                             CONST RECT *pRect, 
                             DWORD       dwFlags)
{
    // Need to Sync first
    Sync();

    // We only care about the top-most levels of the cube-map
    if (iLevel != 0)
    {
        return;
    }

    // We don't need to mark the surface dirty if this was a
    // read-only lock; (this can happen for RT+Tex where we
    // need to sync even for read-only locks).
    if (dwFlags & D3DLOCK_READONLY)
    {
        return;
    }

    // Notify the resource that we are dirty
    OnResourceDirty();

    // Don't do anything if we are already all dirty or
    // if the app has specified that we shouldn't keep
    // track of this rect
    if (!m_IsFaceAllDirtyArray[iFace] &&
        !(dwFlags & D3DLOCK_NO_DIRTY_UPDATE))
    {
        InternalAddDirtyRect(iFace, pRect);
    }
    // We're done now.
    return;

} // OnSurfaceLock

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::IsTextureLocked"

// Debug only parameter checking do determine if a piece
// of a mip-chain is locked
#ifdef DEBUG
BOOL CCubeMap::IsTextureLocked()
{
    for (DWORD iFace = 0; iFace < 6; iFace++)
    {
        for (UINT iLevel = 0; iLevel < m_cLevels; iLevel++)
        {
            D3DCUBEMAP_FACES Face = (D3DCUBEMAP_FACES) iFace;            
            if (GetSurface(Face, iLevel)->IsLocked())
                return TRUE;
        }
    }
    return FALSE;

} // IsTextureLocked
#endif // !DEBUG


// End of file : cubemap.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\cubemap.hpp ===
#ifndef __CUBEMAP_HPP__
#define __CUBEMAP_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cubesurface.h
 *  Content:    Class header for the cube-map class. This class acts a
 *              container for the (planar) Surfaces that are used as textures.
 *              The textures are organized into a set of 6 possible faces
 *              each of which is mip-mapped
 *
 *
 ***************************************************************************/

// Includes
#include "texture.hpp"
#include "pixel.hpp"

// Forward decls
class CCubeSurface;

//
// The cube-map class holds a collection of CCubeSurfaces. The CubeMap class
// implements the IDirect3DCubeTexture8 interface; each CubeSurface implements the
// IDirect3DSurface8 interface. To reduce overhead per level, we have
// put most of the "real" guts of each surface into the CubeMap container class;
// i.e. most of the methods of the CubeSurface really just end up calling
// something in the CubeMap object.
//
// The base class implementation assumes a sys-mem allocation.
//

class CCubeMap : public CBaseTexture, public IDirect3DCubeTexture8
{
public:
    static HRESULT Create(CBaseDevice            *pDevice,
                          DWORD                   cpEdge,
                          DWORD                   cLevels,
                          DWORD                   dwUsage,
                          D3DFORMAT               Format,
                          D3DPOOL                 Pool,
                          IDirect3DCubeTexture8 **ppCubeMap);

    // Destructor
    virtual ~CCubeMap();

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID       riid,
                               VOID FAR   **ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    // IDirect3DResource methods
    STDMETHOD(GetDevice)(IDirect3DDevice8 ** ppvObj);

    STDMETHOD(SetPrivateData)(REFGUID  riid,
                              CONST VOID    *pvData,
                              DWORD    cbData,
                              DWORD    dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID  riid,
                              VOID    *pvData,
                              DWORD   *pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD_(DWORD, GetPriority)();
    STDMETHOD_(DWORD, SetPriority)(DWORD dwPriority);
    STDMETHOD_(void, PreLoad)();
    STDMETHOD_(D3DRESOURCETYPE, GetType)();

    // IDirect3DMipTexture methods
    STDMETHOD_(DWORD, GetLOD)();
    STDMETHOD_(DWORD, SetLOD)(DWORD dwLOD);
    STDMETHOD_(DWORD, GetLevelCount)();

    // IDirect3DCubeMap methods
    STDMETHOD(GetLevelDesc)(UINT   iLevel, D3DSURFACE_DESC *pDesc);

    STDMETHOD(GetCubeMapSurface)(D3DCUBEMAP_FACES    FaceType,
                                 UINT                iLevel,
                                 IDirect3DSurface8 **ppCubeMapSurface);

    STDMETHOD(LockRect)(D3DCUBEMAP_FACES    FaceType,
                        UINT                iLevel,
                        D3DLOCKED_RECT     *pLockedRectData,
                        CONST RECT         *pRect,
                        DWORD               dwFlags);

    STDMETHOD(UnlockRect)(D3DCUBEMAP_FACES FaceType,
                          UINT             iLevel);

    STDMETHOD(AddDirtyRect)(D3DCUBEMAP_FACES  FaceType,
                            CONST RECT       *pRect);

    // Public helper stuff

    // Direct accessor for surface descriptor
    const D3DSURFACE_DESC *Desc() const
    {
        return &m_desc;
    } // AccessDesc;

    // Helper for Lock
    void ComputeCubeMapOffset(UINT              iFace,
                              UINT              iLevel,
                              CONST RECT       *pRect,
                              D3DLOCKED_RECT   *pLockedRectData)
    {
        BYTE *pbFace = m_rgbPixels + iFace * m_cbSingleFace;
        CPixel::ComputeMipMapOffset(Desc(),
                                    iLevel,
                                    pbFace,
                                    pRect,
                                    pLockedRectData);
    } // ComputeCubeMapOffset

    // Notification when a cube-surface is locked for writing
    void OnSurfaceLock(DWORD    iFace,
                       DWORD    iLevel,
                       CONST RECT    *pRect,
                       DWORD    dwFlags);

    // Methods for CResource

    // Specifies a creation of a resource that
    // looks just like the current one; in a new POOL
    // with a new LOD.
    virtual HRESULT Clone(D3DPOOL     Pool,
                          CResource **ppResource) const;

    // Provides a method to access basic structure of the
    // pieces of the resource. A resource may be composed
    // of one or more buffers.
    virtual const D3DBUFFER_DESC* GetBufferDesc() const;

    // Updates destination with source dirty rects
    virtual HRESULT UpdateDirtyPortion(CResource *pResourceTarget);

    // Allows the Resource Manager to mark the texture
    // as needing to be completely updated on next
    // call to UpdateDirtyPortion
    virtual void MarkAllDirty();

    // Methods for CBaseTexture

    // Method for UpdateTexture to call; does type-specific
    // parameter checking before calling UpdateDirtyPortion
    virtual HRESULT UpdateTexture(CBaseTexture *pTextureTarget);

    // Parameter validation method to make sure that no part of
    // the texture is locked.
#ifdef DEBUG
    virtual BOOL IsTextureLocked();
#endif  // DEBUG

private:
    // Constructor returns an error code
    // if the object could not be fully
    // constructed
    CCubeMap(CBaseDevice *pDevice,
             DWORD        cpEdge,
             DWORD        cLevels,
             DWORD        dwUsage,
             D3DFORMAT    UserFormat,
             D3DFORMAT    RealFormat,
             D3DPOOL      Pool,
             REF_TYPE     refType,
             HRESULT     *phr
             );

    // Internally keep track of current
    // set of dirty rects
    void InternalAddDirtyRect(DWORD iFace, CONST RECT *pRect);

    // Helpful accessor for getting to a particular
    // level of the cube-map
#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetSurface"

    CCubeSurface *GetSurface(D3DCUBEMAP_FACES FaceType, DWORD iLevel)
    {
        DXGASSERT(FaceType <= CUBEMAP_MAXFACES);
        DXGASSERT(iLevel < m_cLevels);
        DXGASSERT(m_prgCubeSurfaces);
        return m_prgCubeSurfaces[FaceType * m_cLevels + iLevel];
    } // GetSurface

    // Each cubemap has an array of CCubeSurfaces
    CCubeSurface   **m_prgCubeSurfaces;

    // Each cubemap has a memory block that holds
    // all the pixel data in a contiguous chunk
    BYTE            *m_rgbPixels;

    // Keep track of how much memory we needed
    // for an entire face (including alignment padding)
    DWORD            m_cbSingleFace;

    // Keep track of description
    D3DSURFACE_DESC  m_desc;

    // In DX7 we kept track of upto 6 RECTs per mip-chain.
    // These rects indicate which portion of the top-most level of
    // a mip-chain were modified. (We continue to ignore modifications
    // to lower levels of the mip-chain. This is by-design.)
    //
    // NOTE: However, for cube-maps, it isn't clear what the right
    // dirty rect system ought to be. So we keep track of one
    // rect per-face (which is a union of all the locks taken
    // on that face). If we have a real-world app using managed
    // cube-maps, we really should profile it and examine usage
    // patterns.

    enum
    {
        CUBEMAP_MAXFACES = 6,
    };

    RECT    m_DirtyRectArray[CUBEMAP_MAXFACES];

    // To ease processing, we also keep the following data
    BOOL    m_IsFaceCleanArray[CUBEMAP_MAXFACES];
    BOOL    m_IsFaceAllDirtyArray[CUBEMAP_MAXFACES];
    BOOL    m_IsAnyFaceDirty;

}; // class CCubeMap

#endif // __CUBEMAP_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\cubesurf.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cubesurf.cpp
 *  Content:    Implementation of the CCubeSurface class
 *
 *
 ***************************************************************************/

#include "ddrawpr.h"
#include "cubesurf.hpp"

// IUnknown methods

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::QueryInterface"

STDMETHODIMP CCubeSurface::QueryInterface(REFIID riid, 
                                          void **ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter for Surface of a Cube Texture");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for Surface of a Cube Texture");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DSurface8  || 
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DSurface8 *>(this));
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to QueryInterface for Surface of a Cubemap");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::AddRef"

STDMETHODIMP_(ULONG) CCubeSurface::AddRef()
{
    API_ENTER_NO_LOCK(Device());    
#ifdef DEBUG
    m_cRefDebug++;
#endif // DEBUG

    return m_pParent->AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::Release"

STDMETHODIMP_(ULONG) CCubeSurface::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());    
#ifdef DEBUG
    m_cRefDebug--;
    if (m_cRefDebug & 0x80000000)
    {
        DPF_ERR("A level of a cube-map has been released more often than it has been add-ref'ed! Danger!!");
    }
#endif // DEBUG

    return m_pParent->ReleaseImpl();
} // Release

// IBuffer methods
#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::SetPrivateData"

STDMETHODIMP CCubeSurface::SetPrivateData(REFGUID   riid, 
                                          CONST void     *pvData, 
                                          DWORD     cbData, 
                                          DWORD     dwFlags)
{
    API_ENTER(Device());

    return m_pParent->SetPrivateDataImpl(riid, 
                                         pvData, 
                                         cbData, 
                                         dwFlags, 
                                         CombinedFaceLevel());
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::GetPrivateData"

STDMETHODIMP CCubeSurface::GetPrivateData(REFGUID   riid, 
                                          void     *pvData, 
                                          DWORD    *pcbData)
{
    API_ENTER(Device());

    return m_pParent->GetPrivateDataImpl(riid,
                                         pvData,
                                         pcbData,
                                         CombinedFaceLevel());

} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::FreePrivateData"

STDMETHODIMP CCubeSurface::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    return m_pParent->FreePrivateDataImpl(riid,
                                          CombinedFaceLevel());
} // FreePrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::GetContainer"

STDMETHODIMP CCubeSurface::GetContainer(REFIID riid, 
                                        void **ppContainer)
{
    API_ENTER(Device());

    return m_pParent->QueryInterface(riid, ppContainer);
} // OpenContainer

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::GetDevice"

STDMETHODIMP CCubeSurface::GetDevice(IDirect3DDevice8 ** ppDevice)
{
    API_ENTER(Device());

    return m_pParent->GetDevice(ppDevice);
} // OpenDevice


// IDirect3DSurface methods

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::GetDesc"

STDMETHODIMP CCubeSurface::GetDesc(D3DSURFACE_DESC *pDesc)
{
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pDesc, sizeof(D3DSURFACE_DESC)))
    {
        DPF_ERR("bad pointer for pDesc passed to GetDesc for Surface of a Cubemap");
        return D3DERR_INVALIDCALL;
    }

    // The internal desc indicates the real
    // format and pool. We need to report
    // back the original data
    *pDesc = InternalGetDesc();

    pDesc->Pool   = m_pParent->GetUserPool();
    pDesc->Format = m_pParent->GetUserFormat();
    pDesc->Usage &= D3DUSAGE_EXTERNAL;

    // We're done
    return S_OK;

} // GetDesc

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::InternalGetDesc"

D3DSURFACE_DESC CCubeSurface::InternalGetDesc() const
{
    D3DSURFACE_DESC desc;

    // Start from the parent's desc
    desc = *m_pParent->Desc();

    // Width and height are the shifted from the parent 
    desc.Width  >>= m_iLevel;
    desc.Height >>= m_iLevel;

    if (desc.Width == 0)
    {
        desc.Width = 1;
    }

    if (desc.Height == 0)
    {
        desc.Height = 1;
    }

    // Modify the type
    desc.Type    = D3DRTYPE_SURFACE;

    // Modify the size field
    desc.Size = CPixel::ComputeSurfaceSize(desc.Width, 
                                           desc.Height, 
                                           desc.Format);

    // We're done
    return desc;
} // InternalGetDesc


#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::LockRect"

STDMETHODIMP CCubeSurface::LockRect(D3DLOCKED_RECT *pLockedRectData, 
                                    CONST RECT     *pRect, 
                                    DWORD           dwFlags)
{   
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedRectData, sizeof(D3DLOCKED_RECT)))
    {
        DPF_ERR("bad pointer for pLockedRectData passed to LockRect for Surface of a Cubemap");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data
    ZeroMemory(pLockedRectData, sizeof(D3DLOCKED_RECT));

    // Validate Rect
    if (pRect != NULL)
    {
        DWORD Width  = m_pParent->Desc()->Width  >> m_iLevel;
        DWORD Height = m_pParent->Desc()->Height >> m_iLevel;

        if (!CPixel::IsValidRect(m_pParent->Desc()->Format,
                                 Width, 
                                 Height, 
                                 pRect))
        {
            DPF_ERR("LockRect for a level of a Cube Texture failed");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_SURF_VALID)
    {
        if (dwFlags & D3DLOCK_DISCARD)
        {
            if (dwFlags & D3DLOCK_READONLY)
            {
                DPF_ERR("D3DLOCK_READONLY is not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
            if (!(m_pParent->Desc()->Usage & D3DUSAGE_DYNAMIC))
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only with dynamic textures");
                return D3DERR_INVALIDCALL;
            }
            if (CombinedFaceLevel() > 0)
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only on D3DCUBEMAP_FACE_POSITIVE_X"
                        " and the top mip level. DISCARD in this case will discard"
                        " the entire cubemap.");
                return D3DERR_INVALIDCALL;
            }
            if (pRect != NULL)
            {
                DPF_ERR("Subrects not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            DPF_ERR("Invalid dwFlags parameter passed to LockRect for Surface of a Cubemap");
            DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_SURF_VALID);
            return D3DERR_INVALIDCALL;
        }
    }

    if (!m_isLockable)
    {
        m_pParent->ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }

    return InternalLockRect(pLockedRectData, pRect, dwFlags);
} // LockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::InternalLockRect"

HRESULT CCubeSurface::InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                       CONST RECT     *pRect, 
                                       DWORD           dwFlags)
{   

    // Only one lock outstanding at a time is supported
    if (m_isLocked)
    {
        DPF_ERR("LockRect failed on a cube map level; surface was already locked.");
        return D3DERR_INVALIDCALL;
    }

    // Notify the parent/device if we are about to be modified
    if ( (m_pParent->GetUserPool() != D3DPOOL_SCRATCH) && (!(dwFlags & D3DLOCK_READONLY)) )
    {
        m_pParent->OnSurfaceLock(m_iFace, m_iLevel, pRect, dwFlags);
    }

    // Fill out the locked rect structure
    m_pParent->ComputeCubeMapOffset(m_iFace,
                                    m_iLevel,
                                    pRect,
                                    pLockedRectData);


    DXGASSERT(pLockedRectData->pBits != NULL);
    
    // Mark ourselves as locked
    m_isLocked = 1;

    // Done
    return S_OK;
} // InternalLockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::UnlockRect"

STDMETHODIMP CCubeSurface::UnlockRect()
{
    API_ENTER(Device());

    // If we aren't locked; then something is wrong
    if (m_isLocked == 0)
    {
        DPF_ERR("UnlockRect failed on a cube map level; surface wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
    DXGASSERT(m_isLockable);

    return InternalUnlockRect();
} // UnlockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::InternalUnlockRect"

HRESULT CCubeSurface::InternalUnlockRect()
{
    // Clear our locked state
    m_isLocked = 0;

    // If we are lock-once; then we mark ourselves as not lockable
    if (m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE)
    {
        m_isLockable = FALSE;
    }

    // Done
    return S_OK;
} // InternalUnlockRect


//
// CDriverCubeSurface class modifies the implementation
// of the LockRect and UnlockRect methods of the CCubeSurface class
//

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverCubeSurface::LockRect"

STDMETHODIMP CDriverCubeSurface::LockRect(D3DLOCKED_RECT *pLockedRectData, 
                                          CONST RECT     *pRect, 
                                          DWORD           dwFlags)
{   
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedRectData, sizeof(D3DLOCKED_RECT)))
    {
        DPF_ERR("bad pointer for m_pLockedRectData passed to LockRect for Surface of a driver-allocated Cubemap");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data
    ZeroMemory(pLockedRectData, sizeof(D3DLOCKED_RECT));

    // Validate Rect
    if (pRect != NULL)
    {
        DWORD Width  = m_pParent->Desc()->Width  >> m_iLevel;
        DWORD Height = m_pParent->Desc()->Height >> m_iLevel;

        if (!CPixel::IsValidRect(m_pParent->Desc()->Format,
                                 Width, 
                                 Height, 
                                 pRect))
        {
            DPF_ERR("LockRect for a level of a Cube Texture failed");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_SURF_VALID)
    {
        if (dwFlags & D3DLOCK_DISCARD)
        {
            if (dwFlags & D3DLOCK_READONLY)
            {
                DPF_ERR("D3DLOCK_READONLY is not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
            if (!(m_pParent->Desc()->Usage & D3DUSAGE_DYNAMIC))
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only with dynamic textures");
                return D3DERR_INVALIDCALL;
            }
            if (CombinedFaceLevel() > 0)
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only on D3DCUBEMAP_FACE_POSITIVE_X"
                        " and the top mip level. DISCARD in this case will discard"
                        " the entire cubemap.");
                return D3DERR_INVALIDCALL;
            }
            if (pRect != NULL)
            {
                DPF_ERR("Subrects not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            DPF_ERR("Invalid dwFlags parameter passed to LockRect for a Surface of a driver allocated Cubemap");
            DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_SURF_VALID);
            return D3DERR_INVALIDCALL;
        }
    }

    if (!m_isLockable)
    {
        m_pParent->ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }

    return InternalLockRect(pLockedRectData, pRect, dwFlags);
} // CDriverCubeSurface::LockRect


#undef DPF_MODNAME
#define DPF_MODNAME "CDriverCubeSurface::InternalLockRect"

HRESULT CDriverCubeSurface::InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                             CONST RECT     *pRect, 
                                             DWORD           dwFlags)
{   
    // Only one lock outstanding at a time is supported
    if (m_isLocked)
    {
        DPF_ERR("LockRect failed on a Cube level; surface was already locked.");
        return D3DERR_INVALIDCALL;
    }

    // Notify the parent/device if we are about to be accessed.
    // Driver textures may be written to by HW through 
    // SRT/DrawPrim as well as UpdateTexture. So we may need to sync 
    // with the current command batch.
    m_pParent->OnSurfaceLock(m_iFace, m_iLevel, pRect, dwFlags);

    // Prepare a LockData structure for the HAL call
    D3D8_LOCKDATA lockData;
    ZeroMemory(&lockData, sizeof lockData);

    lockData.hDD        = m_pParent->Device()->GetHandle();
    lockData.hSurface   = m_hKernelHandle;
    lockData.dwFlags    = dwFlags;
    if (pRect != NULL)
    {
        lockData.bHasRect = TRUE;
        lockData.rArea = *((RECTL *) pRect);
    }
    
    HRESULT hr = m_pParent->Device()->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to lock driver cube-map surface");
        return hr;
    }

    // Fill in the Locked_Rect fields 
    D3DFORMAT Format = m_pParent->Desc()->Format;
    if (CPixel::IsDXT(Format))
    {
        // Pitch is the number of bytes for
        // one row's worth of blocks for linear formats

        // Start with our width
        UINT Width = m_pParent->Desc()->Width >> m_iLevel;

        // Convert to blocks
        Width = Width / 4;

        // At least one block
        if (Width == 0)
            Width = 1;

        if (Format == D3DFMT_DXT1)
        {
            // 8 bytes per block for DXT1
            pLockedRectData->Pitch = Width * 8;
        }
        else
        {
            // 16 bytes per block for DXT2-5
            pLockedRectData->Pitch = Width * 16;
        }
    }
    else
    {
        pLockedRectData->Pitch = lockData.lPitch;
    }

    pLockedRectData->pBits  = lockData.lpSurfData;

#ifdef DEBUG
    if ((dwFlags & D3DLOCK_DISCARD))
    {
        DXGASSERT(m_iLevel == 0 && m_iFace == 0);
        if (!CPixel::IsFourCC(Format) &&
            !CPixel::IsIHVFormat(Format))
        {
            DXGASSERT(pRect == NULL);
            memset(pLockedRectData->pBits, 0xDD, pLockedRectData->Pitch * m_pParent->Desc()->Height);
            for (UINT j = 0; j < 6; ++j)
            {
                for (UINT i = 0; i < m_pParent->GetLevelCount(); ++i)
                {
                    if (i != 0 || j != 0)
                    {
                        DXGASSERT(i != 0 || j != 0);
                        D3DLOCKED_RECT Rect;
                        HRESULT hr = m_pParent->LockRect((D3DCUBEMAP_FACES)j, i, &Rect, NULL, 0);
                        if (FAILED(hr))
                        {
                            DPF(1, "Lock to cube mipsublevel failed. Not good.");
                            break;
                        }
                        D3DSURFACE_DESC LevelDesc;
                        m_pParent->GetLevelDesc(i, &LevelDesc);
                        memset(Rect.pBits, 0xDD, Rect.Pitch * LevelDesc.Height);
                        m_pParent->UnlockRect((D3DCUBEMAP_FACES)j, i);
                    }
                }
            }
        }
    }
#endif // DEBUG

    // Mark ourselves as locked
    m_isLocked = 1;

    // Done
    return S_OK;
} // CDriverCubeSurface::InternalLockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverCubeSurface::UnlockRect"

STDMETHODIMP CDriverCubeSurface::UnlockRect()
{
    API_ENTER(Device());

    // If we aren't locked; then something is wrong
    if (m_isLocked == 0)
    {
        DPF_ERR("UnlockRect failed on a driver-allocated Cube level; surface wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
    DXGASSERT(m_isLockable);
    return InternalUnlockRect();
} // CDriverCubeSurface::UnlockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverCubeSurface::UnlockRect"

HRESULT CDriverCubeSurface::InternalUnlockRect()
{

    // Call the driver to perform the unlock
    D3D8_UNLOCKDATA unlockData = {
        m_pParent->Device()->GetHandle(),
        m_hKernelHandle
    };

    HRESULT hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
    if (FAILED(hr))
    {
        DPF_ERR("Driver cube-map surface failed to unlock");
        return hr;
    }

    // Clear our locked state
    m_isLocked = 0;

    // If we are lock-once; then we mark ourselves as not lockable
    if (m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE)
    {
        m_isLockable = FALSE;
    }

    // Done
    return S_OK;
} // CDriverCubeSurface::InternalUnlockRect


// End of file : cubesurf.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\dbgtopic.h ===
//emp-u-ty
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DDrawDebug"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\cubesurf.hpp ===
#ifndef __CUBESURF_HPP__
#define __CUBESURF_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cubesurf.hpp
 *  Content:    Class header the cubesurface class. This class acts
 *              as a level for the CubeMap class. The base class
 *              assumes a system-memory allocation; while the
 *              Driver sub-class will call the driver for every
 *              lock and unlock operation.
 *
 *
 ***************************************************************************/

// Includes
#include "cubemap.hpp"
//
// The CCubeSurface class is a special class that
// works solely with the CCubeMap class. Each CubeSurface
// corresponds to a single level and face of the cube-map. They are
// not stand-alone COM objects because they share the
// same life-time as their CCubeMap parent.
//
// The CDriverCubeSurface class handles
// the driver-managed and vid-mem versions of this
// class. 
//

class CCubeSurface : public CBaseSurface
{
public:

    // Constructor
    CCubeSurface(CCubeMap *pParent, 
                 BYTE      iFace, 
                 BYTE      iLevel,
                 HANDLE    hKernelHandle)
                 :
        m_pParent(pParent),
        m_iFace(iFace),
        m_iLevel(iLevel),
        m_hKernelHandle(hKernelHandle)
    {
        DXGASSERT(hKernelHandle || (pParent->GetUserPool() == D3DPOOL_SCRATCH) );
        DXGASSERT(m_pParent);
    #ifdef DEBUG
        m_cRefDebug = 0; 
    #endif // DEBUG

        if (m_pParent->Desc()->Usage & 
                (D3DUSAGE_LOCK | D3DUSAGE_LOADONCE))
        {
            m_isLockable = TRUE;
        }
        else
        {   
            m_isLockable = FALSE;
        }

    } // CCubeSurface

    ~CCubeSurface()
    {
        DXGASSERT(m_pParent);
        DXGASSERT(m_cRefDebug == 0); 
        if (m_hKernelHandle)
        {
            // Tell the thunk layer that we need to
            // be freed.
            D3D8_DESTROYSURFACEDATA DestroySurfData;
            DestroySurfData.hDD = m_pParent->Device()->GetHandle();
            DestroySurfData.hSurface = m_hKernelHandle;
            m_pParent->Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
        }
#ifdef DEBUG
        else
        {
            DXGASSERT(m_pParent->GetUserPool() == D3DPOOL_SCRATCH);
        }
#endif //DEBUG
    }; // ~CCubeSurface

public:
    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, 
                               LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    // IBuffer methods
    STDMETHOD(SetPrivateData)(REFGUID riid, 
                              CONST VOID* pvData, 
                              DWORD cbData, 
                              DWORD dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID riid, 
                              LPVOID pvData, 
                              LPDWORD pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD(GetContainer)(REFIID riid, 
                            void **ppContainer);

    STDMETHOD(GetDevice)(IDirect3DDevice8 ** ppvObj);

    // IDirect3DSurface8 methods
    STDMETHOD(GetDesc)(D3DSURFACE_DESC *pDesc);

    STDMETHOD(LockRect)(D3DLOCKED_RECT *pLockedRectData, 
                        CONST RECT     *pRect, 
                        DWORD           dwFlags);

    STDMETHOD(UnlockRect)();

    // BaseSurface methods
    virtual DWORD DrawPrimHandle() const
    {
        return D3D8GetDrawPrimHandle(m_hKernelHandle);
    } // GetDrawPrimHandle

    virtual HANDLE KernelHandle() const
    {
        return m_hKernelHandle;
    } // GetKernelHandle
    virtual DWORD IncrementUseCount()
    {
        return m_pParent->IncrementUseCount();
    } // IncrementUseCount

    virtual DWORD DecrementUseCount()
    {
        return m_pParent->DecrementUseCount();
    } // DecrementUseCount

    virtual void Batch()
    {
        m_pParent->Batch();
        return;
    } // Batch

    virtual void Sync()
    {
        m_pParent->Sync();
        return;
    } // Sync

    // Internal lock functions bypass
    // parameter checking and also whether the
    // surface marked as Lockable or LockOnce
    // etc. (Methods of CBaseSurface.)
    virtual HRESULT InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                     CONST RECT     *pRect, 
                                     DWORD           dwFlags);

    virtual HRESULT InternalUnlockRect();

    virtual D3DSURFACE_DESC InternalGetDesc() const;

    // Access the device of the surface
    virtual CBaseDevice *InternalGetDevice() const
    {
        return m_pParent->Device();
    } // InternalGetDevice

    // Determines if a LOAD_ONCE surface has already
    // been loaded
    virtual BOOL IsLoaded() const
    {
        DXGASSERT(m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE);
        if (m_isLockable)
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    } // IsLoaded

    // End Of BaseSurface methods

    // Quick accessor for the device
    // Access the device of the surface
    CBaseDevice *Device() const
    {
        return m_pParent->Device();
    } // Device

protected:
    CCubeMap *m_pParent;
    BOOL      m_isLockable;
    BYTE      m_iLevel;
    BYTE      m_iFace;

    // Helper function so that we can put all
    // the private data into the same list. This
    // returns a value that can be used to tag
    // each of the private datas that are held
    // by the master cubemap. Also, the value
    // of (m_cLevel) is used as the tag for
    // the CubeMap's private data itself
    BYTE CombinedFaceLevel()
    {
        DXGASSERT(m_iLevel < (1<<5));
        DXGASSERT(m_iFace < (1<<3));
        return (m_iFace << 5) + m_iLevel;
    } // CombinedFaceLevel

    // We'll need a kernel handle so that
    // we can communicate to the kernel for
    // the Destroy call
    HANDLE   m_hKernelHandle;

    // Debugging trick to help spew better
    // information if someone over-releases a cubesurface
    // (Since our ref's carry over to the parent object; it
    // means that over-releases can be hard to find.)
#ifdef DEBUG
    DWORD   m_cRefDebug;
#endif // DEBUG

}; // CCubeSurface

// The CDriverCubeSurface is a modification of the base Cube-map
// class. It keeps track some additional information and overrides
// some of the methods. It implements Lock/Unlock by calling the
// driver; hence it is used for both driver-managed and vid-mem
// surface

class CDriverCubeSurface : public CCubeSurface
{
public:
    // Constructor
    CDriverCubeSurface(CCubeMap *pParent, 
                      BYTE       iFace,
                      BYTE       iLevel,
                      HANDLE     hKernelHandle)
                      :
        CCubeSurface(pParent, iFace, iLevel, hKernelHandle)
    {
    } // Init

    STDMETHOD(LockRect)(D3DLOCKED_RECT *pLockedRectData, 
                        CONST RECT     *pRect, 
                        DWORD            dwFlags);

    STDMETHOD(UnlockRect)(THIS);

    // Internal lock functions bypass
    // parameter checking and also whether the
    // surface marked as Lockable or LockOnce
    // etc. (Methods of CBaseSurface.)
    virtual HRESULT InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                     CONST RECT     *pRect, 
                                     DWORD           dwFlags);

    virtual HRESULT InternalUnlockRect();

}; // CDriverCubeSurface

#endif // __CUBESURF_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\d3dobj.hpp ===
#ifndef __D3DOBJ_HPP__
#define __D3DOBJ_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dobj.hpp
 *  Content:    Base class header for resources and buffers
 *
 *
 ***************************************************************************/

// Helper function for parameter checking
inline BOOL IsPowerOfTwo(DWORD dwNumber)
{
    if (dwNumber == 0 || (dwNumber & (dwNumber-1)) != 0)
        return FALSE;
    else
        return TRUE;
} // IsPowerOfTwo

// forward decls
class CBaseObject;

// Entry-points that are inside/part of a device/enum may need to
// take a critical section. They do this by putting this
// line of code at the beginning of the API. 
//
// Use API_ENTER for APIs that return an HRESULT; 
// Use API_ENTER_RET for APIs that return a struct (as an out param)
// Use API_ENTER_VOID for APIs that return void.
// Use API_ENTER_SUBOBJECT_RELEASE for Release methods on sub-objects. 
// Use API_ENTER_NOLOCK for Release methods on the Device or Enum itself. 
// Use API_ENTER_NOLOCK for AddRef on anything.
//          
//
// (Release is special because the action of release may cause the 
// destruction of the device/enum; which would free the critical section
// before we got a chance to call Unlock on that critical section.)
//
// The class CLockOwner is a common base class for both CBaseDevice
// and CEnum.

#ifdef DEBUG

    #define API_ENTER(pLockOwner)                                           \
            if (IsBadWritePtr((void *)this, sizeof(*this))             ||   \
                IsBadWritePtr((void *)pLockOwner, sizeof(*pLockOwner)) ||   \
                !pLockOwner->IsValid())                                     \
            {                                                               \
                DPF_ERR("Invalid 'this' parameter to D3D8 API.");           \
                return D3DERR_INVALIDCALL;                                  \
            }                                                               \
            CLockD3D _lock(pLockOwner, DPF_MODNAME, __FILE__)

    // Use this for API's that return something other than an HRESULT
    #define API_ENTER_RET(pLockOwner, RetType)                              \
            if (IsBadWritePtr((void *)this, sizeof(*this))             ||   \
                IsBadWritePtr((void *)pLockOwner, sizeof(*pLockOwner)) ||   \
                !pLockOwner->IsValid())                                     \
            {                                                               \
                DPF_ERR("Invalid 'this' parameter to D3D8 API..");          \
                /* We only allow DWORD types of returns for compat */       \
                /* with C users.                                   */       \
                return (RetType)0;                                          \
            }                                                               \
            CLockD3D _lock(pLockOwner, DPF_MODNAME, __FILE__)

    // Use this for API's that return void
    #define API_ENTER_VOID(pLockOwner)                                      \
            if (IsBadWritePtr((void *)this, sizeof(*this))             ||   \
                IsBadWritePtr((void *)pLockOwner, sizeof(*pLockOwner)) ||   \
                !pLockOwner->IsValid())                                     \
            {                                                               \
                DPF_ERR("Invalid 'this' parameter to D3D8 API...");         \
                return;                                                     \
            }                                                               \
            CLockD3D _lock(pLockOwner, DPF_MODNAME, __FILE__)

    // Use this for Release API's of subobjects i.e. not Device or Enum
    #define API_ENTER_SUBOBJECT_RELEASE(pLockOwner)                         \
            if (IsBadWritePtr((void *)this, sizeof(*this))             ||   \
                IsBadWritePtr((void *)pLockOwner, sizeof(*pLockOwner)) ||   \
                !pLockOwner->IsValid())                                     \
            {                                                               \
                DPF_ERR("Invalid 'this' parameter to D3D8 API....");        \
                return 0;                                                   \
            }                                                               \
            CLockD3D _lock(pLockOwner, DPF_MODNAME, __FILE__, TRUE)

    // Use this for API tracing for methods
    // that don't need a crit-sec lock at-all in Retail.
    #define API_ENTER_NO_LOCK_HR(pLockOwner)                                \
            if (IsBadWritePtr((void *)this, sizeof(*this))             ||   \
                IsBadWritePtr((void *)pLockOwner, sizeof(*pLockOwner)) ||   \
                !pLockOwner->IsValid())                                     \
            {                                                               \
                DPF_ERR("Invalid 'this' parameter to D3D8 API.....");       \
                return D3DERR_INVALIDCALL;                                  \
            }                                                               \
            CNoLockD3D _noLock(DPF_MODNAME, __FILE__)

    // Use this for API tracing for Release for the device or enum 
    // (which is special; see note above). Also for AddRef for anything 
    #define API_ENTER_NO_LOCK(pLockOwner)                                   \
            if (IsBadWritePtr((void *)this, sizeof(*this))             ||   \
                IsBadWritePtr((void *)pLockOwner, sizeof(*pLockOwner)) ||   \
                !pLockOwner->IsValid())                                     \
            {                                                               \
                DPF_ERR("Invalid 'this' parameter to D3D8 API......");      \
                return 0;                                                   \
            }                                                               \
            CNoLockD3D _noLock(DPF_MODNAME, __FILE__)



#else  // !DEBUG

    #define API_ENTER(pLockOwner)                          \
            CLockD3D _lock(pLockOwner)

    #define API_ENTER_RET(pLockOwner, RetType)             \
            CLockD3D _lock(pLockOwner)

    #define API_ENTER_VOID(pLockOwner)                     \
            CLockD3D _lock(pLockOwner)

    #define API_ENTER_SUBOBJECT_RELEASE(pLockOwner)        \
            CLockD3D _lock(pLockOwner, TRUE)

    #define API_ENTER_NO_LOCK(pLockOwner)

    #define API_ENTER_NO_LOCK_HR(pLockOwner)

#endif // !DEBUG

// This is a locking object that is supposed to work with
// the device/enum to determine whether and which critical section needs to
// be taken. The use of a destructor means that "Unlock" will happen
// automatically as part of the destructor

class CLockD3D
{
public:

#ifdef DEBUG
    CLockD3D(CLockOwner *pLockOwner, char *moduleName, char *fileName, BOOL bSubObjectRelease = FALSE)
#else // !DEBUG
    CLockD3D(CLockOwner *pLockOwner, BOOL bSubObjectRelease = FALSE)
#endif // !DEBUG
    {
        // Remember the device
        m_pLockOwner = pLockOwner;

        // Add-ref the LockOwner if there is a risk that
        // that we might cause the LockOwner to go away in processing 
        // the current function i.e. SubObject Release
        if (bSubObjectRelease)
        {
            m_pLockOwner->AddRefOwner(); 
            
            // Remember to unlock it
            m_bNeedToReleaseLockOwner = TRUE;
        }
        else
        {
            // No need to AddRef/Release the device
            m_bNeedToReleaseLockOwner = FALSE;
        }

        // Ask the LockOwner to take a lock for us
        m_pLockOwner->Lock();

#ifdef DEBUG
        m_Count++;
        DPF(6, "*** LOCK_D3D: CNT = %ld %s %s", m_Count, moduleName, fileName);
#endif
    } // CD3DLock

    ~CLockD3D()
    {
#ifdef DEBUG
        DPF(6, "*** UNLOCK_D3D: CNT = %ld", m_Count);
        m_Count--;
#endif // DEBUG

        m_pLockOwner->Unlock();

        // Call Release if we need to
        if (m_bNeedToReleaseLockOwner)
            m_pLockOwner->ReleaseOwner();
    } // ~CD3DLock

private:

#ifdef DEBUG
    static DWORD    m_Count;
#endif // DEBUG

    CLockOwner     *m_pLockOwner;
    BOOL            m_bNeedToReleaseLockOwner;
}; // class CLockD3D

#ifdef DEBUG
// Helper debug-only class for API tracing
class CNoLockD3D
{
public:
    CNoLockD3D(char *moduleName, char *fileName)
    {
        DPF(6, "*** LOCK_D3D: Module= %s %s", moduleName, fileName);
    } // CD3DLock

    ~CNoLockD3D()
    {
        DPF(6, "*** UNLOCK_D3D:");
    } // ~CD3DLock
}; // CNoLockD3D
#endif // DEBUG

//
// This header file contains the base class for all resources and buffers      x
// types of objects
//
// The CBaseObject class contains functionality for the following
// services which can be used by the derived classes:
//          AddRefImpl/ReleaseImpl
//          Get/SetPrivateDataImpl data
//          OpenDeviceImpl
//
// Base objects should allocated with "new" which is means that they
// should be 32-byte aligned by our default allocator.
//
// Resources inherit from CBaseObject and add functionality for
// priority
//

// Add-ref semantics for these objects is complex; a constructor
// flag indicates how/when/if the object will add-ref the device.
typedef enum
{
    // External objects add-ref the device; they are
    // freed by calling Release()
    REF_EXTERNAL  = 0,

    // Intrinsic objects don't add-ref the device
    // except for additional add-refs. They are freed
    // when the number of releases equals the number of
    // addrefs AND the device has called DecrUseCount
    // on the object.
    REF_INTRINSIC = 1,

    // Internal is like intrinsic except that we
    // assert that no one should ever call AddRef or Release
    // on this object at all. To free it, you have to
    // call DecrUseCount
    REF_INTERNAL = 2,

} REF_TYPE;

class CBaseObject
{
public:

    // Provides access to the two handles represent
    // this object to the DDI/TokenStream. Specifically,
    // this represents the Real Sys-Mem data in the
    // case of Managed Resources. (To find
    // the vid-mem mapping for a managed resource;
    // see resource.hpp)
    DWORD BaseDrawPrimHandle() const
    {
        return D3D8GetDrawPrimHandle(m_hKernelHandle);
    } // DrawPrimHandle

    HANDLE BaseKernelHandle() const
    {
        return m_hKernelHandle;
    } // KernelHandle

    // NOTE: No internal object should ever add-ref another
    // internal object; otherwise we may end up with ref-count
    // cycles that prevent anything from ever going away.
    // Instead, an internal object may mark another internal
    // object as being "InUse" which will force it to be kept
    // in memory until it is no-longer in use (and the ref-count
    // is zero.)

    // Internal Implementations of AddRef and Release
    DWORD AddRefImpl();
    DWORD ReleaseImpl();

    DWORD IncrementUseCount()
    {
        DXGASSERT(m_refType != REF_INTERNAL || m_cRef == 0);
        m_cUseCount++;
        return m_cUseCount;
    } // IncrUseCount

    DWORD DecrementUseCount()
    {
        DXGASSERT(m_refType != REF_INTERNAL || m_cRef == 0);
        DXGASSERT(m_cUseCount > 0);
        m_cUseCount--;
        if (m_cUseCount == 0 && m_cRef == 0)
        {
            // Before deleting a BaseObject,
            // we need to call OnDestroy to make sure that
            // there is nothing pending in the command
            // stream that uses this object
            OnDestroy();

            // Ok; now safe to delete the object
            delete this;
            return 0;
        }
        return m_cUseCount;
    } // DecrUseCount

    // Internal implementation functions for
    // the PrivateData set of methods
    HRESULT SetPrivateDataImpl(REFGUID refguidTag,
                               CONST VOID* pvData,
                               DWORD cbSize,
                               DWORD dwFlags,
                               BYTE  iLevel);
    HRESULT GetPrivateDataImpl(REFGUID refguidTag,
                               LPVOID pvBuffer,
                               LPDWORD pcbSize,
                               BYTE iLevel) const;
    HRESULT FreePrivateDataImpl(REFGUID refguidTag,
                                BYTE iLevel);

    // Implements the OpenDevice method
    HRESULT GetDeviceImpl(IDirect3DDevice8 ** ppvInterface) const
    {
        if (!VALID_PTR_PTR(ppvInterface))
        {
            DPF_ERR("Invalid ppvInterface parameter passed to GetDevice");
            return D3DERR_INVALIDCALL;
        }

        return m_pDevice->QueryInterface(IID_IDirect3DDevice8, (void**) ppvInterface);
    }; // OpenDeviceImpl

    CBaseDevice * Device() const
    {
        return m_pDevice;
    } // Device

    // Method to for swapping the underlying identity of
    // a surface. Caller must make sure that we're not locked
    // or other such badness.
    void SwapKernelHandles(HANDLE *phKernelHandle)
    {
        DXGASSERT(m_hKernelHandle != NULL);
        DXGASSERT(*phKernelHandle != NULL);

        HANDLE tmp = m_hKernelHandle;
        m_hKernelHandle = *phKernelHandle;
        *phKernelHandle = tmp;
    }

protected:
    // The following are methods that are only
    // accessible by derived classes: they don't make
    // sense for other classes to call explicitly.

    // Constructor
    //

    CBaseObject(CBaseDevice *pDevice, REF_TYPE ref = REF_EXTERNAL) :
        m_pDevice(pDevice),
        m_refType(ref),
        m_hKernelHandle(NULL)
    {
        DXGASSERT(m_pDevice);
        DXGASSERT(m_refType == REF_EXTERNAL  ||
                  m_refType == REF_INTRINSIC ||
                  m_refType == REF_INTERNAL);

        m_pPrivateDataHead = NULL;
        if (ref == REF_EXTERNAL)
        {
            // External objects add-ref the device
            // as well as having their own reference
            // count set to one
            m_pDevice->AddRef();
            m_cRef     = 1;
            m_cUseCount = 0;
        }
        else
        {
            // Internal and intrinsic objects have no
            // initial ref-count; but they are
            // marked as InUse; the device frees them
            // by calling DecrUseCount
            m_cUseCount = 1;
            m_cRef     = 0;
        }
    }; // CBaseObject

    // The destructor is marked virtual so that delete calls to
    // the base interface will be handled properly
    virtual ~CBaseObject()
    {
        DXGASSERT(m_pDevice);
        DXGASSERT(m_cRef == 0);
        DXGASSERT(m_cUseCount == 0);

        CPrivateDataNode *pNode = m_pPrivateDataHead;
        while (pNode)
        {
            CPrivateDataNode *pNodeNext = pNode->m_pNodeNext;
            delete pNode;
            pNode = pNodeNext;
        }

        if (m_refType == REF_EXTERNAL)
        {
            // Release our reference on the
            // device
            m_pDevice->Release();
        }
    }; // ~CBaseObject

    // OnDestroy function is called just
    // before an object is about to get deleted; we
    // use this to provide synching as well as notification
    // to FE when a texture is going away.
    virtual void OnDestroy()
    {
        // Not all classes have to worry about this;
        // so the default is to do nothing.
    }; // OnDestroy

    void SetKernelHandle(HANDLE hKernelHandle)
    {
        // This better be null; or we either leaking something
        // or we had some uninitialized stuff that will hurt later
        DXGASSERT(m_hKernelHandle == NULL);

        // Remember our handles
        m_hKernelHandle    = hKernelHandle;

        DXGASSERT(m_hKernelHandle != NULL);
    } // SetHandle

    BOOL IsInUse()
    {
        return (m_cUseCount > 0);
    } // IsInUse

private:
    //
    // RefCount must be DWORD aligned
    //
    DWORD m_cRef;

    // Keep a "Use Count" which indicates whether
    // the device (or other object tied to the lifetime of
    // the device) is relying on this object from staying around.
    // This is used to prevent ref-count cycles that would
    // occur whenever something like SetTexture add-ref'ed the
    // the texture that was passed in.
    DWORD m_cUseCount;

    // Keep Track of the device that owns this object
    // This is an add-ref'ed value
    CBaseDevice *m_pDevice;

    // We need an internal handle so that
    // we can communicate to the driver/kernel.
    //
    // Note that the base object does not release this
    // and it is the responsibility of the derived
    // class to do so.
    HANDLE   m_hKernelHandle;

    // Keep track of list of private data objects
    class CPrivateDataNode;
    CPrivateDataNode *m_pPrivateDataHead;

    // Need to keep track of an intrinsic flag
    // to decide whether to release the device on
    // free
    // CONSIDER: Try to merge this flag into some
    // other variable.
    REF_TYPE  m_refType;

    // Helper function to find the right node
    CPrivateDataNode* Find(REFGUID refguidTag, BYTE iLevel) const;

    // Each private data is stored in this node
    // object which is only used for this purpose
    // by this class
    class CPrivateDataNode
    {
    public:
        CPrivateDataNode() {};
        ~CPrivateDataNode()
        {
            Cleanup();
        } // ~CPrivateDateNode

        GUID              m_guid;
        CPrivateDataNode *m_pNodeNext;
        DWORD             m_cbSize;
        DWORD             m_dwFlags;
        BYTE              m_iLevel;
        union
        {
            void         *m_pvData;
            IUnknown     *m_pUnknown;
        };

        void Cleanup();
    }; // CPrivateDataNode

}; // class CBaseObject


// Helper class for all surface types
//
class CBaseSurface : public IDirect3DSurface8
{
public:
    CBaseSurface() :
      m_isLocked(FALSE) {}

    // Methods to allow D3D methods to treat all surface
    // variants the same way
    virtual DWORD  DrawPrimHandle() const PURE;
    virtual HANDLE KernelHandle()   const PURE;

    // See CBaseObject::IncrementUseCount and
    // CBaseObject::DecrementUseCount and the
    // description of the REF_TYPEs above.
    virtual DWORD IncrementUseCount() PURE;
    virtual DWORD DecrementUseCount() PURE;

    // Batching logic is necessary to make sure
    // that the command buffer is flushed before
    // any read or write access is made to a
    // a surface. This should be called at
    // SetRenderTarget time; and it should be
    // called for the currently set rendertarget
    // and zbuffer when the batch count is updated
    virtual void Batch() PURE;

    // Sync should be called when a surface is
    // about to be modified; Normally this is taken
    // care of automatically by Lock; but it also
    // needs to be called prior to using the Blt
    // DDI.
    virtual void Sync() PURE;

    // Internal lock functions bypass
    // parameter checking and also whether the
    // surface marked as Lockable or LockOnce
    // etc.
    virtual HRESULT InternalLockRect(D3DLOCKED_RECT *pLockedRectData,
                                     CONST RECT     *pRect,
                                     DWORD           dwFlags) PURE;
    virtual HRESULT InternalUnlockRect() PURE;

    BOOL IsLocked() const
    {
        return m_isLocked;
    }; // IsLocked

    // Determines if a LOAD_ONCE surface has already
    // been loaded
    virtual BOOL IsLoaded() const PURE;

    // Provides a method to access basic structure of the
    // pieces of the resource.
    virtual D3DSURFACE_DESC InternalGetDesc() const PURE;

    // Access the device of the surface
    virtual CBaseDevice *InternalGetDevice() const PURE;

public:
    BOOL m_isLocked;

}; // class CBaseSurface

#endif // __D3DOBJ_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\d3dobj.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dobj.cpp
 *  Content:    Base class implementation for resources and buffers
 *
 *
 ***************************************************************************/

#include "ddrawpr.h"
#include "d3dobj.hpp"

// Declare static data for CLockD3D
#ifdef DEBUG
DWORD   CLockD3D::m_Count = 0;
#endif // DEBUG

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseObject::AddRefImpl"

// Internal Implementations of AddRef and Release
DWORD CBaseObject::AddRefImpl()
{
    // Internal objects should never be add-ref'ed
    // or released
    DXGASSERT(m_refType != REF_INTERNAL);

    // Only Intrinsic objects should have a ref
    // count of zero. (Internal objects also have
    // a ref count of zero; but AddRef shouldn't
    // be called for those.)
    DXGASSERT(m_cRef > 0 || m_refType == REF_INTRINSIC);

    // The first extra ref for an intrinsic
    // object causes an add-ref to the device
    if (m_cRef == 0)
    {
        DXGASSERT(m_refType == REF_INTRINSIC);

        UINT crefDevice = m_pDevice->AddRef();
        DXGASSERT(crefDevice > 1);
    }

    // InterlockedIncrement requires the memory
    // to be aligned on DWORD boundary
    DXGASSERT(((ULONG_PTR)(&m_cRef) & 3) == 0);
    InterlockedIncrement((LONG *)&m_cRef);

    return m_cRef;
} // AddRefImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseObject::AddRefImpl"

DWORD CBaseObject::ReleaseImpl()
{
    // Internal objects should never be add-ref'ed
    // or released
    DXGASSERT(m_refType != REF_INTERNAL);

    // Assert that we are not being
    // over-released.
    DXGASSERT(m_cRef > 0);

    if (m_cRef == 0)
    {
        // This heinous state can happen if a texture
        // was being held by the device; but not
        // only has the app held onto a pointer to
        // the texture, but they have released
        // their own pointer.

        // For this case, the safest thing to do
        // is return zero instead of crashing.
        return 0;
    }

    // InterlockedDecrement requires the memory
    // to be aligned on DWORD boundary
    DXGASSERT(((ULONG_PTR)(&m_cRef) & 3) == 0);
    InterlockedDecrement((LONG *)&m_cRef);
    if (m_cRef != 0)
    {
        // For a non-zero ref count,
        // just return the value
        return m_cRef;
    }

    // If we are not in use, then we delete ourselves
    // otherwise we wait until we are no longer marked
    // in use
    if (m_cUseCount == 0)
    {
        DXGASSERT(m_cRef == 0);

        // Before deleting a BaseObject,
        // we need to call OnDestroy to make sure that
        // there is nothing pending in the command
        // stream that uses this object
        OnDestroy();

        delete this;
    }
    else
    {
        // To make sure that we don't again release the
        // device at our destructor, we mark the object
        // as being non-external (refcount is zero and usecount is
        // non-zero). At this point, we know the object
        // is not an internal one: hence it was either
        // external or intrinsic. In either case, it could
        // potentially be handed out again (through GetBackBuffer or
        // GetTexture) and so we need to handle the case
        // where AddRef might be called. We mark the object as
        // INTRINSIC to indicate that that even though we don't
        // have a Ref on the device (as soon as we release it below),
        // we may need to acquire one if it gets add-ref'ed.
        DXGASSERT(m_refType != REF_INTERNAL);
        m_refType = REF_INTRINSIC;

        // We are still in use by the device; but we don't
        // have any external references; so we can
        // release our reference on the device. (Note that
        // even though this should be done before
        // changing the reftype, this must be the LAST
        // thing we do in this function.)
        m_pDevice->Release();

        // But this could have been the LAST reference to the
        // device; which means that device will now have
        // freed us; and the current object has now been
        // deleted. So don't access any member data!!
        //
        // How can this happen? Imagine an app that releases
        // everything except an external vb that is the current
        // stream source: in this case, the only device ref is from
        // the external object; but that extrenal object has a use
        // count of 1; when the app calls release on the
        // the vb, we end up here; calling release on the device
        // causes in turn a call to DecrementUseCount on the
        // current object; which causes the object to be freed.
    }

    // DO NOT PUT CODE HERE (see comment above)

    return 0;
} // ReleaseImpl


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseObject::SetPrivateDataImpl"

// Internal function that adds some private data
// information to an object. Supports having private
// data for multiple levels through the optional
// iLevel parameter
HRESULT CBaseObject::SetPrivateDataImpl(REFGUID refguidTag,
                                        CONST VOID*  pvData,
                                        DWORD   cbSize,
                                        DWORD   dwFlags,
                                        BYTE    iLevel)
{
    if (cbSize > 0 &&
        !VALID_PTR(pvData, cbSize))
    {
        DPF_ERR("Invalid pvData pointer to SetPrivateData");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&refguidTag, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid to SetPrivateData");
        return D3DERR_INVALIDCALL;
    }

    if (dwFlags & ~D3DSPD_IUNKNOWN)
    {
        DPF_ERR("Invalid flags to SetPrivateData");
        return D3DERR_INVALIDCALL;
    }

    if (dwFlags & D3DSPD_IUNKNOWN)
    {
        if (cbSize != sizeof(LPVOID))
        {
            DPF_ERR("Invalid size for IUnknown to SetPrivateData");
            return D3DERR_INVALIDCALL;
        }
    }

    // Remember if we allocated a new node or
    // not for error handling
    BOOL fNewNode;

    // Find the node in our list (if there)
    CPrivateDataNode *pNode = Find(refguidTag, iLevel);
    if (pNode)
    {
        // Clean up whatever it has already
        pNode->Cleanup();
        fNewNode = FALSE;
    }
    else
    {
        // Allocate a new node
        pNode = new CPrivateDataNode;
        if (pNode == NULL)
        {
            DPF_ERR("SetPrivateData failed a memory allocation");
            return E_OUTOFMEMORY;
        }

        // Initialize a few fields
        fNewNode = TRUE;
        pNode->m_guid = refguidTag;
        pNode->m_iLevel = iLevel;
    }

    // Initialize the other fields
    pNode->m_dwFlags = dwFlags;
    pNode->m_cbSize = cbSize;

    // Copy the data portion over
    if (dwFlags & D3DSPD_IUNKNOWN)
    {
        // We add-ref the object while we
        // keep a pointer to it
        pNode->m_pUnknown = (IUnknown *)pvData;
        pNode->m_pUnknown->AddRef();
    }
    else
    {
        // Allocate a buffer to store our data
        // into
        pNode->m_pvData = new BYTE[cbSize];
        if (pNode->m_pvData == NULL)
        {
            DPF_ERR("SetPrivateData failed a memory allocation");
            // If memory allocation failed,
            // then we may need to free the Node
            if (fNewNode)
            {
                delete pNode;
            }
            return E_OUTOFMEMORY;
        }
        memcpy(pNode->m_pvData, pvData, cbSize);
    }

    // If we allocated a new Node then
    // we need to put it into our list somewhere
    if (fNewNode)
    {
        // Stuff it at the beginning
        pNode->m_pNodeNext = m_pPrivateDataHead;
        m_pPrivateDataHead = pNode;
    }

    return S_OK;
} // CBaseObject::SetPrivateDataImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseObject::GetPrivateDataImpl"

// Internal function that searches the private data list
// for a match. This supports a single list for a container
// and all of its children by using the iLevel parameter.
HRESULT CBaseObject::GetPrivateDataImpl(REFGUID refguidTag,
                                        LPVOID  pvBuffer,
                                        LPDWORD pcbSize,
                                        BYTE    iLevel) const
{
    if (!VALID_WRITEPTR(pcbSize, sizeof(DWORD)))
    {
        DPF_ERR("Invalid pcbSize pointer to GetPrivateData");
        return D3DERR_INVALIDCALL;
    }

    if (pvBuffer)
    {
        if (*pcbSize > 0 &&
            !VALID_WRITEPTR(pvBuffer, *pcbSize))
        {
            DPF_ERR("Invalid pvData pointer to GetPrivateData");
            return D3DERR_INVALIDCALL;
        }
    }

    if (!VALID_PTR(&refguidTag, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid to GetPrivateData");
        return D3DERR_INVALIDCALL;
    }

    // Find the node in our list
    CPrivateDataNode *pNode = Find(refguidTag, iLevel);
    if (pNode == NULL)
    {
        DPF_ERR("GetPrivateData failed to find a match.");
        return D3DERR_NOTFOUND;
    }

    // Is the user just asking for the size?
    if (pvBuffer == NULL)
    {
        // Return the amount of buffer that was used
        *pcbSize = pNode->m_cbSize;

        // Return Ok in this case.
        return S_OK;
    }

    // Check if we were given a large enough buffer
    if (*pcbSize < pNode->m_cbSize)
    {
        DPF(2, "GetPrivateData called with insufficient buffer.");

        // If the buffer is insufficient, return
        // the necessary size in the out parameter
        *pcbSize = pNode->m_cbSize;

        // An error is returned since pvBuffer != NULL and
        // no data was actually returned.
        return D3DERR_MOREDATA;
    }

    // There is enough room; so just overwrite with
    // the right size
    *pcbSize = pNode->m_cbSize;

    // Handle the IUnknown case
    if (pNode->m_dwFlags & D3DSPD_IUNKNOWN)
    {
        *(IUnknown**)pvBuffer = pNode->m_pUnknown;

        // We Add-Ref the returned object
        pNode->m_pUnknown->AddRef();
        return S_OK;
    }

    memcpy(pvBuffer, pNode->m_pvData, pNode->m_cbSize);
    return S_OK;

} // CBaseObject::GetPrivateDataImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseObject::FreePrivateDataImpl"

HRESULT CBaseObject::FreePrivateDataImpl(REFGUID refguidTag,
                                         BYTE    iLevel)
{
    if (!VALID_PTR(&refguidTag, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid to FreePrivateData");
        return D3DERR_INVALIDCALL;
    }

    // Keep track of the address of the pointer
    // that points to our current node
    CPrivateDataNode **ppPrev = &m_pPrivateDataHead;

    // Keep track of our current node
    CPrivateDataNode *pNode = m_pPrivateDataHead;

    // Find the node in our list
    while (pNode)
    {
        // A match means that iLevel AND the guid
        // match up
        if (pNode->m_iLevel == iLevel &&
            pNode->m_guid   == refguidTag)
        {
            // If found, update the pointer
            // the points to the current node to
            // point to our Next
            *ppPrev = pNode->m_pNodeNext;

            // Delete the current node
            delete pNode;

            // We're done
            return S_OK;
        }

        // Update our previous pointer address
        ppPrev = &pNode->m_pNodeNext;

        // Update our current node to point
        // to the next node
        pNode = pNode->m_pNodeNext;
    }

    DPF_ERR("FreePrivateData called but failed to find a match");
    return D3DERR_NOTFOUND;
} // CBaseObject::FreePrivateDataImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseObject::Find"

// Helper function to iterate through the list of
// data members
CBaseObject::CPrivateDataNode * CBaseObject::Find(REFGUID refguidTag,
                                                  BYTE iLevel) const
{
    CPrivateDataNode *pNode = m_pPrivateDataHead;
    while (pNode)
    {
        if (pNode->m_iLevel == iLevel &&
            pNode->m_guid   == refguidTag)
        {
            return pNode;
        }
        pNode = pNode->m_pNodeNext;
    }
    return NULL;
} // CBaseObject::Find

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseObject::CPrivateDataNode::Cleanup"

void CBaseObject::CPrivateDataNode::Cleanup()
{
    if (m_dwFlags & D3DSPD_IUNKNOWN)
    {
        DXGASSERT(m_cbSize == sizeof(IUnknown *));
        m_pUnknown->Release();
    }
    else
    {
        delete [] m_pvData;
    }
    m_pvData = NULL;
    m_cbSize = 0;
    m_dwFlags &= ~D3DSPD_IUNKNOWN;

    return;
} // CBaseObject::CPrivateDataNode::Cleanup



// End of file : d3dobj.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\d3dmem.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dmem.c
 *  Content:    Direct3D mem allocation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

static D3DMALLOCFUNCTION malloc_function = (D3DMALLOCFUNCTION) MemAlloc;
static D3DFREEFUNCTION free_function = MemFree;

#ifdef __USEGLOBALNEWANDDELETE
//----------------------------------------------------------------------------
// 
// Global new and delete
//
//----------------------------------------------------------------------------
void* operator new(size_t s)
{
    void *p;
    MallocAligned(&p,s);
    return p;
};

void operator delete(void* p)
{
    FreeAligned(p);
};
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "D3DMalloc"

HRESULT D3DAPI D3DMalloc(LPVOID* p_return, size_t size)
{
    void* p;

    if (!VALID_OUTPTR(p_return)) 
    {
        DPF_ERR("Bad pointer given. Memory allocation fails");
        return D3DERR_INVALIDCALL;
    }
    if (size > 0) 
    {
        p = malloc_function(size);
        if (p == NULL)
            return (E_OUTOFMEMORY);
    } 
    else 
    {
        p = NULL;
    }
    *p_return = p;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DFree"

VOID D3DAPI D3DFree(LPVOID p)
{
    if (p == NULL) 
        return;

    if (!VALID_DWORD_PTR(p)) 
    {
        DPF_ERR("invalid pointer. Memory Free ignored");
        return;
    }
    if (p) 
    {
        free_function(p);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "MallocAligned"

#define CACHE_LINE 32
HRESULT MallocAligned(void** p_return, size_t size)
{
    char* p;
    size_t offset;
    HRESULT error;

    if (!p_return)
        return D3DERR_INVALIDCALL;

    if (size > 0) 
    {
        if ((error = D3DMalloc((void**) &p, size + CACHE_LINE)) != S_OK)
        {
            *p_return = NULL;
            return error;
        }
        offset = (size_t)(CACHE_LINE - ((ULONG_PTR)p & (CACHE_LINE - 1)));
        p += offset;
        ((size_t*)p)[-1] = offset;
    } 
    else
    {
        p = NULL;
    }
    *p_return = p;
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FreeAligned"

void FreeAligned(void* p)
{
    if (p) 
    {
        size_t offset = ((size_t*)p)[-1];
        p = (void*) ((unsigned char*)p - offset);
        D3DFree(p);
    }
}
#undef DPF_MODNAME
#define DPF_MODNAME "CAlignedBuffer32::Grow"

//----------------------------------------------------------------------------
// Growing aligned buffer implementation.
//
HRESULT CAlignedBuffer32::Grow(DWORD growSize)
{
    if (allocatedBuf)
        D3DFree(allocatedBuf);
    size = growSize;
    if (D3DMalloc(&allocatedBuf, size + 31) != S_OK)
    {
        allocatedBuf = 0;
        alignedBuf = 0;
        size = 0;
        return E_OUTOFMEMORY;
    }
    alignedBuf = (LPVOID)(((ULONG_PTR)allocatedBuf + 31 ) & ~31);
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\ddgdi32.c ===
/******************************Module*Header*******************************\
* Module Name: ddraw.c
*
* Client side stubs for the private DirectDraw system APIs.
*
* Created: 3-Dec-1995
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/


#define _D3DTYPES_H_
#define _D3DCAPS_H_
#include "ddrawpr.h"
//#include "ddrawgdi.h"
#include <ddrawint.h>
#include <d3dnthal.h>
#include <winddi.h>
#include <osthunk.h>
#include "ddithunk.h"
#include <d3d8sddi.h>
#include <assert.h>

#define _FACD3D  0x876
#define MAKE_D3DHRESULT( code )  MAKE_HRESULT( 1, _FACD3D, code )
#define D3DERR_DEVICELOST                       MAKE_D3DHRESULT(2152)
#define D3DERR_DRIVERINTERNALERROR              MAKE_D3DHRESULT(2087)
#define D3DERR_NOTAVAILABLE                     MAKE_D3DHRESULT(2154)
#define D3DERR_OUTOFVIDEOMEMORY                 MAKE_D3DHRESULT(380)
#define D3DERR_DEFERRED_DP2ERROR                MAKE_D3DHRESULT(2158)

typedef struct _KNOWNENTRY
{
    DWORD   PCIID;
    DWORD   VersionMajor;       // 0 means all versions
    DWORD   VersionMinor;       // 0 means all versions
    DWORD   Flags;
} KNOWNENTRY;

// The buffer used by GetDriverInfo2 is constrained to the maximum size
// specified below by restrictions in the Win2K kernel. It is vital that
// all data passed to the driver and received from the driver via
// GetDriverInfo2 fit within a buffer of this number of DWORDS.
// This size has to be less than 1K to let the kernel do its own buffer
// overwrite testing.
#define MAX_GDI2_BUFFER_DWORD_SIZE (249)

// Bogus value used to initialize write only fields when communicating
// with the driver in debug builds
#define BOGUS_FIELD_VALUE          0xBAADCAFEul

// Some global variables used to track when surfaces are free for all devices
// in the process.  This is tricky since we don't keep a device list.
DWORD GlobalUniqueness = 0;
DWORD NumDevices = 0;
DWORD NumReadyDevices = 0;

//todo d16 for rage 128 series... need date/time
//todo :G200, G400 new RT+Tex formats... need date/time
//todo: Need driver date/time for Kyro: |KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8
//todo: Trident 8420, 9910: need date/time for D16
//todo: dates for SiS parts D16

const KNOWNENTRY gKnownDeviceList[] =
{
    // NVidia
    {0x12D20018,          0,          0, KNOWN_ZSTENCILDEPTH},                                      // Riva 128         
    {0x10DE0020,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT
    {0x10DE0028,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT2
    {0x10DE0029,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT2 Ultra
    {0x10DE002C,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Vanta
    {0x10DE002D,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT2 Model 64
    {0x10DE00A0,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Aladdin TNT2
    {0x10DE0100,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV10 (GeForce) 
    {0x10DE0101,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV10 (GeForce DDR) 
    {0x10DE0103,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV10 (Quadro) 
    {0x10DE0110,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV11 (GeForce2 MX) 
    {0x10DE0111,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV11 (GeForce2 MX) 
    {0x10DE0113,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV11 (Quadro2 MXR) 
    {0x10DE0150,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (GeForce2)
    {0x10DE0151,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (GeForce2 DDR) 
    {0x10DE0152,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (GeForce2 BR) 
    {0x10DE0153,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (Quadro2) 
    {0x10DE0200,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV20 (GeForce 3)
    // 3DFX
    {0x121A0003,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5},            // Banshee
    {0x121A0005,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5},            // Voodoo3
    {0x121a0009,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A8R8G8B8},       // Voodoo4/5; same PCI-ID
    // ATI                                                                                           
    {0x10024742,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024744,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024749,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x1002474D,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x1002474E,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x1002474F,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024750,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024752,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C42,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro (PCI)
    {0x10024C49,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro (PCI)
    {0x10024C4E,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C52,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C53,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C60,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro LT

    {0x10024C4D,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X1R5G5B5},   // Rage Mobility AGP

    {0x10024C46, 0x0005000a, 0x00000404, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128
    {0x10024C46,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128
    {0x10024D46, 0x0005000a, 0x00000404, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128
    {0x10024D46,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128

    {0x10025046, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS
    {0x10025046,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS
    {0x10025245, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x10025245,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x10025246, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x10025246,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x1002524B, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 VR PCI //DX8.1
    {0x1002524B,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 VR PCI //DX8.1
    {0x1002524C, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x1002524C,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128

    //New 128s for DX8.1:
    {0x10025041, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025041,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025042, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025042,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025043, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025043,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025044, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025044,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025045, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025045,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025047, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025047,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025048, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025048,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025049, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025049,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x1002504a, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x1002504a,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x1002504b, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x1002504b,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x1002504c, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x1002504c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x1002504d, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP            DX8.1
    {0x1002504d,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP            DX8.1
    {0x1002504e, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x1002504e,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x1002504f, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x1002504f,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025050, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025050,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025051, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025051,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025052, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x10025052,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x10025053, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025053,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025054, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025054,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025055, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025055,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025056, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025056,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025057, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025057,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025058, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x10025058,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
                        
    {0x10025345, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x10025345,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x10025346, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x10025346,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x10025347, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x10025347,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x10025348, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X   DX8.1
    {0x10025348,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X   DX8.1
    {0x1002534b, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x1002534b,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x1002534c, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x1002534c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x1002534d, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x1002534d,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x1002534e, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X     DX8.1
    {0x1002534e,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X     DX8.1

    {0x10025446, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA GL AGP      DX8.1
    {0x10025446,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA GL AGP      DX8.1
    {0x1002544c, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA VR AGP      DX8.1
    {0x1002544c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA VR AGP      DX8.1
    {0x10025452, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA4XL VR-R AGP DX8.1
    {0x10025452,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA4XL VR-R AGP DX8.1

    {0x10025144,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6
    {0x10025145,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6
    {0x10025146,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6
    {0x10025147,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6

    // Intel                                                                                         
    {0x80867800,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},  // Intel i740
    {0x80867123,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},  // Intel 810
    {0x80867125,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},                              // Intel 810e
    {0x80861132,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},                                                 // Intel 815
    {0x80861A12,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},                                            // Intel Timna

    // Matrox                                                                                        
    {0x102b0520, 0x0005000c, 0x000104b0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},                                      // G200 PCI
    {0x102b0520,          0,          0, KNOWN_ZSTENCILDEPTH},                                      // G200 PCI
    {0x102b0521, 0x0005000c, 0x000104b0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // G200 AGP
    {0x102b0521,          0,          0, KNOWN_ZSTENCILDEPTH},          // G200 AGP
    {0x102b0525, 0x0005000c, 0x000104b0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // G400, G450
    {0x102b0525,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // G400, G450
    // 3DLabs                                                                                        
    {0x3d3d0008,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH},                                      // 3DLabs Gamma
    {0x104c3d07,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8}, // Perm2
    {0x3d3d0009,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8},                                      // Perm2
    {0x3d3d000a,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Perm3
    {0x3d3d000a, 0x00050000, 0x08930001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Perm3
    {0x3d3d000c, 0x00050000, 0x08930001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Perm3
    // Videologic                                                                                    
    {0x104a0010, 0x0004000c, 0x0001080c, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // PowerVR Kyro updated driver
    {0x104a0010,          0,          0, KNOWN_ZSTENCILDEPTH}, // PowerVR Kyro
    // S3                                                                                            
    {0x53338811,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge
    {0x53335631,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge
    {0x53338a01,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge DX/GX DX8.1
    {0x53338c01,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge MX DX8.1
    {0x53338a10,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge GX2 DX8.1
    {0x53338a20,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},          // Savage3D
    {0x53338a22,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // Savage4
    {0x53339102,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},          // Savage2K
    {0x53338c10,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},          // Savage MX DX8.1
    {0x53338c12,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},          // Savage IX DX8.1
    {0x53338a25,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // Savage Pro DX8.1
    {0x53338a26,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // Savage Pro DX8.1
    // Trident
    {0x10239880,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER}, // Trident Blade 3D 9880
    {0x10238500,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident Blade 3D/ProMedia DX8.1
    {0x10238400,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident Blade 3D/MVP4     DX8.1
    {0x10238420,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident CyberBlade i7 
    {0x10239910,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident CyberBlade DX8.1
    // SiS
    {0x10390300, 0x0005000c, 0x0001044c, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},               // SiS 300
    {0x10390300,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},               // SiS 300
    {0x10396326, 0x0005000c, 0x00010514, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5},          // SiS 6326
    {0x10396326,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER },          // SiS 6326
    {0x10395300, 0x0005000c, 0x0001044c, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},               // SiS 300
    {0x10395300,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},               // SiS 300
    {0x10396300, 0x0005000c, 0x0001044c, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},               // SiS 6300
    {0x10396300,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5},               // SiS 6300
    {0x10390310, 0x0005000d, 0x0001035c, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 310
    {0x10390315, 0x0005000d, 0x0001035c, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 315
    {0x10390325, 0x0005000d, 0x000107d0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 325
    {0x10396325, 0x0005000d, 0x000107d0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 640/740
    {0x126f0720,          0,          0, KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5} //Silicon Motion Lynx3DM
};

#define NUM_KNOWN_DEVICES      (sizeof(gKnownDeviceList)/sizeof(KNOWNENTRY))

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

void InformDriverFreeAGP(HANDLE hDD);
void InformDriverToDeferFrees(HANDLE hDD);
void InformDriverAGPWorkaroundAware(HANDLE hDD);

#ifdef DEBUG
// Debug helper to indicate which surfaces are around
// 
void DebugPrintSurfaceInfo(PDDSURFHANDLE pSurf)
{
    switch (pSurf->Type)
    {
    case D3DRTYPE_SURFACE:
        DPF(0,"  D3DRTYPE_SURFACE");
        break;
    case D3DRTYPE_VOLUME:
        DPF(0,"  D3DRTYPE_VOLUME");
        break;
    case D3DRTYPE_TEXTURE:
        DPF(0,"  D3DRTYPE_TEXTURE");
        break;
    case D3DRTYPE_VOLUMETEXTURE:
        DPF(0,"  D3DRTYPE_VOLUMETEXTURE");
        break;
    case D3DRTYPE_CUBETEXTURE:
        DPF(0,"  D3DRTYPE_CUBETEXTURE");
        break;
    case D3DRTYPE_VERTEXBUFFER:
        DPF(0,"  D3DRTYPE_VERTEXBUFFER");
        break;
    case D3DRTYPE_INDEXBUFFER:
        DPF(0,"  D3DRTYPE_INDEXBUFFER");
        break;
    case D3DRTYPE_COMMANDBUFFER:
        DPF(0,"  D3DRTYPE_COMMANDBUFFER");
        break;
    default:
        DPF(0,"  UNKNOWN SURFACE TYPE");
        break;
    }
} // DebugPrintSurfaceInfo
#endif 



HRESULT MapLegacyResult(HRESULT in)
{
    HRESULT hr;
    switch (in)
    {
    case DD_OK:
        hr = S_OK;
        break;

    case DDERR_OUTOFVIDEOMEMORY:
        hr = D3DERR_OUTOFVIDEOMEMORY;
        break;

    case DDERR_CURRENTLYNOTAVAIL:
    case DDERR_UNSUPPORTED:
        hr = D3DERR_NOTAVAILABLE;
        break;

    case DDERR_OUTOFMEMORY:
        hr = E_OUTOFMEMORY;
        break;

    default:
        hr = D3DERR_DRIVERINTERNALERROR;
    }
    return hr;
}

BOOL CanKnownDriverDoThis(PDDDEVICEHANDLE pDevice, DWORD Flag)
{
    BOOL ret = FALSE;
    int i;

    if (pDevice->ForceFlagsOff & Flag)
    {
        return FALSE;
    }
    else if (pDevice->ForceFlagsOn & Flag)
    {
        return TRUE;
    }

    // Only drivers in our known good list can support lightweight
    // surfaces

    if (pDevice->PCIID == 0)
    {
        D3DADAPTER_IDENTIFIER8  DI;

        GetAdapterInfo(pDevice->szDeviceName, &DI, TRUE, TRUE, FALSE);
        pDevice->PCIID = (DI.VendorId << 16) | DI.DeviceId;
        pDevice->DriverVersionHigh = DI.DriverVersion.HighPart;
        pDevice->DriverVersionLow = DI.DriverVersion.LowPart;
    }
    for (i = 0; i < NUM_KNOWN_DEVICES; i++)
    {
        if ((gKnownDeviceList[i].PCIID == pDevice->PCIID) &&
            (gKnownDeviceList[i].Flags & Flag) &&
            ((pDevice->DriverVersionHigh > gKnownDeviceList[i].VersionMajor) ||
             ((pDevice->DriverVersionHigh == gKnownDeviceList[i].VersionMajor) &&
              (pDevice->DriverVersionLow >= gKnownDeviceList[i].VersionMinor))))
        {
            ret = TRUE;
            break;
        }
    }

    return ret;
}

BOOL FormatCompatibleWithDisplayFormat(
    PDDDEVICEHANDLE pDD,
    D3DFORMAT Format)
{
    // The surface is compatible if formats match
    if (Format == pDD->DisplayFormatWithAlpha)
        return TRUE;
    return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseDX7SurfaceHandle"

void ReleaseDX7SurfaceHandle(HANDLE hDD, DWORD handle)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;

    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry =
        pDeviceHandle->SurfaceHandleList.dwFreeList;
    pDeviceHandle->SurfaceHandleList.dwFreeList = handle;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FreeSurfaceObject"

void FreeSurfaceObject (PDDSURFHANDLE pSurf)
{
    DWORD dwRet = DDHAL_DRIVER_NOTHANDLED;

    // If the surface was created by a software driver, we need to call the
    // software driver to destroy it.

    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        // In a creation failure case, we may have not actually called the
        // driver/kernel to create this surface yet.

        // Release the kernel's handle first so that it
        // can finish up whatever it wants to before we free
        // the underlying memory
        if (pSurf->hSurface != 0)
        {
            OsThunkDdDeleteSurfaceObject(pSurf->hSurface);
        }

        // Now free the SW driver's object
        if (pSurf->dwFlags & DDSURF_CREATECOMPLETE)
        {
            dwRet = SwDDIDestroySurface (pSurf->pDevice, pSurf);
        }

    }
    else if (pSurf->hSurface != 0)
    {
        if (pSurf->Pool != D3DPOOL_SYSTEMMEM)
        {
            if ((pSurf->Type == D3DRTYPE_COMMANDBUFFER) ||
                (pSurf->Type == D3DRTYPE_VERTEXBUFFER)  || 
                (pSurf->Type == D3DRTYPE_INDEXBUFFER) )
            {
                OsThunkDdDestroyD3DBuffer(pSurf->hSurface);
            }
            else
            {
                OsThunkDdDestroySurface(pSurf->hSurface, TRUE);
            }
        }
        OsThunkDdDeleteSurfaceObject(pSurf->hSurface);
        pSurf->hSurface = NULL;
    }

    if (pSurf->dwCookie)
    {
        // If CreateSurfaceEx was called on a sysmem surface, we need to tell
        // the driver.  On NT, we only need to tell the software driver since
        // the kernel handles this for a real driver.

        if ((IS_SOFTWARE_DRIVER(pSurf->pDevice)) &&
            (pSurf->dwFlags & DDSURF_CREATECOMPLETE) &&
            (pSurf->Pool == D3DPOOL_SYSTEMMEM))
        {
            // DX7 called CreateSurfaceEx fpVidMem = 0 on each mipmap level
            // (even though it only creates it on the topmost level), so we
            // need to do the same to maintain driver compatibility.

            pSurf->pLcl->lpGbl->fpVidMem = 0;
            SwDDICreateSurfaceEx (pSurf->pDevice->pDD, pSurf->pLcl);
        }

        ReleaseDX7SurfaceHandle(pSurf->pDevice, pSurf->dwCookie);
        pSurf->dwCookie = 0;
    }

    if (pSurf->pLcl != NULL)
    {
        MemFree(pSurf->pLcl);
        pSurf->pLcl = NULL;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CheckForDeviceLost"

BOOL CheckForDeviceLost (HANDLE hDD)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFHANDLE pSurf;
    DWORD           Uniqueness = DdQueryDisplaySettingsUniqueness();

    if (!pDeviceHandle->bDeviceLost &&
        (Uniqueness != pDeviceHandle->DisplayUniqueness))
    {
        // If this is the first device to notice it is lost, then set
        // some state.
        if (InterlockedCompareExchange(&GlobalUniqueness, Uniqueness, GlobalUniqueness) != Uniqueness)
        {
            NumReadyDevices = 0;
        }
        pDeviceHandle->dwFlags &= ~DDDEVICE_READY;

        // The device has transitioned to the lost state, so we need
        // walk through the list and free the vidmem surfaces..

        pDeviceHandle->bDeviceLost  = TRUE;
        pSurf = pDeviceHandle->pSurfList;
        while (pSurf != NULL)
        {
            if (IS_SURFACE_LOOSABLE(pSurf))
            {
                if (pSurf->LockRefCnt == 0)
                {
                    FreeSurfaceObject(pSurf);
                }
                pSurf->fpVidMem = (ULONG_PTR) NULL;
            }
            pSurf = pSurf->pNext;
        }
    }

    return pDeviceHandle->bDeviceLost;
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetDX7SurfaceHandle"

DWORD GetDX7SurfaceHandle (HANDLE hDD)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    DWORD           handle = pDeviceHandle->SurfaceHandleList.dwFreeList;

    if (0==handle)
    {
        // need to grow the dwList
        LPDDSURFACELISTENTRY  newList;
        DWORD   newsize;
        DWORD   index;
        if (NULL != pDeviceHandle->SurfaceHandleList.dwList)
        {
            // old size(current dwFreeList) must not be zero
            DDASSERT(0 != pDeviceHandle->SurfaceHandleList.dwList[0].nextentry);
            // new dwFreeList is always gonna be the old dwList[0].nextentry
            newsize = pDeviceHandle->SurfaceHandleList.dwList[0].nextentry + LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
                DPF_ERR("MemAlloc failure in GetSurfaceHandle(). Can't create new texture/surface/buffer.");
                return  0;
            }
            pDeviceHandle->SurfaceHandleList.dwFreeList =
                pDeviceHandle->SurfaceHandleList.dwList[0].nextentry;
            memcpy((LPVOID)newList,(LPVOID)pDeviceHandle->SurfaceHandleList.dwList,
                pDeviceHandle->SurfaceHandleList.dwList[0].nextentry*sizeof(DDSURFACELISTENTRY));
            MemFree(pDeviceHandle->SurfaceHandleList.dwList);
        }
        else
        {
            newsize = LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
                DPF_ERR("MemAlloc failure in GetSurfaceHandle(). Can't create new texture/surface/buffer");
                return  0;
            }
            // start from one as we don't want 0 as a valid handle
            pDeviceHandle->SurfaceHandleList.dwFreeList = 1;
        }
        pDeviceHandle->SurfaceHandleList.dwList=newList;
        pDeviceHandle->SurfaceHandleList.dwList[0].nextentry=newsize;

        for (index = pDeviceHandle->SurfaceHandleList.dwFreeList;
            index < newsize - 1;
            index++)
        {
            newList[index].nextentry=index+1;
        }
        // indicate end of new FreeList
        newList[newsize-1].nextentry=0;
        // now pop up one and assign it to handle
        handle=pDeviceHandle->SurfaceHandleList.dwFreeList;
    }
    // handle slot is avialable so just remove it from freeList
    pDeviceHandle->SurfaceHandleList.dwFreeList =
    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry;
#if DBG
    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry=0xDEADBEEF;
#endif
    pDeviceHandle->SurfaceHandleList.dwList[handle].dwFlags=0;  //mark it's new
    pDeviceHandle->SurfaceHandleList.dwList[handle].lpSurface=NULL;
    DDASSERT (handle > 0);
    DDASSERT (handle < pDeviceHandle->SurfaceHandleList.dwList[0].nextentry);
    return handle;
}

/*****************************Private*Routine******************************\
* DdConvertToOldFormat
*
* History:
*  3-Nov-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "ConvertToOldFormat"

void ConvertToOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT NewFormat)
{
    // Zero out the format to avoid missing
    // cases where it isn't initialized right
    ZeroMemory(pOldFormat, sizeof(*pOldFormat));

    // Set Size
    pOldFormat->dwSize = sizeof(DDPIXELFORMAT);

    // Convert away
    if (HIWORD((DWORD)NewFormat))
    {
        pOldFormat->dwFlags = DDPF_FOURCC;
        pOldFormat->dwFourCC = (DWORD)NewFormat;
        return;
    }

    switch (NewFormat)
    {
    case D3DFMT_R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 24;
        break;

    case D3DFMT_A8R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0xFF000000;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 32;
        break;

    case D3DFMT_X8R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 32;
        break;

    case D3DFMT_R5G6B5:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x0000f800;
        pOldFormat->dwGBitMask        = 0x000007e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_X1R5G5B5:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00007c00;
        pOldFormat->dwGBitMask        = 0x000003e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A1R5G5B5:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x00008000;
        pOldFormat->dwRBitMask        = 0x00007c00;
        pOldFormat->dwGBitMask        = 0x000003e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A4R4G4B4:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x0000f000;
        pOldFormat->dwRBitMask        = 0x00000f00;
        pOldFormat->dwGBitMask        = 0x000000f0;
        pOldFormat->dwBBitMask        = 0x0000000f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_X4R4G4B4:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00000f00;
        pOldFormat->dwGBitMask        = 0x000000f0;
        pOldFormat->dwBBitMask        = 0x0000000f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_R3G3B2:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x000000e0;
        pOldFormat->dwGBitMask        = 0x0000001c;
        pOldFormat->dwBBitMask        = 0x00000003;
        pOldFormat->dwRGBBitCount     = 8;
        break;

    case D3DFMT_A8R3G3B2:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x0000FF00;
        pOldFormat->dwRBitMask        = 0x000000e0;
        pOldFormat->dwGBitMask        = 0x0000001c;
        pOldFormat->dwBBitMask        = 0x00000003;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A8P8:
        pOldFormat->dwFlags            = DDPF_RGB         |
                                         DDPF_ALPHAPIXELS |
                                         DDPF_PALETTEINDEXED8;

        pOldFormat->dwRGBAlphaBitMask  = 0x0000FF00;
        pOldFormat->dwRGBBitCount      = 16;
        break;

    case D3DFMT_P8:
        pOldFormat->dwFlags            = DDPF_RGB         |
                                         DDPF_PALETTEINDEXED8;
        pOldFormat->dwRGBBitCount      = 8;
        break;

    case D3DFMT_L8:
        pOldFormat->dwFlags             = DDPF_LUMINANCE;
        pOldFormat->dwLuminanceBitMask  = 0x000000FF;
        pOldFormat->dwLuminanceBitCount = 8;
        break;

    case D3DFMT_A8L8:
        pOldFormat->dwFlags                 = DDPF_LUMINANCE |
                                              DDPF_ALPHAPIXELS;
        pOldFormat->dwLuminanceAlphaBitMask = 0x0000FF00;
        pOldFormat->dwLuminanceBitMask      = 0x000000FF;
        pOldFormat->dwLuminanceBitCount     = 16;
        break;

    case D3DFMT_A4L4:
        pOldFormat->dwFlags                 = DDPF_LUMINANCE |
                                              DDPF_ALPHAPIXELS;
        pOldFormat->dwLuminanceAlphaBitMask = 0x000000F0;
        pOldFormat->dwLuminanceBitMask      = 0x0000000F;
        pOldFormat->dwLuminanceBitCount     = 8;
        break;

    case D3DFMT_V8U8:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV;
        pOldFormat->dwBumpDvBitMask        = 0x0000FF00;
        pOldFormat->dwBumpDuBitMask        = 0x000000FF;
        pOldFormat->dwBumpBitCount         = 16;
        break;

    case D3DFMT_L6V5U5:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV |
                                             DDPF_BUMPLUMINANCE;
        pOldFormat->dwBumpLuminanceBitMask = 0x0000FC00;
        pOldFormat->dwBumpDvBitMask        = 0x000003E0;
        pOldFormat->dwBumpDuBitMask        = 0x0000001F;
        pOldFormat->dwBumpBitCount         = 16;
        break;

    case D3DFMT_X8L8V8U8:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV |
                                             DDPF_BUMPLUMINANCE;
        pOldFormat->dwBumpLuminanceBitMask = 0x00FF0000;
        pOldFormat->dwBumpDvBitMask        = 0x0000FF00;
        pOldFormat->dwBumpDuBitMask        = 0x000000FF;
        pOldFormat->dwBumpBitCount         = 32;
        break;

    case D3DFMT_A8:
        pOldFormat->dwFlags                = DDPF_ALPHA;
        pOldFormat->dwAlphaBitDepth        = 8;
        break;

    case D3DFMT_D16:
    case D3DFMT_D16_LOCKABLE:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0xFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0;
        break;

    case D3DFMT_D32:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0;
        break;

    case D3DFMT_D15S1:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0xFFFE;
        pOldFormat->dwStencilBitDepth      = 1;
        pOldFormat->dwStencilBitMask       = 0x0001;
        break;
    case D3DFMT_D24S8:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 8;
        pOldFormat->dwStencilBitMask       = 0xFF;
        break;
    case D3DFMT_S1D15:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0x7FFF;
        pOldFormat->dwStencilBitDepth      = 1;
        pOldFormat->dwStencilBitMask       = 0x8000;
        break;
    case D3DFMT_S8D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 8;
        pOldFormat->dwStencilBitMask       = 0xFF000000;
        break;
    case D3DFMT_X8D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0x00000000;
        break;
    case D3DFMT_D24X8:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0x00000000;
        break;
    case D3DFMT_D24X4S4:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 4;
        pOldFormat->dwStencilBitMask       = 0x0000000F;
        break;
    case D3DFMT_X4S4D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 4;
        pOldFormat->dwStencilBitMask       = 0x0F000000;
        break;

    default:
        // All other formats are treated as a
        // FOURCC
        pOldFormat->dwFlags = DDPF_FOURCC;
        pOldFormat->dwFourCC = (DWORD)NewFormat;
        break;
    }

    return;
}


/*****************************Private*Routine******************************\
* InitSurfaceStructures
*
* History:
*  06-Dec-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "InitSurfaceStructure"

void InitSurfaceStructures(
    PD3D8_CREATESURFACEDATA pCreateSurface,
    DD_SURFACE_LOCAL*       pDDSurfaceLocal,
    DD_SURFACE_GLOBAL*      pDDSurfaceGlobal,
    DD_SURFACE_MORE*        pDDSurfaceMore
   )
{
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;
    DWORD   i;
    DWORD   j;
    DWORD   dwBit;

    for (i = 0; i < pCreateSurface->dwSCnt; i++)
    {
        // Make sure there's always a valid pixel format for the surface:
        if ((pCreateSurface->Format != D3DFMT_UNKNOWN) &&
            (pCreateSurface->Format != D3DFMT_VERTEXDATA) &&
            (pCreateSurface->Format != D3DFMT_INDEX16) &&
            (pCreateSurface->Format != D3DFMT_INDEX32))
        {
            pDDSurfaceLocal[i].dwFlags |= DDRAWISURF_HASPIXELFORMAT;

            // For non-textures, we want to promote X8R8G8B8 to A8R8G8B8 in some cases;
            // this allows things like RTs and Backbuffers to get created matching the
            // primary which is more consistent with typical DX7 usage.
            if (FormatCompatibleWithDisplayFormat(pDevice, (D3DFORMAT)pCreateSurface->Format) &&
                (pCreateSurface->Type == D3DRTYPE_SURFACE))
            {
                ConvertToOldFormat(&pDDSurfaceGlobal[i].ddpfSurface, pDevice->DisplayFormatWithAlpha);
            }
            else
            {
                ConvertToOldFormat(&pDDSurfaceGlobal[i].ddpfSurface, (D3DFORMAT)pCreateSurface->Format);
            }
        }

        // Setup width/height first
        pDDSurfaceGlobal[i].wWidth       = pCreateSurface->pSList[i].cpWidth;
        pDDSurfaceGlobal[i].wHeight      = pCreateSurface->pSList[i].cpHeight;

        //dwCaps3==1 means 1 sample per pixel.
        pDDSurfaceMore[i].ddsCapsEx.dwCaps3 = DDSCAPS3_MULTISAMPLE_MASK & (DWORD) pCreateSurface->MultiSampleType;

        if (pCreateSurface->dwUsage & D3DUSAGE_ALPHACHANNEL)
        {
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_ENABLEALPHACHANNEL;
        }

        switch (pCreateSurface->Type)
        {
        case D3DRTYPE_SURFACE:
            // Surfaces come in three general flavors:
            //  - Primary flip chains
            //  - Z buffers
            //  - OffscreenPlain (RenderTargets or just sys-mem stuff)
            //
            // Textures are a different resource type

            if (pCreateSurface->dwUsage & D3DUSAGE_PRIMARYSURFACE)
            {
                // If we aren't creating a primary flip chain, then we
                // don't have to do much here.
                
                if (pCreateSurface->dwSCnt == 1)
                {
                    pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_PRIMARYSURFACE;
                }
                else
                {
                    if (i == 0)
                    {
                        // This is the front buffer
                        pDDSurfaceLocal[i].ddsCaps.dwCaps |=
                            DDSCAPS_PRIMARYSURFACE |
                            DDSCAPS_VISIBLE |
                            DDSCAPS_FRONTBUFFER;
                    }
                    else
                    {
                        // This is a back buffer
                        pDDSurfaceLocal[i].ddsCaps.dwCaps |=
                            DDSCAPS_BACKBUFFER;
                    }

                    // All surfaces in the primary chain get these caps
                    pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_COMPLEX | DDSCAPS_FLIP | DDSCAPS_3DDEVICE;

                    // We also get a CreateEx handle for all surfaces in the
                    // chain, but not if we're running w/ a software driver.
                    if (((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDD == NULL)
                    {
                        pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
                    }
                }
            }
            else if (pCreateSurface->dwUsage & D3DUSAGE_DEPTHSTENCIL)
            {
                DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );
                pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_ZBUFFER;
                pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            }
            else
            {
                pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_OFFSCREENPLAIN;
            }
            break;
        case D3DRTYPE_VOLUME:
            // We don't create stand-alone volumes
            DDASSERT(FALSE);
            break;
        case D3DRTYPE_TEXTURE:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_TEXTURE;

            //mipmaps are only DDI-level mipmaps if they're more than one level
            if (pCreateSurface->dwSCnt>1)
                pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_MIPMAP;

            if (i > 0)
            {
                // Mark non-top levels as being a sub-level
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
            }

            if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
            }

            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            break;
        case D3DRTYPE_VOLUMETEXTURE:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_VOLUME;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps4 =
                MAKELONG((WORD)(pCreateSurface->pSList[i].cpDepth),0);

            if (i > 0)
            {
                // Mark non-top levels as being a sub-level
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
            }

            if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
            }

            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            break;
        case D3DRTYPE_CUBETEXTURE:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_COMPLEX;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_CUBEMAP;
            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);

            //cubemaps are only DDI-level mipmaps if they're more than one level
            if (pCreateSurface->dwSCnt>6)
                pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_MIPMAP;

            // DX8 only supports creation of all faces
            {
                DWORD dwOrderedFaces[6] = {
                                           DDSCAPS2_CUBEMAP_POSITIVEX,
                                           DDSCAPS2_CUBEMAP_NEGATIVEX,
                                           DDSCAPS2_CUBEMAP_POSITIVEY,
                                           DDSCAPS2_CUBEMAP_NEGATIVEY,
                                           DDSCAPS2_CUBEMAP_POSITIVEZ,
                                           DDSCAPS2_CUBEMAP_NEGATIVEZ
                };

                int MipLevels;

                MipLevels = pCreateSurface->dwSCnt/6; //since all faces are always present in DX8

                DDASSERT(MipLevels>=1);

                //the first n (where n is mip depth) faces are +x, etc.
               pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= dwOrderedFaces[i/MipLevels];

                //every MipLevels'th surface is a top-level face,
                if (i % MipLevels)
                {
                    // Mark non-top levels as being a sub-level
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
                }

                if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
                }
            }

            break;
        case D3DRTYPE_IMAGESURFACE:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );
            // Image surfaces are marked as textures since they have the
            // greatest flexibility for formats. But they don't get
            // a CreateSurfaceEx handle since they are never passed to
            // a driver.
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_TEXTURE;
            break;

        case D3DRTYPE_COMMANDBUFFER:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            DDASSERT((pCreateSurface->dwUsage & D3DUSAGE_INTERNALBUFFER) == 0);
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_COMMANDBUFFER;
            pDDSurfaceGlobal[i].dwLinearSize  = pDDSurfaceGlobal[i].wWidth;
            break;
        case D3DRTYPE_VERTEXBUFFER:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
            if (!(pCreateSurface->dwUsage & D3DUSAGE_INTERNALBUFFER))
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_VERTEXBUFFER;
            }
            if (pDevice->DriverLevel >= 8)
            {
                if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
                }
                else
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTSTATIC;
                }
            }
            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            pDDSurfaceGlobal[i].dwLinearSize  = pDDSurfaceGlobal[i].wWidth;
            break;
        case D3DRTYPE_INDEXBUFFER:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_INDEXBUFFER;
            if (pDevice->DriverLevel >= 8)
            {
                if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
                }
                else
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTSTATIC;
                }
            }
            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            pDDSurfaceGlobal[i].dwLinearSize  = pDDSurfaceGlobal[i].wWidth;
            break;
        }

        if (pCreateSurface->dwUsage & D3DUSAGE_RENDERTARGET)
        {
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_3DDEVICE;
            if (pDDSurfaceMore[i].dwSurfaceHandle == 0)
            {
                pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            }
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_DEPTHSTENCIL)
        {
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_ZBUFFER;
        }
        if (pDevice->DriverLevel >= 8)
        {
            if (pCreateSurface->dwUsage & D3DUSAGE_LOADONCE)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_OPAQUE;
            }
            if (pCreateSurface->dwUsage & D3DUSAGE_WRITEONLY)
            {
                pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_WRITEONLY;
            }        
            if (!(pCreateSurface->dwUsage & D3DUSAGE_LOCK) &&
                !(pCreateSurface->dwUsage & D3DUSAGE_LOADONCE))
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_NOTUSERLOCKABLE;
            }
            if (pCreateSurface->dwUsage & D3DUSAGE_DISCARD)
            {
                DDASSERT(pCreateSurface->Type != D3DRTYPE_TEXTURE);
                DDASSERT(pCreateSurface->Type != D3DRTYPE_CUBETEXTURE);
                DDASSERT(pCreateSurface->Type != D3DRTYPE_VOLUMETEXTURE);
                DDASSERT(pCreateSurface->Type != D3DRTYPE_VOLUME);
                DDASSERT(pCreateSurface->Type != D3DRTYPE_VERTEXBUFFER);
                DDASSERT(pCreateSurface->Type != D3DRTYPE_INDEXBUFFER);

                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_DISCARDBACKBUFFER;
            }
            if (pCreateSurface->dwUsage & D3DUSAGE_POINTS)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_POINTS;
            }
            if (pCreateSurface->dwUsage & D3DUSAGE_RTPATCHES)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_RTPATCHES;
            }
            if (pCreateSurface->dwUsage & D3DUSAGE_NPATCHES)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_NPATCHES;
            }
        }
        else // Pre-DX8 driver
        {
            // We allow LOADONCE through only for textures
            if (pCreateSurface->Type == D3DRTYPE_TEXTURE || 
                pCreateSurface->Type == D3DRTYPE_CUBETEXTURE || 
                pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE)
            {
                if (pCreateSurface->dwUsage & D3DUSAGE_LOADONCE)
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_OPAQUE;
                }
            }
            // We allow WRITEONLY through only for VBs
            if (pCreateSurface->Type == D3DRTYPE_VERTEXBUFFER)
            {
                if (pCreateSurface->dwUsage & D3DUSAGE_WRITEONLY)
                {
                    pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_WRITEONLY;
                } 
            }
        }

        switch (pCreateSurface->Pool)
        {
        case D3DPOOL_LOCALVIDMEM:
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
            break;
        case D3DPOOL_NONLOCALVIDMEM:
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
            break;
        case D3DPOOL_SYSTEMMEM:
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
            break;
        case D3DPOOL_MANAGED:
            pDDSurfaceLocal[i].dwFlags |= DDRAWISURF_DRIVERMANAGED;
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_TEXTUREMANAGE;
            break;
        case D3DPOOL_DEFAULT:
            pCreateSurface->Pool = D3DPOOL_LOCALVIDMEM; 
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
            break;
        default:
            /* Unknown Pool?? */
            DDASSERT(FALSE);
            break;
        }
    }
}

/*****************************Private*Routine******************************\
* SelectAttachmentSurface
*
* Returns an index into the surface creation list that indicates which
* surface this surface should be attached to. For mipmap sublevels this is
* always the preceding surface. For cubemaps, each face attaches to the
* root face (element 0).
*
* History:
*  21-Mar-2000 -by- Jeff Noyle [jeffno]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "SelectAttachmentSurface"

UINT SelectAttachmentSurface(
    PD3D8_CREATESURFACEDATA pCreateSurface,
    UINT                    iThis)
{

    //We should never be called to find the attachment from the root face.
    DDASSERT( iThis > 0);

    if ((pCreateSurface->Type == D3DRTYPE_CUBETEXTURE) &&
        ((iThis % (pCreateSurface->dwSCnt/6)) == 0) //which means we're looking at a top-level face
        )
    {
        //... so we attach this face to the root
        return 0;
    }
    else
    {
        // nope its just a mip sublevel, so we attach to the previous
        return iThis-1;
    }
}


/*****************************Private*Routine******************************\
* CreateVidMemSurface
*
* History:
*  06-Dec-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "CreateVidMemSurface"


HRESULT
CreateVidMemSurface(
    PD3D8_CREATESURFACEDATA pCreateSurface,
    DD_SURFACE_LOCAL*       pDDSurfaceLocal,
    DD_SURFACE_GLOBAL*      pDDSurfaceGlobal,
    DD_SURFACE_MORE*        pDDSurfaceMore,
    HANDLE*                 phInSurface,
    HANDLE*                 phOutSurface,
    BOOL                    bIsLost
   )
{
    DDSURFACEDESC2          SurfaceDesc;
    DD_CREATESURFACEDATA    CreateData7;
    DWORD                   i;
    DWORD                   j;
    BOOL                    bRet;
    DDSURFHANDLE*           pSurf;
    DD_CANCREATESURFACEDATA CanCreateData;
    DEFERREDCREATE*         pDefCreate;

    if (DDSCAPS_EXECUTEBUFFER & pDDSurfaceLocal[0].ddsCaps.dwCaps)
    {
        if (!(DDDEVICE_SUPPORTD3DBUF & 
            ((PDDDEVICEHANDLE)pCreateSurface->hDD)->dwFlags)
           )
        {
            return  E_FAIL;
        }
    }
    // If the device is lost, we don't want to allocate vidmem or call the
    // kernel at this point (the surface will be released soon anyway).

    if (bIsLost)
    {
DeviceLost:
        DDASSERT(pCreateSurface->bReUse == FALSE);
        for (i = 0; i < pCreateSurface->dwSCnt; i++)
        {
            pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
            pDDSurfaceMore[i].dwSurfaceHandle = 0;

            // There is a chance that the app may call Lock at some point,
            // in which case we have to allocate a buffer that they can write
            // to.  Allocating the buffer now is a bit wasteful, but if we
            // allocate it at Lock time the allocation may fail and I'm
            // guessing that apps will handle create surface failures better
            // than they will Lock failures, so we will do the allocation now.

            pDDSurfaceGlobal[i].lPitch = pCreateSurface->pSList[i].cpWidth * 8;
            pDDSurfaceGlobal[i].dwLinearSize =
                pDDSurfaceGlobal[i].lPitch;

            if ((pCreateSurface->Type == D3DRTYPE_VOLUME) ||
                (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
            {
                pSurf->lSlicePitch = pDDSurfaceGlobal[i].lPitch *
                    pCreateSurface->pSList[i].cpHeight;

                pDDSurfaceGlobal[i].fpVidMem = (ULONG_PTR)
                    MemAlloc(pSurf->lSlicePitch *
                    pCreateSurface->pSList[i].cpDepth);
            }
            else
            {
                pDDSurfaceGlobal[i].fpVidMem = (ULONG_PTR)
                    MemAlloc(pDDSurfaceGlobal[i].lPitch *
                    pCreateSurface->pSList[i].cpHeight);
            }

            if (pDDSurfaceGlobal[i].fpVidMem == (ULONG_PTR) NULL)
            {
                for (j = 0; j < i; j++)
                {
                    MemFree((void*)pDDSurfaceGlobal[j].fpVidMem);
                }

                return E_OUTOFMEMORY;
            }
            pSurf->dwFlags |= DDSURF_SYSMEMALLOCATED;
        }

        // If the surface is driver managed, we save the creation info so that 
        // we can retry the creation at reset time
        if (pDDSurfaceLocal[0].dwFlags & DDRAWISURF_DRIVERMANAGED)
        {
            pDefCreate = (PDEFERREDCREATE)MemAlloc(sizeof(DEFERREDCREATE));
            if (pDefCreate == NULL)
            {
                // Cleanup stuff that we allocated above
                for (i = 0; i < pCreateSurface->dwSCnt; ++i)
                {
                    MemFree((void*)pDDSurfaceGlobal[i].fpVidMem);
                    pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
                    pSurf->dwFlags &= ~DDSURF_SYSMEMALLOCATED;
                }
                return E_OUTOFMEMORY;
            }

            // Copy
            pDefCreate->CreateData = *pCreateSurface;

            pDefCreate->CreateData.pSList = (LPDDSURFACEINFO)MemAlloc(sizeof(DDSURFACEINFO) * pCreateSurface->dwSCnt);
            if (pDefCreate->CreateData.pSList == NULL)
            {
                // Cleanup stuff that we allocated above
                MemFree(pDefCreate);
                for (i = 0; i < pCreateSurface->dwSCnt; ++i)
                {
                    MemFree((void*)pDDSurfaceGlobal[i].fpVidMem);
                    pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
                    pSurf->dwFlags &= ~DDSURF_SYSMEMALLOCATED;
                }
                return E_OUTOFMEMORY;
            }

            // Copy
            CopyMemory(pDefCreate->CreateData.pSList, pCreateSurface->pSList, sizeof(DDSURFACEINFO) * pCreateSurface->dwSCnt);

            // Linkup
            pDefCreate->pNext = ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDeferList;
            ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDeferList = pDefCreate;

            // We need to release the cookies allocated in InitSurfaceStructures
            // because this is not an actual create. When we do the actual create, we
            // will be reallocating the cookies.
            for (i = 0; i < pCreateSurface->dwSCnt; ++i)
            {
                pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
                DDASSERT(pSurf->dwCookie != 0);
                ReleaseDX7SurfaceHandle(pSurf->pDevice, pSurf->dwCookie);
                pSurf->dwCookie = 0;
            }

            // *************************MEMORY LEAK WARNING*********************** //
            // The DEFERREDCREATE and DDSURFACEINFO allocations above will
            // not be cleaned up immediately if for some reason DdCreateSurface 
            // (ie the caller of this function) fails after this function returns
            // success. As of 3/2001, DdCreateSurface has no code path that can
            // fail after we return ok below.
            // ******************************************************************* //
        }

        return S_OK;
    }

    // First setup the surface desc

    RtlZeroMemory(&SurfaceDesc, sizeof(SurfaceDesc));
    SurfaceDesc.dwSize = sizeof(SurfaceDesc);
    SurfaceDesc.ddsCaps.dwCaps = pDDSurfaceLocal[0].ddsCaps.dwCaps;
    SurfaceDesc.ddsCaps.dwCaps2 = pDDSurfaceMore[0].ddsCapsEx.dwCaps2;
    SurfaceDesc.ddsCaps.dwCaps3 = pDDSurfaceMore[0].ddsCapsEx.dwCaps3;
    SurfaceDesc.ddsCaps.dwCaps4 = pDDSurfaceMore[0].ddsCapsEx.dwCaps4;
    SurfaceDesc.ddpfPixelFormat = pDDSurfaceGlobal[0].ddpfSurface;
    if ((pCreateSurface->Type == D3DRTYPE_TEXTURE) ||
        (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
    {
        SurfaceDesc.dwMipMapCount = pCreateSurface->dwSCnt;
        if (SurfaceDesc.dwMipMapCount)
        {
            SurfaceDesc.dwFlags |= DDSD_MIPMAPCOUNT;
        }
    }
    else if (pCreateSurface->Type == D3DRTYPE_CUBETEXTURE)
    {
        if (pCreateSurface->dwSCnt > 6)
        {
            SurfaceDesc.dwMipMapCount = pCreateSurface->dwSCnt / 6;
            SurfaceDesc.dwFlags |= DDSD_MIPMAPCOUNT;
        }
    }
    else if (pCreateSurface->dwSCnt > 1)
    {
        SurfaceDesc.dwBackBufferCount = pCreateSurface->dwSCnt - 1;
        SurfaceDesc.dwFlags |= DDSD_BACKBUFFERCOUNT;
    }
    SurfaceDesc.dwHeight = pDDSurfaceGlobal[0].wHeight;
    SurfaceDesc.dwWidth = pDDSurfaceGlobal[0].wWidth;
    SurfaceDesc.dwFlags |= DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
    if (pDDSurfaceLocal[0].dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        SurfaceDesc.dwFlags |= DDSD_PIXELFORMAT;
    }
    if (pCreateSurface->Type == D3DRTYPE_VERTEXBUFFER)
    {
        SurfaceDesc.dwFVF = pCreateSurface->dwFVF;
        SurfaceDesc.dwFlags |= DDSD_FVF;
    }
    if (SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        SurfaceDesc.dwLinearSize = pCreateSurface->pSList[0].iPitch;
        SurfaceDesc.dwFlags |= DDSD_LINEARSIZE;
    }
    if (SurfaceDesc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME)
    {
        SurfaceDesc.dwDepth = pCreateSurface->pSList[0].cpDepth;
        SurfaceDesc.dwFlags |= DDSD_DEPTH;
    }

    if (SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_ZBUFFER)
    {
        // ATI Rage3 driver in Win2K still expects dwZbufferBitDepth
        // in the old place in DDSD, so put it there but probably not
        // set the bit in dwFlags as we don't advocate it.
        ((DDSURFACEDESC*)&SurfaceDesc)->dwZBufferBitDepth =
            SurfaceDesc.ddpfPixelFormat.dwZBufferBitDepth;
    }

    // We do not support texture stage in DX8
    DDASSERT((SurfaceDesc.dwFlags & DDSD_TEXTURESTAGE) == 0);
    DDASSERT(SurfaceDesc.dwTextureStage == 0);

    // Now call CanCreateSurface since this is where most drivers do the
    // majority of their caps checking.

    RtlZeroMemory(&CanCreateData, sizeof(CanCreateData));
    CanCreateData.lpDDSurfaceDesc = (DDSURFACEDESC*) &SurfaceDesc;

    if (!FormatCompatibleWithDisplayFormat(((PDDDEVICEHANDLE)pCreateSurface->hDD), pCreateSurface->Format))
    {
        CanCreateData.bIsDifferentPixelFormat = TRUE;
    }
    else
    {
        CanCreateData.bIsDifferentPixelFormat = FALSE;
    }

    if (SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        bRet = OsThunkDdCanCreateD3DBuffer(DDHANDLE(pCreateSurface->hDD),
                                    &CanCreateData);
    }
    else
    {
        bRet = OsThunkDdCanCreateSurface(DDHANDLE(pCreateSurface->hDD),
                                    &CanCreateData);
    }
    if ( bRet )
    {
        if (CanCreateData.ddRVal != S_OK)
        {
            if (CanCreateData.ddRVal == DDERR_SURFACELOST)
            {
                if (!pCreateSurface->bReUse)
                {
                    goto DeviceLost;
                }
            }
            return CanCreateData.ddRVal;
        }
    }
    /*
     * if the driver didn't handle it, then fail any requests to create a
     * surface that differs in format from the primary surface, except for
     * z buffer and alpha
     */

    else
    {
        // On Win2K, due to broken kernel, when the device is lost, the kernel
        // returns DDHAL_DRIVER_NOT_HANDLED and the return code is DDERR_GENERIC.
        // When we detect this, we check for device lost ourselves.
        if (CanCreateData.ddRVal == DDERR_GENERIC && 
            CheckForDeviceLost (pCreateSurface->hDD))
        {
            if (!pCreateSurface->bReUse)
            {
                goto DeviceLost;
            }
            return DDERR_SURFACELOST;
        }
        if (!FormatCompatibleWithDisplayFormat(((PDDDEVICEHANDLE)pCreateSurface->hDD), pCreateSurface->Format)
            && !(SurfaceDesc.ddsCaps.dwCaps & (DDSCAPS_ZBUFFER|DDSCAPS_ALPHA|DDSCAPS_EXECUTEBUFFER)) )
        {
	    return DDERR_INVALIDPIXELFORMAT;
	}
    }


    // Calculate the surface pitch.  The driver may override this, but if we
    // don't initialize it and the driver doesn't explicitly specify it, then
    // the kernel may fail the allocation.

    if (!(SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
    {
        for (i = 0; i < pCreateSurface->dwSCnt; i++)
        {
            if (SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
            {
                pDDSurfaceGlobal[i].lPitch = ((PDDDEVICEHANDLE)pCreateSurface->hDD)->DisplayPitch;
            }
            else if ((pDDSurfaceLocal[0].dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                     (pDDSurfaceGlobal[0].ddpfSurface.dwRGBBitCount > 0))
            {
                pDDSurfaceGlobal[i].lPitch =
                    (pDDSurfaceGlobal[0].ddpfSurface.dwRGBBitCount / 8) *
                    pDDSurfaceGlobal[i].wWidth;

                // Assume that they need to be 8 byte aligned.

                pDDSurfaceGlobal[i].lPitch += 7;
                pDDSurfaceGlobal[i].lPitch &= 0xfffffff8;
            }
        }
    }

    // If the surface requires attachments, we need to set that up before the
    // CreateSurface call.

    if (pCreateSurface->dwSCnt > 1)
    {
        // First, create all of the surface objects

        for (i = 0; i < pCreateSurface->dwSCnt; i++)
        {
            phInSurface[i] = OsThunkDdCreateSurfaceObject(DDHANDLE(pCreateSurface->hDD),
                NULL,
                &pDDSurfaceLocal[i],
                &pDDSurfaceMore[i],
                &pDDSurfaceGlobal[i],
                FALSE);
            if (phInSurface[i] == NULL)
            {
                for (j = 0; j < i; j++)
                {
                    OsThunkDdDeleteSurfaceObject(phInSurface[j]);
                }
                // Looks like we are lost or something. Check it out.
                if (CheckForDeviceLost (pCreateSurface->hDD))
                {
                    if (!pCreateSurface->bReUse)
                    {
                        goto DeviceLost;
                    }
                    return DDERR_SURFACELOST;
                }
                return E_FAIL;
            }
        }

        // Now attach them all

        for (i = 1; i < pCreateSurface->dwSCnt; i++)
        {
            bRet = OsThunkDdAttachSurface(phInSurface[SelectAttachmentSurface(pCreateSurface,i)],
                                        phInSurface[i]);

            // smac:  handle error condition
        }

        // If it's the primary surface chain, I also need to attach the back
        // to the front (to avoid potential compatibility issues).

        if (pDDSurfaceLocal[0].ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
        {
            bRet = OsThunkDdAttachSurface(phInSurface[pCreateSurface->dwSCnt - 1],
                                        phInSurface[0]);
        }
    }

    // Preset an error in case the kernel can't write status
    // back for some reason.

    CreateData7.ddRVal = E_FAIL;
    CreateData7.dwSCnt = pCreateSurface->dwSCnt;

    if (SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        bRet = OsThunkDdCreateD3DBuffer(DDHANDLE(pCreateSurface->hDD),
                           phInSurface,
                          (LPDDSURFACEDESC)&SurfaceDesc,
                          pDDSurfaceGlobal,
                          pDDSurfaceLocal,
                          pDDSurfaceMore,
                          (PDD_CREATESURFACEDATA) &CreateData7,
                          phOutSurface);
    }
    else
    {
        bRet = OsThunkDdCreateSurface(DDHANDLE(pCreateSurface->hDD),
                           phInSurface,
                          (LPDDSURFACEDESC)&SurfaceDesc,
                          pDDSurfaceGlobal,
                          pDDSurfaceLocal,
                          pDDSurfaceMore,
                          (PDD_CREATESURFACEDATA) &CreateData7,
                          phOutSurface);
    }

    if ( bRet && (CreateData7.ddRVal != S_OK))
    {
        if (pCreateSurface->dwSCnt > 1)
        {
            for (i = 0; i < pCreateSurface->dwSCnt; i++)
            {
                OsThunkDdDeleteSurfaceObject(phInSurface[i]);
            }
        }
        if (CreateData7.ddRVal == DDERR_SURFACELOST)
        {
            if (!pCreateSurface->bReUse)
            {
                goto DeviceLost;
            }
        }
        // Broken Win2K kernel fails with DDERR_OUTOFVIDEOMEMORY, so handle this case
        else if ((CreateData7.ddRVal == DDERR_OUTOFVIDEOMEMORY ||
                 CreateData7.ddRVal == DDERR_GENERIC) &&
                 CheckForDeviceLost (pCreateSurface->hDD))
        {
            if (!pCreateSurface->bReUse)
            {
                goto DeviceLost;
            }
            CreateData7.ddRVal = DDERR_SURFACELOST;
        }
        return CreateData7.ddRVal;
    }

    if (pDDSurfaceLocal[0].ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        pCreateSurface->Pool = D3DPOOL_NONLOCALVIDMEM;
        for (i = 0; i < pCreateSurface->dwSCnt; i++)
        {
            pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
            pSurf->Pool = D3DPOOL_NONLOCALVIDMEM;
        }
    }

    for (i = 0; i < pCreateSurface->dwSCnt; i++)
    {
        pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
        pSurf->hSurface = phOutSurface[i];
    }

    return CreateData7.ddRVal;
}

/*****************************Private*Routine******************************\
* CreateSysMemSurface
*
* History:
*  06-Dec-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "CreateSysMemSurface"

HRESULT
CreateSysMemSurface(
    PD3D8_CREATESURFACEDATA pCreateSurface,
    DD_SURFACE_LOCAL*       pDDSurfaceLocal,
    DD_SURFACE_GLOBAL*      pDDSurfaceGlobal,
    DD_SURFACE_MORE*        pDDSurfaceMore,
    BOOL                    bIsLost
   )
{
    DWORD           i;
    DWORD           j;
    HRESULT         hr;
    BOOL            bRet;
    DDSURFHANDLE*   pSurf;

    hr = S_OK;
    for (i = 0; i < pCreateSurface->dwSCnt; i++)
    {
        pDDSurfaceGlobal[i].fpVidMem = (ULONG_PTR)pCreateSurface->pSList[i].pbPixels;
        pDDSurfaceGlobal[i].lPitch = pCreateSurface->pSList[i].iPitch;
        if ((pCreateSurface->Type == D3DRTYPE_VOLUME) ||
            (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
        {
            pDDSurfaceGlobal[i].dwBlockSizeY = pCreateSurface->pSList[i].iSlicePitch;
        }

        // Hack for NT; they don't support FourCC codes
        if (pDDSurfaceGlobal[i].ddpfSurface.dwFlags == DDPF_FOURCC)
        {
            if (pCreateSurface->Format == D3DFMT_UYVY ||
                pCreateSurface->Format == D3DFMT_YUY2)
            {
                pDDSurfaceGlobal[i].ddpfSurface.dwRGBBitCount = 16;
                // lie about pitch
                pDDSurfaceGlobal[i].lPitch = 
                    ((pDDSurfaceGlobal[i].wWidth*2 + 7) & ~7);
            }
            else if (pCreateSurface->Format == D3DFMT_DXT1 ||
                     pCreateSurface->Format == D3DFMT_DXT2 ||
                     pCreateSurface->Format == D3DFMT_DXT3 ||
                     pCreateSurface->Format == D3DFMT_DXT4 ||
                     pCreateSurface->Format == D3DFMT_DXT5)
            {
                DWORD blksize;
                DWORD realwidth  = pDDSurfaceGlobal[i].wWidth;
                DWORD realheight = pDDSurfaceGlobal[i].wHeight;
                WORD dx, dy;

                if (pCreateSurface->Format == D3DFMT_DXT1)
                {
                    blksize = 8;
                }
                else
                {
                    blksize = 16;
                }

                // HACK STOLEN FROM DX7 DDHEL
                // <kd> used the same logic as dx7 to avoid compat pain

                // The NT bug won't let us create this surface unless we lie.
                // We have to make up a width, height, pitch, and pixel size
                // that GDI will accept as valid.
                dx = (WORD)((realwidth  + 3) >> 2);   // number of 4x4 blocks in a row
                dy = (WORD)((realheight + 3) >> 2);   // number of 4x4 blocks in a column

                pDDSurfaceGlobal[i].wHeight = dy;                    // lie about height
                pDDSurfaceGlobal[i].lPitch = dx*blksize;             // lie about pitch
                pDDSurfaceGlobal[i].wWidth = (WORD)pDDSurfaceGlobal[i].lPitch;   // lie about width
                pDDSurfaceGlobal[i].ddpfSurface.dwRGBBitCount = 8;   // lie about pixel size
            }
        }

        // The presence of a software driver can make a sysmem surface act
        // like a vidmem surface, so we need to explicitly say that it's in sysmem

        pDDSurfaceLocal[i].ddsCaps.dwCaps &=
            ~(DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
        pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

        pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
        pSurf->hSurface = OsThunkDdCreateSurfaceObject(DDHANDLE(pCreateSurface->hDD),
                NULL,
                &pDDSurfaceLocal[i],
                &pDDSurfaceMore[i],
                &pDDSurfaceGlobal[i],
                TRUE);

        if (pSurf->hSurface == NULL)
        {
            // Note that the main reason for this error is actually
            // out-of-memory; but it could also point at a bug
            // somewhere between the validation logic in kernel 
            // and the validation logic in our runtime,
            DPF_ERR("Kernel failed registration of sys-mem object; out of system-memory condition");
            hr = E_OUTOFMEMORY;
        }
    }

    // If we successfully created the handles, then we create any attachments
    // that we might require.

    if (SUCCEEDED(hr))
    {
        for (i = 1; i < pCreateSurface->dwSCnt; i++)
        {
            pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
            bRet = OsThunkDdAttachSurface(
                ((PDDSURFHANDLE)pCreateSurface->pSList[
                        SelectAttachmentSurface(pCreateSurface,i)
                        ].hKernelHandle)->hSurface,
                    pSurf->hSurface);

            // smac:  handle error condition
        }
    }

    // If we're still OK, then we should call CreateSurfaceEx

    if (SUCCEEDED(hr))
    {
        if (pDDSurfaceMore[0].dwSurfaceHandle != 0)
        {
            // If using a software driver, we need to call CreateSurfaceEx
            // in the software driver; otherwsie, we call the kernel

            if (!IS_SOFTWARE_DRIVER(pCreateSurface->hDD))
            {
                if (bIsLost)
                {
                    // We set defer on the top level so CreateSurfaceEx gets called on Reset
                    pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[0].hKernelHandle;
                    pSurf->dwFlags |= DDSURF_DEFERCREATEEX;
                    return hr;
                }            
                hr = OsThunkDdCreateSurfaceEx(
                        DDHANDLE(pCreateSurface->hDD),
                        ((PDDSURFHANDLE)pCreateSurface->pSList[0].hKernelHandle)->hSurface,
                        pDDSurfaceMore[0].dwSurfaceHandle);
                if (FAILED(hr))
                {
                    if (hr == DDERR_SURFACELOST ||
                        CheckForDeviceLost (pCreateSurface->hDD)) // Due to broken Win2K implementation
                    {
                        // We set defer on the top level so CreateSurfaceEx gets called on Reset
                        pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[0].hKernelHandle;
                        pSurf->dwFlags |= DDSURF_DEFERCREATEEX;
                        return S_OK;
                    }
                }
            }
        }
    }

    return hr;
}

BOOL IsWhistler()
{
    OSVERSIONINFOEX osvi;
    DWORDLONG       dwlConditionMask = 0;

    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osvi.dwMajorVersion = 5;
    osvi.dwMinorVersion = 1;

    VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, 
        VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, 
        VER_GREATER_EQUAL );

    return VerifyVersionInfo(&osvi, 
                             VER_MAJORVERSION|VER_MINORVERSION,
                             dwlConditionMask);
}
// ResetUniqueness will cause runtime to think there is a device lost,
// have to do that only for whistler when fscreen app alt-tab away to
// desktop mode that is the same as the fullscreen, whistler 
void ResetUniqueness( HANDLE hDD )
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    if (pDeviceHandle->bIsWhistler)
        pDeviceHandle->DisplayUniqueness = 0;
}
/*****************************Private*Routine******************************\
* DdCreateSurface
*
* History:
*  2-Nov-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "DdCreateSurface"

HRESULT
APIENTRY
DdCreateSurface(
    PD3D8_CREATESURFACEDATA pCreateSurface
   )
{
    ULONG                       i;
    ULONG                       j;
    DDSURFACEDESC2              SurfaceDesc;
    HANDLE                      hInSurface;
    HANDLE                      hOutSurface;
    DD_SURFACE_LOCAL            SurfaceLocal;
    DD_SURFACE_GLOBAL           SurfaceGlobal;
    DD_SURFACE_MORE             SurfaceMore;
    DD_SURFACE_LOCAL*           pDDSurfaceLocal = NULL;
    DD_SURFACE_GLOBAL*          pDDSurfaceGlobal = NULL;
    DD_SURFACE_MORE*            pDDSurfaceMore = NULL;
    HANDLE*                     phInSurface = NULL;
    HANDLE*                     phOutSurface = NULL;
    HRESULT                     hr;
    BOOL                        bSysMemCreate = FALSE;
    PDDSURFHANDLE               pSurf;
    BOOL                        bIsLost = FALSE;
    DWORD                       dwNumToCreate;
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;

    dwNumToCreate = pCreateSurface->dwSCnt;

    // If the device is lost, we don't want to actually allocate vidmem, but
    // we still need to support sysmem surfaces.  We also have to fake up
    // vidmem allocations since we only want to expose lost devices in a
    // couple of places.

    if (CheckForDeviceLost (pCreateSurface->hDD))
    {
        bIsLost = TRUE;
        if (pCreateSurface->bReUse)
        {
            return DDERR_SURFACELOST;
        }
    }

    // For every surface, convert to the kernel's surface data structure,
    // call the kernel, then convert back:

    hr = S_OK;

    // If we are only creating one, no need to allocate gobs of memory; otherwise, do it
    if (dwNumToCreate == 1)
    {
        RtlZeroMemory(&SurfaceLocal, sizeof(SurfaceLocal));
        RtlZeroMemory(&SurfaceGlobal, sizeof(SurfaceGlobal));
        RtlZeroMemory(&SurfaceMore, sizeof(SurfaceMore));
        hInSurface = NULL;
        hOutSurface = NULL;
        pDDSurfaceLocal  = &SurfaceLocal;
        pDDSurfaceGlobal  = &SurfaceGlobal;
        pDDSurfaceMore  = &SurfaceMore;
        phInSurface = &hInSurface;
        phOutSurface = &hOutSurface;
    }
    else
    {
        pDDSurfaceLocal = (DD_SURFACE_LOCAL*) MemAlloc(
            sizeof(DD_SURFACE_LOCAL) * dwNumToCreate);

        pDDSurfaceGlobal = (DD_SURFACE_GLOBAL*) MemAlloc(
            sizeof(DD_SURFACE_GLOBAL) * dwNumToCreate);

        pDDSurfaceMore = (DD_SURFACE_MORE*) MemAlloc(
            sizeof(DD_SURFACE_MORE) * dwNumToCreate);

        phInSurface = (HANDLE*) MemAlloc(sizeof(HANDLE) * dwNumToCreate);

        phOutSurface = (HANDLE*) MemAlloc(
            sizeof(HANDLE) * dwNumToCreate);

        if ((pDDSurfaceLocal == NULL) ||
            (pDDSurfaceGlobal == NULL) ||
            (pDDSurfaceMore == NULL) ||
            (phInSurface == NULL) ||
            (phOutSurface == NULL))
        {
            hr = E_OUTOFMEMORY;
            goto CleanupCreate;
        }
    }

    InitSurfaceStructures (pCreateSurface,
        pDDSurfaceLocal,
        pDDSurfaceGlobal,
        pDDSurfaceMore);

    // Allocate the internal surface structures for each surface in the chain
    // and initialize it if we are not reusing the surface
    if (!pCreateSurface->bReUse)
    {
        for (i = 0; i < dwNumToCreate; i++)
        {
            pSurf = (PDDSURFHANDLE) MemAlloc(sizeof(DDSURFHANDLE));
            if (pSurf == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto CleanupCreate;
            }
            pSurf->Pool = pCreateSurface->Pool;
            pSurf->Format = pCreateSurface->Format;
            pSurf->Type = pCreateSurface->Type;

            // This is sort of a hack to save space.  For regular surfaces, we need
            // to know the height to handle the lost case, but for volume textures,
            // we really need to know the depth.  To save space, we will re-use the
            // same variable.

            if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
            {
                pSurf->dwHeight = pCreateSurface->pSList[i].cpDepth;
            }
            else
            {
                pSurf->dwHeight = pCreateSurface->pSList[i].cpHeight;
            }
            pCreateSurface->pSList[i].hKernelHandle = (HANDLE) pSurf;
            pSurf->pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;

            // You may find it wasteful that we assign handles to each mipmap level,
            // even though we only call CreateSurfaceEx on the topmost level.  We need
            // to do this, however, since DX7 worked this way and it also call
            // CreateSurfaceEx fpVidMem = 0 at release time on each level of the mipmap.

            pSurf->dwCookie = pDDSurfaceMore[i].dwSurfaceHandle;

            // Now figure out if this is a sysmem surface, a software driver
            // surface, or a HAL surface.

            if (pSurf->Pool != D3DPOOL_SYSTEMMEM)
            {
                // If they are running w/ a software driver (refrast, RGB HEL, etc.),
                // we will not allow any surfaces to be created in video memory except
                // for the primary flipping chain. And also for surfaces marked
                // USAGE_OFFSCREENPLAIN (which are used for the cursors)

                if (IS_SOFTWARE_DRIVER(pCreateSurface->hDD) &&
                    !(pCreateSurface->dwUsage & D3DUSAGE_PRIMARYSURFACE) &&
                    !(pCreateSurface->dwUsage & D3DUSAGE_OFFSCREENPLAIN))
                {
                    pSurf->dwFlags |= DDSURF_SOFTWARE;
                }
                else
                {
                    pSurf->dwFlags |= DDSURF_HAL;
                }
            }

            if (pCreateSurface->bTreatAsVidMem == TRUE)
            {
                // For objects that should be treated as non-persistent
                // i.e. Reset fails unless these are all freed; we
                // set a flag here and check it in DoVidMemSurfacesExist()
                pSurf->dwFlags |= DDSURF_TREATASVIDMEM;
            }

            // If a software driver will see this surface (either because it
            // will create it, or because it's a sysmem surface that will need
            // to handle CreateEx), we need to build a heavyweight surface structure.

            if (IS_SOFTWARE_DRIVER(pCreateSurface->hDD))
            {
                if (!(pSurf->dwFlags & DDSURF_HAL) &&
                    (pSurf->dwCookie != 0))
                {
                    pSurf->pLcl = SwDDIBuildHeavyWeightSurface(
                                    pSurf->pDevice->pDD,
                                    pCreateSurface,
                                    &pDDSurfaceLocal[i],
                                    &pDDSurfaceGlobal[i],
                                    &pDDSurfaceMore[i],
                                    i);
                    if (pSurf->pLcl == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto CleanupCreate;
                    }
                }
            }
        }
    }
    else // fill in the new cookie
    {
        for (i = 0; i < dwNumToCreate; i++)
        {
            pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
            DDASSERT(pSurf->dwCookie == 0);
            pSurf->dwCookie = pDDSurfaceMore[i].dwSurfaceHandle;
        }
    }

    // Now create the actual surfaces

    pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[0].hKernelHandle;
    if (pSurf->Pool == D3DPOOL_SYSTEMMEM)
    {
        hr = CreateSysMemSurface(
                pCreateSurface,
                pDDSurfaceLocal,
                pDDSurfaceGlobal,
                pDDSurfaceMore,
                bIsLost);
    }
    else if (pSurf->dwFlags & DDSURF_SOFTWARE)
    {
        // Call the software rasterizer if it can handle it.
        // This allows them to allocate the memory, etc., but
        // we still need to call the kernel to create an object

        hr = SwDDICreateSurface(pCreateSurface,
                                pDDSurfaceLocal,
                                pDDSurfaceGlobal,
                                pDDSurfaceMore);

        // We only need to get a kernel-handle
        // for back-buffers
        
        if (SUCCEEDED(hr) && (pCreateSurface->dwUsage & D3DUSAGE_BACKBUFFER))
        {
            hr = CreateSysMemSurface(pCreateSurface,
                                     pDDSurfaceLocal,
                                     pDDSurfaceGlobal,
                                     pDDSurfaceMore,
                                     bIsLost);

            if (FAILED(hr))
            {
                // we need to mark all the surfaces
                // as completely built so that
                // we free them correctly
                for (i = 0; i < dwNumToCreate; i++)
                {
                    pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;

                    pSurf->dwFlags |= DDSURF_CREATECOMPLETE;
                }
            }
        }
    }
    else
    {
        hr = CreateVidMemSurface (pCreateSurface,
                                  pDDSurfaceLocal,
                                  pDDSurfaceGlobal,
                                  pDDSurfaceMore,
                                  phInSurface,
                                  phOutSurface,
                                  bIsLost);
    }
    if (FAILED(hr))
    {
        goto CleanupCreate;
    }

    // Everything worked so far, so now we just need to finish up.

    for(i = 0; i < dwNumToCreate; i++)
    {
        pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;

        pSurf->dwFlags |= DDSURF_CREATECOMPLETE;
        if (!(pSurf->dwFlags & DDSURF_HAL))
        {
            // It's a sysmem surface - either explicit or a software driver
            pSurf->fpVidMem = (ULONG_PTR)pCreateSurface->pSList[i].pbPixels;
            pSurf->dwLinearSize = pCreateSurface->pSList[i].iPitch;
            pSurf->lPitch = pCreateSurface->pSList[i].iPitch;
            pSurf->lSlicePitch = pCreateSurface->pSList[i].iSlicePitch;
        }
        else
        {
            pSurf->fpVidMem = (ULONG_PTR)pDDSurfaceGlobal[i].fpVidMem;
            pSurf->dwLinearSize = pDDSurfaceGlobal[i].dwLinearSize;
            pCreateSurface->pSList[i].iPitch = pSurf->dwLinearSize;
            pSurf->lPitch = pDDSurfaceGlobal[i].lPitch;
            if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
            {
                pSurf->lSlicePitch = pDDSurfaceGlobal[i].dwBlockSizeY;
            }
            else
            {
                pSurf->lSlicePitch = 0;
            }
        }

        // If it's a software driver, we may need to attach surfaces

        if ((0==(pSurf->dwFlags & DDSURF_HAL)) &&
            (IS_SOFTWARE_DRIVER(pCreateSurface->hDD)) &&
            (i > 0))
        {
            // Cubes are created strangely... Each face is attached to the root,
            // and each mipsublevel is attached to its face

            DDASSERT(pCreateSurface->Type != D3DRTYPE_CUBETEXTURE || pCreateSurface->dwSCnt>=6);

            SwDDIAttachSurfaces (
                    ((PDDSURFHANDLE)pCreateSurface->pSList[
                            SelectAttachmentSurface(pCreateSurface,i)
                        ].hKernelHandle)->pLcl,
                    pSurf->pLcl);
        }
    }

    // If it's a software driver, we need to call CreateSurfaceEx after
    // all of the attachments are made.

    if ((IS_SOFTWARE_DRIVER(pCreateSurface->hDD)) &&
        (pSurf->dwCookie != 0))
    {
        SwDDICreateSurfaceEx (pDevice->pDD,
            ((PDDSURFHANDLE)pCreateSurface->pSList[0].hKernelHandle)->pLcl);
    }

    // Now save the surfaces in a linked list
    // If re-using, then we are already on the list so don't do anything
    if (!pCreateSurface->bReUse)
    {
        for (i = 0; i < dwNumToCreate; i++)
        {
            ((PDDSURFHANDLE)(pCreateSurface->pSList[i].hKernelHandle))->pNext =
                pDevice->pSurfList;
            ((PDDSURFHANDLE)(pCreateSurface->pSList[i].hKernelHandle))->pPrevious =
                NULL;
            if (pDevice->pSurfList != NULL)
            {
                pDevice->pSurfList->pPrevious = (PDDSURFHANDLE)(pCreateSurface->pSList[i].hKernelHandle);
            }
            pDevice->pSurfList = (PDDSURFHANDLE)(pCreateSurface->pSList[i].hKernelHandle);
        }
    }

    CleanupCreate:
    if (1 != dwNumToCreate)
    {
        if (pDDSurfaceLocal != NULL)
        {
            MemFree(pDDSurfaceLocal);
        }
        if (pDDSurfaceGlobal != NULL)
        {
            MemFree(pDDSurfaceGlobal);
        }
        if (pDDSurfaceMore != NULL)
        {
            MemFree(pDDSurfaceMore);
        }
        if (phInSurface != NULL)
        {
            MemFree(phInSurface);
        }
        if (phOutSurface != NULL)
        {
            MemFree(phOutSurface);
        }
    }

    if (FAILED(hr))
    {
        // Clean everything up

        for (i = 0; i < dwNumToCreate; i++)
        {
            pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
            if (pSurf != NULL)
            {
                FreeSurfaceObject(pSurf);
                // If we are reusing, then we need to keep the pSurf around
                // for a retry
                if (!pCreateSurface->bReUse)
                {
                    MemFree(pSurf);
                }
            }
            pCreateSurface->pSList[i].hKernelHandle   = NULL;
        }
    }

    return(MapLegacyResult(hr));
}


/******************************Public*Routine******************************\
*
* D3dContextCreate
*
* History:
*  Mon Jun 03 14:18:29 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3dContextCreate"

DWORD WINAPI 
D3dContextCreate(PD3D8_CONTEXTCREATEDATA pCreateContext)
{
    PD3DCONTEXTHANDLE   pContext = NULL;
    BOOL                bIsLost = FALSE;
    DWORD               dwRet = DDHAL_DRIVER_HANDLED;

    // Don't call the driver if the device is lost

    pCreateContext->ddrval = S_OK;
    if (!CheckForDeviceLost (pCreateContext->hDD))
    {
        dwRet = OsThunkD3dContextCreate(DDHANDLE(pCreateContext->hDD),
            GetSurfHandle(pCreateContext->hSurface),
            GetSurfHandle(pCreateContext->hDDSZ),
            (D3DNTHAL_CONTEXTCREATEI *)pCreateContext);
        if (pCreateContext->ddrval == DDERR_SURFACELOST)
        {
            bIsLost = TRUE;
            pCreateContext->ddrval = S_OK;
            CheckForDeviceLost (pCreateContext->hDD);
        }
    }
    else
    {
        bIsLost = TRUE;
    }

    // We need to abstract the handle for a couple of reasons:
    // 1.  The context handle can change due to lost devices, and
    //     we'd prefer to abstract this from D3D.
    // 2.  We need to know the device that this handle belongs to
    //     so we can always check for device lost.

    if (pCreateContext->ddrval == S_OK)
    {
        pContext = (PD3DCONTEXTHANDLE) MemAlloc(sizeof(D3DCONTEXTHANDLE));
        if (pContext == NULL)
        {
            // smac: clean up

            pCreateContext->dwhContext = (ULONG_PTR) NULL;
            pCreateContext->ddrval = E_OUTOFMEMORY;
        }
        else
        {
            pContext->pDevice = pCreateContext->hDD;
            if (bIsLost)
            {
                pContext->dwFlags = D3DCONTEXT_DEFERCREATE;
                pContext->dwPID = pCreateContext->dwPID;
                pContext->hDeferHandle = (HANDLE)pCreateContext->dwhContext;
                pContext->pSurface = pCreateContext->hSurface;
                pContext->pDDSZ = pCreateContext->hDDSZ;
            }
            else
            {
                pContext->dwhContext = (HANDLE) pCreateContext->dwhContext;
            }
            pCreateContext->dwhContext = (ULONG_PTR) pContext;
        }
    }

    pCreateContext->ddrval = MapLegacyResult(pCreateContext->ddrval);

    return dwRet;
}

/******************************Public*Routine******************************\
*
* D3dContextDestroy
*
* History:
*  Mon Jun 03 14:18:29 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3dContextDestroy"

DWORD WINAPI 
D3dContextDestroy(PD3D8_CONTEXTDESTROYDATA pDestroyContext)
{
    PD3DCONTEXTHANDLE pContext = (PD3DCONTEXTHANDLE) pDestroyContext->dwhContext;

    CheckForDeviceLost (pContext->pDevice);

    pDestroyContext->ddrval = S_OK;
    if (pContext->dwhContext)
    {
        pDestroyContext->dwhContext = (LONG_PTR) pContext->dwhContext;
        OsThunkD3dContextDestroy((LPD3DNTHAL_CONTEXTDESTROYDATA) pDestroyContext);
    }

    pContext->pDevice->pContext = NULL;
    MemFree(pContext);

    pDestroyContext->ddrval = MapLegacyResult(pDestroyContext->ddrval);

    return DDHAL_DRIVER_HANDLED;
}

/******************************Public*Routine******************************\
*
* D3dContextDestroyAll
*
* History:
*  Mon Jun 03 14:18:29 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3dContextDestroyAll"

DWORD WINAPI 
D3dContextDestroyAll(PD3D8_CONTEXTDESTROYALLDATA pDestroyAllContext)
{
    OsThunkD3dContextDestroyAll((LPD3DNTHAL_CONTEXTDESTROYALLDATA) pDestroyAllContext);

    // smac:  Need to add code here to free all contexts for each device
    // the PID has?

    return DDHAL_DRIVER_HANDLED;
}

/******************************Public*Routine******************************\
*
* DdGetDriverState
*
* History:
*  Mon Jun 03 14:18:29 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdGetDriverState"

DWORD WINAPI DdGetDriverState(PD3D8_GETDRIVERSTATEDATA pGetDriverState)
{
    PD3DCONTEXTHANDLE pContext = (PD3DCONTEXTHANDLE) pGetDriverState->dwhContext;
    DWORD       dwRet = DDHAL_DRIVER_HANDLED;
    ULONG_PTR   pTemp;

    pGetDriverState->ddRVal = E_FAIL;
    if (!CheckForDeviceLost (pContext->pDevice))
    {
        pTemp = pGetDriverState->dwhContext;
        pGetDriverState->dwhContext = (ULONG_PTR) pContext->dwhContext;
        dwRet = OsThunkDdGetDriverState ((DD_GETDRIVERSTATEDATA*)pGetDriverState);
        pGetDriverState->dwhContext = pTemp;
        if (pGetDriverState->ddRVal == DDERR_SURFACELOST)
        {
            pGetDriverState->ddRVal = E_FAIL;
        }
    }

    pGetDriverState->ddRVal = MapLegacyResult(pGetDriverState->ddRVal);

    return dwRet;
}

/******************************Public*Routine******************************\
*
* D3dValidateTextureStageState
*
* History:
*  Mon Jun 03 14:18:29 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3dValidateTextureStageState"

DWORD WINAPI D3dValidateTextureStageState(PD3D8_VALIDATETEXTURESTAGESTATEDATA pValidate)
{
    PD3DCONTEXTHANDLE pContext = (PD3DCONTEXTHANDLE) pValidate->dwhContext;
    DWORD       dwRet = DDHAL_DRIVER_HANDLED;
    ULONG_PTR   pTemp;

    pValidate->ddrval = D3DERR_DEVICELOST;
    pValidate->dwNumPasses = 0;
    if (!CheckForDeviceLost (pContext->pDevice))
    {
        pTemp = pValidate->dwhContext;
        pValidate->dwhContext = (ULONG_PTR) pContext->dwhContext;
        dwRet = OsThunkD3dValidateTextureStageState((D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA*)pValidate);
        pValidate->dwhContext = pTemp;
        if (pValidate->ddrval == DDERR_SURFACELOST)
        {
            pValidate->ddrval = D3DERR_DEVICELOST;
        }
    }

    return dwRet;
}

/******************************Public*Routine******************************\
*
* D3dDrawPrimitives2
*
* History:
*  Mon Jun 17 13:27:05 1996     -by-    Anantha Kancherla [anankan]
*   Created
*
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "D3dDrawPrimitives2"

DWORD WINAPI D3dDrawPrimitives2(PD3D8_DRAWPRIMITIVES2DATA pdp2data)
{
    PD3DCONTEXTHANDLE pContext = (PD3DCONTEXTHANDLE) pdp2data->dwhContext;
    DWORD       dwRet = DDHAL_DRIVER_HANDLED;
    ULONG_PTR   pTemp;

    if (CheckForDeviceLost (pContext->pDevice))
    {
        goto DeviceLost;
    }

    pTemp = pdp2data->dwhContext;
    pdp2data->dwhContext = (ULONG_PTR) pContext->dwhContext;

    if (pdp2data->dwFlags & D3DHALDP2_USERMEMVERTICES)
    {
        dwRet = OsThunkD3dDrawPrimitives2 (
            GetSurfHandle(pdp2data->hDDCommands),
            NULL, // No DDraw surface, pass NULL handle
            (LPD3DNTHAL_DRAWPRIMITIVES2DATA)pdp2data,
            &((PDDSURFHANDLE)(pdp2data->hDDCommands))->fpVidMem,
            &((PDDSURFHANDLE)(pdp2data->hDDCommands))->dwLinearSize,
            NULL,
            NULL
           );
        if (dwRet == DDHAL_DRIVER_HANDLED)
        {
            if (pdp2data->ddrval == DDERR_SURFACELOST)
            {
                pdp2data->dwhContext = pTemp;
                goto DeviceLost;
            }
            else if ((pdp2data->ddrval != S_OK) && 
                (DDERR_WASSTILLDRAWING != pdp2data->ddrval) )
            {
                pContext->pDevice->dwFlags |= DDDEVICE_DP2ERROR;
            }
        }
        pdp2data->fpVidMem_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->fpVidMem;
        pdp2data->dwLinearSize_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->dwLinearSize;
        pdp2data->fpVidMem_VB = 0;
        pdp2data->dwLinearSize_VB = 0;
    }
    else
    {
        dwRet = OsThunkD3dDrawPrimitives2 (
            GetSurfHandle(pdp2data->hDDCommands),
            GetSurfHandle(pdp2data->hDDVertex),
            (LPD3DNTHAL_DRAWPRIMITIVES2DATA)pdp2data,
            &((PDDSURFHANDLE)(pdp2data->hDDCommands))->fpVidMem,
            &((PDDSURFHANDLE)(pdp2data->hDDCommands))->dwLinearSize,
            &((PDDSURFHANDLE)(pdp2data->hDDVertex))->fpVidMem,
            &((PDDSURFHANDLE)(pdp2data->hDDVertex))->dwLinearSize
            );
        if (dwRet == DDHAL_DRIVER_HANDLED)
        {
            if (pdp2data->ddrval == DDERR_SURFACELOST)
            {
                pdp2data->dwhContext = pTemp;
                goto DeviceLost;
            }
            else if ((pdp2data->ddrval != S_OK) &&
                (DDERR_WASSTILLDRAWING != pdp2data->ddrval) )
            {
                pContext->pDevice->dwFlags |= DDDEVICE_DP2ERROR;
            }
        }

        pdp2data->fpVidMem_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->fpVidMem;
        pdp2data->dwLinearSize_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->dwLinearSize;
        pdp2data->fpVidMem_VB = ((PDDSURFHANDLE)(pdp2data->hDDVertex))->fpVidMem;
        pdp2data->dwLinearSize_VB = ((PDDSURFHANDLE)(pdp2data->hDDVertex))->dwLinearSize;
    }
    pdp2data->dwhContext = pTemp;

    return dwRet;

DeviceLost:
    pdp2data->ddrval = S_OK;
    pdp2data->dwErrorOffset = 0;

    // Need to set these values to their original
    // state so that the FE doesn't get confused.
    pdp2data->fpVidMem_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->fpVidMem;
    pdp2data->dwLinearSize_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->dwLinearSize;
    if (pdp2data->dwFlags & D3DHALDP2_USERMEMVERTICES)
    {
        pdp2data->fpVidMem_VB       = 0;
        pdp2data->dwLinearSize_VB   = 0;
    }
    else
    {
        pdp2data->fpVidMem_VB = ((PDDSURFHANDLE)(pdp2data->hDDVertex))->fpVidMem;
        pdp2data->dwLinearSize_VB = ((PDDSURFHANDLE)(pdp2data->hDDVertex))->dwLinearSize;
    }

    // Don't map the legacy result because the runtime needs to handle the
    // WASSTILLDRAWING case.  The runtime will do this mapping for us.

    return DDHAL_DRIVER_HANDLED;
}

LPRGNDATA GetClipList(HWND hWnd)
{
    int APIENTRY GetRandomRgn(HDC hdc, HRGN hrgn, int iNum);
    int rc;
    HRESULT         ddrval = S_OK;
    DWORD           dwSize;
    DWORD           cbRealSize;
    HDC             hdc;
    HRGN            hrgn;
    LPRGNDATA       lpClipList;

    hdc = GetDC(hWnd);
    if (hdc == NULL)
    {
        DPF_ERR("GetDC failed. Unable to accelerate Present.");
        return NULL;
    }

    // Create the appropriate Region object
    hrgn = CreateRectRgn(0, 0, 0, 0);
    if (hrgn == NULL)
    {
        DPF_ERR("CreateRectRgn failed. Unable to accelerate Present.");
        ReleaseDC(hWnd, hdc);
        return NULL;
    }

    // Set the Region to the DC
    if (-1 == GetRandomRgn(hdc, hrgn, 4))
    {
        DPF_ERR("GetRandomRgn failed. Unable to accelerate Present.");
        ReleaseDC(hWnd, hdc);
        DeleteObject(hrgn);
        return NULL;
    }

    // Get the size
    dwSize = GetRegionData(hrgn, 0, NULL);

    if (0 == dwSize)
    {
        // Release allocations
        ReleaseDC(hWnd, hdc);
        DeleteObject(hrgn);
        return NULL;
    }
    do
    {
        lpClipList = (LPRGNDATA)MemAlloc(dwSize);
        if (NULL == lpClipList)
        {
            // Release allocations
            ReleaseDC(hWnd, hdc);
            DeleteObject(hrgn);
            return NULL;
        }
        // Get the window's region's REGIONDATA
        cbRealSize = GetRegionData(hrgn, dwSize, lpClipList);
        if (cbRealSize > dwSize)
        {
            MemFree(lpClipList);
            dwSize =  cbRealSize;   // make it bigger and try again
        }
        else
        {
            break;  // succeeded
        }
    }while(TRUE);

    ReleaseDC(hWnd, hdc);
    DeleteObject(hrgn);

    if (cbRealSize == 0)
    {
        DPF_ERR("GetRegionData failed. Unable to accelerate Present.");
        MemFree(lpClipList);
        return NULL;
    }
    return  lpClipList;
}

/*
 * ClipRgnToRect
 */
void ClipRgnToRect(LPRECT prect, LPRGNDATA prd)
{
    RECT        rect;
    int         i;
    int         n;
    LPRECTL     prectlD;
    LPRECTL     prectlS;


    if (prect == NULL || prd == NULL)
    {
        return;
    }

    // If the bounding rect of the region is exactly equal to
    // or inside of the Restricting rect then we know
    // we don't have to do any more work.
    //
    // In the common case, the rcBound will be the client
    // area of a window and so will the restricting rect.
    if (prect->top    <= prd->rdh.rcBound.top &&
        prect->bottom >= prd->rdh.rcBound.bottom &&
        prect->left   <= prd->rdh.rcBound.left &&
        prect->right  >= prd->rdh.rcBound.right)
    {
        return;
    }

    // If the bounding rect doesn't equal the prect then
    // we might have to do some clipping.
    rect = *prect;

    prectlD = (LPRECTL) prd->Buffer;
    prectlS = (LPRECTL) prd->Buffer;
    n = (int)prd->rdh.nCount;

    for (i=0; i<n; i++)
    {
        prectlD->left  = max(prectlS->left, rect.left);
        prectlD->right = min(prectlS->right, rect.right);
        prectlD->top   = max(prectlS->top, rect.top);
        prectlD->bottom= min(prectlS->bottom, rect.bottom);

        prectlS++;

        if ((prectlD->bottom - prectlD->top <= 0) ||
            (prectlD->right - prectlD->left <= 0))
        {
            prd->rdh.nCount--;  // dont count empty rect.
        }
        else
        {
            prectlD++;
        }
    }

    return;

} /* ClipRgnToRect */

/*
 * XformRect
 *
 * Transform a clipped rect in destination space to the corresponding clipped
 * rect in src space. So, if we're stretching from src to dest, this yields
 * the unstretched clipping rect in src space.
 *
 *  PARAMETERS:
 *      prcSrc - unclipped rect in the source space
 *      prcDest - unclipped rect in the destination space
 *      prcClippedDest - the rect we want to transform
 *      prcClippedSrc - the resulting rect in the source space.  return value.
 *      scale_x - 16.16 fixed point src/dest width ratio
 *      scale_y  - 16.16 fixed point src/dest height ratio
 *
 *  DESCRIPTION:
 *      Given an rect in source space and a rect in destination space, and a
 *      clipped rectangle in the destination space (prcClippedDest), return
 *      the rectangle in the source space (prcClippedSrc) that maps to
 *      prcClippedDest.
 *
 *      Use 16.16 fixed point math for more accuracy. (Shift left, do math,
 *      shift back (w/ round))
 *
 *  RETURNS:
 *      S_OK always.  prcClippedSrc is the mapped rectangle.
 *
 */
HRESULT XformRect(RECT * prcSrc, RECT * prcDest, RECT * prcClippedDest,
                  RECT * prcClippedSrc, DWORD scale_x, DWORD scale_y)
{
    /*
     * This first calculation is done with fixed point arithmetic (16.16).
     * The result is converted to (32.0) below. Scale back into source space
     */
    prcClippedSrc->left = (prcClippedDest->left - prcDest->left) * scale_x;
    prcClippedSrc->right = (prcClippedDest->right - prcDest->left) * scale_x;
    prcClippedSrc->top = (prcClippedDest->top - prcDest->top) * scale_y;
    prcClippedSrc->bottom = (prcClippedDest->bottom - prcDest->top) * scale_y;

    /*
     * now round (adding 0x8000 rounds) and translate (offset by the
     * src offset)
     */
    prcClippedSrc->left = (((DWORD)prcClippedSrc->left + 0x8000) >> 16) + prcSrc->left;
    prcClippedSrc->right = (((DWORD)prcClippedSrc->right + 0x8000) >> 16) + prcSrc->left;
    prcClippedSrc->top = (((DWORD)prcClippedSrc->top + 0x8000) >> 16) + prcSrc->top;
    prcClippedSrc->bottom = (((DWORD)prcClippedSrc->bottom + 0x8000) >> 16) + prcSrc->top;

    /*
     * Check for zero-sized source rect dimensions and bump if necessary
     */
    if (prcClippedSrc->left == prcClippedSrc->right)
    {
        if (prcClippedSrc->right == prcSrc->right)
        {
            (prcClippedSrc->left)--;
        }
        else
        {
            (prcClippedSrc->right)++;
        }

    }
    if (prcClippedSrc->top == prcClippedSrc->bottom)
    {
        if (prcClippedSrc->bottom == prcSrc->bottom)
        {
            (prcClippedSrc->top)--;
        }
        else
        {
            (prcClippedSrc->bottom)++;
        }

    }

    return S_OK;

} /* XformRect */

/*****************************Private*Routine******************************\
* DdBlt
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
* 31-Mar-2000 -by- Kan Qiu [kanqiu]
* Made it handle clipping case
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdBlt"
#define SIZE_OF_A_CLIPLIST(lpRgn) \
        (sizeof(RGNDATAHEADER)+sizeof(RECTL)*lpRgn->rdh.nCount)

DWORD
WINAPI
DdBlt(
    PD3D8_BLTDATA pBlt
   )
{
    DDHAL_BLTDATA   bd;
    DWORD       ret = DDHAL_DRIVER_NOTHANDLED;
    PDDSURFHANDLE   pDstSurf = (PDDSURFHANDLE) pBlt->hDestSurface;
    PDDSURFHANDLE   pSrcSurf = (PDDSURFHANDLE) pBlt->hSrcSurface;
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pBlt->hDD;
    DWORD   bltcaps;
    if (CheckForDeviceLost (pBlt->hDD))
    {
        // Some blts should fail, others should succeed:
        // persistant -> non persitant : OK
        // persistant -> persitant : FAIL
        // non persistant -> persistant : FAIL
        // non persistant -> non persistant : OK

        if (pDstSurf && ((pDstSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
            (pDstSurf->Pool == D3DPOOL_NONLOCALVIDMEM))
           )
        {
            pBlt->ddRVal = S_OK;
        }
        else
        {
            pBlt->ddRVal = D3DERR_DEVICELOST;
        }
        return DDHAL_DRIVER_HANDLED;
    }
    ZeroMemory(&bd, sizeof bd);
    bd.ddRVal      = E_FAIL;  // always assume error

    // Just a colorfill?
#ifdef DEBUG
    if ((pSrcSurf == NULL) && pDstSurf)
    {
        do
        {
            bd.dwFlags     = pBlt->dwFlags & DDBLT_VALID;
            bd.IsClipped   = FALSE; // NT Kernel cannot handle it
            bd.bltFX       = pBlt->bltFX;
            bd.rDest       = pBlt->rDest;

            ret = OsThunkDdBlt(GetSurfHandle(pBlt->hDestSurface),
                       0,
                       (PDD_BLTDATA) &bd);
        
            if (DDHAL_DRIVER_NOTHANDLED == ret)
            {
                DPF_ERR("Driver failed color-fill blt. SWAPEFFECT_DISCARD not being enforced.");
            }
        } while (bd.ddRVal == DDERR_WASSTILLDRAWING);
 
        return S_OK;
    }
#endif 

    // Are we going to send this blt to the driver?
    if (!pDstSurf)
    {
        // NULL destination ? we are running SW driver w/o ddraw support
        // use GDI for blting
        goto gdiblt;                    
    }
    else if (IS_SOFTWARE_DRIVER_SURFACE(pSrcSurf))
    {
        if (!(pDevice->DDCaps & DDCAPS_CANBLTSYSMEM))
            goto gdiblt;            
        bltcaps = pDevice->SVBCaps;
    }
    else
    {
        bltcaps = pDevice->DDCaps;
    }
    if (!(bltcaps & DDCAPS_BLT))
        goto gdiblt;            
    
    //it is assumed that the format for a presented back buffer is OK and has
    //been validated by higher layers of the runtime. (e.g. if the back
    //buffer has alpha, or in the future is very different from front buffer format)
    if ((pDstSurf->Format == pSrcSurf->Format) ||
        (pBlt->dwFlags & DDBLT_WINDOWCLIP) ) //which means this is a presentation blt
    {
        //Yes, we're going to the driver...
        bd.rDest       = pBlt->rDest;
        bd.rSrc        = pBlt->rSrc;
        bd.dwFlags     = pBlt->dwFlags & DDBLT_VALID;
        bd.dwROPFlags  = pBlt->dwROPFlags;
        bd.IsClipped   = FALSE; // NT Kernel cannot handle it
        bd.bltFX       = pBlt->bltFX;

        // This is for Window Redirection support
        // (available on post-Windows 2000)
        // On Windows 2000, bd.Blt is ignored by win32k.sys
        if (pBlt->dwFlags & DDBLT_WINDOWCLIP)
        {
           bd.Blt      = (VOID*)(pBlt->hWnd);
        }

        // Mask DX8 flags from the OS
        if (pBlt->dwFlags & DDBLT_DX8ORHIGHER)
        {
            bd.dwFlags &= ~(DDBLT_WINDOWCLIP | DDBLT_COPYVSYNC | DDBLT_DX8ORHIGHER);
        }

        DPF(10,"pBlt->rDest %08lx %08lx %08lx %08lx",
            pBlt->rDest.top, pBlt->rDest.bottom,
            pBlt->rDest.left, pBlt->rDest.right);
        if ((pBlt->hWnd) && (DDBLT_WINDOWCLIP & pBlt->dwFlags))
        {
            RECTL   rOrigSrc=pBlt->rSrc;   // unclipped src rect
            LONG    SrcWidth = rOrigSrc.right - rOrigSrc.left;
            LONG    SrcHeight = rOrigSrc.bottom - rOrigSrc.top;
            RECT    rOrigDest;
            do
            {
                LPRGNDATA   prd;
                LPRECT      prect;
                DWORD       cnt;
                if (GetClientRect(pBlt->hWnd, &rOrigDest))
                {
                    POINT   pOrigDest;
                    if (rOrigDest.right > pBlt->rDest.right)
                        rOrigDest.right = pBlt->rDest.right;
                    if (rOrigDest.bottom > pBlt->rDest.bottom)
                        rOrigDest.bottom = pBlt->rDest.bottom;
                    if (0 < pBlt->rDest.left)
                        rOrigDest.left = pBlt->rDest.left;
                    if (0 < pBlt->rDest.top)
                        rOrigDest.top = pBlt->rDest.top;
                    if ((rOrigDest.right <= rOrigDest.left) ||
                        (rOrigDest.bottom <= rOrigDest.top)
                       )
                    {
                        pBlt->ddRVal = S_OK;
                        return DDHAL_DRIVER_HANDLED;
                    }
                        
                    pOrigDest.x = - pDevice->rcMonitor.left;
                    pOrigDest.y = - pDevice->rcMonitor.top;
                    if (!ClientToScreen(pBlt->hWnd, &pOrigDest))
                        DPF_ERR("ClientToScreen Failed on pOrigDest?");
                    if (!OffsetRect(&rOrigDest, pOrigDest.x, pOrigDest.y ))
                        DPF_ERR("OffsetRect Failed on rOrigDest?");
                    if (rOrigDest.bottom <= 0 || rOrigDest.right <= 0 ||
                        (rOrigDest.top + pDevice->rcMonitor.top >= pDevice->rcMonitor.bottom) ||
                        (rOrigDest.left + pDevice->rcMonitor.left >= pDevice->rcMonitor.right))
                    {
                        // client is completely outside device space
                        // means cross device blt is needed
                        goto gdiblt;
                    }
                }
                else
                {
                    DPF_ERR("GetClientRect Failed ?");
                    goto gdiblt;
                }
                if (   ( NULL == pDevice->pClipList ) 
                    || ( NULL == pDevice->pOrigClipList )
                    || ( pDevice->hLastWnd != pBlt->hWnd )
                    || (DDERR_VISRGNCHANGED == bd.ddRVal))
                {
                    DWORD   dwClipListSize;
                    if ( NULL != pDevice->pClipList )
                    {
                        MemFree(pDevice->pClipList);
                        pDevice->pClipList = NULL;
                    }    
                    if ( NULL != pDevice->pOrigClipList )
                    {
                        MemFree(pDevice->pOrigClipList);
                        pDevice->pOrigClipList = NULL;
                    }    
                    prd = GetClipList(pBlt->hWnd);
                    if (NULL == prd)
                        goto gdiblt;
                
                    prect=(LPRECT) &prd->Buffer[0];
                    for (cnt=0; cnt<prd->rdh.nCount; cnt++)
                    {
                        if ((prect[cnt].top < pDevice->rcMonitor.top) ||
                            (prect[cnt].left < pDevice->rcMonitor.left) ||
                            (prect[cnt].bottom > pDevice->rcMonitor.bottom) ||
                            (prect[cnt].right > pDevice->rcMonitor.right)
                          )
                        {
                            // do GDI blt if any rect is outside
                            MemFree (prd);
                            goto gdiblt;
                        }
                        if (!OffsetRect( &prect[cnt], - pDevice->rcMonitor.left, 
                            - pDevice->rcMonitor.top ))
                            DPF_ERR("OffsetRect Failed on prect[cnt]?");
                    }
                    dwClipListSize = SIZE_OF_A_CLIPLIST(prd);
                    pDevice->pOrigClipList = (LPRGNDATA)MemAlloc(dwClipListSize);
                    if (NULL != pDevice->pOrigClipList)
                    {
                        memcpy(pDevice->pOrigClipList, prd, dwClipListSize);
                        pDevice->hLastWnd = pBlt->hWnd;
                    }                
                }
                else
                {                    
                    prd = pDevice->pClipList;
                    memcpy(prd, pDevice->pOrigClipList,
                        SIZE_OF_A_CLIPLIST(pDevice->pOrigClipList));
                }
                DDASSERT( (0 == pDevice->pClipList) || ( prd == pDevice->pClipList) );
                DDASSERT( NULL != prd );

                // Clip the region to the rect before we go further
                ClipRgnToRect(&rOrigDest, prd );

                // Process each visible sub-rect separately
                if (prd->rdh.nCount > 0)
                {
                    int         x_offset;
                    int         y_offset;
                    DWORD       scale_x;
                    DWORD       scale_y;
                    BOOL        stretch_blt;
                    pDevice->pClipList = prd;

                    // precalculate a couple of variables
                    if ((rOrigDest.bottom - rOrigDest.top == SrcHeight) &&
                        (rOrigDest.right - rOrigDest.left == SrcWidth))
                    {
                        x_offset = rOrigSrc.left - rOrigDest.left;
                        y_offset = rOrigSrc.top - rOrigDest.top;
                        stretch_blt = FALSE;
                    }
                    else
                    {
                        if (!(bltcaps & DDCAPS_BLTSTRETCH))
                            goto gdiblt;
                        // scale_x and scale_y are fixed point variables scaled
                        // 16.16 (16 integer bits and 16 fractional bits)
                        scale_x = (SrcWidth << 16) /
                            (rOrigDest.right - rOrigDest.left);
                        scale_y = (SrcHeight << 16) /
                            (rOrigDest.bottom - rOrigDest.top);
                        stretch_blt = TRUE;
                    }

                    if (DDBLT_COPYVSYNC & pBlt->dwFlags)
                    {
                        DD_GETSCANLINEDATA   ScanData;
                        DWORD                msStartTime = GetTickCount();
                        DWORD                msCurrentTime;
                        DWORD                threshold=pBlt->threshold;

                        // Compute how many milliseconds there
                        // are per refresh. We round down.
                        msCurrentTime = msStartTime;                

                        // If the previous blt was just a few ms ago
                        // then we can make up the difference by yielding
                        if ((msCurrentTime - pBlt->msLastPresent) < threshold )
                        {
                            Sleep(threshold + pBlt->msLastPresent - msCurrentTime);
                            msCurrentTime = pBlt->msLastPresent + threshold;
                        }

                        threshold = ((PDDSURFHANDLE)pBlt->hDestSurface)->dwHeight/2;
                        while (DDHAL_DRIVER_HANDLED == 
                            OsThunkDdGetScanLine(DDHANDLE(pBlt->hDD),&ScanData))
                        {
                            if (DD_OK != ScanData.ddRVal)
                                break;

                            if ((LONG)ScanData.dwScanLine >= rOrigDest.bottom)
                                break;
                        
                            if ((LONG)(ScanData.dwScanLine + threshold/3) < rOrigDest.top)
                                break;

                            // just yield 1 ms instead of doing lengthy calculation which
                            // does not get me better result
                            if ((LONG)(ScanData.dwScanLine + threshold) < rOrigDest.bottom)
                            {
                                Sleep(1);
                            }
                            // If we've been spinning here for 30ms
                            // then blt anyway; probably something
                            // running in the background taking
                            // up CPU cycles
                            msCurrentTime = GetTickCount();
                            if ((msCurrentTime - msStartTime) > 30)
                            {
                                break;
                            }
                        }

                        // Remember the time of last blt
                        pBlt->msLastPresent = msCurrentTime;
                    }
                    //traverse the visible rect list and send each piece to
                    //the driver to blit
                    prect=(LPRECT) &prd->Buffer[0];

                    for (cnt=0;cnt<prd->rdh.nCount;cnt++)
                    {

                        // find out where on the src rect we need to get
                        // the data from.

                        bd.rDest.left = prect[cnt].left;
                        bd.rDest.right = prect[cnt].right;
                        bd.rDest.top = prect[cnt].top;
                        bd.rDest.bottom = prect[cnt].bottom;
                        if (!stretch_blt)
                        {
                            // no stretch
                            // one-to-one mapping from source to destination
                            bd.rSrc.left = bd.rDest.left + x_offset;
                            bd.rSrc.right = bd.rDest.right + x_offset;
                            bd.rSrc.top = bd.rDest.top + y_offset;
                            bd.rSrc.bottom = bd.rDest.bottom + y_offset;
                        }
                        else
                        {
                            // stretching
                            // linear mapping from source to destination
                            // calculate the source rect which transforms to the
                            // dest rect
                            XformRect((RECT *)&(rOrigSrc), &rOrigDest,
                                (RECT *)&(bd.rDest), (RECT *)&(bd.rSrc),
                                scale_x, scale_y);
                        }

                        // If mirror Blt, we must fix up source rect here!
                        if (bd.dwFlags & DDBLT_DDFX)
                        {
                            int temp;

                            if (bd.bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT)
                            {
                                temp = bd.rSrc.left;
                                bd.rSrc.left = rOrigSrc.left +
                                    rOrigSrc.right - bd.rSrc.right;
                                bd.rSrc.right = rOrigSrc.left +
                                    rOrigSrc.right - temp;
                            }

                            if (bd.bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN)
                            {
                                temp = bd.rSrc.top;
                                bd.rSrc.top = rOrigSrc.top +
                                    rOrigSrc.bottom - bd.rSrc.bottom;
                                bd.rSrc.bottom = rOrigSrc.top +
                                    rOrigSrc.bottom - temp;
                            }
                        }

                        do
                        {
                            bd.ddRVal = E_FAIL;  // always assume error

                            if (bd.dwFlags & DDBLT_PRESENTATION)
                            {
                                if (cnt == prd->rdh.nCount-1)
                                {
                                    bd.dwFlags |= DDBLT_LAST_PRESENTATION;
                                }
                            }

                            ret = OsThunkDdBlt(GetSurfHandle(pBlt->hDestSurface),
                                       GetSurfHandle(pBlt->hSrcSurface),
                                       (PDD_BLTDATA) &bd);
                            if (DDHAL_DRIVER_NOTHANDLED == ret)
                            {
                                bd.ddRVal = E_FAIL;  // make it out of loop
                                break;
                            }
                            if (bd.ddRVal == DDERR_SURFACELOST)
                            {
                                bd.ddRVal = S_OK;
                                break;
                            }

                            /*
                             * NOTE: If clipping has introduced more than
                             * one rectangle we behave as if DDBLT_WAIT
                             * was specified on all rectangles after the
                             * first. This is necessary as the first
                             * rectangle will probably cause the accelerator
                             * to be busy. Hence, the attempt to blit the
                             * second rectangle will fail with
                             * DDERR_WASSTILLDRAWING. If we pass this to
                             * the application (rather than busy waiting)
                             * the application is likely to retry the blit
                             * (which will fail on the second rectangle again)
                             * and we have an application sitting in an
                             * infinite loop).
                             */
                        } while(  (DDERR_WASSTILLDRAWING == bd.ddRVal) &&
                                  ( (DDBLT_WAIT & pBlt->dwFlags) ||
                                    (1 < prd->rdh.nCount)
                                  )
                               );
                        if (FAILED(bd.ddRVal))
                            break;
                    }
                }
                else
                {
                    MemFree (prd);
                    pDevice->pClipList = NULL;
                    bd.ddRVal = S_OK;
                    ret = DDHAL_DRIVER_HANDLED;
                    break;  // all clipped, no need to blt!
                }
                if (DDERR_VISRGNCHANGED == bd.ddRVal)
                {
                    OsThunkDdResetVisrgn(GetSurfHandle(pBlt->hDestSurface),(HWND)0);
                    pDevice->hLastWnd = NULL;   // zero cached info for DdBlt
                }
            } while (DDERR_VISRGNCHANGED == bd.ddRVal);
        }
        else
        {
            DDASSERT( 0 == (bd.dwFlags & DDBLT_PRESENTATION));
            if ((bd.rDest.right - bd.rDest.left != bd.rSrc.right - bd.rSrc.left || 
                 bd.rDest.bottom - bd.rDest.top != bd.rSrc.bottom - bd.rSrc.top)
                 && !(bltcaps & DDCAPS_BLTSTRETCH)
               )
                goto gdiblt;

            do
            {
                bd.ddRVal = E_FAIL;  // always assume error
                ret = OsThunkDdBlt(GetSurfHandle(pBlt->hDestSurface),
                           GetSurfHandle(pBlt->hSrcSurface),
                           (PDD_BLTDATA) &bd);
                if (DDHAL_DRIVER_NOTHANDLED == ret)
                {
                    bd.ddRVal = E_FAIL;  // make it out of loop
                    break;
                }
                if (bd.ddRVal == DDERR_SURFACELOST)
                {
                    bd.ddRVal = S_OK;
                }
                if (DDERR_VISRGNCHANGED == bd.ddRVal)
                {
                    OsThunkDdResetVisrgn(GetSurfHandle(pBlt->hDestSurface),(HWND)0);
                    pDevice->hLastWnd = NULL;   // zero cached info for DdBlt
                }
            } while ( (DDERR_VISRGNCHANGED == bd.ddRVal) ||
                      ( (DDERR_WASSTILLDRAWING == bd.ddRVal) &&
                        (DDBLT_WAIT & pBlt->dwFlags)
                      )
                    );
        }
    }

gdiblt:
    if (FAILED(bd.ddRVal))
    {
        // !!! Just use GetDC on the DirectDraw surface for now, though this is
        // probably way too slow on drivers which do not support derived
        // surfaces. DirectDraw Blt support should be added soon.
        HDC hDCTarget;
        BOOL    bGetDCfromWnd = (pBlt->hWnd) && 
                    ((DDBLT_WINDOWCLIP & pBlt->dwFlags) || !pBlt->hDestSurface);
        if (bGetDCfromWnd)
            hDCTarget = GetDC(pBlt->hWnd);
        else
            hDCTarget = D3D8GetDC(pBlt->hDestSurface, NULL);
        if (hDCTarget != NULL)
        {
            HDC hDCSource = D3D8GetDC(pBlt->hSrcSurface, NULL);
            if (hDCSource != NULL)
            {
                LONG DestWidth=pBlt->rDest.right - pBlt->rDest.left;
                LONG DestHeight= pBlt->rDest.bottom - pBlt->rDest.top;
                LONG SrcWidth= pBlt->rSrc.right - pBlt->rSrc.left;
                LONG SrcHeight= pBlt->rSrc.bottom - pBlt->rSrc.top;
                if (DestWidth == SrcWidth && DestHeight == SrcHeight)
                {
                    if (BitBlt(
                        hDCTarget,
                        pBlt->rDest.left,
                        pBlt->rDest.top,
                        DestWidth,
                        DestHeight,
                        hDCSource,
                        pBlt->rSrc.left,
                        pBlt->rSrc.top,
                        SRCCOPY))
                    {
                        bd.ddRVal = S_OK;
                        ret = DDHAL_DRIVER_HANDLED;
                    }
                }
                else
                {
                    // COLORONCOLOR is not the default in NT
                    int saved = SetStretchBltMode(hDCTarget,COLORONCOLOR);
                    if (StretchBlt(
                        hDCTarget,
                        pBlt->rDest.left,
                        pBlt->rDest.top,
                        DestWidth,
                        DestHeight,
                        hDCSource,
                        pBlt->rSrc.left,
                        pBlt->rSrc.top,
                        SrcWidth,
                        SrcHeight,
                        SRCCOPY))
                    {
                        bd.ddRVal = S_OK;
                        ret = DDHAL_DRIVER_HANDLED;
                    }
                    // restore to previous mode
                    if (saved)
                        SetStretchBltMode(hDCTarget,saved);
                }
                D3D8ReleaseDC(pBlt->hSrcSurface, hDCSource);
            }
            if (bGetDCfromWnd)
                ReleaseDC(pBlt->hWnd, hDCTarget);
            else
                D3D8ReleaseDC(pBlt->hDestSurface, hDCTarget);
        }        
    }

    pBlt->ddRVal = MapLegacyResult(bd.ddRVal);

    // We only want to report DP2 errors  during the present call because
    // checking for it everywhere is too hard.
    if ((pBlt->ddRVal == DD_OK) &&
        (pDevice->dwFlags & DDDEVICE_DP2ERROR) &&
        (pBlt->dwFlags & DDBLT_WINDOWCLIP))
    {
        pDevice->dwFlags &= ~DDDEVICE_DP2ERROR;

        // We use a special error here to mean that the blt succeeded
        // but that that some DP2 failed since the last present
        pBlt->ddRVal = D3DERR_DEFERRED_DP2ERROR;
    }

    return ret;
}

/*****************************Private*Routine******************************\
* DdFlip
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdFlip"

DWORD
APIENTRY
DdFlip(
    PD3D8_FLIPDATA pFlip
   )
{
    HANDLE          hSurfTargLeft=NULL;
    HANDLE          hSurfCurrLeft=NULL;
    DDHAL_FLIPDATA  FlipData;
    DWORD           dwRet;

    if (CheckForDeviceLost (pFlip->hDD))
    {
        pFlip->ddRVal = S_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    FlipData.dwFlags = (pFlip->dwFlags  & ~DDFLIP_WAIT);
    FlipData.ddRVal = DDERR_GENERIC;
    if (pFlip->dwFlags & DDFLIP_STEREO)
    {
        hSurfTargLeft = GetSurfHandle(pFlip->hSurfTargLeft);
        hSurfCurrLeft = GetSurfHandle(pFlip->hSurfCurrLeft);
    }
    do
    {
        dwRet = OsThunkDdFlip(GetSurfHandle(pFlip->hSurfCurr),
                       GetSurfHandle(pFlip->hSurfTarg),
                       hSurfCurrLeft,
                       hSurfTargLeft,
                       (PDD_FLIPDATA) &FlipData);
        if (FlipData.ddRVal == DDERR_SURFACELOST)
        {
            FlipData.ddRVal = S_OK;
        }
    }while (DDERR_WASSTILLDRAWING == FlipData.ddRVal &&
        (DDFLIP_WAIT & pFlip->dwFlags));
    pFlip->ddRVal = MapLegacyResult(FlipData.ddRVal);

    // We only want to report DP2 errors  during the present call because
    // checking for it everywhere is too hard.
    if ((pFlip->ddRVal == DD_OK) &&
        (((DDDEVICEHANDLE*)pFlip->hDD)->dwFlags & DDDEVICE_DP2ERROR))
    {
        ((DDDEVICEHANDLE*)pFlip->hDD)->dwFlags &= ~DDDEVICE_DP2ERROR;

        // We use a special error here to mean that the flip succeeded
        // but that that some DP2 failed since the last present
        pFlip->ddRVal = D3DERR_DEFERRED_DP2ERROR;
    }

    return dwRet;
}

/*****************************Private*Routine******************************\
* DdLock
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdLock"

HRESULT
APIENTRY
DdLock(
    PD3D8_LOCKDATA pLock
   )
{
    DD_LOCKDATA     LockData;
    PDDSURFHANDLE   pSurf;
    BOOL            bAdjustSlice = FALSE;

    pSurf = (PDDSURFHANDLE) pLock->hSurface;

    // If the device is lost, we need to fake up a buffer for
    // the app to write to.  We still allow software drivers
    // handle the Lock call, however. Further, we also allow
    // driver managed surfaces to go through.

    if (CheckForDeviceLost (pLock->hDD) &&
        !IS_SOFTWARE_DRIVER_SURFACE(pSurf) &&
        pSurf->Pool != D3DPOOL_MANAGED)
    {
        goto DeviceLost;
    }

    // We do make an exception for fake deferred creates
    // of driver managed surfaces. The driver doesn't know
    // about these deferred surfaces, so we don't call it.
    // ASSUMPTIONS: even if DDSURF_SYSMEMALLOCATED can be
    // set below, we expect it to be never set below for
    // **driver managed surfaces**. For these surfaces, we
    // assume that it will be set only in 
    // CreateVidMemSurface. This assumption is true as of
    // 3/2001.

    if ((pSurf->dwFlags & DDSURF_SYSMEMALLOCATED) != 0)
    {
        DDASSERT(pSurf->fpVidMem != (ULONG_PTR)NULL);
        goto DeviceLost;
    }

    // Mask off new flags
    LockData.dwFlags  = pLock->dwFlags;
    LockData.dwFlags &= (D3DLOCK_READONLY         |
                         D3DLOCK_DISCARD          |   
                         D3DLOCK_NOOVERWRITE      |
                         D3DLOCK_NOSYSLOCK);       
    // Always set lock_wait
    LockData.dwFlags |= DDLOCK_WAIT;
    // Also set equivalent DDLOCK flag for NO_DIRTY_UPDATE
    // if the driver understands it
    if ((pLock->dwFlags & D3DLOCK_NO_DIRTY_UPDATE) != 0)
    {
        LockData.dwFlags |= DDLOCK_NODIRTYUPDATE;
    }

    if(pLock->bHasRange)
    {
        LockData.bHasRect = TRUE;
        LockData.rArea.left = 0;
        LockData.rArea.right = 0;
        LockData.rArea.top = pLock->range.Offset;
        LockData.rArea.bottom = pLock->range.Offset + pLock->range.Size;
    }
    else
    {
        LockData.bHasRect = pLock->bHasRect;
        LockData.rArea = pLock->rArea;
    }

    if (pLock->bHasBox)
    {
        LockData.bHasRect = TRUE;
        LockData.rArea.left = pLock->box.Left;
        LockData.rArea.right = pLock->box.Right;
        LockData.rArea.top = pLock->box.Top;
        LockData.rArea.bottom = pLock->box.Bottom;

        // We cannot change the kernel for an OS before whistler, so we will
        // not pass the front/back to the driver.  For ref and for newer OSes,
        // we will stick the front/back into the high word of left/right

        if (IS_SOFTWARE_DRIVER_SURFACE(pSurf) ||
            ((((PDDDEVICEHANDLE)pLock->hDD)->bIsWhistler) &&
             (((PDDDEVICEHANDLE)pLock->hDD)->dwFlags & DDDEVICE_SUPPORTSUBVOLUMELOCK)))
        {
            LockData.dwFlags |= DDLOCK_HASVOLUMETEXTUREBOXRECT;
            LockData.rArea.left |= (pLock->box.Front << 16);
            LockData.rArea.right |= (pLock->box.Back << 16);
        }
        else
        {
            bAdjustSlice = TRUE;
        }
    }

    LockData.ddRVal = DDERR_WASSTILLDRAWING;

    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        // This is a software driver, so we need to treat
        // it specially

        SwDDILock (pLock->hDD, pSurf, &LockData);
    }
    else
    {
        while ((LockData.ddRVal == DDERR_VISRGNCHANGED) ||
            (LockData.ddRVal == DDERR_WASSTILLDRAWING))
        {
            if ((pSurf->Type == D3DRTYPE_VERTEXBUFFER) ||
                (pSurf->Type == D3DRTYPE_COMMANDBUFFER)||
                (pSurf->Type == D3DRTYPE_INDEXBUFFER))
            {
                OsThunkDdLockD3D(pSurf->hSurface,
                                 &LockData);
            }
            else
            {
                OsThunkDdLock(pSurf->hSurface,
                                &LockData,
                                NULL);
            }

            if (LockData.ddRVal == DDERR_VISRGNCHANGED)
            {
                if (pLock->dwFlags & DDLOCK_FAILONVISRGNCHANGED)
                {
                    break;
                }
                else
                {
                    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pLock->hDD;
                    OsThunkDdResetVisrgn(pSurf->hSurface, (HWND)0);
                    pDevice->hLastWnd = NULL;   // zero cached info for DdBlt
                }
            }

            // In the past we would require DDLOCK_WAIT to
            // decide if we would spin or exit now we always wait
        }
        if (LockData.ddRVal == DDERR_SURFACELOST)
        {
            CheckForDeviceLost(pLock->hDD);
            goto DeviceLost;
        }
    }

    if (LockData.ddRVal == S_OK)
    {
        pLock->lpSurfData = LockData.lpSurfData;
        pLock->lPitch = pSurf->lPitch;

        if ((pSurf->Type == D3DRTYPE_VOLUME) ||
            (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
        {
            pLock->lSlicePitch = pSurf->lSlicePitch;

            if (bAdjustSlice)
            {
                ((BYTE*)pLock->lpSurfData) += (pLock->lSlicePitch * 
                                                pLock->box.Front);
            }
        }
        pSurf->LockRefCnt++;
    }

    return MapLegacyResult(LockData.ddRVal);

DeviceLost:
    // At the time the device is lost, fpVidMem is set to NULL
    // for all vidmem surfaces.  Therefore, if it is non-NULL
    // we are safe to use what we already have; otherwise, we
    // have to allocate our own.

    if (pSurf->fpVidMem == (ULONG_PTR) NULL)
    {
        if ((pSurf->Type == D3DRTYPE_VOLUME) ||
            (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
        {
            // For volume textures, dwHeight really contains the depth
            pSurf->fpVidMem = (ULONG_PTR) MemAlloc(pSurf->lSlicePitch * pSurf->dwHeight);
        }
        else
        {
            pSurf->fpVidMem = (ULONG_PTR) MemAlloc(pSurf->lPitch * pSurf->dwHeight);
        }
        if (pSurf->fpVidMem == (ULONG_PTR) NULL)
        {
            pLock->lpSurfData = (void*)pSurf->fpVidMem;
            return E_FAIL;
        }
        pSurf->dwFlags |= DDSURF_SYSMEMALLOCATED;
    }
    pLock->lpSurfData = (void*)pSurf->fpVidMem;
    pLock->lPitch = pSurf->lPitch;

    if ((pSurf->Type == D3DRTYPE_VOLUME) ||
        (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
    {
        pLock->lSlicePitch = pSurf->lSlicePitch;
    }
    pSurf->LockRefCnt++;

    return S_OK;
}

/*****************************Private*Routine******************************\
* DdUnlock
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdUnlock"

HRESULT
APIENTRY
DdUnlock(
    PD3D8_UNLOCKDATA pUnlock
   )
{
    DD_UNLOCKDATA   UnlockData;
    PDDSURFHANDLE   pSurf;

    pSurf = (PDDSURFHANDLE) pUnlock->hSurface;

    if (pSurf->LockRefCnt > 0)
    {
        pSurf->LockRefCnt--;
    }
    if (CheckForDeviceLost (pUnlock->hDD) &&
        !IS_SOFTWARE_DRIVER_SURFACE(pSurf) &&
        pSurf->Pool != D3DPOOL_MANAGED)
    {
        return S_OK;
    }
    if ((pSurf->dwFlags & DDSURF_SYSMEMALLOCATED) != 0)
    {
        DDASSERT(pSurf->fpVidMem != (ULONG_PTR)NULL);
        return S_OK;
    }

    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        // This is a software driver, so we need to treat
        // it specially

        SwDDIUnlock (pUnlock->hDD, pSurf, &UnlockData);
    }
    else
    {
        if ((GetSurfType(pUnlock->hSurface) == D3DRTYPE_VERTEXBUFFER) ||
            (GetSurfType(pUnlock->hSurface) == D3DRTYPE_COMMANDBUFFER) ||
            (GetSurfType(pUnlock->hSurface) == D3DRTYPE_INDEXBUFFER))
        {
            OsThunkDdUnlockD3D(GetSurfHandle(pUnlock->hSurface),
                             &UnlockData);
        }
        else
        {
            OsThunkDdUnlock(GetSurfHandle(pUnlock->hSurface),
                          &UnlockData);
        }
        if (UnlockData.ddRVal == DDERR_SURFACELOST)
        {
            UnlockData.ddRVal = S_OK;
        }
    }
    return MapLegacyResult(UnlockData.ddRVal);
}

/*****************************Private*Routine******************************\
* DdGetBltStatus
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdGetBltStatus"

DWORD
APIENTRY
DdGetBltStatus(
    PD3D8_GETBLTSTATUSDATA pGetBltStatus
   )
{
    DDHAL_GETBLTSTATUSDATA  StatusData;
    DWORD dwRet;

    if (CheckForDeviceLost (pGetBltStatus->hDD))
    {
        pGetBltStatus->ddRVal = S_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    StatusData.dwFlags = pGetBltStatus->dwFlags;
    dwRet = OsThunkDdGetBltStatus(GetSurfHandle(pGetBltStatus->hSurface),
                               (PDD_GETBLTSTATUSDATA) &StatusData);
    
    if (StatusData.ddRVal == DDERR_SURFACELOST)
    {
        StatusData.ddRVal = S_OK;
    }

    pGetBltStatus->ddRVal = MapLegacyResult(StatusData.ddRVal);

    return dwRet;
}

/*****************************Private*Routine******************************\
* DdGetFlipStatus
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdGetFlipStatus"

DWORD
APIENTRY
DdGetFlipStatus(
    PD3D8_GETFLIPSTATUSDATA pGetFlipStatus
   )
{
    DDHAL_GETFLIPSTATUSDATA StatusData;
    DWORD dwRet;

    if (CheckForDeviceLost (pGetFlipStatus->hDD))
    {
        pGetFlipStatus->ddRVal = S_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    StatusData.dwFlags = pGetFlipStatus->dwFlags;

    dwRet = OsThunkDdGetFlipStatus(GetSurfHandle(pGetFlipStatus->hSurface),
                                   (PDD_GETFLIPSTATUSDATA) &StatusData);

    if (StatusData.ddRVal == DDERR_SURFACELOST)
    {
        StatusData.ddRVal = S_OK;
    }

    pGetFlipStatus->ddRVal = MapLegacyResult(StatusData.ddRVal);

    return dwRet;
}

/*****************************Private*Routine******************************\
* DdWaitForVerticalBlank
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdWaitForVerticalBlank"

DWORD
APIENTRY
DdWaitForVerticalBlank(
    PD3D8_WAITFORVERTICALBLANKDATA pWaitForVerticalBlank
   )
{
    DDHAL_WAITFORVERTICALBLANKDATA WaitData;
    DWORD dwRet;

    if (CheckForDeviceLost (pWaitForVerticalBlank->hDD))
    {
        goto DeviceLost;
    }

    WaitData.dwFlags    = pWaitForVerticalBlank->dwFlags;
    WaitData.hEvent     = 0;

    dwRet = OsThunkDdWaitForVerticalBlank(DDHANDLE(pWaitForVerticalBlank->hDD),
                (PDD_WAITFORVERTICALBLANKDATA) &WaitData);

    if (WaitData.ddRVal == DDERR_SURFACELOST)
    {
        goto DeviceLost;
    }

    pWaitForVerticalBlank->bIsInVB  = WaitData.bIsInVB;
    pWaitForVerticalBlank->ddRVal   = WaitData.ddRVal;

    if (WaitData.ddRVal == DDERR_VERTICALBLANKINPROGRESS)
    {
        pWaitForVerticalBlank->bIsInVB = TRUE;                   
    }
    else
    {
        pWaitForVerticalBlank->bIsInVB = FALSE;                   
    }
    pWaitForVerticalBlank->ddRVal = DD_OK;

    return dwRet;

DeviceLost:
    {
        static int LostTestVerticalBlank;

        pWaitForVerticalBlank->ddRVal = DD_OK;
        if (pWaitForVerticalBlank->dwFlags == DDWAITVB_I_TESTVB)
        {
            if (LostTestVerticalBlank > 0)
            {
                pWaitForVerticalBlank->bIsInVB = TRUE;
            }
            else
            {
                pWaitForVerticalBlank->bIsInVB = FALSE;
            }
            LostTestVerticalBlank = LostTestVerticalBlank == 0 ? 1 : 0;
        }
        else if (pWaitForVerticalBlank->dwFlags == DDWAITVB_BLOCKEND)
        {
            pWaitForVerticalBlank->bIsInVB = FALSE;
        }
        else
        {
            pWaitForVerticalBlank->bIsInVB = TRUE;
        }
    }
    return DDHAL_DRIVER_HANDLED;
}

/*****************************Private*Routine******************************\
* DdDestroySurface
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdDestroySurface"

DWORD
APIENTRY
DdDestroySurface(
    PD3D8_DESTROYSURFACEDATA pDestroySurface
   )
{
    DWORD i;
    PDDSURFHANDLE pSurf = (PDDSURFHANDLE) pDestroySurface->hSurface;
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pDestroySurface->hDD;
    PDEFERREDCREATE pDefCreate = pDevice->pDeferList;

    FreeSurfaceObject(pSurf);

    // Remove the surface from the linked list

    if (pDevice->pSurfList == pSurf)
    {
        pDevice->pSurfList = pSurf->pNext;
        if (pSurf->pNext != NULL)
        {
            pSurf->pNext->pPrevious = NULL;
        }
    }
    else
    {
        if (pSurf->pNext != NULL)
        {
            pSurf->pNext->pPrevious = pSurf->pPrevious;
        }
        pSurf->pPrevious->pNext = pSurf->pNext;
    }

    // If we allcoated the memory for this surface (due to a lost state),
    // then we should free it now.

    if (pSurf->dwFlags & DDSURF_SYSMEMALLOCATED)
    {
        MemFree((void*) pSurf->fpVidMem);
    }

    // If this surface pointer is cached in the context structure, we need
    // to remedy that.

    if (pSurf->pDevice->pContext != NULL)
    {
        if (pSurf->pDevice->pContext->pSurface == pSurf)
        {
            pSurf->pDevice->pContext->pSurface = NULL;
        }
        if (pSurf->pDevice->pContext->pDDSZ == pSurf)
        {
            pSurf->pDevice->pContext->pDDSZ = NULL;
        }
    }

    MemFree (pSurf);

    // We look in the defer list to see if any referenced surface
    // is being destroyed. If this is the case, then we need to
    // update the defer list and mark the surfaces as freed so
    // that we don't try and resurrect destroyed surfaces. Although
    // this appears slow, it is not too bad because a deferred list
    // will be present only if a mode switch happened. In this case,
    // it doesn't hurt if things are a little slow.

    while (pDefCreate != NULL)
    {
        for (i = 0; i < pDefCreate->CreateData.dwSCnt; i++)
        {
            if (pSurf == (PDDSURFHANDLE) pDefCreate->CreateData.pSList[i].hKernelHandle)
            {
                pDefCreate->CreateData.pSList[i].hKernelHandle = 0;
                break;
            }
        }
        pDefCreate = pDefCreate->pNext;
    }

    return (DDHAL_DRIVER_HANDLED);
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3D8GetMode"

DWORD
APIENTRY
D3D8GetMode(
    HANDLE          Handle,
    char*           pDeviceName,
    D3DDISPLAYMODE* pMode,
    D3DFORMAT       Unknown16)
{
    DEVMODE     dm;
    HDC         hdc;

    memset (&dm, 0, sizeof(dm));
    dm.dmSize = sizeof(dm);
    if (EnumDisplaySettings(pDeviceName, ENUM_CURRENT_SETTINGS, &dm))
    {
        pMode->Width        = dm.dmPelsWidth;
        pMode->Height       = dm.dmPelsHeight;
        pMode->RefreshRate  = dm.dmDisplayFrequency;

        switch (dm.dmBitsPerPel)
        {
        case 8:
            pMode->Format = D3DFMT_P8;
            break;

        case 24:
            pMode->Format = D3DFMT_R8G8B8;
            break;

        case 32:
            pMode->Format = D3DFMT_X8R8G8B8;
            break;

        case 15:
        case 16:
            pMode->Format = D3DFMT_R5G6B5;
            hdc = DD_CreateDC(pDeviceName);
            if (hdc)
            {
                HBITMAP hbm;
                BITMAPINFO *pbmi;
                DWORD *pdwColors;

                if (pbmi = (BITMAPINFO*) MemAlloc(3 * sizeof (RGBQUAD) + sizeof (BITMAPINFO)))
                {
                    if (hbm = CreateCompatibleBitmap(hdc, 1, 1))
                    {
                        pbmi->bmiHeader.biSize = sizeof (BITMAPINFOHEADER);

                        if (GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS))
                        {
                            if (pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                            {
                                GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight,
                                    NULL, pbmi, DIB_RGB_COLORS);

                                pdwColors = (DWORD *) &pbmi->bmiColors[0];
                                if (pdwColors[1] == 0x3e0)
                                {
                                    pMode->Format = D3DFMT_X1R5G5B5;
                                }
                            }
                        }
                        DeleteObject(hbm);
                    }
                    MemFree(pbmi);
                }
                DD_DoneDC(hdc);
            }
            break;

        default:
            pMode->Format = D3DFMT_UNKNOWN;
            break;
        }
        return S_OK;
    }

    // I don't know in which cases we would ever hit this
    return D3DERR_DRIVERINTERNALERROR;
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3D8SetMode"

DWORD
APIENTRY
D3D8SetMode(
    HANDLE          Handle,
    char*           pDeviceName,
    UINT            Width,
    UINT            Height,
    UINT            BPP,
    UINT            RefreshRate,
    BOOL            bRestore)
{
    HANDLE h = GetModuleHandle("USER32");
    LONG (WINAPI *pfnChangeDisplaySettingsExA)(LPCSTR,LPDEVMODEA,HWND,DWORD,LPVOID);
    DEVMODE dm, * pdm;
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) Handle;

    // Init the devmode properly:

    dm.dmSize               = sizeof(DEVMODE);
    EnumDisplaySettings (pDeviceName,0,&dm);

    dm.dmBitsPerPel         = BPP;
    dm.dmPelsWidth          = Width;
    dm.dmPelsHeight         = Height;
    dm.dmDisplayFrequency   = RefreshRate;
    dm.dmDisplayFlags       = 0;
    dm.dmFields             = DM_BITSPERPEL |
                              DM_PELSWIDTH |
                              DM_PELSHEIGHT |
                              DM_DISPLAYFREQUENCY;

    // Now tell the OS to do the mode change

    (FARPROC)pfnChangeDisplaySettingsExA = GetProcAddress(h,"ChangeDisplaySettingsExA");
    if (pfnChangeDisplaySettingsExA)
    {
        InformDriverToDeferFrees(pDevice);
        if (bRestore)
        {
            if ((*pfnChangeDisplaySettingsExA)(pDeviceName,
                NULL, NULL, CDS_FULLSCREEN, 0) == DISP_CHANGE_SUCCESSFUL)
            {
                return S_OK;
            }
        }
        else
        {
            if ((*pfnChangeDisplaySettingsExA)(pDeviceName,
                &dm, NULL, CDS_FULLSCREEN, 0) == DISP_CHANGE_SUCCESSFUL)
            {
                return S_OK;
            }
        }
        if (NumReadyDevices == NumDevices)
        {
            InformDriverFreeAGP(pDevice);
        }
    }

    return D3DERR_DRIVERINTERNALERROR;
}

/*****************************Private*Routine******************************\
* DdSetMode
*
* History:
*  29-Nov-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "DdSetMode"

DWORD
APIENTRY
DdSetMode(
    PD3D8_SETMODEDATA pSetMode
   )
{
    UINT    BPP;
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) pSetMode->hDD;

    // smac: How should lost devices behave?
    CheckForDeviceLost(pSetMode->hDD);

    pSetMode->ddRVal = D3DERR_DRIVERINTERNALERROR;

    switch (pSetMode->Format)
    {
    case D3DFMT_P8:
        BPP = 8;
        break;

    case D3DFMT_R5G6B5:
    case D3DFMT_X1R5G5B5:
        BPP = 16;
        break;

    case D3DFMT_R8G8B8:
        BPP = 24;
        break;

    case D3DFMT_A8R8G8B8:
    case D3DFMT_X8R8G8B8:
        BPP = 32;
        break;

    default:
        return DDHAL_DRIVER_HANDLED;
    }

    pSetMode->ddRVal = D3D8SetMode(pDeviceHandle,
                                   pDeviceHandle->szDeviceName,
                                   pSetMode->dwWidth,
                                   pSetMode->dwHeight,
                                   BPP,
                                   pSetMode->dwRefreshRate,
                                   pSetMode->bRestore);

    return DDHAL_DRIVER_HANDLED;
}

/*****************************Private*Routine******************************\
* DdGetScanLine
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "DdGetScanLine"

DWORD
APIENTRY
DdGetScanLine(
    PD3D8_GETSCANLINEDATA pGetScanLine
   )
{
    DDHAL_GETSCANLINEDATA   ScanData;
    DWORD                   dwRet;

    if (CheckForDeviceLost(pGetScanLine->hDD))
    {
        goto DeviceLost;
    }

    dwRet = OsThunkDdGetScanLine(DDHANDLE(pGetScanLine->hDD),
                                 (PDD_GETSCANLINEDATA) &ScanData);

    if (ScanData.ddRVal == DDERR_SURFACELOST)
    {
        goto DeviceLost;
    }

    pGetScanLine->dwScanLine = ScanData.dwScanLine;
    if (ScanData.ddRVal == DDERR_VERTICALBLANKINPROGRESS)
    {
        pGetScanLine->bInVerticalBlank = TRUE;
        ScanData.ddRVal = S_OK;
    }
    else
    {
        pGetScanLine->bInVerticalBlank = FALSE;
    }
    pGetScanLine->ddRVal = MapLegacyResult(ScanData.ddRVal);

    return dwRet;

DeviceLost:
    {
        static int LostScanLine;

        // When lost, we want to mix up the return values in case somebody
        // calling us is waiting for these values to change

        pGetScanLine->ddRVal = DD_OK;
        if (LostScanLine == 0)
        {
            pGetScanLine->dwScanLine = 0;
            pGetScanLine->bInVerticalBlank = TRUE;
        }
        else 
        {
            pGetScanLine->dwScanLine = LostScanLine;
            pGetScanLine->bInVerticalBlank = FALSE;
        }
        if ((LostScanLine += 10) > 100)
        {
            LostScanLine = 0;
        }
    }
    return DDHAL_DRIVER_HANDLED;
}

/*****************************Private*Routine******************************\
* DdSetExclusiveMode
*
* History:
*  22-Apr-1998 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdSetExclusiveMode"

DWORD
APIENTRY
DdSetExclusiveMode(
    PD3D8_SETEXCLUSIVEMODEDATA pSetExclusiveMode
   )
{
    DDHAL_SETEXCLUSIVEMODEDATA  ExclusiveData;
    DWORD dwRet;

    // smac: How should lost devices behave?
    CheckForDeviceLost(pSetExclusiveMode->hDD);

    ZeroMemory(&ExclusiveData, sizeof(ExclusiveData));
    ExclusiveData.dwEnterExcl = pSetExclusiveMode->dwEnterExcl;

    dwRet = OsThunkDdSetExclusiveMode(
                DDHANDLE(pSetExclusiveMode->hDD),
                (PDD_SETEXCLUSIVEMODEDATA) &ExclusiveData);

    pSetExclusiveMode->ddRVal = MapLegacyResult(ExclusiveData.ddRVal);

    return dwRet;
}

/*****************************Private*Routine******************************\
* DdFlipToGDISurface
*
* History:
*  22-Apr-1998 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "DdFlipToGDISurface"

DWORD
APIENTRY
DdFlipToGDISurface(
    PD3D8_FLIPTOGDISURFACEDATA pFlipToGDISurface
   )
{
    DDHAL_FLIPTOGDISURFACEDATA  FlipData;
    DWORD dwRet;

    // smac: How should lost devices behave?
    CheckForDeviceLost(pFlipToGDISurface->hDD);

    FlipData.dwToGDI = pFlipToGDISurface->dwToGDI;
    FlipData.dwReserved = 0;
    FlipData.ddRVal = E_FAIL;
    dwRet = OsThunkDdFlipToGDISurface(
                DDHANDLE(pFlipToGDISurface->hDD),
                (PDD_FLIPTOGDISURFACEDATA) &FlipData);
    if (DDHAL_DRIVER_HANDLED == dwRet)
        pFlipToGDISurface->ddRVal = FlipData.ddRVal;

    pFlipToGDISurface->ddRVal = MapLegacyResult(pFlipToGDISurface->ddRVal);

    return dwRet;
}

/*****************************Private*Routine******************************\
* DdGetAvailDriverMemory
*
* History:
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "DdGetAvailDriverMemory"

DWORD
APIENTRY
DdGetAvailDriverMemory(
    PD3D8_GETAVAILDRIVERMEMORYDATA pGetAvailDriverMemory
   )
{
    DDHAL_GETAVAILDRIVERMEMORYDATA  MemoryData;
    DWORD dwRet;

    // smac: How should lost devices behave?
    CheckForDeviceLost(pGetAvailDriverMemory->hDD);

    pGetAvailDriverMemory->dwFree = 0;

    // Convert the pool to something that the driver can understand

    memset(&MemoryData, 0, sizeof(MemoryData));
    switch (pGetAvailDriverMemory->Pool)
    {
    case D3DPOOL_LOCALVIDMEM:
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
        break;
    case D3DPOOL_DEFAULT:
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        break;
    case D3DPOOL_NONLOCALVIDMEM:
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
        break;

    default:
        return DDHAL_DRIVER_HANDLED;
    }

    if (pGetAvailDriverMemory->dwUsage & D3DUSAGE_DEPTHSTENCIL)
    {
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_ZBUFFER;
    }
    if (pGetAvailDriverMemory->dwUsage & D3DUSAGE_RENDERTARGET)
    {
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_3DDEVICE;
    }
    if (pGetAvailDriverMemory->dwUsage & D3DUSAGE_TEXTURE)
    {
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_TEXTURE;
    }

    dwRet = OsThunkDdGetAvailDriverMemory(
                DDHANDLE(pGetAvailDriverMemory->hDD),
                (PDD_GETAVAILDRIVERMEMORYDATA) &MemoryData);

    pGetAvailDriverMemory->dwFree = MemoryData.dwFree;

    return dwRet;
}

/*****************************Private*Routine******************************\
* D3D8QueryDirectDrawObject
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8QueryDirectDrawObject"


BOOL
APIENTRY
D3D8QueryDirectDrawObject(
    HANDLE                      hDD,
    PD3D8_DRIVERCAPS            pDriverCaps,
    PD3D8_CALLBACKS             pCallbacks,
    char*                       pDeviceName,
    HINSTANCE                   hLibrary,
    D3D8_GLOBALDRIVERDATA*      pGblDriverData,
    D3DHAL_D3DEXTENDEDCAPS*     pExtendedCaps,
    LPDDSURFACEDESC             pTextureFormats,
    LPDDPIXELFORMAT             pZStencilFormats,
    UINT*                       pcTextureFormats,
    UINT*                       pcZStencilFormats
   )
{
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) hDD;
    DD_HALINFO                  HalInfo;
    DWORD                       adwCallBackFlags[3];
    DWORD                       dwFlags;
    VIDEOMEMORY*                pVideoMemoryList;
    VIDEOMEMORY*                pVideoMemory;
    DWORD                       dwNumHeaps;
    DWORD                       dwNumFourCC;
    D3DNTHAL_CALLBACKS          D3dCallbacks;
    D3DNTHAL_GLOBALDRIVERDATA   D3dDriverData;
    DD_D3DBUFCALLBACKS          D3dBufferCallbacks;
    DDSCAPSEX                   SurfCapsEx;
    DD_GETDRIVERINFODATA        GetDriverInfoData;
    DWORD                       dwSize;
    DD_MORESURFACECAPS *        pSurfCaps;
    DWORD                       dwRet;
    DWORD                       i;
    DD_MISCELLANEOUSCALLBACKS   MiscCallbacks;
    DD_MISCELLANEOUS2CALLBACKS  Misc2Callbacks;
    D3DNTHAL_CALLBACKS3         D3dCallbacks3;
    D3DDISPLAYMODE              Mode;
    UINT                        MaxZStencilFormats;
    UINT                        MaxTextureFormats;
    
    DDASSERT(pcTextureFormats);
    DDASSERT(pcZStencilFormats);

    MaxTextureFormats = *pcTextureFormats;
    MaxZStencilFormats = *pcZStencilFormats;
    *pcTextureFormats=0;
    *pcZStencilFormats=0;

    // memset the extended caps and global driver data
    ZeroMemory( pExtendedCaps, sizeof( *pExtendedCaps ) );
    ZeroMemory( pGblDriverData, sizeof( *pGblDriverData ) );

    // smac: How should lost devices behave?
    CheckForDeviceLost(hDD);

    // Get all of the neccesary caps
    // Note: do this memset before the Query, since the caller might (ok will) be
    // using a ptr internal to this struct to hold a reference to the

    memset(pDriverCaps, 0, sizeof(D3D8_DRIVERCAPS));

    // Behavior change: This code used to query for the supported texture format
    // list if the device is not software only and the caller supplied a non-NULL
    // buffer for the supported texture formats. Now, however, we never request
    // texture formats at this point. We only request them if we need to, that
    // is if the driver turns out to be a DirectX 7.0 driver or if it is a
    // DirectX 8.0 driver that doesn't support the new format querying mechanism.
    // This later clause is temporary only. Prior to RTM we will require
    // DirectX 8.0 drivers to support the new format querying mechanism.
    if (!OsThunkDdQueryDirectDrawObject(DDHANDLE(hDD),
                                      &HalInfo,
                                      &adwCallBackFlags[0],
                                      &D3dCallbacks,
                                      &D3dDriverData,
                                      &D3dBufferCallbacks,
                                      NULL,
                                      &dwNumHeaps,
                                      NULL,
                                      &dwNumFourCC,
                                      NULL))
    {
        return(FALSE);
    }
    if ((!(HalInfo.dwFlags & DDHALINFO_GETDRIVERINFO2)) &&
        (!(IS_SOFTWARE_DRIVER(pDevice)))                &&
        (NULL != pTextureFormats))
    {
        // This is not a DirectX 8.0 or higher level driver so query again to get
        // the texture formats (as we know we won't get them through the new DirectX 8.0
        // interfaces).
        if (!OsThunkDdQueryDirectDrawObject(DDHANDLE(hDD),
                                        &HalInfo,
                                        &adwCallBackFlags[0],
                                        &D3dCallbacks,
                                        &D3dDriverData,
                                        &D3dBufferCallbacks,
                                        pTextureFormats,
                                        &dwNumHeaps,
                                        NULL,
                                        &dwNumFourCC,
                                        NULL))
        {
            return(FALSE);
        }
    }

    if (!IS_SOFTWARE_DRIVER(pDevice))
    {
        // Initialize the texture format count from the driver data.
        // However, if this is a DX8 style driver this number will be
        // replaced by a format count reported by the new DX8 mechanism
        // code later in this function.
        *pcTextureFormats = D3dDriverData.dwNumTextureFormats;
    }

    // Display drivers can all render windowed
    if( (HalInfo.dwFlags & DDHALINFO_ISPRIMARYDISPLAY) ||
        IsVGADevice(pDeviceName))
    {
        HalInfo.ddCaps.dwCaps2 |= DDCAPS2_CANRENDERWINDOWED;
    }

    pDriverCaps->D3DCaps.Caps         = HalInfo.ddCaps.dwCaps;
    pDriverCaps->D3DCaps.Caps2        = HalInfo.ddCaps.dwCaps2;
    pDriverCaps->D3DCaps.Caps3        = HalInfo.ddCaps.dwSVCaps;
    pDriverCaps->SVBCaps              = HalInfo.ddCaps.dwSVBCaps;
    pDriverCaps->VSBCaps              = HalInfo.ddCaps.dwVSBCaps;
    pDriverCaps->SVBCaps2             = HalInfo.ddCaps.dwSVBCaps2;

    pDevice->DisplayPitch = HalInfo.vmiData.lDisplayPitch;

    // Get the extended surface caps

    SurfCapsEx.dwCaps2 = 0;
    SurfCapsEx.dwCaps3 = 0;
    SurfCapsEx.dwCaps4 = 0;

    memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
    GetDriverInfoData.dwSize = sizeof(GetDriverInfoData);

    GetDriverInfoData.guidInfo = GUID_DDMoreSurfaceCaps;
    dwSize = sizeof(DD_MORESURFACECAPS) + ((dwNumHeaps ? dwNumHeaps - 1 : 0) * sizeof(DDSCAPSEX) * 2);
    pSurfCaps = (DD_MORESURFACECAPS*) MemAlloc(dwSize);
    GetDriverInfoData.ddRVal = E_FAIL;
    if (pSurfCaps != NULL)
    {
        pSurfCaps->dwSize = dwSize;
        GetDriverInfoData.dwExpectedSize = dwSize;
        GetDriverInfoData.lpvData        = pSurfCaps;

        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
        if ((dwRet == DDHAL_DRIVER_HANDLED) &&
            (GetDriverInfoData.ddRVal == S_OK))
        {
            SurfCapsEx = pSurfCaps->ddsCapsMore;
        }
        MemFree(pSurfCaps);
    }

    // If the driver supports the "GetDriverInfo2" usage of GetDriverInfo then
    // use that now to get the D3DCAPS8.
    if ((HalInfo.dwFlags & DDHALINFO_GETDRIVERINFO2) &&
        !IS_SOFTWARE_DRIVER(pDevice))
    {
        // This buffer is used to pass information down to the driver and get
        // information back from the driver. The GetDriverInfo2 header and
        // any additional information to pass to the driver is copied into this
        // buffer prior to calling GetDriverInfo2. After the call the information
        // returned by the driver is contained in this buffer. All information
        // passed to and from the driver must fit within a buffer of this size.
        DWORD                  buffer[MAX_GDI2_BUFFER_DWORD_SIZE];
        DD_GETDRIVERINFO2DATA* pgdi2;
        DD_GETFORMATCOUNTDATA* pgfcd;
        DD_GETFORMATDATA*      pgfd;
        DD_DXVERSION*          pDXVersion;
        int                    i;
        
        // Set up the DXVersion call
        memset(&buffer, 0, sizeof(buffer));
        pDXVersion = (DD_DXVERSION *)buffer;

        // Before we do anything else, we notify the
        // driver about the DX version information. We ignore
        // errors here.
        pDXVersion->gdi2.dwReserved     = sizeof(DD_STEREOMODE);
        pDXVersion->gdi2.dwMagic        = D3DGDI2_MAGIC;
        pDXVersion->gdi2.dwType         = D3DGDI2_TYPE_DXVERSION;
        pDXVersion->gdi2.dwExpectedSize = sizeof(DD_DXVERSION);
        pDXVersion->dwDXVersion         = DD_RUNTIME_VERSION;
        
        memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
        GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
        GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
        GetDriverInfoData.lpvData        = &buffer;
        GetDriverInfoData.dwExpectedSize = sizeof(DD_STEREOMODE);
        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
        if (dwRet != DDHAL_DRIVER_HANDLED       || 
            GetDriverInfoData.ddRVal != S_OK)
        {
            // Errors are ignored here
            dwRet = DDHAL_DRIVER_HANDLED;
        }

        memset(&buffer, 0, sizeof(buffer));

        pgdi2 = (DD_GETDRIVERINFO2DATA*)&buffer;

        // sizeof(DD_STEREOMODE)? The GUID for GetDriverInfo2 is shared with
        // the stereo mode querying stuff. Therefore we need to pass down
        // the structure size (and the expected data size) as
        // sizeof(DD_STEREOMODE) even though we actually have a buffer (and
        // expect a size of sizeof(D3DCAPS8).
        pgdi2->dwReserved     = sizeof(DD_STEREOMODE);
        pgdi2->dwMagic        = D3DGDI2_MAGIC;
        pgdi2->dwType         = D3DGDI2_TYPE_GETD3DCAPS8;
        pgdi2->dwExpectedSize = sizeof(D3DCAPS8);

        memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
        GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
        GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
        GetDriverInfoData.lpvData        = &buffer;
        GetDriverInfoData.dwExpectedSize = sizeof(DD_STEREOMODE);
        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
        if ((dwRet == DDHAL_DRIVER_HANDLED) && (GetDriverInfoData.ddRVal == S_OK))
        {
            // Looks like we got D3DCAPS8 back from the driver. Verify by means
            // of the dwActualSize field in GetDriverInfoData.
            if (sizeof(D3DCAPS8) != GetDriverInfoData.dwActualSize)
            {
                DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(D3DCAPS8))");
                return(FALSE);
            }

            // All went well. Copy the caps data across
            memcpy(&pDriverCaps->D3DCaps, &buffer, sizeof(D3DCAPS8));

            // Drivers may not set the ddraw caps correctly, or they might not update them
            // across mode changes, so use the caps that we already have.
            pDriverCaps->D3DCaps.Caps = HalInfo.ddCaps.dwCaps;

            // Display drivers can all render windowed
            if( (HalInfo.dwFlags & DDHALINFO_ISPRIMARYDISPLAY) ||
                IsVGADevice(pDeviceName))
            {
                pDriverCaps->D3DCaps.Caps2 |= DDCAPS2_CANRENDERWINDOWED;
            }

            // Set the flag indicating that the DDI successfully reported DX8
            // style caps
            pDriverCaps->dwFlags |= DDIFLAG_D3DCAPS8;

            // See device can do sub volume lock for volume texture.
            if (pDriverCaps->D3DCaps.DevCaps & D3DDEVCAPS_SUBVOLUMELOCK)
            {
                pDevice->dwFlags |= DDDEVICE_SUPPORTSUBVOLUMELOCK;
            }
        }

        // If this is a DX8 driver it needs to report it supported texture formats to us
        // using GetDriverInfo2. This is done in two stages, one query to determine the
        // number of supported formats, and one to actually retrieve those formats
        // iteratively.

        // Step 1: Get the number of supported formats
        // Please see the description comments above for a description of why the
        // reserved field is set to sizeof(DD_STEREOMODE)
        memset(&buffer, 0, sizeof(buffer));

        pgfcd = (DD_GETFORMATCOUNTDATA*)&buffer;

        pgfcd->gdi2.dwReserved     = sizeof(DD_STEREOMODE);
        pgfcd->gdi2.dwMagic        = D3DGDI2_MAGIC;
        pgfcd->gdi2.dwType         = D3DGDI2_TYPE_GETFORMATCOUNT;
        pgfcd->gdi2.dwExpectedSize = sizeof(DD_GETFORMATCOUNTDATA);

        #if DBG
            // Ensure the driver actually sets the format count if it succeeds this call
            pgfcd->dwFormatCount    = BOGUS_FIELD_VALUE;
        #endif // DBG

        memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
        GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
        GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
        GetDriverInfoData.lpvData        = &buffer;
        GetDriverInfoData.dwExpectedSize = sizeof(DD_STEREOMODE);
        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
        if ((dwRet == DDHAL_DRIVER_HANDLED) && (GetDriverInfoData.ddRVal == S_OK))
        {
            // Looks like we got a DD_GETFORMATCOUNTDATA back from the driver. Verify by means
            // of the dwActualSize field in GetDriverInfoData.
            if (sizeof(DD_GETFORMATCOUNTDATA) != GetDriverInfoData.dwActualSize)
            {
                DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(DD_GETFORMATCOUNTDATA))");
                return(FALSE);
            }

            #ifdef DBG
                if (BOGUS_FIELD_VALUE == ((DD_GETFORMATCOUNTDATA*)&buffer)->dwFormatCount)
                {
                    DPF_ERR( "Driver succeeded GETFORMATCOUNT request but didn't set dwFormatCount. Driver error." );
                    return(FALSE);
                }
            #endif // DBG

            // All went well. Replace the number of supported texture formats the driver
            // reported to us with this new number. We don't use the legacy texture format
            // list if this new mechanism is supported
            
            *pcTextureFormats = ((DD_GETFORMATCOUNTDATA*)&buffer)->dwFormatCount;

            // Step2: Query for each of the surface formats in turn.
            // We only do this if the caller requested that we do by means of a non-NULL
            // texture format buffer
            if (NULL != pTextureFormats)
            {
                DWORD          c;
                DDSURFACEDESC* pOutFormat;

                // For simplicities sake we ask for a single format at a time. Not exactly
                // high-performance but this should not matter at this stage of the code.
                pOutFormat = pTextureFormats;
                *pcTextureFormats = min(MaxTextureFormats, *pcTextureFormats);
                for (c = 0; c < (*pcTextureFormats); ++c)
                {
                    // We reinitialize the entire request each time. We could probably
                    // optimize this but it doesn't seem worth it.
                    memset(&buffer, 0, sizeof(DD_GETFORMATDATA));

                    pgfd = (DD_GETFORMATDATA*)&buffer;

                    pgfd->gdi2.dwReserved     = sizeof(DD_STEREOMODE);
                    pgfd->gdi2.dwMagic        = D3DGDI2_MAGIC;
                    pgfd->gdi2.dwType         = D3DGDI2_TYPE_GETFORMAT;
                    pgfd->gdi2.dwExpectedSize = sizeof(DD_GETFORMATDATA);
                    pgfd->dwFormatIndex        = c;
                    #if DBG
                        // Ensure the driver actually sets the format count if it succeeds this call
                        pgfd->format.dwSize    = BOGUS_FIELD_VALUE;
                    #endif // DBG
 
                    memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
                    GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
                    GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
                    GetDriverInfoData.lpvData        = &buffer;
                    GetDriverInfoData.dwExpectedSize = sizeof(DD_STEREOMODE);
                    dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
                    if ((dwRet == DDHAL_DRIVER_HANDLED) && (GetDriverInfoData.ddRVal == S_OK))
                    {
                        // Looks like we got a DD_GETFORMATDATA back from the driver. Verify by means
                        // of the dwActualSize field in GetDriverInfoData.
                        if (sizeof(DD_GETFORMATDATA) != GetDriverInfoData.dwActualSize)
                        {
                            DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(DD_GETFORMATDATA))");
                            return(FALSE);
                        }

                        DDASSERT(c == ((DD_GETFORMATDATA*)&buffer)->dwFormatIndex);

                        #ifdef DBG
                            if (BOGUS_FIELD_VALUE == (((DD_GETFORMATDATA*)&buffer)->format).dwSize)
                            {
                                DPF_ERR( "Driver succeeded GETFORMAT request but didn't set format. Driver error." );
                                return(FALSE);
                            }
                        #endif // DBG

                        // Looks like all went well. Initialize the surface description part of the format
                        // list and copy the pixel format we got from the driver across.
                        memset(pOutFormat, 0, sizeof(DDSURFACEDESC));
                        pOutFormat->dwSize  = sizeof(DDSURFACEDESC);
                        pOutFormat->dwFlags = DDSD_PIXELFORMAT;
                        memcpy(&pOutFormat->ddpfPixelFormat, &(((DD_GETFORMATDATA*)&buffer)->format), sizeof(DDPIXELFORMAT));

                        ++pOutFormat;
                    }
                }
            }
        }
        else
        {
            DPF(0, "Driver claims DX8 but fails call to GETFORMATCOUNT"             );
            DPF(0, "DX7 texture format list will be used but this will change soon" );
            DPF(0, "Fix driver to support DX8 style surface format reporting now"   );

            // This is a DirectX 8.0 level driver but it doesn't appear to support the
            // new DirectX 8.0 style format querying mechanism so query the kernel
            // again for the DirectX 7.0 style capabilities and use them instead.
            // Note, this is a temporary measure only, prior to the RTM of DirectX 8.0
            // this fallback will be removed and drivers will be required to support
            // the new DirectX 8.0 style format reporting mechanism
            if ((!IS_SOFTWARE_DRIVER(pDevice)) && (NULL != pTextureFormats))
            {
                if (!OsThunkDdQueryDirectDrawObject(DDHANDLE(hDD),
                        &HalInfo,
                        &adwCallBackFlags[0],
                        &D3dCallbacks,
                        &D3dDriverData,
                        &D3dBufferCallbacks,
                        pTextureFormats,
                        &dwNumHeaps,
                        NULL,
                        &dwNumFourCC,
                        NULL))
                {
                    return(FALSE);
                }
            }
        }
    }
    else if (D3dCallbacks.dwSize != 0 && D3dDriverData.dwSize != 0)
    {
        pGblDriverData->dwSize = D3dDriverData.dwSize;
        
        //watcha gonna do:
        DDASSERT(sizeof(pGblDriverData->hwCaps) == sizeof(D3dDriverData.hwCaps));
        memcpy(&pGblDriverData->hwCaps, &D3dDriverData.hwCaps, sizeof(pGblDriverData->hwCaps));
        
        pGblDriverData->dwNumVertices = D3dDriverData.dwNumVertices;
        pGblDriverData->dwNumClipVertices = D3dDriverData.dwNumClipVertices;
        
        // Get the D3D extended caps
        
        GetDriverInfoData.guidInfo       = GUID_D3DExtendedCaps;
        GetDriverInfoData.ddRVal         = E_FAIL;
        GetDriverInfoData.dwExpectedSize = sizeof(D3DHAL_D3DEXTENDEDCAPS);
        GetDriverInfoData.lpvData        = pExtendedCaps;
        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
        if ((dwRet != DDHAL_DRIVER_HANDLED) ||
            (GetDriverInfoData.ddRVal != S_OK))
        {
            DPF_ERR( "Get EXTENDEDCAPS from the driver failed" );
            return FALSE;
        }
    }

    // Get the supported Z formats.  We only do this if we are not using a
    // software driver

    if (!IS_SOFTWARE_DRIVER(pDevice))
    {
        DWORD tempbuf[249];  // make this <1K bytes or GetDriverInfo() fails cuz it cant do its "expected size overwrite" test within its own 1K tempbuffer

        GetDriverInfoData.guidInfo       = GUID_ZPixelFormats;
        GetDriverInfoData.ddRVal         = E_FAIL;
        GetDriverInfoData.dwExpectedSize = sizeof(tempbuf);
        GetDriverInfoData.lpvData        = tempbuf;
        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);

        if ((dwRet != DDHAL_DRIVER_HANDLED) ||
            (GetDriverInfoData.ddRVal != S_OK) ||
            ((GetDriverInfoData.dwActualSize-sizeof(DWORD)) % sizeof(DDPIXELFORMAT) != 0) ||
            ((tempbuf[0]*sizeof(DDPIXELFORMAT)+sizeof(DWORD))>sizeof(tempbuf)))

        {
            // It could be that this is an old driver that doesn't support
            // stencil.  We might be able to get some info from the global
            // driver data.

            if (pGblDriverData->hwCaps.dwDeviceZBufferBitDepth & DDBD_16)
            {
                (*pcZStencilFormats)++;
                if (pZStencilFormats && 
                    (*pcZStencilFormats <= MaxZStencilFormats))
                {
                    pZStencilFormats->dwSize = sizeof(DDPIXELFORMAT);
                    pZStencilFormats->dwFlags = DDPF_ZBUFFER;
                    pZStencilFormats->dwZBufferBitDepth = 16;
                    pZStencilFormats->dwStencilBitDepth = 0;
                    pZStencilFormats->dwZBitMask = 0xffff;
                    pZStencilFormats->dwStencilBitMask = 0x0000;
                    pZStencilFormats++;
                }
            }
            if (pGblDriverData->hwCaps.dwDeviceZBufferBitDepth & DDBD_32)
            {
                (*pcZStencilFormats)++;
                if (pZStencilFormats &&
                    (*pcZStencilFormats <= MaxZStencilFormats))
                {
                    pZStencilFormats->dwSize = sizeof(DDPIXELFORMAT);
                    pZStencilFormats->dwFlags = DDPF_ZBUFFER;
                    pZStencilFormats->dwZBufferBitDepth = 32;
                    pZStencilFormats->dwStencilBitDepth = 0;
                    pZStencilFormats->dwZBitMask = 0xffffffff;
                    pZStencilFormats->dwStencilBitMask = 0x00000000;
                    pZStencilFormats++;
                }
            }
        }
        else
        {
            //We have a GetDriverInfo response to our Z format query. These are
            //DDPIXELFORMATs that we can copy back to our caller
            (*pcZStencilFormats) = tempbuf[0];
            if(pZStencilFormats)
            {
                MaxZStencilFormats = min(MaxZStencilFormats, tempbuf[0]);
                memcpy(pZStencilFormats, &tempbuf[1], MaxZStencilFormats * sizeof(DDPIXELFORMAT));
            }
        }
    }

    // Get info about the current mode

    D3D8GetMode (NULL, pDeviceName, &Mode, 0);

    pDevice->DisplayFormatWithAlpha = Mode.Format;
    pDevice->DisplayFormatWithoutAlpha = Mode.Format;
    if (Mode.Format == D3DFMT_X8R8G8B8)
    {
        if (HalInfo.vmiData.ddpfDisplay.dwFlags & DDPF_ALPHAPIXELS)
        {
            pDevice->DisplayFormatWithAlpha = D3DFMT_A8R8G8B8;
        }
    }
    if (Mode.Format == D3DFMT_X1R5G5B5)
    {
        if (HalInfo.vmiData.ddpfDisplay.dwFlags & DDPF_ALPHAPIXELS)
        {
            pDevice->DisplayFormatWithAlpha = D3DFMT_A1R5G5B5;
        }
    }

    pDriverCaps->DisplayWidth               = Mode.Width;
    pDriverCaps->DisplayHeight              = Mode.Height;
    pDriverCaps->DisplayFrequency           = Mode.RefreshRate;
    pDriverCaps->DisplayFormatWithoutAlpha  = Mode.Format;
    pDriverCaps->DisplayFormatWithAlpha     = pDevice->DisplayFormatWithAlpha;


    // Get the Miscellaneous callbacks
    GetDriverInfoData.guidInfo       = GUID_MiscellaneousCallbacks;
    GetDriverInfoData.ddRVal         = E_FAIL;
    GetDriverInfoData.dwExpectedSize = sizeof(DD_MISCELLANEOUSCALLBACKS);
    GetDriverInfoData.lpvData        = &MiscCallbacks;
    dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
    if ((dwRet != DDHAL_DRIVER_HANDLED) ||
        (GetDriverInfoData.ddRVal != S_OK))
    {
        memset (&MiscCallbacks, 0, sizeof(DD_MISCELLANEOUSCALLBACKS));
    }

    // Get the Miscellaneous2 callbacks
    GetDriverInfoData.guidInfo       = GUID_Miscellaneous2Callbacks;
    GetDriverInfoData.ddRVal         = E_FAIL;
    GetDriverInfoData.dwExpectedSize = sizeof(DD_MISCELLANEOUS2CALLBACKS);
    GetDriverInfoData.lpvData        = &Misc2Callbacks;
    dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
    if ((dwRet != DDHAL_DRIVER_HANDLED) ||
        (GetDriverInfoData.ddRVal != S_OK))
    {
        memset (&Misc2Callbacks, 0, sizeof(DD_MISCELLANEOUS2CALLBACKS));
    }

    // Get the D3Dcallbacks3 callbacks
    GetDriverInfoData.guidInfo       = GUID_D3DCallbacks3;
    GetDriverInfoData.ddRVal         = E_FAIL;
    GetDriverInfoData.dwExpectedSize = sizeof(D3DNTHAL_CALLBACKS3);
    GetDriverInfoData.lpvData        = &D3dCallbacks3;
    dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
    if ((dwRet != DDHAL_DRIVER_HANDLED) ||
        (GetDriverInfoData.ddRVal != S_OK))
    {
        memset (&D3dCallbacks3, 0, sizeof(D3DNTHAL_CALLBACKS3));
    }

    // Fill in the D3D8 Callback table
    RtlZeroMemory(pCallbacks, sizeof(*pCallbacks));
    pCallbacks->CreateSurface           = DdCreateSurface;
    pCallbacks->DestroySurface          = DdDestroySurface;
    pCallbacks->Lock                    = DdLock;
    pCallbacks->Unlock                  = DdUnlock;
    pCallbacks->Blt                     = DdBlt;
    pCallbacks->GetScanLine             = DdGetScanLine;
    pCallbacks->Flip                    = DdFlip;
    pCallbacks->WaitForVerticalBlank    = DdWaitForVerticalBlank;
    pCallbacks->GetBltStatus            = DdGetBltStatus;
    pCallbacks->GetFlipStatus           = DdGetFlipStatus;
    pCallbacks->SetMode                 = DdSetMode;
    pCallbacks->FlipToGDISurface        = DdFlipToGDISurface;
    pCallbacks->SetExclusiveMode        = DdSetExclusiveMode;
    pCallbacks->GetAvailDriverMemory    = DdGetAvailDriverMemory;

    if (D3dCallbacks.ContextCreate != NULL)
    {
        pCallbacks->CreateContext   = D3dContextCreate;
    }
    if (D3dCallbacks.ContextDestroy != NULL)
    {
        pCallbacks->ContextDestroy = D3dContextDestroy;
    }
    if (D3dCallbacks.ContextDestroyAll != NULL)
    {
        pCallbacks->ContextDestroyAll = D3dContextDestroyAll;
    }
    if (Misc2Callbacks.GetDriverState)
    {
        pCallbacks->GetDriverState = DdGetDriverState;
    }
    if (D3dCallbacks3.ValidateTextureStageState != NULL)
    {
        pCallbacks->ValidateTextureStageState = D3dValidateTextureStageState;
    }
    if (D3dCallbacks3.DrawPrimitives2 != NULL)
    {
        pCallbacks->DrawPrimitives2 = D3dDrawPrimitives2;
    }
    if (HalInfo.dwFlags & DDHALINFO_GETDRIVERINFO2)
    {
        pDevice->dwFlags |= DDDEVICE_GETDRIVERINFO2;
        if (!(pDevice->dwFlags & DDDEVICE_INITIALIZED))
        {
            // Since this is the first time we have seen this device, we need
            // to tell the driver that the runtime will send the propoer AGP
            // notification.
            InformDriverAGPWorkaroundAware((HANDLE) pDevice);
        }
    }
    pDevice->dwFlags |= DDDEVICE_INITIALIZED;

    if (FAILED(GetNTDeviceRect(pDeviceName,&pDevice->rcMonitor)))
    {
        SetRect(&pDevice->rcMonitor,0,0,
            GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
    }

    // What about HW cursor support? check Must be done before SoftwareRast
    // Caps Overrides

    if (0 == pDriverCaps->D3DCaps.MaxStreams)
    {
        // The hardware driver is DX7
        if (CanKnownDriverDoThis(pDevice, KNOWN_HWCURSOR))
        {
            pDriverCaps->D3DCaps.CursorCaps = D3DCURSORCAPS_COLOR; 
            pDriverCaps->KnownDriverFlags |= KNOWN_HWCURSOR;
            if (CanKnownDriverDoThis(pDevice, KNOWN_HWCURSORLOWRES))
            {
                pDriverCaps->D3DCaps.CursorCaps |= D3DCURSORCAPS_LOWRES; 
                pDriverCaps->KnownDriverFlags |= KNOWN_HWCURSORLOWRES;
            }
        }
    }
    // need to save a HAL copy in thunklayer, for example DdBlt needs caps
    pDevice->DDCaps = pDriverCaps->D3DCaps.Caps;
    pDevice->SVBCaps = pDriverCaps->SVBCaps;

    // If Refrast or the HEL has a hook, call it to let it change whatever it wants

    if (IS_SOFTWARE_DRIVER(pDevice))
    {
        *pcZStencilFormats = 0;

        SwDDIMungeCaps (
            hLibrary,
            hDD,
            pDriverCaps,
            pCallbacks,
            pTextureFormats,
            pcTextureFormats,
            pDevice->pSwInitFunction
            );
    }

    pDevice->DriverLevel = 0;
    if (pDriverCaps->D3DCaps.MaxStreams != 0)
    {
        pDevice->DriverLevel = 8;
    }
    else if (pCallbacks->DrawPrimitives2 != NULL)
    {
        pDevice->DriverLevel = 7;
    }

    // Determine what version of windows is running so we can know
    // what lock parameters to send.  Whistler is version 5.1.

    pDevice->bIsWhistler = IsWhistler();

    // If it's a pre-dx8 driver and they support cubemaps, we need to
    // specify whether they support mipped cubemaps or not.
    
    if (pDevice->DriverLevel < 8)
    {
        if (CanKnownDriverDoThis(pDevice, KNOWN_MIPPEDCUBEMAPS))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_MIPPEDCUBEMAPS;
        }

        // Does this driver have a Z/Stencil depth restriction?
        if (CanKnownDriverDoThis(pDevice, KNOWN_ZSTENCILDEPTH))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_ZSTENCILDEPTH;
        }

        // Does device have no driver known to over-queue windowed presentation blts?
        if (CanKnownDriverDoThis(pDevice, KNOWN_NOTAWINDOWEDBLTQUEUER))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_NOTAWINDOWEDBLTQUEUER;
        }

        // Does device support D3DFMT_D16_LOCKABLE
        if (CanKnownDriverDoThis(pDevice, KNOWN_D16_LOCKABLE))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_D16_LOCKABLE;
        }

        // Figure out what RT/Texture formats it supports
        if (CanKnownDriverDoThis(pDevice, KNOWN_CANMISMATCHRT))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_CANMISMATCHRT;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_X1R5G5B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_X1R5G5B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_R5G6B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_R5G6B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_X8R8G8B8))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_X8R8G8B8;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A8R8G8B8))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A8R8G8B8;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A1R5G5B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A1R5G5B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A4R4G4B4))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A4R4G4B4;
        }
    }

    if (NULL != HalInfo.lpD3DBufCallbacks )
    {
        pDevice->dwFlags |= DDDEVICE_SUPPORTD3DBUF;
    }
    else
    {
        pDevice->dwFlags &= ~DDDEVICE_SUPPORTD3DBUF;
    }
    return(TRUE);
}

//
// See NT bug 448720...
//
// AGP surfaces will be unlocked by the kernel mode in response to mode switches.
// App may still be writing to surface.
// Driver should therefore defer free of AGP memory until later.
// "Later" is defined as when the usermode determines the app is done writing and can tell
// the driver so.
//
// Drivers need to know that the runtime can do this so they can turn off any other workarounds
// they might have.
//

/*****************************Private*Routine******************************\
* GetDriverInfo2
*
* History:
*  06-Nov-2001  maxmcm      Wrote it
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "GetDriverInfo2"

DWORD
APIENTRY
GetDriverInfo2(
    DWORD* pdwDrvRet,
    HANDLE hDriver,
    DWORD dwType,
    DWORD dwSize,
    void* pBuffer)
{
    DD_GETDRIVERINFO2DATA*          pGDI2Data;
    DD_GETDRIVERINFODATA            GetDriverInfoData;
    DWORD                           dwRet;
    PDDDEVICEHANDLE                 pDevice;

    // In some cases (e.g. ProfileAdapter), it is possible that we can get
    // here with a NULL device, so we should check for that.
    pDevice = (PDDDEVICEHANDLE) hDriver;
    if (pDevice == NULL)
    {
        *pdwDrvRet = E_FAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    // Don't call the driver if they don't support GETDRIVERINFO2
    if (!(pDevice->dwFlags & DDDEVICE_GETDRIVERINFO2))
    {
        *pdwDrvRet = E_FAIL;
        return DDHAL_DRIVER_HANDLED;
    }
       
    // Setup GetDriverInfo2 call
    pGDI2Data = (DD_GETDRIVERINFO2DATA*) pBuffer;

    memset(pGDI2Data, 0, sizeof(*pGDI2Data));
    pGDI2Data->dwReserved       = sizeof(DD_STEREOMODE);
    pGDI2Data->dwMagic          = D3DGDI2_MAGIC;
    pGDI2Data->dwType           = dwType;
    pGDI2Data->dwExpectedSize   = dwSize;

    memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
    GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
    GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
    GetDriverInfoData.lpvData        = pGDI2Data;
    GetDriverInfoData.dwExpectedSize = sizeof(DD_STEREOMODE);

    // Ask the driver for information
    dwRet = OsThunkDdGetDriverInfo(DDHANDLE(pDevice), &GetDriverInfoData);

    *pdwDrvRet = GetDriverInfoData.ddRVal;
    return dwRet;
}


void InformDriverAGPWorkaroundAware(HANDLE hDD)
{
    DDNT_DEFERRED_AGP_AWARE_DATA  aad;
    DWORD                       dwDrvRet;
    DWORD                       dwGDI2Ret;

    dwGDI2Ret = GetDriverInfo2(&dwDrvRet, hDD,
                                   _NT_D3DGDI2_TYPE_DEFERRED_AGP_AWARE,
                                   sizeof(aad), &aad);

    //drop the return code on the floor.... just a notification
}

void InformDriverFreeAGP(HANDLE hDD)
{
    DDNT_FREE_DEFERRED_AGP_DATA   fad;
    DWORD                       dwDrvRet;
    DWORD                       dwGDI2Ret;

    fad.dwProcessId = GetCurrentProcessId();

    dwGDI2Ret = GetDriverInfo2(&dwDrvRet, hDD,
                                   _NT_D3DGDI2_TYPE_FREE_DEFERRED_AGP,
                                   sizeof(fad), &fad);

    //drop the return code on the floor.... just a notification
}

void InformDriverToDeferFrees(HANDLE hDD)
{
    DDNT_FREE_DEFERRED_AGP_DATA   fad;
    DWORD                       dwDrvRet;
    DWORD                       dwGDI2Ret;

    fad.dwProcessId = GetCurrentProcessId();

    dwGDI2Ret = GetDriverInfo2(&dwDrvRet, hDD,
                                   _NT_D3DGDI2_TYPE_DEFER_AGP_FREES,
                                   sizeof(fad), &fad);

    //drop the return code on the floor.... just a notification
}

/*****************************Private*Routine******************************\
* D3D8CreateDirectDrawObject
*
* Calls GDI32 to get the global DirectDraw handle.
*
* History:
*  16-Nov-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8CreateDirectDrawObject"

VOID
APIENTRY
D3D8CreateDirectDrawObject(
    HDC             hdc,
    char*           szDeviceName,
    HANDLE*         phDD,
    D3DDEVTYPE      Type,
    HINSTANCE*      phLibrary,
    VOID*           pInitFunction
   )
{
    DDRAWI_DIRECTDRAW_GBL   ddg;
    PDDDEVICEHANDLE         pDeviceHandle;
    HKEY                    hKey = (HKEY) NULL;

    *phDD = NULL;
    ddg.hDD = 0;
    pDeviceHandle = NULL;
    DdCreateDirectDrawObject (&ddg, hdc);

    if (ddg.hDD != 0)
    {
        pDeviceHandle = MemAlloc (sizeof(DDDEVICEHANDLE));
        if (pDeviceHandle != NULL)
        {
            pDeviceHandle->hDD = (HANDLE)ddg.hDD;
            *phDD = (HANDLE) pDeviceHandle;
            lstrcpy (pDeviceHandle->szDeviceName, szDeviceName);
            pDeviceHandle->DisplayUniqueness =
                DdQueryDisplaySettingsUniqueness();
            pDeviceHandle->hLastWnd = NULL;
            pDeviceHandle->pClipList = NULL;
            pDeviceHandle->pOrigClipList = NULL;
            *phLibrary = NULL;
            pDeviceHandle->DeviceType = Type;
            if (Type == D3DDEVTYPE_REF)
            {
                *phLibrary = LoadLibrary (D3D8_REFRASTNAME);
                pDeviceHandle->pDD = SwDDICreateDirectDraw();
                if (pDeviceHandle->pDD == NULL)
                {
                    *phDD = NULL;
                }
                else
                {
                    pDeviceHandle->hLibrary = *phLibrary;
                }
            }
            else if (Type == D3DDEVTYPE_SW)
            {
                pDeviceHandle->pDD = SwDDICreateDirectDraw();
                if (pDeviceHandle->pDD == NULL)
                {
                    *phDD = NULL;
                }
                else
                {
                    pDeviceHandle->pSwInitFunction = pInitFunction;
                }
            }
        }
    }

    if (*phDD == NULL)
    {
        if (pDeviceHandle)
        {
            MemFree (pDeviceHandle);
        }

        if (ddg.hDD != 0)
        {
            OsThunkDdDeleteDirectDrawObject((HANDLE) ddg.hDD);
        }
    }
    else
    {
        // See if they want to explicitly enable/disable driver behavior
        if (!RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
        {
            DWORD   type;
            DWORD   value;
            DWORD   cb = sizeof(value);

            pDeviceHandle->ForceFlagsOn = 0;
            pDeviceHandle->ForceFlagsOff = 0;
#ifdef DEBUG
            if (!RegQueryValueEx(hKey, "ForceDriverFlagsOn", NULL, &type, (CONST LPBYTE)&value, &cb))
            {
                pDeviceHandle->ForceFlagsOn = value;
            }
            cb = sizeof(value);
#endif
            if (!RegQueryValueEx(hKey, "ForceDriverFlagsOff", NULL, &type, (CONST LPBYTE)&value, &cb))
            {
                pDeviceHandle->ForceFlagsOff = value;
            }
            RegCloseKey(hKey);
        }
        NumDevices++;
    }
}

/*****************************Private*Routine******************************\
* D3D8DeleteDirectDrawObject
*
* Note that all associated surface objects must be deleted before the
* DirectDrawObject can be deleted.
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8DeleteDirectDrawObject"

VOID
APIENTRY
D3D8DeleteDirectDrawObject(
    HANDLE hDD
   )
{
    PDDDEVICEHANDLE pHandle = (PDDDEVICEHANDLE) hDD;
    PDEFERREDCREATE pTemp;

    NumDevices--;
    if (pHandle!= NULL)
    {
        PDEFERREDCREATE pDefCreate = pHandle->pDeferList;

        OsThunkDdDeleteDirectDrawObject(DDHANDLE(hDD));
        if (NULL != pHandle->SurfaceHandleList.dwList)
        {
            MemFree(pHandle->SurfaceHandleList.dwList);
        }
        if (NULL != pHandle->pDD)
        {
            if ( NULL != pHandle->pDD->lpGbl->lpDDCBtmp)
            {
                MemFree(pHandle->pDD->lpGbl->lpDDCBtmp);
            }
            MemFree(pHandle->pDD);
        }
        if (NULL != pHandle->pClipList)
        {
            MemFree(pHandle->pClipList);
        }
        if (NULL != pHandle->pOrigClipList)
        {
            MemFree(pHandle->pOrigClipList);
        }
#ifdef DEBUG
        // In debug print the types of objects
        // that weren't released
        if (pHandle->pSurfList != NULL)
        {
            PDDSURFHANDLE pSurf = pHandle->pSurfList;
            DPF_ERR("Not all objects were freed: the following indicate "
                    "the types of unfreed objects.");
            while (pSurf)
            {
                DebugPrintSurfaceInfo(pSurf);
                pSurf = pSurf->pNext;
            }
        }
#endif
        while (pDefCreate != NULL)
        {
            pTemp = pDefCreate->pNext;
            MemFree(pDefCreate->CreateData.pSList);
            MemFree(pDefCreate);
            pDefCreate = pTemp;
        }
        DDASSERT(pHandle->pSurfList == NULL);
        DDASSERT(pHandle->pContext == NULL);

        MemFree(hDD);
    }
}

/*****************************Private*Routine******************************\
* DdGetDC
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8GetDC"

HDC
APIENTRY
D3D8GetDC(
    HANDLE                    hSurface,
    LPPALETTEENTRY            pPalette
   )
{
    if (CheckForDeviceLost((HANDLE)((PDDSURFHANDLE)hSurface)->pDevice))
    {
        return NULL;
    }
    return(OsThunkDdGetDC(GetSurfHandle(hSurface), pPalette));
}

/*****************************Private*Routine******************************\
* DdReleaseDC
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8ReleaseDC"

BOOL
APIENTRY
D3D8ReleaseDC(
    HANDLE                  hSurface,
    HDC                     hdc
   )
{
    DDASSERT(hdc != NULL);

    return(OsThunkDdReleaseDC(GetSurfHandle(hSurface)));
}

/*****************************Private*Routine******************************\
* DdReenableDirectDrawObject
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8ReenableDirectDrawObject"

BOOL
APIENTRY
D3D8ReenableDirectDrawObject(
    HANDLE                  hDD,
    BOOL*                   pbNewMode
   )
{
    BOOL    bRet;
    PDDDEVICEHANDLE pHandle = (PDDDEVICEHANDLE) hDD;

    bRet = OsThunkDdReenableDirectDrawObject(DDHANDLE(hDD),
                                           pbNewMode);

    if (!bRet && 
        ((pHandle->DeviceType == D3DDEVTYPE_REF) || 
            (pHandle->DeviceType == D3DDEVTYPE_SW)) &&
        !(pHandle->DDCaps & ~DDCAPS_NOHARDWARE))
    {
        bRet = TRUE;
    }

    return bRet;
}

/*****************************Private*Routine******************************\
* DdSetGammaRamp
*
* History:
*  18-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8SetGammaRamp"

BOOL
APIENTRY
D3D8SetGammaRamp(
    HANDLE      hDD,
    HDC         hdc,
    LPVOID      lpGammaRamp
   )
{
    if (CheckForDeviceLost(hDD))
    {
        return TRUE;
    }

    return(OsThunkDdSetGammaRamp(DDHANDLE(hDD), hdc,
        lpGammaRamp));
}

/*****************************Private*Routine******************************\
* D3D8BuildModeTable
*
* History:
*  15-Dec-1999 -by- smac
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8BuildModeTable"

VOID
APIENTRY
D3D8BuildModeTable(
    char*               pszDevice,
    D3DDISPLAYMODE*     pModeTable,
    DWORD*              pNumEntries,
    D3DFORMAT           Unknown16,
    HANDLE              hProfile,
    BOOL                b16bppSupported,
    BOOL                b32bppSupported
   )
{
    int             i;
    int             j;
    DEVMODE         dm;
    D3DFORMAT       format;
    int             NumTempEntries = 0;
    DWORD           NumActualEntries = 0;

    dm.dmSize = sizeof(dm);
    for (i = 0; EnumDisplaySettings(pszDevice, i, &dm); ++i)
    {
        // Filter out all modes other than 15, 16 and 32bpp
        if ((dm.dmBitsPerPel != 15) &&
            (dm.dmBitsPerPel != 16) &&
            (dm.dmBitsPerPel != 32))
        {
            continue;
        }

        if (((dm.dmBitsPerPel == 15) ||
             (dm.dmBitsPerPel == 16)) &&
            !b16bppSupported)
        {
            continue;
        }
        else if ((dm.dmBitsPerPel == 32) &&
            !b32bppSupported)
        {
            continue;
        }
       
        // Make sure that we understand the format.

        if ((dm.dmBitsPerPel == 16) ||
            (dm.dmBitsPerPel == 15))
        {
            format = Unknown16;
        }
        else
        {
            DDASSERT(dm.dmBitsPerPel == 32);
            format = D3DFMT_X8R8G8B8;
        }

        if (pModeTable != NULL)
        {
            ///The caller must pass us a number
            DDASSERT( (*pNumEntries) );
            if ( NumActualEntries >= (*pNumEntries) )
            {
                //we exceeded the number of entries allocated for us.
                //tell the caller to re-query and try again.
                NumActualEntries = 0;
                break;
            }

            // Add the new mode.
            pModeTable[NumActualEntries].Width       = dm.dmPelsWidth;
            pModeTable[NumActualEntries].Height      = dm.dmPelsHeight;
            pModeTable[NumActualEntries].RefreshRate = dm.dmDisplayFrequency;
            pModeTable[NumActualEntries].Format      = format;
        }
         
        NumActualEntries++;

    }

    //The caller will either pass a NULL modelist pointer, in which case
    //it is expecting us to fill in the number of entries. If the modelist
    // is non-null, the caller expects us to fill the table but not
    // overwrite. If we find the table has grown, ask the caller to 
    // re-allocate by returning 0 modes.
    (*pNumEntries) = NumActualEntries;
}

/*****************************Private*Routine******************************\
* D3D8IsDeviceLost
*
* History:
*  15-Dec-1999 -by- smac
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8IsDeviceLost"

BOOL
APIENTRY
D3D8IsDeviceLost(
    HANDLE  hDD
   )
{
    return CheckForDeviceLost(hDD);
}

/*****************************Private*Routine******************************\
* D3D8CanRestoreNow
* 15-Dec-1999 -by- smac
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8CanRestoreNow"

BOOL
APIENTRY
D3D8CanRestoreNow(
    HANDLE  hDD
   )
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    BOOL            bNewMode;
    D3D8_DRIVERCAPS DriverData;
    D3D8_GLOBALDRIVERDATA D3DGlobalDriverData;
    D3DHAL_D3DEXTENDEDCAPS D3DExtendedCaps;
    D3D8_CALLBACKS  Callbacks;
    UINT            uiDummy;

    // If we aren't lost, then it's an easy call

    if (!CheckForDeviceLost(hDD))
    {
        return TRUE;
    }

    // Otherwise, we actually need to call the kernel and look at the caps

    memset(&DriverData, 0, sizeof(DriverData));
    memset(&D3DGlobalDriverData, 0, sizeof(D3DGlobalDriverData));
    memset(&D3DExtendedCaps, 0, sizeof(D3DExtendedCaps));
    memset(&Callbacks, 0, sizeof(Callbacks));
    if (!D3D8ReenableDirectDrawObject (hDD,&bNewMode) ||
        !D3D8QueryDirectDrawObject(hDD,
                                   &DriverData,
                                   &Callbacks,
                                   pDeviceHandle->szDeviceName,
                                   pDeviceHandle->hLibrary,
                                   &D3DGlobalDriverData,
                                   &D3DExtendedCaps,
                                   NULL,NULL,&uiDummy,&uiDummy))
    {
        return FALSE;
    }

    if (IS_SOFTWARE_DRIVER(hDD) ||
        ((DriverData.D3DCaps.Caps & DDCAPS_3D) &&
        (Callbacks.DrawPrimitives2 != NULL)))
    {
        return TRUE;
    }

    return FALSE;
}

/*****************************Private*Routine******************************\
* D3D8RestoreDevice
* 15-Dec-1999 -by- smac
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8RestoreDevice"

void
APIENTRY
D3D8RestoreDevice (
    HANDLE hDD
   )
{
    HRESULT hr;
    DWORD i, j, k;
    DWORD Width, Height, Depth;
    BYTE *SliceSrc, *SliceDst, *RowSrc, *RowDst;
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFHANDLE pSurf;
    PD3DCONTEXTHANDLE pContext = pDeviceHandle->pContext;
    PDEFERREDCREATE pDefCreate = pDeviceHandle->pDeferList;
    PDEFERREDCREATE *ppNext = &pDeviceHandle->pDeferList;
    PDEFERREDCREATE pTemp;
    D3D8_LOCKDATA LockData;
    D3D8_UNLOCKDATA UnlockData;
    ULONG_PTR pVidmem[32 * 6];

    // First, say that we aren't lost anymore

    pDeviceHandle->DisplayUniqueness =
        DdQueryDisplaySettingsUniqueness();
    pDeviceHandle->bDeviceLost = FALSE;
    pDeviceHandle->dwFlags &= ~DDDEVICE_DP2ERROR;

    // Now, check for any sysmem surfaces that were created while
    // the device was lost and call CreateSurfaceEx if they need it.

    pSurf = pDeviceHandle->pSurfList;

    while (pSurf != NULL)
    {
        if ((pSurf->dwCookie != 0) &&
            (pSurf->dwFlags & DDSURF_DEFERCREATEEX))
        {
            hr = OsThunkDdCreateSurfaceEx(
                    DDHANDLE(hDD),
                    pSurf->hSurface,
                    pSurf->dwCookie);
            if (SUCCEEDED(hr))
            {
                pSurf->dwFlags &= ~DDSURF_DEFERCREATEEX;
            }
            else
            {
                // TODO: Handle error condition
                DPF(0, "CreateSurfaceEx failed when resurrecting sysmem or D3D managed surfaces");
            }
        }
        pSurf = pSurf->pNext;
    }

    // Now, create the D3D context if we need to.

    if ((pContext != NULL) &&
        (pContext->dwFlags & D3DCONTEXT_DEFERCREATE))
    {
        D3D8_CONTEXTCREATEDATA  ContextData;

        memset(&ContextData, 0, sizeof(ContextData));
        ContextData.hDD = DDHANDLE(hDD);
        ContextData.dwPID = pContext->dwPID;
        ContextData.dwhContext = (ULONG_PTR) pContext->hDeferHandle;

        OsThunkD3dContextCreate(DDHANDLE(hDD),
            GetSurfHandle(pContext->pSurface),
            GetSurfHandle(pContext->pDDSZ),
            (D3DNTHAL_CONTEXTCREATEI *)&ContextData);

        if (SUCCEEDED(ContextData.ddrval))
        {
            pContext->dwhContext = (HANDLE) ContextData.dwhContext;
            pContext->dwFlags &= ~D3DCONTEXT_DEFERCREATE;
        }
        else
        {
            // TODO: Handle error condition
        }
    }

    // Finally resurrect our deferred driver managed surfaces (Gulp!)

    while (pDefCreate != NULL)
    {
        DDASSERT(pDefCreate->CreateData.dwSCnt <= 32 * 6);

        // First check if the deferred surface exists at all. The problem
        // is that DdDestroySurface could have been called. We could have
        // removed the surface from the deferred list in DdDestroySurface
        // but since DdDestroySurface is called piecemeal, it gets
        // very annoying. The removal is best done here.
        // ASSUMPTION: if pSList[0].hKernelHandle is NULL then
        // pSList[1,2,etc].hKernelHandle are also NULL. There is no
        // reason for this to be not the case as of 3/2001.

        if (pDefCreate->CreateData.pSList[0].hKernelHandle == NULL)
        {
            pTemp = pDefCreate->pNext;
            *ppNext = pTemp;
            MemFree(pDefCreate->CreateData.pSList);
            MemFree(pDefCreate);
            pDefCreate = pTemp;
            continue;
        }

        // Save off all the fpVidmems since they will be overwritten

        for (i = 0; i < pDefCreate->CreateData.dwSCnt; i++)
        {
            pSurf = (PDDSURFHANDLE) pDefCreate->CreateData.pSList[i].hKernelHandle;
            pVidmem[i] = pSurf->fpVidMem;
        }

        // Attempt to resurrect

        pDefCreate->CreateData.bReUse = TRUE;
        hr = DdCreateSurface(&pDefCreate->CreateData);
        if (SUCCEEDED(hr))
        {
            for (i = 0; i < pDefCreate->CreateData.dwSCnt; i++)
            {
                pSurf = (PDDSURFHANDLE) pDefCreate->CreateData.pSList[i].hKernelHandle;

                // Reset DDSURF_SYSMEMALLOCATED to keep DdLock below happy

                pSurf->dwFlags &= ~DDSURF_SYSMEMALLOCATED;

                // Lock and copy

                ZeroMemory(&LockData, sizeof(LockData));
                LockData.hDD = hDD;
                LockData.hSurface = pSurf;
                hr = DdLock(&LockData);
                if (SUCCEEDED(hr))
                {
                    SliceSrc = (BYTE*)pVidmem[i];
                    SliceDst = (BYTE*)LockData.lpSurfData;
                    Width = pDefCreate->CreateData.pSList[i].cpWidth;
                    Height = pDefCreate->CreateData.pSList[i].cpHeight;
                    Depth = pDefCreate->CreateData.pSList[i].cpDepth;
                    if (!(pDefCreate->CreateData.Type == D3DRTYPE_VOLUME ||
                        pDefCreate->CreateData.Type == D3DRTYPE_VOLUMETEXTURE))
                    {
                        Depth = 1;
                    }
                    for (j = 0; j < Depth; ++j)
                    {
                        RowSrc = SliceSrc;
                        RowDst = SliceDst;
                        for (k = 0; k < Height; ++k)
                        {
                            CopyMemory(RowDst, RowSrc, min(LockData.lPitch, (LONG)Width * 8));
                            RowSrc += Width * 8;
                            RowDst += LockData.lPitch;
                        }
                        SliceSrc += Width * Height * 8;
                        SliceDst += LockData.lSlicePitch;
                    }

                    ZeroMemory(&UnlockData, sizeof(UnlockData));
                    UnlockData.hDD = hDD;
                    UnlockData.hSurface = pSurf;
                    hr = DdUnlock(&UnlockData);
                    if (FAILED(hr))
                    {
                        // TODO: Handle/(ignore?) failure 
                        DPF(0,"Unlock failed when resurrecting driver managed surface.");
                    }
                }
                else
                {
                    // TODO: Handle/(ignore?) failure 
                    DPF(0,"Lock failed when resurrecting driver managed surface. Texture may go missing.");
                }

                // Free the temporary fpVidmem that we allocated in CreateVidmemSurface
            
                MemFree((VOID*)pVidmem[i]);
            }

            // Remove from list and freeup all memory
     
            pTemp = pDefCreate->pNext;
            *ppNext = pTemp;
            MemFree(pDefCreate->CreateData.pSList);
            MemFree(pDefCreate);
            pDefCreate = pTemp;
        }
        else
        {
            // We set ReUse to FALSE to indicate that we were not able to resurrect
            pDefCreate->CreateData.bReUse = FALSE;

            ppNext = &(pDefCreate->pNext);
            pDefCreate = pDefCreate->pNext;
        }
    }

    if (pDeviceHandle->pDeferList != NULL)
    {
        // TODO:
        // Ummm, we were not able to resurrect. This may be due to out of memory
        // or if a mode switch happened as we were trying to Reset (ACK!). The
        // former probably needs to be reported to the app. The latter is
        // probably harmless, because the app will eventually realize this and
        // try again.
        DPF(0,"Unable to resurrect all driver managed surfaces.");
    }
}
                     

/*****************************Private*Routine******************************\
* D3D8AreVidmemSurfaces
* 15-Dec-1999 -by- smac
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8DoVidmemSurfacesExist "

BOOL
APIENTRY
D3D8DoVidmemSurfacesExist (
    HANDLE hDD
   )
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFHANDLE pSurf;

    // Walk the list and return TRUE is we find any surfaces that are either
    // local or nonlocal vidmem.

    pSurf = pDeviceHandle->pSurfList;
    while (pSurf != NULL)
    {
        if ((pSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
            (pSurf->Pool == D3DPOOL_NONLOCALVIDMEM) ||
            (pSurf->dwFlags & DDSURF_TREATASVIDMEM))
        {
#if DBG
            DPF(0,"The following D3DPOOL_DEFAULT surfaces/buffers/textures still exist");
            pSurf = pDeviceHandle->pSurfList;
            while (pSurf != NULL)
            {
                if ((pSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
                    (pSurf->Pool == D3DPOOL_NONLOCALVIDMEM) ||
                    (pSurf->dwFlags & DDSURF_TREATASVIDMEM))
                {
                    DebugPrintSurfaceInfo(pSurf);
                }
                pSurf = pSurf->pNext;
            }
#endif

            return TRUE;
        }
        pSurf = pSurf->pNext;
    }

    // Is this the first time that the device has become ready?
    if (!(pDeviceHandle->dwFlags & DDDEVICE_READY) &&
        (pDeviceHandle->bDeviceLost))
    {
        pDeviceHandle->dwFlags |= DDDEVICE_READY;
        if (++NumReadyDevices == NumDevices)
        {
            InformDriverFreeAGP(pDeviceHandle);
        }
    }

    return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3D8BeginProfile"

HANDLE
APIENTRY
D3D8BeginProfile(
    char*           pDeviceName)
{
    return NULL;
}
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8EndProfile"

void
APIENTRY
D3D8EndProfile(
    HANDLE  Handle)
{
}

DWORD APIENTRY D3D8SetCooperativeLevel(
    HANDLE hDD,
    HWND hWnd,
    DWORD dwFlags )
{
    return S_OK;
}

BOOL APIENTRY D3D8IsDummySurface(
    HANDLE hSurface )
{
    return FALSE;
}

VOID APIENTRY D3D8LoseDevice(
    HANDLE hDD )
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFHANDLE   pSurf;

    if (!pDeviceHandle->bDeviceLost)
    {
        pDeviceHandle->bDeviceLost  = TRUE;
        pSurf = pDeviceHandle->pSurfList;
        while (pSurf != NULL)
        {
            if (IS_SURFACE_LOOSABLE(pSurf))
            {
                FreeSurfaceObject(pSurf);
                pSurf->fpVidMem = (ULONG_PTR) NULL;
            }
            pSurf = pSurf->pNext;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\ddcreate.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddcreate.c
 *  Content:    DirectDraw create object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   31-dec-94  craige  initial implementation
 *   13-jan-95  craige  re-worked to updated spec + ongoing work
 *   21-jan-95  craige  made 32-bit + ongoing work
 *   13-feb-94  craige  allow 32-bit callbacks
 *   21-feb-95  craige  disconnect anyone who forgot to do it themselves
 *   27-feb-95  craige  new sync. macros
 *   06-mar-95  craige  HEL integration
 *   08-mar-95  craige  new APIs
 *   11-mar-95  craige  palette stuff
 *   15-mar-95  craige  more HEL integration
 *   19-mar-95  craige  use HRESULTs, process termination cleanup fixes
 *   27-mar-95  craige  linear or rectangular vidmem
 *   28-mar-95  craige  removed Get/SetColorKey, added FlipToGDISurface
 *   29-mar-95  craige  reorg to only call driver once per creation, and
 *                      to allow driver to load us first
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  fill in free video memory
 *   09-apr-95  craige  fixed deadlock situation with a process having a lock
 *                      on the primary surface while another process starts
 *   12-apr-95  craige  bug when driver object freed (extra leave csect)
 *   13-apr-95  craige  EricEng's little contribution to our being late
 *   15-apr-95  craige  fail load if no DD components present
 *   06-may-95  craige  use driver-level csects only
 *   09-may-95  craige  escape call to get 32-bit DLL
 *   12-may-95  craige  added DirectDrawEnumerate; use GUIDs in DirectDrawCreate
 *   14-may-95  craige  call DoneExclusiveMode during CurrentProcessCleanup
 *   15-may-95  craige  restore display mode on a per-process basis
 *   19-may-95  craige  memory leak on mode change
 *   23-may-95  craige  added Flush, GetBatchLimit, SetBatchLimit
 *   24-may-95  craige  plugged another memory leak; allow fourcc codes &
 *                      number of vmem heaps to change
 *   26-may-95  craige  somebody freed the vmem heaps and then tried to
 *                      free the surfaces!
 *   28-may-95  craige  unicode support; make sure blt means at least srccopy
 *   05-jun-95  craige  removed GetVersion, FreeAllSurfaces, DefWindowProc;
 *                      change GarbageCollect to Compact
 *   06-jun-95  craige  call RestoreDisplayMode
 *   07-jun-95  craige  removed DCLIST
 *   12-jun-95  craige  new process list stuff
 *   16-jun-95  craige  new surface structure
 *   18-jun-95  craige  specify pitch for rectangular memory; deadlock
 *                      with MemAlloc16 if we don't take the DLL lock
 *   25-jun-95  craige  one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   27-jun-95  craige  replaced batch limit/flush stuff with BltBatch
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns
 *   02-jul-95  craige  new registry format
 *   03-jul-95  craige  YEEHAW: new driver struct; SEH
 *   06-jul-95  craige  RemoveFromDriverList was screwing up links
 *   07-jul-95  craige  added pdevice stuff
 *   08-jul-95  craige  call InvalidateAllSurfaces
 *   10-jul-95  craige  support SetOverlayPosition
 *   11-jul-95  craige  validate pdevice is from a dibeng mini driver;
 *                      fail aggregation calls; one ddraw object/process
 *   13-jul-95  craige  ENTER_DDRAW is now the win16 lock; need to
 *                      leave Win16 lock while doing ExtEscape calls
 *   14-jul-95  craige  allow driver to specify heap is already allocated
 *   15-jul-95  craige  invalid HDC set in emulation only
 *   18-jul-95  craige  need to initialize dwPreferredMode
 *   20-jul-95  craige  internal reorg to prevent thunking during modeset
 *   20-jul-95  toddla  zero DDHALINFO before thunking in case nobody home.
 *   22-jul-95  craige  emulation only needs to initialize correctly
 *   29-jul-95  toddla  added DEBUG code to clear driver caps
 *   31-jul-95  toddla  added DD_HAL_VERSION
 *   31-jul-95  craige  set DDCAPS_BANKSWITCHED
 *   01-aug-95  toddla  added dwPDevice to DDRAWI_DIRECTDRAW_GBL
 *   10-aug-95  craige  validate alignment fields
 *   13-aug-95  craige  check DD_HAL_VERSION & set DDCAPS2_CERTIFIED
 *   21-aug-95  craige  mode X support
 *   27-aug-95  craige  bug 738: use GUID instead of IID
 *   05-sep-95  craige  bug 814
 *   08-sep-95  craige  bug 845: reset driver callbacks every time
 *   09-sep-95  craige  bug 949: don't allow ddraw to run in 4bpp
 *                      bug 951: NULL out fn tables at reset
 *   10-sep-95  toddla  dont allow DirectDrawCreate to work for < 8bpp mode.
 *   10-sep-95  toddla  added Message box when DirectDrawCreate fails
 *   20-sep-95  craige  made primary display desc. a string resource
 *   21-sep-95  craige  bug 1215: let ddraw16 know about certified for modex
 *   21-nov-95  colinmc made Direct3D a queryable interface off DirectDraw
 *   27-nov-95  colinmc new member to return available vram of a given type
 *                      (defined by DDSCAPS)
 *   05-dec-95  colinmc changed DDSCAPS_TEXTUREMAP => DDSCAPS_TEXTURE for
 *                      consitency with Direct3D
 *   09-dec-95  colinmc execute buffer support
 *   15-dec-95  colinmc fixed bug setting HAL up for execute buffers
 *   25-dec-95  craige  added InternalDirectDrawCreate for ClassFactory work
 *   31-dec-95  craige  more ClassFactory work
 *   04-jan-96  kylej   add driver interface structures
 *   22-jan-96  jeffno  NT driver conversation in createSurface.
 *                      Since vidmem ptrs can legally be 0 for kernel, added
 *                      DDRAWISURFACEGBL_ISGDISURFACE and use that to find gdi
 *   02-feb-96  kylej   Move HAL function pointers to local object
 *   28-feb-96  kylej   Change DDHALINFO structure
 *   02-mar-96  colinmc Repulsive hack to support interim drivers
 *   06-mar-96  kylej   init HEL even with non-display drivers
 *   13-mar-96  craige  Bug 7528: hw that doesn't have modex
 *   13-mar-96  jeffno  Dynamic mode switch support for NT
 *                      Register process IDs with NT kernel stuff
 *   16-mar-96  colinmc Callback tables now initialized in dllmain
 *   18-mar-96  colinmc Bug 13545: Independent clippers cleanup
 *   22-mar-96  colinmc Bug 13316: uninitialized interfaces
 *   23-mar-96  colinmc Bug 12252: Direct3D not cleaned up properly on crash
 *   14-apr-96  colinmc Bug 17736: No driver notification of flip to GDI
 *   16-apr-96  colinmc Bug 17921: Remove interim driver support
 *   19-apr-96  colinmc Bug 18059: New caps bit to indicate that driver
 *                      can't interleave 2D and 3D operations during scene
 *                      rendering
 *   11-may-96  colinmc Bug 22293: Now validate GUID passed to DirectDraw
 *                      Create in retail as well as debug
 *   16-may-96  colinmc Bug 23215: Not checking for a mode index of -1
 *                      on driver initialization
 *   27-may-96  kylej   Bug 24595: Set Certified bit after call to
 *                      FakeDDCreateDriverObject.
 *   26-jun-96  colinmc Bug 2041: DirectDraw needs time bomb
 *   22-jul-96  colinmc Work Item: Minimal stackable driver support
 *   23-aug-96  craige  registry entries for sw only and modex only
 *   31-aug-96  colinmc Removed erroneous time bomb
 *   03-sep-96  craige  App compatibilty stuff
 *   01-oct-96  ketand  added GetAvailVidMem entrypoint for driver callbacks
 *   05-sep-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   10-oct-96  colinmc Refinements of the Win16 locking stuff
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   15-oct-96  toddla  support multimonitor
 *   09-nov-96  colinmc Fixed problem with old and new drivers not working
 *                      with DirectDraw
 *   17-nov-96  colinmc Added ability to use PrintScrn key to snapshot
 *                      DirectDraw applications.
 *   08-dec-96  colinmc Initial AGP support
 *   21-jan-97  ketand  Added a rectMonitor to lpDD_gbl to allow for correct clipping
 *                      on multi-monitor systems.
 *   25-jan-97  nwilt   Instance GUID in GetDriverInfo struct
 *                      Query for D3DCallbacks2 w/no deps on D3D
 *   27-jan-97  colinmc Fixed problem with multi-mon on emulated displays
 *   27-jan-97  ketand  Multi-mon. Remove bad globals; pass them explicitly. Fix ATTENTIONs.
 *   29-jan-97  smac    Removed old ring 0 code
 *   30-jan-97  colinmc Work item 4125: Add time bomb for beta
 *   30-jan-97  jeffno  Allow surfaces wider than the primary
 *   30-jan-97  ketand  Only enumerate secondaries for multi-mon systems.
 *   01-feb-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *   07-feb-97  ketand  Zero DisplayDevice struct between calls to EnumDisplayDevices.
 *                      Fix memory leak w.r.t. GetAndValidateNewHalInfo
 *   24-feb-97  ketand  Update Rects whenever a display change occurs.
 *   24-feb-97  ketand  Add a dwContext to GetDriverInfoData
 *   03-mar-97  smac    Added kernel mode interface
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   08-mar-97  colinmc Added support for DMA style AGP usage
 *   11-mar-97  jeffno  Asynchronous DMA support
 *   11-mar-97  nwilt   Fail driver create if driver exports some DrawPrimitive
 *                      exports without exporting all of them.
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   20-mar-97  nwilt   #6625 and D3D extended caps
 *   24-mar-97  jeffno  Optimized Surfaces
 *   13-may-97  colinmc AGP support on OSR 2.1 systems
 *   26-may-97  nwilt   Fail driver create if driver sets D3DDEVCAPS_DRAWPRIMTLVERTEX
 *                      without exporting the callbacks.
 *   31-jul-97 jvanaken Bug 7093:  Ensure unique HDC for each process/driver pair
 *                      in a multimonitor system.
 *   16-sep-97  jeffno  DirectDrawEnumerateEx
 *   30-sep-97  jeffno  IDirectDraw4
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   05-nov-97 jvanaken Support for master sprite list in SetSpriteDisplayList
 *
 ***************************************************************************/
extern "C" {
#include "ddrawpr.h"

#ifdef WINNT
    #include "ddrawgdi.h"
    #define BUILD_DDDDK
    #include "d3dhal.h"
#endif

#ifdef WIN95
#include "d3dhal.h"
#endif

} // extern C

#include "pixel.hpp"

#ifdef DEBUG
    #define static
#endif

#undef DPF_MODNAME
#define DPF_MODNAME     "DirectDrawObjectCreate"

#define DISPLAY_STR     "display"

#define D3DFORMAT_OP_BACKBUFFER                 0x00000020L

char g_szPrimaryDisplay[MAX_DRIVER_NAME] = "";

void getPrimaryDisplayName(void);


#ifndef WIN16_SEPARATE
    #ifdef WIN95
        CRITICAL_SECTION ddcCS = {0};
        #define ENTER_CSDDC() EnterCriticalSection(&ddcCS)
        #define LEAVE_CSDDC() LeaveCriticalSection(&ddcCS)
    #else
        #define ENTER_CSDDC()
        #define LEAVE_CSDDC()
    #endif
#else
    #define ENTER_CSDDC()
    #define LEAVE_CSDDC()
#endif


/*
 * DISPLAY_DEVICEA
 *
 * define a local copy of the structures and constants needed
 * to call EnumDisplayDevices
 *
 */
#ifndef DISPLAY_DEVICE_ATTACHED_TO_DESKTOP
#define DISPLAY_DEVICE_ATTACHED_TO_DESKTOP 0x00000001
#define DISPLAY_DEVICE_MULTI_DRIVER        0x00000002
#define DISPLAY_DEVICE_PRIMARY_DEVICE      0x00000004
#define DISPLAY_DEVICE_MIRRORING_DRIVER    0x00000008
#define DISPLAY_DEVICE_VGA                 0x00000010
typedef struct {
    DWORD  cb;
    CHAR   DeviceName[MAX_DRIVER_NAME];
    CHAR   DeviceString[128];
    DWORD  StateFlags;
} DISPLAY_DEVICEA;
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "MakeDX8Caps"

void 
MakeDX8Caps( D3DCAPS8 *pCaps8, 
             const D3D8_GLOBALDRIVERDATA*   pGblDrvData,
             const D3DHAL_D3DEXTENDEDCAPS*  pExtCaps )
{   
    // we shouldn't memset pCaps8 as members like Caps, Caps2, Caps3 (dwSVCaps) and 
    // CursorCaps are already set by Thunk layer
    
    pCaps8->DevCaps = pGblDrvData->hwCaps.dwDevCaps;

    pCaps8->PrimitiveMiscCaps  = pGblDrvData->hwCaps.dpcTriCaps.dwMiscCaps;
    pCaps8->RasterCaps         = pGblDrvData->hwCaps.dpcTriCaps.dwRasterCaps;
    pCaps8->ZCmpCaps           = pGblDrvData->hwCaps.dpcTriCaps.dwZCmpCaps;
    pCaps8->SrcBlendCaps       = pGblDrvData->hwCaps.dpcTriCaps.dwSrcBlendCaps;
    pCaps8->DestBlendCaps      = pGblDrvData->hwCaps.dpcTriCaps.dwDestBlendCaps;
    pCaps8->AlphaCmpCaps       = pGblDrvData->hwCaps.dpcTriCaps.dwAlphaCmpCaps;
    pCaps8->ShadeCaps          = pGblDrvData->hwCaps.dpcTriCaps.dwShadeCaps;
    pCaps8->TextureCaps        = pGblDrvData->hwCaps.dpcTriCaps.dwTextureCaps;
    pCaps8->TextureFilterCaps  = pGblDrvData->hwCaps.dpcTriCaps.dwTextureFilterCaps;

        // Adjust the texture filter caps for the legacy drivers that 
        // set only the legacy texture filter caps and not the newer ones.
    if ((pCaps8->TextureFilterCaps & (D3DPTFILTERCAPS_MINFPOINT  |
                                      D3DPTFILTERCAPS_MAGFPOINT  |
                                      D3DPTFILTERCAPS_MIPFPOINT  |
                                      D3DPTFILTERCAPS_MINFLINEAR |
                                      D3DPTFILTERCAPS_MAGFLINEAR |
                                      D3DPTFILTERCAPS_MIPFLINEAR)) == 0)
    {
        if (pCaps8->TextureFilterCaps & D3DPTFILTERCAPS_NEAREST)
        {
            pCaps8->TextureFilterCaps |= (D3DPTFILTERCAPS_MINFPOINT | 
                                          D3DPTFILTERCAPS_MAGFPOINT);
        }

        if (pCaps8->TextureFilterCaps & D3DPTFILTERCAPS_LINEAR)
        { 
            pCaps8->TextureFilterCaps |= (D3DPTFILTERCAPS_MINFLINEAR |
                                          D3DPTFILTERCAPS_MAGFLINEAR);
        }

        if (pCaps8->TextureFilterCaps & D3DPTFILTERCAPS_MIPNEAREST)
        { 
            pCaps8->TextureFilterCaps |= (D3DPTFILTERCAPS_MINFPOINT |
                                          D3DPTFILTERCAPS_MAGFPOINT |
                                          D3DPTFILTERCAPS_MIPFPOINT);
        }

        if (pCaps8->TextureFilterCaps & D3DPTFILTERCAPS_MIPLINEAR)
        { 
            pCaps8->TextureFilterCaps |= (D3DPTFILTERCAPS_MINFLINEAR |
                                          D3DPTFILTERCAPS_MAGFLINEAR |
                                          D3DPTFILTERCAPS_MIPFPOINT);
        }

        if (pCaps8->TextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPNEAREST)
        { 
            pCaps8->TextureFilterCaps |= (D3DPTFILTERCAPS_MINFPOINT |
                                          D3DPTFILTERCAPS_MAGFPOINT |
                                          D3DPTFILTERCAPS_MIPFLINEAR);
        }

        if (pCaps8->TextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPLINEAR)
        { 
            pCaps8->TextureFilterCaps |= (D3DPTFILTERCAPS_MINFLINEAR |
                                          D3DPTFILTERCAPS_MAGFLINEAR |
                                          D3DPTFILTERCAPS_MIPFLINEAR);
        }
    }
        
    pCaps8->TextureAddressCaps = pGblDrvData->hwCaps.dpcTriCaps.dwTextureAddressCaps;

        // Set the cube-texture filter caps only if the device supports
        // cubemaps.
    if (pCaps8->TextureCaps & D3DPTEXTURECAPS_CUBEMAP)
    {
        pCaps8->CubeTextureFilterCaps    = pGblDrvData->hwCaps.dpcTriCaps.dwTextureFilterCaps;
    }
        
    const D3DPRIMCAPS* pTC = &pGblDrvData->hwCaps.dpcTriCaps;
    const D3DPRIMCAPS* pLC = &pGblDrvData->hwCaps.dpcLineCaps;
    if (pLC->dwTextureCaps) pCaps8->LineCaps |= D3DLINECAPS_TEXTURE ;
    if (pLC->dwZCmpCaps == pTC->dwZCmpCaps)
        pCaps8->LineCaps |= D3DLINECAPS_ZTEST;
    if ( (pLC->dwSrcBlendCaps == pTC->dwSrcBlendCaps) &&
         (pLC->dwDestBlendCaps == pTC->dwDestBlendCaps) )
        pCaps8->LineCaps |= D3DLINECAPS_BLEND;
    if (pLC->dwAlphaCmpCaps == pTC->dwAlphaCmpCaps)
        pCaps8->LineCaps |= D3DLINECAPS_ALPHACMP;
    if (pLC->dwRasterCaps & (D3DPRASTERCAPS_FOGVERTEX|D3DPRASTERCAPS_FOGTABLE))
        pCaps8->LineCaps |= D3DLINECAPS_FOG;

    if( pExtCaps->dwMaxTextureWidth == 0 )
        pCaps8->MaxTextureWidth = 256;
    else
        pCaps8->MaxTextureWidth  = pExtCaps->dwMaxTextureWidth;
    
    if( pExtCaps->dwMaxTextureHeight == 0 )
        pCaps8->MaxTextureHeight = 256;
    else
        pCaps8->MaxTextureHeight = pExtCaps->dwMaxTextureHeight;

    pCaps8->MaxTextureRepeat = pExtCaps->dwMaxTextureRepeat;
    pCaps8->MaxTextureAspectRatio = pExtCaps->dwMaxTextureAspectRatio;
    pCaps8->MaxAnisotropy = pExtCaps->dwMaxAnisotropy;
    pCaps8->MaxVertexW = pExtCaps->dvMaxVertexW;

    pCaps8->GuardBandLeft    = pExtCaps->dvGuardBandLeft;
    pCaps8->GuardBandTop     = pExtCaps->dvGuardBandTop;
    pCaps8->GuardBandRight   = pExtCaps->dvGuardBandRight;
    pCaps8->GuardBandBottom  = pExtCaps->dvGuardBandBottom;

    pCaps8->ExtentsAdjust = pExtCaps->dvExtentsAdjust;
    pCaps8->StencilCaps = pExtCaps->dwStencilCaps;

    pCaps8->FVFCaps = pExtCaps->dwFVFCaps;
    pCaps8->TextureOpCaps = pExtCaps->dwTextureOpCaps;
    pCaps8->MaxTextureBlendStages = pExtCaps->wMaxTextureBlendStages;
    pCaps8->MaxSimultaneousTextures = pExtCaps->wMaxSimultaneousTextures;

    pCaps8->VertexProcessingCaps = pExtCaps->dwVertexProcessingCaps;
    pCaps8->MaxActiveLights = pExtCaps->dwMaxActiveLights;
    pCaps8->MaxUserClipPlanes = pExtCaps->wMaxUserClipPlanes;
    pCaps8->MaxVertexBlendMatrices = pExtCaps->wMaxVertexBlendMatrices;
    if (pCaps8->MaxVertexBlendMatrices == 1)
        pCaps8->MaxVertexBlendMatrices = 0;

    //
    // Stuff in the DX8 caps that cannot be reported by the pre DX8 drivers
    //
    pCaps8->MaxPointSize = 0;
    pCaps8->MaxPrimitiveCount = 0xffff;
    pCaps8->MaxVertexIndex = 0xffff;
    pCaps8->MaxStreams = 0;
    pCaps8->MaxStreamStride = 255;
    pCaps8->MaxVertexBlendMatrixIndex = 0;
    pCaps8->MaxVolumeExtent  = 0;

    // Format is 8.8 in bottom of DWORD
    pCaps8->VertexShaderVersion = D3DVS_VERSION(0,0);
    pCaps8->MaxVertexShaderConst = 0;
    pCaps8->PixelShaderVersion = D3DPS_VERSION(0,0);
    pCaps8->MaxPixelShaderValue = 1.0f;

} // MakeDX8Caps

/*
 * xxxEnumDisplayDevices
 *
 * wrapper around the new Win32 API EnumDisplayDevices
 * uses GetProcAddress() so we run on Win95.
 *
 * this function exists in NT 4.0 and Win97 (Memphis) but not Win95
 *
 */
BOOL xxxEnumDisplayDevicesA(LPVOID lpUnused, DWORD iDevice, DISPLAY_DEVICEA *pdd, DWORD dwFlags)
{
    HMODULE h = GetModuleHandle("USER32");
    BOOL (WINAPI *pfnEnumDisplayDevices)(LPVOID, DWORD, DISPLAY_DEVICEA *, DWORD);

    *((void **)&pfnEnumDisplayDevices) = GetProcAddress(h,"EnumDisplayDevicesA");

    //
    // NT 4.0 had a EnumDisplayDevicesA but it does not have the same
    // number of params, so ignore it unless a GetMonitorInfoA exists too.
    //
    if (GetProcAddress(h,"GetMonitorInfoA") == NULL)
        pfnEnumDisplayDevices = NULL;

    if (pfnEnumDisplayDevices)
    {
        return (*pfnEnumDisplayDevices)(lpUnused, iDevice, pdd, dwFlags);
    }

    //else we emulate the function for 95, NT4:
    if (iDevice > 0)
        return FALSE;

    pdd->StateFlags = DISPLAY_DEVICE_PRIMARY_DEVICE;
    lstrcpy(pdd->DeviceName, DISPLAY_STR);
    LoadString(g_hModule, IDS_PRIMARYDISPLAY, pdd->DeviceString, sizeof(pdd->DeviceString));

    return TRUE;
}

// Multi-monitor defines; these are wrong in the TRANGO tree;
// so I need to define them here explicitly. When we move to
// something that matches Memphis/NT5 then we can remove these
#undef SM_XVIRTUALSCREEN
#undef SM_YVIRTUALSCREEN
#undef SM_CXVIRTUALSCREEN
#undef SM_CYVIRTUALSCREEN
#undef SM_CMONITORS
#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80

#ifndef ENUM_CURRENT_SETTINGS
#define ENUM_CURRENT_SETTINGS       ((DWORD)-1)
#endif


#ifdef WINNT
// This function gets the device rect by calling GetMonitorInfo.
// On Win98, we got this by calling EnumDisplaySettings, but this
// doesn't work on NT5 and reading the documentation, it never
// indicates that it should work, so we'll just do it the documented
// way.
HRESULT GetNTDeviceRect(LPSTR pDriverName, LPRECT lpRect)
{
    MONITORINFO MonInfo;
    HMONITOR hMon;

    MonInfo.cbSize = sizeof(MONITORINFO);
    if (_stricmp(pDriverName, DISPLAY_STR) == 0)
    {
        hMon = GetMonitorFromDeviceName(g_szPrimaryDisplay);
    }
    else
    {
        hMon = GetMonitorFromDeviceName(pDriverName);
    }
    if (hMon != NULL)
    {
        if (GetMonitorInfo(hMon, &MonInfo) != 0)
        {
            CopyMemory(lpRect, &MonInfo.rcMonitor, sizeof(RECT));
            return S_OK;
        }
    }
    return E_FAIL;
}
#endif


/*
 * IsVGADevice()
 *
 * determine if the passed device name is a VGA
 *
 */
BOOL IsVGADevice(LPSTR szDevice)
{
    //
    //  assume "DISPLAY" and "DISPLAY1" are VGA devices
    //
    if ((_stricmp(szDevice, DISPLAY_STR) == 0) ||
        ((szDevice[0] == '\\') &&
          (szDevice[1] == '\\') &&
          (szDevice[2] == '.')))
    {
        return TRUE;
    }

    return FALSE;
}

/*
 * This function is currently only used in NT
 */

#ifdef WINNT

BOOL GetDDStereoMode(LPDDRAWI_DIRECTDRAW_GBL pdrv,
                      DWORD dwWidth,
                      DWORD dwHeight,
                      DWORD dwBpp,
                      DWORD dwRefreshRate)
{
    DDHAL_GETDRIVERINFODATA     gdidata;
    HRESULT                     hres;
    DDSTEREOMODE                ddStereoMode;

    DDASSERT(pdrv != NULL);

    /*
     * If driver does not support GetDriverInfo callback, it also
     * has no extended capabilities to report, so we're done.
     */
    if (!VALIDEX_CODE_PTR (pdrv->pGetDriverInfo))
    {
        return FALSE;
    }

    /*
     * The mode can't be stereo if the driver doesn't support it...
     */
    if (0 == (pdrv->ddCaps.dwCaps2 & DDCAPS2_STEREO))
    {
        return FALSE;
    }

    ZeroMemory(&ddStereoMode, sizeof(DDSTEREOMODE));

    ddStereoMode.dwSize=sizeof(DDSTEREOMODE);
    ddStereoMode.dwWidth=dwWidth;
    ddStereoMode.dwHeight=dwHeight;
    ddStereoMode.dwBpp=dwBpp;
    ddStereoMode.dwRefreshRate=dwRefreshRate;

    ddStereoMode.bSupported = TRUE;

    /*
     * Get the actual driver data
     */
    memset(&gdidata, 0, sizeof(gdidata));
    gdidata.dwSize = sizeof(gdidata);
    gdidata.dwFlags = 0;
    gdidata.guidInfo = GUID_DDStereoMode;
    gdidata.dwExpectedSize = sizeof(DDSTEREOMODE);
    gdidata.lpvData = &ddStereoMode;
    gdidata.ddRVal = E_FAIL;

    // Pass a context variable so that the driver
    // knows which instance of itself to use
    // w.r.t. this function. These are different
    // values on Win95 and NT.
#ifdef WIN95
    gdidata.dwContext = pdrv->dwReserved3;
#else
    gdidata.dwContext = pdrv->hDD;
#endif

    return TRUE;

} /* GetDDStereoMode */

#endif //WINNT


/*
 * doneDC
 */
void DD_DoneDC(HDC hdc_dd)
{
    if (hdc_dd != NULL)
    {
        DPF(5, "DeleteDC 0x%x", hdc_dd);
        DeleteDC(hdc_dd);
        hdc_dd = NULL;
    }

} /* doneDC */

#undef DPF_MODNAME
#define DPF_MODNAME     "DirectDrawCreate"


/*
 * createDC
 *
 * create a new DC given a device name.
 * doneDC() should be called to free DC
 *
 * the following are valid for device names:
 *
 *      DISPLAY      - the main display device via CreateDC("DISPLAY", ...)
 *                     this is the normal case.
 *
 *      foobar       - the foobar.drv via CreateDC("foobar", ...)
 *                     used for secondary displays listed in the registry
 *
 *      \\.\DisplayX - display device X via CreateDC(NULL,"\\.\DisplayX",...)
 *                     used on Memphis and NT5 for secondary displays
 *
 */
HDC DD_CreateDC(LPSTR pdrvname)
{
    HDC         hdc;
    UINT        u;

    DDASSERT(pdrvname != NULL);

#ifdef DEBUG
    if (pdrvname[0] == 0)
    {
        DPF(3, "createDC() empty string!!!");
        DebugBreak();
        return NULL;
    }
#endif

    #if defined(NT_FIX) || defined(WIN95)
        u = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    #endif
    #ifdef WINNT
        /*
         * Note that DirectDraw refers to the driver for the primary monitor
         * in a multimon system as "display", but NT uses "display" to refer
         * to the desktop as a whole.  To handle this mismatch, we store
         * NT's name for the primary monitor's driver in g_szPrimaryDisplay
         * and substitute this name in place of "display" in our calls to NT.
        */
        if (GetSystemMetrics(SM_CMONITORS) > 1)
        {
            if ((_stricmp(pdrvname, DISPLAY_STR) == 0))
            {
                if (g_szPrimaryDisplay[0] == '\0')
                {
                    getPrimaryDisplayName();
                }
                pdrvname = g_szPrimaryDisplay;
            }
        }
    #endif //WINNT

    DPF(5, "createDC(%s)", pdrvname);

    if (pdrvname[0] == '\\' && pdrvname[1] == '\\' && pdrvname[2] == '.')
        hdc = CreateDC(NULL, pdrvname, NULL, NULL);
    else
        hdc = CreateDC(pdrvname, NULL, NULL, NULL);

    #if defined(NT_FIX) || defined(WIN95) //fix this error mode stuff
        SetErrorMode(u);
    #endif

    if (hdc == NULL)
    {
        DPF(3, "createDC(%s) FAILED!", pdrvname);
    }

    return hdc;

} /* createDC */

/*****************************Private*Routine******************************\
* DdConvertFromOldFormat
*
* History:
*  13-Nov-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "ConvertFromOldFormat"

void ConvertFromOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT *pNewFormat)
{
    *pNewFormat = D3DFMT_UNKNOWN;
    if (pOldFormat->dwFlags & DDPF_FOURCC)
    {
        *pNewFormat = (D3DFORMAT) pOldFormat->dwFourCC;
    }
    else if (pOldFormat->dwFlags == DDPF_RGB)
    {
        switch (pOldFormat->dwRGBBitCount)
        {
        case 8:
            if ((pOldFormat->dwRBitMask == 0x000000e0) &&
                (pOldFormat->dwGBitMask == 0x0000001c) &&
                (pOldFormat->dwBBitMask == 0x00000003))
            {
                *pNewFormat = D3DFMT_R3G3B2;
            }
            else
            {
                *pNewFormat = D3DFMT_P8;
            }
            break;

        case 16:
            if ((pOldFormat->dwRBitMask == 0x0000f800) &&
                (pOldFormat->dwGBitMask == 0x000007e0) &&
                (pOldFormat->dwBBitMask == 0x0000001f))
            {
                *pNewFormat = D3DFMT_R5G6B5;
            }
            else if ((pOldFormat->dwRBitMask == 0x00007c00) &&
                (pOldFormat->dwGBitMask == 0x000003e0) &&
                (pOldFormat->dwBBitMask == 0x0000001f))
            {
                *pNewFormat = D3DFMT_X1R5G5B5;
            }
            else if ((pOldFormat->dwRBitMask == 0x00000f00) &&
                (pOldFormat->dwGBitMask == 0x000000f0) &&
                (pOldFormat->dwBBitMask == 0x0000000f))
            {
                *pNewFormat = D3DFMT_X4R4G4B4;
            }
            break;

        case 24:
            if ((pOldFormat->dwRBitMask == 0x00ff0000) &&
                (pOldFormat->dwGBitMask == 0x0000ff00) &&
                (pOldFormat->dwBBitMask == 0x000000ff))
            {
                *pNewFormat = D3DFMT_R8G8B8;
            }
            break;

        case 32:
            if ((pOldFormat->dwRBitMask == 0x00ff0000) &&
                (pOldFormat->dwGBitMask == 0x0000ff00) &&
                (pOldFormat->dwBBitMask == 0x000000ff))
            {
                *pNewFormat = D3DFMT_X8R8G8B8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_RGB | DDPF_ALPHAPIXELS))
    {
        switch (pOldFormat->dwRGBBitCount)
        {
        case 16:
            if ((pOldFormat->dwRGBAlphaBitMask == 0x0000FF00) &&
                (pOldFormat->dwRBitMask == 0x000000e0) &&
                (pOldFormat->dwGBitMask == 0x0000001c) &&
                (pOldFormat->dwBBitMask == 0x00000003))
            {
                *pNewFormat = D3DFMT_A8R3G3B2;
            }
            else if ((pOldFormat->dwRGBAlphaBitMask == 0x0000f000) &&
                (pOldFormat->dwRBitMask == 0x00000f00) &&
                (pOldFormat->dwGBitMask == 0x000000f0) &&
                (pOldFormat->dwBBitMask == 0x0000000f))
            {
                *pNewFormat = D3DFMT_A4R4G4B4;
            }
            else if ((pOldFormat->dwRGBAlphaBitMask == 0x0000FF00) &&
                (pOldFormat->dwRBitMask == 0x00000f00) &&
                (pOldFormat->dwGBitMask == 0x000000f0) &&
                (pOldFormat->dwBBitMask == 0x0000000f))
            {
                *pNewFormat = D3DFMT_A4R4G4B4;
            }
            else if ((pOldFormat->dwRGBAlphaBitMask == 0x00008000) &&
                (pOldFormat->dwRBitMask == 0x00007c00) &&
                (pOldFormat->dwGBitMask == 0x000003e0) &&
                (pOldFormat->dwBBitMask == 0x0000001f))
            {
                *pNewFormat = D3DFMT_A1R5G5B5;
            }
            break;

        case 32:
            if ((pOldFormat->dwRGBAlphaBitMask == 0xff000000) &&
                (pOldFormat->dwRBitMask == 0x00ff0000) &&
                (pOldFormat->dwGBitMask == 0x0000ff00) &&
                (pOldFormat->dwBBitMask == 0x000000ff))
            {
                *pNewFormat = D3DFMT_A8R8G8B8;
            }
            break;
        }
    }
#if 0
    // We don't convert the old representation of A8 to
    // the new format because there are some existing DX7 drivers
    // that expose the old format but don't implement it correctly
    // or completely. We've seen Blt failures, and Rendering failures.
    // So this becomes a DX8+ only feature; in which case
    // we will get a new-style format from the driver.
    // MB43799
    else if (pOldFormat->dwFlags == DDPF_ALPHA)
    {
        if (pOldFormat->dwAlphaBitDepth == 8)
        {
            *pNewFormat = D3DFMT_A8;
        }
    }
#endif
    else if (pOldFormat->dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_RGB))
    {
        switch (pOldFormat->dwRGBBitCount)
        {
        case 8:
            if (pOldFormat->dwFlags == (DDPF_PALETTEINDEXED8 | DDPF_RGB))
            {
                *pNewFormat = D3DFMT_P8;
            }
            break;

        case 16:
            if (pOldFormat->dwFlags == (DDPF_PALETTEINDEXED8 |
                                        DDPF_RGB             |
                                        DDPF_ALPHAPIXELS) &&
                pOldFormat->dwRGBAlphaBitMask == 0xFF00)
            {

                *pNewFormat = D3DFMT_A8P8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_ZBUFFER)
    {
        switch (pOldFormat->dwZBufferBitDepth)
        {
        case 32:
            if (pOldFormat->dwZBitMask == 0xffffffff)
            {
                *pNewFormat = D3DFMT_D32;
            }
            else if (pOldFormat->dwZBitMask == 0x00FFFFFF)
            {
                *pNewFormat = D3DFMT_X8D24;
            }
            else if (pOldFormat->dwZBitMask == 0xFFFFFF00)
            {
                *pNewFormat = D3DFMT_D24X8;
            }
            break;

        case 16:
            if (pOldFormat->dwZBitMask == 0xffff)
            {
                *pNewFormat = D3DFMT_D16_LOCKABLE;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_ZBUFFER | DDPF_STENCILBUFFER))
    {
        switch (pOldFormat->dwZBufferBitDepth)
        {
        case 32:
            if ((pOldFormat->dwZBitMask == 0xffffff00) &&
                (pOldFormat->dwStencilBitMask == 0x000000ff) &&
                (pOldFormat->dwStencilBitDepth == 8))
            {
                *pNewFormat = D3DFMT_D24S8;
            }
            else if ((pOldFormat->dwZBitMask == 0x00ffffff) &&
                (pOldFormat->dwStencilBitMask == 0xff000000) &&
                (pOldFormat->dwStencilBitDepth == 8))
            {
                *pNewFormat = D3DFMT_S8D24;
            }
            else if ((pOldFormat->dwZBitMask == 0xffffff00) &&
                (pOldFormat->dwStencilBitMask == 0x0000000f) &&
                (pOldFormat->dwStencilBitDepth == 4))
            {
                *pNewFormat = D3DFMT_D24X4S4;
            }
            else if ((pOldFormat->dwZBitMask == 0x00ffffff) &&
                (pOldFormat->dwStencilBitMask == 0x0f000000) &&
                (pOldFormat->dwStencilBitDepth == 4))
            {
                *pNewFormat = D3DFMT_X4S4D24;
            }
            break;
        case 16:
            if ((pOldFormat->dwZBitMask == 0xfffe) &&
                (pOldFormat->dwStencilBitMask == 0x0001) &&
                (pOldFormat->dwStencilBitDepth == 1))
            {
                *pNewFormat = D3DFMT_D15S1;
            }
            else if ((pOldFormat->dwZBitMask == 0x7fff) &&
                (pOldFormat->dwStencilBitMask == 0x8000) &&
                (pOldFormat->dwStencilBitDepth == 1))
            {
                *pNewFormat = D3DFMT_S1D15;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_LUMINANCE)
    {
        switch (pOldFormat->dwLuminanceBitCount)
        {
        case 8:
            if (pOldFormat->dwLuminanceBitMask == 0xFF)
            {
                *pNewFormat = D3DFMT_L8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_LUMINANCE | DDPF_ALPHAPIXELS))
    {
        switch (pOldFormat->dwLuminanceBitCount)
        {
        case 8:
            if (pOldFormat->dwLuminanceBitMask      == 0x0F &&
                pOldFormat->dwLuminanceAlphaBitMask == 0xF0)
            {
                *pNewFormat = D3DFMT_A4L4;
            }
        case 16:
            if (pOldFormat->dwLuminanceBitMask      == 0x00FF &&
                pOldFormat->dwLuminanceAlphaBitMask == 0xFF00)
            {
                *pNewFormat = D3DFMT_A8L8;
            }

            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_BUMPDUDV)
    {
        switch (pOldFormat->dwBumpBitCount)
        {
        case 16:
            if (pOldFormat->dwBumpDuBitMask == 0xFF &&
                pOldFormat->dwBumpDvBitMask == 0xFF00)
            {
                *pNewFormat = D3DFMT_V8U8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_BUMPDUDV | DDPF_BUMPLUMINANCE))
    {
        switch (pOldFormat->dwBumpBitCount)
        {
        case 16:
            if (pOldFormat->dwBumpDuBitMask        == 0x001F &&
                pOldFormat->dwBumpDvBitMask        == 0x03E0 &&
                pOldFormat->dwBumpLuminanceBitMask == 0xFC00)
            {
                *pNewFormat = D3DFMT_L6V5U5;
            }
            break;

        case 32:
            if (pOldFormat->dwBumpDuBitMask        == 0x0000FF &&
                pOldFormat->dwBumpDvBitMask        == 0x00FF00 &&
                pOldFormat->dwBumpLuminanceBitMask == 0xFF0000)
            {
                *pNewFormat = D3DFMT_X8L8V8U8;
            }
            break;
        }
    }
}


/*
 * FetchDirectDrawData
 *
 * Go get new HAL info...
 */
void FetchDirectDrawData(
            PD3D8_DEVICEDATA    pBaseData,
            void*               pInitFunction,
            D3DFORMAT           Unknown16,
            DDSURFACEDESC*      pHalOpList,
            DWORD               NumHalOps)
{
    BOOL                bNewMode;
    BOOL                bRetVal;
    UINT                i=0;
    BOOL                bAlreadyAnOpList = FALSE;
    LPDDPIXELFORMAT     pZStencilFormatList=0;
    DDSURFACEDESC      *pTextureList=0;
    D3D8_GLOBALDRIVERDATA D3DGlobalDriverData;
    D3DHAL_D3DEXTENDEDCAPS D3DExtendedCaps;
    BOOL                bBackbuffersExist = FALSE;
    BOOL                bReset = FALSE;
    
    ZeroMemory( &D3DGlobalDriverData, sizeof(D3DGlobalDriverData) );
    ZeroMemory( &D3DExtendedCaps, sizeof(D3DExtendedCaps) );
    
    if (pBaseData->hDD == NULL)
    {
        #ifdef WINNT
            D3D8CreateDirectDrawObject(pBaseData->hDC,
                pBaseData->DriverName,
                &pBaseData->hDD,
                pBaseData->DeviceType,
                &pBaseData->hLibrary,
                pInitFunction);
        #else
            D3D8CreateDirectDrawObject(&pBaseData->Guid,
                pBaseData->DriverName,
                &pBaseData->hDD,
                pBaseData->DeviceType,
                &pBaseData->hLibrary,
                pInitFunction);
        #endif

        if (pBaseData->hDD == NULL)
        {
            #ifdef WINNT
                DPF(1, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:NT Kernel mode would not create driver object... Failing over to emulation");
            #endif
            goto ErrorExit;
        }
    }
    else
    {
        // If we already have 3D caps, then we are resetting 

        if ((pBaseData->DriverData.dwFlags & DDIFLAG_D3DCAPS8) &&
            (pBaseData->DriverData.D3DCaps.DevCaps != 0))
        {
            bReset = TRUE;
        }
    }

    // Now we can get the driver info...
    // The first call returns the amount of space we need to allocate for the
    // texture and z/stencil lists

    UINT cTextureFormats;
    UINT cZStencilFormats;

    if (bReset)
    {
        // If we are ressting, we do not want to rebuild all of the caps, the
        // format list, etc., but we still need to call the thunk layer because
        // on NT this resets the kernel.

        D3D8_DRIVERCAPS     TempData;
        D3D8_CALLBACKS      TempCallbacks;

        if (!D3D8ReenableDirectDrawObject(pBaseData->hDD,&bNewMode) ||
            !D3D8QueryDirectDrawObject(pBaseData->hDD,
                                   &TempData,
                                   &TempCallbacks,
                                   pBaseData->DriverName,
                                   pBaseData->hLibrary,
                                   &D3DGlobalDriverData,
                                   &D3DExtendedCaps,
                                   NULL,
                                   NULL,
                                   &cTextureFormats,
                                   &cZStencilFormats))
        {
            goto ErrorExit;
        }
        pBaseData->DriverData.DisplayWidth              = TempData.DisplayWidth;
        pBaseData->DriverData.DisplayHeight             = TempData.DisplayHeight;
        pBaseData->DriverData.DisplayFormatWithAlpha    = TempData.DisplayFormatWithAlpha;
        pBaseData->DriverData.DisplayFormatWithoutAlpha = TempData.DisplayFormatWithoutAlpha;
        pBaseData->DriverData.DisplayFrequency          = TempData.DisplayFrequency;
    }
    else
    {
        MemFree (pBaseData->DriverData.pGDD8SupportedFormatOps);
        pBaseData->DriverData.pGDD8SupportedFormatOps = NULL;

        if (!D3D8ReenableDirectDrawObject(pBaseData->hDD,&bNewMode) ||
            !D3D8QueryDirectDrawObject(pBaseData->hDD,
                                       &pBaseData->DriverData,
                                       &pBaseData->Callbacks,
                                       pBaseData->DriverName,
                                       pBaseData->hLibrary,
                                       &D3DGlobalDriverData,
                                       &D3DExtendedCaps,
                                       NULL,
                                       NULL,
                                       &cTextureFormats,
                                       &cZStencilFormats))
        {
            DPF(1, "****Direct3D DRIVER DISABLING ERROR****:First call to DdQueryDirectDrawObject failed!");
            D3D8DeleteDirectDrawObject(pBaseData->hDD);
            pBaseData->hDD = NULL;
            goto ErrorExit;
        }

        // First we make space for the formats
        // let's do memalloc for pTextureList just once, 3 extra for possible backbuffers
        // 3 extra for D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET
        pTextureList = (DDSURFACEDESC *) MemAlloc ((cTextureFormats+ cZStencilFormats + 6) * sizeof (*pTextureList));
        if (pTextureList == NULL)
        {
            DPF_ERR("****Direct3D DRIVER DISABLING ERROR****:Unable to allocate memory for texture formats!");
            D3D8DeleteDirectDrawObject(pBaseData->hDD);
            pBaseData->hDD = NULL;
            goto ErrorExit;
        }

        if (cZStencilFormats > 0)
        {
            pZStencilFormatList = (DDPIXELFORMAT *) MemAlloc (cZStencilFormats * sizeof (*pZStencilFormatList));
            if (pZStencilFormatList == NULL)
            {
                DPF_ERR("****Direct3D DRIVER DISABLING ERROR****:Unable to allocate memory for Z/Stencil formats!");
                D3D8DeleteDirectDrawObject(pBaseData->hDD);
                pBaseData->hDD = NULL;
                goto ErrorExit;
            }
        }

        //Now that we've allocated space for the texture and z/stencil lists, we can go get em.
        if (!D3D8QueryDirectDrawObject(pBaseData->hDD,
                                       &pBaseData->DriverData,
                                       &pBaseData->Callbacks,
                                       pBaseData->DriverName,
                                       pBaseData->hLibrary,
                                       &D3DGlobalDriverData,
                                       &D3DExtendedCaps,
                                       pTextureList,
                                       pZStencilFormatList,
                                       &cTextureFormats,
                                       &cZStencilFormats))
        {
            DPF_ERR("****Direct3D DRIVER DISABLING ERROR****:Second call to DdQueryDirectDrawObject failed!");
            D3D8DeleteDirectDrawObject(pBaseData->hDD);
            pBaseData->hDD = NULL;
            goto ErrorExit;
        }

        // If no D3DCAPS8 was reported by the thunk layer, then the driver
        // must be a pre-DX8 driver. We must sew together the 
        // D3DGlobalDriverData and the ExtendedCaps (which have to be reported).
        // Note: The thunk layer already has plugged in the DDraw Caps such
        // as the Caps, Caps2 and Caps3 (dwSVCaps).
        if( (pBaseData->DriverData.dwFlags & DDIFLAG_D3DCAPS8) == 0 )
        {
            MakeDX8Caps( &pBaseData->DriverData.D3DCaps,
                         &D3DGlobalDriverData,
                         &D3DExtendedCaps );
            pBaseData->DriverData.dwFlags |= DDIFLAG_D3DCAPS8;

        }
        else
        {
            // They reported the DX8 caps. 
            // Internally we check MaxPointSize if it is zero or not
            // to determine if PointSprites are supported or not. So if a DX8 driver said 1.0
            // set it to Zero
            if (pBaseData->DriverData.D3DCaps.MaxPointSize == 1.0)
            {
                pBaseData->DriverData.D3DCaps.MaxPointSize = 0;
            }
        }

        // There are some legacy caps that are reported by the drivers that
        // we dont want the applications to see. Should weed them out here.
        pBaseData->DriverData.D3DCaps.PrimitiveMiscCaps &= ~(D3DPMISCCAPS_MASKPLANES | 
            D3DPMISCCAPS_CONFORMANT);
        
        pBaseData->DriverData.D3DCaps.DevCaps &= ~(D3DDEVCAPS_FLOATTLVERTEX |
            D3DDEVCAPS_SORTINCREASINGZ | D3DDEVCAPS_SORTDECREASINGZ |
            D3DDEVCAPS_SORTEXACT);

        pBaseData->DriverData.D3DCaps.TextureCaps &= ~(D3DPTEXTURECAPS_TRANSPARENCY |
            D3DPTEXTURECAPS_BORDER | D3DPTEXTURECAPS_COLORKEYBLEND);
        
        pBaseData->DriverData.D3DCaps.VertexProcessingCaps &= ~(D3DVTXPCAPS_VERTEXFOG);

        pBaseData->DriverData.D3DCaps.RasterCaps &= ~(D3DPRASTERCAPS_SUBPIXEL |
            D3DPRASTERCAPS_SUBPIXELX | D3DPRASTERCAPS_STIPPLE |
            D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT |
            D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
            D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT);

        pBaseData->DriverData.D3DCaps.ShadeCaps &= ~(D3DPSHADECAPS_COLORFLATMONO |
            D3DPSHADECAPS_COLORFLATRGB | D3DPSHADECAPS_COLORGOURAUDMONO | 
            D3DPSHADECAPS_COLORPHONGMONO | D3DPSHADECAPS_COLORPHONGRGB |
            D3DPSHADECAPS_SPECULARFLATMONO | D3DPSHADECAPS_SPECULARFLATRGB |
            D3DPSHADECAPS_SPECULARGOURAUDMONO | D3DPSHADECAPS_SPECULARPHONGMONO |
            D3DPSHADECAPS_SPECULARPHONGRGB | D3DPSHADECAPS_ALPHAFLATBLEND |
            D3DPSHADECAPS_ALPHAFLATSTIPPLED | D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED |
            D3DPSHADECAPS_ALPHAPHONGBLEND | D3DPSHADECAPS_ALPHAPHONGSTIPPLED |
            D3DPSHADECAPS_FOGFLAT | D3DPSHADECAPS_FOGPHONG);

        // Now we generate the list of supported ops from the texture format
        // list and z/stencil list.
        //
        // A DX7 or older driver will return to us a simple list of pixel formats.
        // We will take this list and convert it into a list of supported
        // texture formats in the DX8 style. To that we will append any
        // z/stencil formats.
        //
        // First step in generating supported op lists: see if the list is
        // already a DX8 style format list. If it is (i.e. if any
        // entries are DDPF_D3DFORMAT, then all we need to do is
        // yank out the old-style entries (drivers are allowed to
        // keep both so they can run against old runtimes).

        for (i = 0; i < cTextureFormats; i++)
        {

            if (pTextureList[i].ddpfPixelFormat.dwFlags == DDPF_D3DFORMAT)
            {
                bAlreadyAnOpList = TRUE;
                break;
            }
        }

        if (bAlreadyAnOpList)
        {
            // mmmmm.... dx8 driver. We'll ignore its Z/stencil list because
            // such a driver is supposed to put additional op entries in the
            // "texture" list (i.e. the op list) for its z/stencil formats
            // Now all we have to do is ZAP all the old-style entries.
            for (i = 0; i < (INT)cTextureFormats; i++)
            {
                if (pTextureList[i].ddpfPixelFormat.dwFlags != DDPF_D3DFORMAT && i < (INT)cTextureFormats)
                {
                    // ha! zap that evil old-style entry!
                    // (scroll the remainder of the list down
                    // to squish this entry)
                    DDASSERT(cTextureFormats > 0); //after all, we're in a for loop.
                    if (i < (INT)(cTextureFormats - 1))
                    {
                        memcpy(pTextureList + i,
                               pTextureList + i + 1,
                               sizeof(*pTextureList)*(cTextureFormats - i - 1));
                    }
                    cTextureFormats--;
                    i--;
                }
            }

            // TODO:  Remove this as soon as we think that drivers have caught up to
            //        our OP LIST changes.
            for (i = 0; i < cTextureFormats; i++)
            {
                if (pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_BACKBUFFER)
                {
                    pTextureList[i].ddpfPixelFormat.dwOperations &= ~D3DFORMAT_OP_BACKBUFFER;
                    pTextureList[i].ddpfPixelFormat.dwOperations |= D3DFORMAT_OP_3DACCELERATION;
                    if (pBaseData->DeviceType == D3DDEVTYPE_HAL)
                    {
                        pTextureList[i].ddpfPixelFormat.dwOperations |= D3DFORMAT_OP_DISPLAYMODE;
                    }
                }
            }

            // If it's a SW driver, we've got a lot of extra work to do.

            if ((pBaseData->DeviceType == D3DDEVTYPE_REF) ||
                (pBaseData->DeviceType == D3DDEVTYPE_SW))
            {
                // First, make sure that the SW driver didn't erroneuously report any
                // D3DFORMAT_OP_DISPLAYMODE entries.

                for (i = 0; i < cTextureFormats; i++)
                {
                    if (pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_DISPLAYMODE)
                    {
                        DPF_ERR("*****The SW driver is disabled because it claims to support D3DFORMAT_OP_DISPLAYMODE*****");
                        D3D8DeleteDirectDrawObject(pBaseData->hDD);
                        pBaseData->hDD = NULL;
                        goto ErrorExit;
                    }
                }
                        
                // Now for the hard part. The HAL reports which display modes
                // it can support, and the SW driver reports which display
                // modes it can accelerate.  We need to prune the SW list so
                // that it matches the HW list.

                for (i = 0; i < cTextureFormats; i++)
                {
                    if (pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_3DACCELERATION)
                    {
                        // Does the HAL support this mode?
                        if (IsSupportedOp ((D3DFORMAT) pTextureList[i].ddpfPixelFormat.dwFourCC,
                                           pHalOpList,
                                           NumHalOps,
                                           D3DFORMAT_OP_DISPLAYMODE))
                        {
                            pTextureList[i].ddpfPixelFormat.dwOperations |= D3DFORMAT_OP_DISPLAYMODE;
                        }
                        else
                        {
                            pTextureList[i].ddpfPixelFormat.dwOperations &= ~D3DFORMAT_OP_3DACCELERATION;
                        }
                    }
                }
            }

            // since we found one op-style entry, we shouldn't have
            // killed them all
            DDASSERT(cTextureFormats);
        }
        else
        {
            // Hmmm.. yucky non DX8 driver! Better go through its texture list
            // and turn it into an op list
            INT i;
            for(i=0; i< (INT)cTextureFormats; i++)
            {
                // we proved this above:
                DDASSERT(pTextureList[i].ddpfPixelFormat.dwFlags != DDPF_D3DFORMAT);

                D3DFORMAT NewFormat;
                ConvertFromOldFormat(&pTextureList[i].ddpfPixelFormat, &NewFormat );

                if (NewFormat != D3DFMT_UNKNOWN)    // we succeeded the conversion
                {
                    pTextureList[i].ddpfPixelFormat.dwFourCC = (DWORD) NewFormat;
                    pTextureList[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                    pTextureList[i].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_TEXTURE;

                    if (pBaseData->DriverData.D3DCaps.TextureCaps & D3DPTEXTURECAPS_CUBEMAP)
                    {
                        // It is assumed that any texture format works for cubes
                        pTextureList[i].ddpfPixelFormat.dwOperations |=
                            D3DFORMAT_OP_CUBETEXTURE;

                        if (NewFormat == D3DFMT_X1R5G5B5    ||
                            NewFormat == D3DFMT_R5G6B5      ||
                            NewFormat == D3DFMT_A8R8G8B8    ||
                            NewFormat == D3DFMT_X8R8G8B8)
                        {
                            // For these three formats, we assume
                            // all cube-map hw supports rendering to them. 
                            //
                            // Testing indicates that these formats don't work 
                            // well if they are in bitdepth other than the primary; 
                            // so we only specify that the RT aspect of these
                            // formats work if they are basically the same
                            // as the primary.
                            pTextureList[i].ddpfPixelFormat.dwOperations |=
                                D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET;
                        }
                    }

                    // If they can support render target textures, add those flags in now
                    DWORD RTBit = D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET;
                    if (pBaseData->DriverData.KnownDriverFlags & KNOWN_CANMISMATCHRT)
                    {
                        RTBit = D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
                    }
                    if ((NewFormat == D3DFMT_X1R5G5B5) &&
                        (pBaseData->DriverData.KnownDriverFlags & KNOWN_RTTEXTURE_X1R5G5B5))
                    {
                        pTextureList[i].ddpfPixelFormat.dwOperations |= RTBit;
                    }
                    else if ((NewFormat == D3DFMT_R5G6B5) &&
                        (pBaseData->DriverData.KnownDriverFlags & KNOWN_RTTEXTURE_R5G6B5))
                    {
                        pTextureList[i].ddpfPixelFormat.dwOperations |= RTBit;
                    }
                    else if ((NewFormat == D3DFMT_X8R8G8B8) &&
                        (pBaseData->DriverData.KnownDriverFlags & KNOWN_RTTEXTURE_X8R8G8B8))
                    {
                        pTextureList[i].ddpfPixelFormat.dwOperations |= RTBit;
                    }
                    else if ((NewFormat == D3DFMT_A8R8G8B8) &&
                        (pBaseData->DriverData.KnownDriverFlags & KNOWN_RTTEXTURE_A8R8G8B8))
                    {
                        pTextureList[i].ddpfPixelFormat.dwOperations |= RTBit;
                    }
                    else if ((NewFormat == D3DFMT_A1R5G5B5) &&
                        (pBaseData->DriverData.KnownDriverFlags & KNOWN_RTTEXTURE_A1R5G5B5))
                    {
                        pTextureList[i].ddpfPixelFormat.dwOperations |= RTBit;
                    }
                    else if ((NewFormat == D3DFMT_A4R4G4B4) &&
                        (pBaseData->DriverData.KnownDriverFlags & KNOWN_RTTEXTURE_A4R4G4B4))
                    {
                        pTextureList[i].ddpfPixelFormat.dwOperations |= RTBit;
                    }

                    pTextureList[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                    pTextureList[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                    pTextureList[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                }
                else
                {
                    DPF(3,"This driver exposes an unrecognized DX7- style texture format");
                    // and we eat it up:
                    // (scroll the remainder of the list down to
                    // squish this entry)
                    DDASSERT(cTextureFormats>0); //after all, we're in a for loop.
                    if (i < (INT)(cTextureFormats - 1))
                    {
                        memcpy(pTextureList + i,
                               pTextureList + i + 1,
                               sizeof(*pTextureList)*(cTextureFormats - i - 1));
                    }
                    cTextureFormats--;
                    i--;
                }
            }

            //And laboriously tack on the z/stencil formats. Phew.
            for (i = 0; i < (INT)cZStencilFormats; i++)
            {
                DDASSERT(pZStencilFormatList);

                //we proved this above:
                DDASSERT(pZStencilFormatList[i].dwFlags != DDPF_D3DFORMAT);

                D3DFORMAT NewFormat;

                ConvertFromOldFormat(&pZStencilFormatList[i], &NewFormat);
                if (NewFormat != D3DFMT_UNKNOWN)    //we succeeded the conversion
                {
                    // Room for these elements was allocated above...
                    pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                    pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) NewFormat;
                    pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_ZSTENCIL;
                    pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                    pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                    pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;

                    // See if part is "known good" i.e. it can mix-and-match
                    // ZBuffer and RT formats
                    if (pBaseData->DriverData.KnownDriverFlags & KNOWN_ZSTENCILDEPTH)
                    {
                        pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations 
                                |=  D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH;
                    }

                    // If part successfully supports lockable 16-bit zbuffer tests
                    // then we allow D16_LOCKABLE through; else we only expose D3DFMT_D16
                    if (NewFormat == D3DFMT_D16_LOCKABLE)                    
                    {
                        if (!(pBaseData->DriverData.KnownDriverFlags & KNOWN_D16_LOCKABLE))
                        {
                            pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_D16;
                        }
                    }

                    cTextureFormats++;
                }
                else
                {
                    DPF(3,"This driver exposes an unrecognized DX6 style Z/Stencil format");
                }
            }

            // Now we need to add in off-screen render target formats for this Non-DX8 driver.

            // DX8 doesn't allow back buffers to be used as textures, so we add
            // a whole new entry to the op list for each supported back buffer
            // format (i.e. don't go searching for any existing texturable format
            // entry that matches and OR in the RT op).
            //
            //If the format is a back-buffer format, we assume it can be rendered when in the same
            //display mode. Note the presence of this entry in the format op list doesn't imply
            //necessarily that the device can render in that depth. CheckDeviceFormat could still
            //fail for modes of that format... This gives us license to blindly add the formats
            //here before we really know what set of back buffer formats the device can do.
            //(Note only display devices are given this boost, since voodoos don't run windowed)

            if (pBaseData->dwFlags & DD_DISPLAYDRV)
            {
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) Unknown16;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats ++;

                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8R8G8B8;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats ++;
            }
            else
            {
                // Voodood 2 hack - The V2 doesn't really support offscreen
                // render targets, but we need to add a 565 RT anyway or else
                // our op list won't create the device.
                // CONSIDER: Adding an internal OP flag indicating that this format
                // should NOT succeed in a call to CreateRenderTarget.

                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) Unknown16;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats ++;
            }

            // Now add in the supported display modes

            if (D3DGlobalDriverData.hwCaps.dwDeviceRenderBitDepth & DDBD_16)
            {
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) Unknown16;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_DISPLAYMODE|D3DFORMAT_OP_3DACCELERATION;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats++;
            }
            if (D3DGlobalDriverData.hwCaps.dwDeviceRenderBitDepth & DDBD_24)
            {
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_R8G8B8;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_DISPLAYMODE|D3DFORMAT_OP_3DACCELERATION;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats++;
            }
            if (D3DGlobalDriverData.hwCaps.dwDeviceRenderBitDepth & DDBD_32)
            {
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8R8G8B8;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_DISPLAYMODE|D3DFORMAT_OP_3DACCELERATION;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats++;
            }

            // This is a hack for those really, really old drivers that don't
            // support any D3D at all. We will fill in 16 and 32bpp modes, but remove
            // the 32bpp mode later if we can't find it in the mode table.

            if ((D3DGlobalDriverData.hwCaps.dwDeviceRenderBitDepth == 0)
            #ifdef WIN95
                && (pBaseData->DriverData.D3DCaps.Caps & DDCAPS_BLT)
                && !(pBaseData->DriverData.D3DCaps.Caps & DDCAPS_NOHARDWARE)
            #endif
                )
            {
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) Unknown16;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_DISPLAYMODE;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats++;

                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8R8G8B8;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_DISPLAYMODE;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats++;           
            }
        }

        // As a final pass we infer operations as necessary. If we have an
        // general operation that implies other specific operations; then we
        // turn on the bits of those specific operations. This is better
        // than relying on the driver to get everything right; because it lets us
        // add more specific operations in future releases without breaking
        // old releases.
        for (i = 0; i < cTextureFormats; i++)
        {
            DWORD *pdwOperations = &(pTextureList[i].ddpfPixelFormat.dwOperations);

            // Off-screen RT means truly mode-independent
            if ((*pdwOperations) & D3DFORMAT_OP_OFFSCREEN_RENDERTARGET)
            {
                (*pdwOperations) |= D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET;
                (*pdwOperations) |= D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
            }

            // Same except for alpha means exact same is good too
            if ((*pdwOperations) & D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET)
            {
                (*pdwOperations) |= D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
            }

            // Color Independent Z implies that forced Z matching is ok too.
            if ((*pdwOperations) & D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH)
            {
                (*pdwOperations) |= D3DFORMAT_OP_ZSTENCIL;
            }
        }

        // Now we make a final pass to verify that they driver did gave us an
        // OP list that makes sense.  The OP list rules are:
        //
        // 1. Only One Endian-ness for any DS format is allowed i.e. D15S1 OR
        //    S1D15, not both independent of other bits.
        // 2. A list should only include D3DFORMAT_OP_DISPLAYMODE for exactly 
        //    one 16bpp format (i.e. shouldnt enumerate 5:5:5 and 5:6:5).
        // 3. A list should not any alpha formats with D3DFORMAT_OP_DISPLAYMODE 
        //    or D3DFORMAT_OP_3DACCEL set.
        // 4. Make sure no mode has OP_3DACCEL set that doesnt also have
        //    OP_DISPLAYMODE set.
        //
        // We also register IHV formats with CPixel.
        //

        BOOL    BadOpList = FALSE;
        for (i = 0; i < cTextureFormats; i++)
        {
            if ((pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_PIXELSIZE) &&
                pTextureList[i].ddpfPixelFormat.dwPrivateFormatBitCount != 0)
            {
                CPixel::Register((D3DFORMAT)pTextureList[i].ddpfPixelFormat.dwFourCC, pTextureList[i].ddpfPixelFormat.dwPrivateFormatBitCount);
            }

            if ((pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_3DACCELERATION) &&
                !(pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_DISPLAYMODE))
            {
                DPF_ERR("***Driver disabled because it reported a format with D3DFORMAT_OP_3DACCELERATION without D3DFORMAT_OP_DISPLAYMODE");
                BadOpList = TRUE;
            }
    
            if ((pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_3DACCELERATION) &&
                ((pTextureList[i].ddpfPixelFormat.dwFourCC == (DWORD) D3DFMT_A8R8G8B8) ||
                 (pTextureList[i].ddpfPixelFormat.dwFourCC == (DWORD) D3DFMT_A1R5G5B5)))
            {
                DPF_ERR("***Driver disabled because it reported an alpha format with D3DFORMAT_OP_3DACCELERATION");
                BadOpList = TRUE;
            }

            if ((pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_DISPLAYMODE) &&
                (pTextureList[i].ddpfPixelFormat.dwFourCC == (DWORD) D3DFMT_R5G6B5))
            {
                if (IsSupportedOp (D3DFMT_X1R5G5B5, pTextureList, cTextureFormats, D3DFORMAT_OP_DISPLAYMODE))
                {
                    DPF_ERR("***Driver disabled because it reported both D3DFMT_R5G6B5 and D3DFMT_X1R5G5B5 as a display mode");
                    BadOpList = TRUE;
                }
            }

            if (pTextureList[i].ddpfPixelFormat.dwFourCC == (DWORD) D3DFMT_D15S1)
            {
                if (IsSupportedOp (D3DFMT_S1D15, pTextureList, cTextureFormats, 0))
                {
                    DPF_ERR("***Driver disabled because it reported both D3DFMT_D15S1 and D3DFMT_S1D15");
                    BadOpList = TRUE;
                }
            }
            else if (pTextureList[i].ddpfPixelFormat.dwFourCC == (DWORD) D3DFMT_D24S8)
            {
                if (IsSupportedOp (D3DFMT_S8D24, pTextureList, cTextureFormats, 0))
                {
                    DPF_ERR("***Driver disabled because it reported both D3DFMT_D24S8 and D3DFMT_S8D24");
                    BadOpList = TRUE;
                }
            }
            else if (pTextureList[i].ddpfPixelFormat.dwFourCC == (DWORD) D3DFMT_D24X8)
            {
                if (IsSupportedOp (D3DFMT_X8D24, pTextureList, cTextureFormats, 0))
                {
                    DPF_ERR("***Driver disabled because it reported both D3DFMT_D24X8 and D3DFMT_X8D24");
                    BadOpList = TRUE;
                }
            }
            else if (pTextureList[i].ddpfPixelFormat.dwFourCC == (DWORD) D3DFMT_D24X4S4)
            {
                if (IsSupportedOp (D3DFMT_X4S4D24, pTextureList, cTextureFormats, 0))
                {
                    DPF_ERR("***Driver disabled because it reported both D3DFMT_D24X4S4 and D3DFMT_X4S4D24");
                    BadOpList = TRUE;
                }
            }
        }
        if (BadOpList)
        {
            D3D8DeleteDirectDrawObject(pBaseData->hDD);
            pBaseData->hDD = NULL;
            goto ErrorExit;
        }


        // and now we assign the texture list to its place in the driver data
        pBaseData->DriverData.pGDD8SupportedFormatOps  = pTextureList;
        if (pTextureList != NULL)
        {
            pTextureList = NULL;    //so it won't be freed later
            pBaseData->DriverData.GDD8NumSupportedFormatOps = cTextureFormats;
        }
        else
        {
            pBaseData->DriverData.GDD8NumSupportedFormatOps = 0;
        }

        if (!(pBaseData->DriverData.D3DCaps.Caps2 & DDCAPS2_NONLOCALVIDMEM))
        {
            if (pBaseData->DriverData.D3DCaps.DevCaps & D3DDEVCAPS_TEXTURENONLOCALVIDMEM)
            {   //some drivers(Riva128 on PCI) incorrectly sets D3DDEVCAPS_TEXTURENONLOCALVIDMEM
                DPF(1, "driver set D3DDEVCAPS_TEXTURENONLOCALVIDMEM w/o DDCAPS2_NONLOCALVIDMEM:turning off D3DDEVCAPS_TEXTURENONLOCALVIDMEM");
                pBaseData->DriverData.D3DCaps.DevCaps &= ~D3DDEVCAPS_TEXTURENONLOCALVIDMEM;
            }
        }

        // For pre-DX8, we have some munging of caps that is necessary
        if (pBaseData->DriverData.D3DCaps.MaxStreams == 0)
        {
            DWORD *pdwTextureCaps = &pBaseData->DriverData.D3DCaps.TextureCaps;
            if (*pdwTextureCaps & D3DPTEXTURECAPS_CUBEMAP)
            {
                if (pBaseData->DriverData.KnownDriverFlags & KNOWN_MIPPEDCUBEMAPS)
                {
                    *pdwTextureCaps |= D3DPTEXTURECAPS_MIPCUBEMAP;
                }
                else
                {
                    // Turn off Mip filter flags since this is card doesnt support a mipped cubemap.
                    pBaseData->DriverData.D3DCaps.CubeTextureFilterCaps &= ~(D3DPTFILTERCAPS_MIPFPOINT  |
                                                                             D3DPTFILTERCAPS_MIPFLINEAR);
                }
                // Also we need to specify that cube-maps must
                // be power-of-two
                *pdwTextureCaps |= D3DPTEXTURECAPS_CUBEMAP_POW2;
            }

            // We need to determine the part can support mipmaps...
            if (pBaseData->DriverData.D3DCaps.TextureFilterCaps &
                    (D3DPTFILTERCAPS_MIPNEAREST         |
                     D3DPTFILTERCAPS_MIPLINEAR          |
                     D3DPTFILTERCAPS_LINEARMIPNEAREST   |
                     D3DPTFILTERCAPS_LINEARMIPLINEAR    |
                     D3DPTFILTERCAPS_MIPFPOINT          |
                     D3DPTFILTERCAPS_MIPFLINEAR))
            {
                *pdwTextureCaps |= D3DPTEXTURECAPS_MIPMAP;
            }
            else
            {
                DPF(3, "Device doesn't support mip-maps");
            }
        }

        // We disable driver-management for pre-dx8 parts because
        // the semantics for driver-management are now different
        // for dx8; and hence we can't use old driver's logic.
        pBaseData->DriverData.D3DCaps.Caps2 &= ~DDCAPS2_CANMANAGETEXTURE;

        // For HW that needs separate banks of texture memory; we
        // disable multi-texturing. This is done because we don't want to
        // have an API that puts the burden on the application to specifically
        // code for this case.
        if (pBaseData->DriverData.D3DCaps.DevCaps & D3DDEVCAPS_SEPARATETEXTUREMEMORIES)
        {
            pBaseData->DriverData.D3DCaps.MaxSimultaneousTextures = 1;

            // Turn off this flag.
            pBaseData->DriverData.D3DCaps.DevCaps &= ~D3DDEVCAPS_SEPARATETEXTUREMEMORIES;
        }
    }

ErrorExit:

    if (NULL != pTextureList)
        MemFree(pTextureList);

    // It was only temporary, having now been merged into the supported op list.
    if (NULL != pZStencilFormatList)
        MemFree(pZStencilFormatList);

    return;

} /* FetchDirectDrawData */

/*
 * DirectDrawSupported
 */
BOOL DirectDrawSupported(void)
{
    HDC         hdc;
    unsigned    u;

    hdc = GetDC(NULL);
    u = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
    ReleaseDC(NULL, hdc);

    if (u < 8)
    {
        return FALSE;
    }
    return TRUE;

} /* DirectDrawSupported */

// Utility function that tells us if there is more than
// one display device in the system.  (We count all devices,
// regardless of whether they are attached to the desktop.)
BOOL IsMultiMonitor(void)
{
    int i, n;

    // Each loop below enumerates one display device.
    for (i = 0, n = 0; ; i++)
    {
        DISPLAY_DEVICEA dd;

        // Zero the memory of the DISPLAY_DEVICE struct between calls to
        // EnumDisplayDevices
        ZeroMemory(&dd, sizeof(dd));
        dd.cb = sizeof(dd);
        if (!xxxEnumDisplayDevicesA(NULL, i, &dd, 0))
        {
            break;      // no more devices to enumerate
        }
        if (dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
        {
            continue;   // not a real hardware display driver
        }
        // We're just trying to count the number of display devices in the
        // system and see if there is more than one.
        if (++n > 1)
        {
            return TRUE;   // multiple display devices
        }
    }

    return FALSE;  // single display device
}


BOOL fDoesGDI(HDC hdc)
{
    //
    // the 3Dfx driver always return 1 to every thing
    // verify GetNearest()  color works.
    //
    BOOL b = GetNearestColor(hdc, 0x000000) == 0x000000 &&
             GetNearestColor(hdc, 0xFFFFFF) == 0xFFFFFF;
    if (b)
    {
        DPF(3,"Driver is a GDI driver");
    }

    return b;
}

/*
 * Functions to dynamically link against exports we need in user32 on
 * older OSes
 */
//These statics will be per-process, cuz it's outside the shared section
typedef BOOL (WINAPI * LPENUMMONITORS) (HDC, LPRECT, MONITORENUMPROC, LPARAM);
typedef BOOL (WINAPI * LPGETMONINFO) (HMONITOR, MONITORINFO *);
typedef BOOL (WINAPI * LPISDEBUG) (void);
static LPISDEBUG pIsDebuggerPresent = 0;
static LPENUMMONITORS pEnumMonitors = 0;
static LPGETMONINFO pGetMonitorInfo = 0;
static BOOL bTriedToGetProcAlready = FALSE;

BOOL DynamicLinkToOS(void)
{
    if (1) //!pEnumMonitors)
    {
        HMODULE hUser32;
        HMODULE hKernel32;

        if (0) //bTriedToGetProcAlready)
            return FALSE;

        bTriedToGetProcAlready = TRUE;

        hUser32 = GetModuleHandle(TEXT("USER32"));
        pEnumMonitors = (LPENUMMONITORS) GetProcAddress(hUser32,"EnumDisplayMonitors");
        pGetMonitorInfo = (LPGETMONINFO) GetProcAddress(hUser32,"GetMonitorInfoA");

        hKernel32 = GetModuleHandle(TEXT("KERNEL32"));
        pIsDebuggerPresent = (LPISDEBUG) GetProcAddress(hKernel32,"IsDebuggerPresent");

        if (!pEnumMonitors || !pGetMonitorInfo || !pIsDebuggerPresent)
        {
            DPF(3,"Failed to get proc addresses");
            return FALSE;
        }
    }

    DDASSERT(pEnumMonitors);
    DDASSERT(pGetMonitorInfo);
    DDASSERT(pEnumMonitors);

    return TRUE;
}

BOOL InternalGetMonitorInfo(HMONITOR hMon, MONITORINFO *lpInfo)
{
    DynamicLinkToOS();

    if (!pGetMonitorInfo)
        return FALSE;

    return pGetMonitorInfo(hMon, lpInfo);
}

typedef struct
{
    LPSTR       pName;
    HMONITOR    hMon;
} CALLBACKSTRUCT, * LPCALLBACKSTRUCT;


BOOL InternalEnumMonitors(MONITORENUMPROC proc, LPCALLBACKSTRUCT lp)
{
    DynamicLinkToOS();

    if (!pEnumMonitors)
        return FALSE;

    pEnumMonitors(NULL,NULL,proc,(LPARAM)lp);

    return TRUE;
}
/*
 * InternalIsDebuggerPresent
 * A little helper so that this runtime runs against older OSes
 */
BOOL InternalIsDebuggerPresent(void)
{
    DynamicLinkToOS();

    if (!pIsDebuggerPresent)
        return FALSE;

    return pIsDebuggerPresent();
}

//
// getPrimaryDisplayName
//

void getPrimaryDisplayName(void)
{
    DISPLAY_DEVICE dd;
    int i;

    ZeroMemory(&dd, sizeof dd);
    dd.cb = sizeof dd;

    for (i = 0; xxxEnumDisplayDevicesA(NULL, i, &dd, 0); ++i)
    {
        if (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
        {
            lstrcpyn(g_szPrimaryDisplay, dd.DeviceName, sizeof g_szPrimaryDisplay);
            return;
        }
    }

    lstrcpy(g_szPrimaryDisplay, DISPLAY_STR);
}

/*
 * InternalDirectDrawCreate
 */

HRESULT InternalDirectDrawCreate(
                PD3D8_DEVICEDATA*   ppBaseData,
                PADAPTERINFO        pDeviceInfo,
                D3DDEVTYPE          DeviceType,
                VOID*               pInitFunction,
                D3DFORMAT           Unknown16,
                DDSURFACEDESC*      pHalOpList,
                DWORD               NumHalOps)
{
    int                         rc;
    HDC                         hdc_dd;
    HKEY                        hkey;
    ULONG_PTR                   hDD;
    PD3D8_DEVICEDATA            pBaseData;

    *ppBaseData = (PD3D8_DEVICEDATA) NULL;

    /*
     * check for < 8 bpp and disallow.
     */
    if (!DirectDrawSupported())
    {
        DPF_ERR("DDraw and Direct3D are not supported in less than 8bpp modes. Creating Device fails.");
        return D3DERR_NOTAVAILABLE;
    }

    ENTER_CSDDC();

    hdc_dd = NULL;
    hDD = 0;

    //
    // Get the primary display name, which will usually be something like
    // \\.\Display1 and in some cases may be \\.\Display1\Unit0. We only
    // do this one time, and store it globally. On Win98, the global name
    // will be shared between all processes, and on NT5, each process will
    // have its own copy. Also, note that the primary device name may change
    // on NT5; we need to look into this.
    //

    if (g_szPrimaryDisplay[0] == '\0')
    {
        getPrimaryDisplayName();
    }

    // Create the object and get all of the data.

    hdc_dd = DD_CreateDC(pDeviceInfo->DeviceName);
    if (hdc_dd == NULL)
    {
        DPF_ERR("Could not create driver, CreateDC failed! Creating Device fails.");
        LEAVE_CSDDC();
        return E_OUTOFMEMORY;
    }

    // Create the driver object

    pBaseData = (PD3D8_DEVICEDATA) MemAlloc (sizeof (D3D8_DEVICEDATA));
    if (pBaseData == NULL)
    {
        DPF_ERR("Insufficient system memory! Creating Device fails. ");
        DD_DoneDC(hdc_dd);
        LEAVE_CSDDC();
        return E_OUTOFMEMORY;
    }
    ZeroMemory( pBaseData, sizeof(D3D8_DEVICEDATA) );
    strcpy(pBaseData->DriverName, pDeviceInfo->DeviceName);
    pBaseData->hDC = hdc_dd;
    pBaseData->Guid = pDeviceInfo->Guid;
    pBaseData->DeviceType = DeviceType;

    // Even if it's not a display driver, it may still be a GDI driver

    if (hdc_dd != NULL)
    {
        if (pDeviceInfo->bIsDisplay)
        {
            pBaseData->dwFlags |= DD_DISPLAYDRV;
        }
        else if (fDoesGDI(hdc_dd))
        {
            pBaseData->dwFlags |= DD_GDIDRV;
        }
    }

    // Get all of the driver caps and callbacks

    FetchDirectDrawData(pBaseData, 
                        pInitFunction, 
                        Unknown16, 
                        pHalOpList,
                        NumHalOps);

    if (pBaseData->hDD == NULL)
    {
        DDASSERT(NULL == pBaseData->DriverData.pGDD8SupportedFormatOps);
        DD_DoneDC(hdc_dd);
        MemFree(pBaseData);
        LEAVE_CSDDC();
        return D3DERR_NOTAVAILABLE;
    }
    *ppBaseData = pBaseData;
    LEAVE_CSDDC();
    return S_OK;

} /* InternalDirectDrawCreate */


/*
 * InternalDirectDrawRelease
 */

HRESULT InternalDirectDrawRelease(PD3D8_DEVICEDATA  pBaseData)
{
    D3D8DeleteDirectDrawObject(pBaseData->hDD);
    DD_DoneDC(pBaseData->hDC);
    MemFree(pBaseData->DriverData.pGDD8SupportedFormatOps);
    MemFree(pBaseData);

    return S_OK;
} /* InternalDirectDrawRelease */


BOOL CALLBACK MonitorEnumProc(HMONITOR hMon, HDC hdc, LPRECT lpr, LPARAM lParam)
{
    MONITORINFOEX       mix;
    MONITORINFO         mi;
    LPCALLBACKSTRUCT    lpcb = (LPCALLBACKSTRUCT) lParam;

    mi.cbSize = sizeof(mi);
    if (!InternalGetMonitorInfo(hMon,&mi))
        return FALSE;

    mix.cbSize = sizeof(mix);
    if (!InternalGetMonitorInfo(hMon,(MONITORINFO*) &mix))
        return FALSE;

    if (!strcmp(lpcb->pName,(LPSTR)mix.szDevice))
    {
        //Found it!!
        lpcb->hMon = hMon;
        return FALSE;
    }
    return TRUE;
}

/*
 * GetMonitorFromDeviceName
 */
HMONITOR GetMonitorFromDeviceName(LPSTR szName)
{
    CALLBACKSTRUCT cbs;
    cbs.pName = szName;
    cbs.hMon = NULL;

    if (!InternalEnumMonitors(MonitorEnumProc, &cbs))
        return NULL;

    return cbs.hMon;
}



/*
 * these are exported... temp. hack for non-Win95
 */
#ifndef WIN95
void DDAPI thk3216_ThunkData32(void)
{
}
void DDAPI thk1632_ThunkData32(void)
{
}

DWORD DDAPI DDGetPID(void)
{
    return 0;
}

int DDAPI DDGetRequest(void)
{
    return 0;
}

BOOL DDAPI DDGetDCInfo(LPSTR fname)
{
    return 0;
}


#ifdef POSTPONED
BOOL DDAPI DD32_HandleExternalModeChange(LPDEVMODE pModeInfo)
{
    return FALSE;
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\ddithunk.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddithunk.h
 *  Content:	header file used by the NT DDI thunk layer
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Dec-99  smac    Created it
 *
 ***************************************************************************/

#ifndef __DDITHUNK_INCLUDED__
#define __DDITHUNK_INCLUDED__

// Entire file should not be used in Win9x builds
#ifndef WIN95

#define MAX_ZSTENCIL_FORMATS    40

typedef struct _DDSURFHANDLE *PDDSURFHANDLE;
typedef struct _DEFERREDCREATE *PDEFERREDCREATE;

typedef struct _D3DCONTEXTHANDLE
{
    HANDLE                      dwhContext;
    DWORD                       dwFlags;
    struct _DDDEVICEHANDLE*     pDevice;
    DWORD                       dwPID;
    HANDLE                      hDeferHandle;
    struct _DDSURFHANDLE*       pSurface;
    struct _DDSURFHANDLE*       pDDSZ;
} D3DCONTEXTHANDLE, * PD3DCONTEXTHANDLE;

#define D3DCONTEXT_DEFERCREATE  0x00000001

typedef struct _DDDEVICEHANDLE
{
    HANDLE                      hDD;
    DWLIST                      SurfaceHandleList;
    char                        szDeviceName[MAX_DRIVER_NAME];
    LPDDRAWI_DIRECTDRAW_LCL     pDD;    // Used by Refrast and RGB HEL
    BOOL                        bDeviceLost;
    UINT                        DisplayUniqueness;
    PDDSURFHANDLE               pSurfList;
    PD3DCONTEXTHANDLE           pContext;
    D3DFORMAT                   DisplayFormatWithoutAlpha;
    D3DFORMAT                   DisplayFormatWithAlpha;
    UINT                        DisplayPitch;
    DWORD                       DriverLevel;
    RECT                        rcMonitor;
    HWND                        hLastWnd;
    LPRGNDATA                   pClipList;      //result from pOrigClipList
    LPRGNDATA                   pOrigClipList;  //ClipList before ClipRgnToRect
    VOID*                       pSwInitFunction;
    BOOL                        bIsWhistler;
    DWORD                       PCIID;
    DWORD                       DriverVersionHigh;
    DWORD                       DriverVersionLow;
    DWORD                       ForceFlagsOff;
    DWORD                       ForceFlagsOn;
    DWORD                       dwFlags;    
    DWORD                       DDCaps;
    DWORD                       SVBCaps;
    HANDLE                      hLibrary;
    PDEFERREDCREATE             pDeferList;
    D3DDEVTYPE                  DeviceType;
} DDDEVICEHANDLE, * PDDDEVICEHANDLE;
#define DDDEVICE_SUPPORTD3DBUF        0x01    //this device has D3DBuf callbacks
#define DDDEVICE_DP2ERROR             0x02    //A DP2 call failed
#define DDDEVICE_SUPPORTSUBVOLUMELOCK 0x04    //this device supports sub-volume texture lock
#define DDDEVICE_READY                0x08    //All vidmem surfs have been destroyed for this device
#define DDDEVICE_GETDRIVERINFO2       0x10    // Driver support the GetDriverInfo2 call
#define DDDEVICE_INITIALIZED          0x20    // The device has been initialized
#define DDHANDLE(x)  \
    (((PDDDEVICEHANDLE)(x))->hDD)

typedef struct _DDSURFHANDLE
{
    // NOTE: dwCookie must be the first element
    // since we need easy access to it from the 
    // client and the thunk layer itself.
    DWORD                       dwCookie;   // CreateSurfaceEx handle

    HANDLE                      hSurface;   // Kernel mode surface handle
    D3DPOOL                     Pool;       // Location of surface
    D3DFORMAT                   Format;   
    D3DRESOURCETYPE             Type;       // What kind of surface it is
    ULONG_PTR                   fpVidMem;
    DWORD                       dwLinearSize;
    LONG                        lPitch;
    LPDDRAWI_DDRAWSURFACE_LCL   pLcl;
    PDDDEVICEHANDLE             pDevice;
    DWORD                       dwFlags;
    DWORD                       dwHeight;
    LONG                        lSlicePitch; // Offset to next slice for volume texture
    struct _DDSURFHANDLE*       pNext;
    struct _DDSURFHANDLE*       pPrevious;
    UINT                        LockRefCnt;
} DDSURFHANDLE, * PDDSURFHANDLE;

typedef struct _DEFERREDCREATE
{
    D3D8_CREATESURFACEDATA      CreateData;
    struct _DEFERREDCREATE     *pNext;
} DEFERREDCREATE, *PDEFERREDCREATE;

#define DDSURF_SYSMEMALLOCATED      0x00000001
#define DDSURF_DEFERCREATEEX        0x00000002
#define DDSURF_HAL                  0x00000004
#define DDSURF_SOFTWARE             0x00000008
#define DDSURF_CREATECOMPLETE       0x00000010
#define DDSURF_TREATASVIDMEM        0x00000020      // Flag to indicate that surf should
                                                    // be treated as vid-mem for the
                                                    // "do vid-mem surfaces exist" case


#define IS_SOFTWARE_DRIVER(x)                                       \
    (((PDDDEVICEHANDLE)(x))->pDD != NULL)

#define IS_SOFTWARE_DRIVER_SURFACE(x)                               \
    (((PDDSURFHANDLE)(x))->dwFlags & DDSURF_SOFTWARE)

#define IS_SURFACE_LOOSABLE(x)                                      \
    (!IS_SOFTWARE_DRIVER_SURFACE(x) &&                              \
    ((((PDDSURFHANDLE)(x))->Pool == D3DPOOL_LOCALVIDMEM) ||        \
    (((PDDSURFHANDLE)(x))->Pool == D3DPOOL_NONLOCALVIDMEM)))

__inline HANDLE GetSurfHandle(HANDLE hSurface)
{
    if(hSurface)                                     
    {                                                   
        return(((PDDSURFHANDLE)hSurface)->hSurface); 
    }                                                   
    return NULL;
}

__inline D3DRESOURCETYPE GetSurfType(HANDLE hSurface)
{
    if(hSurface)                                     
    {                                                   
        return(((PDDSURFHANDLE)hSurface)->Type); 
    }                                                   
    return (D3DRESOURCETYPE) 0;
}


// Function protoptypes

extern LPDDRAWI_DIRECTDRAW_LCL SwDDICreateDirectDraw( void);
extern void ConvertToOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT NewFormat);
extern void SwDDIMungeCaps (HINSTANCE hLibrary, HANDLE hDD, PD3D8_DRIVERCAPS pDriverCaps, PD3D8_CALLBACKS pCallbacks, LPDDSURFACEDESC, UINT*, VOID* pSwInitFunction);
extern LPDDRAWI_DDRAWSURFACE_LCL SwDDIBuildHeavyWeightSurface (LPDDRAWI_DIRECTDRAW_LCL, PD3D8_CREATESURFACEDATA pCreateSurface, DD_SURFACE_LOCAL* pSurfaceLocal, DD_SURFACE_GLOBAL* pSurfaceGlobal, DD_SURFACE_MORE* pSurfaceMore, DWORD index);
extern void SwDDICreateSurfaceEx(LPDDRAWI_DIRECTDRAW_LCL pDrv, LPDDRAWI_DDRAWSURFACE_LCL pLcl);
extern void SwDDIAttachSurfaces (LPDDRAWI_DDRAWSURFACE_LCL pFrom, LPDDRAWI_DDRAWSURFACE_LCL pTo);
extern HRESULT SwDDICreateSurface( PD3D8_CREATESURFACEDATA pCreateSurface, DD_SURFACE_LOCAL* pDDSurfaceLocal, DD_SURFACE_GLOBAL* pDDSurfaceGlobal, DD_SURFACE_MORE*  pDDSurfaceMore);
extern void AddUnknownZFormats( UINT NumFormats, DDPIXELFORMAT* pFormats, UINT* pNumUnknownFormats, D3DFORMAT* pUnknownFormats);
extern DWORD SwDDILock( HANDLE hDD, PDDSURFHANDLE   pSurf, DD_LOCKDATA* pLockData);
extern DWORD SwDDIUnlock( HANDLE hDD, PDDSURFHANDLE   pSurf, DD_UNLOCKDATA* pUnlockData);
extern DWORD SwDDIDestroySurface( HANDLE hDD, PDDSURFHANDLE pSurf);
extern HRESULT MapLegacyResult(HRESULT hr);

#endif // !WIN95

#endif // __DDITHUNK_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllinit.c
 *  Content:    DDRAW.DLL initialization
 *
 ***************************************************************************/

/*
 * unfortunately we have to break our pre-compiled headers to get our
 * GUIDS defined...
 */
#define INITGUID
#include "ddrawpr.h"
#include <initguid.h>
#ifdef WINNT
#undef IUnknown
#include <objbase.h>
#include "aclapi.h"
#endif


HANDLE              hWindowListMutex; //=(HANDLE)0;

#define WINDOWLISTMUTEXNAME "DDrawWindowListMutex"
#define INITCSWINDLIST() \
hWindowListMutex = CreateMutex(NULL,FALSE,WINDOWLISTMUTEXNAME);
#define FINIWINDLIST() CloseHandle(hWindowListMutex);


HINSTANCE           g_hModule=0;

/*
 * Winnt specific global statics
 */

BYTE szDeviceWndClass[] = "DirectDrawDeviceWnd";


/*
 * This mutex is owned by the exclusive mode owner
 */
HANDLE              hExclusiveModeMutex=0;
HANDLE              hCheckExclusiveModeMutex=0;
#define EXCLUSIVE_MODE_MUTEX_NAME "__DDrawExclMode__"
#define CHECK_EXCLUSIVE_MODE_MUTEX_NAME "__DDrawCheckExclMode__"

//#endif


/*
 * Win95 specific global statics
 */

#ifdef WIN95
    LPVOID	        lpWin16Lock;

    static CRITICAL_SECTION csInit = {0};
    CRITICAL_SECTION	csWindowList;
    CRITICAL_SECTION    csDriverObjectList;
#endif


extern BOOL APIENTRY D3DDllMain(HMODULE hModule, 
                                DWORD   dwReason, 
                                LPVOID  lpvReserved);

extern void CPixel__Cleanup();

#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"

/*
 * DllMain
 */
BOOL WINAPI 
DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
    DWORD pid;
    BOOL  didhelp;

    pid = GetCurrentProcessId();

    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(hmod);
        DPFINIT();
        // Create the DirectDraw csect
        DPF(4, "====> ENTER: DLLMAIN(%08lx): Process Attach: %08lx, tid=%08lx", DllMain,
             pid, GetCurrentThreadId());

        /*
         * This must be the first time.
         */
        INITCSWINDLIST();

        g_hModule = hmod;

        //Let's grant the world MUTEX_ALL_ACCESS.... (bugs 210604, 30170, 194290, 194355)
        {
#ifdef WINNT
            SECURITY_ATTRIBUTES sa;
            SID_IDENTIFIER_AUTHORITY sia = SECURITY_WORLD_SID_AUTHORITY;
            PSID adminSid = 0;
            ULONG cbAcl;
            PACL acl=0;
            PSECURITY_DESCRIPTOR pSD;
            BYTE buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
            BOOL bSecurityGooSucceeded = FALSE;
            //Granny's old fashioned LocalAlloc:
            BYTE Buffer1[256];
            BYTE Buffer2[16];

            // Create the SID for world
            cbAcl = GetSidLengthRequired(1);
            if (cbAcl < sizeof(Buffer2))
            {
                adminSid = (PSID) Buffer2;
                InitializeSid(
                    adminSid,
                    &sia,
                    1
                    );
                *GetSidSubAuthority(adminSid, 0) = SECURITY_WORLD_RID;
          
               // Create an ACL giving World all access.
                cbAcl = sizeof(ACL) +
                             (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                             GetLengthSid(adminSid);
                if (cbAcl < sizeof(Buffer1))
                {
                    acl = (PACL)&Buffer1;
                    if (InitializeAcl(
                        acl,
                        cbAcl,
                        ACL_REVISION
                        ))
                    {
                        if (AddAccessAllowedAce(
                            acl,
                            ACL_REVISION,
                            SYNCHRONIZE|MUTANT_QUERY_STATE|DELETE|READ_CONTROL, //|WRITE_OWNER|WRITE_DAC,
                            adminSid
                            ))
                        {
                            // Create a security descriptor with the above ACL.
                            pSD = (PSECURITY_DESCRIPTOR)buffer;
                            if (InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
                            {
                                if (SetSecurityDescriptorDacl(pSD, TRUE, acl, FALSE))
                                {
                                    // Fill in the SECURITY_ATTRIBUTES struct.
                                    sa.nLength = sizeof(sa);
                                    sa.lpSecurityDescriptor = pSD;
                                    sa.bInheritHandle = TRUE;

                                    bSecurityGooSucceeded = TRUE;
                                }
                            }
                        }
                    }
                }
            } 
#endif
            DDASSERT(0 == hExclusiveModeMutex);
            hExclusiveModeMutex = CreateMutex( 
#ifdef WINNT
                bSecurityGooSucceeded ? &sa : 
#endif
                    NULL,     //use default access if security goo failed.
                FALSE, 
                EXCLUSIVE_MODE_MUTEX_NAME );
#ifdef WINNT
            if (0 == hExclusiveModeMutex)
            {
                hExclusiveModeMutex = OpenMutex(
                    SYNCHRONIZE|DELETE,  // access flag
                    FALSE,    // inherit flag
                    EXCLUSIVE_MODE_MUTEX_NAME          // pointer to mutex-object name
                    );
            }
#endif

            if (hExclusiveModeMutex == 0)
            {
                DPF_ERR("Could not create exclusive mode mutex. exiting");
                return FALSE;
            }

            DDASSERT(0 == hCheckExclusiveModeMutex);
            hCheckExclusiveModeMutex = CreateMutex( 
#ifdef WINNT
                bSecurityGooSucceeded ? &sa : 
#endif
                    NULL,     //use default access if security goo failed.
                FALSE, 
                CHECK_EXCLUSIVE_MODE_MUTEX_NAME );

#ifdef WINNT
            if (0 == hCheckExclusiveModeMutex)
            {
                hCheckExclusiveModeMutex = OpenMutex(
                    SYNCHRONIZE|DELETE,  // access flag
                    FALSE,    // inherit flag
                    CHECK_EXCLUSIVE_MODE_MUTEX_NAME          // pointer to mutex-object name
                    );
            }
#endif
            if (hCheckExclusiveModeMutex == 0)
            {
                DPF_ERR("Could not create exclusive mode check mutex. exiting");
                CloseHandle(hExclusiveModeMutex);
                return FALSE;
            }
        }

        if (!MemInit())
        {
            DPF(0,"LEAVING, COULD NOT MemInit");
            CloseHandle(hExclusiveModeMutex);
            CloseHandle(hCheckExclusiveModeMutex);
            return FALSE;
        }


        // Do whatever it takes for D3D (mostly PSGP stuff)
        D3DDllMain(g_hModule, dwReason, lpvReserved);


        DPF(4, "====> EXIT: DLLMAIN(%08lx): Process Attach: %08lx", DllMain,
             pid);
        break;

    case DLL_PROCESS_DETACH:
        DPF(4, "====> ENTER: DLLMAIN(%08lx): Process Detach %08lx, tid=%08lx",
             DllMain, pid, GetCurrentThreadId());

        // Cleanup registry in CPixel
        CPixel__Cleanup();

        /*
         * disconnect from thunk, even if other cleanup code commented out...
         */

        MemFini();

        DDASSERT(0 != hExclusiveModeMutex);
        CloseHandle(hCheckExclusiveModeMutex);
        CloseHandle(hExclusiveModeMutex);
        FINIWINDLIST();

        // Do whatever it takes for D3D (mostly PSGP stuff)
        D3DDllMain(g_hModule, dwReason, lpvReserved);

        DPF(4, "====> EXIT: DLLMAIN(%08lx): Process Detach %08lx",
             DllMain, pid);
        break;

        /*
         * we don't ever want to see thread attach/detach
         */
#ifdef DEBUG
    case DLL_THREAD_ATTACH:
        DPF(4, "THREAD_ATTACH");
        break;

    case DLL_THREAD_DETACH:
        DPF(4,"THREAD_DETACH");
        break;
#endif
    default:
        break;
    }

    return TRUE;

} /* DllMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\ddrawpr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddrawpr.h
 *  Content:    DirectDraw private header file
 *  History:    Confidential. If we told you, we'd have to...
 *
 ***************************************************************************/

#ifndef __DDRAWPR_INCLUDED__
#define __DDRAWPR_INCLUDED__

#ifdef WIN95

#ifdef WINNT
#undef WINNT
#endif

#endif

#ifndef WIN95
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#endif

#ifdef WIN95
    #define WIN16_SEPARATE
#endif
#include "verinfo.h"

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <mmsystem.h>

#include <string.h>
#include <stddef.h>


#pragma warning( disable: 4704)

#include "dpf.h"

/*
 * registry stuff
 */
#include "ddreg.h"

#include "memalloc.h"

#include <objbase.h>
#include "ddrawi.h"
#include "d3d8ddi.h"
#include "dwininfo.h"


// Information stored on each device in the system
#define MAX_DX8_ADAPTERS     12

typedef struct _ADAPTERINFO
{
    GUID                Guid;
    char                DeviceName[MAX_PATH];
    BOOL                bIsPrimary;
    BOOL                bIsDisplay;
    DWORD               NumModes;
    D3DDISPLAYMODE*     pModeTable;
    D3DFORMAT           Unknown16;
    D3D8_DRIVERCAPS     HALCaps;
    UINT                HALFlags;
    BOOL                bNoDDrawSupport;
} ADAPTERINFO, * PADAPTERINFO;

#ifdef __cplusplus
    #include "d3d8p.h"
    #include "enum.hpp"
    #include "dxgint.h"
#endif



/*
 * Need this to get CDS_ macros under NT build environment for win95.
 * winuserp.h comes from private\windows\inc
 */
#ifdef NT_BUILD_ENVIRONMENT
    #ifdef WIN32
        #include "winuserp.h"
    #endif
#endif
#include "ids8.h"

/*
 * NT kernel mode stub(ish)s
 */
#ifndef WIN95
    #include "ddrawgdi.h"
#endif


/*
 * Direct3D interfacing defines.
 */
#ifdef __cplusplus
extern "C" {
#endif

/*
 * reminder
 */
#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) "):" str

/*
 * synchronization
 */

#ifdef WINNT
#define NT_USES_CRITICAL_SECTION
#endif

#include "ddheap.h"
#include "ddagp.h"

/* ddraw.dll exports */
#ifdef WIN95
    extern BOOL WINAPI DdCreateDirectDrawObject( LPDDRAWI_DIRECTDRAW_GBL pddd, LPGUID lpGuid, DWORD dwFlags );
    extern BOOL WINAPI DdReenableDirectDrawObject( LPDDRAWI_DIRECTDRAW_GBL pddd, LPBOOL pbNewMode );
    extern BOOL WINAPI DdQueryDirectDrawObject( LPDDRAWI_DIRECTDRAW_GBL pddd, LPDDHALINFO lpDDHALInfo, LPDDHAL_DDCALLBACKS pddHALDD, LPDDHAL_DDSURFACECALLBACKS pddHALDDSurface, LPDDHAL_DDPALETTECALLBACKS pddHALDDPalette, LPD3DHAL_CALLBACKS pd3dHALCallbacks, LPD3DHAL_GLOBALDRIVERDATA pd3dHALDriverData, LPDDHAL_DDEXEBUFCALLBACKS pddNTHALBufferCallbacks, LPVOID pVoid1, LPVOID pVoid2, LPVOID pVoid3 );
    extern ULONG WINAPI DdQueryDisplaySettingsUniqueness( VOID );
#endif


/* enum.cpp */
extern BOOL IsSupportedOp (D3DFORMAT Format, DDSURFACEDESC* pList, UINT NumElements, DWORD dwRequestedOps);

/* ddcreate.c */
extern BOOL IsVGADevice(LPSTR szDevice);
extern BOOL xxxEnumDisplayDevicesA(LPVOID lpUnused, DWORD iDevice, struct _DISPLAY_DEVICEA *pdd, DWORD dwFlags);
extern HMONITOR GetMonitorFromDeviceName(LPSTR szName);
extern void FetchDirectDrawData( PD3D8_DEVICEDATA pBaseData, void* pInitFunction, D3DFORMAT Unknown16, DDSURFACEDESC* pHalOpList, DWORD NumHalOps);
extern DWORD DirectDrawMsg(LPSTR msg);
extern BOOL InternalGetMonitorInfo(HMONITOR hMon, MONITORINFO *lpInfo);


#ifdef WINNT
extern BOOL GetCurrentMode(LPDDRAWI_DIRECTDRAW_GBL, LPDDHALINFO lpHalInfo, char *szDrvName);
extern HRESULT GetNTDeviceRect( LPSTR pDriverName, LPRECT lpRect );
#endif

extern HDC  DD_CreateDC(LPSTR pdrvname);
extern void DD_DoneDC(HDC hdc);

extern LONG xxxChangeDisplaySettingsExA(LPCSTR szDevice, LPDEVMODEA pdm, HWND hwnd, DWORD dwFlags,LPVOID lParam);
extern HRESULT InternalDirectDrawCreate( PD3D8_DEVICEDATA *lplpDD, PADAPTERINFO pDeviceInfo, D3DDEVTYPE DeviceType, VOID* pInitFunction, D3DFORMAT Unknown16, DDSURFACEDESC* pHalOpList, DWORD NumHalOps);
extern HRESULT InternalDirectDrawRelease(PD3D8_DEVICEDATA  pBaseData);

/* dddefwp.c */
extern HRESULT SetAppHWnd( LPDDRAWI_DIRECTDRAW_LCL thisg, HWND hWnd, DWORD dwFlags );
extern VOID CleanupWindowList( DWORD pid );
extern void ClipTheCursor(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPRECT lpRect);

/* drvinfo.c */
extern BOOL Voodoo1GoodToGo( GUID * pGuid );
extern void GetAdapterInfo( char* pDriverName, D3DADAPTER_IDENTIFIER8* pDI, BOOL bDisplayDriver, BOOL bGuidOnly, BOOL bDriverName);

DEFINE_GUID( guidVoodoo1A, 0x3a0cfd01,0x9320,0x11cf,0xac,0xa1,0x00,0xa0,0x24,0x13,0xc2,0xe2 );
DEFINE_GUID( guidVoodoo1B, 0xaba52f41,0xf744,0x11cf,0xb4,0x52,0x00,0x00,0x1d,0x1b,0x41,0x26 );

/*
 * macros for validating pointers
 */

#ifndef DEBUG
#define FAST_CHECKING
#endif

/*
 * VALIDEX_xxx macros are the same for debug and retail
 */
#define VALIDEX_PTR( ptr, size ) \
        (!IsBadReadPtr( ptr, size) )

#define VALIDEX_IID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( IID )) )

#define VALIDEX_PTR_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID )) )

#define VALIDEX_CODE_PTR( ptr ) \
        (!IsBadCodePtr( (FARPROC) ptr ) )

#define VALIDEX_GUID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( GUID ) ) )

#define VALIDEX_DDDEVICEIDENTIFIER_PTR( ptr ) (!IsBadWritePtr( ptr, sizeof( DDDEVICEIDENTIFIER )))
#define VALIDEX_DDDEVICEIDENTIFIER2_PTR( ptr ) (!IsBadWritePtr( ptr, sizeof( DDDEVICEIDENTIFIER2 )))


/*
 * These macros validate the size (in debug and retail) of callback
 * tables.
 *
 * NOTE: It is essential that the comparison against the current
 * callback size expected by this DirectDraw the comparison operator
 * be >= rather than ==. This is to ensure that newer drivers can run
 * against older DirectDraws.
 */
#define VALIDEX_DDCALLBACKSSIZE( ptr )                       \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ( ptr )->dwSize == DDCALLBACKSSIZE_V1   )   || \
            ( ( ptr )->dwSize >= DDCALLBACKSSIZE      ) ) )

#define VALIDEX_DDSURFACECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDSURFACECALLBACKSSIZE ) )

#define VALIDEX_DDPALETTECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDPALETTECALLBACKSSIZE ) )

#define VALIDEX_DDPALETTECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDPALETTECALLBACKSSIZE ) )

#define VALIDEX_DDEXEBUFCALLBACKSSIZE( ptr )                 \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDEXEBUFCALLBACKSSIZE ) )

#define VALIDEX_DDVIDEOPORTCALLBACKSSIZE( ptr )              \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDVIDEOPORTCALLBACKSSIZE ) )

#define VALIDEX_DDMOTIONCOMPCALLBACKSSIZE( ptr )              \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMOTIONCOMPCALLBACKSSIZE ) )

#define VALIDEX_DDCOLORCONTROLCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDCOLORCONTROLCALLBACKSSIZE ) )

#define VALIDEX_DDMISCELLANEOUSCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMISCELLANEOUSCALLBACKSSIZE ) )

#define VALIDEX_DDMISCELLANEOUS2CALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMISCELLANEOUS2CALLBACKSSIZE ) )

#define VALIDEX_D3DCALLBACKS2SIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( (( ptr )->dwSize >= D3DHAL_CALLBACKS2SIZE ) ))

#define VALIDEX_D3DCOMMANDBUFFERCALLBACKSSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= D3DHAL_COMMANDBUFFERCALLBACKSSIZE ) )

#define VALIDEX_D3DCALLBACKS3SIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= D3DHAL_CALLBACKS3SIZE ) )

#define VALIDEX_DDKERNELCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDKERNELCALLBACKSSIZE ) )

#define VALIDEX_DDUMODEDRVINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDHAL_DDUMODEDRVINFOSIZE ) )
#define VALIDEX_DDOPTSURFKMODEINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDOPTSURFACEKMODEINFOSIZE ) )

#define VALIDEX_DDOPTSURFUMODEINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDOPTSURFACEUMODEINFOSIZE ) )

#define VALIDEX_DDNTCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDNTCALLBACKSSIZE ) )

#ifndef FAST_CHECKING
#define VALID_DDKERNELCAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDKERNELCAPS ) ) && \
        (ptr->dwSize == sizeof( DDKERNELCAPS )) )
#define VALID_DWORD_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DWORD ) ))
#define VALID_BOOL_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( BOOL ) ))
#define VALID_HDC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( HDC ) ))
#define VALID_RGNDATA_PTR( ptr, size ) \
        (!IsBadWritePtr( ptr, size ) )
#define VALID_PTR_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID )) )
#define VALID_IID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( IID )) )
#define VALID_HWND_PTR( ptr ) \
        (!IsBadWritePtr( (LPVOID) ptr, sizeof( HWND )) )
#define VALID_VMEM_PTR( ptr ) \
        (!IsBadWritePtr( (LPVOID) ptr, sizeof( VMEM )) )
#define VALID_POINTER_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID ) * cnt ) )
#define VALID_HANDLE_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( HANDLE )) )
#define VALID_DDCORECAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDCORECAPS ) ) && \
         (ptr->dwSize == sizeof( DDCORECAPS ) ) )
#define VALID_DWORD_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( DWORD ) * cnt ) )
#define VALID_GUID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( GUID ) ) )
#define VALID_BYTE_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( BYTE ) * cnt ) )
#define VALID_PTR( ptr, size ) \
        (!IsBadReadPtr( ptr, size) )
#define VALID_WRITEPTR( ptr, size ) \
        (!IsBadWritePtr( ptr, size) )

#else
#define VALID_PTR( ptr, size )          1
#define VALID_WRITEPTR( ptr, size )     1
#define VALID_DDKERNELCAPS_PTR( ptr) (ptr->dwSize == sizeof( DDKERNELCAPS ))
#define VALID_DWORD_PTR( ptr )  1
#define VALID_BOOL_PTR( ptr )   1
#define VALID_HDC_PTR( ptr )    1
#define VALID_RGNDATA_PTR( ptr )        1
#define VALID_PTR_PTR( ptr )    1
#define VALID_IID_PTR( ptr )    1
#define VALID_HWND_PTR( ptr )   1
#define VALID_VMEM_PTR( ptr )   1
#define VALID_POINTER_ARRAY( ptr, cnt ) 1
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt )    1
#define VALID_HANDLE_PTR( ptr ) 1
#define VALID_DDCORECAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDCORECAPS )
#define VALID_DWORD_ARRAY( ptr, cnt )   1
#define VALID_GUID_PTR( ptr )   1
#define VALID_BYTE_ARRAY( ptr, cnt ) 1

#endif

/*
 * All global data is should be just here.
 */

#define GLOBAL_STORAGE_CLASS extern

/*
 * This member should stay at the top in order to guarantee that it be intialized to zero
 * -see dllmain.c 's instance of this structure
 */
GLOBAL_STORAGE_CLASS    HINSTANCE           g_hModule;

/*
 * Winnt specific global statics
 */

GLOBAL_STORAGE_CLASS    HANDLE              hExclusiveModeMutex;
GLOBAL_STORAGE_CLASS    HANDLE              hCheckExclusiveModeMutex;


/*
 * IMPORTANT NOTE: This function validates the HAL information passed to us from the driver.
 * It is vital that we code this check so that we will pass HAL information structures
 * larger than the ones we know about so that new drivers can work with old DirectDraws.
 */
#define VALIDEX_DDHALINFO_PTR( ptr )                         \
        ( ( ( ( ptr )->dwSize == sizeof( DDHALINFO_V1 ) ) || \
            ( ( ptr )->dwSize == DDHALINFOSIZE_V2 )       || \
            ( ( ptr )->dwSize >= sizeof( DDHALINFO ) ) ) &&  \
          !IsBadWritePtr( ( ptr ), ( UINT ) ( ( ptr )->dwSize ) ) )


/* Turn on D3D stats collection for Debug builds HERE */
#define COLLECTSTATS    DBG

#ifdef __cplusplus
}       // extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\drvinfo.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	drvinfo.c
 *  Content:	DirectDraw driver info implementation
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   17-jun-98	jeffno  initial implementation, after michael lyons and toddla
 *   14-jun-99  mregen  return WHQL certification level -- postponed
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "ddrawpr.h"

#include <tchar.h>
#include <stdio.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <softpub.h>
#include <mscat.h>



//========================================================================
//
// just some handy forward declarations
//
DWORD GetWHQLLevel(LPTSTR lpszDriver, LPSTR lpszWin9xDriver);
DWORD IsFileDigitallySigned(LPTSTR lpszDriver);
BOOL FileIsSignedOld(LPTSTR lpszFile);

//
//  These functions are defined in mscat.h. They are not available on win95,
//  so we have to use LoadLibrary to load mscat32.dll and wincrypt.dll
//
typedef HCATINFO WINAPI funcCryptCATAdminEnumCatalogFromHash(HCATADMIN hCatAdmin,
                                                             BYTE *pbHash,
                                                             DWORD cbHash,
                                                             DWORD dwFlags,
                                                             HCATINFO *phPrevCatInfo);
typedef BOOL WINAPI funcCryptCATAdminCalcHashFromFileHandle(HANDLE hFile,
                                                            DWORD *pcbHash,
                                                            BYTE *pbHash,
                                                            DWORD dwFlags);
typedef HANDLE WINAPI funcCryptCATOpen(LPWSTR pwszFileName, 
                                        DWORD fdwOpenFlags,
                                        HCRYPTPROV hProv,
                                        DWORD dwPublicVersion,
                                        DWORD dwEncodingType);
typedef BOOL WINAPI funcCryptCATClose(IN HANDLE hCatalog);
typedef CRYPTCATATTRIBUTE * WINAPI funcCryptCATGetCatAttrInfo(HANDLE hCatalog,
                                                           LPWSTR pwszReferenceTag);
typedef BOOL WINAPI      funcCryptCATAdminAcquireContext(HCATADMIN *phCatAdmin, 
                                                        GUID *pgSubsystem, 
                                                        DWORD dwFlags);
typedef BOOL WINAPI      funcCryptCATAdminReleaseContext(HCATADMIN hCatAdmin,
                                                         DWORD dwFlags);
typedef BOOL WINAPI funcCryptCATAdminReleaseCatalogContext(HCATADMIN hCatAdmin,
                                                       HCATINFO hCatInfo,
                                                       DWORD dwFlags);
typedef BOOL WINAPI funcCryptCATCatalogInfoFromContext(HCATINFO hCatInfo,
                                                   CATALOG_INFO *psCatInfo,
                                                   DWORD dwFlags);

typedef CRYPTCATATTRIBUTE * WINAPI funcCryptCATEnumerateCatAttr(HCATINFO hCatalog,
                                                           CRYPTCATATTRIBUTE *lpCat);


//
//  function defined in wincrypt.dll
//
typedef LONG WINAPI funcWinVerifyTrust(HWND hwnd, GUID *pgActionID,
                                  LPVOID pWVTData);

//
//  our storage for the mscat32/wincrypt dll loader
//
typedef struct tagCatApi {
    BOOL bInitialized;
    HINSTANCE hLibMSCat;
    HINSTANCE hLibWinTrust;
    HCATADMIN hCatAdmin;
    funcCryptCATClose *pCryptCATClose;
    funcCryptCATGetCatAttrInfo *pCryptCATGetCatAttrInfo;
    funcCryptCATOpen *pCryptCATOpen;
    funcCryptCATAdminEnumCatalogFromHash *pCryptCATAdminEnumCatalogFromHash;
    funcCryptCATAdminCalcHashFromFileHandle *pCryptCATAdminCalcHashFromFileHandle;
    funcCryptCATAdminAcquireContext *pCryptCATAdminAcquireContext;
    funcCryptCATAdminReleaseContext *pCryptCATAdminReleaseContext;
    funcCryptCATAdminReleaseCatalogContext *pCryptCATAdminReleaseCatalogContext;
    funcCryptCATCatalogInfoFromContext *pCryptCATCatalogInfoFromContext;
    funcCryptCATEnumerateCatAttr *pCryptCATEnumerateCatAttr;
    funcWinVerifyTrust *pWinVerifyTrust;
} CATAPI,* LPCATAPI;

//========================================================================
//
// some helper functions to open/close crypt API
//
#undef DPF_MODNAME
#define DPF_MODNAME "InitCATAPI"


BOOL InitCATAPI(LPCATAPI lpCatApi)
{
    UINT uiOldErrorMode;
    HINSTANCE hLibMSCat;
    HINSTANCE hLibWinTrust;

    DDASSERT(lpCatApi!=NULL);
    ZeroMemory(lpCatApi, sizeof(CATAPI));

    // already initialized by ZeroMemory
    // lpCatApi->bInitialized=FALSE:

    uiOldErrorMode=SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hLibMSCat=LoadLibrary("mscat32.dll");
    hLibWinTrust=LoadLibrary("wintrust.dll");

    if (hLibMSCat!=NULL &&
        hLibWinTrust!=NULL)
    {
        lpCatApi->pCryptCATOpen=(funcCryptCATOpen *)
            GetProcAddress (hLibMSCat, "CryptCATOpen");
        lpCatApi->pCryptCATClose=(funcCryptCATClose *)
            GetProcAddress (hLibMSCat, "CryptCATClose");
        lpCatApi->pCryptCATGetCatAttrInfo=(funcCryptCATGetCatAttrInfo *)
            GetProcAddress (hLibMSCat, "CryptCATGetCatAttrInfo");
        lpCatApi->pCryptCATAdminCalcHashFromFileHandle=(funcCryptCATAdminCalcHashFromFileHandle*)
            GetProcAddress (hLibMSCat, "CryptCATAdminCalcHashFromFileHandle");
        lpCatApi->pCryptCATAdminEnumCatalogFromHash=(funcCryptCATAdminEnumCatalogFromHash*)
            GetProcAddress (hLibMSCat, "CryptCATAdminEnumCatalogFromHash");
        lpCatApi->pCryptCATAdminAcquireContext=(funcCryptCATAdminAcquireContext*)
            GetProcAddress (hLibMSCat, "CryptCATAdminAcquireContext");
        lpCatApi->pCryptCATAdminReleaseContext=(funcCryptCATAdminReleaseContext*)
            GetProcAddress (hLibMSCat, "CryptCATAdminReleaseContext");
        lpCatApi->pCryptCATAdminReleaseCatalogContext=(funcCryptCATAdminReleaseCatalogContext*)
            GetProcAddress (hLibMSCat, "CryptCATAdminReleaseCatalogContext");
        lpCatApi->pCryptCATCatalogInfoFromContext=(funcCryptCATCatalogInfoFromContext*)
            GetProcAddress (hLibMSCat, "CryptCATCatalogInfoFromContext");
        lpCatApi->pCryptCATEnumerateCatAttr=(funcCryptCATEnumerateCatAttr*)
            GetProcAddress (hLibMSCat, "CryptCATEnumerateCatAttr");
        lpCatApi->pWinVerifyTrust=(funcWinVerifyTrust*)
            GetProcAddress (hLibWinTrust,"WinVerifyTrust");

        if (lpCatApi->pCryptCATOpen!=NULL &&
            lpCatApi->pCryptCATClose!=NULL &&
            lpCatApi->pCryptCATGetCatAttrInfo!=NULL &&
            lpCatApi->pCryptCATAdminCalcHashFromFileHandle!=NULL &&
            lpCatApi->pCryptCATAdminEnumCatalogFromHash!=NULL &&
            lpCatApi->pCryptCATAdminAcquireContext!=NULL &&
            lpCatApi->pCryptCATAdminReleaseContext!=NULL &&
            lpCatApi->pCryptCATAdminReleaseCatalogContext!=NULL &&
            lpCatApi->pCryptCATCatalogInfoFromContext!=NULL &&
            lpCatApi->pCryptCATEnumerateCatAttr !=NULL &&
            lpCatApi->pWinVerifyTrust!=NULL
           )
        {
            if ((*lpCatApi->pCryptCATAdminAcquireContext)(&lpCatApi->hCatAdmin,NULL,0))
            {
                lpCatApi->hLibMSCat=hLibMSCat;
                lpCatApi->hLibWinTrust=hLibWinTrust;
                lpCatApi->bInitialized=TRUE;
            }
        } 
    }

    if (!lpCatApi->bInitialized)
    {
       FreeLibrary(hLibMSCat);
       FreeLibrary(hLibWinTrust);
    }

    SetErrorMode(uiOldErrorMode);

    return lpCatApi->bInitialized;
}

BOOL ReleaseCATAPI(LPCATAPI lpCatApi)
{
    DDASSERT(lpCatApi!=NULL);

    if (lpCatApi->bInitialized)
    {
        (*lpCatApi->pCryptCATAdminReleaseContext)(lpCatApi->hCatAdmin, 0);

        FreeLibrary(lpCatApi->hLibMSCat);
        FreeLibrary(lpCatApi->hLibWinTrust);
        ZeroMemory(lpCatApi, sizeof(CATAPI));        

        return TRUE;
    }

    return FALSE;
}

//========================================================================
//
// _strstr
//
// String-in-string function, written to avoid RTL inclusion necessity.
//
//========================================================================
char *_strstr(char *s1, char *s2)
{
	if (s1 && s2)
	{
		while (*s1)
		{
			char *p1=s1;
			char *p2=s2;

			while (*p2 && (*p1==*p2))
			{
				p1++;
				p2++;
			}
			if (*p2==0)
				return s1;

			s1++;
		}
	}

	return NULL;
}
//***&&*%**!!ing c runtime

DWORD _atoi(char * p)
{
    DWORD dw=0;
    while ((*p >= '0' && *p <= '9') || (*p >= 'A' && *p <= 'F') || (*p >= 'A' && *p <= 'F'))
    {
        dw = dw*16;
        if (*p >= 'a')
            dw += *p-'a' + 10;
        else if (*p >= 'A')
            dw += *p-'A' + 10;
        else
            dw += *p-'0';

        p++;
    }
    return dw;
}

char *FindLast(char * s, char c)
{
    char * pFound=0;
    if (s)
    {
        while (*s)
        {
            if (*s == c)
                pFound = s;
            s++;
        }
    }
    return pFound;
}

//========================================================================
// hard-coded vendor IDs
//========================================================================
#define VEN_3DFX			"VEN_121A"
#define VEN_3DFXVOODOO1                 "VEN_121A&DEV_0001"
#define VEN_POWERVR			"VEN_1033"

#ifdef WIN95

void GetFileVersionData (D3DADAPTER_IDENTIFIER8* pDI)
{
    void *				buffer;
    VS_FIXEDFILEINFO *	verinfo;
    DWORD				dwSize;
    DWORD                               dwHi,dwLo;

    //Failure means 0 returned
    pDI->DriverVersion.HighPart = 0;
    pDI->DriverVersion.LowPart = 0;

    dwSize = GetFileVersionInfoSize (pDI->Driver, 0);

    if (!dwSize)
    {
        return;
    }

    buffer=MemAlloc(dwSize);
    if (!buffer)
    {
        return;
    }

    if (!GetFileVersionInfo(pDI->Driver, 0, dwSize, buffer))
    {
        MemFree(buffer);
        return;
    }

    if (!VerQueryValue(buffer, "\\", (void **)&verinfo, (UINT *)&dwSize))
    {
        MemFree(buffer);
        return;
    }

    pDI->DriverVersion.HighPart = verinfo->dwFileVersionMS;
    pDI->DriverVersion.LowPart  = verinfo->dwFileVersionLS;

    MemFree(buffer);
}

extern HRESULT _GetDriverInfoFromRegistry(char *szClass, char *szClassNot, char *szVendor, D3DADAPTER_IDENTIFIER8* pDI, char *szDeviceID);

/*
 * following are all the 9x-specific version functions
 */
void GetHALName(char* pDriverName, D3DADAPTER_IDENTIFIER8* pDI)
{
    pDI->Driver[0] = '\0';
    D3D8GetHALName(pDriverName, pDI->Driver);
}


BOOL CheckPowerVR(D3DADAPTER_IDENTIFIER8* pDI)
{
#if 0
    BOOL    bFound=FALSE;
    HKEY    hKey;
    DWORD   dwSize;
    DWORD   dwType;

    if (pdrv->dwFlags & DDRAWI_SECONDARYDRIVERLOADED)
    {
        /*
         * Any secondary driver information in the registry at all? (assert this is true)
         */
        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
                                         REGSTR_PATH_SECONDARY,
                                        &hKey))
        {
            /*
             * Extract the name of the secondary driver's DLL. (assert this works)
             */
            dwSize = sizeof(pDI->di.szDriver) - 1;
            if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                  REGSTR_VALUE_SECONDARY_DRIVERNAME,
                                                  NULL,
                                                  &dwType,
                                                  pDI->di.szDriver,
                                                  &dwSize))
            {
                if (REG_SZ == dwType)
                {
                    GetFileVersionData(pDI);
                }
            }
            RegCloseKey(hKey);
        }

        if (SUCCEEDED(_GetDriverInfoFromRegistry(NULL, "Display", VEN_POWERVR, pDI)))
        {
            //got PVR data...
            bFound = TRUE;
        }
    }
    return bFound;
#endif
    return TRUE;
}

HRESULT Check3Dfx (D3DADAPTER_IDENTIFIER8* pDI)
{
    HRESULT hr = S_OK;
    char    szDeviceID[MAX_DDDEVICEID_STRING];

    if (FAILED(_GetDriverInfoFromRegistry(NULL, "Display", VEN_3DFX, pDI, szDeviceID)))
    {
        DPF_ERR("Couldn't get registry data for this device");
        hr = E_FAIL;
    }

    return hr;
}

HRESULT GetDriverInfoFromRegistry(char *szClass, char *szClassNot, char *szVendor, D3DADAPTER_IDENTIFIER8* pDI, char *szDeviceID)
{
    return _GetDriverInfoFromRegistry(szClass, szClassNot, szVendor, pDI, szDeviceID);
}


/*
 * Given a DISPLAY_DEVICE, get driver name
 * NOTE::: THIS FUNCTION NUKES THE DISPLAY_DEVICE.DeviceKey STRING!!!!
 */
void GetWin9XDriverName(DISPLAY_DEVICEA * pdd, LPSTR pDrvName)
{
    HKEY hKey;

    lstrcat(pdd->DeviceKey, "\\DEFAULT");
    if (ERROR_SUCCESS == RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            pdd->DeviceKey,
                            0,
                            KEY_QUERY_VALUE ,
                            &hKey))
    {
        DWORD dwSize = MAX_DDDEVICEID_STRING;
        DWORD dwType = 0;

        RegQueryValueEx(hKey,
                         TEXT("drv"),
                         NULL,
                         &dwType,
                         pDrvName,
                         &dwSize);

        RegCloseKey(hKey);
    }
}

#else //win95


HRESULT Check3Dfx(D3DADAPTER_IDENTIFIER8* pDI)
{
    return E_FAIL;
}

HRESULT GetDriverInfoFromRegistry(char *szClass, char *szClassNot, char *szVendor, D3DADAPTER_IDENTIFIER8* pDI, char *szDeviceID)
{
    return E_FAIL;
}

/*
 * Given a DISPLAY_DEVICE, get driver name, assuming winnt5
 * NOTE::: THIS FUNCTION NUKES THE DISPLAY_DEVICE.DeviceKey STRING!!!!
 */
void GetNTDriverNameAndVersion(DISPLAY_DEVICEA * pdd, D3DADAPTER_IDENTIFIER8* pDI)
{
    HKEY                hKey;
    void*               buffer;
    DWORD               dwSize;
    VS_FIXEDFILEINFO*   verinfo;

    //
    //  old style to determine display driver...returns name of miniport!
    //

    char * pTemp;

    // The device key has the form blah\blah\services\<devicekey>\DeviceN
    // So we back up one node:
    if ((pTemp = FindLast(pdd->DeviceKey,'\\')))
    {
        char * pTempX;
        char cOld=*pTemp;
        *pTemp = 0;

        //If we back up one node, we'll have the registry key under which the driver is stored. Let's use that!
        if ((pTempX = FindLast(pdd->DeviceKey,'\\')))
        {
            lstrcpyn(pDI->Driver, pTemp+1, sizeof(pDI->Driver));
            //ATTENTION No point getting version data without a filname:
            //We need a new service or something to get the used display driver name
            //GetFileVersionData(pDI);
        }

        *pTemp=cOld;
    }

    //
    //  we can find the display driver in a registry key
    //
    //  note: InstalledDisplayDrivers can contain several entries
    //  to display drivers Since there is no way to find out which
    //  one is the active one, we always return the first as being
    //  the display driver!
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(
                         HKEY_LOCAL_MACHINE,
                         pdd->DeviceKey+18,
                         0,
                         KEY_QUERY_VALUE ,
                        &hKey))
        {
        DWORD dwSize = sizeof(pDI->Driver);
        DWORD dwType = 0;
        if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                              TEXT("InstalledDisplayDrivers"),
                                              NULL,
                                              &dwType,
                                              pDI->Driver,
                                              &dwSize))
        {   
            lstrcat(pDI->Driver, TEXT(".dll"));
        }

        RegCloseKey(hKey);
    }

    // We have the name, now get the version

    pDI->DriverVersion.HighPart = 0;
    pDI->DriverVersion.LowPart = 0;

    dwSize=GetFileVersionInfoSize(pDI->Driver, 0);
    if (dwSize == 0)
        return;

    buffer = MemAlloc(dwSize);
    if (buffer == NULL)
        return;

    if (!GetFileVersionInfo(pDI->Driver, 0, dwSize, buffer))
    {
        MemFree(buffer);
        return;
    }

    if (!VerQueryValue(buffer, "\\", (void **)&verinfo, (UINT *)&dwSize))
    {
        MemFree(buffer);
        return;
    }

    pDI->DriverVersion.HighPart = verinfo->dwFileVersionMS;
    pDI->DriverVersion.LowPart  = verinfo->dwFileVersionLS;

    MemFree(buffer);
}
#endif //win95



void GenerateIdentifier(D3DADAPTER_IDENTIFIER8* pDI)
{
    LPDWORD pdw;

    CopyMemory(&pDI->DeviceIdentifier, &CLSID_DirectDraw, sizeof(pDI->DeviceIdentifier));

    //The device IDs get XORed into the whole GUID with the vendor and device ID in the 
    //first two DWORDs so they don't get XORed with anything else. This makes it 
    DDASSERT(sizeof(GUID) >= 4*sizeof(DWORD));
    pdw = (LPDWORD) &pDI->DeviceIdentifier;
    pdw[0] ^= pDI->VendorId;
    pdw[1] ^= pDI->DeviceId;
    pdw[2] ^= pDI->SubSysId;
    pdw[3] ^= pDI->Revision;

    // The driver version gets XORed into the last two DWORDs of the GUID:
    pdw[2] ^= pDI->DriverVersion.LowPart;
    pdw[3] ^= pDI->DriverVersion.HighPart;
}


void ParseDeviceId(D3DADAPTER_IDENTIFIER8* pDI, char *szDeviceID)
{
    char * p;

    DPF(5,"Parsing %s",szDeviceID);

    pDI->VendorId = 0;
    pDI->DeviceId = 0;
    pDI->SubSysId = 0;
    pDI->Revision = 0;

    if (p =_strstr(szDeviceID, "VEN_"))
        pDI->VendorId = _atoi(p + 4);

    if (p = _strstr(szDeviceID, "DEV_"))
        pDI->DeviceId = _atoi(p + 4);

    if (p = _strstr(szDeviceID, "SUBSYS_"))
        pDI->SubSysId = _atoi(p + 7);

    if (p = _strstr(szDeviceID, "REV_"))
        pDI->Revision = _atoi(p + 4);
}



void GetAdapterInfo(char* pDriverName, D3DADAPTER_IDENTIFIER8* pDI, BOOL bDisplayDriver, BOOL bGuidOnly, BOOL bDriverName)
{
    HRESULT                     hr = S_OK;
    int                         n;
    DISPLAY_DEVICEA             dd;
    BOOL                        bFound;
    char                        szDeviceID[MAX_DDDEVICEID_STRING];
#ifndef WINNT
    static char                 szWin9xName[MAX_DDDEVICEID_STRING];
#endif

    memset(pDI, 0, sizeof(*pDI));
    szDeviceID[0] = 0;
    #ifndef WINNT

        // On Win9X, it's pretty expensive to get the driver name, so we
        // only want to get it when we really need it
        
        szWin9xName[0] = '\0';
        if (bDriverName)
        {
            GetHALName(pDriverName, pDI);
            GetFileVersionData(pDI);
        }
    #endif

    // If it's a 3dfx, it's easy
      
    if (!bDisplayDriver)
    {
        hr = Check3Dfx(pDI);
    }
    else
    {
        // Not a 3dfx.  Next step: Figure out which display device we 
        // really are and get description string for it
                         
        ZeroMemory(&dd, sizeof(dd));
        dd.cb = sizeof(dd);

        bFound=FALSE;

        for(n=0; xxxEnumDisplayDevicesA(NULL, n, &dd, 0); n++)
        {
            if (0 == _stricmp(dd.DeviceName, pDriverName))
            {
                // Found the device. Now we can get some data for it.
                                
                lstrcpyn(pDI->Description, dd.DeviceString, sizeof(pDI->Description));
                lstrcpyn(szDeviceID, dd.DeviceID, sizeof(szDeviceID));

                bFound = TRUE;

                #ifdef WINNT
                    GetNTDriverNameAndVersion(&dd,pDI);
                #else
                    GetWin9XDriverName(&dd, szWin9xName);
                    if (pDI->Driver[0] == '\0')
                    {
                        lstrcpyn(pDI->Driver, szWin9xName, sizeof(pDI->Driver));
                    }
                #endif

                break;
            }

            ZeroMemory(&dd, sizeof(dd));
            dd.cb = sizeof(dd);
        }

        if (!bFound)
        {
            // Didn't find it: xxxEnumDisplayDevices failed, i.e. we're on 9x or NT4,
                            
            if (FAILED(GetDriverInfoFromRegistry("Display", NULL, NULL, pDI, szDeviceID)))
            {
                return;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        ParseDeviceId(pDI, szDeviceID);

        // Finally, for the primary only, check if a PowerVR is in and functioning
#if 0                
        if (0 == (dwFlags & DDGDI_GETHOSTIDENTIFIER))
        {
            if (IsVGADevice(pdrv->cDriverName) && CheckPowerVR(pDI))
            {
                ParseDeviceId(pDI, szDeviceID);
            }
        }
#endif

        // Munge driver version and ID into the identifier GUID.
                         
        GenerateIdentifier(pDI);

        // Now get the WHQL level

        if (!bGuidOnly)
        {
            #ifdef WINNT
                pDI->WHQLLevel = GetWHQLLevel((LPTSTR)pDI->Driver, NULL);
            #else
                pDI->WHQLLevel = GetWHQLLevel((LPTSTR)pDI->Driver, szWin9xName);
            #endif
        }
        else
        {
            pDI->WHQLLevel = 0;
        }
    }
}


/*
 * Voodoo1GoodToGo
 *
 * The Voodoo 1 driver will succeed the CreateDC call on Voodoo 2, Voodoo 3,
 * or Banshee hardware, but if we use the driver beyond that it will hang
 * the hardware.  This is a work around to not enumerate a Voodoo 1
 * driver if the hardware isn't there.
 *
 * To our knowledge, only two guids were ever used to enumerate Voodoo1
 * hardware, so we will look for those guids and assume that anything else
 * doesn't need to be checked.
 */
BOOL Voodoo1GoodToGo(GUID * pGuid)
{
    D3DADAPTER_IDENTIFIER8  DI;

    if (IsEqualIID(pGuid, &guidVoodoo1A) || IsEqualIID(pGuid, &guidVoodoo1B))
    {
        #ifdef WIN95
            char    szDeviceID[MAX_DDDEVICEID_STRING];

            /*
             * Now search the hardware enum key to see if Voodoo 1 hardware exists
             */
            if (FAILED(_GetDriverInfoFromRegistry(NULL, "Display", VEN_3DFXVOODOO1, &DI, szDeviceID)))
            {
                return FALSE;
            }
        #else
            return FALSE;
        #endif
    }
    return TRUE;
}

#ifndef WINNT
/****************************************************************************
 *
 *  FileIsSignedOld
 *
 *  find win95 style of signature
 *
 ****************************************************************************/
BOOL FileIsSignedOld(LPTSTR lpszFile)
{
typedef struct tagIMAGE_DOS_HEADER      // DOS .EXE header
{
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER, * PIMAGE_DOS_HEADER, FAR* LPIMAGE_DOS_HEADER;

typedef struct tagIMAGE_OS2_HEADER      // OS/2 .EXE header
{
    WORD   ne_magic;                    // Magic number
    CHAR   ne_ver;                      // Version number
    CHAR   ne_rev;                      // Revision number
    WORD   ne_enttab;                   // Offset of Entry Table
    WORD   ne_cbenttab;                 // Number of bytes in Entry Table
    LONG   ne_crc;                      // Checksum of whole file
    WORD   ne_flags;                    // Flag word
    WORD   ne_autodata;                 // Automatic data segment number
    WORD   ne_heap;                     // Initial heap allocation
    WORD   ne_stack;                    // Initial stack allocation
    LONG   ne_csip;                     // Initial CS:IP setting
    LONG   ne_sssp;                     // Initial SS:SP setting
    WORD   ne_cseg;                     // Count of file segments
    WORD   ne_cmod;                     // Entries in Module Reference Table
    WORD   ne_cbnrestab;                // Size of non-resident name table
    WORD   ne_segtab;                   // Offset of Segment Table
    WORD   ne_rsrctab;                  // Offset of Resource Table
    WORD   ne_restab;                   // Offset of resident name table
    WORD   ne_modtab;                   // Offset of Module Reference Table
    WORD   ne_imptab;                   // Offset of Imported Names Table
    LONG   ne_nrestab;                  // Offset of Non-resident Names Table
    WORD   ne_cmovent;                  // Count of movable entries
    WORD   ne_align;                    // Segment alignment shift count
    WORD   ne_cres;                     // Count of resource segments
    BYTE   ne_exetyp;                   // Target Operating system
    BYTE   ne_flagsothers;              // Other .EXE flags
    WORD   ne_pretthunks;               // offset to return thunks
    WORD   ne_psegrefbytes;             // offset to segment ref. bytes
    WORD   ne_swaparea;                 // Minimum code swap area size
    WORD   ne_expver;                   // Expected Windows version number
} IMAGE_OS2_HEADER, * PIMAGE_OS2_HEADER, FAR* LPIMAGE_OS2_HEADER;

typedef struct tagWINSTUB
{
    IMAGE_DOS_HEADER idh;
    BYTE             rgb[14];
} WINSTUB, * PWINSTUB, FAR* LPWINSTUB;

typedef struct tagFILEINFO
{
    BYTE   cbInfo[0x120];
} FILEINFO, * PFILEINFO, FAR* LPFILEINFO;


    FILEINFO           fi;
    int                nRC;
    LPIMAGE_DOS_HEADER lpmz;
    LPIMAGE_OS2_HEADER lpne;
    BYTE               cbInfo[9+32+2];
    BOOL               IsSigned = FALSE;
    OFSTRUCT           OpenStruct;
    HFILE              hFile;

    static WINSTUB winstub = {
        {
            IMAGE_DOS_SIGNATURE,            /* magic */
            0,                              /* bytes on last page - varies */
            0,                              /* pages in file - varies */
            0,                              /* relocations */
            4,                              /* paragraphs in header */
            1,                              /* min allocation */
            0xFFFF,                         /* max allocation */
            0,                              /* initial SS */
            0xB8,                           /* initial SP */
            0,                              /* checksum (ha!) */
            0,                              /* initial IP */
            0,                              /* initial CS */
            0x40,                           /* lfarlc */
            0,                              /* overlay number */
            { 0, 0, 0, 0},                 /* reserved */
           0,                              /* oem id */
            0,                              /* oem info */
            0,                              /* compiler bug */
            { 0},                          /* reserved */
            0x80,                           /* lfanew */
        },
        {
            0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
            0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21,
        }
    };

    OpenStruct.cBytes = sizeof(OpenStruct);
    lstrcpyn(OpenStruct.szPathName, lpszFile, OFS_MAXPATHNAME);
    hFile = OpenFile(lpszFile, &OpenStruct, OF_READ);
    if (hFile == HFILE_ERROR)
    {
        return FALSE;
    }

    nRC = 0;
    ReadFile((HANDLE) hFile, (LPVOID)&fi, sizeof(FILEINFO), &nRC, NULL);
    if (nRC != sizeof(FILEINFO))
    {
        goto FileIsSigned_exit;
    }

    lpmz = (LPIMAGE_DOS_HEADER)(&fi);
    lpne = (LPIMAGE_OS2_HEADER)((WORD)&fi + 0x80);

    winstub.idh.e_cblp = lpmz->e_cblp;
    winstub.idh.e_cp   = lpmz->e_cp;

    if (memcmp(&fi, &winstub, sizeof(winstub)) == 0)
    {
        goto FileIsSigned_exit;
    }

    memcpy(cbInfo, &((PWINSTUB)(&fi)->cbInfo)->rgb[14], sizeof(cbInfo));

    if ((cbInfo[4]      != ' ') ||    // space
         (cbInfo[8]      != ' ') ||    // space
         (cbInfo[9+32]   != '\n') ||    // return
         (cbInfo[9+32+1] != '$'))     // Dollar Sign
    {
        goto FileIsSigned_exit;
    }

    cbInfo[4] = 0;
    cbInfo[8] = 0;

    if ((strcmp((const char*)&cbInfo[0], "Cert") != 0) ||
         (strcmp((const char*)&cbInfo[5], "DX2")  != 0))
    {
        goto FileIsSigned_exit;
    }

    IsSigned=TRUE;

    FileIsSigned_exit:

    _lclose(hFile);

    return IsSigned;
}
#endif


/*
 * GetWHQLLevel - On Win95, look for old stamp only.  On Win2000, use digital
 *		signature only.  On Win98, look for old stamp first, then digital signature
 *		if no old stamp.
 *
 *      return 0 -- unsigned or uncertified
 *      return 1 -- driver certified
 *      return 1997 -- driver certified, PC97 compliant...
 *      return 1998...
 *
 *
 * arguments:
 *      
 * lpszDriver----Path of driver file
 * 
 */

DWORD GetWHQLLevel(LPTSTR lpszDriver, LPSTR lpszWin9xDriver)
{
    TCHAR szTmp[MAX_PATH];
    DWORD dwWhqlLevel = 0;

    // here we should rather call 
    if (GetSystemDirectory(szTmp, MAX_PATH-lstrlen(lpszDriver)-2)==0)
        return 0;

    lstrcat(szTmp, TEXT("\\"));
    lstrcat(szTmp, lpszDriver); 
    _tcslwr(szTmp);

    //
    // Look for a digital signature
    //
    dwWhqlLevel = IsFileDigitallySigned(szTmp);
    if (dwWhqlLevel != 0)
    {
        return dwWhqlLevel;
    }


#ifndef WINNT 
    
    // It wasn't digitally signed, but it may still have been signed
    // the old way.  On Win9X, however, lpszDriver actually contains the
    // 32 bit HAL name rather than the display driver, but we typically only
    // signed the display driver, so we should use lpszWin9xDriver.

    if (lpszWin9xDriver[0] != '\0')
    {
        GetSystemDirectory(szTmp, MAX_PATH-lstrlen(lpszWin9xDriver)-2);
        lstrcat(szTmp, TEXT("\\"));
        lstrcat(szTmp, lpszWin9xDriver); 
    }
    else
    {
        GetSystemDirectory(szTmp, MAX_PATH-lstrlen(lpszDriver)-2);
        lstrcat(szTmp, TEXT("\\"));
        lstrcat(szTmp, lpszDriver); 
    }

    if (FileIsSignedOld(szTmp))
    {
        return 1;
    }
#endif

    return 0;
}


DWORD IsFileDigitallySigned(LPTSTR lpszDriver)
{
    DWORD  dwWHQLLevel=0;         // default, driver not certified
    CATAPI catapi;
    WCHAR *lpFileName;
    DRIVER_VER_INFO VerInfo;
    TCHAR szBuffer[50];
    LPSTR lpAttr;
#ifndef UNICODE
    WCHAR wszDriver[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, lpszDriver, -1, wszDriver, MAX_PATH);
    lpFileName = wcsrchr(wszDriver, TEXT('\\'));
    if (lpFileName==NULL)
    {
        lpFileName = wszDriver;
    }
    else
    {
        lpFileName++;
    }
#else
    lpFileName = _tcsrchr(lpszDriver, TEXT('\\'));
    if (lpFileName==NULL) lpFileName = lpszDriver;
#endif


    //
    //  try to load and initialize the mscat32.dll and wintrust.dll
    //  these dlls are not available on win95
    //
    if (InitCATAPI(&catapi))
    {
        HANDLE hFile;
        DWORD  cbHashSize=0;
        BYTE  *pbHash;
        BOOL   bResult;

        //
        //  create a handle to our driver, because cat api wants handle to file
        //
        hFile = CreateFile(lpszDriver,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            0
                           );

        if (hFile!=INVALID_HANDLE_VALUE) 
        {
            // first query hash size...
            bResult=(*catapi.pCryptCATAdminCalcHashFromFileHandle)(hFile,
                                &cbHashSize,
                                NULL,
                                0);
            pbHash=NULL;
            if (bResult)
            {
                // allocate hash
                pbHash = MemAlloc(cbHashSize);                                       
            } 

            if (pbHash!=NULL)
            {
                HCATINFO hPrevCat=NULL;
                HANDLE hCatalog=NULL;
                WINTRUST_DATA WinTrustData;
                WINTRUST_CATALOG_INFO WinTrustCatalogInfo;
                GUID  guidSubSystemDriver = DRIVER_ACTION_VERIFY;
                CRYPTCATATTRIBUTE *lpCat = NULL;

                //
                //  Now get the hash for our file
                //

                bResult=(*catapi.pCryptCATAdminCalcHashFromFileHandle)(hFile,
                                    &cbHashSize,
                                    pbHash,
                                    0);

                if (bResult)
                {
                    hCatalog=(*catapi.pCryptCATAdminEnumCatalogFromHash)(
                                    catapi.hCatAdmin,
                                    pbHash,
                                    cbHashSize,
                                    0,
                                    &hPrevCat);
                }

                //
                // Initialize the structures that
                // will be used later on in calls to WinVerifyTrust.
                //
                ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
                WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
                WinTrustData.dwUIChoice = WTD_UI_NONE;
                WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
                WinTrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
                WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
                WinTrustData.pPolicyCallbackData = (LPVOID)&VerInfo;

                ZeroMemory(&VerInfo, sizeof(DRIVER_VER_INFO));
                VerInfo.cbStruct = sizeof(DRIVER_VER_INFO);

                WinTrustData.pCatalog = &WinTrustCatalogInfo;
        
                ZeroMemory(&WinTrustCatalogInfo, sizeof(WINTRUST_CATALOG_INFO));
                WinTrustCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
                WinTrustCatalogInfo.pbCalculatedFileHash = pbHash;
                WinTrustCatalogInfo.cbCalculatedFileHash = cbHashSize;
                WinTrustCatalogInfo.pcwszMemberTag = lpFileName;

                while (hCatalog)
                {
                    CATALOG_INFO CatInfo;

                    ZeroMemory(&CatInfo, sizeof(CATALOG_INFO));
                    CatInfo.cbStruct = sizeof(CATALOG_INFO);
                    if ((*catapi.pCryptCATCatalogInfoFromContext)(hCatalog, &CatInfo, 0)) 
                    {
                        HRESULT hRes;

                        WinTrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

                        // Now verify that the file is an actual member of the catalog.
                        hRes = (*catapi.pWinVerifyTrust)
                            (NULL, &guidSubSystemDriver, &WinTrustData);

                        if (hRes == ERROR_SUCCESS)
                        {
                            //
                            // Our driver is certified!  Now see if the cat
                            // info contains the WHQL level
                            //
                            CRYPTCATATTRIBUTE *lpCat = NULL;
                            HANDLE hCat;

                            dwWHQLLevel=1;              // return "certified"

                            hCat =  (*catapi.pCryptCATOpen)(CatInfo.wszCatalogFile, (DWORD)CRYPTCAT_OPEN_EXISTING, (HCRYPTPROV)NULL, 0, 0);
                            lpCat = (*catapi.pCryptCATGetCatAttrInfo) (hCat, L"KV_DISPLAY");
                            if (lpCat != NULL)
                            {
                                WideCharToMultiByte(CP_ACP, 0, (PUSHORT)lpCat->pbValue, -1, szBuffer, 50, NULL, NULL);

                                // The value looks like "1:yyyy-mm-dd".
          
                                lpAttr = _strstr(szBuffer, ":");
                                lpAttr++;
                                lpAttr[4] = '\0';
                                dwWHQLLevel = atoi(lpAttr) * 0x10000;
                                lpAttr[7] = '\0';
                                dwWHQLLevel |= atoi(&lpAttr[5]) * 0x100;
                                dwWHQLLevel |= atoi(&lpAttr[8]);
                            }

                            (*catapi.pCryptCATClose)(hCat);
                            break;
                        }
                    }

                    //
                    // iterate through catalogs...
                    //
                    hPrevCat=hCatalog;
                    hCatalog=(*catapi.pCryptCATAdminEnumCatalogFromHash)(
                                catapi.hCatAdmin,
                                pbHash,
                                cbHashSize,
                                0,
                                &hPrevCat);
                }

                //
                // we might have to free a catalog context!
                //
                if (hCatalog)
                {
                    (*catapi.pCryptCATAdminReleaseCatalogContext)
                        (catapi.hCatAdmin, hCatalog, 0);
                }

                //
                //  free hash
                //
                MemFree(pbHash);

            }

            CloseHandle(hFile);
        }
    }

    ReleaseCATAPI(&catapi);

    return dwWHQLLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\dwinproc.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dwinproc.cpp
 *  Content:    DirectDraw processing of Window messages
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   27-Jan-00  kanqiu  initial implementation
 ***************************************************************************/
#include "ddrawpr.h"

#include "swapchan.hpp"

#include "resource.inl"

#ifdef WINNT

#define USESHOWWINDOW

// WindowInfo structure
typedef struct _D3DWINDOWINFO
{
    DWORD                       dwMagic;
    HWND			hWnd;
    WNDPROC			lpWndProc;
    DWORD			dwFlags;
    CEnum                      *pEnum;
    DWORD			dwDDFlags;
} D3DWINDOWINFO;

// WindowInfo for our single hooked winproc
// This global variable should never never be accessed outside
// of this file.
D3DWINDOWINFO g_WindowInfo = {0, 0, 0, 0, 0, 0};

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::HIDESHOW_IME"

// IME hide/show function
void CSwapChain::HIDESHOW_IME()
{
    if (m_lSetIME)
    {                                          
        SystemParametersInfo(
            SPI_SETSHOWIMEUI, m_lSetIME - 1, NULL, 0);
        InterlockedExchange(&m_lSetIME, 0);
    }
} // HIDESHOW_IME

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::IsWinProcDeactivated"

BOOL CSwapChain::IsWinProcDeactivated() const
{
    // Do we even have our own win-proc?
    if (g_WindowInfo.hWnd != Device()->FocusWindow())
    {
        return FALSE;
    }

    // Check to see if our win-proc is deactivated then
    if (DDRAWILCL_ACTIVENO & g_WindowInfo.dwDDFlags)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
} // IsWinProcActive


#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::MakeFullscreen"
//
// make the passed window fullscreen and topmost and set a timer
// to make the window topmost again, what a hack.
//
void CSwapChain::MakeFullscreen()
{
    // We need to make sure that we don't send this
    // size message to the app
    g_WindowInfo.dwFlags |= WININFO_SELFSIZE;

    // Do the processing
    MONITORINFO MonInfo;
    MonInfo.rcMonitor.top = MonInfo.rcMonitor.left = 0;
    if (1 < Device()->Enum()->GetAdapterCount())
    {
        HMONITOR hMonitor = Device()->Enum()->
            GetAdapterMonitor(Device()->AdapterIndex());
        MonInfo.cbSize = sizeof(MONITORINFO);
        if (hMonitor)
            InternalGetMonitorInfo(hMonitor, &MonInfo);
    }
    SetWindowPos(m_PresentationData.hDeviceWindow, NULL,
        MonInfo.rcMonitor.left,
        MonInfo.rcMonitor.top,
        Width(),
        Height(),
        SWP_NOZORDER | SWP_NOACTIVATE);

    if (GetForegroundWindow() == Device()->FocusWindow())
    {
	// If the exclusive mode window is not visible, make it so.
	if (!IsWindowVisible(m_PresentationData.hDeviceWindow))
	{
	    ShowWindow(m_PresentationData.hDeviceWindow, SW_SHOW);
	}

        SetWindowPos(m_PresentationData.hDeviceWindow, HWND_TOPMOST, 0, 0, 0, 0,
            SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        // If the exclusive mode window is maximized, restore it.
        if (IsZoomed(m_PresentationData.hDeviceWindow))
        {
            ShowWindow(m_PresentationData.hDeviceWindow, SW_RESTORE);
        }
    }

    // We're done; so undo the self-size flag
    g_WindowInfo.dwFlags &= ~WININFO_SELFSIZE;

} // CSwapChain::MakeFullscreen


#undef DPF_MODNAME
#define DPF_MODNAME "handleActivateApp"

HRESULT handleActivateApp(BOOL is_active)
{
    // We are going to start touching some internal
    // data structures of the device and/or enum objects
    // so we have to take the critical section for the device
#ifdef DEBUG
    CLockD3D _lock(g_WindowInfo.pEnum, DPF_MODNAME, __FILE__);
#else
    CLockD3D _lock(g_WindowInfo.pEnum);
#endif 
    
    HRESULT                     ddrval;
    BOOL                        has_excl;
    CEnum                       *pEnum = g_WindowInfo.pEnum;

#ifdef  WINNT
    if (pEnum->CheckExclusiveMode(NULL, &has_excl, is_active) 
        && !has_excl && is_active)
    {
        // If we didn't get exclusive mode, for example, a different thread came in
        DPF_ERR("Could not get exclusive mode when we thought we could");
        return  E_FAIL;
    }
#endif  //WINNT

    /*
     * stuff to do before the mode set if deactivating
     */
    if (is_active)
    {
        /*
         * restore exclusive mode. Here we don't release the ref we took on the exclusive mode mutex,
         * since we want to keep the exclusive mode mutex.
         */
        pEnum->StartExclusiveMode();
    }
    else
    {
        /*
         * restore the mode
         */
        pEnum->DoneExclusiveMode();
    }
    return S_OK;
} /* handleActivateApp */

#undef DPF_MODNAME
#define DPF_MODNAME "WindowProc"

/*
 * WindowProc
 */
LRESULT WINAPI WindowProc(
                HWND hWnd,
                UINT uMsg,
                WPARAM wParam,
                LPARAM lParam)
{
    BOOL                        is_active;
    WNDPROC                     proc;
    BOOL                        get_away;
    LRESULT                     rc;

    /*
     * Check the window proc
     */
    if (g_WindowInfo.hWnd != hWnd || g_WindowInfo.dwMagic != WININFO_MAGIC)
    {
        DPF(4, "FATAL ERROR! Window Proc Called for hWnd %08lx, but not in list!", hWnd);
        DEBUG_BREAK();
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
    
    if (g_WindowInfo.dwFlags & WININFO_SELFSIZE)
    {
        return 0L;   // don't send to app, it's caused by MakeFullscreen
    }

    /*
     * unhook at destroy (or if the WININFO_UNHOOK bit is set)
     */
    proc = g_WindowInfo.lpWndProc;

    if (uMsg == WM_NCDESTROY)
    {
        DPF (4, "*** WM_NCDESTROY unhooking window ***");
        g_WindowInfo.dwFlags |= WININFO_UNHOOK;
    }

    if (g_WindowInfo.dwFlags & WININFO_UNHOOK)
    {
        DPF (4, "*** Unhooking window proc");

        if (g_WindowInfo.dwFlags & WININFO_ZOMBIE)
        {
            DPF (4, "*** Freeing ZOMBIE WININFO ***");
            ZeroMemory(&g_WindowInfo, sizeof(g_WindowInfo));
        }

        SetWindowLongPtr(hWnd, GWLP_WNDPROC, (INT_PTR) proc);

        rc = CallWindowProc(proc, hWnd, uMsg, wParam, lParam);
        return rc;
    }

    /*
     * Code to defer app activation of minimized app until it is restored.
     */
    switch(uMsg)
    {
    #ifdef WIN95
    case WM_POWERBROADCAST:
        if ((wParam == PBT_APMSUSPEND) || (wParam == PBT_APMSTANDBY))
    #else
    //winnt doesn't know about standby vs suspend
    case WM_POWER:
        if (wParam == PWR_SUSPENDREQUEST)
    #endif
        {
            DPF(4, "WM_POWERBROADCAST: deactivating application");
            SendMessage(hWnd, WM_ACTIVATEAPP, 0, GetCurrentThreadId());
        }
        break;
    case WM_SIZE:
        DPF(4, "WM_SIZE hWnd=%X wp=%04X, lp=%08X dwFlags=%08lx", hWnd, wParam, 
            lParam, g_WindowInfo.dwFlags);

        if (!(g_WindowInfo.dwFlags & WININFO_INACTIVATEAPP)
            && ((wParam == SIZE_RESTORED) || (wParam == SIZE_MAXIMIZED))
            && (GetForegroundWindow() == hWnd))
        {
#ifdef WINNT
            //
            // Wouldncha know it, but NT's messaging order is HUGELY different when alt-tabbing
            // between two exclusive mode apps. The first WM_SIZE sent to the activating app is
            // sent BEFORE the deactivating app loses FSE. This WM_SIZE is totally necessary to
            // reactivate the activating app, but it has to wait until the app loses FSE.
            // So, we simply wait on the exclusive mode mutex. This seems to work!
            //
            {
                DWORD dwWaitResult;
                dwWaitResult = WaitForSingleObject(hExclusiveModeMutex, INFINITE);
                switch (dwWaitResult)
                {
                case WAIT_OBJECT_0:
                case WAIT_ABANDONED:
                    ReleaseMutex(hExclusiveModeMutex);
                    break;
                case WAIT_TIMEOUT:
                default:
                    DDASSERT(!"Unexpected return value from WaitForSingleObject");
                }

            }
#endif
            DPF(4, "WM_SIZE: Window restored, sending WM_ACTIVATEAPP");
            PostMessage(hWnd, WM_ACTIVATEAPP, 1, GetCurrentThreadId());
        }
        else
        {
            DPF(4, "WM_SIZE: Window restored, NOT sending WM_ACTIVATEAPP");
        }
        break;

    case WM_ACTIVATEAPP:
        if (IsIconic(hWnd) && wParam)
        {
            DPF(4, "WM_ACTIVATEAPP: Ignoring while minimized");
            return 0;
        }
        else
        {
            g_WindowInfo.dwFlags |= WININFO_INACTIVATEAPP;
        }
        break;
    }

    /*
     * is directdraw involved here?
     */
    if (!(g_WindowInfo.dwFlags & WININFO_DDRAWHOOKED))
    {
        rc = CallWindowProc(proc, hWnd, uMsg, wParam, lParam);

        // clear the WININFO_INACTIVATEAPP bit, but make sure to make sure
        // we are still hooked!
        if (uMsg == WM_ACTIVATEAPP && (g_WindowInfo.hWnd == hWnd))
        {
            g_WindowInfo.dwFlags &= ~WININFO_INACTIVATEAPP;
        }
        return rc;
    }

#ifdef DEBUG
    if (!IsIconic(hWnd))
    {
        if (GetForegroundWindow() == hWnd)
        {
            HWND hwndT;
            RECT rc,rcT;

            GetWindowRect(hWnd, &rc);

            for (hwndT = GetWindow(hWnd, GW_HWNDFIRST);
                hwndT && hwndT != hWnd;
                hwndT = GetWindow(hwndT, GW_HWNDNEXT))
            {
                if (IsWindowVisible(hwndT))
                {
                    GetWindowRect(hwndT, &rcT);
                    if (IntersectRect(&rcT, &rcT, &rc))
                    {
                        DPF(4, "Window %08x is on top of us!!", hwndT);
                    }
                }
            }
        }
    }
#endif

    /*
     * NOTE: we don't take the DLL csect here.   By not doing this, we can
     * up the performance here.   However, this means that the application
     * could have a separate thread kill exclusive mode while window
     * messages were being processed.   This could cause our death.
     * Is this OK?
     */

    switch(uMsg)
    {
    /*
     * WM_SYSKEYUP
     *
     * watch for system keys of app trying to switch away from us...
     *
     * we only need to do this on Win95 because we have disabled all
     * the task-switching hot keys.  on NT we will get switched
     * away from normaly by the system.
     */
    case WM_SYSKEYUP:
        DPF(4, "WM_SYSKEYUP: wParam=%08lx lParam=%08lx", wParam, lParam);
        get_away = FALSE;
        if (wParam == VK_TAB)
        {
            if (lParam & 0x20000000l)
            {
                if (g_WindowInfo.dwFlags & WININFO_IGNORENEXTALTTAB)
                {
                    DPF(4, "AHHHHHHHHHHHH Ignoring AltTab");
                }
                else
                {
                    get_away = TRUE;
                }
            }
        }
        else if (wParam == VK_ESCAPE)
        {
            get_away = TRUE;
        }

        g_WindowInfo.dwFlags &= ~WININFO_IGNORENEXTALTTAB;

        if (get_away)
        {
            DPF(4, "Hot key pressed, switching away from app");
            PostMessage(hWnd, WM_ACTIVATEAPP, 0, GetCurrentThreadId());
        }
        break;

    /*
     * WM_SYSCOMMAND
     *
     * watch for screen savers, and don't allow them!
     *
     */
    case WM_SYSCOMMAND:

        switch(wParam)
        {
        case SC_SCREENSAVE:
            DPF(4, "Ignoring screen saver!");
            return 1;
        // allow window to be restored even if it has popup(s)
        case SC_RESTORE:
            ShowWindow(hWnd, SW_RESTORE);
            break;
        }
        break;

#ifdef USESHOWWINDOW
    case WM_DISPLAYCHANGE:
        DPF(4, "WM_DISPLAYCHANGE: %dx%dx%d", LOWORD(lParam), HIWORD(lParam), wParam);

        //
        //  WM_DISPLAYCHANGE is *sent* to the thread that called
        //  change display settings, we will most likely have the
        //  direct draw lock, make sure we set the WININFO_SELFSIZE
        //  bit while calling down the chain to prevent deadlock
        //
        g_WindowInfo.dwFlags |= WININFO_SELFSIZE;

        rc = CallWindowProc(proc, hWnd, uMsg, wParam, lParam);

        g_WindowInfo.dwFlags &= ~WININFO_SELFSIZE;

        return rc;
#endif

    /*
     * WM_ACTIVATEAPP
     *
     * the application has been reactivated.   In this case, we need to
     * reset the mode
     *
     */
    case WM_ACTIVATEAPP:

        is_active = (BOOL)wParam && GetForegroundWindow() == hWnd && !IsIconic(hWnd);

        if (!is_active && wParam != 0)
        {
            DPF(4, "WM_ACTIVATEAPP: setting wParam to 0, not realy active");
            wParam = 0;
        }

        if (is_active)
        {
            DPF(4, "WM_ACTIVATEAPP: BEGIN Activating app pid=%08lx, tid=%08lx",
                                    GetCurrentProcessId(), GetCurrentThreadId());
        }
        else
        {
            DPF(4, "WM_ACTIVATEAPP: BEGIN Deactivating app pid=%08lx, tid=%08lx",
                                    GetCurrentProcessId(), GetCurrentThreadId());
        }
        if (is_active && (g_WindowInfo.dwDDFlags & DDRAWILCL_ACTIVEYES))
        {
            DPF(4, "*** Already activated");
        }
        else
        if (!is_active && (g_WindowInfo.dwDDFlags & DDRAWILCL_ACTIVENO))
        {
            DPF(4, "*** Already deactivated");
        }
        else
        {
            if (FAILED(handleActivateApp(is_active)))
                break;
            DPF(4, "*** Active state changing");
            if (is_active)
            {
#ifdef DEBUG
                if (GetAsyncKeyState(VK_MENU) < 0)
                    DPF(4, "ALT key is DOWN");

                if (GetKeyState(VK_MENU) < 0)
                    DPF(4, "we think the ALT key is DOWN");
#endif DEBUG

                if (GetAsyncKeyState(VK_MENU) < 0)
                {
                    g_WindowInfo.dwFlags |= WININFO_IGNORENEXTALTTAB;
                    DPF(4, "AHHHHHHH Setting to ignore next alt tab");
                }
                else
                {
                    g_WindowInfo.dwFlags &= ~WININFO_IGNORENEXTALTTAB;
                }
            }

	    /*
	     * In the multi-mon scenario, it's possible that multiple
	     * devices are using this same window, so we need to do
	     * the following for each device.
	     */
            g_WindowInfo.dwDDFlags &= ~(DDRAWILCL_ACTIVEYES|DDRAWILCL_ACTIVENO);
            if (is_active)
            {
                g_WindowInfo.dwDDFlags |= DDRAWILCL_ACTIVEYES;
            }
            else
            {
                g_WindowInfo.dwDDFlags |= DDRAWILCL_ACTIVENO;
            }
        }
        #ifdef DEBUG
            if (is_active)
            {
                DPF(4, "WM_ACTIVATEAPP: DONE Activating app pid=%08lx, tid=%08lx",
                                        GetCurrentProcessId(), GetCurrentThreadId());
            }
            else
            {
                DPF(4, "WM_ACTIVATEAPP: DONE Deactivating app pid=%08lx, tid=%08lx",
                                        GetCurrentProcessId(), GetCurrentThreadId());
            }
        #endif

        rc = CallWindowProc(proc, hWnd, uMsg, wParam, lParam);

        // clear the WININFO_INACTIVATEAPP bit, but make sure to make sure
        // we are still hooked!
        if (g_WindowInfo.hWnd == hWnd)
        {
            g_WindowInfo.dwFlags &= ~WININFO_INACTIVATEAPP;
        }
        return rc;

        break;
    }
    rc = CallWindowProc(proc, hWnd, uMsg, wParam, lParam);
    return rc;

} /* WindowProc */

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::SetAppHWnd"

/*
 * SetAppHWnd
 *
 * Set the WindowList struct up with the app's hwnd info
 * Must be called with Device crit-sec taken and with the
 * Global Exclusive Mode Mutex
 */
HRESULT 
CSwapChain::SetAppHWnd()
{

    HWND    hWnd, hEnumWnd;

    if (m_PresentationData.Windowed)
        hWnd = NULL;
    else
        hWnd = Device()->FocusWindow();

    hEnumWnd = Device()->Enum()->ExclusiveOwnerWindow();
    if (hEnumWnd)
    {
        if (hEnumWnd == Device()->FocusWindow())
        {
            if (m_PresentationData.Windowed)
            {
                Device()->Enum()->SetFullScreenDevice(
                    Device()->AdapterIndex(), NULL);

                // If our enum still has a focus-
                // window then that means another
                // device has gone FS with the same
                // focus-window; so do nothing
                if (Device()->Enum()->ExclusiveOwnerWindow())
                    return DD_OK;             
                
                // Else, fall through so that
                // we tear down the winproc.
            }
            else
            {
                Device()->Enum()->SetFullScreenDevice(
                    Device()->AdapterIndex(), Device());
	        // Already hooked - no need to do more
                return DD_OK;
            }
        }
    } 

    /*
     * check if this isn't doing anything
     */
    if (hWnd == NULL && g_WindowInfo.hWnd == NULL)
    {
        return S_OK;
    }

    // Check if we have a case of different HWND trying to be hooked
    if (hWnd && g_WindowInfo.hWnd && g_WindowInfo.hWnd != hWnd)
    {
        DPF(1, "Hwnd %08lx no good: Different Hwnd (%08lx) already set for Device",
                            hWnd, g_WindowInfo.hWnd);
        return D3DERR_INVALIDCALL;
    }

    /*
     * are we shutting an HWND down?
     */
    if (hWnd == NULL)
    {
        if (IsWindow(g_WindowInfo.hWnd))
        {
            WNDPROC proc;

            proc = (WNDPROC) GetWindowLongPtr(g_WindowInfo.hWnd, GWLP_WNDPROC);

            if (proc != (WNDPROC) WindowProc &&
                proc != (WNDPROC) g_WindowInfo.lpWndProc)
            {
                DPF(3, "Window has been subclassed; cannot restore!");
                g_WindowInfo.dwFlags |= WININFO_ZOMBIE;
            }
            else if (GetWindowThreadProcessId(g_WindowInfo.hWnd, NULL) !=
                     GetCurrentThreadId())
            {
                DPF(3, "intra-thread window unhook, letting window proc do it");
                g_WindowInfo.dwFlags |= WININFO_UNHOOK;
                g_WindowInfo.dwFlags |= WININFO_ZOMBIE;
                PostMessage(g_WindowInfo.hWnd, WM_NULL, 0, 0);
            }
            else
            {
                DPF(4, "Unsubclassing window %08lx", g_WindowInfo.hWnd);
                SetWindowLongPtr(g_WindowInfo.hWnd, GWLP_WNDPROC, 
                    (INT_PTR) g_WindowInfo.lpWndProc);

                ZeroMemory(&g_WindowInfo, sizeof(g_WindowInfo));
            }
        }
        else
        {
            ZeroMemory(&g_WindowInfo, sizeof(g_WindowInfo));
        }

        Device()->Enum()->SetFullScreenDevice(
            Device()->AdapterIndex(), NULL);
    }
    /*
     * changing or adding an hwnd then...
     */
    else
    {
        /*
         * brand new object...
         */
        if (g_WindowInfo.dwMagic == 0)
        {
            g_WindowInfo.dwMagic = WININFO_MAGIC;
            g_WindowInfo.hWnd = hWnd;
            g_WindowInfo.lpWndProc = (WNDPROC) GetWindowLongPtr(hWnd, GWLP_WNDPROC);

            SetWindowLongPtr(hWnd, GWLP_WNDPROC, (INT_PTR) WindowProc);
        }

        g_WindowInfo.pEnum = Device()->Enum();
        g_WindowInfo.dwFlags |= WININFO_DDRAWHOOKED;

        // Sanity check
        DXGASSERT(Device()->Enum()->ExclusiveOwnerWindow() == NULL);

        Device()->Enum()->SetFullScreenDevice(
            Device()->AdapterIndex(), Device());
        DPF(4, "Subclassing window %08lx", g_WindowInfo.hWnd);
    }
    return S_OK;

} /* SetAppHWnd */
extern "C" void ResetUniqueness( HANDLE hDD );

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::DoneExclusiveMode"  
/*
 * DoneExclusiveMode
 */
void
CSwapChain::DoneExclusiveMode(BOOL bChangeWindow)
{
    HRESULT hr = S_OK;
    BOOL    bMinimize = TRUE;
    DPF(4, "DoneExclusiveMode");
    if (m_bExclusiveMode)
    {
        D3D8_SETMODEDATA SetModeData;
        m_bExclusiveMode = FALSE;
        DPF(4, "INACTIVE: %08lx: Restoring original mode (%dx%dx%dx%d)", 
            GetCurrentProcessId(), Device()->DesktopMode().Width,
            Device()->DesktopMode().Height,Device()->DesktopMode().Format,
            Device()->DesktopMode().RefreshRate);
        SetModeData.hDD = Device()->GetHandle();
        SetModeData.dwWidth = Device()->DesktopMode().Width;
        SetModeData.dwHeight = Device()->DesktopMode().Height;
        SetModeData.Format = Device()->DesktopMode().Format;
        SetModeData.dwRefreshRate = Device()->DesktopMode().RefreshRate;
        SetModeData.bRestore = TRUE;

        Device()->GetHalCallbacks()->SetMode(&SetModeData);
        if (SetModeData.ddRVal != S_OK)
        {
            DPF_ERR("Unable to restore to original desktop mode");
           // return SetModeData.ddRVal;
        }
        // some part of the runtime count on that SetMode cause device
        // lost, that's not true for whistler anymore if this fullscreen
        // mode happens to be the same as the original desktop mode.
        // so we ResetUniqueness to force the device to get lost.
        if (Device()->DesktopMode().Width == Width() && 
            Device()->DesktopMode().Height == Height() &&
            Device()->DesktopMode().Format == BackBufferFormat())
            ResetUniqueness(Device()->GetHandle());

        DPF(4, "Enabling error mode, hotkeys");
        SetErrorMode(m_uiErrorMode);

#ifdef WINNT
        // Restore cursor shadow coming out of fullscreen
        SystemParametersInfo(SPI_SETCURSORSHADOW, 0, (LPVOID)m_pCursorShadow, 0);
#endif

        // Restore reactive menus coming out of fullscreen:
        SystemParametersInfo(SPI_SETHOTTRACKING, 0, (LPVOID)m_pHotTracking, 0);
        InterlockedExchange(&m_lSetIME, m_lIMEState + 1);

#ifdef WINNT
        // Notify the display driver that we are chaning cooperative level

        D3D8_SETEXCLUSIVEMODEDATA   ExclusiveData;

        ExclusiveData.hDD  = Device()->GetHandle();
        ExclusiveData.dwEnterExcl = FALSE;
        Device()->GetHalCallbacks()->SetExclusiveMode(&ExclusiveData);
        /*
         * If RestoreDisplayMode failed, we are probably on a different desktop.  In this case,
         * we should not minimize the window or else things won't work right when we switch
         * back to the original desktop.
         */
        if (SetModeData.ddRVal != S_OK)
        {
            HDESK hDesktop;
            static BYTE szName1[256];
            static BYTE szName2[256];
            DWORD dwTemp;

            // Get the name of the current desktop
            hDesktop = OpenInputDesktop( 0, FALSE, DESKTOP_READOBJECTS );
            GetUserObjectInformation( hDesktop, UOI_NAME, szName1, sizeof( szName1 ), &dwTemp );
            CloseDesktop( hDesktop );

            // Get the name of the apps' desktop
            hDesktop = GetThreadDesktop( GetCurrentThreadId() );
            GetUserObjectInformation( hDesktop, UOI_NAME, szName2, sizeof( szName2 ), &dwTemp );
            if( lstrcmp( (const LPCSTR)szName1, (const LPCSTR)szName2 ) )
            {
                bMinimize = FALSE;
            }
        }
#endif
        if (bChangeWindow)
        {
            HIDESHOW_IME();
            /*
             * minimize window if deactivating
             */
            if (IsWindowVisible(m_PresentationData.hDeviceWindow) && bMinimize)
            {
                g_WindowInfo.dwFlags |= WININFO_SELFSIZE;
                #ifdef USESHOWWINDOW
                    ShowWindow(m_PresentationData.hDeviceWindow, SW_SHOWMINNOACTIVE);
                #else
                    SetWindowPos(m_PresentationData.hDeviceWindow, NULL, 0, 0, 0, 0,
                        SWP_NOZORDER | SWP_NOACTIVATE);
                #endif
                g_WindowInfo.dwFlags &= ~WININFO_SELFSIZE;
            }
        }
    }
} /* DoneExclusiveMode */

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::StartExclusiveMode"  
/*
 * StartExclusiveMode
 */
void 
CSwapChain::StartExclusiveMode(BOOL bChangeWindow)
{
    DWORD   dwWaitResult;
    DPF(4, "StartExclusiveMode");

    /*
     * Preceeding code should have taken this mutex already.
     */
    if (!m_bExclusiveMode)
    {
        m_bExclusiveMode = TRUE;
#if defined(WINNT) && defined(DEBUG)
        dwWaitResult = WaitForSingleObject(hExclusiveModeMutex, 0);
        DDASSERT(dwWaitResult == WAIT_OBJECT_0);
        ReleaseMutex(hExclusiveModeMutex);
#endif
        m_uiErrorMode = SetErrorMode(SEM_NOGPFAULTERRORBOX | 
            SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

#ifdef WINNT
        // Save current cursor shadow setting
        SystemParametersInfo(SPI_GETCURSORSHADOW, 0, (LPVOID) &(m_pCursorShadow), 0);
        SystemParametersInfo(SPI_SETCURSORSHADOW, 0, 0, 0);
#endif

        // Save current hot-tracking setting
        SystemParametersInfo(SPI_GETHOTTRACKING, 0, (LPVOID) &(m_pHotTracking), 0);
        SystemParametersInfo(SPI_GETSHOWIMEUI, 0, (LPVOID) &(m_lIMEState), 0);
    
        //And turn it off as we go into exclusive mode
        SystemParametersInfo(SPI_SETHOTTRACKING, 0, 0, 0);
        InterlockedExchange(&m_lSetIME, FALSE + 1);

#ifdef WINNT
        // Notify the display driver that we are chaning cooperative level

        D3D8_SETEXCLUSIVEMODEDATA   ExclusiveData;

        ExclusiveData.hDD  = Device()->GetHandle();
        ExclusiveData.dwEnterExcl = TRUE;
        Device()->GetHalCallbacks()->SetExclusiveMode(&ExclusiveData);
#endif
        if (bChangeWindow)
        {
            MakeFullscreen();
            HIDESHOW_IME();
            if (IsWindowVisible(m_PresentationData.hDeviceWindow))
            {
                g_WindowInfo.dwFlags |= WININFO_SELFSIZE;
                #ifdef USESHOWWINDOW
                    ShowWindow(m_PresentationData.hDeviceWindow, SW_SHOWNOACTIVATE);
                #else
                {
                    RECT rc;
                    SetRect(&rc,0,0,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
                    SetWindowPos(g_WindowInfo.hWnd, NULL,rc.left, rc.top,
                        rc.right  - rc.left,rc.bottom - rc.top,
                        SWP_NOZORDER | SWP_NOACTIVATE);
                }
                #endif
                g_WindowInfo.dwFlags &= ~WININFO_SELFSIZE;
            }
        }
    }
} /* StartExclusiveMode */

#endif  //WINNT
// End of file : dwinproc.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\dxcursor.hpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// dxcursor.hpp
//
// DX Cursor implementation. 
//
// Created 01/17/2000 kanqiu (Kan Qiu)
//=============================================================================

#ifndef __DXCURSOR_HPP__
#define __DXCURSOR_HPP__

#include "surface.hpp"

//-----------------------------------------------------------------------------
// CCursor
//-----------------------------------------------------------------------------

class CCursor 
{
public:
    CCursor(CBaseDevice *pDevice);

    ~CCursor();
    void    Destroy();

    HRESULT SetProperties(
        UINT    xHotSpot,
        UINT    yHotSpot,
        CBaseSurface *pCursorBitmap);

    void    SetPosition(UINT xScreenSpace,UINT yScreenSpace,DWORD Flags);
    BOOL    SetVisibility(BOOL bVisible);
    HRESULT Hide(HANDLE);
    HRESULT Show(HANDLE);
    void    Flip();
private:
    void    UpdateRects();
    HRESULT CursorInit(
        UINT xHotSpot,
        UINT yHotSpot,
        CBaseSurface *pCursorBitmap);

    DWORD                   m_dwCursorFlags;//cursor flags
    HANDLE                  m_hCursorDdb;   //device dependent Cursor image
    HANDLE                  m_hFrontSave;   //excluded front buffer
    HANDLE                  m_hBackSave;    //excluded back buffer
    UINT                    m_xCursorHotSpot;
    UINT                    m_yCursorHotSpot;
    UINT                    m_xCursor;
    UINT                    m_yCursor;
    UINT                    m_Width;
    UINT                    m_Height;
    RECT                    m_CursorRect;
    RECT                    m_BufferRect;
    RECT                    m_CursorRectSave;
    RECT                    m_BufferRectSave;
    CBaseDevice*            m_pDevice;
    HCURSOR                 m_hOsCursor;
    HCURSOR                 m_hHWCursor;
    POINT                   m_MonitorOrigin;    //(x,y) Monitor Top left
    UINT                    m_SavedMouseTrails;
}; // class CCursor
#define DDRAWI_CURSORISON   0x01
#define DDRAWI_CURSORINIT   0x02
#define DDRAWI_CURSORSAVERECT   0x04
#define DDRAWI_CURSORRECTSAVED  0x08
#endif // __DXCURSOR_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\dxgcreat.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxgcreat.cpp
 *  Content     Creates the dxg object
 *
 ***************************************************************************/
#include "ddrawpr.h"

// Includes for creation stuff
#include "mipmap.hpp"
#include "mipvol.hpp"
#include "cubemap.hpp"
#include "surface.hpp"
#include "vbuffer.hpp"
#include "ibuffer.hpp"
#include "swapchan.hpp"
#include "resource.hpp"
#include "d3di.hpp"
#include "resource.inl"

#ifdef WINNT
extern "C" BOOL IsWhistler();
#endif

//---------------------------------------------------------------------------
// CBaseDevice methods
//---------------------------------------------------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::AddRef"

STDMETHODIMP_(ULONG) CBaseDevice::AddRef(void)
{
    API_ENTER_NO_LOCK(this);

    // InterlockedIncrement requires the memory
    // to be aligned on DWORD boundary
    DXGASSERT(((ULONG_PTR)(&m_cRef) & 3) == 0);
    InterlockedIncrement((LONG *)&m_cRef);
    return m_cRef;
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::Release"

STDMETHODIMP_(ULONG) CBaseDevice::Release(void)
{
    API_ENTER_NO_LOCK(this);

    // InterlockedDecrement requires the memory
    // to be aligned on DWORD boundary
    DXGASSERT(((ULONG_PTR)(&m_cRef) & 3) == 0);
    InterlockedDecrement((LONG *)&m_cRef);
    if (m_cRef != 0)
        return m_cRef;

    // If we are about to release; we
    // DPF a warning if the release is on a different
    // thread than the create
    if (!CheckThread())
    {
        DPF_ERR("Final Release for a device can only be called "
                "from the thread that the "
                "device was created from.");

        // No failure can be returned; but this is
        // dangerous situation for the app since
        // windows messages may still be processed
    }

    delete this;
    return 0;
} // Release

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::QueryInterface"

STDMETHODIMP CBaseDevice::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    API_ENTER(this);

    if (!VALID_PTR_PTR(ppv))
    {
        DPF_ERR("Invalid pointer passed to QueryInterface for IDirect3DDevice8" );
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for IDirect3DDevice8");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IUnknown || riid == IID_IDirect3DDevice8)
    {
        *ppv = static_cast<void*>(static_cast<IDirect3DDevice8*>(this));
        AddRef();
    }
    else
    {
        DPF_ERR("Unsupported Interface identifier passed to QueryInterface for IDirect3DDevice8");
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    return S_OK;
} // QueryInterface


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateAdditionalSwapChain"

// Swap Chain stuff
STDMETHODIMP
CBaseDevice::CreateAdditionalSwapChain(
    D3DPRESENT_PARAMETERS *pPresentationParams,
    IDirect3DSwapChain8 **pSwapChain)
{
    API_ENTER(this);
    if (!VALID_WRITEPTR(pPresentationParams, sizeof(D3DPRESENT_PARAMETERS)))
    {
        DPF_ERR("Invalid D3DPRESENT_PARAMETERS pointer to CreateAdditionalSwapChain");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_PTR_PTR(pSwapChain))
    {
        DPF_ERR("Invalid IDirect3DSwapChain8* pointer to CreateAdditionalSwapChain");
        return D3DERR_INVALIDCALL;
    }

    // Zero out return param
    *pSwapChain = NULL;

    if (NULL == m_pSwapChain)
    {
        DPF_ERR("No Swap Chain present; CreateAdditionalSwapChain fails");
        return D3DERR_INVALIDCALL;
    }

    if (pPresentationParams->BackBufferFormat == D3DFMT_UNKNOWN)
    {
        DPF_ERR("Invalid backbuffer format specified. CreateAdditionalSwapChain fails");
        return D3DERR_INVALIDCALL;
    }

    if (m_pSwapChain->m_PresentationData.Windowed
        && pPresentationParams->Windowed)
    {
        // both device and swapchain have to be windowed
        HRESULT hr;

        if ((NULL == pPresentationParams->hDeviceWindow)
            && (NULL == FocusWindow()))
        {
            DPF_ERR("Neither hDeviceWindow nor Focus window specified. CreateAdditionalSwapChain fails");
            return D3DERR_INVALIDCALL;
        }

        *pSwapChain = new CSwapChain(
            this,
            REF_EXTERNAL);

        if (*pSwapChain == NULL)
        {
            DPF_ERR("Out of memory creating swap chain. CreateAdditionalSwapChain fails");
            return E_OUTOFMEMORY;
        }

        static_cast<CSwapChain *> (*pSwapChain) ->Init(
            pPresentationParams,
            &hr);

        if (FAILED(hr))
        {
            DPF_ERR("Failure initializing swap chain. CreateAdditionalSwapChain fails");
            (*pSwapChain)->Release();
            *pSwapChain = NULL;
            return hr;
        }
        return hr;
    }
    else
    {
        DPF_ERR("Can't Create Additional SwapChain for FullScreen");
        return D3DERR_INVALIDCALL;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::SetCursorProperties"
STDMETHODIMP
CBaseDevice::SetCursorProperties(
    UINT    xHotSpot,
    UINT    yHotSpot,
    IDirect3DSurface8 *pCursorBitmap)
{
    API_ENTER(this);

    if (pCursorBitmap == NULL)
    {
        DPF_ERR("Invalid parameter for pCursorBitmap");
        return D3DERR_INVALIDCALL;
    }
    CBaseSurface *pCursorSrc = static_cast<CBaseSurface*>(pCursorBitmap);
    if (pCursorSrc->InternalGetDevice() != this)
    {
        DPF_ERR("Cursor Surface wasn't allocated with this Device. SetCursorProperties fails");
        return D3DERR_INVALIDCALL;
    }

    if (SwapChain()->m_pCursor)
    {
        return SwapChain()->m_pCursor->SetProperties(
            xHotSpot,
            yHotSpot,
            pCursorSrc);
    }
    else
    {
        DPF_ERR("Device is lost. SetCursorProperties does nothing.");
        return S_OK;
    }
} // SetCursorProperties

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::SetCursorPosition"
STDMETHODIMP_(void)
CBaseDevice::SetCursorPosition(
    UINT xScreenSpace,
    UINT yScreenSpace,
    DWORD Flags)
{
    API_ENTER_VOID(this);

    if (SwapChain()->m_pCursor)
        SwapChain()->m_pCursor->SetPosition(xScreenSpace,yScreenSpace,Flags);
    else
        DPF_ERR("Device is lost. SetCursorPosition does nothing.");

    return;
} // SetCursorPosition

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::ShowCursor"
STDMETHODIMP_(BOOL)
CBaseDevice::ShowCursor(
    BOOL bShow  // cursor visibility flag
  )
{
    API_ENTER_RET(this, BOOL);

    if (SwapChain()->m_pCursor)
        return  m_pSwapChain->m_pCursor->SetVisibility(bShow);
    DPF_ERR("Device is lost. ShowCursor does nothing.");
    return FALSE;
} // ShowCursor


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::Reset"

STDMETHODIMP
CBaseDevice::Reset(
    D3DPRESENT_PARAMETERS *pPresentationParams
   )
{
    API_ENTER(this);
    HRESULT hr;

    if (!CheckThread())
    {
        DPF_ERR("Reset can only be called from the thread that the "
                "device was created from.");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_WRITEPTR(pPresentationParams, sizeof(D3DPRESENT_PARAMETERS)))
    {
        DPF_ERR("Invalid D3DPRESENT_PARAMETERS pointer, Reset fails");
        hr = D3DERR_INVALIDCALL;
        goto LoseDevice;
    }

    if (NULL == FocusWindow())
    {
        if (!pPresentationParams->Windowed)
        {
            DPF_ERR("Can't Reset a Device w/o Focus window to Fullscreen");
            hr = D3DERR_INVALIDCALL;
            goto LoseDevice;
        }
        else
        if (NULL == pPresentationParams->hDeviceWindow)
        {
            DPF_ERR("Neither hDeviceWindow nor Focus window specified. Reset fails.");
            hr = D3DERR_INVALIDCALL;
            goto LoseDevice;
        }
    }
    if (pPresentationParams->BackBufferFormat == D3DFMT_UNKNOWN)
    {
        DPF_ERR("Invalid backbuffer format specified. Reset fails");
        hr = D3DERR_INVALIDCALL;
        goto LoseDevice;
    }

    if (NULL == m_pSwapChain)
    {
        DPF_ERR("No Swap Chain present, Reset fails");
        hr = D3DERR_INVALIDCALL;
        goto LoseDevice;
    }

    hr = TestCooperativeLevel();
    if (D3DERR_DEVICELOST == hr)
    {
        DPF_ERR("Reset fails. D3DERR_DEVICELOST returned.");
        goto LoseDevice;
    }
    else if (D3DERR_DEVICENOTRESET == hr)
    {
        // There might be a external mode switch or ALT-TAB from fullscreen
        FetchDirectDrawData(GetDeviceData(), GetInitFunction(),
            Enum()->GetUnknown16(AdapterIndex()),
            Enum()->GetHalOpList(AdapterIndex()),
            Enum()->GetNumHalOps(AdapterIndex()));

        // only update the DesktopMode
        // if lost device was windowed or Fullscreen(but ALT-TABed away)
        // in Multimon case, even Fullscreen with exclusive mode Device could
        // be lost due to a mode change in other adapters and DesktopMode
        // should NOT be updated as it's the current fullscreen mode
        if (!SwapChain()->m_bExclusiveMode)
        {
            m_DesktopMode.Height = DisplayHeight();
            m_DesktopMode.Width = DisplayWidth();
            m_DesktopMode.Format = DisplayFormat();
            m_DesktopMode.RefreshRate = DisplayRate();
        }
    }
    else if (m_fullscreen)
    {
        SwapChain()->FlipToGDISurface();
    }

    if ( S_OK == hr && RenderTarget())
    {
        RenderTarget()->Sync();
    }

    static_cast<CD3DBase*>(this)->CleanupTextures();

    hr = m_pSwapChain->Reset(
        pPresentationParams);

    if (FAILED(hr))
    {
        goto LoseDevice;
    }

    if (pPresentationParams->EnableAutoDepthStencil)
    {
        // Need to validate that this Z-buffer matches
        // the HW
        hr = CheckDepthStencilMatch(pPresentationParams->BackBufferFormat,
                                    pPresentationParams->AutoDepthStencilFormat);
        if (FAILED(hr))
        {
            DPF_ERR("AutoDepthStencilFormat does not match BackBufferFormat "
                    "because the current Device requires the bitdepth of the "
                    "zbuffer to match the render-target. Reset Failed");
            goto LoseDevice;
        }

        IDirect3DSurface8 *pSurf;
        hr = CSurface::CreateZStencil(this,
                                      m_pSwapChain->Width(),
                                      m_pSwapChain->Height(),
                                      pPresentationParams->AutoDepthStencilFormat,
                                      pPresentationParams->MultiSampleType,
                                      REF_INTRINSIC,
                                      &pSurf);
        if (FAILED(hr))
        {
            DPF_ERR("Failure trying to create automatic zstencil surface. Reset Fails");
            goto LoseDevice;
        }
        DXGASSERT(m_pAutoZStencil == NULL);
        m_pAutoZStencil      = static_cast<CBaseSurface *>(pSurf);
    }

    // Disconnect Buffers from our device's state if there is any
    // I tried to not Destroy() upon window->window Reset
    // however, there are many other cares which require it,
    // such as device lost or m_pDDI=NULL due to earlier failure
    // also SetRenderTarget() is tough when m_pDDI is bad
    // some driver(like ATI Rage3) could not Reset view correctly
    // even after SetRenderTarget()
    // therefore always Destroy and do a Init, as a result, driver
    // will always get a DestroyContext and CreateContext clean
//    static_cast<CD3DBase*>(this)->Destroy();
    UpdateRenderTarget(m_pSwapChain->m_ppBackBuffers[0], m_pAutoZStencil);
    hr = static_cast<CD3DBase*>(this)->Init();
LoseDevice:
    if (FAILED(hr))
    {
        DPF_ERR("Reset failed and Reset/TestCooperativeLevel/Release "
            "are the only legal APIs to be called subsequently");
        if ((SwapChain()) && (!SwapChain()->m_PresentationData.Windowed))
        {
            // release the exclusive upon failure
            SwapChain()->m_PresentationData.Windowed = TRUE;
            SwapChain()->SetCooperativeLevel();
        }
        D3D8LoseDevice(GetHandle());
    }
    else
    {
        hr = CResource::RestoreDriverManagementState(this);
        if (FAILED(hr))
        {
            goto LoseDevice;
        }
        hr = static_cast<CD3DBase*>(this)->ResetShaders();
        if (FAILED(hr))
        {
            goto LoseDevice;
        }
    }
    m_fullscreen = !SwapChain()->m_PresentationData.Windowed;
    return hr;
} // Reset

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::SetGammaRamp"

STDMETHODIMP_(void)
CBaseDevice::SetGammaRamp(DWORD dwFlags, CONST D3DGAMMARAMP *pRamp)
{
    API_ENTER_VOID(this);

    if (NULL == pRamp)
    {
        DPF_ERR("Invalid D3DGAMMARAMP pointer. SetGammaRamp ignored.");
        return;
    }
    if (m_pSwapChain == NULL)
    {
        DPF_ERR("No Swap Chain present; SetGammaRamp fails");
        return;
    }

    m_pSwapChain->SetGammaRamp(dwFlags, pRamp);
} // SetGammaRamp

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetGammaRamp"

STDMETHODIMP_(void)
CBaseDevice::GetGammaRamp(D3DGAMMARAMP *pRamp)
{
    API_ENTER_VOID(this);

    if (NULL == pRamp)
    {
        DPF_ERR("Invalid D3DGAMMARAMP pointer. GetGammaRamp ignored");
        return;
    }
    if (m_pSwapChain == NULL)
    {
        DPF_ERR("No Swap Chain present; GetGammaRamp fails");
        return;
    }

    m_pSwapChain->GetGammaRamp(pRamp);
} // GetGammaRamp

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetBackBuffer"

HRESULT
CBaseDevice::GetBackBuffer(UINT                iBackBuffer,
                           D3DBACKBUFFER_TYPE  Type,
                           IDirect3DSurface8 **ppBackBuffer)
{
    API_ENTER(this);

    if (!VALID_PTR_PTR(ppBackBuffer))
    {
        DPF_ERR("Invalid IDirect3DSurface8* pointer to GetBackBuffer");
        return D3DERR_INVALIDCALL;
    }

    // Zero out return param
    *ppBackBuffer = NULL;

    if (m_pSwapChain == NULL)
    {
        DPF_ERR("No Swap Chain present; GetBackBuffer fails");
        return D3DERR_INVALIDCALL;
    }

    return m_pSwapChain->GetBackBuffer(iBackBuffer, Type, ppBackBuffer);
} // GetBackBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::Present"

STDMETHODIMP
CBaseDevice::Present(
    CONST RECT    *pSrcRect,
    CONST RECT    *pDestRect,
    HWND    hWndDestOverride,
    CONST RGNDATA *pDstRegion
   )
{
    API_ENTER(this);

    if (m_pSwapChain == NULL)
    {
        DPF_ERR("No Swap Chain present; Present fails");
        return D3DERR_INVALIDCALL;
    }
    return m_pSwapChain->Present(pSrcRect, pDestRect, hWndDestOverride, pDstRegion);
} // Present

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::TestCooperativeLevel"
STDMETHODIMP CBaseDevice::TestCooperativeLevel(void)
{
    API_ENTER(this);

    if (D3D8IsDeviceLost(GetHandle()))
    {
#ifdef WINNT
        if (m_pSwapChain)
        {
            BOOL bDeactivated = m_pSwapChain->IsWinProcDeactivated();
            if (bDeactivated)
                return D3DERR_DEVICELOST;
        }

        HWND EnumFocusWindow = Enum()->ExclusiveOwnerWindow();
        if (EnumFocusWindow &&
            EnumFocusWindow != FocusWindow())
        {
            DPF(0, "Another device in the same process has gone full-screen."
                   " If you wanted both to go full-screen at the same time,"
                   " you need to pass the same HWND for the Focus Window.");

            return D3DERR_DEVICELOST;
        }
        BOOL    bThisDeviceOwnsExclusive;
        BOOL    bExclusiveExists = Enum()->CheckExclusiveMode(this,
                &bThisDeviceOwnsExclusive, FALSE);
        if (bExclusiveExists && !bThisDeviceOwnsExclusive)
        {
            return D3DERR_DEVICELOST;
        }

#endif  //WINNT
        if (D3D8CanRestoreNow(GetHandle()))
        {
            return D3DERR_DEVICENOTRESET;
        }
        return D3DERR_DEVICELOST;
    }

    return S_OK;
} // TestCooperativeLevel

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetRasterStatus"
STDMETHODIMP CBaseDevice::GetRasterStatus(D3DRASTER_STATUS *pStatus)
{
    API_ENTER(this);

    if (!VALID_WRITEPTR(pStatus, sizeof(*pStatus)))
    {
        DPF_ERR("Invalid Raster Status parameter to GetRasterStatus");
        return D3DERR_INVALIDCALL;
    }

    if (!(GetD3DCaps()->Caps & D3DCAPS_READ_SCANLINE))
    {
        pStatus->ScanLine = 0;
        pStatus->InVBlank = FALSE;
        DPF_ERR("Current device doesn't support D3DCAPS_READ_SCANLINE functionality. GetRasterStatus fails.");
        return D3DERR_INVALIDCALL;
    }

    D3D8_GETSCANLINEDATA getScanLineData;
    getScanLineData.hDD = GetHandle();

    DWORD dwRet = GetHalCallbacks()->GetScanLine(&getScanLineData);
    if (dwRet == DDHAL_DRIVER_HANDLED)
    {
        if (getScanLineData.ddRVal == S_OK)
        {
            pStatus->InVBlank = getScanLineData.bInVerticalBlank;
            if (getScanLineData.bInVerticalBlank)
            {
                pStatus->ScanLine = 0;
            }
            else
            {
                pStatus->ScanLine = getScanLineData.dwScanLine;
            }
        }
        else
        {
            DPF_ERR("Device failed GetScanline. GetRasterStatus fails");
            pStatus->ScanLine = 0;
            pStatus->InVBlank = FALSE;
            return D3DERR_NOTAVAILABLE;
        }
    }
    else
    {
        DPF_ERR("Device failed GetScanline. GetRasterStatus fails.");
        pStatus->ScanLine = 0;
        pStatus->InVBlank = FALSE;
        return D3DERR_NOTAVAILABLE;
    }

    return S_OK;
} // GetRasterStatus

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetDirect3D"

STDMETHODIMP CBaseDevice::GetDirect3D(LPDIRECT3D8 *pD3D8)
{
    API_ENTER(this);

    if (pD3D8 == NULL)
    {
        DPF_ERR("Invalid pointer specified. GetDirect3D fails.");
        return D3DERR_INVALIDCALL;
    }

    DXGASSERT(m_pD3DClass);

    m_pD3DClass->AddRef();
    *pD3D8 = m_pD3DClass;

    return D3D_OK;
} // GetDirect3D

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetCreationParameters"

STDMETHODIMP CBaseDevice::GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters)
{
    API_ENTER(this);

    if (!VALID_WRITEPTR(pParameters, sizeof(D3DDEVICE_CREATION_PARAMETERS)))
    {
        DPF_ERR("bad pointer for pParameters passed to GetCreationParameters");
        return D3DERR_INVALIDCALL;
    }

    pParameters->AdapterOrdinal = m_AdapterIndex;
    pParameters->DeviceType     = m_DeviceType;
    pParameters->BehaviorFlags  = m_dwOriginalBehaviorFlags;
    pParameters->hFocusWindow   = m_hwndFocusWindow;

    return S_OK;
} // GetCreationParameters


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetDisplayMode"

STDMETHODIMP CBaseDevice::GetDisplayMode(D3DDISPLAYMODE *pMode)
{
    API_ENTER(this);

    if (!VALID_WRITEPTR(pMode, sizeof(*pMode)))
    {
        DPF_ERR("Invalid pointer specified to GetDisplayMode");
        return D3DERR_INVALIDCALL;
    }

    pMode->Width = DisplayWidth();
    pMode->Height = DisplayHeight();
    pMode->Format = DisplayFormat();
    pMode->RefreshRate = DisplayRate();

    return D3D_OK;
} // GetDisplayMode

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetAvailableTextureMem"

STDMETHODIMP_(UINT) CBaseDevice::GetAvailableTextureMem(void)
{
    API_ENTER_RET(this, UINT);


    D3D8_GETAVAILDRIVERMEMORYDATA GetAvailDriverMemory;

    GetAvailDriverMemory.hDD = GetHandle();
    GetAvailDriverMemory.Pool = D3DPOOL_DEFAULT;
    GetAvailDriverMemory.dwUsage = D3DUSAGE_TEXTURE;
    GetAvailDriverMemory.dwFree = 0;

    GetHalCallbacks()->GetAvailDriverMemory(&GetAvailDriverMemory);

    #define ONE_MEG_O_VRAM  0x100000

    //Round to nearest meg:
    return (GetAvailDriverMemory.dwFree + ONE_MEG_O_VRAM/2) & (~(ONE_MEG_O_VRAM-1));
} // GetAvailableTextureMem

#undef DPF_MODNAME
#define DPF_MODNAME "CanHardwareBlt"

BOOL CanHardwareBlt (const D3D8_DRIVERCAPS* pDriverCaps,
                           D3DPOOL SrcPool,
                           D3DFORMAT SrcFormat,
                           D3DPOOL DstPool,
                           D3DFORMAT DstFormat,
                           D3DDEVTYPE DeviceType)
{
    // Pools are supposed to be real pools as opposed to
    // what the app specified
    DXGASSERT(SrcPool != D3DPOOL_DEFAULT);
    DXGASSERT(DstPool != D3DPOOL_DEFAULT);
    DXGASSERT(VALID_INTERNAL_POOL(SrcPool));
    DXGASSERT(VALID_INTERNAL_POOL(DstPool));

    //Driver should never be allowed to see scratch:
    if (SrcPool == D3DPOOL_SCRATCH ||
        DstPool == D3DPOOL_SCRATCH)
    {
        return FALSE;
    }

    // For this case, we want to just lock and memcpy.  Why?
    // It's a software driver, so it's going to be a memcpy anyway,
    // and we special case blt since we want to use a real hardware
    // blt for Present even when running a software driver.  So either
    // we lock and memcpy, or we have to keep track of two different
    // Blt entry points (one for the real driver and one for the software
    // driver) just so the software driver can do the memcpy itself.

    if (DeviceType != D3DDEVTYPE_HAL)
    {
        return FALSE;
    }

    // Check that source and dest formats match
    DXGASSERT(SrcFormat == DstFormat);

    // FourCC may not be copy-able
    if (CPixel::IsFourCC(SrcFormat))
    {
        if (!(pDriverCaps->D3DCaps.Caps2 & DDCAPS2_COPYFOURCC))
        {
            return FALSE;
        }
    }

    // We can't do HW blts if either source or
    // dest is in system memory and the driver
    // needs PageLocks
    if (SrcPool == D3DPOOL_SYSTEMMEM ||
        DstPool == D3DPOOL_SYSTEMMEM)
    {
        if (!(pDriverCaps->D3DCaps.Caps2 & DDCAPS2_NOPAGELOCKREQUIRED))
        {
            return FALSE;
        }

        // Now this is tricky; but in DX7 we checked this cap when
        // deciding whether to do BLTs involving system-memory but not
        // when we decided whether to do real Blts. We need to check this.
        if (!(pDriverCaps->D3DCaps.Caps & DDCAPS_CANBLTSYSMEM))
        {
            return FALSE;
        }
    }

    // Check AGP caps first
    if (pDriverCaps->D3DCaps.Caps2 & DDCAPS2_NONLOCALVIDMEMCAPS)
    {
        if (SrcPool == D3DPOOL_SYSTEMMEM)
        {
            if ((DstPool == D3DPOOL_NONLOCALVIDMEM) &&
                (pDriverCaps->D3DCaps.Caps2 & DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL) &&
                (pDriverCaps->SVBCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
            else if (((DstPool == D3DPOOL_LOCALVIDMEM) ||
                      (DstPool == D3DPOOL_MANAGED)) &&
                      (pDriverCaps->SVBCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
        else if (SrcPool == D3DPOOL_NONLOCALVIDMEM)
        {
            if (((DstPool == D3DPOOL_LOCALVIDMEM) ||
                 (DstPool == D3DPOOL_MANAGED)) &&
                 (pDriverCaps->NLVCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
        else if ((SrcPool == D3DPOOL_LOCALVIDMEM) ||
                 (SrcPool == D3DPOOL_MANAGED))
        {
            if (((DstPool == D3DPOOL_LOCALVIDMEM) ||
                 (DstPool == D3DPOOL_MANAGED)) &&
                 (pDriverCaps->D3DCaps.Caps & DDCAPS_BLT))
            {
                return TRUE;
            }
            else if ((DstPool == D3DPOOL_SYSTEMMEM) &&
                     (pDriverCaps->VSBCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
    }
    else
    {
        if (SrcPool == D3DPOOL_SYSTEMMEM)
        {
            if (((DstPool == D3DPOOL_LOCALVIDMEM) ||
                 (DstPool == D3DPOOL_MANAGED)) &&
                 (pDriverCaps->SVBCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
        else if ((SrcPool == D3DPOOL_LOCALVIDMEM) ||
                 (SrcPool == D3DPOOL_MANAGED))
        {
            if (((DstPool == D3DPOOL_LOCALVIDMEM) ||
                 (DstPool == D3DPOOL_MANAGED)) &&
                 (pDriverCaps->D3DCaps.Caps & DDCAPS_BLT))
            {
                return TRUE;
            }
            else if ((DstPool == D3DPOOL_SYSTEMMEM) &&
                     (pDriverCaps->VSBCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
} // CanHardwareBlt

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CopyRects"

STDMETHODIMP CBaseDevice::CopyRects(IDirect3DSurface8 *pSrcSurface,
                                    CONST RECT        *pSrcRectsArray,
                                    UINT               cRects,
                                    IDirect3DSurface8 *pDstSurface,
                                    CONST POINT       *pDstPointsArray)
{
    API_ENTER(this);

    D3DSURFACE_DESC     SrcDesc;
    D3DSURFACE_DESC     DstDesc;
    HRESULT             hr;
    UINT                i;

    // Do some basic paramater checking
    if (!VALID_PTR(pSrcSurface, sizeof(void*)) ||
        !VALID_PTR(pDstSurface, sizeof(void*)))
    {
        DPF_ERR("NULL surface interface specified. CopyRect fails");
        return D3DERR_INVALIDCALL;
    }

    CBaseSurface *pSrc = static_cast<CBaseSurface*>(pSrcSurface);
    if (pSrc->InternalGetDevice() != this)
    {
        DPF_ERR("SrcSurface was not allocated with this Device. CopyRect fails.");
        return D3DERR_INVALIDCALL;
    }

    CBaseSurface *pDst = static_cast<CBaseSurface*>(pDstSurface);
    if (pDst->InternalGetDevice() != this)
    {
        DPF_ERR("DstSurface was not allocated with this Device. CopyRect fails.");
        return D3DERR_INVALIDCALL;
    }

    hr = pSrc->GetDesc(&SrcDesc);
    DXGASSERT(SUCCEEDED(hr));
    hr = pDst->GetDesc(&DstDesc);
    DXGASSERT(SUCCEEDED(hr));

    // Source can not be a load-once surface
    if (SrcDesc.Usage & D3DUSAGE_LOADONCE)
    {
        DPF_ERR("CopyRects can not be used from a Load_Once surface");
        return D3DERR_INVALIDCALL;
    }

    // Destination can not be a load-once surface
    // if it isn't currently lockable.
    if (DstDesc.Usage & D3DUSAGE_LOADONCE)
    {
        if (pDst->IsLoaded())
        {
            DPF_ERR("Destination for CopyRects a Load_Once surface that has"
                    " already been loaded. CopyRects failed.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Source can not be already locked
    if (pSrc->IsLocked())
    {
        DPF_ERR("Source for CopyRects is already Locked. CopyRect failed.");
        return D3DERR_INVALIDCALL;
    }
    if (pDst->IsLocked())
    {
        DPF_ERR("Destination for CopyRects is already Locked. CopyRect failed.");
        return D3DERR_INVALIDCALL;
    }

    if (SrcDesc.Format != DstDesc.Format)
    {
        DPF_ERR("Source and dest surfaces are different formats. CopyRects fails");
        return D3DERR_INVALIDCALL;
    }

    if (CPixel::IsEnumeratableZ(SrcDesc.Format) &&
        !CPixel::IsIHVFormat(SrcDesc.Format))
    {
        DPF_ERR("CopyRects is not supported for Z formats.");
        return D3DERR_INVALIDCALL;
    }

    // Make sure that the rects are entirely within the surface
    if ((cRects > 0) && (pSrcRectsArray == NULL))
    {
        DPF_ERR("Number of rects > 0, but rect array is NULL. CopyRects fails.");
        return D3DERR_INVALIDCALL;
    }

    D3DFORMAT InternalFormat = pSrc->InternalGetDesc().Format;
    BOOL bDXT = CPixel::IsDXT(InternalFormat);

    for (i = 0; i < cRects; i++)
    {
        if (!CPixel::IsValidRect(InternalFormat,
                                 SrcDesc.Width,
                                 SrcDesc.Height,
                                &pSrcRectsArray[i]))
        {
            DPF_ERR("CopyRects failed");
            return D3DERR_INVALIDCALL;
        }

        // Validate the point parameter;
        // if it is NULL, then it means that we're
        // to use the left/top that was in the corresponding rect.
        CONST POINT *pPoint;
        if (pDstPointsArray != NULL)
        {
            pPoint = &pDstPointsArray[i];
        }
        else
        {
            pPoint = (CONST POINT *)&pSrcRectsArray[i];
        }

        if (bDXT)
        {
            if ((pPoint->x & 3) ||
                (pPoint->y & 3))
            {
                DPF_ERR("Destination points array coordinates must each be 4 pixel aligned for DXT surfaces. CopyRects fails");
                return D3DERR_INVALIDCALL;
            }
        }

        // Check that the dest rect (where left/top is the x/y of the point
        // and the right/bottom is x+width, y+height) fits inside
        // the DstDesc.
        if (((pPoint->x +
             (pSrcRectsArray[i].right - pSrcRectsArray[i].left)) > (int)DstDesc.Width) ||
            ((pPoint->y +
             (pSrcRectsArray[i].bottom - pSrcRectsArray[i].top)) > (int)DstDesc.Height) ||
            (pPoint->x < 0) ||
            (pPoint->y < 0))
        {
            DPF_ERR("Destination rect is outside of the surface. CopyRects fails.");
            return D3DERR_INVALIDCALL;
        }
    }

    return InternalCopyRects(pSrc,
                             pSrcRectsArray,
                             cRects,
                             pDst,
                             pDstPointsArray);
} // CopyRects


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::InternalCopyRects"

HRESULT CBaseDevice::InternalCopyRects(CBaseSurface *pSrcSurface,
                                       CONST RECT   *pSrcRectsArray,
                                       UINT          cRects,
                                       CBaseSurface *pDstSurface,
                                       CONST POINT  *pDstPointsArray)
{
    D3DSURFACE_DESC     SrcDesc = pSrcSurface->InternalGetDesc();
    D3DSURFACE_DESC     DstDesc = pDstSurface->InternalGetDesc();

    HRESULT             hr;

    RECT                Rect;
    POINT               Point;
    CONST RECT*         pRect;
    CONST POINT*        pPoint;
    int                 BPP;
    UINT                i;

    // If either one of these surfaces is a deep mipmap level that the
    // driver can't handle, then we didn't really create it so we don't
    // want to try to copy it.

    if (D3D8IsDummySurface(pDstSurface->KernelHandle()) ||
        D3D8IsDummySurface(pSrcSurface->KernelHandle()))
    {
        return D3D_OK;
    }

    if (pSrcRectsArray == NULL)
    {
        cRects = 1;
        pSrcRectsArray = &Rect;
        Rect.left = Rect.top = 0;
        Rect.right = SrcDesc.Width;
        Rect.bottom = SrcDesc.Height;

        pDstPointsArray = &Point;
        Point.x = Point.y = 0;
    }

    // Now figure out what is the best way to copy the data.

    if (CanHardwareBlt(GetCoreCaps(),
                       SrcDesc.Pool,
                       SrcDesc.Format,
                       DstDesc.Pool,
                       DstDesc.Format,
                       GetDeviceType()))
    {
        // If we are setting up a blt outside of the
        // the DP2 stream; then we must call Sync on the
        // source and destination surfaces to make sure
        // that any pending TexBlt to or from the surfaces
        // or any pending triangles using these textures
        // has been sent down to the driver
        pSrcSurface->Sync();
        pDstSurface->Sync();

        if (DstDesc.Pool == D3DPOOL_SYSTEMMEM)
        {
            // If the destination is system-memory,
            // then we need to mark it dirty. Easiest way
            // is lock/unlock
            D3DLOCKED_RECT LockTemp;
            hr = pDstSurface->InternalLockRect(&LockTemp, NULL, 0);
            if (FAILED(hr))
            {
                DPF_ERR("Could not lock sys-mem destination for CopyRects?");
            }
            else
            {
                hr = pDstSurface->InternalUnlockRect();
                DXGASSERT(SUCCEEDED(hr));
            }
        }


        D3D8_BLTDATA    BltData;
        ZeroMemory(&BltData, sizeof BltData);
        BltData.hDD = GetHandle();
        BltData.hDestSurface = pDstSurface->KernelHandle();
        BltData.hSrcSurface = pSrcSurface->KernelHandle();
        BltData.dwFlags = DDBLT_ROP | DDBLT_WAIT;

        for (i = 0; i < cRects; i++)
        {
            if (pDstPointsArray == NULL)
            {
                BltData.rDest.left = pSrcRectsArray[i].left;
                BltData.rDest.top = pSrcRectsArray[i].top;
            }
            else
            {
                BltData.rDest.left = pDstPointsArray[i].x;
                BltData.rDest.top = pDstPointsArray[i].y;
            }
            BltData.rDest.right = BltData.rDest.left +
                pSrcRectsArray[i].right -
                pSrcRectsArray[i].left;
            BltData.rDest.bottom = BltData.rDest.top +
                pSrcRectsArray[i].bottom -
                pSrcRectsArray[i].top;
            BltData.rSrc.left   = pSrcRectsArray[i].left;
            BltData.rSrc.right  = pSrcRectsArray[i].right;
            BltData.rSrc.top    = pSrcRectsArray[i].top;
            BltData.rSrc.bottom = pSrcRectsArray[i].bottom;

            GetHalCallbacks()->Blt(&BltData);
            if (FAILED(BltData.ddRVal))
            {
                // We should mask errors if we are lost
                // and the copy is to vidmem. Also, if
                // the copy is persistent-to-persistent,
                // then fail-over to our lock&copy code
                // later in this function.

                if (BltData.ddRVal == D3DERR_DEVICELOST)
                {
                    if (DstDesc.Pool == D3DPOOL_MANAGED ||
                        DstDesc.Pool == D3DPOOL_SYSTEMMEM)
                    {
                        if (SrcDesc.Pool == D3DPOOL_MANAGED ||
                            SrcDesc.Pool == D3DPOOL_SYSTEMMEM)
                        {
                            // if we got here
                            // then it must be persistent to persistent
                            // so we break out of our loop
                            break;
                        }

                        DPF_ERR("Failing copy from video-memory surface to "
                                "system-memory or managed surface because "
                                "device is lost. CopyRect returns D3DERR_DEVICELOST");
                        return D3DERR_DEVICELOST;
                    }
                    else
                    {
                        // copying to vid-mem when we are lost
                        // can just be ignored; since the lock
                        // is faked anyhow
                        return S_OK;
                    }
                }
            }
        }

        // We can handle persistent-to-persistent even
        // in case of loss. Other errors are fatal.
        if (BltData.ddRVal != D3DERR_DEVICELOST)
        {
            if (FAILED(BltData.ddRVal))
            {
                DPF_ERR("Hardware Blt failed. CopyRects failed");
            }
            return BltData.ddRVal;
        }
    }

    // We are here either because the device doesn't support Blt, or because
    // the hardware blt failed due to device lost and we think that we can
    // emulate it.

    D3DLOCKED_RECT SrcLock;
    D3DLOCKED_RECT DstLock;
    BOOL           bDXT = FALSE;

    // We need to lock both surfaces and basically do a memcpy

    BPP = CPixel::ComputePixelStride(SrcDesc.Format);

    if (CPixel::IsDXT(BPP))
    {
        bDXT = TRUE;
        BPP *= -1;
    }

    if (BPP == 0)
    {
        DPF_ERR("Format not understood - cannot perform the copy. CopyRects fails.");
        return D3DERR_INVALIDCALL;
    }

    // CONSIDER: We should be passing D3DLOCK_NO_DIRTY_RECT
    // and then call AddDirtyRect if this is part of a
    // texture; probably need to add some method to CBaseSurface
    // for this purpose

    hr = pSrcSurface->InternalLockRect(&SrcLock, NULL, D3DLOCK_READONLY | D3DLOCK_NOSYSLOCK);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pDstSurface->InternalLockRect(&DstLock, NULL, D3DLOCK_NOSYSLOCK);
    if (FAILED(hr))
    {
        pSrcSurface->InternalUnlockRect();
        return hr;
    }

    // We check for DeviceLost here when copying from vidmem to sysmem since
    // device lost can happen asynchronously.

    if (((DstDesc.Pool == D3DPOOL_MANAGED) ||
         (DstDesc.Pool == D3DPOOL_SYSTEMMEM)) &&
        ((SrcDesc.Pool != D3DPOOL_MANAGED) &&
         (SrcDesc.Pool != D3DPOOL_SYSTEMMEM)))
    {
        if (D3D8IsDeviceLost(GetHandle()))
        {
            pSrcSurface->InternalUnlockRect();
            pDstSurface->InternalUnlockRect();
            return D3DERR_DEVICELOST;
        }
    }

    pRect = pSrcRectsArray;
    pPoint = pDstPointsArray;
    for (i = 0; i < cRects; i++)
    {
        BYTE*   pSrc;
        BYTE*   pDst;
        DWORD   BytesToCopy;
        DWORD   NumRows;

        // If did not specify a dest point, then we
        // will use the src (left, top) as the dest point.

        if (pDstPointsArray == NULL)
        {
            pPoint = (POINT*) pRect;
        }

        // Handle DXT case inside the loop
        // so that we don't have to touch the user's array
        if (bDXT)
        {
            // Figure out our pointers by converting rect/point
            // offsets to blocks
            pSrc  = (BYTE*)SrcLock.pBits;
            pSrc += (pRect->top  / 4) * SrcLock.Pitch;
            pSrc += (pRect->left / 4) * BPP;

            pDst  = (BYTE*)DstLock.pBits;
            pDst += (pPoint->y   / 4) * DstLock.Pitch;
            pDst += (pPoint->x   / 4) * BPP;

            // Convert top/bottom to blocks
            DWORD top    = (pRect->top) / 4;

            // Handle nasty 1xN, 2xN, Nx1, Nx2 DXT cases
            // by rounding.
            DWORD bottom = (pRect->bottom + 3) / 4;

            // For DXT formats, we know that pitch equals
            // width; so we only need to check if we
            // are copying an entire row to an entire
            // row to go the fast path.
            if ((pRect->left == 0) &&
                (pRect->right == (INT)SrcDesc.Width) &&
                (SrcLock.Pitch == DstLock.Pitch))
            {
                BytesToCopy = SrcLock.Pitch * (bottom - top);
                NumRows     = 1;
            }
            else
            {
                // Convert left/right to blocks
                DWORD left  = (pRect->left  / 4);

                // Round for the right -> block conversion
                DWORD right = (pRect->right + 3) / 4;

                BytesToCopy = (right - left) * BPP;
                NumRows     = bottom - top;
            }
        }
        else
        {
            pSrc = (BYTE*)SrcLock.pBits +
                        (pRect->top * SrcLock.Pitch) +
                        (pRect->left * BPP);
            pDst = (BYTE*)DstLock.pBits +
                        (pPoint->y * DstLock.Pitch) +
                        (pPoint->x * BPP);

            // If the src and dest are linear, we can do it all in a single
            // memcpy
            if ((pRect->left == 0) &&
                ((pRect->right * BPP) == SrcLock.Pitch) &&
                (SrcDesc.Width == DstDesc.Width) &&
                (SrcLock.Pitch == DstLock.Pitch))
            {
                BytesToCopy = SrcLock.Pitch * (pRect->bottom - pRect->top);
                NumRows     = 1;
            }
            else
            {
                BytesToCopy = (pRect->right - pRect->left) * BPP;
                NumRows     = pRect->bottom - pRect->top;
            }
        }

        // Copy the rows
        DXGASSERT(NumRows > 0);
        DXGASSERT(BytesToCopy > 0);
        DXGASSERT(SrcLock.Pitch > 0);
        DXGASSERT(DstLock.Pitch > 0);
        for (UINT j = 0; j < NumRows; j++)
        {
            memcpy(pDst,
                   pSrc,
                   BytesToCopy);
            pSrc += SrcLock.Pitch;
            pDst += DstLock.Pitch;
        }

        // Move onward to the next rect/point pair
        pRect++;
        pPoint++;
    }

    // We check for DeviceLost yet again since it coulkd have occurred while 
    // copying the data.

    hr = D3D_OK;
    if (((DstDesc.Pool == D3DPOOL_MANAGED) ||
         (DstDesc.Pool == D3DPOOL_SYSTEMMEM)) &&
        ((SrcDesc.Pool != D3DPOOL_MANAGED) &&
         (SrcDesc.Pool != D3DPOOL_SYSTEMMEM)))
    {
        if (D3D8IsDeviceLost(GetHandle()))
        {
            hr = D3DERR_DEVICELOST;
        }
    }

    pSrcSurface->InternalUnlockRect();
    pDstSurface->InternalUnlockRect();

    return hr;
} // InternalCopyRects

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::UpdateTexture"

STDMETHODIMP CBaseDevice::UpdateTexture(IDirect3DBaseTexture8 *pSrcTexture,
                                        IDirect3DBaseTexture8 *pDstTexture)
{
    API_ENTER(this);

    HRESULT hr;


#ifdef DEBUG
    // Some parameter validation is in Debug only for performance reasons

    if (pSrcTexture == NULL || pDstTexture == NULL)
    {
        DPF_ERR("Invalid parameter to UpdateTexture");
        return D3DERR_INVALIDCALL;
    }

#endif // DEBUG

    CBaseTexture *pSrcTex = CBaseTexture::SafeCast(pSrcTexture);
    if (pSrcTex->Device() != this)
    {
        DPF_ERR("SrcTexture was not created with this Device. UpdateTexture fails");
        return D3DERR_INVALIDCALL;
    }

    CBaseTexture *pDstTex = CBaseTexture::SafeCast(pDstTexture);
    if (pDstTex->Device() != this)
    {
        DPF_ERR("DstTexture  was not created with this Device. UpdateTexture fails");
        return D3DERR_INVALIDCALL;
    }

#ifdef DEBUG
    // Ensure matching formats
    if (pSrcTex->GetUserFormat() != pDstTex->GetUserFormat())
    {
        DPF_ERR("Formats of source and dest don't match. UpdateTexture fails");
        return D3DERR_INVALIDCALL;
    }

    // Ensure matching types
    if (pSrcTex->GetBufferDesc()->Type !=
        pDstTex->GetBufferDesc()->Type)
    {
        DPF_ERR("Types of source and dest don't match. UpdateTexture fails");
        return D3DERR_INVALIDCALL;
    }

    // Check that Source has at least as many levels as dest
    if (pSrcTex->GetLevelCount() < pDstTex->GetLevelCount())
    {
        DPF_ERR("Source for UpdateTexture must have at least as many levels"
                " as the Destination.");
        return D3DERR_INVALIDCALL;
    }

    // Check that the source texture is not already locked
    if (pSrcTex->IsTextureLocked())
    {
        DPF_ERR("Source for UpdateTexture is currently locked. Unlock must be called "
                "before calling UpdateTexture.");
        return D3DERR_INVALIDCALL;
    }

    // Check that the dest texture is not already locked
    if (pDstTex->IsTextureLocked())
    {
        DPF_ERR("Destination for UpdateTexture is currently locked. Unlock must be called "
                "before calling UpdateTexture.");
        return D3DERR_INVALIDCALL;
    }

#endif // DEBUG

    // Ensure that src was specified in Pool systemmem
    if (pSrcTex->GetUserPool() != D3DPOOL_SYSTEMMEM)
    {
        DPF_ERR("Source Texture for UpdateTexture must be in POOL_SYSTEMMEM.");
        return D3DERR_INVALIDCALL;
    }
    // Ensure that destination was specified in Pool default
    if (pDstTex->GetUserPool() != D3DPOOL_DEFAULT)
    {
        DPF_ERR("Destination Texture for UpdateTexture must be in POOL_DEFAULT.");
        return D3DERR_INVALIDCALL;
    }

#ifdef DEBUG
    // Call UpdateTexture on the source which will use the
    // dirty rects to move just what is needed. This
    // function will also do type-specific parameter checking.
    hr = pSrcTex->UpdateTexture(pDstTex);
#else // !DEBUG
    // In Retail we want to call UpdateDirtyPortion directly;
    // which will bypass the parameter checking
    hr = pSrcTex->UpdateDirtyPortion(pDstTex);
#endif // !DEBUG

    if (FAILED(hr))
    {
        DPF_ERR("UpdateTexture failed to copy");
        return hr;
    }

    return hr;
} // UpdateTexture


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateTexture"

STDMETHODIMP CBaseDevice::CreateTexture(UINT                 Width,
                                        UINT                 Height,
                                        UINT                 cLevels,
                                        DWORD                dwUsage,
                                        D3DFORMAT            Format,
                                        D3DPOOL              Pool,
                                        IDirect3DTexture8  **ppTexture)
{
    API_ENTER(this);

    if (Format == D3DFMT_UNKNOWN)
    {
        DPF_ERR("D3DFMT_UNKNOWN is not a valid format. CreateTexture fails.");
        return D3DERR_INVALIDCALL;
    }

    HRESULT hr = CMipMap::Create(this,
                                 Width,
                                 Height,
                                 cLevels,
                                 dwUsage,
                                 Format,
                                 Pool,
                                 ppTexture);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create a texture");
        return hr;
    }

    return hr;
} // CreateTexture

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateVolumeTexture"

STDMETHODIMP CBaseDevice::CreateVolumeTexture(
    UINT                        Width,
    UINT                        Height,
    UINT                        cpDepth,
    UINT                        cLevels,
    DWORD                       dwUsage,
    D3DFORMAT                   Format,
    D3DPOOL                     Pool,
    IDirect3DVolumeTexture8   **ppVolumeTexture)
{
    API_ENTER(this);

    if (Format == D3DFMT_UNKNOWN)
    {
        DPF_ERR("D3DFMT_UNKNOWN is not a valid format. CreateVolumeTexture fails.");
        return D3DERR_INVALIDCALL;
    }

    HRESULT hr = CMipVolume::Create(this,
                                    Width,
                                    Height,
                                    cpDepth,
                                    cLevels,
                                    dwUsage,
                                    Format,
                                    Pool,
                                    ppVolumeTexture);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create a volume texture");
        return hr;
    }

    return hr;
} // CreateVolumeTexture


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateCubeTexture"

STDMETHODIMP CBaseDevice::CreateCubeTexture(UINT                    cpEdge,
                                            UINT                    cLevels,
                                            DWORD                   dwUsage,
                                            D3DFORMAT               Format,
                                            D3DPOOL                 Pool,
                                            IDirect3DCubeTexture8 **ppCubeMap)
{
    API_ENTER(this);

    if (Format == D3DFMT_UNKNOWN)
    {
        DPF_ERR("D3DFMT_UNKNOWN is not a valid format. CreateCubeTexture fails.");
        return D3DERR_INVALIDCALL;
    }

    HRESULT hr = CCubeMap::Create(this,
                                  cpEdge,
                                  cLevels,
                                  dwUsage,
                                  Format,
                                  Pool,
                                  ppCubeMap);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create cubemap");
        return hr;
    }

    return hr;

} // CreateCubeTexture

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateRenderTarget"

STDMETHODIMP CBaseDevice::CreateRenderTarget(UINT                 Width,
                                             UINT                 Height,
                                             D3DFORMAT            Format,
                                             D3DMULTISAMPLE_TYPE  MultiSample,
                                             BOOL                 bLockable,
                                             IDirect3DSurface8  **ppSurface)
{
    API_ENTER(this);

    if (Format == D3DFMT_UNKNOWN)
    {
        DPF_ERR("D3DFMT_UNKNOWN is not a valid format. CreateRenderTarget fails.");
        return D3DERR_INVALIDCALL;
    }

    HRESULT hr = CSurface::CreateRenderTarget(this,
                                              Width,
                                              Height,
                                              Format,
                                              MultiSample,
                                              bLockable,
                                              REF_EXTERNAL,
                                              ppSurface);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create render-target");
        return hr;
    }
    return hr;
} // CreateRenderTarget

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateDepthStencilSurface"

STDMETHODIMP CBaseDevice::CreateDepthStencilSurface
    (UINT                 Width,
     UINT                 Height,
     D3DFORMAT            Format,
     D3DMULTISAMPLE_TYPE  MultiSample,
     IDirect3DSurface8  **ppSurface)
{
    API_ENTER(this);

    if (Format == D3DFMT_UNKNOWN)
    {
        DPF_ERR("D3DFMT_UNKNOWN is not a valid format. CreateDepthStencilSurface fails.");
        return D3DERR_INVALIDCALL;
    }

    HRESULT hr = CSurface::CreateZStencil(this,
                                          Width,
                                          Height,
                                          Format,
                                          MultiSample,
                                          REF_EXTERNAL,
                                          ppSurface);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create zstencil surface");
        return hr;
    }
    return hr;
} // CreateDepthStencilSurface


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateImageSurface"

STDMETHODIMP CBaseDevice::CreateImageSurface(UINT                 Width,
                                             UINT                 Height,
                                             D3DFORMAT            Format,
                                             IDirect3DSurface8  **ppSurface)
{
    API_ENTER(this);

    HRESULT hr = CSurface::CreateImageSurface(this,
                                              Width,
                                              Height,
                                              Format,
                                              REF_EXTERNAL,
                                              ppSurface);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create image surface");
        return hr;
    }
    return hr;
} // CreateImageSurface


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateVertexBuffer"

STDMETHODIMP CBaseDevice::CreateVertexBuffer(UINT                     cbLength,
                                             DWORD                    dwUsage,
                                             DWORD                    dwFVF,
                                             D3DPOOL                  Pool,
                                             IDirect3DVertexBuffer8 **ppVertexBuffer)
{
    API_ENTER(this);

    if ((dwUsage & ~D3DUSAGE_VB_VALID) != 0)
    {
        DPF_ERR("Invalid usage flags. CreateVertexBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    // Warn if POOL_DEFAULT and not WRITEONLY. We do this here, because fe creates
    // a VB with WRITEONLY not set and we don't want to warn in that case.
    if (Pool == D3DPOOL_DEFAULT && (dwUsage & D3DUSAGE_WRITEONLY) == 0)
    {
        DPF(1, "Vertexbuffer created with POOL_DEFAULT but WRITEONLY not set. Performance penalty could be severe.");
    }

    HRESULT hr = CVertexBuffer::Create(this,
                                       cbLength,
                                       dwUsage,
                                       dwFVF,
                                       Pool,
                                       REF_EXTERNAL,
                                       ppVertexBuffer);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create Vertex Buffer");
        return hr;
    }
    return hr;

} // CBaseDevice::CreateVertexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateIndexBuffer"

STDMETHODIMP CBaseDevice::CreateIndexBuffer(UINT                    cbLength,
                                            DWORD                   dwUsage,
                                            D3DFORMAT               Format,
                                            D3DPOOL                 Pool,
                                            IDirect3DIndexBuffer8 **ppIndexBuffer)
{
    API_ENTER(this);

    if ((dwUsage & ~D3DUSAGE_IB_VALID) != 0)
    {
        DPF_ERR("Invalid usage flags. CreateIndexBuffer fails");
        return D3DERR_INVALIDCALL;
    }

    // Warn if POOL_DEFAULT and not WRITEONLY. We do this here, because fe creates
    // a IB with WRITEONLY not set and we don't want to warn in that case.
    if (Pool == D3DPOOL_DEFAULT && (dwUsage & D3DUSAGE_WRITEONLY) == 0)
    {
        DPF(1, "Indexbuffer created with POOL_DEFAULT but WRITEONLY not set. Performance penalty could be severe.");
    }

    HRESULT hr = CIndexBuffer::Create(this,
                                      cbLength,
                                      dwUsage,
                                      Format,
                                      Pool,
                                      REF_EXTERNAL,
                                      ppIndexBuffer);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create indexbuffer");
        return hr;
    }
    return hr;
} // CBaseDevice::CreateIndexBuffer


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::UpdateRenderTarget"

void CBaseDevice::UpdateRenderTarget(CBaseSurface *pRenderTarget,
                                     CBaseSurface *pZStencil)
{
    // We only change things if the old and new are different;
    // this is to allow the device to update itself to the
    // same object without needing an extra-ref-count

    // Has the RenderTarget changed?
    if (pRenderTarget != m_pRenderTarget)
    {
        // Release old RT
        if (m_pRenderTarget)
            m_pRenderTarget->DecrementUseCount();

        m_pRenderTarget = pRenderTarget;

        if (m_pRenderTarget)
        {
            // IncrementUseCount the new RT
            m_pRenderTarget->IncrementUseCount();

            // Update the batch count for the new rendertarget
            m_pRenderTarget->Batch();
        }
    }


    // Has the Z changed?
    if (m_pZBuffer != pZStencil)
    {
        // Release the old Z
        if (m_pZBuffer)
            m_pZBuffer->DecrementUseCount();

        m_pZBuffer = pZStencil;

        // IncrementUseCount the new Z
        if (m_pZBuffer)
        {
            m_pZBuffer->IncrementUseCount();

            // Update the batch count for the new zbuffer
            m_pZBuffer->Batch();
        }
    }

    return;
} // UpdateRenderTarget

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CBaseDevice"

CBaseDevice::CBaseDevice()
{
    // Give our base class a pointer to ourselves
    SetOwner(this);

    m_hwndFocusWindow           = 0;
    m_cRef                      = 1;

    m_pResourceList             = 0;
    m_pResourceManager          = new CResourceManager();
    m_dwBehaviorFlags           = 0;
    m_dwOriginalBehaviorFlags   = 0;

    m_fullscreen                = FALSE;
    m_bVBFailOversDisabled      = FALSE;

    m_pZBuffer                  = NULL;
    m_pSwapChain                = NULL;
    m_pRenderTarget             = NULL;
    m_pAutoZStencil             = NULL;
    m_ddiType                   = D3DDDITYPE_NULL;

} // CBaseDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::~CBaseDevice"

CBaseDevice::~CBaseDevice()
{
    DWORD cUseCount;

    // Release our objects
    if (m_pAutoZStencil)
    {
        cUseCount = m_pAutoZStencil->DecrementUseCount();
        DXGASSERT(cUseCount == 0 || m_pAutoZStencil == m_pZBuffer);
    }

    // Mark Z buffer as no longer in use
    if (m_pZBuffer)
    {
        cUseCount = m_pZBuffer->DecrementUseCount();
        DXGASSERT(cUseCount == 0);
        m_pZBuffer = NULL;
    }

    // Mark render target as no longer in use
    if (m_pRenderTarget)
    {
        cUseCount = m_pRenderTarget->DecrementUseCount();
        m_pRenderTarget = NULL; //so that FlipToGDISurface won't have to reset it
    }

    if (m_pSwapChain)
    {
        if  (m_fullscreen)
            m_pSwapChain->FlipToGDISurface();
        cUseCount = m_pSwapChain->DecrementUseCount();
        DXGASSERT(cUseCount == 0);
    }

    DD_DoneDC(m_DeviceData.hDC);

    //  Free allocations we made when the device was created

    if (m_DeviceData.DriverData.pGDD8SupportedFormatOps != NULL)
    {
        MemFree(m_DeviceData.DriverData.pGDD8SupportedFormatOps);
    }

    // If a software driver is loaded, unload it now

    if (m_DeviceData.hLibrary != NULL)
    {
        FreeLibrary(m_DeviceData.hLibrary);
    }

    // Shut down the thunk layer

    D3D8DeleteDirectDrawObject(m_DeviceData.hDD);

    delete m_pResourceManager;


    // We release the Enum last because various destructors expect to
    // be around i.e. the swapchain stuff. Also, because it is a
    // stand-alone object; it should not have any dependencies on the
    // the device.
    if (NULL != Enum())
    {
        Enum()->Release();
    }

} // ~CBaseDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::Init"

HRESULT CBaseDevice::Init(
    PD3D8_DEVICEDATA       pDevice,
    D3DDEVTYPE             DeviceType,
    HWND                   hwndFocusWindow,
    DWORD                  dwBehaviorFlags,
    D3DPRESENT_PARAMETERS *pPresentationParams,
    UINT                   AdapterIndex,
    CEnum                 *ParentClass)
{
    HRESULT hr;
    DWORD value = 0;

    m_DeviceData        = *pDevice;
    m_hwndFocusWindow   =  hwndFocusWindow;
    m_DeviceType        =  DeviceType;
    m_AdapterIndex      =  AdapterIndex;
    m_pD3DClass         =  ParentClass;
    GetD3DRegValue(REG_DWORD, "DisableDM", &value, sizeof(DWORD));
#ifdef WINNT
    m_dwBehaviorFlags   =  dwBehaviorFlags | (!IsWhistler() || value != 0 ? D3DCREATE_DISABLE_DRIVER_MANAGEMENT : 0);
#else
    m_dwBehaviorFlags   =  dwBehaviorFlags | (value != 0 ? D3DCREATE_DISABLE_DRIVER_MANAGEMENT : 0);
#endif
    value = 0;
    GetD3DRegValue(REG_DWORD, "DisableST", &value, sizeof(DWORD));
    m_dwOriginalBehaviorFlags = m_dwBehaviorFlags;
    if (value != 0)
    {
        m_dwBehaviorFlags |= D3DCREATE_MULTITHREADED;
    }
    
    MemFree(pDevice);   // Now that we've stored the contents, we can free the old memory

    ParentClass->AddRef();
#ifndef  WINNT
    if (FocusWindow())
    {
        hr = D3D8SetCooperativeLevel(GetHandle(), FocusWindow(), DDSCL_SETFOCUSWINDOW);
        if (FAILED(hr))
        {
            return hr;
        }
    }
#endif  //!WINNT

    //Figure out if we're a screen-saver or not.
    char	        name[_MAX_PATH];
    HMODULE hfile =  GetModuleHandle( NULL );

    name[0]=0;
    GetModuleFileName( hfile, name, sizeof( name ) -1 );
    int len = strlen(name);
    if( ( strlen(name) > 4 ) && 
        name[len - 4 ] == '.' &&
        (name[ len - 3 ] == 's' || name[ len - 3 ] == 'S' )&&
        (name[ len - 2 ] == 'c' || name[ len - 2 ] == 'C' )&&
        (name[ len - 1 ] == 'r' || name[ len - 1 ] == 'R' ))
    {
        m_dwBehaviorFlags |= 0x10000000;
    }

    // Initialize our critical section (if needed)
    if (m_dwBehaviorFlags & D3DCREATE_MULTITHREADED)
    {
        EnableCriticalSection();
    }


    // Initialize the resource manager
    hr = ResourceManager()->Init(this);
    if (hr != S_OK)
    {
        return hr;
    }

    m_DesktopMode.Height = DisplayHeight();
    m_DesktopMode.Width = DisplayWidth();
    m_DesktopMode.Format = DisplayFormat();
    m_DesktopMode.RefreshRate = DisplayRate();
    // Now call Reset to do any mode changes required and to create
    // the primary surface, etc.

    m_pSwapChain = new CSwapChain(
            this,
            REF_INTRINSIC);

    if (m_pSwapChain)
    {
        m_pSwapChain->Init(
            pPresentationParams,
            &hr);

        if (FAILED(hr))
            return hr;
    }
    else
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // If we were created with a specification for a default
    // z buffer; then we need to create one here.
    if (pPresentationParams->EnableAutoDepthStencil)
    {
        // Need to validate that this Z-buffer matches
        // the HW
        hr = CheckDepthStencilMatch(pPresentationParams->BackBufferFormat,
                                    pPresentationParams->AutoDepthStencilFormat);
        if (FAILED(hr))
        {
            DPF_ERR("AutoDepthStencilFormat does not match BackBufferFormat because "
                    "the current Device requires the bitdepth of the zbuffer to "
                    "match the render-target. See CheckDepthStencilMatch documentation. CreateDevice fails.");
            return hr;
        }


        IDirect3DSurface8 *pSurf;
        hr = CSurface::CreateZStencil(
            this,
            m_pSwapChain->Width(),
            m_pSwapChain->Height(),
            pPresentationParams->AutoDepthStencilFormat,
            pPresentationParams->MultiSampleType,
            REF_INTRINSIC,
            &pSurf);
        if (FAILED(hr))
        {
            DPF_ERR("Failure trying to create automatic zstencil surface. CreateDevice Failed.");
            return hr;
        }

        m_pAutoZStencil      = static_cast<CBaseSurface *>(pSurf);
    }

    UpdateRenderTarget(m_pSwapChain->m_ppBackBuffers[0], m_pAutoZStencil);
    m_fullscreen = !SwapChain()->m_PresentationData.Windowed;

    HKEY hKey;
    if(ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = 4;
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, "DisableVBFailovers", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
            dwType == REG_DWORD &&
            dwValue != 0)
        {
            m_bVBFailOversDisabled = TRUE;
        }
        RegCloseKey(hKey);
    }

    return hr;
} // Init

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetDeviceCaps"

STDMETHODIMP CBaseDevice::GetDeviceCaps(D3DCAPS8 *pCaps)
{
    API_ENTER(this);

    if (pCaps == NULL)
    {
        DPF_ERR("Invalid pointer to D3DCAPS8 specified. GetDeviceCaps fails");
        return D3DERR_INVALIDCALL;
    }

    Enum()->FillInCaps (
                pCaps,
                GetCoreCaps(),
                m_DeviceType,
                m_AdapterIndex);

    // Emulation of NPatches is done in software when they are not supported
    // for non-Pure devices.
    if ((pCaps->DevCaps & D3DDEVCAPS_RTPATCHES) && (BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0)
        pCaps->DevCaps |= D3DDEVCAPS_NPATCHES;

    // Now the Caps struct has all the hardware caps.
    // In case the device is running in a software vertex-processing mode
    // fix up the caps to reflect that.
    if( ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0)
        &&
        (static_cast<CD3DHal *>(this))->m_dwRuntimeFlags &
        D3DRT_RSSOFTWAREPROCESSING )
    {
        // We always do TL Vertex clipping for software vertex processing.
        pCaps->PrimitiveMiscCaps |= D3DPMISCCAPS_CLIPTLVERTS;
        
        pCaps->RasterCaps |= (D3DPRASTERCAPS_FOGVERTEX |
                              D3DPRASTERCAPS_FOGRANGE);

        // We do emulation when FVF has point size but the device does not
        // support it
        pCaps->FVFCaps |= D3DFVFCAPS_PSIZE;

        // All DX8 drivers have to support this cap.
        // Emulation is provided by the software vertex pipeline for all
        // pre-DX8 drivers.
        if( pCaps->MaxPointSize == 0 )
        {
            pCaps->MaxPointSize = 64; // __MAX_POINT_SIZE in d3ditype.h
        }

        pCaps->MaxActiveLights = 0xffffffff;
        pCaps->MaxVertexBlendMatrices = 4;
        pCaps->MaxUserClipPlanes = 6; // __MAXUSERCLIPPLANES in d3dfe.hpp
        pCaps->VertexProcessingCaps = (D3DVTXPCAPS_TEXGEN             |
                                       D3DVTXPCAPS_MATERIALSOURCE7    |
                                       D3DVTXPCAPS_DIRECTIONALLIGHTS  |
                                       D3DVTXPCAPS_POSITIONALLIGHTS   |
                                       D3DVTXPCAPS_LOCALVIEWER        |
                                       D3DVTXPCAPS_TWEENING);

        pCaps->MaxVertexBlendMatrixIndex = 255; // __MAXWORLDMATRICES - 1 in
                                                //  d3dfe.hpp
        pCaps->MaxStreams = 16; // __NUMSTREAMS in d3dfe.hpp
        pCaps->VertexShaderVersion = D3DVS_VERSION(1, 1); // Version 1.1
        pCaps->MaxVertexShaderConst = D3DVS_CONSTREG_MAX_V1_1;

        // Nuke NPATCHES and RT Patches caps, because software emulation 
        // cannot do that.
        pCaps->DevCaps &= ~(D3DDEVCAPS_NPATCHES | D3DDEVCAPS_RTPATCHES);
    }

    // MaxPointSize should never be reported as Zero. Internally though
    // we depend on Zero to be what decides to take the point-sprite emulation
    // path or not. 
    // If it is still zero at this point, fudge it up here.
    if( pCaps->MaxPointSize == 0 )
    {
        pCaps->MaxPointSize = 1.0f; 
    }

    return D3D_OK;

} // GetDeviceCaps

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetDeviceCaps"

STDMETHODIMP CBaseDevice::GetFrontBuffer(IDirect3DSurface8 *pDSurface)
{
    API_ENTER(this);

    RECT            Rect;
    D3DSURFACE_DESC SurfDesc;
    CDriverSurface* pPrimary;
    D3DLOCKED_RECT  PrimaryRect;
    D3DLOCKED_RECT  DestRect;
    HRESULT         hr;
    D3DFORMAT       Format;
    UINT            Width;
    UINT            Height;
    BYTE*           pSrc;
    BYTE*           pDest;
    DWORD*          pDstTemp;
    BYTE*           pSrc8;
    WORD*           pSrc16;
    DWORD*          pSrc32;
    UINT            i;
    UINT            j;
    PALETTEENTRY    Palette[256];

    if (pDSurface == NULL)
    {
        DPF_ERR("Invalid pointer to destination surface specified. GetFrontBuffer fails.");
        return D3DERR_INVALIDCALL;
    }
    CBaseSurface *pDestSurface = static_cast<CBaseSurface*>(pDSurface);
    if (pDestSurface->InternalGetDevice() != this)
    {
        DPF_ERR("Destination Surface was not allocated with this Device. GetFrontBuffer fails. ");
        return D3DERR_INVALIDCALL;
    }

    hr = pDestSurface->GetDesc(&SurfDesc);
    DXGASSERT(SUCCEEDED(hr));

    if (SurfDesc.Format != D3DFMT_A8R8G8B8)
    {
        DPF_ERR("Destination surface must have format D3DFMT_A8R8G8B8. GetFrontBuffer fails.");
        return D3DERR_INVALIDCALL;
    }
    if (SurfDesc.Type != D3DRTYPE_SURFACE)
    {
        DPF_ERR("Destination surface is an invalid type. GetFrontBuffer fails.");
        return D3DERR_INVALIDCALL;
    }
    if ( (SurfDesc.Pool != D3DPOOL_SYSTEMMEM) && (SurfDesc.Pool != D3DPOOL_SCRATCH))
    {
        DPF_ERR("Destination surface must be in system or scratch memory. GetFrontBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    Rect.left = Rect.top = 0;
    Rect.right = DisplayWidth();
    Rect.bottom = DisplayHeight();

    if ((SurfDesc.Width < (UINT)(Rect.right - Rect.left)) ||
        (SurfDesc.Height < (UINT)(Rect.bottom - Rect.top)))
    {
        DPF_ERR("Destination surface not big enough to hold the size of the screen. GetFrontBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    if (NULL == m_pSwapChain)
    {
        DPF_ERR("No Swap Chain present, GetFrontBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    // Lock the primary surface

    pPrimary = m_pSwapChain->PrimarySurface();
    if (NULL == pPrimary)
    {
        DPF_ERR("No Primary present, GetFrontBuffer fails");
        return D3DERR_DEVICELOST;
    }

    hr = pPrimary->LockRect(&PrimaryRect,
                            NULL,
                            0);
    if (SUCCEEDED(hr))
    {
        hr = pDestSurface->LockRect(&DestRect,
                                    NULL,
                                    0);

        if (FAILED(hr))
        {
            DPF_ERR("Unable to lock destination surface. GetFrontBuffer fails.");
            pPrimary->UnlockRect();
            return hr;
        }

        Format = DisplayFormat();

        Width = Rect.right;
        Height = Rect.bottom;

        pSrc = (BYTE*) PrimaryRect.pBits;
        pDest = (BYTE*) DestRect.pBits;

        if (Format == D3DFMT_P8)
        {
            HDC hdc;

            hdc = GetDC (NULL);
            GetSystemPaletteEntries(hdc, 0, 256, Palette);
            ReleaseDC (NULL, hdc);
        }

        for (i = 0; i < Height; i++)
        {
            pDstTemp = (DWORD*) pDest;
            switch (Format)
            {
            case D3DFMT_P8:
                pSrc8 = pSrc;
                for (j = 0; j < Width; j++)
                {
                    *pDstTemp = (Palette[*pSrc8].peRed << 16) |
                                (Palette[*pSrc8].peGreen << 8) |
                                (Palette[*pSrc8].peBlue);
                    pSrc8++;
                    pDstTemp++;
                }
                break;

            case D3DFMT_R5G6B5:
                pSrc16 = (WORD*) pSrc;
                for (j = 0; j < Width; j++)
                {
                    DWORD dwTemp = ((*pSrc16 & 0xf800) << 8) |
                                   ((*pSrc16 & 0x07e0) << 5) |
                                   ((*pSrc16 & 0x001f) << 3);

                    // Need to tweak ranges so that
                    // we map entirely to the 0x00 to 0xff
                    // for each channel. Basically, we
                    // map the high two/three bits of each
                    // channel to fill the gap at the bottom.
                    dwTemp |= (dwTemp & 0x00e000e0) >> 5;
                    dwTemp |= (dwTemp & 0x0000c000) >> 6;

                    // Write out our value
                    *pDstTemp = dwTemp;

                    pDstTemp++;
                    pSrc16++;
                }
                break;

            case D3DFMT_X1R5G5B5:
                pSrc16 = (WORD*) pSrc;
                for (j = 0; j < Width; j++)
                {
                    DWORD dwTemp= ((*pSrc16 & 0x7c00) << 9) |
                                  ((*pSrc16 & 0x03e0) << 6) |
                                  ((*pSrc16 & 0x001f) << 3);

                    // Need to tweak ranges so that
                    // we map entirely to the 0x00 to 0xff
                    // for each channel. Basically, we
                    // map the high three bits of each
                    // channel to fill the gap at the bottom.
                    dwTemp |= (dwTemp & 0x00e0e0e0) >> 5;

                    // Write out our value
                    *pDstTemp = dwTemp;

                    pDstTemp++;
                    pSrc16++;
                }
                break;

            case D3DFMT_R8G8B8:
                pSrc8 = pSrc;
                for (j = 0; j < Width; j++)
                {
                    *pDstTemp = (pSrc8[0] << 16) |
                                (pSrc8[1] << 8) |
                                (pSrc8[2]);
                    pDstTemp++;
                    pSrc8 += 3;
                }
                break;

            case D3DFMT_X8R8G8B8:
                pSrc32 = (DWORD*) pSrc;
                for (j = 0; j < Width; j++)
                {
                    *pDstTemp = *pSrc32 & 0xffffff;
                    pDstTemp++;
                    pSrc32++;
                }
                break;

            default:
                DXGASSERT(0);
                pDestSurface->UnlockRect();
                pPrimary->UnlockRect();
                return D3DERR_INVALIDCALL;
            }
            pSrc += PrimaryRect.Pitch;
            pDest += DestRect.Pitch;
        }

        pDestSurface->UnlockRect();
        pPrimary->UnlockRect();
    }

    return hr;
}

// End of file : dxgcreate.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\enum.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       enum.cpp
 *  Content     Handles all of the enum functions for determing what device
 *              you want before you go there.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include <stdio.h>

#include "d3dobj.hpp"
#include "pixel.hpp"
#include "enum.hpp"
#include "d3di.hpp"
#include "fcache.hpp"
#include "swapchan.hpp"


#define D3DPMISCCAPS_DX7VALID      \
    (D3DPMISCCAPS_MASKZ          | \
     D3DPMISCCAPS_LINEPATTERNREP | \
     D3DPMISCCAPS_CULLNONE       | \
     D3DPMISCCAPS_CULLCW         | \
     D3DPMISCCAPS_CULLCCW)

// Maps D3DMULTISAMPLE_TYPE into the bit to use for the flags.
// Maps each of the multisampling values (2 to 16) to the bits[1] to bits[15]
// of wBltMSTypes and wFlipMSTypes
#define DDI_MULTISAMPLE_TYPE(x) (1 << ((x)-1))

#ifdef WINNT
extern "C" BOOL IsWhistler();
#endif

void DXReleaseExclusiveModeMutex(void)
{
    if (hExclusiveModeMutex) 
    {
        BOOL bSucceed = ReleaseMutex(hExclusiveModeMutex);
        if (!bSucceed)
        {
            DWORD dwErr = GetLastError();
            DPF_ERR("Release Exclusive Mode Mutex Failed.");
            DPF_ERR("Application attempts to leave exclusive mode on different thread than the device was created on. Dangerous!!");
            DPF(0, "Mutex 0x%p could not be released. Extended Error = %d", 
                    hExclusiveModeMutex, dwErr);
            DXGASSERT(FALSE);
        }
    }
} // DXReleaseExclusiveModeMutex


// DLL exposed Creation function
IDirect3D8 * WINAPI Direct3DCreate8(UINT SDKVersion)
{
    // Turn off D3D8 interfaces on WOW64.
#ifndef _IA64_
#if _WIN32_WINNT >= 0x0501
    typedef BOOL (WINAPI *PFN_ISWOW64PROC)( HANDLE hProcess,
                                            PBOOL Wow64Process );
    HINSTANCE hInst = NULL;
    hInst = LoadLibrary( "kernel32.dll" );
    if( hInst )
    {
        PFN_ISWOW64PROC pfnIsWow64 = NULL;
        pfnIsWow64 = (PFN_ISWOW64PROC)GetProcAddress( (HMODULE)hInst, "IsWow64Process" );
        // We assume that if this function is not available, then it is some OS where
        // WOW64 does not exist (this means that pre-Release versions of XP are busted)
        if( pfnIsWow64 )
        {
            BOOL wow64Process;
            if (pfnIsWow64(GetCurrentProcess(), &wow64Process) && wow64Process)
            {
                DPF_ERR("DX8 D3D interfaces are not supported on WOW64");
                return NULL;
            }
        }
        FreeLibrary( hInst );
    }
    else
    {
        DPF_ERR("LoadLibrary failed. Quitting.");
        return NULL;
    }
#endif // _WIN32_WINNT >= 0x0501
#endif  // _IA64_

#ifndef DEBUG
    // Check for debug-please registry key. If debug is required, then
    // we delegate this call to the debug version, if it exists,,

    HKEY hKey;

    if (!RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD   type;
        DWORD   value;
        DWORD   cb = sizeof(value);

        if (!RegQueryValueEx(hKey, "LoadDebugRuntime", NULL, &type, (CONST LPBYTE)&value, &cb))
        {

            if (value)
            {
                HINSTANCE hDebugDLL = LoadLibrary("d3d8d.dll");
                if (hDebugDLL)
                {
                    typedef IDirect3D8* (WINAPI * PDIRECT3DCREATE8)(UINT);

                    PDIRECT3DCREATE8 pDirect3DCreate8 =
                        (PDIRECT3DCREATE8) GetProcAddress(hDebugDLL, "Direct3DCreate8");

                    if (pDirect3DCreate8)
                    {
                        return pDirect3DCreate8(SDKVersion);
                    }
                }
            }
        }
        RegCloseKey(hKey);
    }
#else
    //If we are debug, then spew a string at level 2
    DPF(2,"Direct3D8 Debug Runtime selected.");
#endif

#ifndef DX_FINAL_RELEASE
    // Time-bomb check.
    {
        #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
        SYSTEMTIME st;
        GetSystemTime(&st);

        if (st.wYear > DX_EXPIRE_YEAR ||
             ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH)))
           )
        {
            MessageBox(0, DX_EXPIRE_TEXT,
                          TEXT("Microsoft Direct3D"), MB_OK | MB_TASKMODAL);
        }
    }
#endif //DX_FINAL_RELEASE

#ifdef DEBUG
    HKEY hKey;
    if (!RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD   type;
        DWORD   value;
        DWORD   cb = sizeof(value);

        if (!RegQueryValueEx(hKey, "SDKVersion", NULL, &type, (CONST LPBYTE)&value, &cb))
        {
            if (value)
            {
                SDKVersion = value;
            }
        }
        RegCloseKey(hKey);
    }
#endif

    if ((SDKVersion != D3D_SDK_VERSION_DX8) && 
        ((SDKVersion < (D3D_SDK_VERSION)) || (SDKVersion >= (D3D_SDK_VERSION+100))) )
    {
        char pbuf[256];
        _snprintf(pbuf, 256,
            "\n"
            "D3D ERROR: This application compiled against improper D3D headers.\n"
            "The application is compiled with SDK version (%d) but the currently installed\n"
            "runtime supports versions from (%d).\n"
            "Please recompile with an up-to-date SDK.\n\n",
            SDKVersion, D3D_SDK_VERSION);
        OutputDebugString(pbuf);
        return NULL;
    }

    IDirect3D8 *pEnum = new CEnum(SDKVersion);
    if (pEnum == NULL)
    {
        DPF_ERR("Creating D3D enumeration object failed; out of memory. Direct3DCreate fails and returns NULL.");
    }
    return pEnum;
} // Direct3DCreate

//---------------------------------------------------------------------------
// CEnum methods
//---------------------------------------------------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::AddRef"

STDMETHODIMP_(ULONG) CEnum::AddRef(void)
{
    API_ENTER_NO_LOCK(this);

    // InterlockedIncrement requires the memory
    // to be aligned on DWORD boundary
    DXGASSERT(((ULONG_PTR)(&m_cRef) & 3) == 0);
    InterlockedIncrement((LONG *)&m_cRef);
    return m_cRef;
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::Release"

STDMETHODIMP_(ULONG) CEnum::Release(void)
{
    API_ENTER_NO_LOCK(this);

    // InterlockedDecrement requires the memory
    // to be aligned on DWORD boundary
    DXGASSERT(((ULONG_PTR)(&m_cRef) & 3) == 0);
    InterlockedDecrement((LONG *)&m_cRef);
    if (m_cRef != 0)
        return m_cRef;

    for (UINT i = 0; i < m_cAdapter; i++)
    {
        if (m_REFCaps[i].pGDD8SupportedFormatOps)
            MemFree(m_REFCaps[i].pGDD8SupportedFormatOps);

        if (m_SwCaps[i].pGDD8SupportedFormatOps)
            MemFree(m_SwCaps[i].pGDD8SupportedFormatOps);
        
        if (m_AdapterInfo[i].HALCaps.pGDD8SupportedFormatOps)
            MemFree(m_AdapterInfo[i].HALCaps.pGDD8SupportedFormatOps);
        if (m_AdapterInfo[i].pModeTable)
            MemFree(m_AdapterInfo[i].pModeTable);
    }
    if (m_hGammaCalibrator)
    {
        FreeLibrary((HMODULE) m_hGammaCalibrator);
    }

    delete this;
    return 0;
} // Release

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::QueryInterface"

STDMETHODIMP CEnum::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    API_ENTER(this);

    if (!VALID_PTR_PTR(ppv))
    {
        DPF_ERR("Invalid pointer passed to QueryInterface for IDirect3D8 interface");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for IDirect3D8 interface");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IUnknown || riid == IID_IDirect3D8)
    {
        *ppv = static_cast<void*>(static_cast<IDirect3D8*>(this));
        AddRef();
    }
    else
    {
        DPF_ERR("Unsupported Interface identifier passed to QueryInterface for IDirect3D8 interface");
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    return S_OK;
} // QueryInterface


// DisplayGUID - GUID used to enumerate secondary displays.
//
// {67685559-3106-11d0-B971-00AA00342F9F}
//
// we use this GUID and the next 32 for enumerating devices
// returned via EnumDisplayDevices
//
GUID DisplayGUID =
    {0x67685559,0x3106,0x11d0,{0xb9,0x71,0x0,0xaa,0x0,0x34,0x2f,0x9f}};


#undef DPF_MODNAME
#define DPF_MODNAME "::strToGUID"

/*
 * strToGUID
 *
 * converts a string in the form xxxxxxxx-xxxx-xxxx-xx-xx-xx-xx-xx-xx-xx-xx
 * into a guid
 */
static BOOL strToGUID(LPSTR str, GUID * pguid)
{
    int         idx;
    LPSTR       ptr;
    LPSTR       next;
    DWORD       data;
    DWORD       mul;
    BYTE        ch;
    BOOL        done;

    idx = 0;
    done = FALSE;
    while (!done)
    {
        /*
         * find the end of the current run of digits
         */
        ptr = str;
        while ((*str) != '-' && (*str) != 0)
        {
            str++;
        }
        if (*str == 0)
        {
            done = TRUE;
        }
        else
        {
            next = str+1;
        }

        /*
         * scan backwards from the end of the string to the beginning,
         * converting characters from hex chars to numbers as we go
         */
        str--;
        mul = 1;
        data = 0;
        while (str >= ptr)
        {
            ch = *str;
            if (ch >= 'A' && ch <= 'F')
            {
                data += mul * (DWORD) (ch-'A'+10);
            }
            else if (ch >= 'a' && ch <= 'f')
            {
                data += mul * (DWORD) (ch-'a'+10);
            }
            else if (ch >= '0' && ch <= '9')
            {
                data += mul * (DWORD) (ch-'0');
            }
            else
            {
                return FALSE;
            }
            mul *= 16;
            str--;
        }

        /*
         * stuff the current number into the guid
         */
        switch(idx)
        {
        case 0:
            pguid->Data1 = data;
            break;
        case 1:
            pguid->Data2 = (WORD) data;
            break;
        case 2:
            pguid->Data3 = (WORD) data;
            break;
        default:
            pguid->Data4[ idx-3 ] = (BYTE) data;
            break;
        }

        /*
         * did we find all 11 numbers?
         */
        idx++;
        if (idx == 11)
        {
            if (done)
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }
        str = next;
    }
    return FALSE;

} /* strToGUID */

// REF, HAL


typedef struct _DEVICEREGISTRYDATA
{
    UINT                Size;
    UINT                Cookie;
    FILETIME            FileDate;
    GUID                DriverGuid;
    D3D8_DRIVERCAPS     DeviceCaps;
    UINT                OffsetFormatOps;
    D3DFORMAT           Unknown16;
    DWORD               HALFlags;
} DEVICEREGISTRYDATA;

inline UINT EXPECTED_CACHE_SIZE(UINT nFormatOps)
{
    return sizeof(DEVICEREGISTRYDATA) + sizeof(DDSURFACEDESC) * nFormatOps;
}

#define DDRAW_REGCAPS_KEY   "Software\\Microsoft\\DirectDraw\\MostRecentDrivers"
#define VERSION_COOKIE  0x0083

#undef DPF_MODNAME
#define DPF_MODNAME "ReadCapsFromCache"

BOOL GetFileDate (char* Driver, FILETIME* pFileDate)
{
    WIN32_FILE_ATTRIBUTE_DATA   FA;
    char                    Name[MAX_PATH];
    HMODULE                 h = GetModuleHandle("KERNEL32");
    BOOL (WINAPI *pfnGetFileAttributesEx)(LPCSTR, GET_FILEEX_INFO_LEVELS, LPVOID);

    pFileDate->dwLowDateTime = 0;
    pFileDate->dwHighDateTime = 0;

    *((void **)&pfnGetFileAttributesEx) = GetProcAddress(h,"GetFileAttributesExA");
    if (pfnGetFileAttributesEx != NULL)
    {
        GetSystemDirectory(Name, sizeof(Name) - (strlen(Driver) + 3));
        lstrcat(Name,"\\");
        lstrcat(Name, Driver);

        if ((*pfnGetFileAttributesEx)(Name, GetFileExInfoStandard, &FA) != 0)
        {
            *pFileDate = FA.ftCreationTime;
            return TRUE;
        }
    }
    return FALSE;
}

//If pCaps is NULL, then those data will not be returned.
BOOL ReadCapsFromCache(UINT iAdapter,
                       D3D8_DRIVERCAPS *pCaps,
                       UINT* pHALFlags,
                       D3DFORMAT* pUnknown16,
                       char* pDeviceName,
                       BOOL bDisplayDriver)
{
    D3DADAPTER_IDENTIFIER8  DI;
    DEVICEREGISTRYDATA*     pData = NULL;
    UINT                    Size;
    FILETIME                FileDate;

    // Read the data from the registry

    // Don't need WHQL level or driver name
    GetAdapterInfo(pDeviceName, &DI, bDisplayDriver, TRUE, FALSE);

    ReadFromCache(&DI, &Size, (BYTE**)&pData);
    if (pData == NULL)
    {
        return FALSE;
    }

    // We have the data, now do a sanity check to make sure that it
    // it makes sense

    if (pData->Size != Size)
    {
        MemFree(pData);
        return FALSE;
    }
    if (Size != EXPECTED_CACHE_SIZE(pData->DeviceCaps.GDD8NumSupportedFormatOps))
    {
        MemFree(pData);
        return FALSE;
    }
    if (pData->DriverGuid != DI.DeviceIdentifier)
    {
        MemFree(pData);
        return FALSE;
    }
    if (pData->Cookie != VERSION_COOKIE)
    {
        MemFree(pData);
        return FALSE;
    }

    // Check the driver date to see if it changed

    if (GetFileDate(DI.Driver, &FileDate))
    {
        if ((FileDate.dwLowDateTime != pData->FileDate.dwLowDateTime) ||
            (FileDate.dwHighDateTime != pData->FileDate.dwHighDateTime))
        {
            MemFree(pData);
            return FALSE;
        }
    }

    *pUnknown16 = pData->Unknown16;
    *pHALFlags = pData->HALFlags;

    //Sometime we may not be asked to get the whole caps
    if (!pCaps)
    {
        MemFree(pData);
        return TRUE;
    }

    // Now that we have the data, we need to load it into a form that we
    // can use.

    memcpy(pCaps, &pData->DeviceCaps, sizeof(*pCaps));

    //reuse size to calculate size of support format ops
    Size = pData->DeviceCaps.GDD8NumSupportedFormatOps
        * sizeof(*(pData->DeviceCaps.pGDD8SupportedFormatOps));

    pCaps->pGDD8SupportedFormatOps = (DDSURFACEDESC*) MemAlloc(Size);

    if (pCaps->pGDD8SupportedFormatOps != NULL)
    {
        memcpy(pCaps->pGDD8SupportedFormatOps,
              ((BYTE*)pData) + pData->OffsetFormatOps,
              Size);
    }
    else
    {
        pCaps->GDD8NumSupportedFormatOps = 0;
    }

    MemFree(pData);

    return TRUE;
}
#undef DPF_MODNAME
#define DPF_MODNAME "WriteCapsToCache"

void WriteCapsToCache(UINT iAdapter,
                      D3D8_DRIVERCAPS *pCaps,
                      UINT HALFlags,
                      D3DFORMAT Unknown16,
                      char* pDeviceName,
                      BOOL  bDisplayDriver)
{
    DEVICEREGISTRYDATA*     pData;
    D3DADAPTER_IDENTIFIER8  DI;
    UINT                    Size;
    UINT                    Offset;
    FILETIME                FileDate;

    // Allocate the buffer and fill in all of the memory

    Size = EXPECTED_CACHE_SIZE(pCaps->GDD8NumSupportedFormatOps);

    pData = (DEVICEREGISTRYDATA*) MemAlloc(Size);
    if (pData == NULL)
    {
        return;
    }

    // Don't need WHQL level or driver name
    GetAdapterInfo(pDeviceName, &DI, bDisplayDriver, TRUE, FALSE);
    pData->DriverGuid = DI.DeviceIdentifier;

    pData->Size = Size;
    pData->Cookie = VERSION_COOKIE;
    memcpy(&pData->DeviceCaps, pCaps, sizeof(*pCaps));
    pData->Unknown16 = Unknown16;
    pData->HALFlags = HALFlags;

    if (GetFileDate(DI.Driver, &FileDate))
    {
        pData->FileDate = FileDate;
    }

    Offset = sizeof(DEVICEREGISTRYDATA);
    pData->OffsetFormatOps = Offset;
    memcpy(((BYTE*)pData) + Offset,
        pCaps->pGDD8SupportedFormatOps,
        pCaps->GDD8NumSupportedFormatOps *
            sizeof(*(pCaps->pGDD8SupportedFormatOps)));

    // Now save it

    WriteToCache(&DI, Size, (BYTE*) pData);

    MemFree(pData);
}

HRESULT CopyDriverCaps(D3D8_DRIVERCAPS* pDriverCaps, D3D8_DEVICEDATA* pDeviceData, BOOL bForce)
{
    HRESULT hr = D3DERR_INVALIDCALL;

    // Do they report any D3D caps in this mode?

    DWORD   Size;

    // If it's not at least a DX6 driver, we don't want to fill
    // in any caps at all. Also, if it can't texture, then
    // we don't to support it either.
    BOOL bCanTexture = TRUE;
    BOOL bCanHandleFVF = TRUE;
    BOOL bHasGoodCaps = TRUE;
    if (!bForce)
    {
        if (pDeviceData->DriverData.D3DCaps.TextureCaps)
        {
            bCanTexture = TRUE;
        }
        else
        {
            DPF(0, "HAL Disabled: Device doesn't support texturing");
            bCanTexture = FALSE;
        }

        // Some DX6 drivers are not FVF aware; and we need to
        // disable HAL for them.
        if (pDeviceData->DriverData.D3DCaps.FVFCaps != 0)
        {
            bCanHandleFVF = TRUE;
        }
        else
        {
            DPF(0, "HAL Disabled: Device doesn't support FVF");
            bCanHandleFVF = FALSE;
        }

        if (pDeviceData->Callbacks.DrawPrimitives2 == NULL)
        {
            DPF(0, "HAL Disabled: Device doesn't support DX6 or higher");
        }

        // We dont want drivers that report bogus caps:
        // pre-DX8 drivers that can do DX8 features.
        if (pDeviceData->DriverData.D3DCaps.MaxStreams == 0)
        {
            D3DCAPS8& Caps = pDeviceData->DriverData.D3DCaps;

            // Should have none of the following:
            //  1) PointSprites.
            //  2) VertexShaders.
            //  3) PixelShaders.
            //  4) Volume textures.
            //  5) Indexed Vertex Blending.
            //  6) Higher order primitives.
            //  7) PureDevice
            //  8) Perspective Color.
            //  9) Color Write.
            // 10) Newer texture caps.
            if ((Caps.MaxPointSize != 0)              ||
                (Caps.VertexShaderVersion != D3DVS_VERSION(0,0))  ||
                (Caps.PixelShaderVersion != D3DPS_VERSION(0,0))   ||
                (Caps.MaxVolumeExtent != 0)           ||
                (Caps.MaxVertexBlendMatrixIndex != 0) ||
                (Caps.MaxVertexIndex != 0xffff)       ||
                ((Caps.DevCaps & ~(D3DDEVCAPS_DX7VALID | D3DDEVCAPS_HWVERTEXBUFFER)) != 0)        ||
                ((Caps.RasterCaps & ~(D3DPRASTERCAPS_DX7VALID)) != 0) ||
                ((Caps.PrimitiveMiscCaps & ~(D3DPMISCCAPS_DX7VALID)) != 0)  ||
                ((Caps.TextureCaps & ~(D3DPTEXTURECAPS_DX7VALID)) != 0)
                )
            {
                DPF(0, "HAL Disabled: DX7 Device should not support DX8 features");
                bHasGoodCaps = FALSE;
            }
        }
        else
        // We dont want drivers that report bogus caps:
        // DX8 drivers should do DX8 features.
        {
            D3DCAPS8& Caps = pDeviceData->DriverData.D3DCaps;
        }
    }

    // We require drivers to support DP2 (i.e. DX6+),
    // texturing and proper FVF support in order to use a HAL

    if ((pDeviceData->Callbacks.DrawPrimitives2 != NULL &&
        bCanTexture   &&
        bCanHandleFVF &&
        bHasGoodCaps) ||
        bForce)
    {
        MemFree(pDriverCaps->pGDD8SupportedFormatOps);
        memcpy(pDriverCaps,
               &pDeviceData->DriverData, sizeof(pDeviceData->DriverData));

        Size = sizeof(DDSURFACEDESC) *
            pDriverCaps->GDD8NumSupportedFormatOps;
        pDriverCaps->pGDD8SupportedFormatOps =
            (DDSURFACEDESC*) MemAlloc(Size);

        if (pDriverCaps->pGDD8SupportedFormatOps != NULL)
        {
            memcpy(pDriverCaps->pGDD8SupportedFormatOps,
                   pDeviceData->DriverData.pGDD8SupportedFormatOps,
                   Size);
        }
        else
        {
            pDriverCaps->GDD8NumSupportedFormatOps = 0;
        }

        hr = D3D_OK;
    }
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "AddSoftwareDevice"

HRESULT AddSoftwareDevice(D3DDEVTYPE        DeviceType,
                          D3D8_DRIVERCAPS*  pSoftCaps,
                          ADAPTERINFO*      pAdapterInfo,
                          VOID*             pInitFunction)
{
    HRESULT             hr;
    PD3D8_DEVICEDATA    pDeviceData;

    hr = InternalDirectDrawCreate(&pDeviceData,
                                  pAdapterInfo,
                                  DeviceType,
                                  pInitFunction,
                                  pAdapterInfo->Unknown16,
                                  pAdapterInfo->HALCaps.pGDD8SupportedFormatOps,
                                  pAdapterInfo->HALCaps.GDD8NumSupportedFormatOps);
    if (SUCCEEDED(hr))
    {
        hr = CopyDriverCaps(pSoftCaps, pDeviceData, FALSE);

        InternalDirectDrawRelease(pDeviceData);
    }
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CreateCoverWindow"

HWND CreateCoverWindow()
{
#define COVERWINDOWNAME "DxCoverWindow"

    WNDCLASS windowClass =
    {
        0,
        DefWindowProc,
        0,
        0,
        g_hModule,
        LoadIcon(NULL, IDI_APPLICATION),
        LoadCursor(NULL, IDC_ARROW),
        (HBRUSH)(BLACK_BRUSH),
        NULL,
        COVERWINDOWNAME
    };

    RegisterClass(&windowClass);

    HWND hWindow = CreateWindowEx(
            WS_EX_TOPMOST,
            COVERWINDOWNAME,
            COVERWINDOWNAME,
            WS_POPUP,
            0,
            0,
            100,
            100,
            NULL,
            NULL,
            g_hModule,
            NULL);

    return hWindow;
}


HRESULT GetHALCapsInCurrentMode (PD3D8_DEVICEDATA pHalData, PADAPTERINFO pAdapterInfo, BOOL bForce, BOOL bFetchNewCaps)
{
    HRESULT             hr;
    DWORD               i;

    // Free the old stuff if we no longer care

    if (bFetchNewCaps)
    {
        MemFree(pHalData->DriverData.pGDD8SupportedFormatOps);
        pHalData->DriverData.pGDD8SupportedFormatOps = NULL;
        pHalData->DriverData.GDD8NumSupportedFormatOps = 0;

        MemFree(pAdapterInfo->HALCaps.pGDD8SupportedFormatOps);
        pAdapterInfo->HALCaps.pGDD8SupportedFormatOps = NULL;
        pAdapterInfo->HALCaps.GDD8NumSupportedFormatOps = 0;

        // Set this to ensure that we actually get the caps

        pHalData->DriverData.D3DCaps.DevCaps = 0;
        pHalData->DriverData.dwFlags &= ~DDIFLAG_D3DCAPS8;

        FetchDirectDrawData(pHalData, 
                            NULL, 
                            pAdapterInfo->Unknown16, 
                            NULL,
                            0);
    }

    // Do they report any D3D caps in this mode?

    hr = CopyDriverCaps(&pAdapterInfo->HALCaps, pHalData, bForce);

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "ProfileAdapter"

void ProfileAdapter(
    PADAPTERINFO        pAdapterInfo,
    PD3D8_DEVICEDATA    pHalData)
{
    UINT                    i;
    IDirect3DDevice8*       pDevice;
    D3DDISPLAYMODE          OrigMode;
    UINT                    OrigBpp;
    HRESULT                 hr;

    // We will be changing display modes, so first we want to save the current
    // mode so we can return to it later.

    D3D8GetMode (pHalData->hDD, pAdapterInfo->DeviceName, &OrigMode, D3DFMT_UNKNOWN);

    MemFree(pAdapterInfo->HALCaps.pGDD8SupportedFormatOps);
    memset(&pAdapterInfo->HALCaps, 0, sizeof(D3D8_DRIVERCAPS));

    OrigBpp = CPixel::ComputePixelStride(OrigMode.Format)*8;

    //First gather what we need from 16bpp: Unknown16 format
    if (16 != OrigBpp)
    {
            D3D8SetMode (pHalData->hDD,
                        pAdapterInfo->DeviceName,
                        640,
                        480,
                        16,
                        0,
                        FALSE);
    }

    D3DDISPLAYMODE              Mode;
    D3D8GetMode (pHalData->hDD, pAdapterInfo->DeviceName, &Mode, D3DFMT_UNKNOWN);
    pAdapterInfo->Unknown16 = Mode.Format;

    // We need to change to 32bpp, because the above code guarenteed we are now in 16bpp
    hr = D3D8SetMode (pHalData->hDD,
                        pAdapterInfo->DeviceName,
                        640,
                        480,
                        32,
                        0,
                        FALSE);
    if (SUCCEEDED(hr))
    {
        hr = GetHALCapsInCurrentMode(pHalData, pAdapterInfo, FALSE, TRUE);
    }

    if (FAILED(hr))
    {
        // If they don't report caps in 32bpp mode (ala Voodoo 3), then go
        // back to 16bpp mode and get the caps.  If the device supports
        // caps in any mode, we want to exit this function with the caps.

        D3D8SetMode (pHalData->hDD,
                     pAdapterInfo->DeviceName,
                     640,
                     480,
                     16,
                     0,
                     FALSE);

        hr = GetHALCapsInCurrentMode(pHalData, pAdapterInfo, FALSE, TRUE);

        // If they don't report good D3D caps in any mode at all, we still need
        // to return some caps, if only so we can support a SW driver.
     
        if (FAILED(hr))
        {
            GetHALCapsInCurrentMode(pHalData, pAdapterInfo, TRUE, TRUE);
            for (i = 0; i < pAdapterInfo->HALCaps.GDD8NumSupportedFormatOps; i++)
            {
                pAdapterInfo->HALCaps.pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwOperations &= D3DFORMAT_OP_DISPLAYMODE;
            }
        }
    }

    //And now set back to original mode...
    D3D8SetMode (pHalData->hDD,
                     pAdapterInfo->DeviceName,
                     OrigMode.Width,
                     OrigMode.Height,
                     OrigBpp,
                     0,
                     TRUE);
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetRefCaps"


void CEnum::GetRefCaps(UINT iAdapter)
{
    // If we've already got the caps once, there's ne need to get
    // them again

    if (m_REFCaps[iAdapter].GDD8NumSupportedFormatOps == 0)
    {
        AddSoftwareDevice(D3DDEVTYPE_REF,
                          &m_REFCaps[iAdapter],
                          &m_AdapterInfo[iAdapter],
                          NULL);
    }
}

void CEnum::GetSwCaps(UINT iAdapter)
{
    // If we've already got the caps once, there's ne need to get
    // them again

    if (m_SwCaps[iAdapter].GDD8NumSupportedFormatOps == 0)
    {
        AddSoftwareDevice(D3DDEVTYPE_SW,
                          &m_SwCaps[iAdapter],
                          &m_AdapterInfo[iAdapter],
                          m_pSwInitFunction);
    }
}

// IsSupportedOp
// Runs the pixel format operation list looking to see if the
// selected format can support at least the requested operations.

#undef DPF_MODNAME
#define DPF_MODNAME "IsSupportedOp"

BOOL IsSupportedOp (D3DFORMAT   Format,
               DDSURFACEDESC*   pList,
               UINT             NumElements,
               DWORD            dwRequestedOps)
{
    UINT i;

    for (i = 0; i < NumElements; i++)
    {
        DDASSERT(pList[i].ddpfPixelFormat.dwFlags == DDPF_D3DFORMAT);

        if (pList[i].ddpfPixelFormat.dwFourCC == (DWORD) Format &&
            (pList[i].ddpfPixelFormat.dwOperations & dwRequestedOps) == dwRequestedOps)
        {
            return TRUE;
        }
    }

    return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "IsInList"

BOOL IsInList (D3DFORMAT    Format,
               D3DFORMAT*   pList,
               UINT         NumElements)
{
    UINT i;

    for (i = 0; i < NumElements; i++)
    {
        if (pList[i] == Format)
        {
            return TRUE;
        }
    }

    return FALSE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::MapDepthStencilFormat"

D3DFORMAT CEnum::MapDepthStencilFormat(UINT         iAdapter,
                                       D3DDEVTYPE   Type, 
                                       D3DFORMAT    Format) const
{
    DXGASSERT(CPixel::IsMappedDepthFormat(D3DFMT_D24X8));
    DXGASSERT(CPixel::IsMappedDepthFormat(D3DFMT_D15S1));
    DXGASSERT(CPixel::IsMappedDepthFormat(D3DFMT_D24S8));
    DXGASSERT(CPixel::IsMappedDepthFormat(D3DFMT_D16));
    DXGASSERT(CPixel::IsMappedDepthFormat(D3DFMT_D24X4S4));

    if (CPixel::IsMappedDepthFormat(Format))
    {
        DDSURFACEDESC *pTextureList;
        UINT           NumTextures;

        switch (Type)
        {
        case D3DDEVTYPE_SW:
            pTextureList = m_SwCaps[iAdapter].pGDD8SupportedFormatOps;
            NumTextures = m_SwCaps[iAdapter].GDD8NumSupportedFormatOps;
            break;

        case D3DDEVTYPE_HAL:
            NumTextures = m_AdapterInfo[iAdapter].HALCaps.GDD8NumSupportedFormatOps;
            pTextureList = m_AdapterInfo[iAdapter].HALCaps.pGDD8SupportedFormatOps;
            break;

        case D3DDEVTYPE_REF:
            NumTextures = m_REFCaps[iAdapter].GDD8NumSupportedFormatOps;
            pTextureList = m_REFCaps[iAdapter].pGDD8SupportedFormatOps;
            break;
        }

        // No operations are required; we just want to know
        // if this format is listed in the table for any purpose
        // at all
        DWORD dwRequiredOperations = 0;

        switch (Format)
        {
        case D3DFMT_D24X4S4:
            if (IsSupportedOp(D3DFMT_X4S4D24, pTextureList, NumTextures, dwRequiredOperations))
            {
                return D3DFMT_X4S4D24;
            }
            break;

        case D3DFMT_D24X8:
            if (IsSupportedOp(D3DFMT_X8D24, pTextureList, NumTextures, dwRequiredOperations))
            {
                return D3DFMT_X8D24;
            }
            break;

        case D3DFMT_D24S8:
            if (IsSupportedOp(D3DFMT_S8D24, pTextureList, NumTextures, dwRequiredOperations))
            {
                return D3DFMT_S8D24;
            }
            break;

        case D3DFMT_D16:
            if (IsSupportedOp(D3DFMT_D16, pTextureList, NumTextures, dwRequiredOperations))
            {
                return D3DFMT_D16;
            }
            return D3DFMT_D16_LOCKABLE;

        case D3DFMT_D15S1:
            if (IsSupportedOp(D3DFMT_S1D15, pTextureList, NumTextures, dwRequiredOperations))
            {
                return D3DFMT_S1D15;
            }
            break;

        default:
            // Unexpected format?
            DXGASSERT(FALSE);
            break;
        }
    }

    return Format;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::GetAdapterCaps"

HRESULT CEnum::GetAdapterCaps(UINT              iAdapter,
                              D3DDEVTYPE        Type,
                              D3D8_DRIVERCAPS** ppCaps)
{
    *ppCaps = NULL;
    if (Type == D3DDEVTYPE_REF)
    {
        GetRefCaps (iAdapter);
        *ppCaps = &m_REFCaps[iAdapter];
        if (m_REFCaps[iAdapter].GDD8NumSupportedFormatOps == 0)
        {
            DPF_ERR("The reference driver cannot be found. GetAdapterCaps fails.");
            return D3DERR_NOTAVAILABLE;
        }
        return D3D_OK;
    }
    else if (Type == D3DDEVTYPE_SW)
    {
        if (m_pSwInitFunction == NULL)
        {
            DPF_ERR("No SW device has been registered.. GetAdapterCaps fails.");
            return D3DERR_INVALIDCALL;
        }
        else
        {
            GetSwCaps(iAdapter);
            *ppCaps = &m_SwCaps[iAdapter];
            if (m_SwCaps[iAdapter].GDD8NumSupportedFormatOps == 0)
            {
                DPF_ERR("The software driver cannot be loaded.  GetAdapterCaps fails.");
                return D3DERR_NOTAVAILABLE;
            }
            return D3D_OK;
        }
    }
    else if (Type == D3DDEVTYPE_HAL)
    {
        DWORD   i;

        if (m_bDisableHAL)
        {
            DPF_ERR("HW device not available.  GetAdapterCaps fails.");
            return D3DERR_NOTAVAILABLE;
        }

        *ppCaps = &m_AdapterInfo[iAdapter].HALCaps;
        return D3D_OK;
    }

    return D3DERR_INVALIDDEVICE;
}

void GetDX8HALCaps(UINT iAdapter, PD3D8_DEVICEDATA pHalData, ADAPTERINFO * pAdapterInfo)
{
    //DX7 or older drivers may need to be profiled to determine
    //their 555/565 format and whether they support an alpha
    //channel in 32bpp

    D3DFORMAT       CachedUnknown16 = D3DFMT_UNKNOWN;
    UINT            CachedHALFlags = 0;
    D3DDISPLAYMODE  Mode;
    BOOL            bProfiled = FALSE;
    UINT            i;
    HRESULT         hr;

    // If it's a DX8 driver, we hopefully don't need to profile at all.

    pAdapterInfo->Unknown16 = D3DFMT_UNKNOWN;
    hr = GetHALCapsInCurrentMode(pHalData, pAdapterInfo, FALSE, FALSE);
    if (SUCCEEDED(hr))
    {
        for (i = 0; i < pAdapterInfo->HALCaps.GDD8NumSupportedFormatOps; i++)
        {
            if (pAdapterInfo->HALCaps.pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_DISPLAYMODE)
            {
                switch (pAdapterInfo->HALCaps.pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwFourCC)
                {
                case D3DFMT_X1R5G5B5:
                case D3DFMT_R5G6B5:
                    pAdapterInfo->Unknown16 = (D3DFORMAT) pAdapterInfo->HALCaps.pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwFourCC;
                    break;
                }
            }
        }

        if (pAdapterInfo->Unknown16 != D3DFMT_UNKNOWN)
        {
            // That wasn't hard
            return;
        }
    }

    // We are definately need to read stuff from the caps at some point,
    // so why not now?

    if (!ReadCapsFromCache(iAdapter,
           NULL,
           &CachedHALFlags,
           &CachedUnknown16,
           pAdapterInfo->DeviceName,
           pAdapterInfo->bIsDisplay))
    {
        // There's nothing to read, so we need to re-profile
        ProfileAdapter(
                pAdapterInfo,
                pHalData);
        bProfiled = TRUE;
    }

    // If we profiled, then we already have everything that we need;
    // otherwise, we have to go get it.

    if (!bProfiled)
    {
        D3D8GetMode (pHalData->hDD, pAdapterInfo->DeviceName, &Mode, D3DFMT_UNKNOWN);
        if ((Mode.Format == D3DFMT_X1R5G5B5) ||
            (Mode.Format == D3DFMT_R5G6B5))
        {
            pAdapterInfo->Unknown16 = Mode.Format;
        }
        else
        {
            pAdapterInfo->Unknown16 = CachedUnknown16;
        }

        HRESULT hCurrentModeIsSupported = GetHALCapsInCurrentMode(pHalData, pAdapterInfo, FALSE, TRUE);

        if (FAILED(hCurrentModeIsSupported))
        {
            // We assume that this will succeed because the call above already has
            ReadCapsFromCache(iAdapter,
                      &pAdapterInfo->HALCaps,
                      &CachedHALFlags,
                      &CachedUnknown16,
                      pAdapterInfo->DeviceName,
                      pAdapterInfo->bIsDisplay);
            DPF(0,"D3D not supported in current mode - reading caps from file");
        }
    }

    //We now have good caps. Write them out to the cache.
    WriteCapsToCache(iAdapter,
                 &pAdapterInfo->HALCaps,
                 pAdapterInfo->HALFlags,
                 pAdapterInfo->Unknown16,
                 pAdapterInfo->DeviceName,
                 pAdapterInfo->bIsDisplay);
}

#ifdef WINNT
void FakeDirectDrawCreate (ADAPTERINFO * pAdapterInfo, int iAdapter)
{
    HDC             hdc;
    DDSURFACEDESC*  pTextureList = NULL;
    BOOL            bProfiled = FALSE;
    BOOL            b32Supported;
    BOOL            b16Supported;
    int             NumOps;
    DWORD           j;
    
    pTextureList = (DDSURFACEDESC *) MemAlloc (2 * sizeof (*pTextureList));
    if (pTextureList != NULL)
    {
        hdc = DD_CreateDC(pAdapterInfo->DeviceName);
        if (hdc != NULL)
        {
            HANDLE      hDD;
            HINSTANCE   hLib;

            D3D8CreateDirectDrawObject(hdc,
                                       pAdapterInfo->DeviceName,
                                       &hDD,
                                       D3DDEVTYPE_HAL,
                                       &hLib,
                                       NULL);
            if (hDD != NULL)
            {
                pAdapterInfo->bNoDDrawSupport = TRUE;

                // Figure out the unknown 16 value

                if (!ReadCapsFromCache(iAdapter,
                    NULL,
                    &(pAdapterInfo->HALFlags),
                    &(pAdapterInfo->Unknown16),
                    pAdapterInfo->DeviceName,
                    pAdapterInfo->bIsDisplay))
                {
                    D3DDISPLAYMODE  OrigMode;
                    D3DDISPLAYMODE  NewMode;

                    D3D8GetMode (hDD, 
                        pAdapterInfo->DeviceName, 
                        &OrigMode, 
                        D3DFMT_UNKNOWN);

                    if ((OrigMode.Format == D3DFMT_R5G6B5) ||
                        (OrigMode.Format == D3DFMT_X1R5G5B5))
                    {
                        pAdapterInfo->Unknown16 = OrigMode.Format;
                    }
                    else
                    {
                        D3D8SetMode (hDD,
                            pAdapterInfo->DeviceName,
                            640,
                            480,
                            16,
                            0,
                            FALSE);

                        D3D8GetMode (hDD, 
                            pAdapterInfo->DeviceName, 
                            &NewMode, 
                            D3DFMT_UNKNOWN);

                        D3D8SetMode (hDD,
                            pAdapterInfo->DeviceName, 
                            OrigMode.Width,
                            OrigMode.Height,
                            0,
                            0,
                            TRUE);
                        pAdapterInfo->Unknown16 = NewMode.Format;
                    }
                    bProfiled = TRUE;
                }

                // Build the mode table

                while (1)
                {
                    D3D8BuildModeTable(
                        pAdapterInfo->DeviceName,
                        NULL,
                        &(pAdapterInfo->NumModes),
                        pAdapterInfo->Unknown16,
                        hDD,
                        TRUE,
                        TRUE);
                    if (pAdapterInfo->NumModes)
                    {
                        pAdapterInfo->pModeTable = (D3DDISPLAYMODE*)
                            MemAlloc (sizeof(D3DDISPLAYMODE) * pAdapterInfo->NumModes);
                        if (pAdapterInfo->pModeTable != NULL)
                        {
                            D3D8BuildModeTable(
                                pAdapterInfo->DeviceName,
                                pAdapterInfo->pModeTable,
                                &(pAdapterInfo->NumModes),
                                pAdapterInfo->Unknown16,
                                hDD,
                                TRUE,
                                TRUE);

                            //If D3D8BuildModeTable finds it needs more space for its table,
                            //it will return 0 to indicate we should try again.
                            if (0 == pAdapterInfo->NumModes)
                            {
                                MemFree(pAdapterInfo->pModeTable);
                                pAdapterInfo->pModeTable = NULL;
                                continue;
                            }
                        }
                        else
                        {
                            pAdapterInfo->NumModes = 0;
                        }
                    }
                    break;
                }//while(1)

                // Now build a rudimentary op list based on what modes we support

                b32Supported = b16Supported = FALSE;
                for (j = 0; j < pAdapterInfo->NumModes; j++)
                {
                    if (pAdapterInfo->pModeTable[j].Format == D3DFMT_X8R8G8B8)
                    {
                        b32Supported = TRUE;
                    }
                    if (pAdapterInfo->pModeTable[j].Format == pAdapterInfo->Unknown16)
                    {
                        b16Supported = TRUE;
                    }
                }

                NumOps = 0;
                if (b16Supported)
                {
                    pTextureList[NumOps].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                    pTextureList[NumOps].ddpfPixelFormat.dwFourCC = (DWORD) pAdapterInfo->Unknown16;
                    pTextureList[NumOps].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_DISPLAYMODE;
                    pTextureList[NumOps].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                    pTextureList[NumOps].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                    pTextureList[NumOps].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                    NumOps++;
                }

                if (b32Supported)
                {
                    pTextureList[NumOps].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                    pTextureList[NumOps].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8R8G8B8;
                    pTextureList[NumOps].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_DISPLAYMODE;
                    pTextureList[NumOps].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                    pTextureList[NumOps].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                    pTextureList[NumOps].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                    NumOps++;
                }

                pAdapterInfo->HALCaps.pGDD8SupportedFormatOps = pTextureList;
                pAdapterInfo->HALCaps.GDD8NumSupportedFormatOps = NumOps;

                if (bProfiled)
                {
                    WriteCapsToCache(iAdapter,
                        &(pAdapterInfo->HALCaps),
                        pAdapterInfo->HALFlags,
                        pAdapterInfo->Unknown16,
                        pAdapterInfo->DeviceName,
                        pAdapterInfo->bIsDisplay);
                }

                D3D8DeleteDirectDrawObject(hDD);
            }
            DD_DoneDC(hdc);
        }
        if (pAdapterInfo->HALCaps.pGDD8SupportedFormatOps == NULL)
        {
            MemFree(pTextureList);
        }
    }
}
#endif


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::CEnum"


CEnum::CEnum(UINT AppSdkVersion)
    :
    m_cRef(1),
    m_cAdapter(0),
    m_bHasExclusive(FALSE),
    m_AppSdkVersion(AppSdkVersion)
{
    DWORD           rc;
    DWORD           keyidx;
    HKEY            hkey;
    HKEY            hsubkey;
    char            keyname[256];
    char            desc[256];
    char            drvname[MAX_PATH];
    DWORD           cb;
    DWORD           i;
    DWORD           type;
    GUID            guid;
    HDC             hdc;
    DISPLAY_DEVICEA dd;

    // Give our base class a pointer to ourselves
    SetOwner(this);

    // Initialize our critical section
    EnableCriticalSection();

    // Disable DPFs that occur during this phase
    DPF_MUTE();

    // WARNING: Must call DPF_UNMUTE before returning from
    // this function.
    for (i = 0; i < MAX_DX8_ADAPTERS; i++)
        m_pFullScreenDevice[i] = NULL;

    ZeroMemory(m_AdapterInfo, sizeof(m_AdapterInfo));

    // Always make the first entry reflect the primary device
    ZeroMemory(&dd, sizeof(dd));
    dd.cb = sizeof(dd);
    for (i = 0; xxxEnumDisplayDevicesA(NULL, i, &dd, 0); i++)
    {
        //
        // skip drivers that are not hardware devices
        //
        if (dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
            continue;
           
        //
        // don't enumerate devices that are not attached
        //
        if (!(dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP))
            continue;

        if (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
        {
            m_AdapterInfo[m_cAdapter].Guid = DisplayGUID;
            m_AdapterInfo[m_cAdapter].Guid.Data1 += i;
            lstrcpyn(m_AdapterInfo[m_cAdapter].DeviceName, dd.DeviceName, MAX_PATH);
            m_AdapterInfo[m_cAdapter].bIsPrimary = TRUE;
            m_AdapterInfo[m_cAdapter++].bIsDisplay = TRUE;
        }
    }

    // Now get the info for the attached secondary devices

    for (i = 0; xxxEnumDisplayDevicesA(NULL, i, &dd, 0); i++)
    {
        //
        // skip drivers that are not hardware devices
        //
        if (dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
            continue;

        //
        // don't enumerate devices that are not attached
        //
        if (!(dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP))
            continue;

        if (!(dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) &&
            (m_cAdapter < MAX_DX8_ADAPTERS))
        {
            m_AdapterInfo[m_cAdapter].Guid = DisplayGUID;
            m_AdapterInfo[m_cAdapter].Guid.Data1 += i;
            lstrcpyn(m_AdapterInfo[m_cAdapter].DeviceName, dd.DeviceName, MAX_PATH);
            m_AdapterInfo[m_cAdapter].bIsPrimary = FALSE;
            m_AdapterInfo[m_cAdapter++].bIsDisplay = TRUE;
        }
    }

    // Now get info for the passthrough devices listed under
    // HKEY_LOCALMACHINE\Hardware\DirectDrawDrivers

    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_DDHW, &hkey) == 0)
    {
        keyidx = 0;
        while (!RegEnumKey(hkey, keyidx, keyname, sizeof(keyname)))
        {
            if (strToGUID(keyname, &guid))
            {
                if (!RegOpenKey(hkey, keyname, &hsubkey))
                {
                    cb = sizeof(desc) - 1;
                    if (!RegQueryValueEx(hsubkey, REGSTR_KEY_DDHW_DESCRIPTION, NULL, &type,
                        (CONST LPBYTE)desc, &cb))
                    {
                        if (type == REG_SZ)
                        {
                            desc[cb] = 0;
                            cb = sizeof(drvname) - 1;
                            if (!RegQueryValueEx(hsubkey, REGSTR_KEY_DDHW_DRIVERNAME, NULL, &type,
                                (CONST LPBYTE)drvname, &cb))
                            {
                                // It is possible that the registry is out
                                // of date, so we will try to create a DC.
                                // The problem is that the Voodoo 1 driver
                                // will suceed on a Voodoo 2, Banshee, or
                                // Voodoo 3 (and hang later), so we need to
                                //  hack around it.

                                drvname[cb] = 0;
                                if (Voodoo1GoodToGo(&guid))
                                {
                                    hdc = DD_CreateDC(drvname);
                                }
                                else
                                {
                                    hdc = NULL;
                                }
                                if ((type == REG_SZ) &&
                                    (hdc != NULL))
                                {
                                    if (m_cAdapter < MAX_DX8_ADAPTERS)
                                    {
                                        drvname[cb] = 0;
                                        m_AdapterInfo[m_cAdapter].Guid = guid;
                                        lstrcpyn(m_AdapterInfo[m_cAdapter].DeviceName, drvname, MAX_PATH);
                                        m_AdapterInfo[m_cAdapter].bIsPrimary = FALSE;
                                        m_AdapterInfo[m_cAdapter++].bIsDisplay = FALSE;
                                    }
                                }
                                if (hdc != NULL)
                                {
                                    DD_DoneDC(hdc);
                                }
                            }
                        }
                    }
                    RegCloseKey(hsubkey);
                }
            }
            keyidx++;
        }
        RegCloseKey(hkey);
    }
    DPF_UNMUTE();

    //  Now that we know about all of the devices, we need to build a mode
    //  table for each one

    for (i = 0; i < m_cAdapter; i++)
    {
        HRESULT             hr;
        D3DDISPLAYMODE      Mode;
        DWORD               j;
        BOOL                b16bppSupported;
        BOOL                b32bppSupported;
        PD3D8_DEVICEDATA    pHalData;

        hr = InternalDirectDrawCreate(&pHalData,
                                      &m_AdapterInfo[i],
                                      D3DDEVTYPE_HAL,
                                      NULL,
                                      D3DFMT_UNKNOWN,
                                      NULL,
                                      0);

        if (FAILED(hr))
        {
            memset(&m_AdapterInfo[i].HALCaps, 0, sizeof(m_AdapterInfo[i].HALCaps));

            // On Win2K, we want to enable sufficient functionality so that this
            // adapter can at least run a sw driver.  If it truly failed due to 
            // no ddraw support, we need to special case this and then build a
            // rudimentary op list indicting that it works in the current mode.

            #ifdef WINNT
                FakeDirectDrawCreate(&m_AdapterInfo[i], i);
            #endif
        }
        else
        {
            GetDX8HALCaps(i, pHalData, &m_AdapterInfo[i]);

            b16bppSupported = b32bppSupported = FALSE;
            for (j = 0; j < m_AdapterInfo[i].HALCaps.GDD8NumSupportedFormatOps; j++)
            {
                if (m_AdapterInfo[i].HALCaps.pGDD8SupportedFormatOps[j].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_DISPLAYMODE)
                {
                    switch(m_AdapterInfo[i].HALCaps.pGDD8SupportedFormatOps[j].ddpfPixelFormat.dwFourCC)
                    {
                    case D3DFMT_X1R5G5B5:
                    case D3DFMT_R5G6B5:
                        b16bppSupported = TRUE;
                        break;

                    case D3DFMT_X8R8G8B8:
                        b32bppSupported = TRUE;
                        break;
                    }
                }
            }

            while (1)
            {
                D3D8BuildModeTable(
                    m_AdapterInfo[i].DeviceName,
                    NULL,
                    &m_AdapterInfo[i].NumModes,
                    m_AdapterInfo[i].Unknown16,
                    pHalData->hDD,
                    b16bppSupported,
                    b32bppSupported);
                if (m_AdapterInfo[i].NumModes)
                {
                    m_AdapterInfo[i].pModeTable = (D3DDISPLAYMODE*)
                        MemAlloc (sizeof(D3DDISPLAYMODE) * m_AdapterInfo[i].NumModes);
                    if (m_AdapterInfo[i].pModeTable != NULL)
                    {
                        D3D8BuildModeTable(
                            m_AdapterInfo[i].DeviceName,
                            m_AdapterInfo[i].pModeTable,
                            &m_AdapterInfo[i].NumModes,
                            m_AdapterInfo[i].Unknown16,
                            pHalData->hDD,
                            b16bppSupported,
                            b32bppSupported);

                        //If D3D8BuildModeTable finds it needs more space for its table,
                        //it will return 0 to indicate we should try again.
                        if (0 == m_AdapterInfo[i].NumModes)
                        {
                            MemFree(m_AdapterInfo[i].pModeTable);
                            m_AdapterInfo[i].pModeTable = NULL;
                            continue;
                        }
                    }
                    else
                    {
                        m_AdapterInfo[i].NumModes = 0;
                    }
                }
                break;
            }//while(1)

            // If this doesn't have a ddraw HAL, but guessed that it might
            // support a 32bpp mode, go see if we were right.

            if (b32bppSupported && 
                (m_AdapterInfo[i].HALCaps.D3DCaps.DevCaps == 0) &&
                (m_AdapterInfo[i].HALCaps.DisplayFormatWithoutAlpha != D3DFMT_X8R8G8B8))               
            {
                for (j = 0; j < m_AdapterInfo[i].NumModes; j++)
                {
                    if (m_AdapterInfo[i].pModeTable[j].Format == D3DFMT_X8R8G8B8)
                    {
                        break;
                    }
                }
                if (j >= m_AdapterInfo[i].NumModes)
                {
                    // This card apparently does NOT support 32bpp so remove it

                    for (j = 0; j < m_AdapterInfo[i].HALCaps.GDD8NumSupportedFormatOps; j++)
                    {
                        if ((m_AdapterInfo[i].HALCaps.pGDD8SupportedFormatOps[j].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_DISPLAYMODE) &&
                            (m_AdapterInfo[i].HALCaps.pGDD8SupportedFormatOps[j].ddpfPixelFormat.dwFourCC == D3DFMT_X8R8G8B8))
                        {
                            m_AdapterInfo[i].HALCaps.pGDD8SupportedFormatOps[j].ddpfPixelFormat.dwOperations &= ~D3DFORMAT_OP_DISPLAYMODE;
                        }
                    }
                }
            }

            InternalDirectDrawRelease(pHalData);
        }
    }

    m_hGammaCalibrator         = NULL;
    m_pGammaCalibratorProc     = NULL;
    m_bAttemptedGammaCalibrator= FALSE;
    m_bGammaCalibratorExists    = FALSE;

    // The first time through, we will also check to see if a gamma
    // calibrator is registered.  All we'll do here is read the registry
    // key and if it's non-NULL, we'll assume that one exists.
    {
        HKEY hkey;
        if (!RegOpenKey(HKEY_LOCAL_MACHINE,
                         REGSTR_PATH_DDRAW "\\" REGSTR_KEY_GAMMA_CALIBRATOR, &hkey))
        {
            DWORD       type;
            DWORD       cb;

            cb = sizeof(m_szGammaCalibrator);
            if (!RegQueryValueEx(hkey, REGSTR_VAL_GAMMA_CALIBRATOR,
                        NULL, &type, m_szGammaCalibrator, &cb))
            {
                if ((type == REG_SZ) &&
                    (m_szGammaCalibrator[0] != '\0'))
                {
                    m_bGammaCalibratorExists = TRUE;
                }
            }
            RegCloseKey(hkey);
        }
    }

    // Check to see if they disabled the D3DHAL in the registry
    {
        HKEY hKey;
        if (!RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D "\\Drivers", &hKey))
        {
            DWORD   type;
            DWORD   value;
            DWORD   cb = sizeof(value);

            if (!RegQueryValueEx(hKey, "SoftwareOnly", NULL, &type, (CONST LPBYTE)&value, &cb))
            {
                if (value)
                {
                    m_bDisableHAL = TRUE;
                }
                else
                {
                    m_bDisableHAL = FALSE;
                }
            }
            RegCloseKey(hKey);
        }
    }

    DXGASSERT(IsValid());

} // CEnum::CEnum

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::GetAdapterCount"


STDMETHODIMP_(UINT) CEnum::GetAdapterCount()
{
    API_ENTER_RET(this, UINT);

    return m_cAdapter;
} // GetAdapterCount

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::GetAdapterIdentifier"


STDMETHODIMP CEnum::GetAdapterIdentifier(
    UINT                        iAdapter,
    DWORD                       dwFlags,
    D3DADAPTER_IDENTIFIER8     *pIdentifier)
{
    API_ENTER(this);

    if (!VALID_WRITEPTR(pIdentifier, sizeof(D3DADAPTER_IDENTIFIER8)))
    {
        DPF_ERR("Invalid pIdentifier parameter specified for GetAdapterIdentifier");
        return D3DERR_INVALIDCALL;
    }

    memset(pIdentifier, 0, sizeof(*pIdentifier));

    if (dwFlags & ~VALID_D3DENUM_FLAGS)
    {
        DPF_ERR("Invalid flags specified. GetAdapterIdentifier fails.");
        return D3DERR_INVALIDCALL;
    }

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid Adapter number specified. GetAdapterIdentifier fails.");
        return D3DERR_INVALIDCALL;
    }

    // Need driver name

    GetAdapterInfo (m_AdapterInfo[iAdapter].DeviceName,
        pIdentifier,
        m_AdapterInfo[iAdapter].bIsDisplay,
        (dwFlags & D3DENUM_NO_WHQL_LEVEL) ? TRUE : FALSE,
        TRUE);

    return D3D_OK;
} // GetAdapterIdentifier

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::GetAdapterModeCount"

STDMETHODIMP_(UINT) CEnum::GetAdapterModeCount(
    UINT                iAdapter)
{
    API_ENTER_RET(this, UINT);

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. GetAdapterModeCount returns zero.");
        return 0;
    }
    return m_AdapterInfo[iAdapter].NumModes;
} // GetAdapterModeCount


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::EnumAdapterModes"

STDMETHODIMP CEnum::EnumAdapterModes(
    UINT            iAdapter,
    UINT            iMode,
    D3DDISPLAYMODE* pMode)
{
    API_ENTER(this);

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. EnumAdapterModes fails.");
        return D3DERR_INVALIDCALL;
    }

    if (iMode >= m_AdapterInfo[iAdapter].NumModes)
    {
        DPF_ERR("Invalid mode number specified. EnumAdapterModes fails.");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_WRITEPTR(pMode, sizeof(D3DDISPLAYMODE)))
    {
        DPF_ERR("Invalid pMode parameter specified for EnumAdapterModes");
        return D3DERR_INVALIDCALL;
    }

    *pMode = m_AdapterInfo[iAdapter].pModeTable[iMode];

    return D3D_OK;
} // EnumAdapterModes

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::GetAdapterMonitor"

HMONITOR CEnum::GetAdapterMonitor(UINT iAdapter)
{
    API_ENTER_RET(this, HMONITOR);

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. GetAdapterMonitor returns NULL");
        return NULL;
    }

    return GetMonitorFromDeviceName((LPSTR)m_AdapterInfo[iAdapter].DeviceName);
} // GetAdapterMonitor

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::CheckDeviceFormat"

STDMETHODIMP CEnum::CheckDeviceFormat(
    UINT            iAdapter,
    D3DDEVTYPE      DevType,
    D3DFORMAT       DisplayFormat,
    DWORD           Usage,
    D3DRESOURCETYPE RType,
    D3DFORMAT       CheckFormat)
{
    API_ENTER(this);

    D3D8_DRIVERCAPS*    pAdapterCaps;
    HRESULT             hr;

    // Check parameters
    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. CheckDeviceFormat fails");
        return D3DERR_INVALIDCALL;
    }

    // Check Device Type
    if (DevType != D3DDEVTYPE_REF &&
        DevType != D3DDEVTYPE_HAL &&
        DevType != D3DDEVTYPE_SW)
    {
        DPF_ERR("Invalid device specified to CheckDeviceFormat");
        return D3DERR_INVALIDCALL;
    }

    if ((DisplayFormat == D3DFMT_UNKNOWN) ||
        (CheckFormat == D3DFMT_UNKNOWN))
    {
        DPF(0, "D3DFMT_UNKNOWN is not a valid format.");
        return D3DERR_INVALIDCALL;
    }

    // Sanity check the input format
    if ((DisplayFormat != D3DFMT_X8R8G8B8) &&
        (DisplayFormat != D3DFMT_R5G6B5) &&
        (DisplayFormat != D3DFMT_X1R5G5B5) &&
        (DisplayFormat != D3DFMT_R8G8B8))
    {
        DPF(1, "D3D Unsupported for the adapter format passed to CheckDeviceFormat");
        return D3DERR_NOTAVAILABLE;
    }

    //We infer the texture usage from type...
    if (RType == D3DRTYPE_TEXTURE ||
        RType == D3DRTYPE_CUBETEXTURE ||
        RType == D3DRTYPE_VOLUMETEXTURE)
    {
        Usage |= D3DUSAGE_TEXTURE;
    }

    // Surface should be either render targets or Z/Stencil
    else if (RType == D3DRTYPE_SURFACE)
    {
        if (!(Usage & D3DUSAGE_DEPTHSTENCIL) &&
            !(Usage & D3DUSAGE_RENDERTARGET))
        {
            DPF_ERR("Must specify either D3DUSAGE_DEPTHSTENCIL or D3DUSAGE_RENDERTARGET for D3DRTYPE_SURFACE. CheckDeviceFormat fails.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Any attempt to query anything but an unknown Z/stencil
    // or D16 value must fail (because we explicitly don't allow apps to
    // know what the z/stencil format really is, except for D16).

    if (Usage & D3DUSAGE_DEPTHSTENCIL)
    {
        if (!CPixel::IsEnumeratableZ(CheckFormat))
        {
            DPF_ERR("Format is not in approved list for Z buffer formats. CheckDeviceFormats fails.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Parameter check for invalid usages and resource types

    if ((RType != D3DRTYPE_SURFACE) &&
        (RType != D3DRTYPE_VOLUME) &&
        (RType != D3DRTYPE_TEXTURE) &&
        (RType != D3DRTYPE_VOLUMETEXTURE) &&
        (RType != D3DRTYPE_CUBETEXTURE))
    {
        DPF_ERR("Invalid resource type specified. CheckDeviceFormat fails.");
        return D3DERR_INVALIDCALL;
    }

    if (Usage & ~(D3DUSAGE_EXTERNAL |
                  D3DUSAGE_LOCK |
                  D3DUSAGE_TEXTURE |
                  D3DUSAGE_BACKBUFFER |
                  D3DUSAGE_INTERNALBUFFER |
                  D3DUSAGE_OFFSCREENPLAIN |
                  D3DUSAGE_PRIMARYSURFACE))
    {
        DPF_ERR("Invalid usage flag specified. CheckDeviceFormat fails.");
        return D3DERR_INVALIDCALL;
    }

    hr = GetAdapterCaps(iAdapter,
                        DevType,
                        &pAdapterCaps);
    if (FAILED(hr))
    {
        return hr;
    }

    // Check if USAGE_DYNAMIC is allowed
    if ((Usage & D3DUSAGE_DYNAMIC) && (Usage & D3DUSAGE_TEXTURE))
    {
        if (!(pAdapterCaps->D3DCaps.Caps2 & D3DCAPS2_DYNAMICTEXTURES))
        {
            DPF_ERR("Driver does not support dynamic textures.");
            return D3DERR_INVALIDCALL;
        }
        if (Usage & (D3DUSAGE_RENDERTARGET | D3DUSAGE_DEPTHSTENCIL))
        {
            DPF_ERR("Dynamic textures cannot be rendertargets or depth/stencils.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Make sure that the specified display format is supported
    
    if (!IsSupportedOp (DisplayFormat, 
                        pAdapterCaps->pGDD8SupportedFormatOps, 
                        pAdapterCaps->GDD8NumSupportedFormatOps, 
                        D3DFORMAT_OP_DISPLAYMODE |D3DFORMAT_OP_3DACCELERATION))
    {
        return D3DERR_NOTAVAILABLE;
    }

    //We now need to map the API desires to the set of capabilities that we
    //allow drivers to express in their DX8 pixel format operation list.
    DWORD dwRequiredOperations=0;

    //We have three different texturing methodologies that the driver may
    //support independently
    switch(RType)
    {
    case D3DRTYPE_TEXTURE:
        dwRequiredOperations |= D3DFORMAT_OP_TEXTURE;
        break;
    case D3DRTYPE_VOLUMETEXTURE:
        dwRequiredOperations |= D3DFORMAT_OP_VOLUMETEXTURE;
        break;
    case D3DRTYPE_CUBETEXTURE:
        dwRequiredOperations |= D3DFORMAT_OP_CUBETEXTURE;
        break;
    }

    // If it's a depth/stencil, make sure it's a format that the driver understands
    CheckFormat = MapDepthStencilFormat(iAdapter,
                                        DevType, 
                                        CheckFormat);

    //Render targets may be the same format as the display, or they may
    //be different

    if (Usage & D3DUSAGE_RENDERTARGET)
    {
        if (DisplayFormat == CheckFormat)
        {
            // We have a special cap for the case when the offscreen is the
            // same format as the display
            dwRequiredOperations |= D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
        }
        else if ((CPixel::SuppressAlphaChannel(CheckFormat) != CheckFormat) &&  //offscreen has alpha
                 (CPixel::SuppressAlphaChannel(CheckFormat) == DisplayFormat))  //offscreen is same as display mod alpha
        {
            //We have a special cap for the case when the offscreen is the same
            //format as the display modulo the alpha channel
            //(such as X8R8G8B8 for the primary and A8R8G8B8 for the offscreen).
            dwRequiredOperations |= D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET;
        }
        else
        {
            dwRequiredOperations |= D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
        }
    }

    //Some hardware doesn't support Z and color buffers of differing pixel depths.
    //We only do this check on known z/stencil formats, since drivers are free
    //to spoof unknown formats (they can't be locked).

    // Now we know what we're being asked to do on this format...
    // let's run through the driver's list and see if it can do it.
    for(UINT i=0;i< pAdapterCaps->GDD8NumSupportedFormatOps; i++)
    {
        // We need a match for format, plus all the requested operation flags
        if ((CheckFormat ==
                (D3DFORMAT) pAdapterCaps->pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwFourCC) &&
            (dwRequiredOperations == (dwRequiredOperations &
                        pAdapterCaps->pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwOperations)))
        {
            return D3D_OK;
        }
    }

    // We don't spew info here; because NotAvailable is a reasonable
    // usage of the API; this doesn't reflect an app bug or an
    // anomalous circumstance where a message would be useful
    return D3DERR_NOTAVAILABLE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::CheckDeviceType"

STDMETHODIMP CEnum::CheckDeviceType(
    UINT                iAdapter,
    D3DDEVTYPE          DevType,
    D3DFORMAT           DisplayFormat,
    D3DFORMAT           BackBufferFormat,
    BOOL                bWindowed)
{
    API_ENTER(this);

    D3D8_DRIVERCAPS*    pAdapterCaps;
    HRESULT             hr;

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. CheckDeviceType fails.");
        return D3DERR_INVALIDCALL;
    }

    if (DevType != D3DDEVTYPE_REF &&
        DevType != D3DDEVTYPE_HAL &&
        DevType != D3DDEVTYPE_SW)
    {
        DPF_ERR("Invalid device specified to CheckDeviceType");
        return D3DERR_INVALIDCALL;
    }

    if ((DisplayFormat == D3DFMT_UNKNOWN) ||
        (BackBufferFormat == D3DFMT_UNKNOWN))
    {
        DPF(0, "D3DFMT_UNKNOWN is not a valid format.");
        return D3DERR_INVALIDCALL;
    }

    // Force the backbuffer format to be one of the 16 or 32bpp formats (not
    // 24bpp). We do this because DX8 shipped with a similar check in Reset, 
    // and we want to be consistent.

    if ((BackBufferFormat != D3DFMT_X1R5G5B5) &&
        (BackBufferFormat != D3DFMT_A1R5G5B5) &&
        (BackBufferFormat != D3DFMT_R5G6B5) &&
        (BackBufferFormat != D3DFMT_X8R8G8B8) &&
        (BackBufferFormat != D3DFMT_A8R8G8B8))
    {
        // We should return D3DDERR_INVALIDCALL, but we didn't ship that way for
        // DX8 and we don't want to cause regressions, so NOTAVAILABLE is safer.
        DPF(1, "Invalid backbuffer format specified");
        return D3DERR_NOTAVAILABLE;
    }

    // Sanity check the input format
    if ((DisplayFormat != D3DFMT_X8R8G8B8) &&
        (DisplayFormat != D3DFMT_R5G6B5) &&
        (DisplayFormat != D3DFMT_X1R5G5B5) &&
        (DisplayFormat != D3DFMT_R8G8B8))
    {
        DPF(1, "D3D Unsupported for the adapter format passed to CheckDeviceType");
        return D3DERR_NOTAVAILABLE;
    }

    hr = GetAdapterCaps(iAdapter,
                        DevType,
                        &pAdapterCaps);
    if (FAILED(hr))
    {
        return hr;
    }

    // Is the display mode supported?

    if (!IsSupportedOp (DisplayFormat, 
                        pAdapterCaps->pGDD8SupportedFormatOps, 
                        pAdapterCaps->GDD8NumSupportedFormatOps, 
                        D3DFORMAT_OP_DISPLAYMODE |D3DFORMAT_OP_3DACCELERATION))
    {
        return D3DERR_NOTAVAILABLE;
    }


    if (DisplayFormat != BackBufferFormat)
    {
        D3DFORMAT   AlphaFormat = D3DFMT_UNKNOWN;
        UINT        i;

        // This is allowed only if the only difference is alpha.

        switch (DisplayFormat)
        {
        case D3DFMT_X1R5G5B5:
            AlphaFormat = D3DFMT_A1R5G5B5;
            break;

        case D3DFMT_X8R8G8B8:
            AlphaFormat = D3DFMT_A8R8G8B8;
            break;
        }

        hr = D3DERR_NOTAVAILABLE;
        if (AlphaFormat == BackBufferFormat)
        {
            if (IsSupportedOp (AlphaFormat, 
                               pAdapterCaps->pGDD8SupportedFormatOps, 
                               pAdapterCaps->GDD8NumSupportedFormatOps, 
                               D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET))
            {
                hr = D3D_OK;
            }
        }
    }
    else
    {
        // For DX8, we force the backbuffer and display formats to match
        // (minus alpha).  This means that they should support a render target
        // of the same format.

        if (!IsSupportedOp (DisplayFormat, 
                            pAdapterCaps->pGDD8SupportedFormatOps, 
                            pAdapterCaps->GDD8NumSupportedFormatOps, 
                            D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET))
        {
            return D3DERR_NOTAVAILABLE;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (bWindowed &&
            !(pAdapterCaps->D3DCaps.Caps2 & DDCAPS2_CANRENDERWINDOWED))
        {
            hr = D3DERR_NOTAVAILABLE;
        }
    }

    return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::GetAdapterDisplayMode"


STDMETHODIMP CEnum::GetAdapterDisplayMode(UINT iAdapter, D3DDISPLAYMODE* pMode)
{
    API_ENTER(this);

    HANDLE      h;
    HRESULT     hr = D3D_OK;

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. GetAdapterDisplayMode fails");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_WRITEPTR(pMode, sizeof(D3DDISPLAYMODE)))
    {
        DPF_ERR("Invalid pMode parameter specified for GetAdapterDisplayMode");
        return D3DERR_INVALIDCALL;
    }

    if (m_AdapterInfo[iAdapter].bIsDisplay)
    {
        D3D8GetMode (NULL, m_AdapterInfo[iAdapter].DeviceName, pMode, m_AdapterInfo[iAdapter].Unknown16);
    }
    else
    {
        PD3D8_DEVICEDATA    pDeviceData;

        hr = InternalDirectDrawCreate(&pDeviceData,
                                      &m_AdapterInfo[iAdapter],
                                      D3DDEVTYPE_HAL,
                                      NULL,
                                      m_AdapterInfo[iAdapter].Unknown16,
                                      m_AdapterInfo[iAdapter].HALCaps.pGDD8SupportedFormatOps,
                                      m_AdapterInfo[iAdapter].HALCaps.GDD8NumSupportedFormatOps);
        if (SUCCEEDED(hr))
        {
            D3D8GetMode (pDeviceData->hDD, m_AdapterInfo[iAdapter].DeviceName, pMode, D3DFMT_UNKNOWN);
            InternalDirectDrawRelease(pDeviceData);
        }
    }

    return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::EnumDeviceMultiSampleType"


STDMETHODIMP CEnum::CheckDeviceMultiSampleType(
    UINT                iAdapter,
    D3DDEVTYPE          DevType,
    D3DFORMAT           RTFormat,
    BOOL                Windowed,
    D3DMULTISAMPLE_TYPE SampleType)
{
    API_ENTER(this);

    // Check parameters
    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. CheckDeviceMultiSampleType fails.");
        return D3DERR_INVALIDCALL;
    }

    // Check Device Type
    if (DevType != D3DDEVTYPE_REF &&
        DevType != D3DDEVTYPE_HAL &&
        DevType != D3DDEVTYPE_SW)
    {
        DPF_ERR("Invalid device specified to CheckDeviceMultiSampleType");
        return D3DERR_INVALIDCALL;
    }

    if (RTFormat == D3DFMT_UNKNOWN)
    {
        DPF_ERR("D3DFMT_UNKNOWN is not a valid format. CheckDeviceMultiSampleType fails.");
        return D3DERR_INVALIDCALL;
    }

    D3D8_DRIVERCAPS*    pAdapterCaps;
    HRESULT             hr;

    hr = GetAdapterCaps(iAdapter,
                        DevType,
                        &pAdapterCaps);
    if (FAILED(hr))
    {
        return hr;
    }

    if (SampleType == D3DMULTISAMPLE_NONE)
    {
        return D3D_OK;
    }
    else if (SampleType == 1)
    {
        DPF_ERR("Invalid sample type specified. Only enumerated values are supported. CheckDeviceMultiSampleType fails.");
        return D3DERR_INVALIDCALL;
    }
    else if (SampleType > D3DMULTISAMPLE_16_SAMPLES)
    {
        DPF_ERR("Invalid sample type specified. CheckDeviceMultiSampleType fails.");
        return D3DERR_INVALIDCALL;
    }

    // Treat Ref/SW Fullscreen the same as Windowed.
    if (DevType == D3DDEVTYPE_REF ||
        DevType == D3DDEVTYPE_SW)
    {
        Windowed = TRUE;
    }

    // If it's a depth/stencil, make sure it's a format that the driver understands
    RTFormat = MapDepthStencilFormat(iAdapter,
                                     DevType, 
                                     RTFormat);

    DDSURFACEDESC * pDX8SupportedFormatOperations =
        pAdapterCaps->pGDD8SupportedFormatOps;

    // let's run through the driver's list and see if it can do it.
    for (UINT i = 0; i < pAdapterCaps->GDD8NumSupportedFormatOps; i++)
    {
        //We need a match for format, plus all either blt or flip caps
        if (RTFormat == (D3DFORMAT) pDX8SupportedFormatOperations[i].ddpfPixelFormat.dwFourCC)
        {
            // Found the format in question... do we have the MS caps?
            WORD wMSOps = Windowed ?
                pDX8SupportedFormatOperations[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes :
                pDX8SupportedFormatOperations[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes;

            // To determine the bit to use, we map the set of sample-types [2-16] to
            // a particular (bit 1 to bit 15) of the WORD.
            DXGASSERT(SampleType > 1);
            DXGASSERT(SampleType <= 16);
            if (wMSOps & DDI_MULTISAMPLE_TYPE(SampleType))
            {
                return D3D_OK;
            }
        }
    }

    return D3DERR_NOTAVAILABLE;

} // CheckDeviceMultiSampleType


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::CheckDepthStencilMatch"

STDMETHODIMP CEnum::CheckDepthStencilMatch(UINT        iAdapter, 
                                           D3DDEVTYPE  DevType, 
                                           D3DFORMAT   AdapterFormat, 
                                           D3DFORMAT   RTFormat, 
                                           D3DFORMAT   DSFormat)
{
    API_ENTER(this);

    HRESULT hr;

    // Check parameters
    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. CheckDepthStencilMatch fails.");
        return D3DERR_INVALIDCALL;
    }

    // Check Device Type
    if (DevType != D3DDEVTYPE_REF &&
        DevType != D3DDEVTYPE_HAL &&
        DevType != D3DDEVTYPE_SW)
    {
        DPF_ERR("Invalid device specified to CheckDepthStencilMatch");
        return D3DERR_INVALIDCALL;
    }

    if ((AdapterFormat == D3DFMT_UNKNOWN) ||
        (RTFormat == D3DFMT_UNKNOWN) ||
        (DSFormat == D3DFMT_UNKNOWN))
    {
        DPF_ERR("D3DFMT_UNKNOWN is not a valid format. CheckDepthStencilMatch fails.");
        return D3DERR_INVALIDCALL;
    }

    D3D8_DRIVERCAPS *pAdapterCaps = NULL;
    hr = GetAdapterCaps(iAdapter,
                        DevType,
                        &pAdapterCaps);
    if (FAILED(hr))
    {
        return hr;
    }

    // Is the display mode supported?

    if (!IsSupportedOp (AdapterFormat, 
                        pAdapterCaps->pGDD8SupportedFormatOps, 
                        pAdapterCaps->GDD8NumSupportedFormatOps, 
                        D3DFORMAT_OP_DISPLAYMODE |D3DFORMAT_OP_3DACCELERATION))
    {
        return D3DERR_NOTAVAILABLE;
    }

    DDSURFACEDESC * pDX8SupportedFormatOperations =
        pAdapterCaps->pGDD8SupportedFormatOps;

    // Decide what we need to check
    BOOL bCanDoRT = FALSE;
    BOOL bCanDoDS = FALSE;
    BOOL bMatchNeededForDS = FALSE;

    // We only need to check for matching if the user is trying
    // to use D3DFMT_D16 or has Stencil
    if (DSFormat == D3DFMT_D16_LOCKABLE ||
        CPixel::HasStencilBits(DSFormat))
    {
        bMatchNeededForDS = TRUE;
    }

    //In DX8.1 and beyond, we also make this function check D24X8 and D32, since all known parts that have restrictions
    //also have this restriction
    if (GetAppSdkVersion() > D3D_SDK_VERSION_DX8)
    {
        switch (DSFormat)
        {
        case D3DFMT_D24X8:
        case D3DFMT_D32:
            bMatchNeededForDS = TRUE;
        }
    }

    DWORD dwRequiredZOps = D3DFORMAT_OP_ZSTENCIL;

    // If it's a depth/stencil, make sure it's a format that the driver understands
    DSFormat = MapDepthStencilFormat(iAdapter,
                                     DevType, 
                                     DSFormat);

    // let's run through the driver's list and see if this all
    // works
    for (UINT i = 0; i < pAdapterCaps->GDD8NumSupportedFormatOps; i++)
    {
        // See if it matches the RT format
        if (RTFormat == (D3DFORMAT) pDX8SupportedFormatOperations[i].ddpfPixelFormat.dwFourCC)
        {
            // Found the RT Format, can we use as a render-target?
            // we check the format that has the least constraints so that
            // we are truly checking "For all possible RTs that I can make
            // with this device, does the Z match it?" We'd like to say
            // "No." if you couldn't make the RT at all in any circumstance.
            if (D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET &
                pAdapterCaps->pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwOperations)
            {
                bCanDoRT = TRUE;
            }

        }

        // See if it matches the DS Format
        if (DSFormat == (D3DFORMAT) pDX8SupportedFormatOperations[i].ddpfPixelFormat.dwFourCC)
        {
            // Found the DS format, can we use it as DS (and potentially lockable)?
            // i.e. if ALL required bits are on in this FOL entry.
            // Again, we check the formats that have the least constraints.
            if (dwRequiredZOps == 
                (dwRequiredZOps & pAdapterCaps->pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwOperations) )
            {
                bCanDoDS = TRUE;

                if (D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH &
                    pAdapterCaps->pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwOperations)
                {
                    bMatchNeededForDS = FALSE;
                }
            }
        }
    }

    if (!bCanDoRT)
    {
        DPF_ERR("RenderTarget Format is not supported for this "
                "Adapter/DevType/AdapterFormat. This error can happen if the "
                "application has not successfully called CheckDeviceFormats on the "
                "specified Format prior to calling CheckDepthStencilMatch. The application "
                "is advised to call CheckDeviceFormats on this format first, because a "
                "success return from CheckDepthStencilMatch does not guarantee "
                "that the format is valid as a RenderTarget for all possible cases "
                "i.e. D3DRTYPE_TEXTURE or D3DRTYPE_SURFACE or D3DRTYPE_CUBETEXTURE.");
        return D3DERR_INVALIDCALL;
    }
    if (!bCanDoDS)
    {
        DPF_ERR("DepthStencil Format is not supported for this "
                "Adapter/DevType/AdapterFormat. This error can happen if the "
                "application has not successfully called CheckDeviceFormats on the "
                "specified Format prior to calling CheckDepthStencilMatch. The application "
                "is advised to call CheckDeviceFormats on this format first, because a "
                "success return from CheckDepthStencilMatch does not guarantee "
                "that the format is valid as a DepthStencil buffer for all possible cases "
                "i.e. D3DRTYPE_TEXTURE or D3DRTYPE_SURFACE or D3DRTYPE_CUBETEXTURE.");
        return D3DERR_INVALIDCALL;
    }
    if (bMatchNeededForDS)
    {
        // Check if the DS depth matches the RT depth
        if (CPixel::ComputePixelStride(RTFormat) !=
            CPixel::ComputePixelStride(DSFormat))
        {
            DPF(1, "Specified DepthStencil Format can not be used with RenderTarget Format");
            return D3DERR_NOTAVAILABLE;
        }
    }

    // Otherwise, we now know that the both the RT and DS formats
    // are valid and that they match if they need to.
    DXGASSERT(bCanDoRT && bCanDoDS);

    return S_OK;
} // CheckDepthStencilMatch


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::FillInCaps"

void CEnum::FillInCaps (D3DCAPS8              *pCaps,
                        const D3D8_DRIVERCAPS *pDriverCaps,
                        D3DDEVTYPE             Type,
                        UINT                   AdapterOrdinal) const
{
    memset(pCaps, 0, sizeof(D3DCAPS8));

    //
    // do 3D caps first so we can copy the struct and clear the (few) non-3D fields
    //
    if (pDriverCaps->dwFlags & DDIFLAG_D3DCAPS8)
    {
        // set 3D fields from caps8 struct from driver
        *pCaps = pDriverCaps->D3DCaps;

        if (Type == D3DDEVTYPE_HAL)
        {
            pCaps->DevCaps |= D3DDEVCAPS_HWRASTERIZATION;
        }

    }
    else
    {
        // ASSERT here
        DDASSERT(FALSE);
    }

    //
    // non-3D caps
    //

    pCaps->DeviceType = Type;
    pCaps->AdapterOrdinal = AdapterOrdinal;

    pCaps->Caps = pDriverCaps->D3DCaps.Caps &
        (DDCAPS_READSCANLINE |
         DDCAPS_NOHARDWARE);
    pCaps->Caps2 = pDriverCaps->D3DCaps.Caps2 &
        (DDCAPS2_NO2DDURING3DSCENE |
         DDCAPS2_PRIMARYGAMMA |
         DDCAPS2_CANRENDERWINDOWED |
         DDCAPS2_STEREO |
         DDCAPS2_DYNAMICTEXTURES |
#ifdef WINNT
         (IsWhistler() ? DDCAPS2_CANMANAGERESOURCE : 0));
#else
         DDCAPS2_CANMANAGERESOURCE);
#endif

    // Special case: gamma calibrator is loaded by the enumerator...
    if (m_bGammaCalibratorExists)
        pCaps->Caps2 |= DDCAPS2_CANCALIBRATEGAMMA;

    pCaps->Caps3 = pDriverCaps->D3DCaps.Caps3 & ~D3DCAPS3_RESERVED; //mask off the old stereo flags.

    pCaps->PresentationIntervals = D3DPRESENT_INTERVAL_ONE;
    if (pDriverCaps->D3DCaps.Caps2 & DDCAPS2_FLIPINTERVAL)
    {
        pCaps->PresentationIntervals |=
            (D3DPRESENT_INTERVAL_TWO |
             D3DPRESENT_INTERVAL_THREE |
             D3DPRESENT_INTERVAL_FOUR);
    }
    if (pDriverCaps->D3DCaps.Caps2 & DDCAPS2_FLIPNOVSYNC)
    {
        pCaps->PresentationIntervals |=
            (D3DPRESENT_INTERVAL_IMMEDIATE);
    }

    // Mask out the HW VB and IB caps
    pCaps->DevCaps &= ~(D3DDEVCAPS_HWVERTEXBUFFER | D3DDEVCAPS_HWINDEXBUFFER);

    // Clear internal caps
    pCaps->PrimitiveMiscCaps &= ~D3DPMISCCAPS_FOGINFVF;

    // Fix up the vertex fog cap.
    if (pCaps->VertexProcessingCaps & D3DVTXPCAPS_RESERVED)
    {
        pCaps->RasterCaps |= D3DPRASTERCAPS_FOGVERTEX;
        pCaps->VertexProcessingCaps &= ~D3DVTXPCAPS_RESERVED;
    }

} // FillInCaps

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::GetDeviceCaps"

STDMETHODIMP CEnum::GetDeviceCaps(
    UINT            iAdapter,
    D3DDEVTYPE      Type,
    D3DCAPS8       *pCaps)
{
    API_ENTER(this);

    BOOL                bValidRTFormat;
    D3DFORMAT           Format;
    D3D8_DRIVERCAPS*    pAdapterCaps;
    HRESULT             hr;
    DWORD               i;

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. GetDeviceCaps fails.");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_WRITEPTR(pCaps, sizeof(D3DCAPS8)))
    {
        DPF_ERR("Invalid pointer to D3DCAPS8 specified. GetDeviceCaps fails.");
        return D3DERR_INVALIDCALL;
    }

    hr = GetAdapterCaps(iAdapter,
                        Type,
                        &pAdapterCaps);
    if (FAILED(hr))
    {
        // No caps for this type of device
        memset(pCaps, 0, sizeof(D3DCAPS8));
        return hr;
    }

    // Fail this call if the driver dosn't support any accelerated modes

    for (i = 0; i < pAdapterCaps->GDD8NumSupportedFormatOps; i++)
    {
        if (pAdapterCaps->pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_3DACCELERATION)
        {
            break;
        }
    }
    if (i == pAdapterCaps->GDD8NumSupportedFormatOps)
    {
        // No caps for this type of device
        memset(pCaps, 0, sizeof(D3DCAPS8));
        return D3DERR_NOTAVAILABLE;
    }

    FillInCaps (pCaps,
                pAdapterCaps,
                Type,
                iAdapter);

    if (pCaps->MaxPointSize == 0)
    {
        pCaps->MaxPointSize = 1.0f; 
    }

    return D3D_OK;
} // GetDeviceCaps

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::LoadAndCallGammaCalibrator"

void CEnum::LoadAndCallGammaCalibrator(
        D3DGAMMARAMP *pRamp,
        UCHAR * pDeviceName)
{
    API_ENTER_VOID(this);

    if (!m_bAttemptedGammaCalibrator)
    {
        m_bAttemptedGammaCalibrator = TRUE;

        m_hGammaCalibrator = LoadLibrary((char*) m_szGammaCalibrator);
        if (m_hGammaCalibrator)
        {
            m_pGammaCalibratorProc = (LPDDGAMMACALIBRATORPROC)
                GetProcAddress(m_hGammaCalibrator, "CalibrateGammaRamp");

            if (m_pGammaCalibratorProc == NULL)
            {
                FreeLibrary((HMODULE) m_hGammaCalibrator);
                m_hGammaCalibrator = NULL;
            }
        }
    }

    if (m_pGammaCalibratorProc)
    {
        m_pGammaCalibratorProc((LPDDGAMMARAMP) pRamp, pDeviceName);
    }
} // LoadAndCallGammaCalibrator

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::RegisterSoftwareDevice"

STDMETHODIMP CEnum::RegisterSoftwareDevice(
        void*       pInitFunction)
{
    HRESULT         hr;

    API_ENTER(this);

    if (pInitFunction == NULL)
    {
        DPF_ERR("Invalid initialization function specified. RegisterSoftwareDevice fails.");
        return D3DERR_INVALIDCALL;
    }
    if (m_pSwInitFunction != NULL)
    {
        DPF_ERR("A software device is already registered.");
        return D3DERR_INVALIDCALL;
    }
    if (m_cAdapter == 0)
    {
        DPF_ERR("No display devices are available.");
        return D3DERR_NOTAVAILABLE;
    }

    hr = AddSoftwareDevice(D3DDEVTYPE_SW, &m_SwCaps[0], &m_AdapterInfo[0], pInitFunction);
    if (SUCCEEDED(hr))
    {
        m_pSwInitFunction = pInitFunction;
    }

    if (FAILED(hr))
    {
        DPF_ERR("RegisterSoftwareDevice fails");
    }

    return hr;

} // RegisterSoftwareDevice

#ifdef WINNT
#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::FocusWindow"

HWND CEnum::ExclusiveOwnerWindow()
{
    API_ENTER_RET(this, HWND);
    for (UINT iAdapter = 0; iAdapter < m_cAdapter; iAdapter++)
    {
        CBaseDevice *pDevice = m_pFullScreenDevice[iAdapter];
        if (pDevice)
        {
            return pDevice->FocusWindow();
        }
    }
    return NULL;
} // FocusWindow

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::SetFullScreenDevice"
void CEnum::SetFullScreenDevice(UINT         iAdapter,
                                CBaseDevice *pDevice)
{
    API_ENTER_VOID(this);

    if (m_pFullScreenDevice[iAdapter] != pDevice)
    { 
        DDASSERT(NULL == m_pFullScreenDevice[iAdapter] || NULL == pDevice);
        m_pFullScreenDevice[iAdapter] = pDevice;
        if (NULL == pDevice && NULL == ExclusiveOwnerWindow() && m_bHasExclusive)
        {
            m_bHasExclusive = FALSE;
            DXReleaseExclusiveModeMutex();
        }
    }
} // SetFullScreenDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::CheckExclusiveMode"
BOOL CEnum::CheckExclusiveMode(
    CBaseDevice* pDevice,
    LPBOOL pbThisDeviceOwnsExclusive, 
    BOOL bKeepMutex)
{
    DWORD   dwWaitResult;
    BOOL    bExclusiveExists=FALSE; 

    WaitForSingleObject(hCheckExclusiveModeMutex, INFINITE);

    dwWaitResult = WaitForSingleObject(hExclusiveModeMutex, 0);

    if (dwWaitResult == WAIT_OBJECT_0)
    {
        /*
         * OK, so this process now owns the exclusive mode object,
         * Have we taken the Mutex already ?
         */
        if (m_bHasExclusive)
        {
            bExclusiveExists = TRUE;
            bKeepMutex = FALSE;    
        }
        else
        {
            bExclusiveExists = FALSE;
        }
        if (pbThisDeviceOwnsExclusive && pDevice)
        {
            if (bExclusiveExists &&
                (pDevice == m_pFullScreenDevice[pDevice->AdapterIndex()]
                || NULL == m_pFullScreenDevice[pDevice->AdapterIndex()]) &&
                pDevice->FocusWindow() == ExclusiveOwnerWindow()
                )
            {
                *pbThisDeviceOwnsExclusive = TRUE;
            }
            else
            {
                *pbThisDeviceOwnsExclusive = FALSE;
            }
        }
        /*
         * Undo the temporary ref we just took on the mutex to check its state, if we're not actually
         * taking ownership. We are not taking ownership if we already have ownership. This means this routine
         * doesn't allow more than one ref on the exclusive mode mutex.
         */
        if (!bKeepMutex)
        {
            ReleaseMutex(hExclusiveModeMutex);
        }
        else
        {
            m_bHasExclusive = TRUE;
        }
    }
    else if (dwWaitResult == WAIT_TIMEOUT)
    {
        bExclusiveExists = TRUE;
        if (pbThisDeviceOwnsExclusive)
            *pbThisDeviceOwnsExclusive = FALSE;
    }
    else if (dwWaitResult == WAIT_ABANDONED)
    {
        /*
         * Some other thread lost exclusive mode. We have now picked it up.
         */
        bExclusiveExists = FALSE;
        if (pbThisDeviceOwnsExclusive)
            *pbThisDeviceOwnsExclusive = FALSE;
        /*
         * Undo the temporary ref we just took on the mutex to check its state, if we're not actually
         * taking ownership.
         */
        if (!bKeepMutex)
        {
            ReleaseMutex(hExclusiveModeMutex);
        }
        else
        {
            m_bHasExclusive = TRUE;
        }
    }

    ReleaseMutex(hCheckExclusiveModeMutex);

    return bExclusiveExists;
} // CheckExclusiveMode

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::DoneExclusiveMode"  
/*
 * DoneExclusiveMode
 */
void
CEnum::DoneExclusiveMode()
{
    UINT    iAdapter;
    for (iAdapter=0;iAdapter < m_cAdapter;iAdapter++)
    {
        CBaseDevice* pDevice = m_pFullScreenDevice[iAdapter];
        if (pDevice)
        {
            pDevice->SwapChain()->DoneExclusiveMode(TRUE);
        }
    }
    m_bHasExclusive = FALSE;

    DXReleaseExclusiveModeMutex();

} /* DoneExclusiveMode */

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::StartExclusiveMode"  
/*
 * StartExclusiveMode
 */
void 
CEnum::StartExclusiveMode()
{
    UINT    iAdapter;
    for (iAdapter=0;iAdapter<m_cAdapter;iAdapter++)
    {
        CBaseDevice* pDevice = m_pFullScreenDevice[iAdapter];
        if (pDevice)
        {
            pDevice->SwapChain()->StartExclusiveMode(TRUE);
        }
    }
} /* StartExclusiveMode */

#endif // WINNT

// End of file : enum.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\enum.hpp ===
#ifndef __ENUM_HPP__
#define __ENUM_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       enum.hpp
 *  Content:    Class for the enumerator object.
 *
 ***************************************************************************/

// HACK: this belongs elsewhere
#define DXGASSERT(x) DDASSERT(x)

#define HALFLAG_8BITHAL             0x00000001
#define HALFLAG_16BITHAL            0x00000004
#define HALFLAG_24BITHAL            0x00000010
#define HALFLAG_32BITHAL            0x00000040
class CBaseDevice;

// Base class for objects that own their own critical section
class CLockOwner
{
public:
    CLockOwner() :         
        m_bTakeCriticalSection(FALSE),
        m_punkSelf(NULL)
    {
        m_dwOwnerThread = ::GetCurrentThreadId();

#ifdef DEBUG
        // Prepare IsValid debug helper
        for (int i = 0; i < 8; i++)
        {
            // Set some magic numbers to check
            // object validity in debug
            m_dwDebugArray[i] = D3D8MagicNumber + i;
        }
        DXGASSERT(IsValid());
#endif // DEBUG 
    } // CLockOwner

    ~CLockOwner()
    {
        DXGASSERT(IsValid());
        DXGASSERT(m_bTakeCriticalSection == TRUE || 
                  m_bTakeCriticalSection == FALSE);
        if (m_bTakeCriticalSection)
        {
            ::DeleteCriticalSection(&m_CriticalSection);
        }
    } // ~CLockOwner

    void EnableCriticalSection()
    {
        DXGASSERT(m_bTakeCriticalSection == FALSE);
        m_bTakeCriticalSection = TRUE;
        ::InitializeCriticalSection(&m_CriticalSection);
    } // EnableCriticalSection()

#ifdef DEBUG
    BOOL IsValid() const
    {
        for (int i = 0; i < 8; i++)
        {
            if ((INT)m_dwDebugArray[i] != D3D8MagicNumber + i)
                return FALSE;
        }

        // If we are not locking then warn if we are 
        // not being called on the same thread
        if (!m_bTakeCriticalSection)
        {
            if (!CheckThread())
            {
                D3D_WARN(0, "Device that was created without D3DCREATE_MULTITHREADED "
                            "is being used by a thread other than the creation thread.");
            }
        }

        return TRUE;
    } // IsValid

#endif // DEBUG
    BOOL CheckThread() const
    {
        if (::GetCurrentThreadId() == m_dwOwnerThread)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    } // CheckThread


    // Critical Section Locking
    void Lock() 
    {
        if (m_bTakeCriticalSection)
        {
            DXGASSERT(m_bTakeCriticalSection == TRUE);
            ::EnterCriticalSection(&m_CriticalSection);
        }
        else
        {
            DXGASSERT(m_bTakeCriticalSection == FALSE);
        }
        DXGASSERT(IsValid());
    }; // Lock

    void Unlock() 
    {
        DXGASSERT(IsValid());
        if (m_bTakeCriticalSection)
        {
            DXGASSERT(m_bTakeCriticalSection == TRUE);
            ::LeaveCriticalSection(&m_CriticalSection);
        }
        else
        {
            DXGASSERT(m_bTakeCriticalSection == FALSE);
        }
    }; // Unlock

    // Methods to help the API_ENTER_SUBOBJECT_RELEASE case
    ULONG AddRefOwner() 
    { 
        DXGASSERT(m_punkSelf);
        return m_punkSelf->AddRef(); 
    } // AddRefOwner
    ULONG ReleaseOwner()
    { 
        DXGASSERT(m_punkSelf);
        return m_punkSelf->Release(); 
    } // ReleaseOwner

    void SetOwner(IUnknown *punkSelf)
    {
        DXGASSERT(punkSelf);
        m_punkSelf = punkSelf;
    } // SetOwner

private:
    CRITICAL_SECTION m_CriticalSection;
    BOOL             m_bTakeCriticalSection;
    DWORD            m_dwOwnerThread;
    IUnknown        *m_punkSelf;

#ifdef DEBUG
    // Set some magic numbers to check 
    // object validity in debug
    enum
    {
        D3D8MagicNumber  = 0xD3D8D3D8
    };
    DWORD            m_dwDebugArray[8];
#endif

}; // class CLockOwner


// Device Caps/Modes Enumeration Object
class CEnum : public CLockOwner, public IDirect3D8
{
public:
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    STDMETHODIMP RegisterSoftwareDevice(void * pInitFunction);
    STDMETHODIMP_(UINT) GetAdapterCount();
    STDMETHODIMP GetAdapterIdentifier(UINT Adapter,DWORD Flags,D3DADAPTER_IDENTIFIER8 *pIdentifier);
    STDMETHODIMP_(UINT) GetAdapterModeCount(UINT Adapter);
    STDMETHODIMP EnumAdapterModes(UINT iAdapter,UINT iMode,D3DDISPLAYMODE *pMode);
    STDMETHODIMP CheckDeviceType(UINT Adapter,D3DDEVTYPE CheckType, D3DFORMAT AdapterFormat, D3DFORMAT BackBufferFormat, BOOL Windowed);
    STDMETHODIMP CheckDeviceFormat(UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT DisplayFormat,DWORD Usage,D3DRESOURCETYPE RType, D3DFORMAT CheckFormat); 
    STDMETHODIMP GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE* pMode);
    STDMETHODIMP CheckDeviceMultiSampleType(UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT RenderTargetFormat,BOOL Windowed,D3DMULTISAMPLE_TYPE MultiSampleType);
    STDMETHODIMP CheckDepthStencilMatch(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat);
    STDMETHODIMP GetDeviceCaps(UINT iAdapter, D3DDEVTYPE DeviceType, D3DCAPS8 *pCaps);
    STDMETHODIMP_(HMONITOR) GetAdapterMonitor(UINT iAdapter);

    STDMETHOD(CreateDevice)(
        UINT                    iAdapter,
        D3DDEVTYPE              DeviceType,
        HWND                    hwndFocusWindow,
        DWORD                   dwBehaviorFlags,
        D3DPRESENT_PARAMETERS  *pPresentationParams,
        IDirect3DDevice8      **ppDevice);

    // Public constructor for Direct3DCreate8 to call
    CEnum(UINT AppSdkVersion);

    D3DDISPLAYMODE* GetModeTable(UINT iAdapter) const
    {
        return m_AdapterInfo[iAdapter].pModeTable;
    }

    const DWORD GetNumModes(UINT iAdapter) const
    {
        return m_AdapterInfo[iAdapter].NumModes;
    }

    const BOOL NoDDrawSupport(UINT iAdapter) const
    {
        return m_AdapterInfo[iAdapter].bNoDDrawSupport;
    }
    void FillInCaps(D3DCAPS8              *pCaps, 
                    const D3D8_DRIVERCAPS *pDriverCaps,
                    D3DDEVTYPE             Type, 
                    UINT                   AdapterOrdinal) const;

    D3DFORMAT MapDepthStencilFormat(UINT        iAdapter,
                                    D3DDEVTYPE  Type, 
                                    D3DFORMAT   Format) const;

    D3DFORMAT GetUnknown16(UINT             iAdapter)
    {
        return m_AdapterInfo[iAdapter].Unknown16;
    }

    DDSURFACEDESC* GetHalOpList(UINT    iAdapter)
    {
        return m_AdapterInfo[iAdapter].HALCaps.pGDD8SupportedFormatOps;
    }

    DWORD GetNumHalOps(UINT iAdapter)
    {
        return m_AdapterInfo[iAdapter].HALCaps.GDD8NumSupportedFormatOps;
    }

#ifdef WINNT
    void    SetFullScreenDevice(UINT         iAdapter, 
                                CBaseDevice *pDevice);

    HWND ExclusiveOwnerWindow();
    BOOL CheckExclusiveMode(
            CBaseDevice* pDevice,
            LPBOOL pbThisDeviceOwnsExclusive, 
            BOOL bKeepMutex);
    void DoneExclusiveMode();
    void StartExclusiveMode();
#endif // WINNT

    // Gamma calibrator is owned by the enumerator
    void LoadAndCallGammaCalibrator(
        D3DGAMMARAMP *pRamp, 
        UCHAR * pDeviceName);

    void GetRefCaps(UINT    iAdapter);
    void GetSwCaps(UINT     iAdapter);

    void * GetInitFunction() const
    {
        return m_pSwInitFunction;
    }
    UINT GetAppSdkVersion() {return m_AppSdkVersion;}

private:

    HRESULT GetAdapterCaps(UINT                 iAdapter,
                           D3DDEVTYPE           Type,
                           D3D8_DRIVERCAPS**    ppCaps);

    DWORD                   m_cRef;
    UINT                    m_cAdapter;
    ADAPTERINFO             m_AdapterInfo[MAX_DX8_ADAPTERS];
    CBaseDevice             *m_pFullScreenDevice[MAX_DX8_ADAPTERS];
    D3D8_DRIVERCAPS         m_REFCaps[MAX_DX8_ADAPTERS];
    D3D8_DRIVERCAPS         m_SwCaps[MAX_DX8_ADAPTERS];
    VOID*                   m_pSwInitFunction;
    BOOL                    m_bDisableHAL;
    BOOL                    m_bHasExclusive;
    HINSTANCE               m_hGammaCalibrator;
    LPDDGAMMACALIBRATORPROC m_pGammaCalibratorProc;
    BOOL                    m_bAttemptedGammaCalibrator;
    BOOL                    m_bGammaCalibratorExists;
    UCHAR                   m_szGammaCalibrator[MAX_PATH];
    UINT                    m_AppSdkVersion;

}; // class CEnum

#endif // __ENUM_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\dxgint.h ===
#ifndef __DXGINT_H__
#define __DXGINT_H__

// COM interface stuff to allow functions such as CoCreateInstance and the like

#include <unknwn.h>

#include "d3d8p.h"
#include "d3d8ddi.h"
#include "enum.hpp"

// Forward decls
class CResource;
class CResourceManager;
class CBaseTexture;
class CBaseSurface;
class CSwapChain;
class CEnum;


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice"

class CBaseDevice : public CLockOwner, public IDirect3DDevice8
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID, LPVOID FAR*); // 0
    STDMETHODIMP_(ULONG) AddRef(void); // 1
    STDMETHODIMP_(ULONG) Release(void); // 2

    // IDirectGraphicsDevice methods
    STDMETHODIMP TestCooperativeLevel(); // 3
    STDMETHODIMP_(UINT) GetAvailableTextureMem(void); // 4

    // ResourceManagerDiscardBytes is declared in d3di.hpp = 5

    STDMETHODIMP GetDirect3D(LPDIRECT3D8 *pD3D8); // 6
    STDMETHODIMP GetDeviceCaps(D3DCAPS8 *pCaps); // 7
    STDMETHODIMP GetDisplayMode(D3DDISPLAYMODE *pMode); // 8
    STDMETHODIMP GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters); // 9

    STDMETHODIMP SetCursorProperties(
        UINT xHotSpot,UINT yHotSpot,
        IDirect3DSurface8 *pCursorBitmap); // 10
    STDMETHODIMP_(void) SetCursorPosition(UINT xScreenSpace,UINT yScreenSpace,DWORD Flags); // 11
    STDMETHODIMP_(INT) ShowCursor(BOOL bShow);    // 12

    // Swap Chain stuff
    STDMETHODIMP CreateAdditionalSwapChain(
        D3DPRESENT_PARAMETERS *pPresentationParameters,
        IDirect3DSwapChain8 **pSwapChain); // 13

    STDMETHODIMP Reset( D3DPRESENT_PARAMETERS *pPresentationParameters); // 14

    STDMETHODIMP Present(   CONST RECT *pSourceRect,
                            CONST RECT *pDestRect,
                            HWND hTargetWindow,
                            CONST RGNDATA *pDestinationRegion); // 15
    STDMETHODIMP GetBackBuffer(UINT iBackBuffer, D3DBACKBUFFER_TYPE Type, IDirect3DSurface8 **ppBackBuffer); // 16
    STDMETHODIMP GetRasterStatus(D3DRASTER_STATUS *pRasterStatus); // 17

    STDMETHODIMP_(void) SetGammaRamp(DWORD dwFlags, CONST D3DGAMMARAMP *pRamp); // 18
    STDMETHODIMP_(void) GetGammaRamp(D3DGAMMARAMP *pRamp); // 19

    STDMETHODIMP CreateTexture(UINT cpWidth,UINT cpHeight,UINT cLevels,DWORD dwUsage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DTexture8 **ppTexture); // 20
    STDMETHODIMP CreateVolumeTexture(UINT cpWidth,UINT cpHeight,UINT cpDepth,UINT cLevels,DWORD dwUsage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DVolumeTexture8 **ppVolumeTexture); // 21
    STDMETHODIMP CreateCubeTexture(UINT cpEdge,UINT cLevels,DWORD dwUsage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DCubeTexture8 **ppCubeTexture); // 22
    STDMETHODIMP CreateVertexBuffer(UINT cbLength,DWORD Usage,DWORD dwFVF,D3DPOOL Pool,IDirect3DVertexBuffer8 **ppVertexBuffer); // 23
    STDMETHODIMP CreateIndexBuffer(UINT cbLength,DWORD dwUsage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DIndexBuffer8 **ppIndexBuffer); // 24

    STDMETHODIMP CreateRenderTarget(UINT cpWidth,UINT cpHeight,D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, IDirect3DSurface8 **ppSurface); // 25
    STDMETHODIMP CreateDepthStencilSurface(UINT cpWidth,UINT cpHeight,D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, IDirect3DSurface8 **ppSurface); // 26
    STDMETHODIMP CreateImageSurface(UINT cpWidth,UINT cpHeight,D3DFORMAT Format, IDirect3DSurface8 **ppSurface); // 27

    STDMETHODIMP CopyRects(IDirect3DSurface8 *pSourceSurface, CONST RECT *pSourceRectsArray,UINT cRects,IDirect3DSurface8 *pDestinationSurface, CONST POINT *pDestPointsArray); // 28
    STDMETHODIMP UpdateTexture(IDirect3DBaseTexture8 *pSourceTexture,IDirect3DBaseTexture8 *pDestinationTexture); // 29
    STDMETHODIMP GetFrontBuffer(IDirect3DSurface8 *pDestSurface); // 30

    // Constructor/deconstructor
    CBaseDevice();
    virtual ~CBaseDevice();
    HRESULT Init(
        PD3D8_DEVICEDATA        pDeviceData,
        D3DDEVTYPE              DeviceType,
        HWND                    hwndFocusWindow,
        DWORD                   dwBehaviorFlags,
        D3DPRESENT_PARAMETERS  *pPresentationParameters,
        UINT                    AdapterIndex,
        CEnum*                  Parent);

    PD3D8_CALLBACKS GetHalCallbacks(void)
    {
        return &m_DeviceData.Callbacks;
    } // GetHalCallbacks

    // Get a handle for the device; used for kernel calls
    HANDLE GetHandle(void) const
    {
        return m_DeviceData.hDD;
    } // GetHandle

    BOOL CanTexBlt(void) const
    {
        if (GetDeviceType() == D3DDEVTYPE_SW ||
            GetDeviceType() == D3DDEVTYPE_REF)
        {
            // TexBlt is not supported for software
            // devices
            return FALSE;
        }
        // DX7 and above
        return (m_ddiType >= D3DDDITYPE_DX7);
    } // CanTexBlt

    BOOL CanBufBlt(void) const
    {
        if (GetDeviceType() == D3DDEVTYPE_SW ||
            GetDeviceType() == D3DDEVTYPE_REF)
        {
            // BufBlt is not supported for software
            // devices
            return FALSE;
        }
        // DX8 and above
        return (m_ddiType >= D3DDDITYPE_DX8);
    } // CanBufBlt

    BOOL CanDriverManageResource(void) const
    {
        if (m_dwBehaviorFlags & D3DCREATE_DISABLE_DRIVER_MANAGEMENT)
        {
            return FALSE;
        }
        else if (GetD3DCaps()->Caps2 & DDCAPS2_CANMANAGERESOURCE)
        {
            DDASSERT(m_ddiType >= D3DDDITYPE_DX8);
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    } // CanDriverManage

    D3DDDITYPE GetDDIType(void) const
    {
        return m_ddiType;
    } // GetDDIType

    const D3D8_DRIVERCAPS* GetCoreCaps() const
    {
        return &m_DeviceData.DriverData;
    } // GetCoreCaps

    const D3DCAPS8* GetD3DCaps() const
    {
        return &m_DeviceData.DriverData.D3DCaps;
    } // GetD3DCaps

    D3DDISPLAYMODE* GetModeTable() const
    {
        return m_pD3DClass->GetModeTable(m_AdapterIndex);
    } // GetModeTable

    VOID* GetInitFunction() const
    {
        if (m_DeviceType == D3DDEVTYPE_SW)
        {
            return m_pD3DClass->GetInitFunction();
        }
        return NULL;
    } // GetModeTable

    const DWORD GetNumModes() const
    {
        return m_pD3DClass->GetNumModes(m_AdapterIndex);
    } // GetNumModes

    D3D8_DEVICEDATA* GetDeviceData()
    {
        return &m_DeviceData;
    } // GetDeviceData

    CBaseSurface *ZBuffer() const
    {
        return m_pZBuffer;
    } // ZBuffer

    CBaseSurface *RenderTarget() const
    {
        return m_pRenderTarget;
    } // RenderTarget

    void UpdateRenderTarget(CBaseSurface *pRenderTarget, CBaseSurface *pZStencil);

    CResourceManager* ResourceManager() const
    {
        // return the ResourceManager
        return m_pResourceManager;
    } // ResourceManager

    CEnum * Enum() const
    {
        // return the enumerator that created us
        return m_pD3DClass;
    } // Enum

    // Internal version of CopyRects (no parameter validation)
    HRESULT InternalCopyRects(CBaseSurface *pSourceSurface,
                              CONST RECT   *pSourceRectsArray,
                              UINT          cRects,
                              CBaseSurface *pDestinationSurface,
                              CONST POINT  *pDestPointsArray); 

    // Internal function for format validation
    HRESULT CheckDeviceFormat(DWORD             Usage,
                              D3DRESOURCETYPE   RType,
                              D3DFORMAT         CheckFormat)
    {
        return Enum()->CheckDeviceFormat(AdapterIndex(),
                                         GetDeviceType(),
                                         DisplayFormat(),
                                         Usage,
                                         RType,
                                         CheckFormat);
    } // CheckDeviceFormats


    HRESULT CheckDepthStencilMatch(D3DFORMAT RTFormat, D3DFORMAT DSFormat)
    {
        return Enum()->CheckDepthStencilMatch(AdapterIndex(),
                                              GetDeviceType(),
                                              DisplayFormat(),
                                              RTFormat,
                                              DSFormat);
    } // CheckDepthStencilMatch

    // Internal function for multi-sample validation
    HRESULT CheckDeviceMultiSampleType(D3DFORMAT           RenderTargetFormat,
                                       BOOL                Windowed,
                                       D3DMULTISAMPLE_TYPE MultiSampleType)
    {
        return Enum()->CheckDeviceMultiSampleType(
            AdapterIndex(),
            GetDeviceType(),
            RenderTargetFormat,
            Windowed,
            MultiSampleType);
    } // CheckDeviceMultiSampleType

    D3DFORMAT MapDepthStencilFormat(D3DFORMAT Format) const
    {
        return Enum()->MapDepthStencilFormat(
                AdapterIndex(),
                GetDeviceType(),
                Format);
    } // MapDepthStencilFormat

    UINT DisplayWidth() const { return m_DeviceData.DriverData.DisplayWidth; }
    UINT DisplayHeight() const { return m_DeviceData.DriverData.DisplayHeight; }
    D3DFORMAT DisplayFormat() const { return m_DeviceData.DriverData.DisplayFormatWithoutAlpha; }
    UINT DisplayRate() const { return m_DeviceData.DriverData.DisplayFrequency; }
    D3DDEVTYPE GetDeviceType() const
    {
        // Check this value is correct; pure types shouldn't happen
        // and other values are wrong. Users of this method
        // assume that these three are the only possible values.
        DDASSERT(m_DeviceType == D3DDEVTYPE_REF ||
                 m_DeviceType == D3DDEVTYPE_SW ||
                 m_DeviceType == D3DDEVTYPE_HAL);

        return m_DeviceType;
    }
    HWND FocusWindow()
    {
        return m_hwndFocusWindow;
    } // FocusWindow

    CSwapChain* SwapChain() const
    {
        DDASSERT(m_pSwapChain);
        return m_pSwapChain;
    }
    D3DDISPLAYMODE    DesktopMode() const
    {
        return  m_DesktopMode;
    }
    UINT AdapterIndex() const
    {
        return  m_AdapterIndex;
    }
    DWORD BehaviorFlags() const
    {
        return m_dwBehaviorFlags;
    }
    void ResetZStencil()
    {
        m_pAutoZStencil = NULL;
    }
    CBaseSurface* GetZStencil() const
    {
        return m_pAutoZStencil;
    }

    void EnableVidmemVBs()
    {
        m_DeviceData.DriverData.D3DCaps.DevCaps |= (D3DDEVCAPS_HWVERTEXBUFFER);
    }

    void DisableVidmemVBs()
    {
        m_DeviceData.DriverData.D3DCaps.DevCaps &= ~(D3DDEVCAPS_HWVERTEXBUFFER);
    }

    BOOL DriverSupportsVidmemVBs() const
    {
        return (GetD3DCaps()->DevCaps & D3DDEVCAPS_HWVERTEXBUFFER);
    }

    BOOL DriverSupportsVidmemIBs() const
    {
        return (GetD3DCaps()->DevCaps & D3DDEVCAPS_HWINDEXBUFFER);
    }

    BOOL VBFailOversDisabled() const
    {
        return m_bVBFailOversDisabled;
    }

    CResource* GetResourceList() const
    {
        return m_pResourceList;
    }

    void SetResourceList(CResource *pRes)
    {
        m_pResourceList = pRes;
    }

#ifdef DEBUG
    // debugging helper
    UINT RefCount() const
    {
        return m_cRef;
    } // RefCount
#endif // DEBUG


protected:
    // This is the section for access to things that
    // the derived versions of the base device need.

    D3DDDITYPE                  m_ddiType;


private:
    // We mark "main" as a friend so that gensym can
    // access everything it wants to
    friend int main(void);

    DWORD                        m_cRef;
    BOOL                         m_fullscreen; // should be a flag?
    BOOL                         m_bVBFailOversDisabled;

    CResource                   *m_pResourceList;
    CResourceManager            *m_pResourceManager;

    D3D8_DEVICEDATA              m_DeviceData;
    HWND                         m_hwndFocusWindow;
    DWORD                        m_dwBehaviorFlags;
    DWORD                        m_dwOriginalBehaviorFlags;


    CBaseSurface                *m_pZBuffer;
    CSwapChain                  *m_pSwapChain;
    CBaseSurface                *m_pRenderTarget;
    CBaseSurface                *m_pAutoZStencil;

    D3DDEVTYPE                  m_DeviceType;
    UINT                        m_AdapterIndex;
    CEnum                       *m_pD3DClass;

    D3DDISPLAYMODE              m_DesktopMode;
};


#endif // define __DXGINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\dxcursor.cpp ===
/*========================================================================== *
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddcursor.c
 *  Content:    DirectDraw cursor support
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   17-Jan-00  kanqiu  initial implementation(Kan Qiu)
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dxcursor.hpp"
#include "swapchan.hpp"

#define FORMAT_8888_1555(val)  \
    ( ((val & 0x80000000) >> 16) | ((val & 0xF80000) >> 9) | ((val & 0xF800) >> 6) | ((val & 0xF8) >> 3))
#define FORMAT_8888_555(val)  \
    ( ((val & 0xF80000) >> 9) | ((val & 0xF800) >> 6) | ((val & 0xF8) >> 3))
#define FORMAT_8888_565(val)  \
    ( ((val & 0xF80000) >> 8) | ((val & 0xFC00) >> 5) | ((val & 0xF8) >> 3))
#define ISOPAQUE(val)   \
    ( 0xFF000000 == (val & 0xFF000000))


#undef DPF_MODNAME
#define DPF_MODNAME "CCursor::CCursor"

//=============================================================================
// CCursor::CCursor
//
//=============================================================================

CCursor::CCursor(CBaseDevice *pDevice) 
{
    m_pDevice = pDevice;
    m_dwCursorFlags = 0;
    m_hCursorDdb = NULL;
    m_hFrontSave = NULL;  
    m_hBackSave = NULL;
    m_Width = m_Height = 0;
    m_hOsCursor = NULL;
    m_hHWCursor = NULL;
    m_SavedMouseTrails = 0;
    m_xCursor = pDevice->SwapChain()->Width()/2;
    m_yCursor = pDevice->SwapChain()->Height()/2;
    m_MonitorOrigin.x = m_MonitorOrigin.y = 0;
    if ( (!pDevice->SwapChain()->Windowed())
        && (1 < pDevice->Enum()->GetAdapterCount()))
    {
        HMONITOR hMonitor = pDevice->Enum()->
            GetAdapterMonitor(pDevice->AdapterIndex());
        if (hMonitor)
        {
            MONITORINFO MonInfo;
            MonInfo.rcMonitor.top = MonInfo.rcMonitor.left = 0;
            MonInfo.cbSize = sizeof(MONITORINFO);
            InternalGetMonitorInfo(hMonitor, &MonInfo);
            m_MonitorOrigin.x = MonInfo.rcMonitor.left;
            m_MonitorOrigin.y = MonInfo.rcMonitor.top;
        }
    }

} // CCursor::CCursor

#undef DPF_MODNAME
#define DPF_MODNAME "CCursor::~CCursor"

//=============================================================================
// CCursor::~CCursor
//
//=============================================================================

CCursor::~CCursor()
{
    Destroy();
    if (m_hOsCursor)
    {
        SetCursor(m_hOsCursor);
        m_hOsCursor = NULL;
    }
}

void
CCursor::Destroy()
{
    D3D8_DESTROYSURFACEDATA DestroySurfData;
    DestroySurfData.hDD = m_pDevice->GetHandle();
    if (m_hCursorDdb)
    {
        DestroySurfData.hSurface = m_hCursorDdb;
        m_pDevice->GetHalCallbacks()->DestroySurface(&DestroySurfData);
        m_hCursorDdb = NULL;
    }
    if (m_hFrontSave)
    {
        DestroySurfData.hSurface = m_hFrontSave;
        m_pDevice->GetHalCallbacks()->DestroySurface(&DestroySurfData);
        m_hFrontSave = NULL;
    }
    if (m_hBackSave)
    {
        DestroySurfData.hSurface = m_hBackSave;
        m_pDevice->GetHalCallbacks()->DestroySurface(&DestroySurfData);
        m_hBackSave = NULL;
    }
    if ( NULL != m_hHWCursor )
    {
        if ( GetCursor() == m_hHWCursor )
            SetCursor(NULL); // turn it off before destroy
        if (!DestroyIcon((HICON)m_hHWCursor))
        {
            DPF_ERR("Destroy Failed to Destroy Old hwcursor Icon");
        }
        m_hHWCursor = NULL;
        if (m_SavedMouseTrails > 1)
        {
            SystemParametersInfo(SPI_SETMOUSETRAILS,m_SavedMouseTrails,0,0);        
            m_SavedMouseTrails = 0;
        }
    }
}

void
CCursor::UpdateRects()
{
    if (DDRAWI_CURSORISON & m_dwCursorFlags)
    {
        if (DDRAWI_CURSORSAVERECT & m_dwCursorFlags) 
        {
            // SetPosition didn't update RECTs, but next Flip will
            m_dwCursorFlags &= ~DDRAWI_CURSORSAVERECT;
            m_dwCursorFlags |= DDRAWI_CURSORRECTSAVED;
            m_CursorRectSave = m_CursorRect;
            m_BufferRectSave = m_BufferRect;
        }
        if (m_xCursor < m_xCursorHotSpot)
        {
            m_CursorRect.left = m_xCursorHotSpot - m_xCursor;
            m_CursorRect.right = m_Width;
            m_BufferRect.left = 0;
        }
        else
        {
            m_CursorRect.left = 0;
            m_BufferRect.left = m_xCursor - m_xCursorHotSpot;
            if (m_xCursor + m_Width > 
                m_pDevice->DisplayWidth() + m_xCursorHotSpot )
            {
                m_CursorRect.right = m_pDevice->DisplayWidth() + m_xCursorHotSpot
                    - m_xCursor;
            }
            else
            {
                m_CursorRect.right = m_Width;
            }
        }
        m_BufferRect.right = m_BufferRect.left + m_CursorRect.right - m_CursorRect.left;
        if (m_yCursor < m_yCursorHotSpot)
        {
            m_CursorRect.top = m_yCursorHotSpot - m_yCursor;
            m_CursorRect.bottom = m_Height;
            m_BufferRect.top = 0;
        }
        else
        {
            m_CursorRect.top = 0;
            m_BufferRect.top = m_yCursor - m_yCursorHotSpot;
            if (m_yCursor + m_Height > 
                m_pDevice->DisplayHeight() + m_yCursorHotSpot )
            {
                m_CursorRect.bottom = m_pDevice->DisplayHeight() + m_yCursorHotSpot
                    - m_yCursor;
            }
            else
            {
                m_CursorRect.bottom = m_Height;
            }
        }
        m_BufferRect.bottom = m_BufferRect.top + m_CursorRect.bottom - m_CursorRect.top;
    }
}

/*
 * Hide
 *
 * Hide the cursor. Restore buffer with saved area
 */
#undef DPF_MODNAME
#define DPF_MODNAME     "CCursor::Hide"
HRESULT 
CCursor::Hide(HANDLE hSurf)
{
    if (!(DDRAWI_CURSORISON & m_dwCursorFlags))
    {
        return S_OK;
    }
    D3D8_BLTDATA BltData;
    ZeroMemory(&BltData, sizeof BltData);

    if (DDRAWI_CURSORRECTSAVED & m_dwCursorFlags) 
    {
        // this Hide Must have been caused by flip
        m_dwCursorFlags &= ~DDRAWI_CURSORRECTSAVED;
        BltData.rSrc.left = m_CursorRectSave.left;
        BltData.rSrc.right = m_CursorRectSave.right;
        BltData.rSrc.top = m_CursorRectSave.top;
        BltData.rSrc.bottom = m_CursorRectSave.bottom;
        BltData.rDest.left = m_BufferRectSave.left;
        BltData.rDest.top = m_BufferRectSave.top;
        BltData.rDest.right = m_BufferRectSave.right;
        BltData.rDest.bottom = m_BufferRectSave.bottom;
    }
    else
    {
        BltData.rSrc.left = m_CursorRect.left;
        BltData.rSrc.right = m_CursorRect.right;
        BltData.rSrc.top = m_CursorRect.top;
        BltData.rSrc.bottom = m_CursorRect.bottom;
        BltData.rDest.left = m_BufferRect.left;
        BltData.rDest.top = m_BufferRect.top;
        BltData.rDest.right = m_BufferRect.right;
        BltData.rDest.bottom = m_BufferRect.bottom;
    }
    BltData.hSrcSurface = m_hFrontSave;
    BltData.hDestSurface = hSurf;
    BltData.hDD = m_pDevice->GetHandle();
    BltData.dwFlags = DDBLT_ROP | DDBLT_WAIT;
    BltData.bltFX.dwROP = SRCCOPY;
    BltData.ddRVal = E_FAIL;
    m_pDevice->GetHalCallbacks()->Blt(&BltData);
    return  BltData.ddRVal;
}

/*
 * ShowCursor
 *
 * Show the cursor. save exclusion area and blt cursor to it
 */
#undef DPF_MODNAME
#define DPF_MODNAME     "CCursor::Show"
HRESULT 
CCursor::Show(HANDLE hSurf)
{
    if (!(DDRAWI_CURSORISON & m_dwCursorFlags))
    {
        return S_OK;
    }
    D3D8_BLTDATA BltData;
    ZeroMemory(&BltData, sizeof BltData);
    UpdateRects();    
    BltData.rSrc.left = m_BufferRect.left;
    BltData.rSrc.right = m_BufferRect.right;
    BltData.rSrc.top = m_BufferRect.top;
    BltData.rSrc.bottom = m_BufferRect.bottom;
    BltData.hSrcSurface = hSurf;
    BltData.rDest.left = m_CursorRect.left;
    BltData.rDest.top = m_CursorRect.top;
    BltData.rDest.right = m_CursorRect.right;
    BltData.rDest.bottom = m_CursorRect.bottom;
    BltData.hDestSurface = m_hFrontSave;
    BltData.hDD = m_pDevice->GetHandle();
    BltData.dwFlags = DDBLT_ROP | DDBLT_WAIT;
    BltData.bltFX.dwROP = SRCCOPY;
    BltData.ddRVal = E_FAIL;
    m_pDevice->GetHalCallbacks()->Blt(&BltData);
    if (SUCCEEDED(BltData.ddRVal))
    {
        BltData.rSrc.left = m_CursorRect.left;
        BltData.rSrc.right = m_CursorRect.right;
        BltData.rSrc.top = m_CursorRect.top;
        BltData.rSrc.bottom = m_CursorRect.bottom;
        BltData.hSrcSurface = m_hCursorDdb;
        BltData.rDest.left = m_BufferRect.left;
        BltData.rDest.top = m_BufferRect.top;
        BltData.rDest.right = m_BufferRect.right;
        BltData.rDest.bottom = m_BufferRect.bottom;
        BltData.hDestSurface = hSurf;
        BltData.hDD = m_pDevice->GetHandle();
        BltData.dwFlags = DDBLT_ROP | DDBLT_WAIT | DDBLT_KEYSRCOVERRIDE;
         //always use black as key
        BltData.bltFX.ddckSrcColorkey.dwColorSpaceLowValue =
        BltData.bltFX.ddckSrcColorkey.dwColorSpaceHighValue = 0; 
        BltData.bltFX.dwROP = SRCCOPY;
        BltData.ddRVal = E_FAIL;
        m_pDevice->GetHalCallbacks()->Blt(&BltData);
    }
    return  BltData.ddRVal;
}

void
CCursor::Flip()
{
    if (DDRAWI_CURSORISON & m_dwCursorFlags)
    {
        HANDLE  htemp = m_hFrontSave;
        m_hFrontSave = m_hBackSave;
        m_hBackSave = htemp;
    }
}

HCURSOR   CreateColorCursor(
    UINT xHotSpot,
    UINT yHotSpot,
    UINT BitmapWidth,
    UINT BitmapHeight,
    CBaseSurface *pCursorBitmap)
{
    UINT Width = (UINT)GetSystemMetrics(SM_CXCURSOR);
    UINT Height = (UINT)GetSystemMetrics(SM_CYCURSOR);
    ICONINFO    iconinfo;
    D3DLOCKED_RECT lock;
    DWORD   *pSourceBitmap;
    DWORD   *pColorMask;
    BYTE    *pMonoMask;
    HCURSOR     hCursor = NULL;
    HDC     hdcMem      = NULL;
    HBITMAP hbmANDMask  = NULL;
    HWND    hwndDesktop = NULL;
    HBITMAP hbmXORBitmap;
    HDC     hdcScreen;

    static char  bmi[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    LPBITMAPINFO pbmi = (LPBITMAPINFO)bmi;
    iconinfo.fIcon = FALSE;
    iconinfo.xHotspot = xHotSpot*Width/BitmapWidth;
    iconinfo.yHotspot = yHotSpot*Height/BitmapHeight;

    pMonoMask = new BYTE [Width * Height / 8];
    if ( NULL == pMonoMask )
    {
        DPF_ERR("Out of Memory. Unable to create Cursor");
        return NULL;
    }
    ZeroMemory(pMonoMask, (Width * Height / 8));
    pColorMask = new DWORD [Width * Height];
    if ( NULL == pColorMask )
    {
        DPF_ERR("Out of Memory. Unable to CreateCursor");
        delete[] pMonoMask;
        return NULL;
    }
    if (FAILED(pCursorBitmap->LockRect(&lock, NULL, 0)))
    {
        DPF_ERR("Failed to lock pCursorBitmap, it must be lockable. CreateCursor failed");
        delete[] pMonoMask;
        delete[] pColorMask;
        return NULL;
    }
    pSourceBitmap = (DWORD*)lock.pBits;
    for (int j = (int)(Height - 1); j >= 0 ; j--)
    {
        for (UINT i = 0; i < Width; ++i)
        {
            DWORD   pixel= pSourceBitmap[i*BitmapWidth/Width];
            if (ISOPAQUE(pixel))
            {
                pColorMask[j*Width+i] = pixel;
            }
            else
            {
                pMonoMask[(j*Width+i)/8] 
                    |= 1 << (7-((j*Width+i) % 8));    
                pColorMask[j*Width+i] = 0;
            }
        }
        pSourceBitmap += lock.Pitch* BitmapHeight/4/Height;
    }
    if (FAILED(pCursorBitmap->UnlockRect()))
    {
        DPF_ERR("Driver surface failed to unlock pCursorBitmap");
    }
    /************************************************************************/
    /* Initialize the bitmap header for the XOR data.                       */
    /************************************************************************/
    pbmi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth         = Width;
    pbmi->bmiHeader.biHeight        = Height;
    pbmi->bmiHeader.biPlanes        = 1;
    pbmi->bmiHeader.biBitCount      = 32;
    pbmi->bmiHeader.biCompression   = BI_RGB;
    pbmi->bmiHeader.biSizeImage     = Width*Height*sizeof(DWORD);
    pbmi->bmiHeader.biXPelsPerMeter = 0;
    pbmi->bmiHeader.biYPelsPerMeter = 0;
    pbmi->bmiHeader.biClrUsed       = 0;
    pbmi->bmiHeader.biClrImportant  = 0;

    hwndDesktop = GetDesktopWindow();
    hdcScreen = GetWindowDC(hwndDesktop);

    if (0 == hdcScreen)
    { 
        // Error getting the screen DC.
        DPF_ERR("Failed to create screen DC");
        delete[] pMonoMask;
        delete[] pColorMask;
        return  NULL;
    }

    /********************************************************************/
    /* Create XOR Bitmap                                                */
    /********************************************************************/
    iconinfo.hbmColor = CreateDIBitmap(hdcScreen,
                      (LPBITMAPINFOHEADER)pbmi,
                      CBM_INIT,
                      pColorMask,
                      pbmi,
                      DIB_RGB_COLORS);
    delete[] pColorMask;

    /********************************************************************/
    /* Release the DC.                                                  */
    /********************************************************************/
    ReleaseDC(hwndDesktop, hdcScreen);

    if ( NULL == iconinfo.hbmColor)
    {
        delete[] pMonoMask;
        return NULL;
    }
    /************************************************************************/
    /* For the mono bitmap, use CreateCompatibleDC - this makes no          */
    /* difference on NT, but allows this code to work on Windows 95.        */
    /************************************************************************/
    hdcMem = CreateCompatibleDC(NULL);
    if ( NULL == hdcMem)
    {
        DPF_ERR("Failed to create DC");
        delete[] pMonoMask;
        DeleteObject( iconinfo.hbmColor );
        return NULL;
    }

    /************************************************************************/
    /* Create AND Mask (1bpp) - set the RGB colors to black and white.      */
    /************************************************************************/
    pbmi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth         = Width;
    pbmi->bmiHeader.biHeight        = Height;
    pbmi->bmiHeader.biPlanes        = 1;
    pbmi->bmiHeader.biBitCount      = 1;
    pbmi->bmiHeader.biCompression   = BI_RGB;
    pbmi->bmiHeader.biSizeImage     = Width*Height/8;
    pbmi->bmiHeader.biXPelsPerMeter = 0;
    pbmi->bmiHeader.biYPelsPerMeter = 0;
    pbmi->bmiHeader.biClrUsed       = 2;
    pbmi->bmiHeader.biClrImportant  = 0;

    pbmi->bmiColors[0].rgbRed      = 0x00;
    pbmi->bmiColors[0].rgbGreen    = 0x00;
    pbmi->bmiColors[0].rgbBlue     = 0x00;
    pbmi->bmiColors[0].rgbReserved = 0x00;

    pbmi->bmiColors[1].rgbRed      = 0xFF;
    pbmi->bmiColors[1].rgbGreen    = 0xFF;
    pbmi->bmiColors[1].rgbBlue     = 0xFF;
    pbmi->bmiColors[1].rgbReserved = 0x00;

    iconinfo.hbmMask = CreateDIBitmap(hdcMem,
                                (LPBITMAPINFOHEADER)pbmi,
                                CBM_INIT,
                                pMonoMask,
                                pbmi,
                                DIB_RGB_COLORS);
    /************************************************************************/
    /* Free the DC.                                                         */
    /************************************************************************/
    DeleteDC(hdcMem);
    delete[] pMonoMask;
    if ( NULL == iconinfo.hbmMask)
    {
        DPF_ERR("Failed to create AND mask");
        DeleteObject( iconinfo.hbmColor );
        return NULL;
    }
    hCursor = (HCURSOR) CreateIconIndirect(&iconinfo);
    DeleteObject( iconinfo.hbmMask );
    DeleteObject( iconinfo.hbmColor );
    return hCursor;
}
HRESULT
CCursor::CursorInit(
    UINT xHotSpot,
    UINT yHotSpot,
    CBaseSurface *pCursorBitmap)
{
    HRESULT hr=S_OK;
    D3DSURFACE_DESC desc;
    HCURSOR oscursor;
    ICONINFO    cursorinfo;
    BITMAP  bmColor;
    BITMAP  bmMask;
    HDC hdcBitmap;
    HDC hdcCursorDdb;
    ZeroMemory(&cursorinfo, sizeof cursorinfo);
    m_dwCursorFlags &= ~DDRAWI_CURSORINIT;
    if (NULL != pCursorBitmap)
    {
        hr = pCursorBitmap->GetDesc(&desc);
        DXGASSERT(SUCCEEDED(hr));

        if (desc.Format != D3DFMT_A8R8G8B8)
        {
            DPF_ERR("Invalid Format for pCursorBitmap. Must be D3DFMT_A8R8G8B8");
            return D3DERR_INVALIDCALL;
        }

        if ((desc.Width -1) & desc.Width)
        {
            DPF_ERR("Failed to Initialize Cursor: Width must be a 2^n");
            return D3DERR_INVALIDCALL;
        }

        if ((desc.Height -1) & desc.Height)
        {
            DPF_ERR("Failed to Initialize Cursor: Height must be a 2^n");
            return D3DERR_INVALIDCALL;
        }

        if (desc.Width > m_pDevice->DisplayWidth())
        {
            DPF_ERR("Cursor Width must be smaller than DisplayWidth");
            return D3DERR_INVALIDCALL;
        }

        if (desc.Height > m_pDevice->DisplayHeight())
        {
            DPF_ERR("Cursor Height must be smaller than DisplayHeight");
            return D3DERR_INVALIDCALL;
        }
        if (desc.Width <= xHotSpot)
        {
            DPF_ERR("Cursor xHotSpot must be smaller than its Width");
            return D3DERR_INVALIDCALL;
        }
        if (desc.Height <= yHotSpot)
        {
            DPF_ERR("Cursor yHotSpot must be smaller than its Height");
            return D3DERR_INVALIDCALL;
        }
    }
    else if ( NULL == m_hCursorDdb)
    {
        oscursor = SetCursor(NULL);
        if (oscursor)
            m_hOsCursor = oscursor;
        else if (m_hOsCursor)
            oscursor = m_hOsCursor;

        desc.Width = GetSystemMetrics(SM_CXCURSOR);
        desc.Height = GetSystemMetrics(SM_CYCURSOR);    //default
        
        if (oscursor && GetIconInfo(oscursor,&cursorinfo))
        {
            GetObject( cursorinfo.hbmMask, sizeof(BITMAP), &bmMask );
            desc.Width = bmMask.bmWidth;
            if (cursorinfo.hbmColor)
            {
                GetObject( cursorinfo.hbmColor, sizeof(BITMAP), &bmColor );
                desc.Height = bmColor.bmHeight;  //color cursor has only AND mask
            }
            else
            {
                desc.Height = bmMask.bmHeight/2;
            }            
        }
    }
    else
        return  S_OK;
    
    const D3D8_DRIVERCAPS* pDriverCaps=m_pDevice->GetCoreCaps();
    if ((NULL != pCursorBitmap)
        && (
            (
                 // either driver says it can support
                (
                  (D3DCURSORCAPS_COLOR & pDriverCaps->D3DCaps.CursorCaps)
                  &&
                  (
                    (400 <= pDriverCaps->DisplayHeight) 
                    ||
                    (D3DCURSORCAPS_LOWRES & pDriverCaps->D3DCaps.CursorCaps)
                  )
                ) 
                && ((UINT)GetSystemMetrics(SM_CXCURSOR) == desc.Width) 
                && ((UINT)GetSystemMetrics(SM_CYCURSOR) == desc.Height)
            )
            // or windowed case where we have to use OS cursor
            ||
            m_pDevice->SwapChain()->m_PresentationData.Windowed
            // or there is no ddraw support
            ||
            m_pDevice->Enum()->NoDDrawSupport(m_pDevice->AdapterIndex())
           )
       ) 
    {
        HCURSOR hCursor;

        if (!m_pDevice->SwapChain()->m_PresentationData.Windowed 
            && (NULL == m_hHWCursor))
        {
            SystemParametersInfo(SPI_GETMOUSETRAILS,0,&m_SavedMouseTrails,0);
            if (m_SavedMouseTrails > 1)
            {
                // always make sure it's disabled
                SystemParametersInfo(SPI_SETMOUSETRAILS,0,0,0);        
            }
        }
        hCursor = CreateColorCursor(xHotSpot,yHotSpot,
            desc.Width, desc.Height, pCursorBitmap);
        if ( NULL != hCursor)
        {
            if ( NULL != m_hHWCursor)
            {
                if ( GetCursor() == m_hHWCursor )
                    SetCursor(hCursor); // turn it on if it was on
                if (!DestroyIcon((HICON)m_hHWCursor))
                {
                    DPF_ERR("Failed to Destroy Old hwcursor Icon");
                }
            }
            else 
            if ( DDRAWI_CURSORISON & m_dwCursorFlags)
            {
                SetCursor(hCursor); // turn it on if it was on
                // make sure software cursor is off
                m_dwCursorFlags &= ~DDRAWI_CURSORISON;
            }
            m_hHWCursor = hCursor;
            m_dwCursorFlags |= DDRAWI_CURSORINIT;
            return S_OK;
        }
    }
    if (m_SavedMouseTrails > 1)
    {
        SystemParametersInfo(SPI_SETMOUSETRAILS,m_SavedMouseTrails,0,0);        
        m_SavedMouseTrails = 0;
    }
    SetCursor(NULL);
    if ( NULL != m_hHWCursor )
    {
        if (!DestroyIcon((HICON)m_hHWCursor))
        {
            DPF_ERR("Failed to Destroy Old hwcursor Icon");
        }
        m_hHWCursor = NULL;
    }

    if (desc.Width != m_Width || desc.Height != m_Height)
    {
        DDSURFACEINFO SurfInfoArray[3];
        D3D8_CREATESURFACEDATA CreateSurfaceData;
        ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

        Destroy();
        ZeroMemory(SurfInfoArray, sizeof(SurfInfoArray));
        for (int i = 0; i < 3; i++)
        {
            SurfInfoArray[i].cpWidth = desc.Width;
            SurfInfoArray[i].cpHeight = desc.Height;
            ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));
            CreateSurfaceData.hDD      = m_pDevice->GetHandle();
            CreateSurfaceData.pSList   = &SurfInfoArray[i];
            CreateSurfaceData.dwSCnt   = 1;
            CreateSurfaceData.Type     = D3DRTYPE_SURFACE;
            CreateSurfaceData.Pool     = D3DPOOL_LOCALVIDMEM;
            CreateSurfaceData.dwUsage  = D3DUSAGE_OFFSCREENPLAIN;
            CreateSurfaceData.Format   = m_pDevice->DisplayFormat();
            CreateSurfaceData.MultiSampleType = D3DMULTISAMPLE_NONE;
            hr = m_pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
            if (NULL == SurfInfoArray[i].hKernelHandle)
            {
                CreateSurfaceData.Pool  = D3DPOOL_SYSTEMMEM;
                hr = m_pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
            } 
            DPF(10,"CursorInit CreateSurface returns hr=%08lx handle=%08lx",
                hr, SurfInfoArray[i].hKernelHandle);
        }

        m_hCursorDdb = SurfInfoArray[0].hKernelHandle;

        m_hFrontSave = SurfInfoArray[1].hKernelHandle;

        m_hBackSave = SurfInfoArray[2].hKernelHandle; 
        if (m_hCursorDdb && m_hFrontSave && m_hBackSave)
        {
            m_Width = desc.Width;
            m_Height = desc.Height;
        }
        else
        {
            DPF_ERR("Cursor not available for this device");
            return D3DERR_NOTAVAILABLE;        
        }
    }
    if (NULL != pCursorBitmap)
    {
        D3D8_LOCKDATA lockData;
        D3DLOCKED_RECT lock;
        DWORD   *pSourceBitmap;
        INT     SourcePitch;
        ZeroMemory(&lockData, sizeof lockData);
        hr = pCursorBitmap->LockRect(&lock, NULL, 0);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to lock pCursorBitmap surface; Surface must be lockable.");
            return D3DERR_INVALIDCALL;
        }

        lockData.hDD = m_pDevice->GetHandle();
        lockData.hSurface = m_hCursorDdb;
        hr = m_pDevice->GetHalCallbacks()->Lock(&lockData);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to lock driver cursor surface.");
            pCursorBitmap->UnlockRect();
            return hr;
        }
        SourcePitch = lock.Pitch; 
        pSourceBitmap = (DWORD*)lock.pBits;
        switch (m_pDevice->DisplayFormat())
        {
        case D3DFMT_A1R5G5B5:
            {
                BYTE *pScan = (BYTE *) lockData.lpSurfData;
                for (UINT j = 0; j < m_Height; ++j)
                {
                    WORD *pPixel = (WORD *) pScan;
                    for (UINT i = 0; i < m_Width; ++i)
                    {
                        if (ISOPAQUE(pSourceBitmap[i]))
                        {
                            *pPixel = 
                                (WORD)FORMAT_8888_1555(pSourceBitmap[i]);
                            if (0 == (0x7FFF & *pPixel))
                                *pPixel |= 0x0421;  //off black color
                        }
                        else
                            *pPixel = 0;
                        pPixel ++;
                    }
                    pScan += lockData.lPitch;
                    pSourceBitmap += SourcePitch/4;
                }
            }
            break;

        case D3DFMT_X1R5G5B5:
            {
                BYTE *pScan = (BYTE *) lockData.lpSurfData;
                for (UINT j = 0; j < m_Height; ++j)
                {
                    WORD *pPixel = (WORD *) pScan;
                    for (UINT i = 0; i < m_Width; ++i)
                    {
                        if (ISOPAQUE(pSourceBitmap[i]))
                        {
                            *pPixel = 
                                (WORD)FORMAT_8888_555(pSourceBitmap[i]);
                            if (0 == *pPixel)
                                *pPixel |= 0x0421;  //off black color
                        }
                        else
                            *pPixel = 0;
                        pPixel ++;
                    }
                    pScan += lockData.lPitch;
                    pSourceBitmap += SourcePitch/4;
                }
            }
            break;

        case D3DFMT_R5G6B5:
            {
                BYTE *pScan = (BYTE *) lockData.lpSurfData;
                for (UINT j = 0; j < m_Height; ++j)
                {
                    WORD *pPixel = (WORD *) pScan;
                    for (UINT i = 0; i < m_Width; ++i)
                    {
                        if (ISOPAQUE(pSourceBitmap[i]))
                        {
                            *pPixel = 
                                (WORD)FORMAT_8888_565(pSourceBitmap[i]);
                            if (0 == *pPixel)
                                *pPixel |= 0x0821;  //off black color
                        }
                        else
                            *pPixel = 0;
                        pPixel ++;
                    }
                    pScan += lockData.lPitch;
                    pSourceBitmap += SourcePitch/4;
                }
            }
            break;

        case D3DFMT_X8R8G8B8:
            {
                BYTE *pScan = (BYTE *) lockData.lpSurfData;
                for (UINT j = 0; j < m_Height; ++j)
                {
                    DWORD *pPixel = (DWORD *) pScan;
                    for (UINT i = 0; i < m_Width; ++i)
                    {
                        if (ISOPAQUE(pSourceBitmap[i]))
                        {
                            *pPixel = pSourceBitmap[i] & 0x00FFFFFF;
                            if (0 == *pPixel)
                                *pPixel |= 0x010101;    //off black color
                        }
                        else
                            *pPixel = 0;
                        pPixel ++;
                    }
                    pScan += lockData.lPitch;
                    pSourceBitmap += SourcePitch/4;
                }
            }
            break;

        case D3DFMT_A8R8G8B8:
            {
                BYTE *pScan = (BYTE *) lockData.lpSurfData;
                for (UINT j = 0; j < m_Height; ++j)
                {
                    DWORD *pPixel = (DWORD *) pScan;
                    for (UINT i = 0; i < m_Width; ++i)
                    {
                        if (ISOPAQUE(pSourceBitmap[i]))
                        {
                            *pPixel = pSourceBitmap[i];
                            if (0 == (0x00FFFFFF & *pPixel))
                                *pPixel |= 0x010101;    //off black color
                        }
                        else
                            *pPixel = 0;
                        pPixel ++;
                    }
                    pScan += lockData.lPitch;
                    pSourceBitmap += SourcePitch/4;
                }
            }
            break;
        default:
            // this should never happen
            DDASSERT(FALSE);
        }
        D3D8_UNLOCKDATA unlockData;
        ZeroMemory(&unlockData, sizeof unlockData);

        unlockData.hDD = m_pDevice->GetHandle();
        unlockData.hSurface = m_hCursorDdb;
        hr = m_pDevice->GetHalCallbacks()->Unlock(&unlockData);
        if (FAILED(hr))
        {
            DPF_ERR("Driver surface failed to unlock driver cursor surface");
        }
        hr = pCursorBitmap->UnlockRect();
        if (FAILED(hr))
        {
            DPF_ERR("Driver surface failed to unlock pCursorBitmap");
        }
        m_xCursorHotSpot = xHotSpot;
        m_yCursorHotSpot = yHotSpot;
    }
    if (SUCCEEDED(hr))
        m_dwCursorFlags |= DDRAWI_CURSORINIT;
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME     "SetVisibility"
BOOL   
CCursor::SetVisibility(BOOL bVisible)
{
    BOOL    retval = FALSE;
    if (DDRAWI_CURSORINIT & m_dwCursorFlags)
    {
        if (NULL == m_hHWCursor)
        {
            retval = (BOOL) (DDRAWI_CURSORISON & m_dwCursorFlags);
            SetCursor(NULL);
            if (bVisible)
            {
                if (!retval)
                {
                    m_dwCursorFlags |= DDRAWI_CURSORISON;
                    Show(m_pDevice->SwapChain()->
                        PrimarySurface()->KernelHandle());
                    m_dwCursorFlags &= ~(DDRAWI_CURSORSAVERECT | DDRAWI_CURSORRECTSAVED);
                }
            }
            else
            {
                Hide(m_pDevice->SwapChain()->
                    PrimarySurface()->KernelHandle());
                m_dwCursorFlags &= ~(DDRAWI_CURSORISON | 
                    DDRAWI_CURSORSAVERECT | DDRAWI_CURSORRECTSAVED);
            }
        }
        else
        {
            if (m_hHWCursor == GetCursor())
            {
                if (!bVisible)
                    SetCursor(NULL);
                retval = TRUE;
            }
            else
            {
                if (bVisible)
                    SetCursor(m_hHWCursor);
                else
                    SetCursor(NULL);
            }
        }
    }
    return retval;
}
/*
 * SetCursorProperties
 *
 * Setup a cursor
 * This is the method visible to the outside world.
 */
#undef DPF_MODNAME
#define DPF_MODNAME     "SetProperties"
HRESULT 
CCursor::SetProperties(
    UINT    xHotSpot,
    UINT    yHotSpot,
    CBaseSurface *pCursorBitmap)
{
    HRESULT hr;
    DPF(10,"ENTERAPI: SetCursorProperties "
        "xh=%d yh=%d pCursorBitmap=%08lx",
        xHotSpot,yHotSpot,pCursorBitmap);

    m_dwCursorFlags &= ~(DDRAWI_CURSORSAVERECT | DDRAWI_CURSORRECTSAVED);
    hr = Hide(m_pDevice->SwapChain()
        ->PrimarySurface()->KernelHandle());

    if (FAILED(hr))
    {
        DPF_ERR("Failed to Hide Cursor.");
        return  hr;
    }

    hr = CursorInit(xHotSpot, yHotSpot, pCursorBitmap);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to CursorInit.");
        return  hr;
    }

    hr = Show(m_pDevice->SwapChain()->PrimarySurface()->KernelHandle());

    return  hr;
}

/*
 * Cursor::SetPosition
 *
 * Setup a cursor
 * This is the method visible to the outside world.
 */
#undef DPF_MODNAME
#define DPF_MODNAME     "Cursor::SetPosition"

void 
CCursor::SetPosition(
    UINT xScreenSpace,
    UINT yScreenSpace,
    DWORD Flags)
{
    HRESULT hr = S_OK;
    if (DDRAWI_CURSORINIT & m_dwCursorFlags)
    {
        if ( m_hHWCursor)
        {
            if (xScreenSpace == m_xCursor && yScreenSpace == m_yCursor)
            {
                POINT   current;
                if (GetCursorPos(&current))
                {
                    if ((current.x == (INT)xScreenSpace + m_MonitorOrigin.x) &&
                        (current.y == (INT)yScreenSpace + m_MonitorOrigin.y)
                       )
                        return;
                }
            }
            else
            {
                m_xCursor = xScreenSpace;
                m_yCursor = yScreenSpace;
            }
            SetCursorPos(xScreenSpace+m_MonitorOrigin.x,
                yScreenSpace+m_MonitorOrigin.y);
            return;
        }
        if (xScreenSpace == m_xCursor && yScreenSpace == m_yCursor)
            return;
        // only emulated fullscreen cursor ever gets down here
        if (D3DCURSOR_IMMEDIATE_UPDATE & Flags)
            hr = Hide(m_pDevice->SwapChain()->PrimarySurface()->KernelHandle());
        else if (DDRAWI_CURSORISON & m_dwCursorFlags)
            m_dwCursorFlags |= DDRAWI_CURSORSAVERECT; 
        m_xCursor = xScreenSpace;
        m_yCursor = yScreenSpace;
        if (m_xCursor >= m_pDevice->DisplayWidth())
        {
            m_xCursor = m_pDevice->DisplayWidth()-1;
        }
        if (m_yCursor >= m_pDevice->DisplayHeight())
        {
            m_yCursor = m_pDevice->DisplayHeight()-1;
        }
        if (D3DCURSOR_IMMEDIATE_UPDATE & Flags)
        {
            hr = Show(m_pDevice->SwapChain()->PrimarySurface()->KernelHandle());
        }
    }
    else
    {
        m_xCursor = xScreenSpace;
        m_yCursor = yScreenSpace;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\fcache.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       enum.cpp
 *  Content     Handles all of the file caching of device caps.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include <stdio.h>

#include "d3dobj.hpp"
#include "enum.hpp"
#include "d3di.hpp"
#include "shlobj.h"

#define DXCACHEFILENAME     "\\d3d8caps.dat"
#define DXTEMPFILENAME      "\\d3d8caps.tmp"

typedef struct _FDEVICEHEADER
{
    DWORD   VendorId;
    DWORD   DeviceId;
    DWORD   SubSysId;
    DWORD   Revision;
    DWORD   FileOffset;
    DWORD   Size;
} FDEVICEHEADER;

HANDLE OpenCacheFile(DWORD dwDesiredAccess, DWORD dwCreationDisposition, char * pName, char * pPath)
{
    char                    FName[MAX_PATH + 16];

    GetSystemDirectory(FName, MAX_PATH);

    lstrcat(FName, pName);

    HANDLE h = CreateFile( FName, 
                       dwDesiredAccess, 
                       FILE_SHARE_READ, 
                       NULL, 
                       dwCreationDisposition, 
                       FILE_ATTRIBUTE_NORMAL, 
                       NULL);
#ifdef WINNT
    if (INVALID_HANDLE_VALUE == h)
    {
        HMODULE hShlwapi=0;
        typedef HRESULT (WINAPI * PSHGETSPECIALFOLDERPATH) (HWND, LPTSTR, int, BOOL);
        PSHGETSPECIALFOLDERPATH pSHGetSpecialFolderPath=0;

        hShlwapi = LoadLibrary("SHELL32.DLL");
        if (hShlwapi)
        {
            pSHGetSpecialFolderPath = (PSHGETSPECIALFOLDERPATH) GetProcAddress(hShlwapi,"SHGetSpecialFolderPathA");

            if(pSHGetSpecialFolderPath)
            {
                HRESULT hr = pSHGetSpecialFolderPath(
                    NULL,
                    FName,
                    CSIDL_LOCAL_APPDATA,          // <user name>\Local Settings\Applicaiton Data (non roaming)
                    TRUE);

                if (SUCCEEDED(hr))
                {
                    lstrcat(FName, pName);

                    h = CreateFile( FName, 
		       dwDesiredAccess, 
		       FILE_SHARE_READ, 
		       NULL, 
		       dwCreationDisposition, 
		       FILE_ATTRIBUTE_NORMAL, 
		       NULL);
                }
            }
            FreeLibrary(hShlwapi);
        }
    }
#endif

    if (pPath)
    {
        lstrcpy(pPath, FName);
    }
    return h;
}

void ReadFromCache(D3DADAPTER_IDENTIFIER8*  pDI,
                   UINT*                    pCapsSize,
                   BYTE**                   ppCaps)
{
    HANDLE                  h;
    DWORD                   HeaderSize;
    DWORD                   NumRead;
    FDEVICEHEADER*          pHeaderInfo = NULL;
    DWORD                   i;

    // Get the data for the device that we're looking for

    *pCapsSize = 0;
    *ppCaps = NULL;

    // Open the file and look for the device entry

    h = OpenCacheFile (GENERIC_READ, OPEN_EXISTING, DXCACHEFILENAME, NULL);
    if (h == INVALID_HANDLE_VALUE)
    {
        return;
    }

    ReadFile( h, &HeaderSize, sizeof(DWORD), &NumRead, NULL);
    if (NumRead < sizeof(DWORD))
    {
        goto FileError;
    }
    pHeaderInfo = (FDEVICEHEADER*) MemAlloc(HeaderSize);
    if (pHeaderInfo == NULL)
    {
        goto FileError;
    }
    ReadFile( h, pHeaderInfo, HeaderSize, &NumRead, NULL);
    if (NumRead < HeaderSize)
    {
        goto FileError;
    }

    for (i = 0; i < HeaderSize / sizeof(FDEVICEHEADER); i++)
    {
        if ((pHeaderInfo[i].VendorId == pDI->VendorId) &&
            (pHeaderInfo[i].DeviceId == pDI->DeviceId) &&
            (pHeaderInfo[i].SubSysId == pDI->SubSysId) &&
            (pHeaderInfo[i].Revision == pDI->Revision))
        {
            break;
        }
    }
    if (i < HeaderSize / sizeof(FDEVICEHEADER))
    {
        // We have info for the device - now we read it

        if (SetFilePointer (h, pHeaderInfo[i].FileOffset, NULL, FILE_BEGIN) !=
            pHeaderInfo[i].FileOffset)
        {
            goto FileError;
        }
        *ppCaps = (BYTE*) MemAlloc(pHeaderInfo[i].Size);
        if (*ppCaps == NULL)
        {
            goto FileError;
        }
        ReadFile( h, *ppCaps, pHeaderInfo[i].Size, &NumRead, NULL);
        if (NumRead < pHeaderInfo[i].Size)
        {
            MemFree(*ppCaps);
            *ppCaps = NULL;
            goto FileError;
        }

        // If we got this far, then everything worked

        *pCapsSize = pHeaderInfo[i].Size;
    }

FileError:
    if (pHeaderInfo != NULL)
    {
        MemFree(pHeaderInfo);
    }
    CloseHandle(h);
}


void WriteToCache(D3DADAPTER_IDENTIFIER8*   pDI,
                  UINT                      CapsSize,
                  BYTE*                     pCaps)
{
    char                    FName[MAX_PATH + 16];
    char                    NewFName[MAX_PATH + 16];
    BOOL                    bNewFile = FALSE;
    HANDLE                  hOld;
    HANDLE                  hNew;
    DWORD                   NewHeaderSize;
    DWORD                   OldHeaderSize;
    DWORD                   NumWritten;
    DWORD                   NumRead;
    FDEVICEHEADER*          pOldHeaderInfo = NULL;
    FDEVICEHEADER*          pNewHeaderInfo = NULL;
    DWORD                   dwOffset;
    DWORD                   i;
    DWORD                   NewEntries;
    DWORD                   NextEntry;
    DWORD                   Biggest;
    BYTE*                   pBuffer = NULL;

    // Does the file already exist, or do we need to create a new one?
    hOld = OpenCacheFile (GENERIC_READ, OPEN_EXISTING, DXCACHEFILENAME, FName);
    
    if (hOld == INVALID_HANDLE_VALUE)
    {
        bNewFile = TRUE;
    }
    else
    {
        // We don't want this file to get over 65K.  If writing this entry 
        // will cause the file size to exceed that, then we will delete all
        // of the existing data and start from scratch. 

        DWORD dwLow;
        DWORD dwHigh;

        dwLow = GetFileSize (hOld, &dwHigh);
        if ((dwHigh != 0) || ((sizeof(DWORD) - dwLow) < CapsSize))
        {
            CloseHandle(hOld);
            bNewFile = TRUE;
        }
    }

    if (bNewFile)
    {
        // We are creating a new file, which is pretty easy

        hNew = OpenCacheFile (GENERIC_WRITE, CREATE_ALWAYS, DXCACHEFILENAME, NewFName);

        if (hNew != INVALID_HANDLE_VALUE)
        {
            NewHeaderSize = sizeof (FDEVICEHEADER);
            WriteFile (hNew, &NewHeaderSize, sizeof(NewHeaderSize), &NumWritten, NULL);
            if (NumWritten == sizeof(NewHeaderSize))
            {
                FDEVICEHEADER DevHeader;

                DevHeader.VendorId = pDI->VendorId;
                DevHeader.DeviceId = pDI->DeviceId;
                DevHeader.SubSysId = pDI->SubSysId;
                DevHeader.Revision = pDI->Revision;
                DevHeader.FileOffset = sizeof(FDEVICEHEADER) + sizeof(DWORD);
                DevHeader.Size = CapsSize;

                WriteFile (hNew, &DevHeader, sizeof(DevHeader), &NumWritten, NULL);
                if (NumWritten == sizeof(DevHeader))
                {
                    WriteFile (hNew, pCaps, CapsSize, &NumWritten, NULL);
                }
            }
            CloseHandle(hNew);
        }
    }
    else
    {
        // The file already exists, so we will create a new file and copy all of the contents
        // from the existing file over.

        hNew = OpenCacheFile (GENERIC_WRITE, CREATE_ALWAYS, DXTEMPFILENAME, NewFName);

        if (hNew == INVALID_HANDLE_VALUE)
        {
            goto FileError;
        }

        ReadFile (hOld, &OldHeaderSize, sizeof(DWORD), &NumRead, NULL);
        if (NumRead < sizeof(DWORD))
        {
            goto FileError;
        }
        pOldHeaderInfo = (FDEVICEHEADER*) MemAlloc(OldHeaderSize);
        if (pOldHeaderInfo == NULL)
        {
            goto FileError;
        }
        ReadFile (hOld, pOldHeaderInfo, OldHeaderSize, &NumRead, NULL);
        if (NumRead < OldHeaderSize)
        {
            goto FileError;
        }

        // How many entries will exist in the new header?

        NewEntries = 1;
        for (i = 0; i < OldHeaderSize / sizeof (FDEVICEHEADER); i++)
        {
            if ((pOldHeaderInfo[i].VendorId != pDI->VendorId) ||
                (pOldHeaderInfo[i].DeviceId != pDI->DeviceId) ||
                (pOldHeaderInfo[i].SubSysId != pDI->SubSysId) ||
                (pOldHeaderInfo[i].Revision != pDI->Revision))
            {
                NewEntries++;
            }
        }
        pNewHeaderInfo = (FDEVICEHEADER*) MemAlloc(sizeof(FDEVICEHEADER) * NewEntries);
        if (pNewHeaderInfo == NULL)
        {
            goto FileError;
        }

        // Fill in the header info for each device and save it to the new file

        dwOffset = (sizeof(FDEVICEHEADER) * NewEntries) + sizeof(DWORD);
        pNewHeaderInfo[0].VendorId = pDI->VendorId;
        pNewHeaderInfo[0].DeviceId = pDI->DeviceId;
        pNewHeaderInfo[0].SubSysId = pDI->SubSysId;
        pNewHeaderInfo[0].Revision = pDI->Revision;
        pNewHeaderInfo[0].FileOffset = dwOffset;
        pNewHeaderInfo[0].Size = CapsSize;
        dwOffset += CapsSize;

        NextEntry = 1;
        for (i = 0; i < OldHeaderSize / sizeof (FDEVICEHEADER); i++)
        {
            if ((pOldHeaderInfo[i].VendorId != pDI->VendorId) ||
                (pOldHeaderInfo[i].DeviceId != pDI->DeviceId) ||
                (pOldHeaderInfo[i].SubSysId != pDI->SubSysId) ||
                (pOldHeaderInfo[i].Revision != pDI->Revision))
            {
                pNewHeaderInfo[NextEntry].VendorId = pOldHeaderInfo[i].VendorId;
                pNewHeaderInfo[NextEntry].DeviceId = pOldHeaderInfo[i].DeviceId;
                pNewHeaderInfo[NextEntry].SubSysId = pOldHeaderInfo[i].SubSysId;
                pNewHeaderInfo[NextEntry].Revision = pOldHeaderInfo[i].Revision;
                pNewHeaderInfo[NextEntry].FileOffset = dwOffset;
                pNewHeaderInfo[NextEntry].Size = pOldHeaderInfo[i].Size;
                dwOffset += pOldHeaderInfo[i].Size;
                NextEntry++;
            }
        }

        NewHeaderSize = sizeof(FDEVICEHEADER) * NewEntries;
        WriteFile (hNew, &NewHeaderSize, sizeof(NewHeaderSize), &NumWritten, NULL);
        if (NumWritten != sizeof(NewHeaderSize))
        {
            goto FileError;
        }
        WriteFile (hNew, pNewHeaderInfo, NewHeaderSize, &NumWritten, NULL);
        if (NumWritten != NewHeaderSize)
        {
            goto FileError;
        }

        // Write the new device data to the file

        WriteFile (hNew, pCaps, CapsSize, &NumWritten, NULL);
        if (NumWritten != CapsSize)
        {
            goto FileError;
        }

        if (NewEntries > 1)
        {
            // Figure out how big the biggest device size is and allocate a buffer
            // to hold it

            Biggest = 0;
            for (i = 1; i < NewEntries; i++)
            {
                if (pNewHeaderInfo[i].Size > Biggest)
                {
                    Biggest = pNewHeaderInfo[i].Size;
                }
            }

            pBuffer = (BYTE*) MemAlloc(Biggest);
            if (pBuffer == NULL)
            {
                goto FileError;
            }

            // Now read the device data from the old file and write it to
            // the new on.

            NextEntry = 0;
            for (i = 0; i < OldHeaderSize / sizeof (FDEVICEHEADER); i++)
            {
                if ((pOldHeaderInfo[i].VendorId != pDI->VendorId) ||
                    (pOldHeaderInfo[i].DeviceId != pDI->DeviceId) ||
                    (pOldHeaderInfo[i].SubSysId != pDI->SubSysId) ||
                    (pOldHeaderInfo[i].Revision != pDI->Revision))
                {
                    if (SetFilePointer (hOld, pOldHeaderInfo[i].FileOffset, NULL, FILE_BEGIN) !=
                        pOldHeaderInfo[i].FileOffset)
                    {
                        goto FileError;
                    }
                    ReadFile (hOld, pBuffer, pOldHeaderInfo[i].Size, &NumRead, NULL);
                    if (NumRead < pOldHeaderInfo[i].Size)
                    {
                        goto FileError;
                    }
                    WriteFile (hNew, pBuffer, pOldHeaderInfo[i].Size, &NumWritten, NULL);
                    if (NumWritten != pOldHeaderInfo[i].Size)
                    {
                        goto FileError;
                    }
                }
            }
        }

        // If we made it this far, then everything worked

        CloseHandle(hNew);
        CloseHandle(hOld);
        DeleteFile(FName);
        MoveFile(NewFName, FName);
        if (pNewHeaderInfo != NULL)
        {
            MemFree(pNewHeaderInfo);
        }
        if (pOldHeaderInfo != NULL)
        {
            MemFree(pOldHeaderInfo);
        }
        if (pBuffer != NULL)
        {   
            MemFree(pBuffer);
        }
        return;

FileError:
        CloseHandle(hNew);
        CloseHandle(hOld);
        DeleteFile(FName);
        DeleteFile(NewFName);

        if (pNewHeaderInfo != NULL)
        {
            MemFree(pNewHeaderInfo);
        }
        if (pOldHeaderInfo != NULL)
        {
            MemFree(pOldHeaderInfo);
        }
        if (pBuffer != NULL)
        {
            MemFree(pBuffer);
        }
    }
}
            

void RemoveFromCache(D3DADAPTER_IDENTIFIER8* pDI)
{
    char                    FName[MAX_PATH + 16];
    char                    NewFName[MAX_PATH + 16];
    BOOL                    bNewFile = FALSE;
    HANDLE                  hOld;
    HANDLE                  hNew;
    DWORD                   NewHeaderSize;
    DWORD                   OldHeaderSize;
    DWORD                   NumWritten;
    DWORD                   NumRead;
    FDEVICEHEADER*          pOldHeaderInfo = NULL;
    FDEVICEHEADER*          pNewHeaderInfo = NULL;
    DWORD                   dwOffset;
    DWORD                   i;
    DWORD                   NewEntries;
    DWORD                   NextEntry;
    DWORD                   Biggest;
    BYTE*                   pBuffer = NULL;

    // Does the file already exist, or do we need to create a new one?

    hOld = OpenCacheFile (GENERIC_READ, OPEN_EXISTING, DXCACHEFILENAME, FName);

    if (hOld == INVALID_HANDLE_VALUE)
    {
        return;
    }

    ReadFile (hOld, &OldHeaderSize, sizeof(DWORD), &NumRead, NULL);
    if (NumRead < sizeof(DWORD))
    {
        goto FileError;
    }
    if (OldHeaderSize <= sizeof(FDEVICEHEADER))
    {
        // Theres only one entry in the file, so all we need to do
        // is delete it.

        DeleteFile(FName);
        return;
    }

    pOldHeaderInfo = (FDEVICEHEADER*) MemAlloc(OldHeaderSize);
    if (pOldHeaderInfo == NULL)
    {
        goto FileError;
    }
    ReadFile (hOld, pOldHeaderInfo, OldHeaderSize, &NumRead, NULL);
    if (NumRead < OldHeaderSize)
    {
        goto FileError;
    }

    // Create a new file and copy all of the contents from the existing file over.

    hNew = OpenCacheFile (GENERIC_WRITE, CREATE_ALWAYS, DXTEMPFILENAME, NewFName);

    if (hNew == INVALID_HANDLE_VALUE)
    {
        goto FileError;
    }

    // How many entries will exist in the new header?

    NewEntries = 0;
    for (i = 0; i < OldHeaderSize / sizeof (FDEVICEHEADER); i++)
    {
        if ((pOldHeaderInfo[i].VendorId != pDI->VendorId) ||
            (pOldHeaderInfo[i].DeviceId != pDI->DeviceId) ||
            (pOldHeaderInfo[i].SubSysId != pDI->SubSysId) ||
            (pOldHeaderInfo[i].Revision != pDI->Revision))
        {
            NewEntries++;
        }
    }
    pNewHeaderInfo = (FDEVICEHEADER*) MemAlloc(sizeof(FDEVICEHEADER) * NewEntries);
    if (pNewHeaderInfo == NULL)
    {
        goto FileError;
    }

    // Fill in the header info for each device and save it to the new file

    dwOffset = (sizeof(FDEVICEHEADER) * NewEntries) + sizeof(DWORD);

    NextEntry = 0;
    for (i = 0; i < OldHeaderSize / sizeof (FDEVICEHEADER); i++)
    {
        if ((pOldHeaderInfo[i].VendorId != pDI->VendorId) ||
            (pOldHeaderInfo[i].DeviceId != pDI->DeviceId) ||
            (pOldHeaderInfo[i].SubSysId != pDI->SubSysId) ||
            (pOldHeaderInfo[i].Revision != pDI->Revision))
        {
            pNewHeaderInfo[NextEntry].VendorId = pOldHeaderInfo[i].VendorId;
            pNewHeaderInfo[NextEntry].DeviceId = pOldHeaderInfo[i].DeviceId;
            pNewHeaderInfo[NextEntry].SubSysId = pOldHeaderInfo[i].SubSysId;
            pNewHeaderInfo[NextEntry].Revision = pOldHeaderInfo[i].Revision;
            pNewHeaderInfo[NextEntry].FileOffset = dwOffset;
            pNewHeaderInfo[NextEntry].Size = pOldHeaderInfo[i].Size;
            dwOffset += pOldHeaderInfo[i].Size;
            NextEntry++;
        }
    }

    NewHeaderSize = sizeof(FDEVICEHEADER) * NewEntries;
    WriteFile (hNew, &NewHeaderSize, sizeof(NewHeaderSize), &NumWritten, NULL);
    if (NumWritten != sizeof(NewHeaderSize))
    {
        goto FileError;
    }
    WriteFile (hNew, pNewHeaderInfo, NewHeaderSize, &NumWritten, NULL);
    if (NumWritten != NewHeaderSize)
    {
        goto FileError;
    }

    // Figure out how big the biggest device size is and allocate a buffer
    // to hold it

    Biggest = 0;
    for (i = 0; i < NewEntries; i++)
    {
        if (pNewHeaderInfo[i].Size > Biggest)
        {
            Biggest = pNewHeaderInfo[i].Size;
        }
    }

    pBuffer = (BYTE*) MemAlloc(Biggest);
    if (pBuffer == NULL)
    {
        goto FileError;
    }

    // Now read the device data from the old file and write it to
    // the new on.

    NextEntry = 0;
    for (i = 0; i < OldHeaderSize / sizeof (FDEVICEHEADER); i++)
    {
        if ((pOldHeaderInfo[i].VendorId != pDI->VendorId) ||
            (pOldHeaderInfo[i].DeviceId != pDI->DeviceId) ||
            (pOldHeaderInfo[i].SubSysId != pDI->SubSysId) ||
            (pOldHeaderInfo[i].Revision != pDI->Revision))
        {
            if (SetFilePointer (hOld, pOldHeaderInfo[i].FileOffset, NULL, FILE_BEGIN) !=
                pOldHeaderInfo[i].FileOffset)
            {
                goto FileError;
            }
            ReadFile (hOld, pBuffer, pOldHeaderInfo[i].Size, &NumRead, NULL);
            if (NumRead < pOldHeaderInfo[i].Size)
            {
                goto FileError;
            }
            WriteFile (hNew, pBuffer, pOldHeaderInfo[i].Size, &NumWritten, NULL);
            if (NumWritten != pOldHeaderInfo[i].Size)
            {
                goto FileError;
            }
        }
    }

    // If we made it this far, then everything worked

    CloseHandle(hNew);
    CloseHandle(hOld);
    DeleteFile(FName);
    MoveFile(NewFName, FName);
    if (pNewHeaderInfo != NULL)
    {
        MemFree(pNewHeaderInfo);
    }
    if (pOldHeaderInfo != NULL)
    {
        MemFree(pOldHeaderInfo);
    }
    if (pBuffer != NULL)
    {
        MemFree(pBuffer);
    }
    return;

FileError:
    CloseHandle(hNew);
    CloseHandle(hOld);

    if (pNewHeaderInfo != NULL)
    {
        MemFree(pNewHeaderInfo);
    }
    if (pOldHeaderInfo != NULL)
    {
        MemFree(pOldHeaderInfo);
    }
    if (pBuffer != NULL)
    {
        MemFree(pBuffer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\fcache.hpp ===
#ifndef __FCACHE_HPP__
#define __FCACHE_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fcache.hpp
 *  Content:    File cache for device caps.
 *
 ***************************************************************************/


void ReadFromCache(D3DADAPTER_IDENTIFIER8* pDI, UINT* pCapsSize, BYTE** ppCaps);
void WriteToCache(D3DADAPTER_IDENTIFIER8* pDI, UINT CapsSize, BYTE* pCaps);
void RemoveFromCache(D3DADAPTER_IDENTIFIER8* pDI);


#endif // __FCACHE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\getri.c ===
//========================================================================
//
// GetRegistryInfo.CPP
//
// DirectDraw/Direct3D driver information grabber
// (c) Copyright 1998 Microsoft Corp.
// Written by Michael Lyons (mlyons@microsoft.com)
//
// Registry access functions, for querying device stuff from the
// registry
//
// Function names that begin with an underscore are internal only!
//
//========================================================================


#include "ddrawpr.h"

//#include "GetDriverInfo.h"
//#include "GetDriverInfoInt.h"

//========================================================================
// local functions
//========================================================================
BOOL _FindDevice(int    iDevice, LPCSTR szDeviceClass, LPCSTR szDeviceClassNot, LPSTR szHardwareKey, BOOL bIgnoreProblems);
static BOOL _GetDeviceValue(LPCSTR szHardwareKey, LPCSTR szKey,	LPCSTR szValue,	BYTE* buf, DWORD cbbuf);
extern char *_strstr(char *s1, char *s2);

//========================================================================
//
// GetDeviceValue
//
// read	a value	from the HW	or SW of a PnP device
//
// in:
//	szHardwareKey	the hardware key
//	szKey			the sub-key
//	szValue			the value to query
//	cbbuf			the size of the output buffer
//
// out:
//	buf				the destination buffer
//	
// returns:
//	success status
//
//========================================================================
static BOOL _GetDeviceValue(LPCSTR szHardwareKey, LPCSTR szKey,	LPCSTR szValue,	BYTE* buf, DWORD cbbuf)
{
	HKEY	hkeyHW;
	HKEY	hkeySW;
	BOOL	f =	FALSE;
	DWORD	cb;
	char	szSoftwareKey[MAX_DDDEVICEID_STRING];

	//
	// open	the	HW key
	//
	if (RegOpenKey(HKEY_LOCAL_MACHINE, szHardwareKey, &hkeyHW) == ERROR_SUCCESS)
	{
		//
		// try to read the value from the HW key
		//
		*buf = 0;
		cb = cbbuf;
		if (RegQueryValueEx(hkeyHW,	szValue, NULL, NULL, buf, &cb) == ERROR_SUCCESS)
		{
			f =	TRUE;
		}
		else
		{
			//
			// now try the SW key
			//
			static char	szSW[] = "System\\CurrentControlSet\\Services\\Class\\";

			lstrcpy(szSoftwareKey, szSW);
			cb = sizeof(szSoftwareKey) - sizeof(szSW);
			RegQueryValueEx(hkeyHW,	"Driver", NULL,	NULL, (BYTE	*)&szSoftwareKey[sizeof(szSW) -	1],	&cb);

			if (szKey)
			{
				lstrcat(szSoftwareKey, "\\");
				lstrcat(szSoftwareKey, szKey);
			}

			if (RegOpenKey(HKEY_LOCAL_MACHINE, szSoftwareKey, &hkeySW) == ERROR_SUCCESS)
			{
				*buf = 0;
				cb = cbbuf;
				if (RegQueryValueEx(hkeySW,	szValue, NULL, NULL, buf, &cb) == ERROR_SUCCESS)
				{
					f =	TRUE;
				}

				RegCloseKey(hkeySW);
			}
		}

		RegCloseKey(hkeyHW);
	}

	return f;
}



//========================================================================
//
// FindDevice
//
// enum	the	started	PnP	devices	looking	for	a device of	a particular class
//
//	iDevice			what device	to return (0= first	device,	1=second et)
//	szDeviceClass	what class device (ie "Display") NULL will match all
//	szDeviceID		buffer to return the hardware ID (MAX_DDDEVICEID_STRING bytes)
//
// return TRUE if a	device was found.
//
// example:
//
//		for	(int i=0; FindDevice(i,	"Display", DeviceID); i++)
//		{
//		}
//
//========================================================================
BOOL _FindDevice(int iDevice, LPCSTR szDeviceClass, LPCSTR szDeviceClassNot, LPSTR szHardwareKey, BOOL bIgnoreProblems)
{
	HKEY	hkeyPnP;
	HKEY	hkey;
	DWORD	n;
	DWORD	cb;
	DWORD	dw;
	char	ach[MAX_DDDEVICEID_STRING];

	if (RegOpenKey(HKEY_DYN_DATA, "Config Manager\\Enum", &hkeyPnP)	!= ERROR_SUCCESS)
		return FALSE;

	for	(n=0; RegEnumKey(hkeyPnP, n, ach, sizeof(ach)) == 0; n++)
	{
		static char	szHW[] = "Enum\\";

		if (RegOpenKey(hkeyPnP,	ach, &hkey)	!= ERROR_SUCCESS)
			continue;

		lstrcpy(szHardwareKey, szHW);
		cb = MAX_DDDEVICEID_STRING -	sizeof(szHW);
		RegQueryValueEx(hkey, "HardwareKey", NULL, NULL, (BYTE*)szHardwareKey +	sizeof(szHW) - 1, &cb);

		dw = 0;
		cb = sizeof(dw);
		RegQueryValueEx(hkey, "Problem", NULL, NULL, (BYTE*)&dw, &cb);
		RegCloseKey(hkey);

		if ((!bIgnoreProblems) && (dw != 0))		// if this device has a	problem	skip it
			continue;

		if (szDeviceClass || szDeviceClassNot)
		{
			_GetDeviceValue(szHardwareKey, NULL,	"Class", (BYTE *)ach, sizeof(ach));

			if (szDeviceClass && lstrcmpi(szDeviceClass, ach) != 0)
				continue;

			if (szDeviceClassNot && lstrcmpi(szDeviceClassNot, ach) == 0)
				continue;
		}

		//
		// we found	a device, make sure	it is the one the caller wants
		//
		if (iDevice-- == 0)
		{
			RegCloseKey(hkeyPnP);
			return TRUE;
		}
	}

	RegCloseKey(hkeyPnP);
	return FALSE;
}


//========================================================================
//
// _GetDriverInfoFromRegistry
//
// This function goes through the registry and tries to fill in
// information about a driver given a class and maybe a vendor ID
//
// in:
//	szClass		the class name (i.e., "Display")
//	szVendor	the vendor name (i.e., "VEN_121A" for 3Dfx" or NULL
//				if any vendor of the class will do
//
// out:
//	pDI			pointer to a DDDRIVERINFOEX structure to be filled in
//
// returns:
//	success status
//
//========================================================================
HRESULT _GetDriverInfoFromRegistry(char *szClass, 
                                   char *szClassNot, 
                                   char *szVendor, 
                                   D3DADAPTER_IDENTIFIER8* pDI,
                                   char *szDeviceID)
{
	char szDevice[MAX_DDDEVICEID_STRING];
        int i;

        szDeviceID[0]=0;
	pDI->Description[0]=0;


    for (i=0 ; ; i++)
    {
        if (!_FindDevice(i, szClass, szClassNot, szDevice, FALSE))
            break;

        if ((szVendor == NULL) || (_strstr(szDevice, szVendor)))
        {
            //
            // skip the first 5 characters "Enum\"
            //
            strcpy(szDeviceID, &szDevice[5]);
            _GetDeviceValue((LPCSTR)szDevice, NULL, "DeviceDesc", (BYTE *)pDI->Description, sizeof(pDI->Description));
            //_GetDeviceValue((LPCSTR)szDevice, NULL,		"Mfg",			(BYTE *)pDI->szManufacturer, sizeof(pDI->szManufacturer));
            //_GetDeviceValue((LPCSTR)szDevice, "DEFAULT","drv",			(BYTE *)pDI->szGDIDriver, sizeof(pDI->szGDIDriver));

            return S_OK;
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\ibuffer.hpp ===
#ifndef __IBUFFER_HPP__
#define __IBUFFER_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ibuffer.hpp
 *  Content:    Class header the Index buffer class
 *
 ***************************************************************************/

// Includes
#include "buffer.hpp"

// The base-class implementation of the Index buffer assumes
// that it is resides system-memory. It may be managed.
class CIndexBuffer : public IDirect3DIndexBuffer8, public CBuffer
{
public:
    // Creation function for Index Buffers
    static HRESULT Create(CBaseDevice            *pDevice, 
                          DWORD                   cbLength,
                          DWORD                   dwUsage,
                          D3DFORMAT               Format,
                          D3DPOOL                 Pool,
                          REF_TYPE                refType,
                          IDirect3DIndexBuffer8 **ppIndexBuffer);

    static HRESULT CreateSysmemIndexBuffer(CBaseDevice *pDevice,
                                           DWORD        cbLength,
                                           DWORD        dwUsage,
                                           DWORD        dwActualUsage,
                                           D3DFORMAT    Format,
                                           D3DPOOL      Pool,
                                           D3DPOOL      ActualPool,
                                           REF_TYPE     refType,
                                           CIndexBuffer **pIB);

    static HRESULT CreateDriverIndexBuffer(CBaseDevice *pDevice,
                                           DWORD        cbLength,
                                           DWORD        dwUsage,
                                           DWORD        dwActualUsage,
                                           D3DFORMAT    Format,
                                           D3DPOOL      Pool,
                                           D3DPOOL      ActualPool,
                                           REF_TYPE     refType,
                                           CIndexBuffer **pVB);

    static HRESULT CreateDriverManagedIndexBuffer(CBaseDevice *pDevice,
                                                  DWORD        cbLength,
                                                  DWORD        dwUsage,
                                                  DWORD        dwActualUsage,
                                                  D3DFORMAT    Format,
                                                  D3DPOOL      Pool,
                                                  D3DPOOL      ActualPool,
                                                  REF_TYPE     refType,
                                                  CIndexBuffer **pVB);

    // Methods for Resource Management

    // Create duplicate of current object in new pool;
    // LOD is ignored for our type
    virtual HRESULT Clone(D3DPOOL     Pool, 
                          CResource **ppResource) const;

    virtual const D3DBUFFER_DESC* GetBufferDesc() const;

    HRESULT UpdateDirtyPortion(CResource *pResourceTarget);

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, 
                               LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    // Some Methods for IDirect3DBuffer
    STDMETHOD(SetPrivateData)(REFGUID riid, 
                              CONST VOID* pvData, 
                              DWORD cbData, 
                              DWORD dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID riid, 
                              LPVOID pvData, 
                              LPDWORD pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD(GetDevice)(IDirect3DDevice8 **ppDevice);
    STDMETHOD_(DWORD, GetPriority)();
    STDMETHOD_(DWORD, SetPriority)(DWORD dwPriority);
    STDMETHOD_(void, PreLoad)();
    STDMETHOD_(D3DRESOURCETYPE, GetType)();

    // Methods for IDirect3DIndexBuffer8
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags);

    STDMETHOD(Unlock)();
    STDMETHOD(GetDesc)(D3DINDEXBUFFER_DESC *pDesc);

    BYTE* Data() const
    {
        DXGASSERT(m_desc.Usage & D3DUSAGE_SOFTWAREPROCESSING);
        DXGASSERT(m_desc.Pool == D3DPOOL_SYSTEMMEM || m_desc.Pool == D3DPOOL_MANAGED);
        DXGASSERT(m_LockCount == 0);
        return GetPrivateDataPointer();
    }

protected:

    CIndexBuffer(CBaseDevice *pDevice,
                 DWORD        cbLength,
                 DWORD        dwUsage,
                 DWORD        dwActualUsage,
                 D3DFORMAT    Format,
                 D3DPOOL      Pool,
                 D3DPOOL      ActualPool,
                 REF_TYPE     refType,
                 HRESULT     *phr);

#if DBG
    HRESULT ValidateLockParams(UINT cbOffsetToLock, 
                               UINT SizeToLock,
                               BYTE **ppbData,
                               DWORD dwFlags) const;
#endif // DBG

    // Member data
    D3DINDEXBUFFER_DESC   m_desc;
    DWORD                 m_usageUser;

}; // class CIndexBuffer

class CIndexBufferMT : public CIndexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags)
    {
        API_ENTER(Device());
        return CIndexBuffer::Lock(cbOffsetToLock, cbSizeToLock, ppbData, dwFlags);
    }

    STDMETHOD(Unlock)()
    {
        API_ENTER(Device());
        return CIndexBuffer::Unlock();
    }

    friend CIndexBuffer;

protected:

    CIndexBufferMT(CBaseDevice *pDevice,
                   DWORD        cbLength,
                   DWORD        Usage,
                   DWORD        ActualUsage,
                   D3DFORMAT    Format,
                   D3DPOOL      Pool,
                   D3DPOOL      ActualPool,
                   REF_TYPE     refType,
                   HRESULT     *phr) :
        CIndexBuffer(pDevice,
                     cbLength,
                     Usage,
                     ActualUsage,
                     Format,
                     Pool,
                     ActualPool,
                     refType,
                     phr)
    {
    }

}; // class CIndexBufferMT

// This derived version of the Index buffer class
// overrides lock/unlock to call the driver instead
class CDriverIndexBuffer : public CIndexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags);
    STDMETHOD(Unlock)();

    HRESULT LockI(DWORD dwFlags);
    HRESULT UnlockI();

    BYTE* Data() const
    {
        DXGASSERT(FALSE); // Direct pointer access not supported
        return 0;
    }

    // Alloc CIndexBuffer to construct this object
    friend CIndexBuffer;

protected:
    CDriverIndexBuffer(CBaseDevice *pDevice,
                       DWORD        cbLength,
                       DWORD        Usage,
                       DWORD        ActualUsage,
                       D3DFORMAT    Format,
                       D3DPOOL      Pool,
                       D3DPOOL      ActualPool,
                       REF_TYPE     refType,
                       HRESULT     *phr);
    ~CDriverIndexBuffer();

    BYTE*   m_pbData; // stores cached pointer
    
}; // class CDriverIndexBuffer 

class CDriverIndexBufferMT : public CDriverIndexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags)
    {
        API_ENTER(Device());
        return CDriverIndexBuffer::Lock(cbOffsetToLock, cbSizeToLock, ppbData, dwFlags);
    }

    STDMETHOD(Unlock)()
    {
        API_ENTER(Device());
        return CDriverIndexBuffer::Unlock();
    }

    friend CIndexBuffer;

protected:
    CDriverIndexBufferMT(CBaseDevice *pDevice,
                         DWORD        cbLength,
                         DWORD        Usage,
                         DWORD        ActualUsage,
                         D3DFORMAT    Format,
                         D3DPOOL      Pool,
                         D3DPOOL      ActualPool,
                         REF_TYPE     refType,
                         HRESULT     *phr) :
        CDriverIndexBuffer(pDevice,
                           cbLength,
                           Usage,
                           ActualUsage,
                           Format,
                           Pool,
                           ActualPool,
                           refType,
                           phr)
    {
    }

}; // class CIndexBufferMT

// This derived version of the Index buffer class
// overrides lock/unlock to call the driver instead
class CDriverManagedIndexBuffer : public CIndexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags);
    STDMETHOD(Unlock)();

    BYTE* Data() const
    {
        DXGASSERT(m_desc.Usage & D3DUSAGE_SOFTWAREPROCESSING);
        DXGASSERT((m_desc.Usage & D3DUSAGE_WRITEONLY) == 0);
        DXGASSERT(m_LockCount == 0);
        DXGASSERT(m_pbData != 0);
        return m_pbData;
    }

    // Alloc CIndexBuffer to construct this object
    friend CIndexBuffer;

protected:
    CDriverManagedIndexBuffer(CBaseDevice *pDevice,
                       DWORD        cbLength,
                       DWORD        Usage,
                       DWORD        ActualUsage,
                       D3DFORMAT    Format,
                       D3DPOOL      Pool,
                       D3DPOOL      ActualPool,
                       REF_TYPE     refType,
                       HRESULT     *phr);

    HRESULT UpdateCachedPointer(CBaseDevice*);

    friend HRESULT CResource::RestoreDriverManagementState(CBaseDevice*);

    BYTE*   m_pbData; // stores cached pointer
    BOOL    m_bDriverCalled;
    
}; // class CDriverManagedIndexBuffer 

class CDriverManagedIndexBufferMT : public CDriverManagedIndexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags)
    {
        API_ENTER(Device());
        return CDriverManagedIndexBuffer::Lock(cbOffsetToLock, cbSizeToLock, ppbData, dwFlags);
    }

    STDMETHOD(Unlock)()
    {
        API_ENTER(Device());
        return CDriverManagedIndexBuffer::Unlock();
    }

    // Alloc CIndexBuffer to construct this object
    friend CIndexBuffer;

protected:
    CDriverManagedIndexBufferMT(CBaseDevice *pDevice,
                                 DWORD        cbLength,
                                 DWORD        Usage,
                                 DWORD        ActualUsage,
                                 D3DFORMAT    Format,
                                 D3DPOOL      Pool,
                                 D3DPOOL      ActualPool,
                                 REF_TYPE     refType,
                                 HRESULT     *phr) :
        CDriverManagedIndexBuffer(pDevice,
                                   cbLength,
                                   Usage,
                                   ActualUsage,
                                   Format,
                                   Pool,
                                   ActualPool,
                                   refType,
                                   phr)
    {
    }

}; // class CDriverIndexBufferMT

#endif // __IBUFFER_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\ibuffer.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ibuffer.cpp
 *  Content:    Implementation of the CIndexBuffer class.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"

#include "ibuffer.hpp"
#include "d3di.hpp"
#include "ddi.h"
#include "resource.inl"

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::Create"

// Static class function for creating a Index Buffer object.
// (Because it is static; it doesn't have a this pointer.)
//
// We do all parameter checking here to reduce the overhead
// in the constructor which is called by the internal Clone
// method which is used by resource management as part of the
// performance critical download operation.

// Creation function for Index Buffers
HRESULT CIndexBuffer::Create(CBaseDevice        *pDevice,
                             DWORD               cbLength,
                             DWORD               Usage,
                             D3DFORMAT           Format,
                             D3DPOOL             Pool,
                             REF_TYPE            refType,
                             IDirect3DIndexBuffer8  **ppIndexBuffer)
{
    HRESULT hr;

    // Do parameter checking here
    if (!VALID_PTR_PTR(ppIndexBuffer))
    {
        DPF_ERR("Bad parameter passed for ppIndexBuffer for creating a Index buffer");
        return D3DERR_INVALIDCALL;
    }

    // Zero-out return parameter
    *ppIndexBuffer = NULL;

    if (Format != D3DFMT_INDEX16 &&
        Format != D3DFMT_INDEX32)
    {
        DPF_ERR("IndexBuffer must be in D3DFMT_INDEX16 or INDEX32 formats. CreateIndexBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    if ((Format == D3DFMT_INDEX16 && cbLength < 2) ||
        (Format == D3DFMT_INDEX32 && cbLength < 4))
    {
        DPF_ERR("Index buffer should be large enough to hold at least one index");
        return D3DERR_INVALIDCALL;
    }

    if (Pool != D3DPOOL_DEFAULT && Pool != D3DPOOL_MANAGED && Pool != D3DPOOL_SYSTEMMEM)
    {
        DPF_ERR("Index buffer pool should be default or managed or sysmem");
        return D3DERR_INVALIDCALL;
    }

    // Usage flag allowed for only mixed mode or software device
    if ((Usage & D3DUSAGE_SOFTWAREPROCESSING) != 0 && 
        (pDevice->BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING) == 0 &&
        (pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING) == 0)
    {
        DPF_ERR("D3DUSAGE_SOFTWAREPROCESSING can be set only when device is mixed mode. CreateIndexBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    // USAGE_DYNAMIC not allowed with management
    if ((Usage & D3DUSAGE_DYNAMIC) != 0 && Pool == D3DPOOL_MANAGED)
    {
        DPF_ERR("D3DUSAGE_DYNAMIC cannot be used with managed index buffers");
        return D3DERR_INVALIDCALL;
    }

    D3DPOOL ActualPool = Pool;
    DWORD ActualUsage = Usage;

    // Infer Lock from absence of LoadOnce
    if (!(Usage & D3DUSAGE_LOADONCE))
    {
        ActualUsage |= D3DUSAGE_LOCK;
    }

    // On a mixed device, POOL_SYSTEMMEM means the same as D3DUSAGE_SOFTWAREPROCESSING
    if ((pDevice->BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING) != 0 &&
        Pool == D3DPOOL_SYSTEMMEM)
    {
        ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING;
    }

    /*
     * Put a IB in system memory if the following conditions are TRUE
     * 1. USAGE_SOFTWAREPROCESSING is set or it is a software device and they want to clip
     * 2. HAL is pre-DX8 which means that the driver cannot support hardware IBs (but it might still create them because it doesn't know)
     * 3. Usage NPathes and driver does not support NPatches
    */
    if(!pDevice->DriverSupportsVidmemIBs() || !IS_DX8HAL_DEVICE(static_cast<LPD3DBASE>(pDevice)))
    {
        ActualPool = D3DPOOL_SYSTEMMEM;
        if(!IS_DX8HAL_DEVICE(static_cast<LPD3DBASE>(pDevice)))
        {
            ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING; // fe code will read from the IB
        }
    }
    if (((ActualUsage & D3DUSAGE_SOFTWAREPROCESSING) != 0 || (pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING) != 0) &&
        (ActualUsage & D3DUSAGE_DONOTCLIP) == 0)
    {
        if((ActualUsage & D3DUSAGE_INTERNALBUFFER) == 0)
        {
            if ((pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING) != 0 ||
                ActualPool == D3DPOOL_DEFAULT)
            {
                ActualPool = D3DPOOL_SYSTEMMEM; // For software processing, pool can be only sysmem (POOLMANAGED is overwritten)
            }
            ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING;
        }
    }
    if (ActualUsage & D3DUSAGE_NPATCHES &&
        (pDevice->GetD3DCaps()->DevCaps & D3DDEVCAPS_NPATCHES) == 0)
    {
        ActualPool = D3DPOOL_SYSTEMMEM;
        ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING;
    }

    CIndexBuffer *pIndexBuffer;

    if (ActualPool == D3DPOOL_SYSTEMMEM ||
        IsTypeD3DManaged(pDevice, D3DRTYPE_INDEXBUFFER, ActualPool))
    {
        hr = CreateSysmemIndexBuffer(pDevice,
                                     cbLength,
                                     Usage,
                                     ActualUsage,
                                     Format,
                                     Pool,
                                     ActualPool,
                                     refType,
                                     &pIndexBuffer);
    }
    else
    {
        if (IsTypeDriverManaged(pDevice, D3DRTYPE_INDEXBUFFER, ActualPool))
        {
            // If the index buffer is driver managed, but the usage is softwareprocessing, then
            // we turn off writeonly since the fe pipe WILL read from the sysmem backup (which
            // actually lives in the driver). It follows that when a driver manages a VB/IB without
            // writeonly, it MUST have a sysmem backup. (snene - 12/00)
            if ((ActualUsage & D3DUSAGE_SOFTWAREPROCESSING) != 0)
            {
                ActualUsage &= ~D3DUSAGE_WRITEONLY;
            }
            hr = CreateDriverManagedIndexBuffer(pDevice,
                                                cbLength,
                                                Usage,
                                                ActualUsage,
                                                Format,
                                                Pool,
                                                ActualPool,
                                                refType,
                                                &pIndexBuffer);
            // Driver managed index buffer creates can NEVER fail, except for catastrophic reasons so
            // we don't fallback to sysmem. Even if we do fallback to sysmem here, there is no way
            // deferred creates are going to fallback, so no point.
            if (FAILED(hr))
            {
                return hr;
            }
        }
        else
        {
            hr = CreateDriverIndexBuffer(pDevice,
                                         cbLength,
                                         Usage,
                                         ActualUsage,
                                         Format,
                                         Pool,
                                         ActualPool,
                                         refType,
                                         &pIndexBuffer);
        }
        if (FAILED(hr) && hr != D3DERR_OUTOFVIDEOMEMORY)
        {
            if (pDevice->VBFailOversDisabled())
            {
                DPF_ERR("Cannot create Vidmem or Driver managed index buffer. Will ***NOT*** failover to Sysmem.");
                return hr;
            }
            ActualPool = D3DPOOL_SYSTEMMEM;
            hr = CreateSysmemIndexBuffer(pDevice,
                                         cbLength,
                                         Usage,
                                         ActualUsage,
                                         Format,
                                         Pool,
                                         ActualPool,
                                         refType,
                                         &pIndexBuffer);
        }
    }

    if (FAILED(hr))
    {
        return hr;
    }

    // We're done; just return the object
    *ppIndexBuffer = pIndexBuffer;

    return hr;
} // static Create

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::CreateDriverIndexBuffer"

HRESULT CIndexBuffer::CreateDriverIndexBuffer(CBaseDevice *pDevice,
                                              DWORD        cbLength,
                                              DWORD        Usage,
                                              DWORD        ActualUsage,
                                              D3DFORMAT    Format,
                                              D3DPOOL      Pool,
                                              D3DPOOL      ActualPool,
                                              REF_TYPE     refType,
                                              CIndexBuffer **pIB)
{
    HRESULT hr;
    CDriverIndexBuffer *pIndexBuffer;

    // Zero out return
    *pIB = 0;

    if((pDevice->BehaviorFlags() & D3DCREATE_MULTITHREADED) != 0)
    {
        pIndexBuffer = new CDriverIndexBufferMT(pDevice,
                                                cbLength,
                                                Usage,
                                                ActualUsage,
                                                Format,
                                                Pool,
                                                ActualPool,
                                                refType,
                                                &hr);
    }
    else
    {
        pIndexBuffer = new CDriverIndexBuffer(pDevice,
                                              cbLength,
                                              Usage,
                                              ActualUsage,
                                              Format,
                                              Pool,
                                              ActualPool,
                                              refType,
                                              &hr);
    }
    if (pIndexBuffer == 0)
    {
        DPF_ERR("Out of Memory creating index buffer");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pIndexBuffer->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pIndexBuffer->DecrementUseCount();
        }
        return hr;
    }

    *pIB = static_cast<CIndexBuffer*>(pIndexBuffer);

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::CreateSysmemIndexBuffer"

HRESULT CIndexBuffer::CreateSysmemIndexBuffer(CBaseDevice *pDevice,
                                              DWORD        cbLength,
                                              DWORD        Usage,
                                              DWORD        ActualUsage,
                                              D3DFORMAT    Format,
                                              D3DPOOL      Pool,
                                              D3DPOOL      ActualPool,
                                              REF_TYPE     refType,
                                              CIndexBuffer **pIB)
{
    HRESULT hr;
    CIndexBuffer *pIndexBuffer;

    // Zero out return
    *pIB = 0;

    if((pDevice->BehaviorFlags() & D3DCREATE_MULTITHREADED) != 0)
    {
        pIndexBuffer = new CIndexBufferMT(pDevice,
                                          cbLength,
                                          Usage,
                                          ActualUsage,
                                          Format,
                                          Pool,
                                          ActualPool,
                                          refType,
                                          &hr);
    }
    else
    {
        pIndexBuffer = new CIndexBuffer(pDevice,
                                        cbLength,
                                        Usage,
                                        ActualUsage,
                                        Format,
                                        Pool,
                                        ActualPool,
                                        refType,
                                        &hr);
    }
    if (pIndexBuffer == 0)
    {
        DPF_ERR("Out of Memory creating index buffer");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pIndexBuffer->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pIndexBuffer->DecrementUseCount();
        }
        return hr;
    }

    *pIB = pIndexBuffer;

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::CreateDriverManagedIndexBuffer"

HRESULT CIndexBuffer::CreateDriverManagedIndexBuffer(CBaseDevice *pDevice,
                                                     DWORD        cbLength,
                                                     DWORD        Usage,
                                                     DWORD        ActualUsage,
                                                     D3DFORMAT    Format,
                                                     D3DPOOL      Pool,
                                                     D3DPOOL      ActualPool,
                                                     REF_TYPE     refType,
                                                     CIndexBuffer **pIB)
{
    HRESULT hr;
    CDriverManagedIndexBuffer *pIndexBuffer;

    // Zero out return
    *pIB = 0;

    if((pDevice->BehaviorFlags() & D3DCREATE_MULTITHREADED) != 0)
    {
        pIndexBuffer = new CDriverManagedIndexBufferMT(pDevice,
                                                       cbLength,
                                                       Usage,
                                                       ActualUsage,
                                                       Format,
                                                       Pool,
                                                       ActualPool,
                                                       refType,
                                                       &hr);
    }
    else
    {
        pIndexBuffer = new CDriverManagedIndexBuffer(pDevice,
                                                     cbLength,
                                                     Usage,
                                                     ActualUsage,
                                                     Format,
                                                     Pool,
                                                     ActualPool,
                                                     refType,
                                                     &hr);
    }
    if (pIndexBuffer == 0)
    {
        DPF_ERR("Out of Memory creating index buffer");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pIndexBuffer->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pIndexBuffer->DecrementUseCount();
        }
        return hr;
    }

    *pIB = static_cast<CIndexBuffer*>(pIndexBuffer);

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::CIndexBuffer"

// Constructor the Index Buffer class
CIndexBuffer::CIndexBuffer(CBaseDevice *pDevice,
                           DWORD        cbLength,
                           DWORD        Usage,
                           DWORD        ActualUsage,
                           D3DFORMAT    Format,
                           D3DPOOL      Pool,
                           D3DPOOL      ActualPool,
                           REF_TYPE     refType,
                           HRESULT     *phr
                           ):
    CBuffer(pDevice,
            cbLength,
            0,                      // dwFVF
            Format,
            D3DRTYPE_INDEXBUFFER,
            Usage,                  // UserUsage
            ActualUsage,
            Pool,                   // UserPool
            ActualPool,
            refType,
            phr)
{
    if (FAILED(*phr))
        return;

    m_desc.Size          = cbLength;
    m_desc.Format        = Format;
    m_desc.Pool          = ActualPool;
    m_desc.Usage         = ActualUsage;
    m_desc.Type          = D3DRTYPE_INDEXBUFFER;
    m_usageUser          = Usage;

    // If this is a D3D managed buffer then we need
    // to tell the Resource Manager to remember us. This has to happen
    // at the very end of the constructor so that the important data
    // members are built up correctly
    if (CResource::IsTypeD3DManaged(Device(), D3DRTYPE_INDEXBUFFER, ActualPool))
    {
        *phr = InitializeRMHandle();
    }
} // CIndexBuffer::CIndexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::Clone"
HRESULT CIndexBuffer::Clone(D3DPOOL     Pool,
                            CResource **ppResource) const
{
    HRESULT hr;
    CIndexBuffer *pIndexBuffer;
    // Note: we treat clones the same as internal; because
    // they are owned by the resource manager which
    // is owned by the device.
    hr = CreateDriverIndexBuffer(Device(),
                                 m_desc.Size,
                                 m_desc.Usage,
                                 (m_desc.Usage | D3DUSAGE_WRITEONLY) & ~D3DUSAGE_SOFTWAREPROCESSING, // never seen by API!
                                 m_desc.Format,                                 
                                 Pool,
                                 Pool, // never seen by API!
                                 REF_INTERNAL,
                                 &pIndexBuffer);
    *ppResource = static_cast<CResource*>(pIndexBuffer);
    return hr;
} // CIndexBuffer::Clone

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::UpdateDirtyPortion"

HRESULT CIndexBuffer::UpdateDirtyPortion(CResource *pResourceTarget)
{
    if (IsDirty())
    {
        if (Device()->CanBufBlt())
        {
            D3DRANGE range;
            if(m_cbDirtyMin == 0 && m_cbDirtyMax == 0)
            {
                range.Offset = 0;
                range.Size = m_desc.Size;
            }
            else
            {
                range.Offset = m_cbDirtyMin;
                range.Size = m_cbDirtyMax - m_cbDirtyMin;
            }
            HRESULT hr = static_cast<LPD3DBASE>(Device())->BufBlt(static_cast<CBuffer*>(pResourceTarget), this, m_cbDirtyMin, &range);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to copy index buffer");
                return hr;
            }
        }
        else
        {
            DXGASSERT(pResourceTarget->GetBufferDesc()->Pool == D3DPOOL_DEFAULT); // make sure that it is safe to assume that this is a driver VB
            CDriverIndexBuffer *pBufferTarget = static_cast<CDriverIndexBuffer *>(pResourceTarget);

            // Lock the dest (driver) index buffer. It can never be dynamic, so it does
            // not need any unlocking.
            DXGASSERT((pBufferTarget->m_desc.Usage & D3DUSAGE_DYNAMIC) == 0);

            HRESULT hr = pBufferTarget->LockI(D3DLOCK_NOSYSLOCK);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to lock driver index buffer");
                return hr;
            }
            DXGASSERT(pBufferTarget->m_pbData != 0);

            if(m_cbDirtyMin == 0 && m_cbDirtyMax == 0)
            {
                memcpy(pBufferTarget->m_pbData, GetPrivateDataPointer(), m_desc.Size);
            }
            else
            {
                memcpy(pBufferTarget->m_pbData + m_cbDirtyMin, GetPrivateDataPointer() + m_cbDirtyMin, m_cbDirtyMax - m_cbDirtyMin);
            }

            hr = pBufferTarget->UnlockI();
            if (FAILED(hr))
            {
                DPF_ERR("Failed to unlock driver index buffer");
                return hr;
            }
        }

        // Mark ourselves as all clean now.
        OnResourceClean();
    }

    return S_OK;
} // CIndexBuffer::UpdateDirtyPortion

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::GetBufferDesc"
const D3DBUFFER_DESC* CIndexBuffer::GetBufferDesc() const
{
    return (const D3DBUFFER_DESC*)&m_desc;
} // CIndexBuffer::GetBufferDesc

// IUnknown methods
#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::QueryInterface"

STDMETHODIMP CIndexBuffer::QueryInterface(REFIID riid,
                                          LPVOID FAR * ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter passed to CIndexBuffer::QueryInterface");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for an IndexBuffer");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DIndexBuffer8 ||
        riid == IID_IDirect3DResource8    ||
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DIndexBuffer8 *>(this));
        AddRef();
        return S_OK;
    }


    DPF_ERR("Unsupported Interface identifier passed to QueryInterface for an IndexBuffer");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::AddRef"

STDMETHODIMP_(ULONG) CIndexBuffer::AddRef()
{
    API_ENTER_NO_LOCK(Device());

    return AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::Release"

STDMETHODIMP_(ULONG) CIndexBuffer::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());    

    return ReleaseImpl();
} // Release

// IDirect3DBuffer methods

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::GetDesc"

STDMETHODIMP CIndexBuffer::GetDesc(D3DINDEXBUFFER_DESC *pDesc)
{
    API_ENTER(Device());

    if (!VALID_WRITEPTR(pDesc, sizeof(D3DINDEXBUFFER_DESC)))
    {
        DPF_ERR("bad pointer for pDesc passed to GetDesc for an IndexBuffer");
        return D3DERR_INVALIDCALL;
    }

    *pDesc = m_desc;

    // Need to return pool/usage that the user specified
    pDesc->Pool    = GetUserPool();
    pDesc->Usage   = m_usageUser;

    return S_OK;
} // GetDesc

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::GetDevice"

STDMETHODIMP CIndexBuffer::GetDevice(IDirect3DDevice8 ** ppObj)
{
    API_ENTER(Device());

    return GetDeviceImpl(ppObj);
} // GetDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::SetPrivateData"

STDMETHODIMP CIndexBuffer::SetPrivateData(REFGUID   riid,
                                          CONST VOID     *pvData,
                                          DWORD     cbData,
                                          DWORD     dwFlags)
{
    API_ENTER(Device());

    // We use level zero for our data
    return SetPrivateDataImpl(riid, pvData, cbData, dwFlags, 0);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::GetPrivateData"

STDMETHODIMP CIndexBuffer::GetPrivateData(REFGUID   riid,
                                          LPVOID    pvData,
                                          LPDWORD   pcbData)
{
    API_ENTER(Device());

    // We use level zero for our data
    return GetPrivateDataImpl(riid, pvData, pcbData, 0);
} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::FreePrivateData"

STDMETHODIMP CIndexBuffer::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    // We use level zero for our data
    return FreePrivateDataImpl(riid, 0);
} // FreePrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::GetPriority"

STDMETHODIMP_(DWORD) CIndexBuffer::GetPriority()
{
    API_ENTER_RET(Device(), DWORD);

    return GetPriorityImpl();
} // GetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::SetPriority"

STDMETHODIMP_(DWORD) CIndexBuffer::SetPriority(DWORD dwPriority)
{
    API_ENTER_RET(Device(), DWORD);

    return SetPriorityImpl(dwPriority);
} // SetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::PreLoad"

STDMETHODIMP_(void) CIndexBuffer::PreLoad(void)
{
    API_ENTER_VOID(Device());

    PreLoadImpl();
    return;
} // PreLoad

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::GetType"
STDMETHODIMP_(D3DRESOURCETYPE) CIndexBuffer::GetType(void)
{
    API_ENTER_RET(Device(), D3DRESOURCETYPE);

    return m_desc.Type;
} // GetType

// IDirect3DIndexBuffer8 methods

#if DBG
#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::ValidateLockParams"
HRESULT CIndexBuffer::ValidateLockParams(UINT cbOffsetToLock,
                                         UINT SizeToLock,
                                         BYTE **ppbData,
                                         DWORD dwFlags) const
{
    if (!VALID_PTR_PTR(ppbData))
    {
        DPF_ERR("Bad parameter passed for ppbData for creating a index buffer");
        return D3DERR_INVALIDCALL;
    }

    // Zero out return params
    *ppbData = NULL;

    if ((cbOffsetToLock != 0) && (SizeToLock == 0))
    {
        DPF_ERR("Cannot lock zero bytes. Lock IndexBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    if (dwFlags & ~(D3DLOCK_VALID & ~D3DLOCK_NO_DIRTY_UPDATE)) // D3DLOCK_NO_DIRTY_UPDATE not valid for IBs
    {
        DPF_ERR("Invalid flags specified. Lock IndexBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    // If a load-once is already loaded then
    // we're not lockable
    if (!m_isLockable)
    {
        DPF_ERR("Index buffer with D3DUSAGE_LOADONCE can only be locked once");
        return D3DERR_INVALIDCALL;
    }
    if ((dwFlags & (D3DLOCK_DISCARD | D3DLOCK_NOOVERWRITE)) != 0 && (m_usageUser & D3DUSAGE_DYNAMIC) == 0)
    {
        DPF_ERR("Can specify D3DLOCK_DISCARD or D3DLOCK_NOOVERWRITE for only Index Buffers created with D3DUSAGE_DYNAMIC");
        return D3DERR_INVALIDCALL;
    }
    if ((dwFlags & (D3DLOCK_READONLY | D3DLOCK_DISCARD)) == (D3DLOCK_READONLY | D3DLOCK_DISCARD))
    {
        DPF_ERR("Should not specify D3DLOCK_DISCARD along with D3DLOCK_READONLY. Index Buffer Lock fails.");
        return D3DERR_INVALIDCALL;
    }
    if ((dwFlags & D3DLOCK_READONLY) != 0 && (m_usageUser & D3DUSAGE_WRITEONLY) != 0)
    {
        DPF_ERR("Cannot do READ_ONLY lock on a WRITE_ONLY buffer. Index Buffer Lock fails");
        return D3DERR_INVALIDCALL;
    }

    if (ULONGLONG(cbOffsetToLock) + ULONGLONG(SizeToLock) > ULONGLONG(m_desc.Size))
    {
        DPF_ERR("Lock failed: Locked area exceeds size of buffer. Index Buffer Lock fails.");
        return D3DERR_INVALIDCALL;
    }

    if (m_LockCount == 0)
    {
        if ((m_usageUser & D3DUSAGE_DYNAMIC) == 0)
        {
            if (static_cast<CD3DBase*>(Device())->m_SceneStamp == m_SceneStamp &&
                (m_usageUser & D3DUSAGE_WRITEONLY) != 0 &&
                GetUserPool() != D3DPOOL_SYSTEMMEM)
            {
                DPF(1, "Static index buffer locked more than once per frame. Could have severe performance penalty.");
            }
            ((CIndexBuffer*)this)->m_SceneStamp = static_cast<CD3DBase*>(Device())->m_SceneStamp;
        }
        else
        {
            if ((dwFlags & (D3DLOCK_DISCARD | D3DLOCK_NOOVERWRITE)) == 0)
            {
                if (m_TimesLocked > 0 &&
                    (m_usageUser & D3DUSAGE_WRITEONLY) != 0 &&
                    GetUserPool() != D3DPOOL_SYSTEMMEM)
                {
                    DPF(3, "Dynamic index buffer locked twice or more in a row without D3DLOCK_NOOVERWRITE or D3DLOCK_DISCARD. Could have severe performance penalty.");
                }
                ++(((CIndexBuffer*)this)->m_TimesLocked);
            }
            else
            {
                ((CIndexBuffer*)this)->m_TimesLocked = 0;
            }
        }
    }

    DXGASSERT(m_LockCount < 0x80000000);

    return S_OK;
} // ValidateLockParams
#endif // DBG

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::Lock"

STDMETHODIMP CIndexBuffer::Lock(UINT    cbOffsetToLock,
                                UINT    SizeToLock,
                                BYTE  **ppbData,
                                DWORD   dwFlags)
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    HRESULT hr = ValidateLockParams(cbOffsetToLock, SizeToLock, ppbData, dwFlags);
    if (FAILED(hr))
    {
        return hr;
    }
#endif // DBG

// Sanity check
#if DBG
    if (m_LockCount != 0)
    {
        DXGASSERT(GetPrivateDataPointer() != 0);
    }
#endif // DBG

    // Increment our lock count
    ++m_LockCount;

    if ((dwFlags & (D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE)) == 0 && m_LockCount == 1) // for repeat locks, no syncing
    {
        Sync(); // Sync with device command queue
    }

    LockImpl(cbOffsetToLock,
             SizeToLock,
             ppbData,
             dwFlags,
             m_desc.Size);
    
    return S_OK;
} // Lock

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::Unlock"

STDMETHODIMP CIndexBuffer::Unlock()
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    // If we aren't locked; then something is wrong
    if (m_LockCount == 0)
    {
        DPF_ERR("Unlock failed on an index buffer; index buffer wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
#endif // DBG

    // Decrement our lock count
    --m_LockCount;

#if DBG
    if ((m_usageUser & D3DUSAGE_LOADONCE) != 0 && m_LockCount == 0)
    {
        m_isLockable = FALSE;
    }
#endif // DBG

    return S_OK;
} // Unlock

//=============================================
// Methods for the CDriverIndexBuffer class
//=============================================
#undef DPF_MODNAME
#define DPF_MODNAME "CDriverIndexBuffer::CDriverIndexBuffer"
CDriverIndexBuffer::CDriverIndexBuffer(CBaseDevice *pDevice,
                                       DWORD        cbLength,
                                       DWORD        Usage,
                                       DWORD        ActualUsage,
                                       D3DFORMAT    Format,
                                       D3DPOOL      Pool,
                                       D3DPOOL      ActualPool,
                                       REF_TYPE     refType,
                                       HRESULT     *phr
                                       ) :
    CIndexBuffer(pDevice,
                 cbLength,
                 Usage,
                 ActualUsage,
                 Format,
                 Pool,
                 ActualPool,
                 refType,
                 phr),
    m_pbData(0)
{
    if (FAILED(*phr))
    {
        DPF(2, "Failed to create driver indexbuffer");
        return;
    }
} // CDriverIndexBuffer::CDriverIndexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverIndexBuffer::~CDriverIndexBuffer"
CDriverIndexBuffer::~CDriverIndexBuffer()
{
    if (m_pbData != 0)
    {
        HRESULT hr = UnlockI();
        if (FAILED(hr))
        {
            DPF_ERR("Failed to unlock driver index buffer");
        }
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverIndexBuffer::Lock"

STDMETHODIMP CDriverIndexBuffer::Lock(UINT cbOffsetToLock,
                                      UINT SizeToLock,
                                      BYTE **ppbData,
                                      DWORD dwFlags)
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    HRESULT hr = ValidateLockParams(cbOffsetToLock, SizeToLock, ppbData, dwFlags);
    if (FAILED(hr))
    {
        return hr;
    }
#endif // DBG

// Sanity check
#if DBG
    if (m_LockCount != 0)
    {
        DXGASSERT(m_pbData != 0);
    }
#endif // DBG

    // Increment our lock count
    ++m_LockCount;

    if (((dwFlags & (D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE)) == 0 || m_pbData == 0) && m_LockCount == 1) // no work for repeat locks
    {
        HRESULT hr;

        if (m_pbData != 0) // If lock was cached
        {
            DXGASSERT((m_desc.Usage & D3DUSAGE_DYNAMIC) != 0);
            hr = UnlockI();
            if (FAILED(hr))
            {
                DPF_ERR("Driver failed to unlock index buffer");
                *ppbData = 0;
                --m_LockCount;
                return hr;
            }
        }

        hr = LockI(dwFlags | D3DLOCK_NOSYSLOCK);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to lock driver indexbuffer");
            *ppbData = 0;
            --m_LockCount;
            return hr;
        }
    }

    // Return value
    *ppbData = m_pbData + cbOffsetToLock;

    // Done
    return S_OK;
} // Lock

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverIndexBuffer::LockI"
HRESULT CDriverIndexBuffer::LockI(DWORD dwFlags)
{
    // We sync first to make sure that the
    // driver has already processed any data that
    // it needs. LockI only gets called if for
    // cases where we need the interlock i.e.
    // not readonly and not nooverwrite.
    Sync();

    // Prepare a LockData structure for the HAL call
    D3D8_LOCKDATA lockData;
    ZeroMemory(&lockData, sizeof lockData);

    lockData.hDD = Device()->GetHandle();
    lockData.hSurface = BaseKernelHandle();
    lockData.bHasRange = FALSE;
    lockData.dwFlags = dwFlags;

    HRESULT hr = Device()->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to lock driver index buffer");
    }

    // Return value
    m_pbData = (BYTE*)lockData.lpSurfData;

    return hr;
} // LockI

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverIndexBuffer::Unlock"

STDMETHODIMP CDriverIndexBuffer::Unlock()
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    // If we aren't locked; then something is wrong
    if (m_LockCount == 0)
    {
        DPF_ERR("Unlock failed on a Index buffer; buffer wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
#endif // DBG

    if ((m_desc.Usage & D3DUSAGE_DYNAMIC) == 0 && m_LockCount == 1) // Do work only for the last unlock
    {
        HRESULT hr = UnlockI();
        if (FAILED(hr))
        {
            DPF_ERR("Driver failed to unlock index buffer");
            return hr;
        }
    }

    // Decrement our lock count
    --m_LockCount;

#if DBG
    if ((m_usageUser & D3DUSAGE_LOADONCE) != 0 && m_LockCount == 0)
    {
        m_isLockable = FALSE;
    }
#endif // DBG

    // Done
    return S_OK;
} // Unlock

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverIndexBuffer::UnlockI"

HRESULT CDriverIndexBuffer::UnlockI()
{
    DXGASSERT(m_pbData != 0);

    // Call the driver to perform the unlock
    D3D8_UNLOCKDATA unlockData = {
        Device()->GetHandle(),
        BaseKernelHandle()
    };

    HRESULT hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
    if (FAILED(hr))
    {
        DPF_ERR("Driver index buffer failed to unlock");
        return hr;
    }

    m_pbData = 0;

    return hr;
}

//================================================
// Methods for the CDriverManagedIndexBuffer class
//================================================
#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedIndexBuffer::CDriverManagedIndexBuffer"
CDriverManagedIndexBuffer::CDriverManagedIndexBuffer(CBaseDevice *pDevice,
                                                     DWORD        cbLength,
                                                     DWORD        Usage,
                                                     DWORD        ActualUsage,
                                                     D3DFORMAT    Format,
                                                     D3DPOOL      Pool,
                                                     D3DPOOL      ActualPool,
                                                     REF_TYPE     refType,
                                                     HRESULT     *phr
                                                     ) :
    CIndexBuffer(pDevice,
                 cbLength,
                 Usage,
                 ActualUsage,
                 Format,
                 Pool,
                 ActualPool,
                 refType,
                 phr),
    m_pbData(0),
    m_bDriverCalled(FALSE)
{
    if (FAILED(*phr))
        return;
    // If writeonly is not set, we assume that the vertex/index buffer is going
    // to be read from from time to time. Hence, for optimizing the readonly
    // locks, we lock and cache the pointer. (snene - 12/00)
    if ((ActualUsage & D3DUSAGE_WRITEONLY) == 0)
    {
        *phr = UpdateCachedPointer(pDevice);
        if (FAILED(*phr))
            return;
    }
} // CDriverManagedIndexBuffer::CDriverManagedIndexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedIndexBuffer::UpdateCachedPointer"

HRESULT CDriverManagedIndexBuffer::UpdateCachedPointer(CBaseDevice *pDevice)
{
    HRESULT hr;

    // Prepare a LockData structure for the HAL call
    D3D8_LOCKDATA lockData;
    ZeroMemory(&lockData, sizeof lockData);
    
    lockData.hDD = pDevice->GetHandle();
    lockData.hSurface = BaseKernelHandle();
    lockData.bHasRange = FALSE;
    lockData.range.Offset = 0;
    lockData.range.Size = 0;
    lockData.dwFlags = D3DLOCK_READONLY;
    
    hr = pDevice->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
        return hr;
    
    // Call the driver to perform the unlock
    D3D8_UNLOCKDATA unlockData = {
        pDevice->GetHandle(),
            BaseKernelHandle()
    };
    
    hr = pDevice->GetHalCallbacks()->Unlock(&unlockData);
    if (FAILED(hr))
        return hr;
    
    m_pbData = (BYTE*)lockData.lpSurfData;

    return S_OK;
} // CDriverManagedIndexBuffer::UpdateCachedPointer

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedIndexBuffer::Lock"

STDMETHODIMP CDriverManagedIndexBuffer::Lock(UINT cbOffsetToLock,
                                             UINT SizeToLock,
                                             BYTE **ppbData,
                                             DWORD dwFlags)
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

    HRESULT hr = S_OK;

#if DBG
    hr = ValidateLockParams(cbOffsetToLock, SizeToLock, ppbData, dwFlags);
    if (FAILED(hr))
    {
        return hr;
    }
#endif // DBG

    // Increment our lock count
    ++m_LockCount;

    if((dwFlags & D3DLOCK_READONLY) == 0)
    {
        // Sync with device command queue
        Sync();

        // Prepare a LockData structure for the HAL call
        D3D8_LOCKDATA lockData;
        ZeroMemory(&lockData, sizeof lockData);

        lockData.hDD = Device()->GetHandle();
        lockData.hSurface = BaseKernelHandle();
        lockData.bHasRange = (SizeToLock != 0);
        lockData.range.Offset = cbOffsetToLock;
        lockData.range.Size = SizeToLock;
        lockData.dwFlags = dwFlags;

        hr = Device()->GetHalCallbacks()->Lock(&lockData);
        if (FAILED(hr))
        {
            *ppbData = 0;
            DPF_ERR("Failed to lock driver managed index buffer");
            return hr;
        }
        else
        {
            // Update cached pointer
            m_pbData = (BYTE*)lockData.lpSurfData - cbOffsetToLock;
            m_bDriverCalled = TRUE;
        }
    }

    *ppbData = m_pbData + cbOffsetToLock;

    // Done
    return hr;
} // Lock

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedIndexBuffer::Unlock"

STDMETHODIMP CDriverManagedIndexBuffer::Unlock()
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    // If we aren't locked; then something is wrong
    if (m_LockCount == 0)
    {
        DPF_ERR("Unlock failed on a index buffer; buffer wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
#endif

    if (m_bDriverCalled)
    {
        // Call the driver to perform the unlock
        D3D8_UNLOCKDATA unlockData = {
            Device()->GetHandle(),
            BaseKernelHandle()
        };

        HRESULT hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
        if (FAILED(hr))
        {
            DPF_ERR("Driver index buffer failed to unlock");
            return hr;
        }

        m_bDriverCalled = FALSE;
    }

    // Decrement our lock count
    --m_LockCount;

#if DBG
    if ((m_usageUser & D3DUSAGE_LOADONCE) != 0 && m_LockCount == 0)
    {
        m_isLockable = FALSE;
    }
#endif // DBG

    return S_OK;
} // Unlock

// End of file : ibuffer.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\mipmap.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mipmap.cpp
 *  Content:    Implementation of the CMipMap class. 
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"

#include "mipmap.hpp"
#include "mipsurf.hpp"
#include "d3di.hpp"
#include "resource.inl"

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::Create"

// Static class function for creating a mip-map object.
//
// We do all parameter checking here to reduce the overhead
// in the constructor which is called by the internal Clone
// method which is used by resource management as part of the
// performance critical download operation.

HRESULT CMipMap::Create(CBaseDevice         *pDevice, 
                        DWORD                Width,
                        DWORD                Height,
                        DWORD                cLevels,
                        DWORD                Usage,
                        D3DFORMAT            UserFormat,
                        D3DPOOL              Pool,
                        IDirect3DTexture8  **ppMipMap)
{
    HRESULT hr;

    // Do parameter checking here
    if (!VALID_PTR_PTR(ppMipMap))
    {
        DPF_ERR("Bad parameter passed pTexture. CreateTexture failed");
        return D3DERR_INVALIDCALL;
    }

    // Zero-out return parameter
    *ppMipMap = NULL;

    // Check if format is valid
    hr = Validate(pDevice, 
                  D3DRTYPE_TEXTURE, 
                  Pool, 
                  Usage, 
                  UserFormat);
    if (FAILED(hr))
    {
        // Validate does it's own DPFing
        return D3DERR_INVALIDCALL;
    }


    // Infer internal usage flags
    Usage = InferUsageFlags(Pool, Usage, UserFormat);

    // Expand cLevels if necessary
    if (cLevels == 0)
    {
        // See if HW can mip
        if ( (Pool != D3DPOOL_SCRATCH) && !(pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_MIPMAP))
        {
            // Can't mip so use 1
            cLevels = 1;
        }
        else
        {
            // Determine number of levels
            cLevels = ComputeLevels(Width, Height);
        }
    }

    // Extra checks for multi-level case
    if (cLevels > 1)
    {
        if ((Width  >> (cLevels - 1)) == 0 &&
            (Height >> (cLevels - 1)) == 0)
        {
            DPF_ERR("Too many levels for mip-map of this size. CreateTexture failed.");
            return D3DERR_INVALIDCALL;
        }
    }

    if (cLevels > 32)
    {
        DPF_ERR("No more than 32 levels are supported. CreateTexture failed");

        // This limitation is based on the number of
        // bits that we have allocated for iLevel in 
        // some of the supporting classes.
        return D3DERR_INVALIDCALL;
    }

    D3DFORMAT RealFormat = UserFormat;

    // Start parameter checking
    if(Pool != D3DPOOL_SCRATCH)
    {
        //device-specific checking:

        // Check if device can do mipmaps
        if (cLevels > 1)
        {
            if (!(pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_MIPMAP))
            {
                DPF_ERR("Device doesn't support mip-map textures; CreateTexture failed.");
                return D3DERR_INVALIDCALL;
            }
        }

        // Check power-of-two constraints
        if (!IsPowerOfTwo(Width))
        {
            if (pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_POW2)
            {
                if (!(pDevice->GetD3DCaps()->TextureCaps &
                      D3DPTEXTURECAPS_NONPOW2CONDITIONAL))
                {
                    DPF_ERR("Device does not support non-pow2 width for texture");
                    return D3DERR_INVALIDCALL;
                }
                else if (cLevels > 1)
                {  
                    DPF_ERR("Device doesn't support non-pow2 width for multi-level texture");
                    return D3DERR_INVALIDCALL;
                }
            }
        }

        if (!IsPowerOfTwo(Height))
        {
            if (pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_POW2)
            {
                if (!(pDevice->GetD3DCaps()->TextureCaps &
                      D3DPTEXTURECAPS_NONPOW2CONDITIONAL))
                {
                    DPF_ERR("Device does not support non-pow2 height for texture. CreateTexture failed.");
                    return D3DERR_INVALIDCALL;
                }
                else if (cLevels > 1)
                {  
                    DPF_ERR("Device doesn't support non-pow2 height for multi-level texture. CreateTexture failed.");
                    return D3DERR_INVALIDCALL;
                }
            }
        }

        // See if the device requires square textures
        if (Width != Height)
        {
            if (pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_SQUAREONLY)
            {
                DPF_ERR("Device requires square textures only. CreateTexture failed.");
                return D3DERR_INVALIDCALL;
            }
        }

        // Check texture size restrictions
        if (Width > pDevice->GetD3DCaps()->MaxTextureWidth)
        {
            DPF_ERR("Texture width is larger than what the device supports. CreateTexture failed.");
            return D3DERR_INVALIDCALL;
        }

        if (Height > pDevice->GetD3DCaps()->MaxTextureHeight)
        {
            DPF_ERR("Texture height is larger than what the device supports. CreateTexture failed.");
            return D3DERR_INVALIDCALL;
        }

        // Extra checks for multi-level case
        if (cLevels > 1)
        {
            // Check if the device can do multi-level mipmaps.
            if (!(pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_MIPMAP))
            {
                DPF_ERR("Device doesn't support multi-level mipmaps. CreateTexture failed.");
                return D3DERR_INVALIDCALL;
            }
        }

        // Map Depth/Stencil formats; returns no change if no
        // mapping is needed
        RealFormat = pDevice->MapDepthStencilFormat(UserFormat);
    }

    // Size may need to be 4x4
    if (CPixel::Requires4X4(UserFormat))
    {
        if ((Width & 3) ||
            (Height & 3))
        {
            DPF_ERR("DXT Formats require width/height to be a multiple of 4. CreateTexture failed.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Validate against zero width/height
    if (Width   == 0 ||
        Height  == 0)
    {
        DPF_ERR("Width and Height must be non-zero. CreateTexture failed."); 
        return D3DERR_INVALIDCALL;
    }


    // We don't need to check if the HW can do textures since we
    // fail create if we find no texturing support

    // Allocate a new MipMap object and return it
    CMipMap *pMipMap = new CMipMap(pDevice, 
                                   Width, 
                                   Height, 
                                   cLevels,
                                   Usage,
                                   UserFormat,
                                   RealFormat,
                                   Pool,
                                   REF_EXTERNAL,
                                  &hr);
    if (pMipMap == NULL)
    {
        DPF_ERR("Out of Memory creating texture. CreateTexture failed.");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        DPF_ERR("Error during initialization of texture. CreateTexture failed.");
        pMipMap->ReleaseImpl();
        return hr;
    }

    // We're done; just return the object
    *ppMipMap = pMipMap;

    return hr;
} // static Create


#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::CMipMap"

// Constructor for the mip map class
CMipMap::CMipMap(CBaseDevice *pDevice, 
                 DWORD        Width,
                 DWORD        Height,
                 DWORD        cLevels,
                 DWORD        Usage,
                 D3DFORMAT    UserFormat,
                 D3DFORMAT    RealFormat,
                 D3DPOOL      UserPool,
                 REF_TYPE     refType,
                 HRESULT     *phr
                 ) :
    CBaseTexture(pDevice, cLevels, UserPool, UserFormat, refType),
    m_prgMipSurfaces(NULL),
    m_rgbPixels(NULL),
    m_cRectUsed(MIPMAP_ALLDIRTY)
{
    // Initialize basic structures
    m_desc.Format           = RealFormat;
    m_desc.Pool             = UserPool;
    m_desc.Usage            = Usage;
    m_desc.Type             = D3DRTYPE_TEXTURE;
    m_desc.MultiSampleType  = D3DMULTISAMPLE_NONE;
    m_desc.Width            = Width;
    m_desc.Height           = Height;

    // Estimate size of memory allocation
    m_desc.Size   = CPixel::ComputeMipMapSize(Width, 
                                              Height, 
                                              cLevels, 
                                              RealFormat);

    // Allocate Pixel Data for SysMem or D3DManaged cases
    if (IS_D3D_ALLOCATED_POOL(UserPool) ||
        IsTypeD3DManaged(Device(), D3DRTYPE_TEXTURE, UserPool))
    {
        m_rgbPixels     = new BYTE[m_desc.Size];
        if (m_rgbPixels == NULL)
        {
            DPF_ERR("Out of memory allocating memory for mip-map levels.");
            *phr = E_OUTOFMEMORY;
            return;
        }

        // Mark our real pool as sys-mem
        m_desc.Pool = D3DPOOL_SYSTEMMEM;
    }

    // Create the DDSURFACEINFO array and CreateSurfaceData object
    DXGASSERT(cLevels <= 32);

    DDSURFACEINFO SurfInfo[32];
    ZeroMemory(SurfInfo, sizeof(SurfInfo));

    D3D8_CREATESURFACEDATA CreateSurfaceData;
    ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

    // Set up the basic information
    CreateSurfaceData.hDD      = pDevice->GetHandle();
    CreateSurfaceData.pSList   = &SurfInfo[0];
    CreateSurfaceData.dwSCnt   = cLevels;
    CreateSurfaceData.Type     = D3DRTYPE_TEXTURE;
    CreateSurfaceData.dwUsage  = m_desc.Usage;
    CreateSurfaceData.Format   = RealFormat;
    CreateSurfaceData.MultiSampleType = D3DMULTISAMPLE_NONE;
    CreateSurfaceData.Pool     = DetermineCreationPool(Device(), 
                                                       D3DRTYPE_TEXTURE,
                                                       Usage, 
                                                       UserPool);

    // Iterate of each level to create the individual level
    // data
    for (DWORD iLevel = 0; iLevel < cLevels; iLevel++)
    {
        // Fill in the relevant information
        DXGASSERT(Width >= 1);
        DXGASSERT(Height >= 1);
        SurfInfo[iLevel].cpWidth  = Width;
        SurfInfo[iLevel].cpHeight = Height;

        // If we allocated the memory, pass down
        // the sys-mem pointers
        if (m_rgbPixels)
        {
            D3DLOCKED_RECT lock;
            ComputeMipMapOffset(iLevel, 
                                NULL,       // pRect
                                &lock);

            SurfInfo[iLevel].pbPixels = (BYTE*)lock.pBits;
            SurfInfo[iLevel].iPitch   = lock.Pitch;
            
        }

        // Scale width and height down
        if (Width > 1)
        {
            Width >>= 1;
        }
        if (Height > 1)
        {
            Height >>= 1;
        }
    }

    // Allocate array of pointers to MipSurfaces
    m_prgMipSurfaces = new CMipSurface*[cLevels];
    if (m_prgMipSurfaces == NULL)
    {
        DPF_ERR("Out of memory creating mipmap");
        *phr = E_OUTOFMEMORY;
        return;
    }

    // Zero the memory for safe cleanup
    ZeroMemory(m_prgMipSurfaces, sizeof(*m_prgMipSurfaces) * cLevels);

    if (UserPool != D3DPOOL_SCRATCH)
    {
        // Call the HAL to create this surface
        *phr = pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
        if (FAILED(*phr))
            return;

        // NOTE: any failures after this point needs to free up some
        // kernel handles

        // Remember what pool we really got
        m_desc.Pool = CreateSurfaceData.Pool;

        // We need to remember the handles from the top most
        // level of the mip-map
        SetKernelHandle(SurfInfo[0].hKernelHandle);
    }

    // Create and Initialize each MipLevel
    for (iLevel = 0; iLevel < cLevels; iLevel++)
    {
        // Is this a sys-mem or scratch surface; could be d3d managed
        if (IS_D3D_ALLOCATED_POOL(m_desc.Pool))
        {
            m_prgMipSurfaces[iLevel] = 
                    new CMipSurface(this, 
                                    (BYTE)iLevel,
                                    SurfInfo[iLevel].hKernelHandle);
        }
        else
        {
            // Must be a driver kind of surface; could be driver managed
            m_prgMipSurfaces[iLevel] = 
                    new CDriverMipSurface(this, 
                                          (BYTE)iLevel,
                                          SurfInfo[iLevel].hKernelHandle);
        }

        if (m_prgMipSurfaces[iLevel] == NULL)
        {
            DPF_ERR("Out of memory creating miplevel");
            *phr = E_OUTOFMEMORY;

            if (UserPool != D3DPOOL_SCRATCH)
            {
                // Need to free handles that we got before we return; we
                // only free the ones that weren't successfully entrusted
                // to a CMipSurf because those will be cleaned up automatically
                // at their destructor
                for (UINT i = iLevel; i < cLevels; i++)
                {
                    DXGASSERT(SurfInfo[i].hKernelHandle);

                    D3D8_DESTROYSURFACEDATA DestroySurfData;
                    DestroySurfData.hDD = Device()->GetHandle();
                    DestroySurfData.hSurface = SurfInfo[i].hKernelHandle;
                    Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
                }
            }

            return;
        }
    }

    // If this is a D3D managed mipmap then we need 
    // to tell the Resource Manager to remember us. This has to happen
    // at the very end of the constructor so that the important data
    // members are built up correctly
    if (CResource::IsTypeD3DManaged(Device(), D3DRTYPE_TEXTURE, UserPool))
    {
        *phr = InitializeRMHandle();
    }

    return;
} // CMipMap::CMipMap


#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::~CMipMap"

// Destructor
CMipMap::~CMipMap()
{
    // The destructor has to handle partially
    // created objects. Delete automatically
    // handles NULL; and members are nulled
    // as part of core constructors

    if (m_prgMipSurfaces)
    {
        for (DWORD i = 0; i < m_cLevels; i++)
        {
            delete m_prgMipSurfaces[i];
        }
        delete [] m_prgMipSurfaces;
    }
    delete [] m_rgbPixels;
} // CMipMap::~CMipMap

// Methods for the Resource Manager

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::Clone"

// Specifies a creation of a resource that
// looks just like the current one; in a new POOL
// with a new LOD.
HRESULT CMipMap::Clone(D3DPOOL     Pool, 
                       CResource **ppResource) const

{
    // NULL out parameter
    *ppResource = NULL;

    // Determine the number of levels/width/height
    // of the clone
    DWORD cLevels  = GetLevelCountImpl();
    DWORD Width  = m_desc.Width;
    DWORD Height = m_desc.Height;

    DWORD dwLOD = GetLODI();

    // If LOD is zero, then there are no changes
    if (dwLOD > 0)
    {
        // Clamp LOD to cLevels-1
        if (dwLOD >= cLevels)
        {
            dwLOD = cLevels - 1;
        }

        // scale down the destination texture
        // to correspond the appropiate max lod
        Width  >>= dwLOD;
        if (Width == 0)
            Width = 1;

        Height >>= dwLOD;
        if (Height == 0)
            Height = 1;

        // Reduce the number based on the our max lod.
        cLevels -= dwLOD;
    }

    // Sanity checking
    DXGASSERT(cLevels  >= 1);
    DXGASSERT(Width  >  0);
    DXGASSERT(Height >  0);

    // Create the new mip-map object now

    // Note: we treat clones as REF_INTERNAL; because
    // they are owned by the resource manager which 
    // is owned by the device. 

    // Also, we adjust the usage to disable lock-flags
    // since we don't need lockability
    DWORD Usage = m_desc.Usage;
    Usage &= ~(D3DUSAGE_LOCK | D3DUSAGE_LOADONCE);

    HRESULT hr;
    CResource *pResource = new CMipMap(Device(),
                                       Width,
                                       Height,
                                       cLevels,
                                       Usage,
                                       m_desc.Format,   // UserFormat
                                       m_desc.Format,   // RealFormat
                                       Pool,
                                       REF_INTERNAL,
                                       &hr);
    
    if (pResource == NULL)
    {
        DPF_ERR("Failed to allocate mip-map object when copying");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        DPF(5, "Failed to create mip-map when doing texture management");
        pResource->DecrementUseCount();
        return hr;
    }

    *ppResource = pResource;

    return hr;
} // CMipMap::Clone

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetBufferDesc"

// Provides a method to access basic structure of the
// pieces of the resource. A resource may be composed
// of one or more buffers.
const D3DBUFFER_DESC* CMipMap::GetBufferDesc() const
{
    return (const D3DBUFFER_DESC*)&m_desc;
} // CMipMap::GetBufferDesc



// IUnknown methods
#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::QueryInterface"

STDMETHODIMP CMipMap::QueryInterface(REFIID       riid, 
                                     LPVOID FAR * ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter for a IDirect3DTexture8::QueryInterface");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to IDirect3DTexture8::QueryInterface");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DTexture8       || 
        riid == IID_IDirect3DBaseTexture8   ||
        riid == IID_IDirect3DResource8      ||
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DTexture8 *>(this));
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to IDirect3DTexture8::QueryInterface");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::AddRef"

STDMETHODIMP_(ULONG) CMipMap::AddRef()
{
    API_ENTER_NO_LOCK(Device());    
    
    return AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::Release"

STDMETHODIMP_(ULONG) CMipMap::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());    
    
    return ReleaseImpl();
} // Release

// IDirect3DResource methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetDevice"

STDMETHODIMP CMipMap::GetDevice(IDirect3DDevice8 **ppObj)
{
    API_ENTER(Device());
    return GetDeviceImpl(ppObj);
} // GetDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::SetPrivateData"

STDMETHODIMP CMipMap::SetPrivateData(REFGUID riid, 
                                     CONST VOID   *pvData, 
                                     DWORD   cbData, 
                                     DWORD   dwFlags)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // MipMap, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)

    return SetPrivateDataImpl(riid, pvData, cbData, dwFlags, m_cLevels);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetPrivateData"

STDMETHODIMP CMipMap::GetPrivateData(REFGUID riid, 
                                     VOID   *pvData, 
                                     DWORD  *pcbData)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // MipMap, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)
    return GetPrivateDataImpl(riid, pvData, pcbData, m_cLevels);
} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::FreePrivateData"

STDMETHODIMP CMipMap::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // MipMap, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)
    return FreePrivateDataImpl(riid, m_cLevels);
} // FreePrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetPriority"

STDMETHODIMP_(DWORD) CMipMap::GetPriority()
{
    API_ENTER_RET(Device(), DWORD);

    return GetPriorityImpl();
} // GetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::SetPriority"

STDMETHODIMP_(DWORD) CMipMap::SetPriority(DWORD dwPriority)
{
    API_ENTER_RET(Device(), DWORD);

    return SetPriorityImpl(dwPriority);
} // SetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::PreLoad"

STDMETHODIMP_(void) CMipMap::PreLoad(void)
{
    API_ENTER_VOID(Device());

    PreLoadImpl();
    return;
} // PreLoad

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetType"
STDMETHODIMP_(D3DRESOURCETYPE) CMipMap::GetType(void)
{
    API_ENTER_RET(Device(), D3DRESOURCETYPE);

    return m_desc.Type;
} // GetType

// IDirect3DMipTexture methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetLOD"

STDMETHODIMP_(DWORD) CMipMap::GetLOD()
{
    API_ENTER_RET(Device(), DWORD);

    return GetLODImpl();
} // GetLOD

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::SetLOD"

STDMETHODIMP_(DWORD) CMipMap::SetLOD(DWORD dwLOD)
{
    API_ENTER_RET(Device(), DWORD);

    return SetLODImpl(dwLOD);
} // SetLOD

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetLevelCount"

STDMETHODIMP_(DWORD) CMipMap::GetLevelCount()
{
    API_ENTER_RET(Device(), DWORD);

    return GetLevelCountImpl();
} // GetLevelCount

// IDirect3DMipMap methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetLevelDesc"

STDMETHODIMP CMipMap::GetLevelDesc(UINT iLevel, D3DSURFACE_DESC *pDesc)
{
    API_ENTER(Device());

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed GetLevelDesc of IDirect3DTexture8");

        return D3DERR_INVALIDCALL;
    }

    return m_prgMipSurfaces[iLevel]->GetDesc(pDesc);
} // GetLevelDesc;

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetSurfaceLevel"

STDMETHODIMP CMipMap::GetSurfaceLevel(UINT                iLevel, 
                                      IDirect3DSurface8 **ppSurface)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppSurface))
    {
        DPF_ERR("Invalid parameter passed to GetSurfaceLevel of IDirect3DTexture8");
        return D3DERR_INVALIDCALL;
    }

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed GetSurfaceLevel of IDirect3DTexture8");
        *ppSurface = NULL;
        return D3DERR_INVALIDCALL;
    }

    *ppSurface = m_prgMipSurfaces[iLevel];
    (*ppSurface)->AddRef();
    return S_OK;
} // GetSurfaceLevel

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::LockRect"
STDMETHODIMP CMipMap::LockRect(UINT             iLevel,
                               D3DLOCKED_RECT  *pLockedRectData, 
                               CONST RECT      *pRect, 
                               DWORD            dwFlags)
{
    API_ENTER(Device());

    // This is a high-frequency API, so we put parameter
    // checking into debug only
#ifdef DEBUG
    
    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed LockRect of IDirect3DTexture8");
        return D3DERR_INVALIDCALL;
    }

#endif // DEBUG
    
    return m_prgMipSurfaces[iLevel]->LockRect(pLockedRectData, pRect, dwFlags);
} // LockRect


#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::UnlockRect"

STDMETHODIMP CMipMap::UnlockRect(UINT iLevel)
{
    API_ENTER(Device());

    // This is a high-frequency API; so we only do
    // parameter checking in debug
#ifdef DEBUG   
    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed UnlockRect of IDirect3DTexture8");
        return D3DERR_INVALIDCALL;
    }

    return m_prgMipSurfaces[iLevel]->UnlockRect();

#else // !DEBUG

    // We can go to the internal function to avoid
    // the unnecessary call and also to avoid the
    // crit-sec taken twice
    return m_prgMipSurfaces[iLevel]->InternalUnlockRect();

#endif // !DEBUG

} // UnlockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::UpdateTexture"

// This function does type-specific parameter checking
// before calling UpdateDirtyPortion
HRESULT CMipMap::UpdateTexture(CBaseTexture *pResourceTarget)
{
    CMipMap *pTexSource = static_cast<CMipMap*>(this);
    CMipMap *pTexDest   = static_cast<CMipMap*>(pResourceTarget);

    // Figure out how many levels in the source to skip
    DXGASSERT(pTexSource->m_cLevels >= pTexDest->m_cLevels);
    DWORD StartLevel = pTexSource->m_cLevels - pTexDest->m_cLevels;
    DXGASSERT(StartLevel < 32);

    // Compute the size of the top level of the source that is
    // going to be copied.
    UINT SrcWidth  = pTexSource->Desc()->Width;
    UINT SrcHeight = pTexSource->Desc()->Height;
    if (StartLevel > 0)
    {
        SrcWidth  >>= StartLevel;
        SrcHeight >>= StartLevel;
        if (SrcWidth == 0)
            SrcWidth = 1;
        if (SrcHeight == 0)
            SrcHeight = 1;
    }

    // Source and Dest should be the same sizes at this point
    if (SrcWidth != pTexDest->Desc()->Width)
    {
        if (StartLevel)
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since both have the same number of"
                    " mip-levels; their widths must match.");
        }
        else
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since they have the different numbers of"
                    " mip-levels; the widths of the bottom-most levels of"
                    " the source must match all the corresponding levels"
                    " of the destination.");
        }
        return D3DERR_INVALIDCALL;
    }

    if (SrcHeight != pTexDest->Desc()->Height)
    {
        if (StartLevel)
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since both have the same number of"
                    " mip-levels; their heights must match.");
        }
        else
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since they have the different numbers of"
                    " mip-levels; the heights of the bottom-most levels of"
                    " the source must match all the corresponding levels"
                    " of the destination.");
        }
        return D3DERR_INVALIDCALL;
    }

    return UpdateDirtyPortion(pResourceTarget);
} // UpdateTexture


#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::UpdateDirtyPortion"

// Tells the resource that it should copy itself
// to the target. It is the caller's responsibility
// to make sure that Target is compatible with the
// Source. (The Target may have different number of mip-levels
// and be in a different pool; however, it must have the same size, 
// faces, format, etc.)
//
// This function will clear the dirty state.
HRESULT CMipMap::UpdateDirtyPortion(CResource *pResourceTarget)
{
    HRESULT hr;

    // If we are clean, then do nothing
    if (m_cRectUsed == 0)
    {
        if (IsDirty())
        {
            DPF_ERR("A Texture has been locked with D3DLOCK_NO_DIRTY_UPDATE but "
                    "no call to AddDirtyRect was made before the texture was used. "
                    "Hardware texture was not updated.");
        }
        return S_OK;
    }

    // We are dirty; so we need to get some pointers
    CMipMap *pTexSource = static_cast<CMipMap*>(this);
    CMipMap *pTexDest   = static_cast<CMipMap*>(pResourceTarget);

    if (CanTexBlt(pTexDest))
    {
        if (m_cRectUsed == MIPMAP_ALLDIRTY)
        {   
            POINT p = {0, 0};
            RECTL r = {0, 0, Desc()->Width, Desc()->Height};
            hr = static_cast<CD3DBase*>(Device())->TexBlt(pTexDest, pTexSource, &p, &r);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to update texture; not clearing dirty state");
                return hr;
            }
        }
        else
        {
            DXGASSERT(m_cRectUsed < MIPMAP_ALLDIRTY);
            for (DWORD i = 0; i < m_cRectUsed; i++)
            {
                hr = static_cast<CD3DBase*>(Device())->TexBlt(pTexDest, 
                                                              pTexSource, 
                                                              (LPPOINT)&m_DirtyRectArray[i], 
                                                              (LPRECTL)&m_DirtyRectArray[i]);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to update texture; not clearing dirty state");
                    return hr;
                }
            }
        }
    }
    else
    {
        // We can't use TexBlt, so we have to copy each level individually
        // through InternalCopyRects

        // Determine number of source levels to skip
        DXGASSERT(pTexSource->m_cLevels >= pTexDest->m_cLevels);
        DWORD StartLevel = pTexSource->m_cLevels - pTexDest->m_cLevels;
        DWORD LevelsToCopy = pTexSource->m_cLevels - StartLevel;

        CBaseSurface *pSurfaceSrc;
        CBaseSurface *pSurfaceDest;

        if (m_cRectUsed == MIPMAP_ALLDIRTY)
        {
            for (DWORD iLevel = 0; iLevel < LevelsToCopy; iLevel++)
            {
                DXGASSERT(iLevel + StartLevel < this->m_cLevels);
                DXGASSERT(iLevel < pTexDest->m_cLevels);
                pSurfaceSrc = this->m_prgMipSurfaces[iLevel + StartLevel];
                pSurfaceDest = pTexDest->m_prgMipSurfaces[iLevel];

                // Source and Dest should be the same
                // or our caller made a mistake
                DXGASSERT(pSurfaceSrc->InternalGetDesc().Width == 
                          pSurfaceDest->InternalGetDesc().Width);
                DXGASSERT(pSurfaceSrc->InternalGetDesc().Height == 
                          pSurfaceDest->InternalGetDesc().Height);

                // Copy the entire level
                hr = Device()->InternalCopyRects(pSurfaceSrc, 
                                                 NULL, 
                                                 0, 
                                                 pSurfaceDest, 
                                                 NULL);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to update texture; not clearing dirty state");
                    return hr;
                }
            }
        }
        else
        {
            DXGASSERT(m_cRectUsed > 0);
            DXGASSERT(m_cRectUsed <= MIPMAP_MAXDIRTYRECT);

            if (StartLevel)
            {
                // Figure out the right set of target rects
                for (DWORD i = 0; i < m_cRectUsed; i++)
                {
                    ScaleRectDown(&m_DirtyRectArray[i], StartLevel);
                }
            }

            // Use the rects for the top level; but just
            // copy the entirety of other levels
            DXGASSERT(StartLevel < this->m_cLevels);
            DXGASSERT(0 < pTexDest->m_cLevels);
            pSurfaceSrc =  this->m_prgMipSurfaces[StartLevel];
            pSurfaceDest = pTexDest->m_prgMipSurfaces[0];

            DXGASSERT(pSurfaceSrc->InternalGetDesc().Width == 
                      pSurfaceDest->InternalGetDesc().Width);
            DXGASSERT(pSurfaceSrc->InternalGetDesc().Height == 
                      pSurfaceDest->InternalGetDesc().Height);

            // Passing points as NULL means just do a non-translated
            // copy

            // CONSIDER: Maybe we should use the rects for copying the top
            // two levels..
            hr = Device()->InternalCopyRects(pSurfaceSrc, 
                                             m_DirtyRectArray, 
                                             m_cRectUsed, 
                                             pSurfaceDest, 
                                             NULL);       // pPoints

            if (FAILED(hr))
            {
                DPF_ERR("Failed to update texture; not clearing dirty state");
                return hr;
            }

            // Copy each of the levels
            for (DWORD iLevel = 1; iLevel < LevelsToCopy; iLevel++)
            {
                DXGASSERT(iLevel + StartLevel < this->m_cLevels);
                DXGASSERT(iLevel < pTexDest->m_cLevels);

                // Get the next surfaces
                pSurfaceSrc = this->m_prgMipSurfaces[iLevel + StartLevel];
                pSurfaceDest = pTexDest->m_prgMipSurfaces[iLevel];

                // Check that sizes match
                DXGASSERT(pSurfaceSrc->InternalGetDesc().Width == 
                          pSurfaceDest->InternalGetDesc().Width);
                DXGASSERT(pSurfaceSrc->InternalGetDesc().Height == 
                          pSurfaceDest->InternalGetDesc().Height);

                // Copy the entirety of non-top levels
                hr = Device()->InternalCopyRects(pSurfaceSrc, 
                                                 NULL, 
                                                 0, 
                                                 pSurfaceDest, 
                                                 NULL);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to update texture; not clearing dirty state");
                    return hr;
                }
            }
        }
    }

    if (FAILED(hr))
    {
        DPF_ERR("Failed to update texture; not clearing dirty state");

        return hr;
    }

    // Remember that we did the work
    m_cRectUsed = 0;

    // Notify Resource base class that we are now clean
    OnResourceClean();
    DXGASSERT(!IsDirty());

    return S_OK;
} // CMipMap::UpdateDirtyPortion

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::MarkAllDirty"

// Allows the Resource Manager to mark the texture
// as needing to be completely updated on next
// call to UpdateDirtyPortion
void CMipMap::MarkAllDirty()
{
    // Set palette to __INVALIDPALETTE so that UpdateTextures
    // calls the DDI SetPalette the next time.
    SetPalette(__INVALIDPALETTE);

    m_cRectUsed = MIPMAP_ALLDIRTY;

    // Notify Resource base class that we are now dirty
    OnResourceDirty();

    return;
} // CMipMap::MarkAllDirty

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::OnSurfaceLock"

// Methods for the MipSurface to call
// Notification when a mip-level is locked for writing
void CMipMap::OnSurfaceLock(DWORD iLevel, CONST RECT *pRect, DWORD Flags)
{
    // Sync first
    Sync();

    // We only care about the top-most level of the mip-map
    // for dirty rect information
    if (iLevel != 0)
    {
        return;
    }

    // We don't need to mark the surface dirty if this was a
    // read-only lock; (this can happen for RT+Tex where we
    // need to sync even for read-only locks).
    if (Flags & D3DLOCK_READONLY)
    {
        return;
    }
    
    // Send dirty notification
    OnResourceDirty();

    // Remember this dirty rect
    if (m_cRectUsed != MIPMAP_ALLDIRTY &&
        !(Flags & D3DLOCK_NO_DIRTY_UPDATE))
    {
        InternalAddDirtyRect(pRect);
    }

    // We're done now.
    return;

} // CMipMap::OnSurfaceLock

// AddDirtyRect Method
#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::AddDirtyRect"
STDMETHODIMP CMipMap::AddDirtyRect(CONST RECT *pRect)
{
    API_ENTER(Device());

    if (pRect != NULL && !VALID_PTR(pRect, sizeof(RECT)))
    {
        DPF_ERR("Invalid parameter to of IDirect3DTexture8::AddDirtyRect");
        return D3DERR_INVALIDCALL;
    }

    if (pRect)
    {
        if (!CPixel::IsValidRect(Desc()->Format,
                                 Desc()->Width, 
                                 Desc()->Height, 
                                 pRect))
        {
            DPF_ERR("AddDirtyRect for a Texture failed");
            return D3DERR_INVALIDCALL;
        }
    }

    InternalAddDirtyRect(pRect);
    return S_OK;
} // AddDirtyRect

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::InternalAddDirtyRect"

// Internal version of AddDirtyRect: no crit-sec
// or parameter checking
void CMipMap::InternalAddDirtyRect(CONST RECT *pRect)
{
    // If driver managed then batch token
    if (Desc()->Pool == D3DPOOL_MANAGED && !IsD3DManaged())
    {
        RECTL Rect;
        DXGASSERT((Device()->GetD3DCaps()->Caps2 & DDCAPS2_CANMANAGERESOURCE) != 0);
        if (pRect == NULL)
        {
            Rect.left = 0;
            Rect.top = 0;
            Rect.right = (LONG)Desc()->Width;
            Rect.bottom = (LONG)Desc()->Height;
        }
        else
        {
            Rect = *((CONST RECTL*)pRect);
        }
        static_cast<CD3DBase*>(Device())->AddDirtyRect(this, &Rect); // This will fail only due to catastrophic
                                                                     // error and we or the app can't do a
                                                                     // a whole lot about it, so return nothing
        return;
    }

    // Need to mark dirty bit in CResource so that the resource manager works correctly.
    OnResourceDirty();

    // If everything is being modified; then we're totally dirty
    if (pRect == NULL)
    {
        m_cRectUsed = MIPMAP_ALLDIRTY;
        return;
    }

    // If we're all dirty, we can't get dirtier
    if (m_cRectUsed == MIPMAP_ALLDIRTY)
    {
        return;
    }

    // If the rect is the entire surface then we're all dirty 
    DXGASSERT(pRect != NULL);
    if (pRect->left     == 0                        &&
        pRect->top      == 0                        &&
        pRect->right    == (LONG)Desc()->Width      &&
        pRect->bottom   == (LONG)Desc()->Height)
    {
        m_cRectUsed = MIPMAP_ALLDIRTY;
        return;
    }

    // If we have filled up our rects; then we're also all dirty now
    if (m_cRectUsed == MIPMAP_MAXDIRTYRECT)
    {
        m_cRectUsed = MIPMAP_ALLDIRTY;
        return;
    }

    // Remember this rect
    DXGASSERT(m_cRectUsed < MIPMAP_MAXDIRTYRECT);
    DXGASSERT(pRect != NULL);
    m_DirtyRectArray[m_cRectUsed] = *pRect;
    m_cRectUsed++;

    return;
} // InternalAddDirtyRect


#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::IsTextureLocked"

// Debug only parameter checking do determine if a piece
// of a mip-chain is locked
#ifdef DEBUG
BOOL CMipMap::IsTextureLocked()
{
    for (UINT iLevel = 0; iLevel < m_cLevels; iLevel++)
    {
        if (m_prgMipSurfaces[iLevel]->IsLocked())
            return TRUE;
    }
    return FALSE;

} // IsTextureLocked
#endif // !DEBUG


// End of file : mipmap.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\init.cpp ===
#define INITGUID

#define this _this
#include "ddrawpr.h"
#undef this
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\mipsurf.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mipsurf.cpp
 *  Content:    Implementation of the CMipSurface and CDriverMipSurface 
 *              classes.
 *
 *
 ***************************************************************************/

#include "ddrawpr.h"
#include "mipsurf.hpp"

// IUnknown methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::QueryInterface"

STDMETHODIMP CMipSurface::QueryInterface (REFIID  riid, 
                                          void  **ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter for QueryInterface for a Surface of a Texture");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for a Surface of a Texture");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DSurface8  || 
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DSurface8 *>(this));
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to QueryInterface for a Surface of a Texture");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::AddRef"

STDMETHODIMP_(ULONG) CMipSurface::AddRef()
{
    API_ENTER_NO_LOCK(Device());    

#ifdef DEBUG
    m_cRefDebug++;
#endif // DEBUG

    return m_pParent->AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::Release"

STDMETHODIMP_(ULONG) CMipSurface::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());    

#ifdef DEBUG
    m_cRefDebug--;
    if (m_cRefDebug & 0x80000000)
    {
        DPF_ERR("A level of a mip-map has been released more often than it has been add-ref'ed! Danger!!");
    }
#endif // DEBUG

    return m_pParent->ReleaseImpl();
} // Release

// IBuffer methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::SetPrivateData"

STDMETHODIMP CMipSurface::SetPrivateData(REFGUID riid, 
                                         CONST void   *pvData, 
                                         DWORD   cbData, 
                                         DWORD   dwFlags)
{
    API_ENTER(Device());

    return m_pParent->SetPrivateDataImpl(riid, 
                                         pvData, 
                                         cbData, 
                                         dwFlags, 
                                         m_iLevel);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::GetPrivateData"

STDMETHODIMP CMipSurface::GetPrivateData(REFGUID riid, 
                                         void   *pvData, 
                                         DWORD  *pcbData)
{
    API_ENTER(Device());

    return m_pParent->GetPrivateDataImpl(riid,
                                         pvData,
                                         pcbData,
                                         m_iLevel);

} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::FreePrivateData"

STDMETHODIMP CMipSurface::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    return m_pParent->FreePrivateDataImpl(riid,
                                          m_iLevel);
} // FreePrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::GetContainer"

STDMETHODIMP CMipSurface::GetContainer(REFIID riid, 
                                       void **ppContainer)
{
    API_ENTER(Device());

    return m_pParent->QueryInterface(riid, ppContainer);
} // OpenContainer

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::GetDevice"

STDMETHODIMP CMipSurface::GetDevice(IDirect3DDevice8 **ppDevice)
{
    API_ENTER(Device());

    return m_pParent->GetDevice(ppDevice);
} // OpenDevice

// IDirect3DSurface8 methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::GetDesc"

STDMETHODIMP CMipSurface::GetDesc(D3DSURFACE_DESC *pDesc)
{
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pDesc, sizeof(D3DSURFACE_DESC)))
    {
        DPF_ERR("bad pointer for pDesc passed to GetDesc for a Level of a Texture");
        return D3DERR_INVALIDCALL;
    }

    // The internal desc indicates the real
    // format and pool. We need to report
    // back the original data
    *pDesc = InternalGetDesc();

    pDesc->Pool   = m_pParent->GetUserPool();
    pDesc->Format = m_pParent->GetUserFormat();
    pDesc->Usage &= D3DUSAGE_EXTERNAL;

    // We're done
    return S_OK;
} // GetDesc

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::InternalGetDesc"

D3DSURFACE_DESC CMipSurface::InternalGetDesc() const
{
    // We basically get our surface desc from our parent
    // and then modify the width and height fields.
    D3DSURFACE_DESC desc;
    desc          = *m_pParent->Desc();
    desc.Width  >>= m_iLevel;
    desc.Height >>= m_iLevel;

    if (desc.Width == 0)
    {
        desc.Width = 1;
    }
    if (desc.Height == 0)
    {
        desc.Height = 1;
    }

    // Also need to modify the type field
    desc.Type = D3DRTYPE_SURFACE;

    // Also modify the size field
    desc.Size = CPixel::ComputeSurfaceSize(desc.Width, 
                                           desc.Height, 
                                           desc.Format);

    // We're done
    return desc;
} // InternalGetDesc


#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::LockRect"

STDMETHODIMP CMipSurface::LockRect(D3DLOCKED_RECT *pLockedRectData, 
                                   CONST RECT     *pRect, 
                                   DWORD           dwFlags)
{   
    API_ENTER(Device());

    // This is a high-frequency API, so we put parameter
    // checking into debug only
#ifdef DEBUG

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedRectData, sizeof(D3DLOCKED_RECT)))
    {
        DPF_ERR("bad pointer for pLockedRectData passed to LockRect for a Level of a Texture");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data (in debug at least)
    ZeroMemory(pLockedRectData, sizeof(D3DLOCKED_RECT));

    // Validate Rect
    if (pRect != NULL)
    {
        DWORD Width  = m_pParent->Desc()->Width  >> m_iLevel;
        DWORD Height = m_pParent->Desc()->Height >> m_iLevel;

        if (!CPixel::IsValidRect(m_pParent->Desc()->Format,
                                 Width, 
                                 Height, 
                                 pRect))
        {
            DPF_ERR("LockRect for a level of a Texture failed");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_SURF_VALID)
    {
        if (dwFlags & D3DLOCK_DISCARD)
        {
            if (dwFlags & D3DLOCK_READONLY)
            {
                DPF_ERR("D3DLOCK_READONLY is not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
            if (!(m_pParent->Desc()->Usage & D3DUSAGE_DYNAMIC))
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only with dynamic textures");
                return D3DERR_INVALIDCALL;
            }
            if (m_iLevel > 0)
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only on level 0"
                        " (the top mip level). DISCARD in this case will discard"
                        " the entire mipmap.");
                return D3DERR_INVALIDCALL;
            }
            if (pRect != NULL)
            {
                DPF_ERR("Subrects not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            DPF_ERR("Invalid dwFlags parameter passed to LockRect for a Level of a Texture");
            DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_SURF_VALID);
            return D3DERR_INVALIDCALL;
        }
    }
#endif // DEBUG

    // We do this checking in retail too. Must stay in.
    if (!m_isLockable)
    {
        m_pParent->ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }

    // WARNING: For performance reasons, this code is 
    // duplicated in CMipSurface::InternalLockRect

    // Only one lock outstanding at a time is supported
    if (m_isLocked)
    {
        DPF_ERR("LockRect failed on a mip level; surface was already locked.");
        return D3DERR_INVALIDCALL;
    }

    // Notify the parent/device if we are about to be modified
    if ( (m_pParent->GetUserPool() != D3DPOOL_SCRATCH) && (!(dwFlags & D3DLOCK_READONLY)) )
    {
        m_pParent->OnSurfaceLock(m_iLevel, pRect, dwFlags);
    }

    // Figure out our stride/pointer to bits

    // CONSIDER: maybe we should cache our pitch/starting
    // pointer to make this call much cheaper.
    m_pParent->ComputeMipMapOffset(m_iLevel, 
                                   pRect,
                                   pLockedRectData);

    // Mark ourselves as locked
    m_isLocked = 1;

    // Done
    return S_OK;

} // CMipSurface::LockRect

HRESULT CMipSurface::InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                      CONST RECT     *pRect, 
                                      DWORD           dwFlags)
{   
    // WARNING: For performance reasons, this code is 
    // duplicated in CMipSurface::LockRect

    // Only one lock outstanding at a time is supported
    if (m_isLocked)
    {
        DPF_ERR("LockRect failed on a mip level; surface was already locked.");
        return D3DERR_INVALIDCALL;
    }

    // Notify the parent/device if we are about to be modified
    if ( (m_pParent->GetUserPool() != D3DPOOL_SCRATCH) && (!(dwFlags & D3DLOCK_READONLY)) )
    {
        m_pParent->OnSurfaceLock(m_iLevel, pRect, dwFlags);
    }

    // Figure out our stride/pointer to bits

    // CONSIDER: maybe we should cache our pitch/starting
    // pointer to make this call much cheaper.
    m_pParent->ComputeMipMapOffset(m_iLevel, 
                                   pRect,
                                   pLockedRectData);

    // Mark ourselves as locked
    m_isLocked = 1;

    // Done
    return S_OK;
} // InternalLockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::UnlockRect"

STDMETHODIMP CMipSurface::UnlockRect()
{
    API_ENTER(Device());

#ifdef DEBUG
    // If we aren't locked; then something is wrong
    if (m_isLocked == 0)
    {
        DPF_ERR("UnlockRect failed on a mip level; surface wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
#endif // DEBUG

    // Clear our locked state
    m_isLocked = 0;

    // If we are lock-once; then we mark ourselves as not lockable
    if (m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE)
    {
        m_isLockable = FALSE;
    }

    // Done
    return S_OK;
} // UnlockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::InternalUnlockRect"

HRESULT CMipSurface::InternalUnlockRect()
{
    // All this is copied into UnlockRect for speed;
    // maintain both paths !!!

    // Clear our locked state
    m_isLocked = 0;

    // If we are lock-once; then we mark ourselves as not lockable
    if (m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE)
    {
        m_isLockable = FALSE;
    }

    // Done
    return S_OK;
} // InternalUnlockRect

//
// CDriverMipSurface class modifies the implementation
// of the LockRect and UnlockRect methods of the CMipSurface class
//

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverMipSurface::LockRect"

STDMETHODIMP CDriverMipSurface::LockRect(D3DLOCKED_RECT *pLockedRectData, 
                                         CONST RECT     *pRect, 
                                         DWORD           dwFlags)
{   
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedRectData, sizeof(D3DLOCKED_RECT)))
    {
        DPF_ERR("bad pointer for m_pLockedRectData passed to LockRect for a Level of a Texture");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data
    ZeroMemory(pLockedRectData, sizeof(D3DLOCKED_RECT));

    // Validate Rect
    if (pRect != NULL)
    {
        DWORD Width  = m_pParent->Desc()->Width  >> m_iLevel;
        DWORD Height = m_pParent->Desc()->Height >> m_iLevel;

        if (!CPixel::IsValidRect(m_pParent->Desc()->Format,
                                 Width, 
                                 Height, 
                                 pRect))
        {
            DPF_ERR("LockRect for a level of a Texture failed");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_SURF_VALID)
    {
        if (dwFlags & D3DLOCK_DISCARD)
        {
            if (dwFlags & D3DLOCK_READONLY)
            {
                DPF_ERR("D3DLOCK_READONLY is not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
            if (!(m_pParent->Desc()->Usage & D3DUSAGE_DYNAMIC))
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only with dynamic textures");
                return D3DERR_INVALIDCALL;
            }
            if (m_iLevel > 0)
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only on level 0"
                        " (the top mip level). DISCARD in this case will discard"
                        " the entire mipmap.");
                return D3DERR_INVALIDCALL;
            }
            if (pRect != NULL)
            {
                DPF_ERR("Subrects not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            DPF_ERR("Invalid dwFlags parameter passed to LockRect for a Level of a Texture");
            DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_SURF_VALID);
            return D3DERR_INVALIDCALL;
        }
    }

    if (!m_isLockable)
    {
        m_pParent->ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }

    return InternalLockRect(pLockedRectData, pRect, dwFlags);
} // LockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverMipSurface::InternalLockRect"

HRESULT CDriverMipSurface::InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                            CONST RECT     *pRect, 
                                            DWORD           dwFlags)
{   

    // Only one lock outstanding at a time is supported
    if (m_isLocked)
    {
        DPF_ERR("LockRect failed on a mip level; surface was already locked for a Level of a Texture");
        return D3DERR_INVALIDCALL;
    }

    // Notify the parent/device if we are about to be accessed.
    // Driver textures may be written to by HW through 
    // SRT/DrawPrim as well as UpdateTexture. So we may need to sync 
    // with the current command batch.
    m_pParent->OnSurfaceLock(m_iLevel, pRect, dwFlags);
    
    // Prepare a LockData structure for the HAL call
    D3D8_LOCKDATA lockData = {
        Device()->GetHandle(),
        m_hKernelHandle
    };

    if (pRect != NULL)
    {
        lockData.bHasRect = TRUE;
        lockData.rArea = *((RECTL *) pRect);
    }
    else
    {
        lockData.bHasRect = FALSE;
    }

    lockData.dwFlags = dwFlags;
    
    HRESULT hr = Device()->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to lock driver mip-map surface");
        return hr;
    }

    // Fill in the Locked_Rect fields 
    D3DFORMAT Format = m_pParent->Desc()->Format;
    if (CPixel::IsDXT(Format))
    {
        // Pitch is the number of bytes for
        // one row's worth of blocks for linear formats

        // Convert to blocks
        UINT Width = (m_pParent->Desc()->Width + 3)/4;
        for (UINT i = 0; i < m_iLevel; i++)
        {
            // Shrink width by half round up to 1 block
            if (Width > 1)
            {
                Width ++;
                Width >>= 1;
            }
        }
        // At least one block
        if (Width == 0)
            Width = 1;

        if (Format == D3DFMT_DXT1)
        {
            // 8 bytes per block for DXT1
            pLockedRectData->Pitch = Width * 8;
        }
        else
        {
            // 16 bytes per block for DXT2-5
            pLockedRectData->Pitch = Width * 16;
        }
    }
    else
    {
        pLockedRectData->Pitch = lockData.lPitch;
    }

    pLockedRectData->pBits  = lockData.lpSurfData;

#ifdef DEBUG
    if ((dwFlags & D3DLOCK_DISCARD))
    {
        DXGASSERT(m_iLevel == 0);
        if (!CPixel::IsFourCC(Format) &&
            !CPixel::IsIHVFormat(Format))
        {
            DXGASSERT(pRect == NULL);
            memset(pLockedRectData->pBits, 0xDD, pLockedRectData->Pitch * m_pParent->Desc()->Height);
            for (UINT i = 1; i < m_pParent->GetLevelCount(); ++i)
            {
                D3DLOCKED_RECT Rect;
                HRESULT hr = m_pParent->LockRect(i, &Rect, NULL, 0);
                if (FAILED(hr))
                {
                    DPF(1, "Lock to mipsublevel failed. Not good.");
                    break;
                }
                D3DSURFACE_DESC LevelDesc;
                m_pParent->GetLevelDesc(i, &LevelDesc);
                memset(Rect.pBits, 0xDD, Rect.Pitch * LevelDesc.Height);
                m_pParent->UnlockRect(i);
            }
        }
    }
#endif // DEBUG

    // Mark ourselves as locked
    m_isLocked = 1;

    // Done
    return S_OK;
} // CDriverMipSurface::InternalLockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverMipSurface::UnlockRect"

STDMETHODIMP CDriverMipSurface::UnlockRect()
{
    API_ENTER(Device());

    // If we aren't locked; then something is wrong
    if (m_isLocked == 0)
    {
        DPF_ERR("UnlockRect failed on a mip level; surface wasn't locked.");
        return D3DERR_INVALIDCALL;
    }

    DXGASSERT(m_isLockable);

    return InternalUnlockRect();
} // CDriverMipSurface::UnlockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverMipSurface::InternalUnlockRect"

HRESULT CDriverMipSurface::InternalUnlockRect()
{
    // Call the driver to perform the unlock
    D3D8_UNLOCKDATA unlockData = {
        m_pParent->Device()->GetHandle(),
        m_hKernelHandle
    };

    HRESULT hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
    if (FAILED(hr))
    {
        DPF_ERR("Driver surface failed to unlock for a Level of a Texture");
        return hr;
    }

    // Clear our locked state
    m_isLocked = 0;

    // If we are lock-once; then we mark ourselves as not lockable
    if (m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE)
    {
        m_isLockable = FALSE;
    }

    // Done
    return S_OK;
} // CDriverMipSurface::UnlockRect


// End of file : mipsurf.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\mipsurf.hpp ===
#ifndef __MIPSURF_HPP__
#define __MIPSURF_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mipsurf.hpp
 *  Content:    Class header the mipsurface class. This class acts
 *              as a level for the MipMap class. The base class
 *              assumes a system-memory allocation; while the
 *              Driver sub-class will call the driver for every
 *              lock and unlock operation.
 *
 *
 ***************************************************************************/

// Includes
#include "mipmap.hpp"

//
// Each MipSurface implements the IDirect3DSurface8 interface. 
// To reduce overhead per level, we have
// put most of the "real" guts of each surface into the MipMap container 
// class; i.e. most of the methods of the MipSurface really just end 
// up calling something in the MipMap object.
//
// The base class implementation assumes a sys-mem allocation.
//


//
// The CMipSurface class is a special class that
// works solely with the CMipMap class. Each MipSurface
// corresponds to a single level of the mip-map. They are
// not stand-alone COM objects because they share the
// same life-time as their CMipMap parent.
//
// The CDriverMipSurface class is declared later in this file
//

class CMipSurface : public CBaseSurface
{
public:
    // Constructor
    CMipSurface(CMipMap *pParent, 
                BYTE     iLevel,
                HANDLE   hKernelHandle
                ) :
        m_pParent(pParent),
        m_iLevel(iLevel),
        m_hKernelHandle(hKernelHandle)
    {
        DXGASSERT(pParent);
        DXGASSERT(hKernelHandle || (pParent->GetUserPool() == D3DPOOL_SCRATCH) );
    #ifdef DEBUG
        m_cRefDebug = 0; 
    #endif // DEBUG

        if (m_pParent->Desc()->Usage & 
                (D3DUSAGE_LOCK | D3DUSAGE_LOADONCE))
        {
            m_isLockable = TRUE;
        }
        else
        {   
            m_isLockable = FALSE;
        }

        return;
    } // CMipSurface

    ~CMipSurface()
    {
        DXGASSERT(m_cRefDebug == 0); 
        //m_hKernelHandle will be 0 if this is a scratch pool.
        if (m_hKernelHandle)
        {
            // Tell the thunk layer that we need to
            // be freed.

            D3D8_DESTROYSURFACEDATA DestroySurfData;
            DestroySurfData.hDD = m_pParent->Device()->GetHandle();
            DestroySurfData.hSurface = m_hKernelHandle;
            m_pParent->Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
        }
#ifdef DEBUG
        else
        {
            DXGASSERT(m_pParent->GetUserPool() == D3DPOOL_SCRATCH);
        }
#endif //DEBUG
    }; // ~CMipSurface

public:
    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, 
                               LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    // IBuffer methods
    STDMETHOD(SetPrivateData)(REFGUID riid, 
                              CONST VOID* pvData, 
                              DWORD cbData, 
                              DWORD dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID riid, 
                              LPVOID pvData, 
                              LPDWORD pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD(GetContainer)(REFIID riid, 
                            void **ppContainer);

    STDMETHOD(GetDevice)(IDirect3DDevice8 **ppDevice);


    // IDirect3DSurface8 methods
    STDMETHOD(GetDesc)(D3DSURFACE_DESC *pDesc);

    STDMETHOD(LockRect)(D3DLOCKED_RECT *pLockedRectData, 
                        CONST RECT     *pRect, 
                        DWORD           dwFlags);

    STDMETHOD(UnlockRect)();

    // BaseSurface methods

    virtual DWORD DrawPrimHandle() const
    {
        return D3D8GetDrawPrimHandle(m_hKernelHandle);
    } // DrawPrimHandle

    virtual HANDLE KernelHandle() const
    {
        return m_hKernelHandle;
    } // KernelHandle

    virtual DWORD IncrementUseCount()
    {
        return m_pParent->IncrementUseCount();
    } // IncrementUseCount

    virtual DWORD DecrementUseCount()
    {
        return m_pParent->DecrementUseCount();
    } // DecrementUseCount

    virtual void Batch()
    {
        m_pParent->Batch();
        return;
    } // Batch

    virtual void Sync()
    {
        m_pParent->Sync();
        return;
    } // Sync

    // Internal lock functions bypass
    // parameter checking and also whether the
    // surface marked as Lockable or LockOnce
    // etc. (Methods of CBaseSurface.)
    virtual HRESULT InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                     CONST RECT     *pRect, 
                                     DWORD           dwFlags);

    virtual HRESULT InternalUnlockRect();

    virtual D3DSURFACE_DESC InternalGetDesc() const;

    virtual CBaseDevice * InternalGetDevice() const
    {
        return m_pParent->Device();
    } // InternalGetDevice

    // Determines if a LOAD_ONCE surface has already
    // been loaded
    virtual BOOL IsLoaded() const
    {
        DXGASSERT(m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE);
        if (m_isLockable)
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    } // IsLoaded

    // End Of BaseSurface methods

    // Quick method to avoid the virtual function call
    CBaseDevice * Device() const
    {
        return m_pParent->Device();
    } // Device

protected:
    CMipMap *m_pParent;
    BOOL     m_isLockable;
    BYTE     m_iLevel;

    // We'll need internal handles so that
    // we can communicate call Destroy 
    // and so that CDriverMipMap can call
    // Lock/Unlock etc.
    HANDLE   m_hKernelHandle;

    // Debugging trick to help spew better
    // information if someone over-releases a mipsurface
    // (Since our ref's carry over to the parent object; it
    // means that over-releases can be hard to find.)
#ifdef DEBUG
    DWORD   m_cRefDebug;
#endif // DEBUG

}; // CMipSurface

// The CDriverMipSurface is a modification of the base mipsurf
// class. It overrides lock and unlock and routes the call to the
// driver
class CDriverMipSurface : public CMipSurface
{
public:
    // Constructor
    CDriverMipSurface(CMipMap *pParent, 
                      BYTE     iLevel,
                      HANDLE   hKernelHandle
                      ) :
        CMipSurface(pParent, iLevel, hKernelHandle)
    {
    } // CDriverMipSurface

public:

    STDMETHOD(LockRect)(D3DLOCKED_RECT *pLockedRectData, 
                        CONST RECT     *pRect, 
                        DWORD           dwFlags);

    STDMETHOD(UnlockRect)();

    // Internal lock functions bypass
    // parameter checking and also whether the
    // surface marked as Lockable or LockOnce
    // etc. (Methods of CBaseSurface.)
    virtual HRESULT InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                     CONST RECT     *pRect, 
                                     DWORD           dwFlags);

    virtual HRESULT InternalUnlockRect();


}; // CDriverMipSurface


#endif // __MIPSURF_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\mipmap.hpp ===
#ifndef __MIPMAP_HPP__
#define __MIPMAP_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mipmap.hpp
 *  Content:    Class header the mip-map class. This class acts a 
 *              container for the (planar) Surfaces that are used as textures.
 *
 *
 ***************************************************************************/

// Includes
#include "texture.hpp"
#include "pixel.hpp"

// Forward decls
class CMipSurface;

//
// The mip-map class holds a collection of CMipSurfaces. The MipTexture class
// implements the IDirect3DTexture8 interface; each MipSurface implements the
// IDirect3DSurface8 interface. To reduce overhead per level, we have
// put most of the "real" guts of each surface into the MipMap container 
// class; i.e. most of the methods of the MipSurface really just end up 
// calling something in the MipMap object. 
//
// The base class implementation assumes a sys-mem allocation.
//

class CMipMap : public CBaseTexture, public IDirect3DTexture8
{
public:
    // Creation method to allow creation of MipMaps no matter
    // their actual underlying type.
    static HRESULT Create(CBaseDevice        *pDevice, 
                          DWORD               cpWidth,
                          DWORD               cpHeight,
                          DWORD               cLevels,
                          DWORD               dwUsage,
                          D3DFORMAT           Format,
                          D3DPOOL             Pool,
                          IDirect3DTexture8 **ppMipMap);

    // Destructor
    virtual ~CMipMap();


    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID       riid, 
                               LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG,AddRef)  ();
    STDMETHOD_(ULONG,Release) ();

    // IDirect3DResource methods
    STDMETHOD(GetDevice) (IDirect3DDevice8 ** ppvObj);

    STDMETHOD(SetPrivateData)(REFGUID riid, 
                              CONST VOID*  pvData, 
                              DWORD   cbData, 
                              DWORD   dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID riid, 
                              LPVOID  pvData, 
                              LPDWORD pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD_(DWORD, GetPriority)();
    STDMETHOD_(DWORD, SetPriority)(DWORD dwPriority);
    STDMETHOD_(void, PreLoad)();
    STDMETHOD_(D3DRESOURCETYPE, GetType)();

    // IDirect3DMipTexture methods
    STDMETHOD_(DWORD, GetLOD)();
    STDMETHOD_(DWORD, SetLOD)(DWORD dwLOD);
    STDMETHOD_(DWORD, GetLevelCount)();

    // IDirect3DMipMap methods
    STDMETHOD(GetLevelDesc)(UINT iLevel, D3DSURFACE_DESC *pDesc);
    STDMETHOD(GetSurfaceLevel)(UINT                 iLevel,
                               IDirect3DSurface8  **ppSurfaceLevel);


    STDMETHOD(LockRect)(UINT             iLevel,
                        D3DLOCKED_RECT  *pLockedRectData, 
                        CONST RECT      *pRect, 
                        DWORD            dwFlags);
    STDMETHOD(UnlockRect)(UINT           iLevel);


    STDMETHOD(AddDirtyRect)(CONST RECT  *pRect);

    // Direct accessor for surface descriptor
    const D3DSURFACE_DESC *Desc() const
    {
        return &m_desc;
    } // Desc;

    // Helper for Lock
    void ComputeMipMapOffset(UINT iLevel, 
                             CONST RECT *pRect, 
                             D3DLOCKED_RECT *pLockedRectData) const
    {
        CPixel::ComputeMipMapOffset(Desc(),
                                    iLevel,
                                    m_rgbPixels,
                                    pRect,
                                    pLockedRectData);
    } // ComputeMipMapOffset

    // Notification when a mip-level is locked for writing
    void OnSurfaceLock(DWORD iLevel, CONST RECT *pRect, DWORD Flags);

    // Methods for CResource

    // Specifies a creation of a resource that
    // looks just like the current one; in a new POOL
    // with a new LOD.
    virtual HRESULT Clone(D3DPOOL     Pool, 
                          CResource **ppResource) const;

    // Provides a method to access basic structure of the
    // pieces of the resource. 
    virtual const D3DBUFFER_DESC* GetBufferDesc() const;

    // Updates destination with source dirty rects
    virtual HRESULT UpdateDirtyPortion(CResource *pResourceTarget);

    // Allows the Resource Manager to mark the texture
    // as needing to be completely updated on next
    // call to UpdateDirtyPortion
    virtual void MarkAllDirty();
        
    // Methods for CBaseTexture

    // Method for UpdateTexture to call; does type-specific
    // parameter checking before calling UpdateDirtyPortion
    virtual HRESULT UpdateTexture(CBaseTexture *pTextureTarget);

    // Parameter validation method to make sure that no part of
    // the texture is locked.
#ifdef DEBUG
    virtual BOOL IsTextureLocked();
#endif  // DEBUG

private:
    // Constructor returns an error code
    // if the object could not be fully
    // constructed
    CMipMap(CBaseDevice *pDevice, 
            DWORD        cpWidth,
            DWORD        cpHeight,
            DWORD        cLevels,
            DWORD        dwUsage,
            D3DFORMAT    UserFormat,
            D3DFORMAT    RealFormat,
            D3DPOOL      Pool,
            REF_TYPE     refType,
            HRESULT     *phr
            );

    // Internally keep track of current
    // set of dirty rects
    void InternalAddDirtyRect(CONST RECT *pRect);

    // Each mipmap has an array of CMipSurfaces
    CMipSurface     **m_prgMipSurfaces;
    
    // Each mipmap has a memory block that holds
    // all the pixel data in a contiguous chunk
    BYTE             *m_rgbPixels;

    // Keep track of description
    D3DSURFACE_DESC   m_desc;

    // In DX7 we kept track of upto 6 RECTs per mip-chain.
    // These rects indicate which portion of the top-most level of
    // a mip-chain were modified. (We continue to ignore modifications 
    // to lower levels of the mip-chain. This is by-design.)
    enum 
    {
        MIPMAP_MAXDIRTYRECT = 6,
        MIPMAP_ALLDIRTY     = 7
    };

    RECT    m_DirtyRectArray[MIPMAP_MAXDIRTYRECT];

    // If m_cRectUsed is greater than MIPMAP_MAXDIRTYRECT
    // then it means that everything is dirty
    UINT    m_cRectUsed;

}; // class CMipMap

#endif // __MIPMAP_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\mipvol.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mipvol.cpp
 *  Content:    Implementation of the CMipVolume and CManagedMipVolume
 *              classes.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"

#include "mipvol.hpp"
#include "volume.hpp"
#include "d3di.hpp"
#include "resource.inl"

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::Create"

// Static class function for creating a mip-map object.
// (Because it is static; it doesn't have a this pointer.)
//
// We do all parameter checking here to reduce the overhead
// in the constructor which is called by the internal Clone
// method which is used by resource management as part of the
// performance critical download operation.

HRESULT CMipVolume::Create(CBaseDevice              *pDevice,
                           DWORD                     Width,
                           DWORD                     Height,
                           DWORD                     Depth,
                           DWORD                     cLevels,
                           DWORD                     Usage,
                           D3DFORMAT                 Format,
                           D3DPOOL                   Pool,
                           IDirect3DVolumeTexture8 **ppMipVolume)
{
    HRESULT hr;

    // Do parameter checking here
    if (!VALID_PTR_PTR(ppMipVolume))
    {
        DPF_ERR("Bad parameter passed for ppMipVolume for creating a MipVolume");
        return D3DERR_INVALIDCALL;
    }

    // Zero-out return parameter
    *ppMipVolume = NULL;

    // Check if format, pool is valid
    hr = Validate(pDevice, 
                  D3DRTYPE_VOLUMETEXTURE,
                  Pool,
                  Usage,
                  Format);

    if (FAILED(hr))
    {
        // Validate does it's own DPFing
        return D3DERR_INVALIDCALL;
    }

    // Check usage flags
    if (Usage & ~D3DUSAGE_VOLUMETEXTURE_VALID)
    {
        DPF_ERR("Invalid flag specified for volume texture creation.");
        return D3DERR_INVALIDCALL;
    }

    // Infer internal usage flags
    Usage = InferUsageFlags(Pool, Usage, Format);

    // Expand cLevels if necessary
    if (cLevels == 0)
    {
        // See if HW can mip
        if ( (Pool != D3DPOOL_SCRATCH) && !(pDevice->GetD3DCaps()->TextureCaps & 
              D3DPTEXTURECAPS_MIPVOLUMEMAP))
        {
            // Can't mip so use 1
            cLevels = 1;
        }
        else
        {
            // Determine number of levels
            cLevels = ComputeLevels(Width, Height, Depth);
        }
    }

    if (cLevels > 32)
    {
        DPF_ERR("No more than 32 levels are supported. CreateVolumeTexture failed");

        // This limitation is based on the number of
        // bits that we have allocated for iLevel in
        // some of the supporting classes.
        return D3DERR_INVALIDCALL;
    }

    if (cLevels > 1)
    {
        if ((Width  >> (cLevels - 1)) == 0 &&
            (Height >> (cLevels - 1)) == 0 &&
            (Depth  >> (cLevels - 1)) == 0)
        {
            DPF_ERR("Too many levels for volume texture of this size.");
            return D3DERR_INVALIDCALL;
        }
    }

    if (Pool != D3DPOOL_SCRATCH)
    {
        //Device specific constraints:

        // Check size constraints for volumes
        if (pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_VOLUMEMAP_POW2)
        {
            if (!IsPowerOfTwo(Width))
            {
                DPF_ERR("Width must be power of two for mip-volumes");
                return D3DERR_INVALIDCALL;
            }

            if (!IsPowerOfTwo(Height))
            {
                DPF_ERR("Height must be power of two for mip-volumes");
                return D3DERR_INVALIDCALL;
            }

            if (!IsPowerOfTwo(Depth))
            {
                DPF_ERR("Depth must be power of two for mip-volumes");
                return D3DERR_INVALIDCALL;
            }
        }

        // Check texture size restrictions
        if (Width > pDevice->GetD3DCaps()->MaxVolumeExtent)
        {
            DPF_ERR("Texture width is larger than what the device supports. CreateVolumeTexture fails");
            return D3DERR_INVALIDCALL;
        }

        if (Height > pDevice->GetD3DCaps()->MaxVolumeExtent)
        {
            DPF_ERR("Texture height is larger than what the device supports. CreateVolumeTexture fails");
            return D3DERR_INVALIDCALL;
        }

        if (Depth > pDevice->GetD3DCaps()->MaxVolumeExtent)
        {
            DPF_ERR("Texture depth is larger than what the device supports. CreateVolumeTexture fails");
            return D3DERR_INVALIDCALL;
        }

        // Check that the device supports volume texture
        if (!(pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_VOLUMEMAP))
        {
            DPF_ERR("Device doesn't support volume textures; creation failed.");
            return D3DERR_INVALIDCALL;
        }

        // Check if the device supports mipped volumes
        if (cLevels > 1)
        {
            if (!(pDevice->GetD3DCaps()->TextureCaps & 
                    D3DPTEXTURECAPS_MIPVOLUMEMAP))
            {
                DPF_ERR("Device doesn't support mipped volume textures; creation failed.");
                return D3DERR_INVALIDCALL;
            }
        }
    }

    // Size is required to be 4x4
    if (CPixel::Requires4X4(Format))
    {
        if ((Width & 3) ||
            (Height & 3))
        {
            DPF_ERR("DXT Formats require width/height to multiples of 4. CreateVolumeTexture fails");
            return D3DERR_INVALIDCALL;
        }
        if (CPixel::IsVolumeDXT(Format))
        {
            if (Depth & 3)
            {
                DPF_ERR("DXT Formats require width/height to multiples of 4. CreateVolumeTexture fails");
                return D3DERR_INVALIDCALL;
            }
        }
    }

    // Validate against zero width/height/depth
    if (Width   == 0 ||
        Height  == 0 ||
        Depth   == 0)
    {
        DPF_ERR("Width/Height/Depth must be non-zero.  CreateVolumeTexture fails");
        return D3DERR_INVALIDCALL;
    }

    // DX9: May need to support mapping for volumes that 
    // contain depth data someday.

    // Allocate a new MipVolume object and return it
    CMipVolume *pMipVolume = new CMipVolume(pDevice,
                                            Width,
                                            Height,
                                            Depth,
                                            cLevels,
                                            Usage,
                                            Format,
                                            Pool,
                                            REF_EXTERNAL,
                                           &hr);
    if (pMipVolume == NULL)
    {
        DPF_ERR("Out of Memory creating mip-volume");
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
        DPF_ERR("Error during initialization of mip-volume");
        pMipVolume->ReleaseImpl();
        return hr;
    }

    // We're done; just return the object
    *ppMipVolume = pMipVolume;

    return hr;
} // static Create


#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::CMipVolume"

// Constructor for the mip map class
CMipVolume::CMipVolume(CBaseDevice *pDevice,
                       DWORD        Width,
                       DWORD        Height,
                       DWORD        Depth,
                       DWORD        cLevels,
                       DWORD        Usage,
                       D3DFORMAT    UserFormat,
                       D3DPOOL      UserPool,
                       REF_TYPE     refType,
                       HRESULT     *phr
                       ) :
    CBaseTexture(pDevice, cLevels, UserPool, UserFormat, refType),
    m_VolumeArray(NULL),
    m_rgbPixels(NULL),
    m_cBoxUsed(MIPVOLUME_ALLDIRTY)
{
    // We assume that we start out dirty
    DXGASSERT(IsDirty());

    // Initialize basic structures
    m_desc.Format       = UserFormat;
    m_desc.Pool         = UserPool;
    m_desc.Usage        = Usage;
    m_desc.Type         = D3DRTYPE_VOLUMETEXTURE;
    m_desc.Width        = Width;
    m_desc.Height       = Height;
    m_desc.Depth        = Depth;

    // Estimate size of memory allocation
    m_desc.Size         = CPixel::ComputeMipVolumeSize(Width,
                                                       Height,
                                                       Depth,
                                                       cLevels,
                                                       UserFormat);

    // Allocate Pixel Data for SysMem or D3DManaged cases
    if (IS_D3D_ALLOCATED_POOL(UserPool) ||
        IsTypeD3DManaged(Device(), D3DRTYPE_VOLUMETEXTURE, UserPool))
    {
        m_rgbPixels = new BYTE[m_desc.Size];

        if (m_rgbPixels == NULL)
        {
            DPF_ERR("Out of memory allocating memory for mip-volume levels");
            *phr = E_OUTOFMEMORY;
            return;
        }
    }

    // Create the DDSURFACEINFO array and CreateSurfaceData object
    DXGASSERT(cLevels <= 32);

    DDSURFACEINFO SurfInfo[32];
    ZeroMemory(SurfInfo, sizeof(SurfInfo));

    D3D8_CREATESURFACEDATA CreateSurfaceData;
    ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

    // Set up the basic information
    CreateSurfaceData.hDD      = pDevice->GetHandle();
    CreateSurfaceData.pSList   = &SurfInfo[0];
    CreateSurfaceData.dwSCnt   = cLevels;
    CreateSurfaceData.Type     = D3DRTYPE_VOLUMETEXTURE;
    CreateSurfaceData.dwUsage  = m_desc.Usage;
    CreateSurfaceData.Format   = UserFormat;
    CreateSurfaceData.MultiSampleType = D3DMULTISAMPLE_NONE;
    CreateSurfaceData.Pool     = DetermineCreationPool(Device(),
                                                       D3DRTYPE_VOLUMETEXTURE,
                                                       Usage,
                                                       UserPool);

    // Iterate of each level to create the individual level
    // data
    for (DWORD iLevel = 0; iLevel < cLevels; iLevel++)
    {
        // Fill in the relevant information
        DXGASSERT(Width >= 1);
        DXGASSERT(Height >= 1);
        DXGASSERT(Depth >= 1);
        SurfInfo[iLevel].cpWidth  = Width;
        SurfInfo[iLevel].cpHeight = Height;
        SurfInfo[iLevel].cpDepth  = Depth;

        // If we allocated the memory, pass down
        // the sys-mem pointers
        if (m_rgbPixels)
        {
            D3DLOCKED_BOX lock;
            CPixel::ComputeMipVolumeOffset(&m_desc,
                                           iLevel,
                                           m_rgbPixels,
                                           NULL,       // pBox
                                           &lock);

            SurfInfo[iLevel].pbPixels    = (BYTE*)lock.pBits;
            SurfInfo[iLevel].iPitch      = lock.RowPitch;
            SurfInfo[iLevel].iSlicePitch = lock.SlicePitch;
        }

        // Scale width and height down
        if (Width > 1)
        {
            Width  >>= 1;
        }
        if (Height > 1)
        {
            Height >>= 1;
        }
        if (Depth > 1)
        {
            Depth >>= 1;
        }
    }

    // Allocate array of pointers to MipSurfaces
    m_VolumeArray = new CVolume*[cLevels];
    if (m_VolumeArray == NULL)
    {
        DPF_ERR("Out of memory creating VolumeTexture");
        *phr = E_OUTOFMEMORY;
        return;
    }

    // Zero the memory for safe cleanup
    ZeroMemory(m_VolumeArray, sizeof(*m_VolumeArray) * cLevels);

    // NOTE: any failures after this point needs to free up some
    // kernel handles, unless it's scratch

    if (UserPool != D3DPOOL_SCRATCH)
    {
        // Call the HAL to create this surface
        *phr = pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
        if (FAILED(*phr))
            return;

        // Remember what pool we really got
        m_desc.Pool = CreateSurfaceData.Pool;

        // We need to remember the handles from the top most
        // level of the mip-map
        SetKernelHandle(SurfInfo[0].hKernelHandle);
    }

    // Create and Initialize each MipLevel
    for (iLevel = 0; iLevel < cLevels; iLevel++)
    {
        // Is this a sys-mem surface; could be d3d managed
        if (IS_D3D_ALLOCATED_POOL(m_desc.Pool))
        {
            m_VolumeArray[iLevel] =
                    new CVolume(this,
                                (BYTE)iLevel,
                                SurfInfo[iLevel].hKernelHandle);
        }
        else
        {
            // Must be a driver kind of surface; could be driver managed
            m_VolumeArray[iLevel] =
                    new CDriverVolume(this,
                                      (BYTE)iLevel,
                                      SurfInfo[iLevel].hKernelHandle);
        }

        if (m_VolumeArray[iLevel] == NULL)
        {
            DPF_ERR("Out of memory creating volume level");
            *phr = E_OUTOFMEMORY;

            // Need to free handles that we got before we return; we
            // only free the ones that weren't successfully entrusted
            // to a CVolume because those will be cleaned up automatically
            // at their destructor
            if (UserPool != D3DPOOL_SCRATCH)
            {
                for (UINT i = iLevel; i < cLevels; i++)
                {
                    DXGASSERT(SurfInfo[i].hKernelHandle);

                    D3D8_DESTROYSURFACEDATA DestroySurfData;
                    DestroySurfData.hDD = Device()->GetHandle();
                    DestroySurfData.hSurface = SurfInfo[i].hKernelHandle;
                    Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
                }
            }

            return;
        }

    }

    // If this is a D3D managed volume then we need
    // to tell the Resource Manager to remember us. This has to happen
    // at the very end of the constructor so that the important data
    // members are built up correctly
    if (CResource::IsTypeD3DManaged(Device(), D3DRTYPE_VOLUMETEXTURE, UserPool))
    {
        *phr = InitializeRMHandle();
    }

    return;
} // CMipVolume::CMipVolume


#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::~CMipVolume"

// Destructor
CMipVolume::~CMipVolume()
{
    // The destructor has to handle partially
    // created objects. Delete automatically
    // handles NULL; and members are nulled
    // as part of core constructors

    if (m_VolumeArray)
    {
        for (DWORD i = 0; i < m_cLevels; i++)
        {
            delete m_VolumeArray[i];
        }
        delete [] m_VolumeArray;
    }
    delete [] m_rgbPixels;
} // CMipVolume::~CMipVolume

// Methods for the Resource Manager

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::Clone"

// Specifies a creation of a resource that
// looks just like the current one; in a new POOL
// with a new LOD.
HRESULT CMipVolume::Clone(D3DPOOL     Pool,
                          CResource **ppResource) const

{
    // NULL out parameter
    *ppResource = NULL;

    // Determine the number of levels/width/height/depth
    // of the clone
    DWORD cLevels   = GetLevelCountImpl();
    DWORD Width     = m_desc.Width;
    DWORD Height    = m_desc.Height;
    DWORD Depth     = m_desc.Depth;

    DWORD dwLOD     = GetLODI();

    // If LOD is zero, then there are no changes
    if (dwLOD > 0)
    {
        // Clamp LOD to cLevels-1
        if (dwLOD >= cLevels)
        {
            dwLOD = cLevels - 1;
        }

        // scale down the destination texture
        // to correspond the appropiate max lod
        Width  >>= dwLOD;
        if (Width == 0)
            Width = 1;

        Height >>= dwLOD;
        if (Height == 0)
            Height = 1;

        Depth >>= dwLOD;
        if (Depth == 0)
            Depth = 1;

        // Reduce the number based on the our max lod.
        cLevels -= dwLOD;
    }

    // Sanity checking
    DXGASSERT(cLevels  >= 1);
    DXGASSERT(Width    >  0);
    DXGASSERT(Height   >  0);
    DXGASSERT(Depth    >  0);

    // Create the new mip-map object now

    // Note: we treat clones as REF_INTERNAL; because
    // they are owned by the resource manager which
    // is owned by the device.

    // Also, we adjust the usage to disable lock-flags
    // since we don't need lockability
    DWORD Usage = m_desc.Usage;
    Usage &= ~(D3DUSAGE_LOCK | D3DUSAGE_LOADONCE);

    HRESULT hr;
    CResource *pResource = new CMipVolume(Device(),
                                          Width,
                                          Height,
                                          Depth,
                                          cLevels,
                                          Usage,
                                          m_desc.Format,
                                          Pool,
                                          REF_INTERNAL,
                                          &hr);

    if (pResource == NULL)
    {
        DPF_ERR("Failed to allocate mip-volume object when copying");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        DPF(5, "Failed to create mip-map when doing texture management");
        pResource->DecrementUseCount();
        return hr;
    }

    *ppResource = pResource;

    return hr;
} // CMipVolume::Clone

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetBufferDesc"

// Provides a method to access basic structure of the
// pieces of the resource. A resource may be composed
// of one or more buffers.
const D3DBUFFER_DESC* CMipVolume::GetBufferDesc() const
{
    return (const D3DBUFFER_DESC*)&m_desc;
} // CMipVolume::GetBufferDesc



// IUnknown methods
#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::QueryInterface"

STDMETHODIMP CMipVolume::QueryInterface(REFIID       riid,
                                        VOID       **ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter for QueryInterface of a VolumeTexture");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface of a VolumeTexture");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DVolumeTexture8 ||
        riid == IID_IDirect3DBaseTexture8   ||
        riid == IID_IDirect3DResource8      ||
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DVolumeTexture8 *>(this));
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to QueryInterface of a VolumeTexture");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::AddRef"

STDMETHODIMP_(ULONG) CMipVolume::AddRef()
{
    API_ENTER_NO_LOCK(Device());   

    return AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::Release"

STDMETHODIMP_(ULONG) CMipVolume::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());   

    return ReleaseImpl();
} // Release

// IDirect3DResource methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetDevice"

STDMETHODIMP CMipVolume::GetDevice(IDirect3DDevice8 **ppObj)
{
    API_ENTER(Device());
    return GetDeviceImpl(ppObj);
} // GetDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::SetPrivateData"

STDMETHODIMP CMipVolume::SetPrivateData(REFGUID  riid,
                                        CONST VOID    *pvData,
                                        DWORD    cbData,
                                        DWORD    dwFlags)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // MipVolume, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)

    return SetPrivateDataImpl(riid, pvData, cbData, dwFlags, m_cLevels);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetPrivateData"

STDMETHODIMP CMipVolume::GetPrivateData(REFGUID  riid,
                                        VOID    *pvData,
                                        DWORD   *pcbData)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // MipVolume, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)
    return GetPrivateDataImpl(riid, pvData, pcbData, m_cLevels);
} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::FreePrivateData"

STDMETHODIMP CMipVolume::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // MipVolume, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)
    return FreePrivateDataImpl(riid, m_cLevels);
} // FreePrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetPriority"

STDMETHODIMP_(DWORD) CMipVolume::GetPriority()
{
    API_ENTER_RET(Device(), DWORD);

    return GetPriorityImpl();
} // GetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::SetPriority"

STDMETHODIMP_(DWORD) CMipVolume::SetPriority(DWORD dwPriority)
{
    API_ENTER_RET(Device(), DWORD);

    return SetPriorityImpl(dwPriority);
} // SetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::PreLoad"

STDMETHODIMP_(void) CMipVolume::PreLoad(void)
{
    API_ENTER_VOID(Device());

    PreLoadImpl();
    return;
} // PreLoad

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetType"
STDMETHODIMP_(D3DRESOURCETYPE) CMipVolume::GetType(void)
{
    API_ENTER_RET(Device(), D3DRESOURCETYPE);

    return m_desc.Type;
} // GetType

// IDirect3DMipTexture methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetLOD"

STDMETHODIMP_(DWORD) CMipVolume::GetLOD()
{
    API_ENTER_RET(Device(), DWORD);

    return GetLODImpl();
} // GetLOD

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::SetLOD"

STDMETHODIMP_(DWORD) CMipVolume::SetLOD(DWORD dwLOD)
{
    API_ENTER_RET(Device(), DWORD);

    return SetLODImpl(dwLOD);
} // SetLOD

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetLevelCount"

STDMETHODIMP_(DWORD) CMipVolume::GetLevelCount()
{
    API_ENTER_RET(Device(), DWORD);

    return GetLevelCountImpl();
} // GetLevelCount

// IDirect3DMipVolume methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetDesc"

STDMETHODIMP CMipVolume::GetLevelDesc(UINT iLevel, D3DVOLUME_DESC *pDesc)
{
    API_ENTER(Device());

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed GetLevelDesc for a VolumeTexture");

        return D3DERR_INVALIDCALL;
    }

    return m_VolumeArray[iLevel]->GetDesc(pDesc);
} // GetDesc

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetVolumeLevel"

STDMETHODIMP CMipVolume::GetVolumeLevel(UINT               iLevel,
                                        IDirect3DVolume8 **ppVolume)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppVolume))
    {
        DPF_ERR("Invalid parameter passed to GetVolumeLevel");
        return D3DERR_INVALIDCALL;
    }

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed GetVolumeLevel");
        *ppVolume = NULL;
        return D3DERR_INVALIDCALL;
    }
    *ppVolume = m_VolumeArray[iLevel];
    (*ppVolume)->AddRef();
    return S_OK;
} // GetSurfaceLevel

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::LockBox"
STDMETHODIMP CMipVolume::LockBox(UINT             iLevel,
                                 D3DLOCKED_BOX   *pLockedBox,
                                 CONST D3DBOX    *pBox,
                                 DWORD            dwFlags)
{
    API_ENTER(Device());

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed LockBox");
        return D3DERR_INVALIDCALL;
    }

    return m_VolumeArray[iLevel]->LockBox(pLockedBox, pBox, dwFlags);
} // LockRect


#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::UnlockRect"

STDMETHODIMP CMipVolume::UnlockBox(UINT iLevel)
{
    API_ENTER(Device());

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed UnlockBox");
        return D3DERR_INVALIDCALL;
    }

    return m_VolumeArray[iLevel]->UnlockBox();
} // UnlockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::UpdateTexture"

// This function does type-specific parameter checking
// before calling UpdateDirtyPortion
HRESULT CMipVolume::UpdateTexture(CBaseTexture *pResourceTarget)
{
    CMipVolume *pTexSource = static_cast<CMipVolume*>(this);
    CMipVolume *pTexDest   = static_cast<CMipVolume*>(pResourceTarget);

    // Figure out how many levels in the source to skip
    DXGASSERT(pTexSource->m_cLevels >= pTexDest->m_cLevels);
    DWORD StartLevel = pTexSource->m_cLevels - pTexDest->m_cLevels;
    DXGASSERT(StartLevel < 32);

    // Compute the size of the top level of the source that is
    // going to be copied.
    UINT SrcWidth  = pTexSource->Desc()->Width;
    UINT SrcHeight = pTexSource->Desc()->Height;
    UINT SrcDepth  = pTexSource->Desc()->Depth;
    if (StartLevel > 0)
    {
        SrcWidth  >>= StartLevel;
        SrcHeight >>= StartLevel;
        SrcDepth  >>= StartLevel;
        if (SrcWidth == 0)
            SrcWidth = 1;
        if (SrcHeight == 0)
            SrcHeight = 1;
        if (SrcDepth == 0)
            SrcDepth = 1;
    }

    // Source and Dest should be the same sizes at this point
    if (SrcWidth != pTexDest->Desc()->Width)
    {
        if (StartLevel)
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since both have the same number of"
                    " levels; their widths must match.");
        }
        else
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since they have the different numbers of"
                    " levels; the widths of the bottom-most levels of"
                    " the source must match all the corresponding levels"
                    " of the destination.");
        }
        return D3DERR_INVALIDCALL;
    }

    if (SrcHeight != pTexDest->Desc()->Height)
    {
        if (StartLevel)
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since both have the same number of"
                    " levels; their heights must match.");
        }
        else
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since they have the different numbers of"
                    " levels; the heights of the bottom-most levels of"
                    " the source must match all the corresponding levels"
                    " of the destination.");
        }
        return D3DERR_INVALIDCALL;
    }

    if (SrcDepth != pTexDest->Desc()->Depth)
    {
        if (StartLevel)
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since both have the same number of"
                    " levels; their depths must match.");
        }
        else
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since they have the different numbers of"
                    " levels; the depths of the bottom-most levels of"
                    " the source must match all the corresponding levels"
                    " of the destination.");
        }
        return D3DERR_INVALIDCALL;
    }


    return UpdateDirtyPortion(pResourceTarget);
} // UpdateTexture

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::UpdateDirtyPortion"


// Tells the resource that it should copy itself
// to the target. It is the caller's responsibility
// to make sure that Target is compatible with the
// Source. (The Target may have different number of mip-levels
// and be in a different pool; however, it must have the same size,
// faces, format, etc.)
//
// This function will clear the dirty state.
HRESULT CMipVolume::UpdateDirtyPortion(CResource *pResourceTarget)
{
    HRESULT hr;

    // If we are clean, then do nothing
    if (m_cBoxUsed == 0)
    {
        if (IsDirty())
        {
            DPF_ERR("A volume texture has been locked with D3DLOCK_NO_DIRTY_UPDATE but "
                    "no call to AddDirtyBox was made before the texture was used. "
                    "Hardware texture was not updated.");
        }
        return S_OK;
    }

    // We are dirty; so we need to get some pointers
    CMipVolume *pTexSource = static_cast<CMipVolume*>(this);
    CMipVolume *pTexDest   = static_cast<CMipVolume*>(pResourceTarget);

    if (CanTexBlt(pTexDest))
    {
        CD3DBase *pDevice = static_cast<CD3DBase*>(Device());

        if (m_cBoxUsed == MIPVOLUME_ALLDIRTY)
        {   
            D3DBOX box;

            box.Left    = 0;
            box.Right   = Desc()->Width;
            box.Top     = 0;
            box.Bottom  = Desc()->Height;
            box.Front   = 0;
            box.Back    = Desc()->Depth;

            hr = pDevice->VolBlt(pTexDest, 
                                 pTexSource, 
                                 0, 0, 0,   // XYZ offset
                                 &box);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to update volume texture; not clearing dirty state");
                return hr;
            }
        }
        else
        {
            DXGASSERT(m_cBoxUsed < MIPVOLUME_ALLDIRTY);

            for (DWORD i = 0; i < m_cBoxUsed; i++)
            {
                hr = pDevice->VolBlt(pTexDest, 
                                     pTexSource, 
                                     m_DirtyBoxArray[i].Left,
                                     m_DirtyBoxArray[i].Top,
                                     m_DirtyBoxArray[i].Front,
                                     &m_DirtyBoxArray[i]);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to update volume texture; not clearing dirty state");
                    return hr;
                }
            }
        }

        // Remember that we did the work
        m_cBoxUsed = 0;

        return S_OK;
    }

    // We can't use TexBlt, so we have to copy each level individually
    // with Lock and Copy
    
    // Determine number of source levels to skip
    DXGASSERT(pTexSource->m_cLevels >= pTexDest->m_cLevels);
    DWORD StartLevel = pTexSource->m_cLevels - pTexDest->m_cLevels;
    DWORD LevelsToCopy = pTexSource->m_cLevels - StartLevel;

    // Sanity check
    DXGASSERT(LevelsToCopy > 0);

    // Get the volume desc of the top level to copy
    D3DVOLUME_DESC desc;
    hr = pTexDest->GetLevelDesc(0, &desc);
    DXGASSERT(SUCCEEDED(hr));

    BOOL IsAllDirty = FALSE;
    if (m_cBoxUsed == MIPVOLUME_ALLDIRTY)
    {
        m_cBoxUsed = 1;
        m_DirtyBoxArray[0].Left     = 0;
        m_DirtyBoxArray[0].Right    = m_desc.Width >> StartLevel;

        m_DirtyBoxArray[0].Top      = 0;
        m_DirtyBoxArray[0].Bottom   = m_desc.Height >> StartLevel;

        m_DirtyBoxArray[0].Front    = 0;
        m_DirtyBoxArray[0].Back     = m_desc.Depth >> StartLevel;

        IsAllDirty = TRUE;
    }


    // Determine pixel/block size and make some
    // adjustments if necessary

    // cbPixel is size of pixel or (if negative)
    // a special value for use with AdjustForDXT
    UINT cbPixel = CPixel::ComputePixelStride(desc.Format);

    if (CPixel::IsDXT(cbPixel))
    {
        BOOL IsVolumeDXT = CPixel::IsVolumeDXT(desc.Format);

        // Adjust dirty rect coords from pixels into blocks
        for (DWORD iBox = 0; iBox < m_cBoxUsed; iBox++)
        {
            // Basically we just need to round the value
            // down by 2 powers-of-two. (left/top get rounded
            // down, right/bottom get rounded up)

            if (IsVolumeDXT)
            {
                ScaleBoxDown(&m_DirtyBoxArray[iBox], 2);
            }
            else
            {
                ScaleRectDown((RECT *)&m_DirtyBoxArray[iBox], 2);
            }
        }

        // Adjust width/height from pixels into blocks
        if (IsVolumeDXT)
        {
            CPixel::AdjustForVolumeDXT(&desc.Width,
                                       &desc.Height,
                                       &desc.Depth,
                                       &cbPixel);
        }
        else
        {
            CPixel::AdjustForDXT(&desc.Width, &desc.Height, &cbPixel);
        }
    }

    // cbPixel is now the size of a pixel (or of a block if we've
    // converted into DXT block space)


    // We need to copy each volume piece by piece
    for (DWORD Level = 0; Level < LevelsToCopy; Level++)
    {
        CVolume *pVolumeSrc;
        CVolume *pVolumeDst;

        DXGASSERT(Level + StartLevel < pTexSource->m_cLevels);
        pVolumeSrc = pTexSource->m_VolumeArray[Level + StartLevel];

        DXGASSERT(Level < pTexDest->m_cLevels);
        pVolumeDst = pTexDest->m_VolumeArray[Level];

        D3DLOCKED_BOX SrcBox;
        D3DLOCKED_BOX DstBox;

        // Lock the whole source
        hr = pVolumeSrc->InternalLockBox(&SrcBox,
                                         NULL,
                                         D3DLOCK_READONLY);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to update volume texture; not clearing dirty state");
            return hr;
        }

        // Lock the whole dest
        hr = pVolumeDst->InternalLockBox(&DstBox,
                                         NULL,
                                         0);
        if (FAILED(hr))
        {
            pVolumeSrc->InternalUnlockBox();

            DPF_ERR("Failed to update volume texture; not clearing dirty state");
            return hr;
        }

        // Can we do this with one big memcpy, or do we need
        // to break it up?
        if (IsAllDirty &&
            (SrcBox.RowPitch == DstBox.RowPitch) &&
            (SrcBox.SlicePitch == DstBox.SlicePitch) &&
            (SrcBox.RowPitch == (int)(desc.Width * cbPixel)) &&
            (SrcBox.SlicePitch == (int)(SrcBox.RowPitch * desc.Height)))
        {
            BYTE *pSrc = (BYTE*) SrcBox.pBits;
            BYTE *pDst = (BYTE*) DstBox.pBits;
            memcpy(pDst, pSrc, SrcBox.SlicePitch * desc.Depth);
        }
        else
        {
            // Copy each dirty box one by one
            for (DWORD iBox = 0; iBox < m_cBoxUsed; iBox++)
            {
                D3DBOX *pBox = &m_DirtyBoxArray[iBox];

                BYTE *pSrc = (BYTE*)  SrcBox.pBits;
                pSrc += pBox->Front * SrcBox.SlicePitch;
                pSrc += pBox->Top   * SrcBox.RowPitch;
                pSrc += pBox->Left  * cbPixel;

                BYTE *pDst = (BYTE*)  DstBox.pBits;
                pDst += pBox->Front * DstBox.SlicePitch;
                pDst += pBox->Top   * DstBox.RowPitch;
                pDst += pBox->Left  * cbPixel;

                for (DWORD i = pBox->Front; i < pBox->Back; i++)
                {
                    BYTE *pDepthDst = pDst;
                    BYTE *pDepthSrc = pSrc;
                    DWORD cbSpan = cbPixel * (pBox->Right - pBox->Left);

                    for (DWORD j = pBox->Top; j < pBox->Bottom; j++)
                    {
                        memcpy(pDst, pSrc, cbSpan);
                        pDst += DstBox.RowPitch;
                        pSrc += SrcBox.RowPitch;
                    }
                    pDst = pDepthDst + DstBox.SlicePitch;
                    pSrc = pDepthSrc + SrcBox.SlicePitch;
                }
            }
        }

        // Release our locks
        hr = pVolumeDst->InternalUnlockBox();
        DXGASSERT(SUCCEEDED(hr));

        hr = pVolumeSrc->InternalUnlockBox();
        DXGASSERT(SUCCEEDED(hr));

        // Is the last one?
        if (Level+1 < LevelsToCopy)
        {
            // Shrink the desc
            desc.Width  >>= 1;
            if (desc.Width == 0)
                desc.Width = 1;
            desc.Height >>= 1;
            if (desc.Height == 0)
                desc.Height = 1;
            desc.Depth  >>= 1;
            if (desc.Depth == 0)
                desc.Depth = 1;

            // Shrink the boxes
            for (DWORD iBox = 0; iBox < m_cBoxUsed; iBox++)
            {
                ScaleBoxDown(&m_DirtyBoxArray[iBox]);
            }
        }
    }


    if (FAILED(hr))
    {
        DPF_ERR("Failed to update volume texture; not clearing dirty state");

        return hr;
    }

    // Remember that we did the work
    m_cBoxUsed = 0;

    // Notify Resource base class that we are now clean
    OnResourceClean();
    DXGASSERT(!IsDirty());

    return S_OK;
} // CMipVolume::UpdateDirtyPortion

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::MarkAllDirty"

// Allows the Resource Manager to mark the texture
// as needing to be completely updated on next
// call to UpdateDirtyPortion
void CMipVolume::MarkAllDirty()
{
    // Set palette to __INVALIDPALETTE so that UpdateTextures
    // calls the DDI SetPalette the next time.
    SetPalette(__INVALIDPALETTE);

    // Send dirty notification
    m_cBoxUsed = MIPVOLUME_ALLDIRTY;

    // Notify Resource base class that we are now dirty
    OnResourceDirty();

    return;
} // CMipVolume::MarkAllDirty

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::OnVolumeLock"

// Methods for the Volumes to call
// Notification when a mip-level is locked for writing
void CMipVolume::OnVolumeLock(DWORD iLevel, CONST D3DBOX *pBox, DWORD dwFlags)
{
    // Need to Sync first
    Sync();

    // We only care about the top-most level of the mip-map
    if (iLevel != 0)
    {
        return;
    }

    // Send dirty notification
    OnResourceDirty();

    // If we're not all dirty or if the lock specifies
    // that we don't keep track of the lock then
    // remember the box
    if (m_cBoxUsed != MIPVOLUME_ALLDIRTY &&
        !(dwFlags & D3DLOCK_NO_DIRTY_UPDATE))
    {
        InternalAddDirtyBox(pBox);
    }

    return;
} // CMipVolume::OnVolumeLock

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::AddDirtyBox"

STDMETHODIMP CMipVolume::AddDirtyBox(CONST D3DBOX *pBox)
{
    API_ENTER(Device());

    if (pBox != NULL && !VALID_PTR(pBox, sizeof(D3DBOX)))
    {
        DPF_ERR("Invalid parameter to AddDirtyBox");
        return D3DERR_INVALIDCALL;
    }

    if (pBox)
    {
        if (!CPixel::IsValidBox(Desc()->Format,
                                Desc()->Width, 
                                Desc()->Height, 
                                Desc()->Depth,
                                pBox))
        {
            DPF_ERR("AddDirtyBox for a Volume Texture failed");
            return D3DERR_INVALIDCALL;
        }
    }

    InternalAddDirtyBox(pBox);
    return S_OK;
} // AddDirtyBox

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::InternalAddDirtyBox"

void CMipVolume::InternalAddDirtyBox(CONST D3DBOX *pBox)
{
    // If driver managed then batch token
    if (Desc()->Pool == D3DPOOL_MANAGED && !IsD3DManaged())
    {
        D3DBOX Box;
        DXGASSERT((Device()->GetD3DCaps()->Caps2 & DDCAPS2_CANMANAGERESOURCE) != 0);
        if (pBox == NULL)
        {
            Box.Left   = 0;
            Box.Top    = 0;             
            Box.Front  = 0;
            Box.Right  = Desc()->Width; 
            Box.Bottom = Desc()->Height;
            Box.Back   = Desc()->Depth;
        }
        else
        {
            Box = *pBox;
        }
        static_cast<CD3DBase*>(Device())->AddDirtyBox(this, &Box); // This will fail only due to catastrophic
                                                                   // error and we or the app can't do a
                                                                   // a whole lot about it, so return nothing
        return;
    }

    // Need to mark dirty bit in CResource so that the resource manager works correctly.
    OnResourceDirty();

    // If everything is being modified; then we're totally dirty
    if (pBox == NULL)
    {
        m_cBoxUsed = MIPVOLUME_ALLDIRTY;
        return;
    }

    // If we're all dirty, we can't get dirtier
    if (m_cBoxUsed == MIPVOLUME_ALLDIRTY)
    {
        return;
    }

    // If the rect is the entire surface then we're all dirty
    DXGASSERT(pBox != NULL);
    if (pBox->Left     == 0                 &&
        pBox->Top      == 0                 &&
        pBox->Front    == 0                 &&
        pBox->Right    == Desc()->Width   &&
        pBox->Bottom   == Desc()->Height  &&
        pBox->Back     == Desc()->Depth)
    {
        m_cBoxUsed = MIPVOLUME_ALLDIRTY;
        return;
    }

    // If we have filled up our boxes; then we're also all dirty now
    if (m_cBoxUsed == MIPVOLUME_MAXDIRTYBOX)
    {
        m_cBoxUsed = MIPVOLUME_ALLDIRTY;
        return;
    }

    // Remember this rect
    DXGASSERT(m_cBoxUsed < MIPVOLUME_MAXDIRTYBOX);
    DXGASSERT(pBox != NULL);
    m_DirtyBoxArray[m_cBoxUsed] = *pBox;
    m_cBoxUsed++;

    // We're done now.
    return;

} // InternalAddDirtyBox


#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::IsTextureLocked"

// Debug only parameter checking do determine if a piece
// of a mip-chain is locked
#ifdef DEBUG
BOOL CMipVolume::IsTextureLocked()
{
    for (UINT iLevel = 0; iLevel < m_cLevels; iLevel++)
    {
        if (m_VolumeArray[iLevel]->IsLocked())
            return TRUE;
    }
    return FALSE;

} // IsTextureLocked
#endif // !DEBUG

// End of file : mipvol.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\pixel.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dobj.cpp
 *  Content:    Base class implementation for resources and buffers
 *
 *
 ***************************************************************************/

#include "ddrawpr.h"
#include "pixel.hpp"

IHVFormatInfo *CPixel::m_pFormatList = 0;

extern "C" void CPixel__Cleanup()
{
    CPixel::Cleanup();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::Cleanup"
void CPixel::Cleanup()
{
    while(m_pFormatList != 0)
    {
        IHVFormatInfo *t = m_pFormatList->m_pNext;
        delete m_pFormatList;
        m_pFormatList = t;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::BytesPerPixel"

UINT CPixel::BytesPerPixel(D3DFORMAT Format)
{
    switch (Format)
    {
    case D3DFMT_DXT1:
        // Size is negative to indicate DXT; and indicates
        // the size of the block
        return (UINT)(-8);
    case D3DFMT_DXT2:
    case D3DFMT_DXT3:
    case D3DFMT_DXT4:
    case D3DFMT_DXT5:
        // Size is negative to indicate DXT; and indicates
        // the size of the block
        return (UINT)(-16);

#ifdef VOLUME_DXT
    case D3DFMT_DXV1:
        // Size is negative to indicate DXT; and indicates
        // the size of the block
        return (UINT)(-32);

    case D3DFMT_DXV2:
    case D3DFMT_DXV3:
    case D3DFMT_DXV4:
    case D3DFMT_DXV5:
        return (UINT)(-64);
#endif //VOLUME_DXT

    case D3DFMT_A8R8G8B8:
    case D3DFMT_X8R8G8B8:
    case D3DFMT_D32:
    case D3DFMT_D24S8:
    case D3DFMT_S8D24:
    case D3DFMT_X8L8V8U8:
    case D3DFMT_X4S4D24:
    case D3DFMT_D24X4S4:
    case D3DFMT_Q8W8V8U8:
    case D3DFMT_V16U16:
    case D3DFMT_W11V11U10:
    case D3DFMT_W10V11U11:
    case D3DFMT_A2W10V10U10:
    case D3DFMT_A8X8V8U8:
    case D3DFMT_L8X8V8U8:
    case D3DFMT_A2B10G10R10:
    case D3DFMT_A8B8G8R8:
    case D3DFMT_X8B8G8R8:
    case D3DFMT_G16R16:
    case D3DFMT_D24X8:  
        return 4;

    case D3DFMT_R8G8B8:
        return 3;

    case D3DFMT_R5G6B5:
    case D3DFMT_X1R5G5B5:
    case D3DFMT_A1R5G5B5:
    case D3DFMT_A4R4G4B4:
    case D3DFMT_A8L8:
    case D3DFMT_V8U8:
    case D3DFMT_L6V5U5:
    case D3DFMT_D16:
    case D3DFMT_D16_LOCKABLE:
    case D3DFMT_D15S1:
    case D3DFMT_S1D15:
    case D3DFMT_A8P8:
    case D3DFMT_A8R3G3B2:
    case D3DFMT_UYVY:
    case D3DFMT_YUY2:
    case D3DFMT_X4R4G4B4:
        return 2;

    case D3DFMT_P8:
    case D3DFMT_L8:
    case D3DFMT_R3G3B2:
    case D3DFMT_A4L4:
    case D3DFMT_A8:
        return 1;

    default:
        return 0;
    };
}; // BytesPerPixel

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputePixelStride"

UINT CPixel::ComputePixelStride(D3DFORMAT Format)
{
    UINT BPP = BytesPerPixel(Format);
    if (BPP == 0)
    {
        for(IHVFormatInfo *p = m_pFormatList; p != 0; p = p->m_pNext)
        {
            if (p->m_Format == Format)
            {
                return p->m_BPP >> 3;
            }
        }
    }
    return BPP;
}; // ComputePixelStride

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeSurfaceStride"

// Figure out a stride for a particular surface based on format and width
inline UINT CPixel::ComputeSurfaceStride(UINT cpWidth, UINT cbPixel)
{
    // Figure out basic (linear) stride;
    UINT dwStride = cpWidth * cbPixel;

    // Round up to multiple of 4 (for NT; but makes sense to maximize
    // cache hits and reduce unaligned accesses)
    dwStride = (dwStride + 3) & ~3;

    return dwStride;
}; // ComputeSurfaceStride


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeSurfaceSize"

UINT CPixel::ComputeSurfaceSize(UINT            cpWidth,
                                UINT            cpHeight,
                                UINT            cbPixel)
{
    return cpHeight * ComputeSurfaceStride(cpWidth, cbPixel);
} // ComputeSurfaceSize

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeMipMapSize"

UINT CPixel::ComputeMipMapSize(UINT             cpWidth,
                               UINT             cpHeight,
                               UINT             cLevels,
                               D3DFORMAT       Format)
{
    UINT cbPixel = ComputePixelStride(Format);

    // Adjust pixel->block if necessary
    BOOL isDXT = IsDXT(cbPixel);
    DDASSERT((UINT)isDXT <= 1);
    if (isDXT)
    {
        AdjustForDXT(&cpWidth, &cpHeight, &cbPixel);
    }

    UINT cbSize = 0;
    for (UINT i = 0; i < cLevels; i++)
    {
        // Figure out the size for
        // each level of the mip-map
        cbSize += ComputeSurfaceSize(cpWidth, cpHeight, cbPixel);

        // Shrink width and height by half; clamp to 1 pixel
        if (cpWidth > 1)
        {
            cpWidth += (UINT)isDXT;
            cpWidth >>= 1;
        }
        if (cpHeight > 1)
        {
            cpHeight += (UINT)isDXT;
            cpHeight >>= 1;
        }
    }
    return cbSize;

} // ComputeMipMapSize

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeMipVolumeSize"

UINT CPixel::ComputeMipVolumeSize(UINT          cpWidth,
                                  UINT          cpHeight,
                                  UINT          cpDepth,
                                  UINT          cLevels,
                                  D3DFORMAT    Format)
{
    UINT cbPixel = ComputePixelStride(Format);

    // Adjust pixel->block if necessary
    BOOL isDXT       = IsDXT(cbPixel);
    BOOL isVolumeDXT = IsVolumeDXT(Format);
    DDASSERT((UINT)isDXT <= 1);

    if (isVolumeDXT)
    {
        DXGASSERT(isDXT);
        AdjustForVolumeDXT(&cpWidth, &cpHeight, &cpDepth, &cbPixel);
    }
    else if (isDXT)
    {
        AdjustForDXT(&cpWidth, &cpHeight, &cbPixel);
    }

    UINT cbSize = 0;

    for (UINT i = 0; i < cLevels; i++)
    {
        // Figure out the size for
        // each level of the mip-volume
        cbSize += cpDepth * ComputeSurfaceSize(cpWidth, cpHeight, cbPixel);

        // Shrink width and height by half; clamp to 1 pixel
        if (cpWidth > 1)
        {
            cpWidth += (UINT)isDXT;
            cpWidth >>= 1;
        }
        if (cpHeight > 1)
        {
            cpHeight += (UINT)isDXT;
            cpHeight >>= 1;
        }
        if (cpDepth > 1)
        {
            cpDepth >>= 1;
        }
    }
    return cbSize;

} // ComputeMipVolumeSize

// Given a surface desc, a level, and pointer to
// bits (pBits in the LockedRectData) and a sub-rect,
// this will fill in the pLockedRectData structure
void CPixel::ComputeMipMapOffset(const D3DSURFACE_DESC *pDescTopLevel,
                                 UINT                   iLevel,
                                 BYTE                  *pBits,
                                 CONST RECT            *pRect,
                                 D3DLOCKED_RECT        *pLockedRectData)
{
    DXGASSERT(pBits != NULL);
    DXGASSERT(pLockedRectData != NULL);
    DXGASSERT(iLevel < 32);
    DXGASSERT(pDescTopLevel != NULL);
    DXGASSERT(0 != ComputePixelStride(pDescTopLevel->Format));
    DXGASSERT(pDescTopLevel->Width > 0);
    DXGASSERT(pDescTopLevel->Height > 0);

    // CONSIDER: This is slow; and we can do a much better
    // job for the non-compressed/wacky cases.
    UINT       cbOffset = 0;
    UINT       cbPixel  = ComputePixelStride(pDescTopLevel->Format);
    UINT       cpWidth  = pDescTopLevel->Width;
    UINT       cpHeight = pDescTopLevel->Height;

    // Adjust pixel->block if necessary
    BOOL isDXT = IsDXT(cbPixel);
    DDASSERT((UINT)isDXT <= 1);
    if (isDXT)
    {
        AdjustForDXT(&cpWidth, &cpHeight, &cbPixel);
    }

    for (UINT i = 0; i < iLevel; i++)
    {
        cbOffset += ComputeSurfaceSize(cpWidth,
                                       cpHeight,
                                       cbPixel);

        // Shrink width and height by half; clamp to 1 pixel
        if (cpWidth > 1)
        {
            cpWidth += (UINT)isDXT;
            cpWidth >>= 1;
        }
        if (cpHeight > 1)
        {
            cpHeight += (UINT)isDXT;
            cpHeight >>= 1;
        }
    }

    // For DXTs, the pitch is the number of bytes
    // for a single row of blocks; which is the same
    // thing as the normal routine
    pLockedRectData->Pitch = ComputeSurfaceStride(cpWidth,
                                                  cbPixel);
    DXGASSERT(pLockedRectData->Pitch != 0);

    // Don't adjust for Rect for DXT formats
    if (pRect)
    {
        if (isDXT)
        {
            DXGASSERT((pRect->top  & 3) == 0);
            DXGASSERT((pRect->left & 3) == 0);
            cbOffset += (pRect->top  / 4) * pLockedRectData->Pitch +
                        (pRect->left / 4) * cbPixel;
        }
        else
        {
            cbOffset += pRect->top  * pLockedRectData->Pitch +
                        pRect->left * cbPixel;
        }
    }

    pLockedRectData->pBits = pBits + cbOffset;

} // ComputeMipMapOffset

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeMipVolumeOffset"

// MipVolume version of ComputeMipMapOffset
void CPixel::ComputeMipVolumeOffset(const D3DVOLUME_DESC  *pDescTopLevel,
                                    UINT                    iLevel,
                                    BYTE                    *pBits,
                                    CONST D3DBOX            *pBox,
                                    D3DLOCKED_BOX          *pLockedBoxData)
{
    DXGASSERT(pBits != NULL);
    DXGASSERT(pLockedBoxData != NULL);
    DXGASSERT(iLevel < 32);
    DXGASSERT(pDescTopLevel != NULL);
    DXGASSERT(0 != ComputePixelStride(pDescTopLevel->Format));
    DXGASSERT(pDescTopLevel->Width > 0);
    DXGASSERT(pDescTopLevel->Height > 0);
    DXGASSERT(pDescTopLevel->Depth > 0);

    UINT       cbOffset = 0;
    UINT       cbPixel  = ComputePixelStride(pDescTopLevel->Format);
    UINT       cpWidth  = pDescTopLevel->Width;
    UINT       cpHeight = pDescTopLevel->Height;
    UINT       cpDepth  = pDescTopLevel->Depth;

    // Adjust pixel->block if necessary
    BOOL isDXT       = IsDXT(cbPixel);
    BOOL isVolumeDXT = IsVolumeDXT(pDescTopLevel->Format);
    DDASSERT((UINT)isDXT <= 1);

    if (isVolumeDXT)
    {
        DXGASSERT(isDXT);
        AdjustForVolumeDXT(&cpWidth, &cpHeight, &cpDepth, &cbPixel);
    }
    else if (isDXT)
    {
        AdjustForDXT(&cpWidth, &cpHeight, &cbPixel);
    }

    for (UINT i = 0; i < iLevel; i++)
    {
        cbOffset += cpDepth * ComputeSurfaceSize(cpWidth,
                                                 cpHeight,
                                                 cbPixel);

        // Shrink width and height by half; clamp to 1 pixel
        if (cpWidth > 1)
        {
            cpWidth += (UINT)isDXT;
            cpWidth >>= 1;
        }
        if (cpHeight > 1)
        {
            cpHeight += (UINT)isDXT;
            cpHeight >>= 1;
        }
        if (cpDepth > 1)
        {
            cpDepth >>= 1;
        }
    }


    // For DXTs, the row pitch is the number of bytes
    // for a single row of blocks; which is the same
    // thing as the normal routine
    pLockedBoxData->RowPitch = ComputeSurfaceStride(cpWidth,
                                                    cbPixel);
    DXGASSERT(pLockedBoxData->RowPitch != 0);

    // For DXVs the slice pitch is the number of bytes
    // for a single plane of blocks; which is the same thing
    // as the normal routine
    pLockedBoxData->SlicePitch = ComputeSurfaceSize(cpWidth,
                                                    cpHeight,
                                                    cbPixel);
    DXGASSERT(pLockedBoxData->SlicePitch != 0);

    // Adjust for Box
    if (pBox)
    {
        UINT iStride = pLockedBoxData->RowPitch;
        UINT iSlice  = pLockedBoxData->SlicePitch;
        if (isDXT)
        {
            if (isVolumeDXT)
            {
                DXGASSERT((pBox->Front & 3) == 0);
                cbOffset += (pBox->Front / 4) * iSlice;
            }
            else
            {
                cbOffset += (pBox->Front) * iSlice;
            }

            DXGASSERT((pBox->Top  & 3) == 0);
            DXGASSERT((pBox->Left & 3) == 0);
            cbOffset += (pBox->Top  / 4) * iStride +
                        (pBox->Left / 4) * cbPixel;
        }
        else
        {
            cbOffset += pBox->Front * iSlice  +
                        pBox->Top   * iStride +
                        pBox->Left  * cbPixel;
        }
    }

    pLockedBoxData->pBits = pBits + cbOffset;

} // ComputeMipVolumeOffset


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsValidRect"

BOOL CPixel::IsValidRect(D3DFORMAT   Format,
                         UINT        Width,
                         UINT        Height,
                         const RECT *pRect)
{
    if (!VALID_PTR(pRect, sizeof(RECT)))
    {
        DPF_ERR("bad pointer for pRect");
        return FALSE;
    }

    // Treat width/height of zero as 1
    if (Width == 0)
        Width = 1;
    if (Height == 0)
        Height = 1;

    // Check that Rect is reasonable
    if ((pRect->left >= pRect->right) ||
        (pRect->top >= pRect->bottom))
    {
        DPF_ERR("Invalid Rect: zero-area.");
        return FALSE;
    }

    // Check that Rect fits the surface
    if (pRect->left   < 0             ||
        pRect->top    < 0             ||
        pRect->right  > (INT)Width    ||
        pRect->bottom > (INT)Height)
    {
        DPF_ERR("pRect doesn't fit inside the surface");
        return FALSE;
    }

    // Check if 4X4 rules are needed
    if (CPixel::Requires4X4(Format))
    {
        if ((pRect->left & 3) ||
            (pRect->top  & 3))
        {
            DPF_ERR("Rects for DXT surfaces must be on 4x4 boundaries");
            return FALSE;
        }
        if ((pRect->right & 3) && ((INT)Width != pRect->right))
        {
            DPF_ERR("Rects for DXT surfaces must be on 4x4 boundaries");
            return FALSE;
        }
        if ((pRect->bottom & 3) && ((INT)Height != pRect->bottom))
        {
            DPF_ERR("Rects for DXT surfaces must be on 4x4 boundaries");
            return FALSE;
        }
    }

    // Everything checks out
    return TRUE;
} // IsValidRect

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsValidBox"

BOOL CPixel::IsValidBox(D3DFORMAT       Format,
                        UINT            Width,
                        UINT            Height,
                        UINT            Depth,
                        const D3DBOX   *pBox)
{
    if (!VALID_PTR(pBox, sizeof(D3DBOX)))
    {
        DPF_ERR("bad pointer for pBox");
        return FALSE;
    }

    // Treat width/height/depth of zero as 1
    if (Width == 0)
        Width = 1;
    if (Height == 0)
        Height = 1;
    if (Depth == 0)
        Depth = 1;

    // Check that Box is reasonable
    if ((pBox->Left  >= pBox->Right) ||
        (pBox->Top   >= pBox->Bottom) ||
        (pBox->Front >= pBox->Back))
    {
        DPF_ERR("Invalid Box passed: non-positive volume.");
        return FALSE;
    }

    // Check that box fits the surface
    if (pBox->Right  > Width         ||
        pBox->Bottom > Height        ||
        pBox->Back   > Depth)
    {
        DPF_ERR("Box doesn't fit inside the volume");
        return FALSE;
    }

    // Check if 4X4 rules are needed
    if (CPixel::Requires4X4(Format))
    {
        if ((pBox->Left & 3) ||
            (pBox->Top  & 3))
        {
            if (CPixel::IsVolumeDXT(Format))
                DPF_ERR("Boxes for DXV volumes must be on 4x4x4 boundaries");
            else
                DPF_ERR("Boxes for DXT volumes must be on 4x4 boundaries");

            return FALSE;
        }
        if ((pBox->Right & 3) && (Width != pBox->Right))
        {
            if (CPixel::IsVolumeDXT(Format))
                DPF_ERR("Boxes for DXV volumes must be on 4x4x4 boundaries");
            else
                DPF_ERR("Boxes for DXT volumes must be on 4x4 boundaries");
            return FALSE;
        }
        if ((pBox->Bottom & 3) && (Height != pBox->Bottom))
        {
            if (CPixel::IsVolumeDXT(Format))
                DPF_ERR("Boxes for DXV volumes must be on 4x4x4 boundaries");
            else
                DPF_ERR("Boxes for DXT volumes must be on 4x4 boundaries");
            return FALSE;
        }

        if (CPixel::IsVolumeDXT(Format))
        {
            // For Volume DXT; we need to check front/back too
            if (pBox->Front & 3)
            {
                DPF_ERR("Boxes for DXV volumes must be on 4x4x4 boundaries");
                return FALSE;
            }
            if ((pBox->Back & 3) && (Depth != pBox->Back))
            {
                DPF_ERR("Boxes for DXV volumes must be on 4x4x4 boundaries");
                return FALSE;
            }
        }
    }

    // Everything checks out
    return TRUE;
} // IsValidBox

D3DFORMAT CPixel::SuppressAlphaChannel(D3DFORMAT Format)
{
    switch(Format)
    {
    case D3DFMT_A8R8G8B8:
        return D3DFMT_X8R8G8B8;
    case D3DFMT_A1R5G5B5:
        return D3DFMT_X1R5G5B5;
    case D3DFMT_A4R4G4B4:
        return D3DFMT_X4R4G4B4;
    }

    return Format;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::Register"

HRESULT CPixel::Register(D3DFORMAT Format, DWORD BPP)
{
    DXGASSERT(BPP != 0);

    // Do not register duplicates
    for(IHVFormatInfo *p = m_pFormatList; p != 0; p = p->m_pNext)
    {
        if (p->m_Format == Format)
        {
            return S_OK;
        }
    }

    // Not found, add to registry.
    // This allocation will be leaked, but since
    // we don't expect to have a large number of
    // IHV formats, the leak is not a big deal.
    // Also, the leak will be immediately recovered
    // upon process exit.
    p = new IHVFormatInfo;
    if (p == 0)
    {
        return E_OUTOFMEMORY;
    }
    p->m_Format = Format;
    p->m_BPP = BPP;
    p->m_pNext = m_pFormatList;
    m_pFormatList = p;

    return S_OK;
}

// End of file : pixel.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\mipvol.hpp ===
#ifndef __MIPVOL_HPP__
#define __MIPVOL_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mipvol.hpp
 *  Content:    Class header the mip-volume class. This class acts a 
 *              container for Volumes that are used as textures.
 *
 *
 ***************************************************************************/

// Includes
#include "texture.hpp"
#include "pixel.hpp"

// Forward decls
class CVolume;

//
// The mip-map class holds a collection of CVolumes. The MipVolume class
// implements the IDirect3DVolumeTexture8 interface; each Volume implements 
// the IDirect3DVolume8 interface. To reduce overhead per level, we have
// put most of the "real" guts of each volume into the container class;
// i.e. most of the methods of the Volume really just end up calling
// something in the MipVolume object.
//
// The base class implementation assumes a sys-mem allocation.
//

class CMipVolume : public CBaseTexture, public IDirect3DVolumeTexture8
{
public:
    // Creation method to allow creation of MipVolumes no matter
    // their actual underlying type.
    static HRESULT Create(CBaseDevice              *pDevice, 
                          DWORD                     cpWidth,
                          DWORD                     cpHeight,
                          DWORD                     cpDepth,
                          DWORD                     cLevels,
                          DWORD                     dwUsage,
                          D3DFORMAT                 Format,
                          D3DPOOL                   Pool,
                          IDirect3DVolumeTexture8 **ppMipVolume);

    // Destructor
    virtual ~CMipVolume();

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID  riid, 
                               VOID  **ppvObj);
    STDMETHOD_(ULONG,AddRef)  ();
    STDMETHOD_(ULONG,Release) ();

    // IDirect3DResource methods
    STDMETHOD(GetDevice) (IDirect3DDevice8 **ppvObj);

    STDMETHOD(SetPrivateData)(REFGUID  riid, 
                              CONST VOID    *pvData, 
                              DWORD    cbData, 
                              DWORD    dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID  riid, 
                              VOID    *pvData, 
                              DWORD   *pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD_(DWORD, GetPriority)();
    STDMETHOD_(DWORD, SetPriority)(DWORD dwPriority);
    STDMETHOD_(void, PreLoad)();
    STDMETHOD_(D3DRESOURCETYPE, GetType)();

    // IDirect3DMipTexture methods
    STDMETHOD_(DWORD, GetLOD)();
    STDMETHOD_(DWORD, SetLOD)(DWORD dwLOD);
    STDMETHOD_(DWORD, GetLevelCount)();

    // IDirect3DMipVolume methods
    STDMETHOD(GetLevelDesc)(UINT iLevel, D3DVOLUME_DESC *pDesc);
    STDMETHOD(GetVolumeLevel)(UINT                iLevel,
                              IDirect3DVolume8  **ppVolumeLevel);

    STDMETHOD(LockBox)(UINT             iLevel,
                       D3DLOCKED_BOX   *pLockedBox, 
                       CONST D3DBOX    *pBox, 
                       DWORD            dwFlags);
    STDMETHOD(UnlockBox)(UINT           iLevel);


    STDMETHOD(AddDirtyBox)(CONST D3DBOX *pBox);

    // Direct accessor for surface descriptor
    const D3DVOLUME_DESC *Desc() const
    {
        return &m_desc;
    } // AccessDesc;

    // Helper for Lock
    void ComputeMipVolumeOffset(UINT            iLevel, 
                                CONST D3DBOX   *pBox, 
                                D3DLOCKED_BOX  *pLockedBoxData)
    {
        CPixel::ComputeMipVolumeOffset(Desc(),
                                       iLevel,
                                       m_rgbPixels,
                                       pBox,
                                       pLockedBoxData);
    } // ComputeMipVolumeOffset

    // Notification when a mip-level is locked for writing
    void OnVolumeLock(DWORD iLevel, CONST D3DBOX *pBox, DWORD dwFlags);


    // Methods for the CResource

    // Specifies a creation of a resource that
    // looks just like the current one; in a new POOL
    // with a new LOD.
    virtual HRESULT Clone(D3DPOOL     Pool, 
                          CResource **ppResource) const;

    // Provides a method to access basic structure of the
    // pieces of the resource. 
    virtual const D3DBUFFER_DESC* GetBufferDesc() const;

    // Updates destination with source dirty rects
    virtual HRESULT UpdateDirtyPortion(CResource *pResourceTarget);

    // Allows the Resource Manager to mark the texture
    // as needing to be completely updated on next
    // call to UpdateDirtyPortion
    virtual void MarkAllDirty();

    // Methods for CBaseTexture

    // Method for UpdateTexture to call; does type-specific
    // parameter checking before calling UpdateDirtyPortion
    virtual HRESULT UpdateTexture(CBaseTexture *pTextureTarget);

    // Parameter validation method to make sure that no part of
    // the texture is locked.
#ifdef DEBUG
    virtual BOOL IsTextureLocked();
#endif  // DEBUG


private:
    // Constructor returns an error code
    // if the object could not be fully
    // constructed
    CMipVolume(CBaseDevice *pDevice, 
               DWORD        cpWidth,
               DWORD        cpHeight,
               DWORD        cpDepth,
               DWORD        cLevels,
               DWORD        dwUsage,
               D3DFORMAT    Format,
               D3DPOOL      Pool,
               REF_TYPE     refType,
               HRESULT     *phr
               );

    // Internal implementation of AddDirtyBox
    void InternalAddDirtyBox(CONST D3DBOX *pBox);

    // Each MipVolume has an array of CMipSurfaces
    CVolume        **m_VolumeArray;
    
    // Each MipVolume has a memory block that holds
    // all the pixel data in a contiguous chunk
    BYTE            *m_rgbPixels;

    // Keep track of description
    D3DVOLUME_DESC m_desc;

    // In DX7 we kept track of upto 6 RECTs per mip-chain.
    // These rects indicate which portion of the top-most level of
    // a mip-chain were modified. (We continue to ignore modifications 
    // to lower levels of the mip-chain. This is by-design.)
    //
    // For MipVolumes, we follow the same guidelines.. but it is less
    // clear that this is the right number to choose.
     
    enum 
    {
        MIPVOLUME_MAXDIRTYBOX  = 6,
        MIPVOLUME_ALLDIRTY     = 7
    };

    D3DBOX     m_DirtyBoxArray[MIPVOLUME_MAXDIRTYBOX];

    // If m_cBoxUsed is greater than MIPVOLUME_MAXDIRTYBOX
    // then it means that everything is dirty
    UINT        m_cBoxUsed;

}; // class CMipVolume

#endif // __MIPVOL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\resource.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rman.cpp
 *  Content:    Resource management
 *
 ***************************************************************************/

#include "ddrawpr.h"
#include "dxgint.h"
#include "resource.hpp"
#include "texture.hpp"
#include "d3di.hpp"
#include "ddi.h"

// Always use heap 0
DWORD CMgmtInfo::m_rmHeap = 0;

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::UpdateDirtyPortion"

// These stub functions are only supported for managed resources;
// they should never get called; the asserts are there to help
// determine where the bug is if they do get called.
HRESULT CResource::UpdateDirtyPortion(CResource *pResourceTarget)
{
    // This should not be called except for D3D_MANAGED
    // objects because we don't keep dirty portion records
    // for other kinds of objects.

    // If we were D3D_MANAGED: the real class should have
    // overriden this method
    DXGASSERT(!IsTypeD3DManaged(Device(), 
                                GetBufferDesc()->Type,
                                GetBufferDesc()->Pool));

    // If this isn't D3DManaged, we shouldn't have
    // been called.
    DXGASSERT(FALSE);

    // return something benign for retail build
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::MarkAllDirty"

void CResource::MarkAllDirty()
{
    // This should not be called except for D3D_MANAGED
    // objects because we don't keep dirty portion records
    // for other kinds of objects.

    // If we were D3D_MANAGED: the real class should have
    // overriden this method
    DXGASSERT(!IsTypeD3DManaged(Device(), 
                                GetBufferDesc()->Type,
                                GetBufferDesc()->Pool));

    // If this isn't D3DManaged, we shouldn't have
    // been called.
    DXGASSERT(FALSE);
} // CResource::MarkAllDirty

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::SetPriorityImpl"

DWORD CResource::SetPriorityImpl(DWORD newPri)
{
    DWORD oldPriority = 0;
    if (IsD3DManaged())
    {
        oldPriority = Device()->ResourceManager()->SetPriority(m_RMHandle, newPri);        
    }
    // If IsD3DManaged() is FALSE and if the actual pool
    // is found to be D3DPOOL_MANAGED then the resource
    // MUST be driver managed.
    else if (GetBufferDesc()->Pool == D3DPOOL_MANAGED)
    {
        CD3DBase *pDev = static_cast<CD3DBase*>(Device());
        DXGASSERT(IS_DX8HAL_DEVICE(pDev));
        oldPriority = SetPriorityI(newPri);
        pDev->SetPriority(this, newPri);
    }
    // If above two conditions are false, then we must
    // check if we have fallen back to sysmem for some
    // reason even if the app requested managed. We
    // can know whether the app requested D3DPOOL_MANAGED
    // by calling GetUserPool().
    else if (GetUserPool() == D3DPOOL_MANAGED)
    {
        // We assert because sysmem fallback is currently
        // possible for only vertex or index buffers.
        DXGASSERT(GetBufferDesc()->Type == D3DRTYPE_VERTEXBUFFER ||
                  GetBufferDesc()->Type == D3DRTYPE_INDEXBUFFER);
        // No need to do any real work since the
        // resource is in sysmem in any case.
        oldPriority = SetPriorityI(newPri);
    }
    else
    {
        DPF_ERR("Priority set on non-managed object. SetPriority returns zero.");
    }
    return oldPriority;
} // SetPriorityImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::GetPriorityImpl"

DWORD CResource::GetPriorityImpl()
{
    if (!IsD3DManaged() && GetBufferDesc()->Pool != D3DPOOL_MANAGED && GetUserPool() != D3DPOOL_MANAGED)
    {
        DPF_ERR("Priority accessed on non-managed object. GetPriority returns zero.");
        return 0;
    }
    return GetPriorityI();    
} // GetPriorityImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::PreLoadImpl"
void CResource::PreLoadImpl()
{
    if (IsD3DManaged())
    {
        Device()->ResourceManager()->PreLoad(m_RMHandle);
    }
    // If IsD3DManaged() is FALSE and if the actual pool
    // is found to be D3DPOOL_MANAGED then the resource
    // MUST be driver managed.
    else if (GetBufferDesc()->Pool == D3DPOOL_MANAGED)
    {
        CD3DBase *pDev = static_cast<CD3DBase*>(Device());
        DXGASSERT(IS_DX8HAL_DEVICE(pDev));
        if(GetBufferDesc()->Type == D3DRTYPE_TEXTURE ||
           GetBufferDesc()->Type == D3DRTYPE_VOLUMETEXTURE ||
           GetBufferDesc()->Type == D3DRTYPE_CUBETEXTURE)
        {
            POINT p = {0, 0};
            RECTL r = {0, 0, 0, 0};
            pDev->TexBlt(0, 
                         static_cast<CBaseTexture*>(this), 
                         &p, 
                         &r);
        }
        else
        {
            DXGASSERT(GetBufferDesc()->Type == D3DRTYPE_VERTEXBUFFER ||
                      GetBufferDesc()->Type == D3DRTYPE_INDEXBUFFER);
            D3DRANGE range = {0, 0};
            pDev->BufBlt(0,
                         static_cast<CBuffer*>(this), 
                         0,
                         &range);
        }
    }
    // If above two conditions are false, then we must
    // check if we have fallen back to sysmem for some
    // reason even if the app requested managed. We
    // can know whether the app requested D3DPOOL_MANAGED
    // by calling GetUserPool().
    else if (GetUserPool() == D3DPOOL_MANAGED)
    {
        // We assert because sysmem fallback is currently
        // possible for only vertex or index buffers.
        DXGASSERT(GetBufferDesc()->Type == D3DRTYPE_VERTEXBUFFER ||
                  GetBufferDesc()->Type == D3DRTYPE_INDEXBUFFER);

        // Do nothing since vertex/index buffer are in sysmem
        // and preload has no meaning
    }
    else
    {
        DPF_ERR("PreLoad called on non-managed object");
    }
} // PreLoadImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::RestoreDriverManagementState"

HRESULT CResource::RestoreDriverManagementState(CBaseDevice *pDevice)
{
    for(CResource *pRes = pDevice->GetResourceList(); pRes != 0; pRes = pRes->m_pNext)
    {
        if (pRes->GetBufferDesc()->Pool == D3DPOOL_MANAGED && !pRes->IsD3DManaged()) // Must be driver managed
        {
            static_cast<CD3DBase*>(pDevice)->SetPriority(pRes, pRes->GetPriorityI());
            if (pRes->GetBufferDesc()->Type == D3DRTYPE_TEXTURE ||
                pRes->GetBufferDesc()->Type == D3DRTYPE_VOLUMETEXTURE ||
                pRes->GetBufferDesc()->Type == D3DRTYPE_CUBETEXTURE)
            {
                static_cast<CD3DBase*>(pDevice)->SetTexLOD(static_cast<CBaseTexture*>(pRes), 
                                                           static_cast<CBaseTexture*>(pRes)->GetLODI());
            }
            // We need to update cached pointers for read/write vertex and index buffers
            else if (pRes->GetBufferDesc()->Type == D3DRTYPE_VERTEXBUFFER &&
                     (pRes->GetBufferDesc()->Usage & D3DUSAGE_WRITEONLY) == 0)
            {
                HRESULT hr = static_cast<CDriverManagedVertexBuffer*>(pRes)->UpdateCachedPointer(pDevice);
                if (FAILED(hr))
                {
                    return hr;
                }
            }
            else if (pRes->GetBufferDesc()->Type == D3DRTYPE_INDEXBUFFER &&
                     (pRes->GetBufferDesc()->Usage & D3DUSAGE_WRITEONLY) == 0)
            {
                HRESULT hr = static_cast<CDriverManagedIndexBuffer*>(pRes)->UpdateCachedPointer(pDevice);
                if (FAILED(hr))
                {
                    return hr;
                }
            }
        }
    }
    return S_OK;
} // RestoreDriverManagementState

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::Initialize"

BOOL CRMHeap::Initialize()
{
    m_data_p = new CMgmtInfo*[m_size];
    if (m_data_p == 0)
    {
        DPF_ERR("Failed to allocate texture heap.");
        return FALSE;
    }
    memset(m_data_p, 0, sizeof(CMgmtInfo*) * m_size);
    return TRUE;
} // CRMHeap::Initialize

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::heapify"

void CRMHeap::heapify(DWORD k)
{
    while(TRUE)
    {
        DWORD smallest;
        DWORD l = lchild(k);
        DWORD r = rchild(k);
        if (l < m_next)
            if (m_data_p[l]->Cost() < m_data_p[k]->Cost())
                smallest = l;
            else
                smallest = k;
        else
            smallest = k;
        if (r < m_next)
            if (m_data_p[r]->Cost() < m_data_p[smallest]->Cost())
                smallest = r;
        if (smallest != k)
        {
            CMgmtInfo *t = m_data_p[k];
            m_data_p[k] = m_data_p[smallest];
            m_data_p[k]->m_rmHeapIndex = k;
            m_data_p[smallest] = t;
            m_data_p[smallest]->m_rmHeapIndex = smallest;
            k = smallest;
        }
        else
            break;
    }
} // CRMHeap::heapify

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::add"

BOOL CRMHeap::add(CMgmtInfo *pMgmtInfo)
{
    DXGASSERT(pMgmtInfo->m_rmHeapIndex == 0);
    if (m_next == m_size)
    {
        m_size = m_size * 2 - 1;
        CMgmtInfo **p = new CMgmtInfo*[m_size];
        if (p == 0)
        {
            DPF_ERR("Failed to allocate memory to grow heap.");
            m_size = (m_size + 1) / 2; // restore size
            return FALSE;
        }
        memcpy(p + 1, m_data_p + 1, sizeof(CMgmtInfo*) * (m_next - 1));
        delete[] m_data_p;
        m_data_p = p;
    }
    ULONGLONG Cost = pMgmtInfo->Cost();
    for (DWORD k = m_next; k > 1; k = parent(k))
        if (Cost < m_data_p[parent(k)]->Cost())
        {
            m_data_p[k] = m_data_p[parent(k)];
            m_data_p[k]->m_rmHeapIndex = k;
        }
        else
            break;
    m_data_p[k] = pMgmtInfo;
    m_data_p[k]->m_rmHeapIndex = k;
    ++m_next;
    return TRUE;
} // CRMHeap::add

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::extractMin"

CMgmtInfo* CRMHeap::extractMin()
{
    CMgmtInfo *pMgmtInfo = m_data_p[1];
    --m_next;
    m_data_p[1] = m_data_p[m_next];
    m_data_p[1]->m_rmHeapIndex = 1;
    heapify(1);
    pMgmtInfo->m_rmHeapIndex = 0;
    return pMgmtInfo;
} // CRMHeap::extractMin

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::extractMax"

CMgmtInfo* CRMHeap::extractMax()
{
    // When extracting the max element from the heap, we don't need to
    // search the entire heap, but just the leafnodes. This is because
    // it is guaranteed that parent nodes are cheaper than the leaf nodes
    // so once you have looked through the leaves, you won't find anything
    // cheaper.
    // NOTE: (lchild(i) >= m_next) is TRUE only for leaf nodes.
    // ALSO NOTE: You cannot have a rchild without a lchild, so simply
    //            checking for lchild is sufficient.
    // 
    // CONSIDER(40358): Should have asserts to verify above assumptions; but
    //                  it would require writing a heap-consistency
    //                  checker. Maybe someday.
    //
    unsigned max = m_next - 1;
    ULONGLONG maxcost = 0;
    for (unsigned i = max; lchild(i) >= m_next; --i)
    {
        ULONGLONG Cost = m_data_p[i]->Cost();
        if (maxcost < Cost)
        {
            maxcost = Cost;
            max = i;
        }
    }
    CMgmtInfo* pMgmtInfo = m_data_p[max];
    if (pMgmtInfo->m_bInUse)
    {
        max = 0;
        maxcost = 0;
        for (i = m_next - 1; i > 0; --i)
        {
            ULONGLONG Cost = m_data_p[i]->Cost();
            if (maxcost < Cost && !m_data_p[i]->m_bInUse)
            {
                maxcost = Cost;
                max = i;
            }
        }
        if (max == 0) // All textures in use
            return 0;
        pMgmtInfo = m_data_p[max];
    }
    del(m_data_p[max]);
    return pMgmtInfo;
} // CRMHeap::extractMax

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::extractNotInScene"

CMgmtInfo* CRMHeap::extractNotInScene(DWORD dwScene)
{
    for (unsigned i = 1; i < m_next; ++i)
    {
        if (m_data_p[i]->m_scene != dwScene)
        {
            CMgmtInfo* pMgmtInfo = m_data_p[i];
            del(m_data_p[i]);
            return pMgmtInfo;
        }
    }
    return 0;
} // CRMHeap::extractNotInScene

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::del"

void CRMHeap::del(CMgmtInfo* pMgmtInfo)
{
    DWORD k = pMgmtInfo->m_rmHeapIndex;
    --m_next;
    ULONGLONG Cost = m_data_p[m_next]->Cost();
    if (Cost < pMgmtInfo->Cost())
    {
        while(k > 1)
        {
            if (Cost < m_data_p[parent(k)]->Cost())
            {
                m_data_p[k] = m_data_p[parent(k)];
                m_data_p[k]->m_rmHeapIndex = k;
            }
            else
                break;
            k = parent(k);
        }
        m_data_p[k] = m_data_p[m_next];
        m_data_p[k]->m_rmHeapIndex = k;
    }
    else
    {
        m_data_p[k] = m_data_p[m_next];
        m_data_p[k]->m_rmHeapIndex = k;
        heapify(k);
    }
    pMgmtInfo->m_rmHeapIndex = 0;
} // CRMHeap::del

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::update"

void CRMHeap::update(CMgmtInfo* pMgmtInfo, BOOL inuse, DWORD priority, DWORD ticks)
{
    DWORD k = pMgmtInfo->m_rmHeapIndex;
    ULONGLONG Cost;
#ifdef _X86_
    _asm
    {
        mov     edx, inuse;
        shl     edx, 31;
        mov     eax, priority;
        mov     ecx, eax;
        shr     eax, 1;
        or      edx, eax;
        mov     DWORD PTR Cost + 4, edx;
        shl     ecx, 31;
        mov     eax, ticks;
        shr     eax, 1;
        or      eax, ecx;
        mov     DWORD PTR Cost, eax;
    }
#else
    Cost = ((ULONGLONG)inuse << 63) + ((ULONGLONG)priority << 31) + ((ULONGLONG)(ticks >> 1));
#endif
    if (Cost < pMgmtInfo->Cost())
    {
        while(k > 1)
        {
            if (Cost < m_data_p[parent(k)]->Cost())
            {
                m_data_p[k] = m_data_p[parent(k)];
                m_data_p[k]->m_rmHeapIndex = k;
            }
            else
                break;
            k = parent(k);
        }
        pMgmtInfo->m_bInUse = inuse;
        pMgmtInfo->m_priority = priority;
        pMgmtInfo->m_ticks = ticks;
        pMgmtInfo->m_rmHeapIndex = k;
        m_data_p[k] = pMgmtInfo;
    }
    else
    {
        pMgmtInfo->m_bInUse = inuse;
        pMgmtInfo->m_priority = priority;
        pMgmtInfo->m_ticks = ticks;
        heapify(k);
    }
} // CRMHeap::update

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::resetAllTimeStamps"

void CRMHeap::resetAllTimeStamps(DWORD ticks)
{
    for (unsigned i = 1; i < m_next; ++i)
    {
        update(m_data_p[i], m_data_p[i]->m_bInUse, m_data_p[i]->m_priority, ticks);
    }
} // CRMHeap::resetAllTimeStamps

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::Init"

HRESULT CResourceManager::Init(CBaseDevice *pD3D8)
{
    const D3DCAPS8* pCaps = pD3D8->GetD3DCaps();
    if (pCaps != 0)
        if (pCaps->DevCaps & D3DDEVCAPS_SEPARATETEXTUREMEMORIES)
        {
            m_dwNumHeaps = pD3D8->GetD3DCaps()->MaxSimultaneousTextures;
            if (m_dwNumHeaps < 1)
            {
                DPF_ERR("Max simultaneous textures not set. Forced to 1.");
                m_dwNumHeaps = 1;
            }
            DPF(2, "Number of heaps set to %u.", m_dwNumHeaps);
        }
        else
            m_dwNumHeaps = 1;
    else
        m_dwNumHeaps = 1;
    m_heap_p = new CRMHeap[m_dwNumHeaps];
    if (m_heap_p == 0)
    {
        DPF_ERR("Out of memory allocating texture heap.");
        return E_OUTOFMEMORY;
    }
    for (DWORD i = 0; i < m_dwNumHeaps; ++i)
    {
        if (m_heap_p[i].Initialize() == FALSE)
        {
            delete[] m_heap_p;
            m_heap_p = 0;
            return E_OUTOFMEMORY;
        }
    }
    m_pD3D8 = pD3D8;
    return S_OK;
} // CResourceManager::Init

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::IsDriverManaged"

BOOL CResourceManager::IsDriverManaged(D3DRESOURCETYPE Type) const
{
#if DBG
    switch (Type)
    {
    case D3DRTYPE_TEXTURE:
    case D3DRTYPE_VOLUMETEXTURE:
    case D3DRTYPE_CUBETEXTURE:
    case D3DRTYPE_VERTEXBUFFER:
    case D3DRTYPE_INDEXBUFFER:
        break;

    default:
        DXGASSERT(FALSE && "Management not supported for this type");
        return FALSE;
    };
#endif // DBG

    return m_pD3D8->CanDriverManageResource();

}; // IsDriverManaged(D3DRESOURCETYPE)

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::Manage"

HRESULT CResourceManager::Manage(CResource *pResource, RMHANDLE *pHandle)
{
    *pHandle = 0;
    DXGASSERT(!pResource->IsD3DManaged());

    CMgmtInfo *pRMInfo = new CMgmtInfo(pResource);        
    if (pRMInfo == 0)
    {
        return E_OUTOFMEMORY;
    }
    *pHandle = pRMInfo;
    return S_OK;
} // CResourceManager::Manage

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::UnManage"

void CResourceManager::UnManage(RMHANDLE hRMHandle)
{
    CMgmtInfo* &pMgmtInfo = hRMHandle;
    if (pMgmtInfo == 0)
        return;
    if (InVidmem(hRMHandle))
    {
        m_heap_p[pMgmtInfo->m_rmHeap].del(pMgmtInfo);
    }
    delete pMgmtInfo;
} // CResourceManager::UnManage

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::SetPriority"

DWORD CResourceManager::SetPriority(RMHANDLE hRMHandle, DWORD newPriority)
{
    CMgmtInfo* &pMgmtInfo = hRMHandle;
    DXGASSERT(pMgmtInfo != 0);
    DWORD oldPriority = pMgmtInfo->m_pBackup->SetPriorityI(newPriority);
    if (InVidmem(hRMHandle))
    {
        m_heap_p[pMgmtInfo->m_rmHeap].update(pMgmtInfo, pMgmtInfo->m_bInUse, newPriority, pMgmtInfo->m_ticks); 
    }
    return oldPriority;
} // CResourceManager::SetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::SetLOD"

DWORD CResourceManager::SetLOD(RMHANDLE hRMHandle, DWORD dwLodNew)
{
    DWORD oldLOD;
    CMgmtInfo* &pMgmtInfo = hRMHandle;
    DXGASSERT(pMgmtInfo != 0);
    DXGASSERT(pMgmtInfo->m_pBackup->GetBufferDesc()->Type == D3DRTYPE_TEXTURE ||
              pMgmtInfo->m_pBackup->GetBufferDesc()->Type == D3DRTYPE_VOLUMETEXTURE ||
              pMgmtInfo->m_pBackup->GetBufferDesc()->Type == D3DRTYPE_CUBETEXTURE);
    CBaseTexture *pTex = static_cast<CBaseTexture*>(pMgmtInfo->m_pBackup);
    if (dwLodNew < pTex->GetLevelCount())
    {
        oldLOD = pTex->SetLODI(dwLodNew);
    }
    else
    {
        DPF_ERR("Texture does not have sufficient miplevels for current LOD. LOD set to GetLevelCount()-1.");
        oldLOD = pTex->SetLODI(pTex->GetLevelCount() - 1);
    }
    if (InVidmem(hRMHandle))
    {
        m_heap_p[pMgmtInfo->m_rmHeap].del(pMgmtInfo); 
        pMgmtInfo->m_pRes->DecrementUseCount();
        pMgmtInfo->m_pRes = 0;
        static_cast<LPD3DBASE>(this->m_pD3D8)->NeedResourceStateUpdate(); // Need to call this so that DrawPrimitive will do the necessary work
    }
    return oldLOD;
} // CResourceManager::SetLOD

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::PreLoad"
void CResourceManager::PreLoad(RMHANDLE hRMHandle)
{
    CMgmtInfo* &pMgmtInfo = hRMHandle;
    DXGASSERT(pMgmtInfo != 0);
    BOOL  bDirty = FALSE;
    m_PreLoading = TRUE;
    UpdateVideo(hRMHandle, &bDirty);
    m_PreLoading = FALSE;
} // CResourceManaged::PreLoad

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::Lock"

void CResourceManager::Lock(RMHANDLE hRMHandle)
{
    if (hRMHandle != 0)
    {
        CMgmtInfo* &pMgmtInfo = hRMHandle;
        if (InVidmem(hRMHandle))
        {
            m_heap_p[pMgmtInfo->m_rmHeap].update(pMgmtInfo, TRUE, pMgmtInfo->m_pBackup->GetPriorityI(), pMgmtInfo->m_ticks); 
        }
    }
} // CResourceManager::Lock

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::Unlock"

void CResourceManager::Unlock(RMHANDLE hRMHandle)
{
    if (hRMHandle != 0)
    {
        CMgmtInfo* &pMgmtInfo = hRMHandle;
        if (InVidmem(hRMHandle))
        {
            m_heap_p[pMgmtInfo->m_rmHeap].update(pMgmtInfo, FALSE, pMgmtInfo->m_pBackup->GetPriorityI(), pMgmtInfo->m_ticks); 
        }
    }
} // CResourceManager::Unlock

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::FreeResources"

BOOL CResourceManager::FreeResources(DWORD dwHeap, DWORD dwBytes)
{
    if (m_heap_p[dwHeap].length() == 0)
        return FALSE;
    unsigned sz;
    CMgmtInfo *rc;
    for (unsigned i = 0; m_heap_p[dwHeap].length() != 0 && i < dwBytes; i += sz)
    {
        // Find the LRU texture and remove it.
        rc = m_heap_p[dwHeap].minCost();
        if (rc->m_bInUse)
            return FALSE;
        sz = rc->m_pRes->GetBufferDesc()->Size; // save size
        if (rc->m_scene == m_dwScene)
        {
            if(m_PreLoading)
            {
                return TRUE;
            }
            if (m_pD3D8->GetD3DCaps()->RasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR)
            {                
                DPF(0, "Trying to locate texture not used in current scene...");
                rc = m_heap_p[dwHeap].extractNotInScene(m_dwScene);
                if (rc == 0)
                {
                    DPF_ERR("No such texture found. Cannot evict textures used in current scene.");
                    return FALSE;
                }
                DPF(0, "Texture found!");
                rc->m_pRes->DecrementUseCount();
                rc->m_pRes = 0;
            }
            else
            {
                DPF(1, "Texture cache thrashing. Removing MRU texture.");
                rc = m_heap_p[dwHeap].extractMax();
                if (rc == 0)
                {
                    DPF_ERR("All textures in use, cannot evict texture.");
                    return FALSE;
                }
                rc->m_pRes->DecrementUseCount();
                rc->m_pRes = 0;
            }
        }
        else
        {
            rc = m_heap_p[dwHeap].extractMin();
            rc->m_pRes->DecrementUseCount();
            rc->m_pRes = 0;
        }
        DPF(2, "Removed texture with timestamp %u,%u (current = %u).", rc->m_priority, rc->m_ticks, tcm_ticks);
    }
    return TRUE;
} // CResourceManager::FreeResources

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::DiscardBytes"

void CResourceManager::DiscardBytes(DWORD cbBytes)
{
    for (DWORD i = 0; i < m_dwNumHeaps; ++i)
    {
        if (cbBytes == 0)
        {
            while(m_heap_p[i].length())
            {
                CMgmtInfo *pMgmtInfo = m_heap_p[i].extractMin();
                pMgmtInfo->m_pRes->DecrementUseCount();
                pMgmtInfo->m_pRes = 0;
            }
        }
        else
        {
            FreeResources(i, cbBytes / m_dwNumHeaps);
        }
    }
    static_cast<LPD3DBASE>(m_pD3D8)->NeedResourceStateUpdate();
    tcm_ticks = 0;
    m_dwScene = 0;
} // CResourceManager::DiscardBytes

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::TimeStamp"

void CResourceManager::TimeStamp(CMgmtInfo *pMgmtInfo)
{
    pMgmtInfo->m_scene = m_dwScene;
    m_heap_p[pMgmtInfo->m_rmHeap].update(pMgmtInfo, pMgmtInfo->m_bInUse, pMgmtInfo->m_pBackup->GetPriorityI(), tcm_ticks);
    unsigned tickp2 = tcm_ticks + 2;
    if (tickp2 > tcm_ticks)
    {
        tcm_ticks = tickp2;
    }
    else // counter has overflowed. Let's reset all timestamps to zero
    {
        DPF(2, "Timestamp counter overflowed. Reseting timestamps for all textures.");
        tcm_ticks = 0;
        for (DWORD i = 0; i < m_dwNumHeaps; ++i)
            m_heap_p[i].resetAllTimeStamps(0);
    }
} // CResourceManager::TimeStamp

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::UpdateVideoInternal"

HRESULT CResourceManager::UpdateVideoInternal(CMgmtInfo *pMgmtInfo)
{
    HRESULT ddrval;
    DWORD trycount = 0, bytecount = pMgmtInfo->m_pBackup->GetBufferDesc()->Size;
    LPD3DBASE lpDevI = static_cast<LPD3DBASE>(m_pD3D8);
    // We need to make sure that we don't evict any mapped textures
    for (DWORD dwStage = 0; dwStage < lpDevI->m_dwMaxTextureBlendStages; ++dwStage)
    {
        if (lpDevI->m_lpD3DMappedTexI[dwStage] != 0)
        {
            Lock(lpDevI->m_lpD3DMappedTexI[dwStage]->RMHandle());
        }
    }
    for (DWORD dwStream = 0; dwStream < lpDevI->m_dwNumStreams; ++dwStream)
    {
        if (lpDevI->m_pStream[dwStream].m_pVB != 0)
        {
            Lock(lpDevI->m_pStream[dwStream].m_pVB->RMHandle());
        }
    }
    if (lpDevI->m_pIndexStream->m_pVBI != 0)
    {
        Lock(lpDevI->m_pIndexStream->m_pVBI->RMHandle());
    }
    // Attempt to allocate a texture.
    do
    {
        ++trycount;
        ddrval = pMgmtInfo->m_pBackup->Clone(D3DPOOL_DEFAULT, &pMgmtInfo->m_pRes);
        if (SUCCEEDED(ddrval)) // No problem, there is enough memory.
        {
            pMgmtInfo->m_scene = m_dwScene;
            pMgmtInfo->m_ticks = tcm_ticks;
            DXGASSERT(pMgmtInfo->m_rmHeapIndex == 0);
            if (!m_heap_p[pMgmtInfo->m_rmHeap].add(pMgmtInfo))
            {
                ddrval = E_OUTOFMEMORY;
                goto exit2;
            }
        }
        else if (ddrval == D3DERR_OUTOFVIDEOMEMORY) // If out of video memory
        {
            if (!FreeResources(pMgmtInfo->m_rmHeap, bytecount))
            {
                DPF_ERR("all Freed no further video memory available");
                ddrval = D3DERR_OUTOFVIDEOMEMORY;        //nothing left
                goto exit1;
            }
            bytecount <<= 1;
        }
        else
        {
            D3DRESOURCETYPE Type = pMgmtInfo->m_pBackup->GetBufferDesc()->Type;
            if (Type == D3DRTYPE_VERTEXBUFFER ||
                Type == D3DRTYPE_INDEXBUFFER)
            {
                if (lpDevI->VBFailOversDisabled())
                {
                    DPF_ERR("Cannot create Vidmem or Driver managed VB/IB. Will ***NOT*** failover to Sysmem.");
                    goto exit1;
                }
                // Fallback to sysmem
                DPF(5, "Driver does not support vidmem VB, falling back to sysmem");
                CResource *pRes = pMgmtInfo->m_pBackup;
                pRes->DeleteRMHandle();
                // HACK HACK HACK
                ((D3DBUFFER_DESC*)pRes->GetBufferDesc())->Pool = D3DPOOL_SYSTEMMEM;
                ddrval = S_OK;
            }
            else
            {
                DPF(0, "Unexpected error in Clone %08x", ddrval);
            }
            goto exit1;
        }
    }
    while (ddrval == D3DERR_OUTOFVIDEOMEMORY);

    if (trycount > 1)
    {
        lpDevI->NeedResourceStateUpdate();
        DPF(1, "Allocated texture after %u tries.", trycount);
    }
    pMgmtInfo->m_pBackup->MarkAllDirty();
    ddrval = pMgmtInfo->m_pBackup->UpdateDirtyPortion(pMgmtInfo->m_pRes);
    if (FAILED(ddrval))
    {
        DPF(0, "Unexpected error in UpdateDirtyPortion %08x", ddrval);
        goto exit3;
    }
    ddrval = S_OK;
    goto exit1;
exit3:
    m_heap_p[pMgmtInfo->m_rmHeap].del(pMgmtInfo);
exit2:
    pMgmtInfo->m_pRes->DecrementUseCount();
    pMgmtInfo->m_pRes = 0;
exit1:
    for (dwStage = 0; dwStage < lpDevI->m_dwMaxTextureBlendStages; ++dwStage)
    {
        if (lpDevI->m_lpD3DMappedTexI[dwStage])
        {
            Unlock(lpDevI->m_lpD3DMappedTexI[dwStage]->RMHandle());
        }
    }
    for (dwStream = 0; dwStream < lpDevI->m_dwNumStreams; ++dwStream)
    {
        if (lpDevI->m_pStream[dwStream].m_pVB != 0)
        {
            Unlock(lpDevI->m_pStream[dwStream].m_pVB->RMHandle());
        }
    }
    if (lpDevI->m_pIndexStream->m_pVBI != 0)
    {
        Unlock(lpDevI->m_pIndexStream->m_pVBI->RMHandle());
    }
    return ddrval;
} // CResourceManager::UpdateVideo

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::OnResourceDirty"

void CResourceManager::OnResourceDirty(RMHANDLE hRMHandle) const
{
    static_cast<LPD3DBASE>(m_pD3D8)->NeedResourceStateUpdate();
} // CResourceManager::OnResourceDirty

// End of file : resource.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\pixel.hpp ===
#ifndef __PIXEL_HPP__
#define __PIXEL_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pixel.hpp
 *  Content:    Utility class for working with pixel formats
 *
 *
 ***************************************************************************/

// includes
#include "d3dobj.hpp"

struct IHVFormatInfo
{
    D3DFORMAT       m_Format;
    DWORD           m_BPP;
    IHVFormatInfo  *m_pNext;
};

// This is a utility class that implements useful helpers for
// allocating and accessing various pixel formats. All methods
// are static and hence should be accessed as follows:
//  e.g. CPixel::LockOffset(...)
//

class CPixel
{
public:
    // Allocate helpers

    // Determine the amount of memory that is needed to
    // allocate various things..
    static UINT ComputeSurfaceSize(UINT            cpWidth,
                                   UINT            cpHeight,
                                   D3DFORMAT       Format);

    static UINT ComputeVolumeSize(UINT             cpWidth,
                                  UINT             cpHeight,
                                  UINT             cpDepth,
                                  D3DFORMAT        Format);


    static UINT ComputeMipMapSize(UINT             cpWidth,
                                  UINT             cpHeight,
                                  UINT             cLevels,
                                  D3DFORMAT        Format);

    static UINT ComputeMipVolumeSize(UINT          cpWidth,
                                     UINT          cpHeight,
                                     UINT          cpDepth,
                                     UINT          cLevels,
                                     D3DFORMAT     Format);

    // Lock helpers

    // Given a surface desc, a level, and pointer to
    // bits (pBits in the LockedRectData) and a sub-rect,
    // this will fill in the pLockedRectData structure
    static void ComputeMipMapOffset(const D3DSURFACE_DESC  *pDescTopLevel,
                                    UINT                    iLevel,
                                    BYTE                   *pBits,
                                    CONST RECT             *pRect,
                                    D3DLOCKED_RECT         *pLockedRectData);

    // MipVolume version of ComputeMipMapOffset
    static void ComputeMipVolumeOffset(const D3DVOLUME_DESC  *pDescTopLevel,
                                       UINT                   iLevel,
                                       BYTE                  *pBits,
                                       CONST D3DBOX          *pBox,
                                       D3DLOCKED_BOX         *pLockedBoxData);

    // Surface version of ComputeMipMapOffset
    static void ComputeSurfaceOffset(const D3DSURFACE_DESC  *pDesc,
                                     BYTE                   *pBits,
                                     CONST RECT             *pRect,
                                     D3DLOCKED_RECT         *pLockedRectData);

    // Is this a supported format?
    static BOOL IsSupported(D3DRESOURCETYPE Type, D3DFORMAT Format);

    // Is this a IHV non-standard format? i.e. do
    // we know the number of bytes per pixel?
    static BOOL IsIHVFormat(D3DFORMAT Format);

    // Is this a Z format that the user can create?
    static BOOL IsEnumeratableZ (D3DFORMAT Format);

    // Is this a Z format that needs mapping b4 sending
    // to the driver?
    static BOOL IsMappedDepthFormat(D3DFORMAT Format);

    // All depth formats other than D16 are currently
    // defined to be non-lockable. This function will
    // return FALSE for:
    //      non-Z formats 
    //      D16_LOCKABLE
    //      IHV formats
    static BOOL IsNonLockableZ(D3DFORMAT Format);

    // Pixel Stride will return negative for DXT formats
    // Call AdjustForDXT to work with things at the block level
    static UINT ComputePixelStride(D3DFORMAT Format);

    // This will adjust cbPixel
    // to pixels per block; and width and height will
    // be adjusted to pixels. Assumes the IsDXT(cbPixel).
    static void AdjustForDXT(UINT *pcpWidth,
                             UINT *pcpHeight,
                             UINT *pcbPixel);

    // Adjust parameters for VolumeDXT
    static void AdjustForVolumeDXT(UINT *pcpWidth,
                                   UINT *pcpHeight,
                                   UINT *pcpDepth,
                                   UINT *pcbPixel);

    // returns TRUE if cbPixel is "negative" i.e. DXT/V group
    static BOOL IsDXT(UINT cbPixel);

    // returns TRUE if format is one of the DXT/V group
    static BOOL IsDXT(D3DFORMAT Format);

    // returns TRUE if format is one of the DXV family
    static BOOL IsVolumeDXT(D3DFORMAT Format);

    // returns TRUE if format has stencil bits
    static BOOL HasStencilBits(D3DFORMAT Format);

    // returns TRUE if format is paletted
    static BOOL IsPaletted(D3DFORMAT Format);

    // Helpers for validation for DXTs.
    static BOOL IsValidRect(D3DFORMAT    Format,
                            UINT         Width,
                            UINT         Height,
                            const RECT  *pRect);

    static BOOL IsValidBox(D3DFORMAT     Format,
                           UINT          Width,
                           UINT          Height,
                           UINT          Depth,
                           const D3DBOX *pBox);

    // Needs 4x4 Rules (DXT/DXVs)
    static BOOL Requires4X4(D3DFORMAT Format);

    // Detection for "real" FourCC formats
    static BOOL IsFourCC(D3DFORMAT Format);

    static D3DFORMAT SuppressAlphaChannel(D3DFORMAT Format);

    static UINT BytesPerPixel(D3DFORMAT Format);

    // Register format for later lookup
    static HRESULT Register(D3DFORMAT Format, DWORD BPP);

    // Cleanup registry
    static void Cleanup();

private:
    // Internal functions

    static UINT ComputeSurfaceStride(UINT cpWidth, UINT cbPixel);

    static UINT ComputeSurfaceSize(UINT            cpWidth,
                                   UINT            cpHeight,
                                   UINT            cbPixel);

    static IHVFormatInfo *m_pFormatList;


}; // CPixel



#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsIHVFormat"

inline BOOL CPixel::IsIHVFormat(D3DFORMAT Format)
{
    // If we know the number of bytes per
    // pixel; it's a non-IHV format
    if (BytesPerPixel(Format) != 0)
        return FALSE;

    // Must be an IHV format
    return TRUE;

} // IsIHVFormat


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeSurfaceOffset"

inline void CPixel::ComputeSurfaceOffset(const D3DSURFACE_DESC  *pDesc,
                                         BYTE                   *pBits,
                                         CONST RECT             *pRect,
                                         D3DLOCKED_RECT         *pLockedRectData)
{
    ComputeMipMapOffset(pDesc, 0, pBits, pRect, pLockedRectData);
} // ComputeSurfaceOffset


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeSurfaceSize"

inline UINT CPixel::ComputeSurfaceSize(UINT            cpWidth,
                                       UINT            cpHeight,
                                       D3DFORMAT       Format)
{
    UINT cbPixel = ComputePixelStride(Format);

    // Adjust pixel->block if necessary
    BOOL isDXT = IsDXT(cbPixel);
    if (isDXT)
    {
        AdjustForDXT(&cpWidth, &cpHeight, &cbPixel);
    }

    return ComputeSurfaceSize(cpWidth,
                              cpHeight,
                              cbPixel);
} // ComputeSurfaceSize

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::AdjustForDXT"
inline void CPixel::AdjustForDXT(UINT *pcpWidth,
                                 UINT *pcpHeight,
                                 UINT *pcbPixel)
{
    DXGASSERT(pcbPixel);
    DXGASSERT(pcpWidth);
    DXGASSERT(pcpHeight);
    DXGASSERT(IsDXT(*pcbPixel));

    // Adjust width and height for DXT formats to be in blocks
    // instead of pixels. Blocks are 4x4 pixels.
    *pcpWidth  = (*pcpWidth  + 3) / 4;
    *pcpHeight = (*pcpHeight + 3) / 4;

    // Negate the pcbPixel to determine bytes per block
    *pcbPixel *= -1;

    // We only know of two DXT formats right now...
    DXGASSERT(*pcbPixel == 8 || *pcbPixel == 16);

} // CPixel::AdjustForDXT

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::AdjustForVolumeDXT"
inline void CPixel::AdjustForVolumeDXT(UINT *pcpWidth,
                                       UINT *pcpHeight,
                                       UINT *pcpDepth,
                                       UINT *pcbPixel)
{
    DXGASSERT(pcbPixel);
    DXGASSERT(pcpWidth);
    DXGASSERT(pcpHeight);
    DXGASSERT(IsDXT(*pcbPixel));

    // Adjust width, height, depth for DXT formats to be in blocks
    // instead of pixels. Blocks are 4x4x4 pixels.
    *pcpWidth  = (*pcpWidth  + 3) / 4;
    *pcpHeight = (*pcpHeight + 3) / 4;
    *pcpDepth  = (*pcpDepth  + 3) / 4;

    // Negate the pcbPixel to determine bytes per block
    *pcbPixel *= -1;

    // We only know of two DXV formats right now...
    DXGASSERT(*pcbPixel == 32 || *pcbPixel == 64);
} // CPixel::AdjustForVolumeDXT


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeVolumeSize"

inline UINT CPixel::ComputeVolumeSize(UINT             cpWidth,
                                      UINT             cpHeight,
                                      UINT             cpDepth,
                                      D3DFORMAT        Format)
{
    UINT cbPixel = ComputePixelStride(Format);

    if (IsDXT(cbPixel))
    {
        if (IsVolumeDXT(Format))
        {
            AdjustForVolumeDXT(&cpWidth, &cpHeight, &cpDepth, &cbPixel);
        }
        else
        {
            AdjustForDXT(&cpWidth, &cpHeight, &cbPixel);
        }
    }

    return cpDepth * ComputeSurfaceSize(cpWidth, cpHeight, cbPixel);
} // ComputeVolumeSize

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsSupported"
inline BOOL CPixel::IsSupported(D3DRESOURCETYPE Type, D3DFORMAT Format)
{
    UINT cbPixel = ComputePixelStride(Format);

    if (cbPixel == 0)
    {
        return FALSE;
    }
    else if (IsVolumeDXT(Format))
    {
        if (Type == D3DRTYPE_VOLUMETEXTURE)
            return TRUE;
        else
            return FALSE;
    }
    else
    {
        return TRUE;
    }
} // IsSupported

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsDXT(cbPixel)"

// returns TRUE if cbPixel is "negative"
inline BOOL CPixel::IsDXT(UINT cbPixel)
{
    if (((INT)cbPixel) < 0)
        return TRUE;
    else
        return FALSE;
} // IsDXT

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsDXT(format)"

// returns TRUE if this is a linear format
// i.e. DXT or DXV
inline BOOL CPixel::IsDXT(D3DFORMAT Format)
{
    // CONSIDER: This is a duplication of Requires4x4 function
    switch (Format)
    {
        // normal DXTs
    case D3DFMT_DXT1:
    case D3DFMT_DXT2:
    case D3DFMT_DXT3:
    case D3DFMT_DXT4:
    case D3DFMT_DXT5:

#ifdef VOLUME_DXT
        // Volume dxts
    case D3DFMT_DXV1:
    case D3DFMT_DXV2:
    case D3DFMT_DXV3:
    case D3DFMT_DXV4:
    case D3DFMT_DXV5:
#endif //VOLUME_DXT

        return TRUE;
    }

    return FALSE;
} // IsDXT

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::Requires4X4"

// returns TRUE for formats that have 4x4 rules
inline BOOL CPixel::Requires4X4(D3DFORMAT Format)
{

    switch (Format)
    {
        // normal DXTs
    case D3DFMT_DXT1:
    case D3DFMT_DXT2:
    case D3DFMT_DXT3:
    case D3DFMT_DXT4:
    case D3DFMT_DXT5:

#ifdef VOLUME_DXT
        // Volume dxts
    case D3DFMT_DXV1:
    case D3DFMT_DXV2:
    case D3DFMT_DXV3:
    case D3DFMT_DXV4:
    case D3DFMT_DXV5:
#endif //VOLUME_DXT

        return TRUE;
    }

    return FALSE;
} // Requires4X4


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::HasStencilBits"

// returns TRUE if format has stencil bits
inline BOOL CPixel::HasStencilBits(D3DFORMAT Format)
{
    switch (Format)
    {
    case D3DFMT_S1D15:
    case D3DFMT_D15S1:
    case D3DFMT_S8D24:
    case D3DFMT_D24S8:
    case D3DFMT_X4S4D24:
    case D3DFMT_D24X4S4:
        return TRUE;
    }

    return FALSE;
} // HasStencilBits

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsVolumeDXT"

// returns TRUE if format is one of the DXTV family
inline BOOL CPixel::IsVolumeDXT(D3DFORMAT Format)
{
#ifdef VOLUME_DXT
    if (Format >= D3DFMT_DXV1 && Format <= D3DFMT_DXV5)
        return TRUE;
    else
#endif //VOLUME_DXT
        return FALSE;
} // IsVolumeDXT

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsPaletted"

// returns TRUE if Format is paletted
inline BOOL CPixel::IsPaletted(D3DFORMAT Format)
{
    return (Format == D3DFMT_P8) || (Format == D3DFMT_A8P8);
} // IsPaletted

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsFourCC"

// returns TRUE if Format is a FourCC
inline BOOL CPixel::IsFourCC(D3DFORMAT Format)
{
    DWORD dwFormat = (DWORD)Format;
    if (HIBYTE(LOWORD(dwFormat)) != 0)
    {
        // FourCC formats are non-zero for in their
        // third byte.
        return TRUE;
    }
    else
    {
        return FALSE;
    }
} // IsFourCC


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsEnumeratableZ"

// IsEnumeratableZ
//
// We only want to enumerate D16 and the Z formats.  We have to know
// about the others so we have to keep them in our list, but we added this
// function so we'd never enumerate them to the app.

inline BOOL CPixel::IsEnumeratableZ (D3DFORMAT Format)
{
    if ((Format == D3DFMT_D16)          ||
        (Format == D3DFMT_D16_LOCKABLE) ||
        (Format == D3DFMT_D15S1)        ||
        (Format == D3DFMT_D24X8)        ||
        (Format == D3DFMT_D24X4S4)      ||
        (Format == D3DFMT_D24S8)        ||
        (Format == D3DFMT_D32))
    {
        return TRUE;
    }

    // IHV formats are creatable; so we let them pass
    if (IsIHVFormat(Format))
    {
        return TRUE;
    }

    return FALSE;
} // IsEnumeratableZ

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsMappedDepthFormat"

// Is this a Z format that needs mapping b4 sending
// to the driver?
inline BOOL CPixel::IsMappedDepthFormat(D3DFORMAT Format)
{
    // D16_LOCKABLE and D32 do not need
    // mapping
    if ((Format == D3DFMT_D16)      ||
        (Format == D3DFMT_D15S1)    ||
        (Format == D3DFMT_D24X4S4)  ||
        (Format == D3DFMT_D24X8)    ||
        (Format == D3DFMT_D24S8))
    {
        return TRUE;
    }
    return FALSE;
} // IsMappedDepthFormat


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsNonLockableZ"

// All depth formats other than D16 are currently
// defined to be non-lockable. This function will
// return FALSE for:
//      non-Z formats 
//      D16_LOCKABLE
//      IHV formats

inline BOOL CPixel::IsNonLockableZ(D3DFORMAT Format)
{
    if ((Format == D3DFMT_D16)      ||
        (Format == D3DFMT_D15S1)    ||
        (Format == D3DFMT_D24X8)    ||
        (Format == D3DFMT_D24S8)    ||
        (Format == D3DFMT_D24X4S4)  ||
        (Format == D3DFMT_D32))
    {
        return TRUE;
    }

    // D16_LOCKABLE is lockable; and other
    // formats are either lockable i.e. IHV or
    // are not a Z format.

    return FALSE;
} // IsNonLockableZ

#endif // __PIXEL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\resource.hpp ===
#ifndef __RESOURCE_HPP__
#define __RESOURCE_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       resource.hpp
 *  Content:    Base class header for resources. A resource is an non-trivial
 *              object that is directly used by the graphics pipeline. It 
 *              be composed of a set of buffers; for example a mip-map is 
 *              a resource that is composed of Surfaces (which are buffers).
 *
 *              Since resources are non-trivial (i.e. more than few bytes), 
 *              they may need management. The resource cooperates with the
 *              Resource Manager component to get management functionality.
 *
 ***************************************************************************/

#include "d3dobj.hpp"

// Forward Decl
struct CMgmtInfo;
class CResourceManager;

// Handle for Resource Manager; internally implemented as a pointer
typedef CMgmtInfo *RMHANDLE;

// A Resource is a Base Object that additionally
// has a Priority field
class CResource : public CBaseObject
{
public:

    static HRESULT RestoreDriverManagementState(CBaseDevice *pDevice);

    // These methods are for the
    // use of the Resource Manager
    RMHANDLE RMHandle() const
    {
        return m_RMHandle;
    }; // RMHandle

    // Determine if a resource is managed or driver-managed
    BOOL IsD3DManaged() const
    {
        // Zero is not a valid RM handle 
        return (m_RMHandle != 0);
    }; // IsD3DManaged

    // Set the device batch number that
    // this resource was last used in. In this
    // context; the batch refers to whether
    // this resource was used in the current
    // command buffer (i.e. containing unflushed commands).
    void Batch();

    // Same as Batch() except it batches the
    // backing (or sysmem) texture rather than the 
    // promoted (or vidmem) one.
    void BatchBase();

    // Notifies the device that this resource
    // is about to be modified in a way that
    // may require a flush. (i.e. Whenever the bits
    // could change or a surface is going away.)
    void Sync();

    // Sets batch number
    void SetBatchNumber(ULONGLONG batch)
    {
        // Batch numbers should only be increasing since we
        // start at zero.
        DXGASSERT(batch >= m_qwBatchCount);

        m_qwBatchCount = batch;
    } // SetBatchNumber

    // returns the batch number that this resource
    // was last referred in
    ULONGLONG GetBatchNumber() const
    {
        return m_qwBatchCount;
    }

    // returns the DrawPrim handle associated with
    // the Driver-Accessible clone if it is Managed; 
    // otherwise returns the handle of itself.
    DWORD DriverAccessibleDrawPrimHandle() const;

    // returns the Kernel handle associated with
    // the Driver-Accessible clone if it is Managed; 
    // otherwise returns the handle of itself.
    HANDLE DriverAccessibleKernelHandle() const;

    // Specifies a creation of a resource that
    // looks just like the current one. The LOD parameter
    // may not be relevant for all Resource types.
    virtual HRESULT Clone(D3DPOOL    Pool,
                          CResource **ppResource) const PURE;

    // Provides a method to access basic structure of the
    // pieces of the resource. 
    virtual const D3DBUFFER_DESC* GetBufferDesc() const PURE;

    // Tells the resource that it should copy itself
    // to the target. It is the caller's responsibility
    // to make sure that Target is compatible with the
    // Source. (The Target may have different number of mip-levels
    // and be in a different pool; however, it must have the same size, 
    // faces, format, etc.)
    //
    // This function will clear the dirty state.
    virtual HRESULT UpdateDirtyPortion(CResource *pResourceTarget) PURE;

    // Allows the Resource Manager to mark the texture
    // as needing to be completely updated on next
    // call to UpdateDirtyPortion
    virtual void MarkAllDirty() PURE;
        
    // Indicates whether the Resource has been modified since
    // the last time that UpdateDirtyPortion has been called.
    // All managed resources start out in the Dirty state.
    BOOL IsDirty() const
    {
        return m_bIsDirty;
    } // IsDirty

    void PreLoadImpl();

    // Returns the pool which the user passed in
    D3DPOOL GetUserPool() const
    {
        return m_poolUser;
    } // GetUserPool
    
protected:
    // The following are methods that only make sense
    // to be called by derived classes

    // Helper to check if a type is managed
    static BOOL IsTypeD3DManaged(CBaseDevice        *pDevice, 
                                 D3DRESOURCETYPE     Type, 
                                 D3DPOOL             Pool);

    static BOOL IsTypeDriverManaged(CBaseDevice        *pDevice, 
                                    D3DRESOURCETYPE     Type, 
                                    D3DPOOL             Pool);

    // Helper to determine what the 'real' pool is
    // for a managed resource.
    static D3DPOOL DetermineCreationPool(CBaseDevice        *pDevice, 
                                          D3DRESOURCETYPE    Type, 
                                          DWORD              dwUsage,
                                          D3DPOOL            Pool);

    // Constructor for Resources; all resources start out dirty
    CResource(CBaseDevice *pDevice, D3DPOOL Pool, REF_TYPE refType = REF_EXTERNAL) : 
        CBaseObject(pDevice, refType),
        m_RMHandle(0),
        m_qwBatchCount(0),
        m_Priority(0),
        m_bIsDirty(TRUE),
        m_poolUser(Pool),
        m_pPrev(0)
    {
        m_pNext = pDevice->GetResourceList();
        pDevice->SetResourceList(this);
        if (m_pNext != 0)
        {
            m_pNext->m_pPrev = this;
        }
    }; // CResource

    virtual ~CResource();

    // Priority Inlines
    DWORD SetPriorityImpl(DWORD newPri);

    DWORD GetPriorityImpl();

    // Allows initialization of the RMHandle after
    // construction is basically complete
    HRESULT InitializeRMHandle();

    // Allows RMHandle to be set to zero
    void DeleteRMHandle();

    // Helper to notify the RM that
    // we are now dirty. 
    void OnResourceDirty();

    // Helper to notify resource when it
    // is all clean
    void OnResourceClean();

    // Resources need to implement OnDestroy by 
    // calling Sync; (Textures overload this
    // to call OnTextureDestroy on the device before
    // calling their base class.)
    virtual void OnDestroy(void)
    {
        Sync();
        return;
    } // OnDestroy

    // Returns the current priority 
    DWORD GetPriorityI() const
    {
        return m_Priority;
    }

    // Sets the current priority (but does not do any work)
    DWORD SetPriorityI(DWORD Priority)
    {
        DWORD oldPriority = m_Priority;
        m_Priority = Priority;
        return oldPriority;
    }

private:

    RMHANDLE    m_RMHandle;
    ULONGLONG   m_qwBatchCount;
    DWORD       m_Priority;
    BOOL        m_bIsDirty;

    // Remember the pool that the user passed in
    D3DPOOL     m_poolUser;

    // Linked list of resources
    CResource  *m_pPrev;
    CResource  *m_pNext;

    friend CResourceManager;
}; // CResource

struct CMgmtInfo
{
    // This is static because we assume all resources
    // to be in heap zero. WHEN the resource manager
    // supports multiple heaps, m_rmHeap should be
    // made per object again.
    static DWORD m_rmHeap;

    DWORD      m_priority;
    DWORD      m_LOD;
    BOOL       m_bInUse;
   
    DWORD      m_rmHeapIndex;
    DWORD      m_scene;
    DWORD      m_ticks;
    CResource *m_pRes;
    CResource *m_pBackup;

    CMgmtInfo(CResource*);
    ~CMgmtInfo();

    ULONGLONG Cost() const
    {
#ifdef _X86_
        ULONGLONG retval;
        _asm
        {
            mov     ebx, this;
            mov     edx, [ebx]CMgmtInfo.m_bInUse;
            shl     edx, 31;
            mov     eax, [ebx]CMgmtInfo.m_priority;
            mov     ecx, eax;
            shr     eax, 1;
            or      edx, eax;
            mov     DWORD PTR retval + 4, edx;
            shl     ecx, 31;
            mov     eax, [ebx]CMgmtInfo.m_ticks;
            shr     eax, 1;
            or      eax, ecx;
            mov     DWORD PTR retval, eax;
        }
        return retval;
#else
        return ((ULONGLONG)m_bInUse << 63) + ((ULONGLONG)m_priority << 31) + ((ULONGLONG)(m_ticks >> 1));
#endif
    }
}; // CMgmtInfo 

inline CMgmtInfo::CMgmtInfo(CResource *pBackup)
{
    m_priority = 0;
    m_LOD = 0;
    m_bInUse = FALSE;
    m_rmHeap = 0;
    m_rmHeapIndex = 0;
    m_scene = 0;
    m_ticks = 0;
    m_pRes = 0;
    m_pBackup = pBackup;
} // CMgmtInfo::CMgmtInfo

inline CMgmtInfo::~CMgmtInfo()
{
    if (m_pRes != 0)
    {
        m_pRes->DecrementUseCount();
    }
} // CMgmtInfo::~CMgmtInfo

class CRMHeap 
{

private:

    enum { InitialSize = 1023 };

    DWORD m_next, m_size;
    CMgmtInfo **m_data_p;

    DWORD parent(DWORD k) const { return k / 2; }
    DWORD lchild(DWORD k) const { return k * 2; }
    DWORD rchild(DWORD k) const { return k * 2 + 1; }
    void heapify(DWORD k);

public:

    CRMHeap(DWORD size = InitialSize);
    ~CRMHeap();
    BOOL Initialize();

    DWORD length() const { return m_next - 1; }
    CMgmtInfo* minCost() const { return m_data_p[1]; }

    BOOL add(CMgmtInfo*);
    CMgmtInfo* extractMin();
    CMgmtInfo* extractMax();
    CMgmtInfo* extractNotInScene(DWORD dwScene);
    void del(CMgmtInfo*);
    void update(CMgmtInfo*, BOOL inuse, DWORD priority, DWORD ticks); 
    void resetAllTimeStamps(DWORD ticks);
}; // class CRMHeap

inline CRMHeap::CRMHeap(DWORD size)
{
    m_next = 1;
    m_size = size + 1;
} // CRMHeap::CRMHeap

inline CRMHeap::~CRMHeap()
{
    delete[] m_data_p;
} // CRMHeap::~CRMHeap

class CResourceManager
{
    
public:

    CResourceManager();
    ~CResourceManager();

    // Need to call before using the manager
    HRESULT Init(CBaseDevice *pD3D8);

    // Check to see if a type is going to driver managed
    // or going to be D3D managed
    BOOL IsDriverManaged(D3DRESOURCETYPE Type) const;
    
    // Specify that a resource needs to be managed
    //
    // Error indicates that we don't support management for this
    // resource type.
    HRESULT Manage(CResource *pResource, RMHANDLE *pHandle);
    
    // Stop managing a resouce; called when a managed resource
    // is going away
    void UnManage(RMHANDLE hRMHandle);
    
    // The RM manages Priority and LOD for the resource    
    DWORD SetPriority(RMHANDLE hRMHandle, DWORD newPriority);
    DWORD SetLOD(RMHANDLE hRMHandle, DWORD dwLodNew);

    // Preloads resource into video memory
    void PreLoad(RMHANDLE hRMHandle);

    // Checks if the resource is in video memory
    BOOL InVidmem(RMHANDLE hRMHandle) const;

    // This is called when DrawPrimitive needs to 
    // make sure that all resources used in the
    // current call are in video memory and are
    // uptodate.
    HRESULT UpdateVideo(RMHANDLE hRMHandle, BOOL *bDirty);
    HRESULT UpdateVideoInternal(CMgmtInfo *pMgmtInfo);

    // This returns the appropriate handle for a
    // managed resource
    DWORD DrawPrimHandle(RMHANDLE hRMHandle) const;

    // This returns the appropriate kernel handle for a
    // managed resource
    HANDLE KernelHandle(RMHANDLE hRMHandle) const;

    // This call will batch the appropriate resource
    // for the purpose of syncing
    void Batch(RMHANDLE hRMHandle, ULONGLONG batch) const;

    // Called from outside when a managed resource becomes dirty
    void OnResourceDirty(RMHANDLE hRMHandle) const;

    void DiscardBytes(DWORD cbBytes);

    void SceneStamp() { ++m_dwScene; }

private:

    CBaseDevice *m_pD3D8;
    unsigned tcm_ticks, m_dwScene, m_dwNumHeaps;
    BOOL m_PreLoading;
    CRMHeap *m_heap_p;

    BOOL FreeResources(DWORD dwHeap, DWORD dwBytes);

    void Lock(RMHANDLE hRMHandle);
    void Unlock(RMHANDLE hRMHandle);

    void TimeStamp(CMgmtInfo *pMgmtInfo);
    
}; // class CResourceManager

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::IsTypeD3DManaged"

inline BOOL CResource::IsTypeD3DManaged(CBaseDevice        *pDevice, 
                                        D3DRESOURCETYPE     Type, 
                                        D3DPOOL             Pool)
{
    if (Pool == D3DPOOL_MANAGED)
    {
        return !IsTypeDriverManaged(pDevice, Type, Pool);
    }
    else
    {
        return FALSE;
    }
}; // IsTypeD3DManaged

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::IsTypeDriverManaged"

inline BOOL CResource::IsTypeDriverManaged(CBaseDevice     *pDevice, 
                                           D3DRESOURCETYPE  Type, 
                                           D3DPOOL          Pool)
{
    if (Pool == D3DPOOL_MANAGED)
    {
        if (pDevice->ResourceManager()->IsDriverManaged(Type))
        {
            return TRUE;
        }
    }
    return FALSE;
}; // IsTypeDriverManaged

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::DetermineCreationPool"

inline D3DPOOL CResource::DetermineCreationPool(CBaseDevice    *pDevice, 
                                                D3DRESOURCETYPE Type, 
                                                DWORD           dwUsage,
                                                D3DPOOL         Pool)
{
    if (Pool == D3DPOOL_MANAGED)
    {
        if (IsTypeDriverManaged(pDevice, Type, Pool))
        {
            // This pool is used by the thunk layer
            // to use the driver management flag during
            // create
            return D3DPOOL_MANAGED;
        }
        else
        {
            // If it is not driver managed; then it 
            // becomes D3DMANAGED
            return D3DPOOL_SYSTEMMEM;
        }
    }
    else
    {
        // Not managed at all; so we just
        // use the same pool we started with
        return Pool;
    }
} // DetermineCreationPool


#undef DPF_MODNAME
#define DPF_MODNAME "CResource::~CResource"

inline CResource::~CResource()
{
    // If managed, we need to notify
    // the ResourceManager that we are going away
    if (IsD3DManaged())
    {
        Device()->ResourceManager()->UnManage(m_RMHandle);
    }
    // Unlink from the resource list
    if (m_pNext != 0)
    {
        m_pNext->m_pPrev = m_pPrev;
    }    
    if (m_pPrev != 0)
    {
        m_pPrev->m_pNext = m_pNext;
        DXGASSERT(Device()->GetResourceList() != this);
    }
    else
    {
        DXGASSERT(Device()->GetResourceList() == this);
        Device()->SetResourceList(m_pNext);
    }
}; // ~CResource

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::InitializeRMHandle"

// Allows initialization of the RMHandle after
// construction is basically complete
inline HRESULT CResource::InitializeRMHandle()
{
    // We should not already have a handle
    DXGASSERT(m_RMHandle == 0);
    
    // Get a handle from the resource manager
    return Device()->ResourceManager()->Manage(this, &m_RMHandle);
}; // InitializeRMHandle

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::DeleteRMHandle"

inline void CResource::DeleteRMHandle()
{
    // We should already have a handle
    DXGASSERT(m_RMHandle != 0);

    Device()->ResourceManager()->UnManage(m_RMHandle);
    m_RMHandle = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::OnResourceDirty"

// Add a helper to notify the RM that
// we are now dirty. 
inline void CResource::OnResourceDirty()
{
    // Update our state
    m_bIsDirty = TRUE;

    // Only need to notify RM for managed textures
    // that have been been set through SetTexture
    if (IsD3DManaged() && IsInUse())
    {
        Device()->ResourceManager()->OnResourceDirty(m_RMHandle);
    } 

    return;
}; // OnResourceDirty

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::OnResourceClean"

// Add a helper to help maintain m_bIsDirty bit
inline void CResource::OnResourceClean()
{
    DXGASSERT(m_bIsDirty == TRUE);
    m_bIsDirty = FALSE;
    return;
}; // OnResourceDirty


#undef DPF_MODNAME
#define DPF_MODNAME "CResource::DriverAccessibleDrawPrimHandle"

inline DWORD CResource::DriverAccessibleDrawPrimHandle() const
{
    if (IsD3DManaged())
    {
        // Return the DrawPrim handle of my clone
        return Device()->ResourceManager()->DrawPrimHandle(RMHandle());
    }
    else
    {
        return BaseDrawPrimHandle();
    }
} // CResource::DriverAccessibleDrawPrimHandle

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::DriverAccessibleKernelHandle"

inline HANDLE CResource::DriverAccessibleKernelHandle() const
{
    if (IsD3DManaged())
    {
        // Return the DrawPrim handle of my clone
        HANDLE h = Device()->ResourceManager()->KernelHandle(RMHandle());
        
        // If this handle is NULL, then it means it was called
        // without calling UpdateVideo which isn't allowed/sane
        DXGASSERT(h != NULL);
        
        return h;
    }
    else
    {
        return BaseKernelHandle();
    }
} // CResource::DriverAccessibleKernelHandle


#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::CResourceManager"

inline CResourceManager::CResourceManager()
{
    m_pD3D8 = 0;
    tcm_ticks = m_dwScene = m_dwNumHeaps = 0;
    m_heap_p = 0;
    m_PreLoading = FALSE;
} // CResourceManager::CResourceManager

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::~CResourceManager"

inline CResourceManager::~CResourceManager()
{
    // We should not call DiscardBytes here
    // because this destructor can be called via
    // the device destructor chain. In this situation
    // DiscardBytes will access bad or already freed
    // data.
    delete[] m_heap_p;
} // CResourceManager::~CResourceManager

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::DrawPrimHandle"

inline DWORD CResourceManager::DrawPrimHandle(RMHANDLE hRMHandle) const
{
    if (InVidmem(hRMHandle))
    {
        CMgmtInfo* &pMgmtInfo = hRMHandle;
        return pMgmtInfo->m_pRes->BaseDrawPrimHandle();
    }
    else
    {
        return 0;
    }
} // CResourceManager::DrawPrimHandle

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::KernelHandle"

inline HANDLE CResourceManager::KernelHandle(RMHANDLE hRMHandle) const
{
    if (InVidmem(hRMHandle))
    {
        CMgmtInfo* &pMgmtInfo = hRMHandle;
        return pMgmtInfo->m_pRes->BaseKernelHandle();
    }
    else
    {
        return 0;
    }
} // CResourceManager::Kernelhandle

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::InVidmem"

inline BOOL CResourceManager::InVidmem(RMHANDLE hRMHandle) const
{
    CMgmtInfo* &pMgmtInfo = hRMHandle;
    DXGASSERT(pMgmtInfo != 0);
    return pMgmtInfo->m_pRes != 0;
} // CResourceManager::InVidmem

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::Batch"

inline void CResourceManager::Batch(RMHANDLE hRMHandle, ULONGLONG batch) const
{
    if (InVidmem(hRMHandle))
    {
        CMgmtInfo* &pMgmtInfo = hRMHandle;
        pMgmtInfo->m_pRes->SetBatchNumber(batch);
    }
} // CResourceManager::Batch

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::UpdateVideo"

inline HRESULT CResourceManager::UpdateVideo(RMHANDLE hRMHandle, BOOL *bDirty)
{
    HRESULT ddrval = S_OK;
    CMgmtInfo* &pMgmtInfo = hRMHandle;
    if (!InVidmem(hRMHandle))
    {
        ddrval = UpdateVideoInternal(pMgmtInfo);
        *bDirty = TRUE;
    }
    else
    {
        if (pMgmtInfo->m_pBackup->IsDirty())
        {
            ddrval = pMgmtInfo->m_pBackup->UpdateDirtyPortion(pMgmtInfo->m_pRes);
        }
        TimeStamp(pMgmtInfo);
    }
    return ddrval;
}

#endif // __RESOURCE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\sources.inc ===
TARGETPATH=obj
TARGETNAME = d3dfw

TARGETTYPE = LIBRARY

INCLUDES = \
    ..\;         \
    $(DDK_INC_PATH);\
    $(INCLUDES);

USE_ATL=1
!UNDEF USE_NATIVE_EH

C_DEFINES = $(C_DEFINES) /DNEW_DPF

SOURCES = \
    ..\d3dmem.cpp    \
    ..\pixel.cpp     \
    ..\d3dobj.cpp    \
    ..\resource.cpp  \
    ..\texture.cpp   \
    ..\mipmap.cpp    \
    ..\mipsurf.cpp   \
    ..\mipvol.cpp    \
    ..\volume.cpp    \
    ..\cubemap.cpp   \
    ..\cubesurf.cpp  \
    ..\surface.cpp   \
    ..\buffer.cpp    \
    ..\vbuffer.cpp   \
    ..\ibuffer.cpp   \
    ..\enum.cpp      \
    ..\dxgcreat.cpp  \
    ..\swapchan.cpp  \
    ..\dxcursor.cpp  \
    ..\dwinproc.cpp  \
    ..\_dpf.c        \
    ..\_memallo.c    \
    ..\ddcreate.cpp  \
    ..\dllmain.c     \
    ..\drvinfo.c     \
    ..\fcache.cpp    \
    ..\init.cpp

PRECOMPILED_INCLUDE = ..\ddrawpr.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\surface.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       surface.cpp
 *  Content:    Implementation of the CSurface class.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"

#include "surface.hpp"
#include "pixel.hpp"
#include "swapchan.hpp"

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::Create"

// Static class function for creating a RenderTarget/ZStencil object.
// (Because it is static; it doesn't have a this pointer.)

HRESULT CSurface::Create(CBaseDevice        *pDevice, 
                         DWORD               Width,
                         DWORD               Height,
                         DWORD               Usage,
                         D3DFORMAT           UserFormat,
                         D3DMULTISAMPLE_TYPE MultiSampleType,
                         REF_TYPE            refType,
                         IDirect3DSurface8 **ppSurface)
{
    HRESULT     hr;

    // Do parameter checking here
    if (!VALID_PTR_PTR(ppSurface))
    {
        DPF_ERR("Bad parameter passed for ppSurface for creating a surface. CreateRenderTarget/CreateDepthStencil failed");
        return D3DERR_INVALIDCALL;
    }

    // Zero-out return parameter
    *ppSurface = NULL;

    // Size may need to be 4x4
    if (CPixel::Requires4X4(UserFormat))
    {
        if ((Width & 3) ||
            (Height & 3))
        {
            DPF_ERR("DXT Formats require width/height to be a multiple of 4. CreateRenderTarget/CreateDepthStencil failed.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Validate against zero width/height
    if (Width   == 0 ||
        Height  == 0)
    {
        DPF_ERR("Width/Height must be non-zero. CreateRenderTarget/CreateDepthStencil failed"); 
        return D3DERR_INVALIDCALL;
    }

    // Now verify that the device can support the specified format
    hr = pDevice->CheckDeviceFormat(
            Usage & (D3DUSAGE_RENDERTARGET  |
                     D3DUSAGE_DEPTHSTENCIL),
            D3DRTYPE_SURFACE,
            UserFormat);    
    if (FAILED(hr))
    {
        DPF_ERR("The format is not supported by this device. CreateRenderTarget/CreateDepthStencil failed");
        return D3DERR_INVALIDCALL;
    }

    // Infer lockability for DepthStencil from format
    if (Usage & D3DUSAGE_DEPTHSTENCIL)
    {
        if (!CPixel::IsNonLockableZ(UserFormat))
        {
            Usage |= D3DUSAGE_LOCK;
        }
    }

    // Validate lockability
    if ((MultiSampleType != D3DMULTISAMPLE_NONE) &&
        (Usage & D3DUSAGE_LOCK))
    {
        // RT have explicit lockability
        if (Usage & D3DUSAGE_RENDERTARGET)
        {
            DPF_ERR("Multi-Sampled render-targets are not lockable. CreateRenderTarget failed");
            return D3DERR_INVALIDCALL;
        }
        else
        {
            DPF_ERR("Multi-Sampled Depth Stencil buffers are not lockable. "
                    "Use D3DFMT_D16 instead of D3DFMT_D16_LOCKABLE. CreateDepthStencil failed");
            return D3DERR_INVALIDCALL;
        }
    }
  

    // Map depth/stencil format
    D3DFORMAT RealFormat = pDevice->MapDepthStencilFormat(UserFormat);
   
    // Create the surface 
    CSurface *pSurface;

    pSurface = new CDriverSurface(pDevice, 
                                  Width, 
                                  Height, 
                                  Usage, 
                                  UserFormat,
                                  RealFormat, 
                                  MultiSampleType,
                                  0,            // hKernelHandle
                                  refType,
                                  &hr);

    if (pSurface == NULL)
    {
        DPF_ERR("Out of Memory creating surface. CreateRenderTarget/CreateDepthStencil failed");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        DPF_ERR("Error during initialization of surface. CreateRenderTarget/CreateDepthStencil failed");
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pSurface->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pSurface->DecrementUseCount();
        }

        return hr;
    }

    // We're done; just return the object
    *ppSurface = pSurface;

    return hr;
} // static Create for ZBuffers and RenderTargets


#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::CreateImageSurface"
// Function for creating sys-mem stand-alone surfaces
// that can be used with CopyRect and SetCursorSurface and
// ReadBuffer
HRESULT CSurface::CreateImageSurface(CBaseDevice        *pDevice, 
                                     DWORD               Width,
                                     DWORD               Height,
                                     D3DFORMAT           Format,
                                     REF_TYPE            refType,
                                     IDirect3DSurface8 **ppSurface)
{
    HRESULT hr;

    // Do parameter checking here
    if (!VALID_PTR_PTR(ppSurface))
    {
        DPF_ERR("Bad parameter passed for ppSurface for creating a surface. CreateImageSurface failed.");
        return D3DERR_INVALIDCALL;
    }

    // Zero-out return parameter
    *ppSurface = NULL;

    // Has to be supported format
    if (!CPixel::IsSupported(D3DRTYPE_SURFACE, Format))
    {
        DPF_ERR("This format is not supported for CreateImageSurface");
        return D3DERR_INVALIDCALL;
    }

    if (CPixel::IsNonLockableZ(Format))
    {
        DPF_ERR("This Z format is not supported for CreateImageSurface");
        return D3DERR_INVALIDCALL;
    }

    // Size may need to be 4x4
    if (CPixel::Requires4X4(Format))
    {
        if ((Width & 3) ||
            (Height & 3))
        {
            DPF_ERR("DXT Formats require width/height to be a multiple of 4. CreateImageSurface failed.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Validate against zero width/height
    if (Width   == 0 ||
        Height  == 0)
    {
        DPF_ERR("Width/Height must be non-zero. CreateImageSurface failed."); 
        return D3DERR_INVALIDCALL;
    }


    // Usage is explictly just Usage_LOCK
    DWORD Usage = D3DUSAGE_LOCK;

    CSurface *pSurface = new CSysMemSurface(pDevice, 
                                            Width, 
                                            Height, 
                                            Usage, 
                                            Format, 
                                            refType,
                                           &hr);
    if (pSurface == NULL)
    {
        DPF_ERR("Out of Memory creating surface. CreateImageSurface failed.");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        DPF_ERR("Error during initialization of surface. CreateImageSurface failed.");
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pSurface->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pSurface->DecrementUseCount();
        }

        return hr;
    }

    // We're done; just return the object
    *ppSurface = pSurface;

    return S_OK;
} // static CreateImageSurface


#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::CSurface"

// Constructor the surface class; this is the 
// base class for render targets/zbuffers/and backbuffers
CSurface::CSurface(CBaseDevice         *pDevice, 
                   DWORD                Width,
                   DWORD                Height,
                   DWORD                Usage,
                   D3DFORMAT            Format,
                   REF_TYPE             refType,
                   HRESULT             *phr
                   ) :
    CBaseObject(pDevice, refType),
    m_qwBatchCount(0)
{
    // Sanity check
    DXGASSERT(phr);

    // Initialize basic structures
    m_desc.Format       = Format;
    m_desc.Pool         = D3DPOOL_DEFAULT;
    m_desc.Usage        = Usage;
    m_desc.Type         = D3DRTYPE_SURFACE;
    m_desc.Width        = Width;
    m_desc.Height       = Height;

    m_formatUser        = Format;
    m_poolUser          = D3DPOOL_DEFAULT;

    // Return success
    *phr = S_OK;

} // CSurface::CSurface


#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::~CSurface"

// Destructor
CSurface::~CSurface()
{
    // The destructor has to handle partially
    // created objects. 

    // Check to make sure that we aren't deleting
    // an object that is referenced in the current (unflushed)
    // command stream buffer.
    DXGASSERT(m_qwBatchCount <= static_cast<CD3DBase*>(Device())->CurrentBatch());
} // CSurface::~CSurface


// IUnknown methods
#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::QueryInterface"

STDMETHODIMP CSurface::QueryInterface(REFIID      riid, 
                                      LPVOID FAR *ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter passed to CSurface::QueryInterface");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to CSurface::QueryInterface");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DSurface8 || riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DSurface8 *>(this));
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to CSurface::QueryInterface");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::AddRef"

STDMETHODIMP_(ULONG) CSurface::AddRef()
{
    API_ENTER_NO_LOCK(Device());   
    
    return AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::Release"

STDMETHODIMP_(ULONG) CSurface::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());   
    
    return ReleaseImpl();
} // Release

// IDirect3DBuffer methods

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::GetDevice"

STDMETHODIMP CSurface::GetDevice(IDirect3DDevice8 ** ppObj)
{
    API_ENTER(Device());
    return GetDeviceImpl(ppObj);
} // GetDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::SetPrivateData"

STDMETHODIMP CSurface::SetPrivateData(REFGUID riid, 
                                      CONST VOID* pvData, 
                                      DWORD cbData, 
                                      DWORD dwFlags)
{
    API_ENTER(Device());

    // We use level zero for our data
    return SetPrivateDataImpl(riid, pvData, cbData, dwFlags, 0);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::GetPrivateData"

STDMETHODIMP CSurface::GetPrivateData(REFGUID riid, 
                                      LPVOID pvData, 
                                      LPDWORD pcbData)
{
    API_ENTER(Device());

    // We use level zero for our data
    return GetPrivateDataImpl(riid, pvData, pcbData, 0);
} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::FreePrivateData"

STDMETHODIMP CSurface::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    // We use level zero for our data
    return FreePrivateDataImpl(riid, 0);
} // FreePrivateData


#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::GetContainer"

STDMETHODIMP CSurface::GetContainer(REFIID riid, 
                                    void **ppContainer)
{
    API_ENTER(Device());

    // Our 'container' is just the device since
    // we are a standalone surface object
    return Device()->QueryInterface( riid, ppContainer);
} // OpenContainer

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::GetDesc"

STDMETHODIMP CSurface::GetDesc(D3DSURFACE_DESC *pDesc)
{
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pDesc, sizeof(*pDesc)))
    {
        DPF_ERR("bad pointer for pDesc passed to CSurface::GetDesc");
        return D3DERR_INVALIDCALL;
    }

    *pDesc                 = m_desc;
    pDesc->Format          = m_formatUser;
    pDesc->Pool            = m_poolUser;
    pDesc->Usage          &= D3DUSAGE_EXTERNAL;

    return S_OK;
} // GetDesc

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::InternalGetDesc"

D3DSURFACE_DESC CSurface::InternalGetDesc() const
{
    return m_desc;
} // InternalGetDesc


#ifdef DEBUG
#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::ReportWhyLockFailed"

// DPF why Lock failed as clearly as possible
void CSurface::ReportWhyLockFailed(void) const
{
    // If there are multiple reasons that lock failed; we report
    // them all to minimize user confusion

    if (InternalGetDesc().MultiSampleType != D3DMULTISAMPLE_NONE)
    {
        DPF_ERR("Lock is not supported for surfaces that have multi-sampling enabled.");
    }

    if (InternalGetDesc().Usage & D3DUSAGE_DEPTHSTENCIL)
    {
        DPF_ERR("Lock is not supported for depth formats other than D3DFMT_D16_LOCKABLE");
    }

    // If this is not a non-lockable Z format, and
    // we are not multisampled; then the user must
    // have explicitly chosen to create us in an non-lockable way
    if (InternalGetDesc().Usage & D3DUSAGE_BACKBUFFER)
    {
        DPF_ERR("Backbuffers are not lockable unless application specifies "
                "D3DPRESENTFLAG_LOCKABLE_BACKBUFFER at CreateDevice and Reset. "
                "Lockable backbuffers incur a performance cost on some "
                "graphics hardware.");
    }
    else if (InternalGetDesc().Usage & D3DUSAGE_RENDERTARGET)
    {
        DPF_ERR("RenderTargets are not lockable unless application specifies "
                "TRUE for the Lockable parameter for CreateRenderTarget. Lockable "
                "render targets incur a performance cost on some graphics hardware.");
    }

    // If we got here; then USAGE_LOCK should not have been set
    DXGASSERT(!(InternalGetDesc().Usage & D3DUSAGE_LOCK));

    return;
} // CSurface::ReportWhyLockFailed
#endif // DEBUG

//=============================================
// Methods for the CSysMemSurface class
//=============================================
#undef DPF_MODNAME
#define DPF_MODNAME "CSysMemSurface::CSysMemSurface"
CSysMemSurface::CSysMemSurface(CBaseDevice         *pDevice, 
                               DWORD                Width,
                               DWORD                Height,
                               DWORD                Usage,
                               D3DFORMAT            Format,
                               REF_TYPE             refType,
                               HRESULT             *phr
                               ) :
    CSurface(pDevice, 
             Width, 
             Height, 
             Usage, 
             Format, 
             refType, 
             phr),
    m_rgbPixels(NULL)
{
    if (FAILED(*phr))
        return;

    // Compute how much memory we need
    m_desc.Size = CPixel::ComputeSurfaceSize(Width, 
                                             Height, 
                                             Format);

    // Specify system memory
    m_desc.Pool = D3DPOOL_SYSTEMMEM;
    m_poolUser  = D3DPOOL_SYSTEMMEM;

    // Specify no multisampling
    m_desc.MultiSampleType  = D3DMULTISAMPLE_NONE;

    // Allocate the memory
    m_rgbPixels = new BYTE[m_desc.Size];
    if (m_rgbPixels == NULL)
    {
        DPF_ERR("Out of memory allocating surface.");
        *phr = E_OUTOFMEMORY;
        return;
    }

    // Figure out our pitch
    D3DLOCKED_RECT lock;
    CPixel::ComputeSurfaceOffset(&m_desc,
                                  m_rgbPixels,
                                  NULL,       // pRect
                                 &lock);


    // Create a DDSURFACE and CreateSurfaceData object
    DDSURFACEINFO SurfInfo;
    ZeroMemory(&SurfInfo, sizeof(SurfInfo));

    // If we are not passed a handle, then we need to get one from
    // the DDI

    D3D8_CREATESURFACEDATA CreateSurfaceData;
    ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

    // Set up the basic information
    CreateSurfaceData.hDD               = pDevice->GetHandle();
    CreateSurfaceData.pSList            = &SurfInfo;
    CreateSurfaceData.dwSCnt            = 1;

    // ImageSurface is an internal type so that the thunk layer
    // knows that it is not really a texture
    CreateSurfaceData.Type              = D3DRTYPE_IMAGESURFACE;
    CreateSurfaceData.Pool              = m_desc.Pool;
    CreateSurfaceData.dwUsage           = m_desc.Usage;
    CreateSurfaceData.MultiSampleType   = D3DMULTISAMPLE_NONE;
    CreateSurfaceData.Format            = Format;

    // Specify the surface data
    SurfInfo.cpWidth  = Width;
    SurfInfo.cpHeight = Height;
    SurfInfo.pbPixels = (BYTE*)lock.pBits;
    SurfInfo.iPitch   = lock.Pitch;

    *phr = pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
    if (FAILED(*phr))
    {
        DPF_ERR("Failed to create sys-mem surface");
        return;
    }

    DXGASSERT(CreateSurfaceData.Pool == D3DPOOL_SYSTEMMEM);
    DXGASSERT(m_desc.Pool == D3DPOOL_SYSTEMMEM);
    DXGASSERT(m_poolUser == D3DPOOL_SYSTEMMEM);

    SetKernelHandle(SurfInfo.hKernelHandle);

    return;
} // CSysMemSurface::CSysMemSurface

#undef DPF_MODNAME
#define DPF_MODNAME "CSysMemSurface::~CSysMemSurface"
CSysMemSurface::~CSysMemSurface() 
{
    if (KernelHandle() != 0)
    {
        D3D8_DESTROYSURFACEDATA DestroyData;

        ZeroMemory(&DestroyData, sizeof DestroyData);
        DestroyData.hDD = Device()->GetHandle();
        DestroyData.hSurface = KernelHandle();
        Device()->GetHalCallbacks()->DestroySurface(&DestroyData);
    }

    // Free the memory we've allocated for the surface
    delete [] m_rgbPixels;

    return;
} // CSysMemSurface::CSysMemSurface


#undef DPF_MODNAME
#define DPF_MODNAME "CSysMemSurface::LockRect"

STDMETHODIMP CSysMemSurface::LockRect(D3DLOCKED_RECT *pLockedRectData, 
                                      CONST RECT           *pRect, 
                                      DWORD           dwFlags)
{   
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedRectData, sizeof(D3DLOCKED_RECT)))
    {
        DPF_ERR("bad pointer for m_pLockedRectData passed to LockRect for an ImageSurface.");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data
    ZeroMemory(pLockedRectData, sizeof(D3DLOCKED_RECT));

    // Validate Rect
    if (pRect != NULL)
    {
        if (!CPixel::IsValidRect(m_desc.Format,
                                 m_desc.Width, 
                                 m_desc.Height, 
                                 pRect))
        {
            DPF_ERR("LockRect for a Surface failed");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_SURF_VALID)
    {
        DPF_ERR("Invalid dwFlags parameter passed to LockRect for an ImageSurface");
        DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_SURF_VALID);
        return D3DERR_INVALIDCALL;
    }

    // Can't lock surfaces that are not lockable
    if (!IsLockable())
    {
        ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }

    return InternalLockRect(pLockedRectData, pRect, dwFlags);
} // LockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CSysMemSurface::InternalLockRect"

HRESULT CSysMemSurface::InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                         CONST RECT     *pRect, 
                                         DWORD           dwFlags)
{   
    // Only one lock outstanding at a time is supported
    // (even internally)
    if (m_isLocked)
    {
        DPF_ERR("LockRect failed on a surface; surface was already locked for an ImageSurface");
        return D3DERR_INVALIDCALL;
    }

    CPixel::ComputeSurfaceOffset(&m_desc,
                                  m_rgbPixels, 
                                  pRect,
                                  pLockedRectData);

    // Mark ourselves as locked
    m_isLocked = TRUE;

    // Done
    return S_OK;
} // InternalLockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CSysMemSurface::UnlockRect"

STDMETHODIMP CSysMemSurface::UnlockRect()
{
    API_ENTER(Device());

    // If we aren't locked; then something is wrong
    if (!m_isLocked)
    {
        DPF_ERR("UnlockRect failed on a mip level; surface wasn't locked for an ImageSurface");
        return D3DERR_INVALIDCALL;
    }

    DXGASSERT(IsLockable());

    return InternalUnlockRect();
} // UnlockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CSysMemSurface::InternalUnlockRect"

HRESULT CSysMemSurface::InternalUnlockRect()
{
    DXGASSERT(m_isLocked);

    // Clear our locked state
    m_isLocked = FALSE;

    // Done
    return S_OK;
} // InternalUnlockRect


//=============================================
// Methods for the CDriverSurface class
//=============================================
#undef DPF_MODNAME
#define DPF_MODNAME "CDriverSurface::CDriverSurface"
CDriverSurface::CDriverSurface(CBaseDevice          *pDevice, 
                               DWORD                 Width,
                               DWORD                 Height,
                               DWORD                 Usage,
                               D3DFORMAT             UserFormat,
                               D3DFORMAT             RealFormat,
                               D3DMULTISAMPLE_TYPE   MultiSampleType,
                               HANDLE                hKernelHandle,
                               REF_TYPE              refType,
                               HRESULT              *phr
                               ) :
    CSurface(pDevice, 
             Width, 
             Height, 
             Usage, 
             RealFormat, 
             refType, 
             phr)
{
    // Even in failure paths, we need to remember
    // the passed in kernel handle so we can uniformly
    // free it
    if (hKernelHandle)
        SetKernelHandle(hKernelHandle);
    
    // On failure; just return here
    if (FAILED(*phr))
    {
        return;
    }

    // Remember User Format
    m_formatUser = UserFormat;

    // Remember multi-sample type
    m_desc.MultiSampleType  = MultiSampleType;

    // Parameter check MS types; (since swapchan bypasses
    // the static Create; we need to parameter check here.)

    if (MultiSampleType != D3DMULTISAMPLE_NONE)
    {
        *phr = pDevice->CheckDeviceMultiSampleType(RealFormat,
                                                   pDevice->SwapChain()->Windowed(),
                                                   MultiSampleType);
        if (FAILED(*phr))
        {
            DPF_ERR("Unsupported multisample type requested. CreateRenderTarget/CreateDepthStencil failed.");
            return;
        }
    }

    // Back buffers are actually, for now, created just like other device
    // surfaces.
    
    // Otherwise, we need to call the driver
    // and get ourselves a handle. 

    // Create a DDSURFACE and CreateSurfaceData object
    DDSURFACEINFO SurfInfo;
    ZeroMemory(&SurfInfo, sizeof(SurfInfo));

    if ((hKernelHandle == NULL) &&
        (!(pDevice->Enum()->NoDDrawSupport(pDevice->AdapterIndex())) ||
         !(D3DUSAGE_PRIMARYSURFACE & Usage))
       )
    {
        // If we are not passed a handle, then we need to get one from
        // the DDI

        D3D8_CREATESURFACEDATA CreateSurfaceData;
        ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

        // Set up the basic information
        CreateSurfaceData.hDD             = pDevice->GetHandle();
        CreateSurfaceData.pSList          = &SurfInfo;
        CreateSurfaceData.dwSCnt          = 1;
        CreateSurfaceData.Type            = D3DRTYPE_SURFACE;
        CreateSurfaceData.Pool            = m_desc.Pool;
        CreateSurfaceData.dwUsage         = m_desc.Usage;
        CreateSurfaceData.Format          = RealFormat;
        CreateSurfaceData.MultiSampleType = MultiSampleType;

        // Specify the surface data
        SurfInfo.cpWidth  = Width;
        SurfInfo.cpHeight = Height;

        *phr = pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
        if (FAILED(*phr))
        {
            DPF_ERR("Failed to create driver surface");
            return;
        }

        // Remember the kernel handle
        SetKernelHandle(SurfInfo.hKernelHandle);

        // Remember the actual pool
        m_desc.Pool = CreateSurfaceData.Pool;
    }
    else
    {
        // If the caller has already allocated this
        // then we assume that the pool is LocalVidMem
        SurfInfo.hKernelHandle = hKernelHandle;
        m_desc.Pool            = D3DPOOL_LOCALVIDMEM;
    }

    m_desc.Size = SurfInfo.iPitch * Height;
    if (m_desc.MultiSampleType != D3DMULTISAMPLE_NONE)
        m_desc.Size *= (UINT)m_desc.MultiSampleType;

    return;
} // CDriverSurface::CDriverSurface

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverSurface::~CDriverSurface"
CDriverSurface::~CDriverSurface() 
{
    if (KernelHandle() != 0)
    {
        D3D8_DESTROYSURFACEDATA DestroyData;

        ZeroMemory(&DestroyData, sizeof DestroyData);
        DestroyData.hDD = Device()->GetHandle();
        DestroyData.hSurface = KernelHandle();
        Device()->GetHalCallbacks()->DestroySurface(&DestroyData);
    }

    return;
} // CDriverSurface::CDriverSurface


#undef DPF_MODNAME
#define DPF_MODNAME "CDriverSurface::LockRect"

STDMETHODIMP CDriverSurface::LockRect(D3DLOCKED_RECT *pLockedRectData, 
                                      CONST RECT           *pRect, 
                                      DWORD           dwFlags)
{   
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedRectData, sizeof(D3DLOCKED_RECT)))
    {
        DPF_ERR("bad pointer for m_pLockedRectData passed to LockRect");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data
    ZeroMemory(pLockedRectData, sizeof(D3DLOCKED_RECT));

    // Validate Rect
    if (pRect != NULL)
    {
        if (!CPixel::IsValidRect(m_desc.Format,
                                 m_desc.Width, 
                                 m_desc.Height, 
                                 pRect))
        {
            DPF_ERR("LockRect for a driver-allocated Surface failed");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_SURF_VALID)
    {
        DPF_ERR("Invalid dwFlags parameter passed to LockRect");
        DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_SURF_VALID);
        return D3DERR_INVALIDCALL;
    }

    // Can't lock surfaces that are not lockable
    if (!IsLockable())
    {
        ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }
    return InternalLockRect(pLockedRectData, pRect, dwFlags);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverSurface::InternalLockRect"

HRESULT CDriverSurface::InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                         CONST RECT     *pRect, 
                                         DWORD           dwFlags)
{   
    // Only one lock outstanding at a time is supported
    // (even internally)
    if (m_isLocked)
    {
        DPF_ERR("LockRect failed on a surface; surface was already locked.");
        return D3DERR_INVALIDCALL;
    }

    D3D8_LOCKDATA lockData;
    ZeroMemory(&lockData, sizeof lockData);

    lockData.hDD        = Device()->GetHandle();
    lockData.hSurface   = KernelHandle();
    lockData.dwFlags    = dwFlags;
    if (pRect != NULL)
    {
        lockData.bHasRect = TRUE;
        lockData.rArea = *((RECTL *) pRect);
    }
    else
    {
        DXGASSERT(lockData.bHasRect == FALSE);
    }

    // Sync before allowing read or write access
    Sync();

    HRESULT hr = Device()->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
    {
        DPF_ERR("Error trying to lock driver surface");
        return hr;
    }

    // Fill in the Locked_Rect fields 
    if (CPixel::IsDXT(m_desc.Format))
    {
        // Pitch is the number of bytes for
        // one row's worth of blocks for linear formats

        // Start with our width
        UINT Width = m_desc.Width;

        // Convert to blocks
        Width = Width / 4;

        // At least one block
        if (Width == 0)
            Width = 1;

        if (m_desc.Format == D3DFMT_DXT1)
        {
            // 8 bytes per block for DXT1
            pLockedRectData->Pitch = Width * 8;
        }
        else
        {
            // 16 bytes per block for DXT2-5
            pLockedRectData->Pitch = Width * 16;
        }
    }
    else
    {
        pLockedRectData->Pitch = lockData.lPitch;
    }
    pLockedRectData->pBits  = lockData.lpSurfData;

    // Mark ourselves as locked
    m_isLocked = TRUE;

    // Done
    return hr;
} // LockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverSurface::UnlockRect"

STDMETHODIMP CDriverSurface::UnlockRect()
{
    API_ENTER(Device());

    // If we aren't locked; then something is wrong
    if (!m_isLocked)
    {
        DPF_ERR("UnlockRect failed; surface wasn't locked.");
        return D3DERR_INVALIDCALL;
    }

    return InternalUnlockRect();
}
#undef DPF_MODNAME
#define DPF_MODNAME "CDriverSurface::InternalUnlockRect"

HRESULT CDriverSurface::InternalUnlockRect()
{
    DXGASSERT(m_isLocked);

    D3D8_UNLOCKDATA unlockData = {
        Device()->GetHandle(),
        KernelHandle()
    };

    HRESULT hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
    if (SUCCEEDED(hr))
    {
        // Clear our locked state
        m_isLocked = FALSE;
    }

    // Done
    return hr;
} // UnlockRect


// End of file : surface.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\resource.inl ===
#ifndef __RESOURCE_INL__
#define __RESOURCE_INL__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       resource.inl
 *  Content:    Contains inlines from CResource that need to be separated
 *              to prevent a reference cycle with CD3DBase
 *
 ***************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::Sync"

inline void CResource::Sync()
{
    static_cast<CD3DBase*>(Device())->Sync(m_qwBatchCount);
} // CResource::Sync

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::Batch"

inline void CResource::Batch()
{
    if (IsD3DManaged())
    {
        Device()->ResourceManager()->Batch(RMHandle(), static_cast<CD3DBase*>(Device())->CurrentBatch());
    }
    else
    {
        SetBatchNumber(static_cast<CD3DBase*>(Device())->CurrentBatch());
    }
} // CResource::Batch

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::BatchBase"

inline void CResource::BatchBase()
{
    SetBatchNumber(static_cast<CD3DBase*>(Device())->CurrentBatch());
} // CResource::BatchBase

#endif //__RESOURCE_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\surface.hpp ===
#ifndef __SURFACE_HPP__
#define __SURFACE_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       surface.hpp
 *  Content:    Class header the stand-alone surface class. This class
 *              is intended to be returned by the CreateRenderTarget
 *              creation method. It is also used by the CreateZStencil
 *              device method.
 *
 ***************************************************************************/

// Includes
#include "d3dobj.hpp"
#include "d3di.hpp"

//
// The CSurface class is a standalone surface class; "standalone" indicates
// that it doesn't rely on another class for storing state. 
//
// The base class implementation assumes a sys-mem allocation.
//

class CSurface : public CBaseObject, public CBaseSurface
{
public:
    // Creation method to allow creation of render targets
    static HRESULT CreateRenderTarget(CBaseDevice        *pDevice, 
                                      DWORD               cpWidth,
                                      DWORD               cpHeight,
                                      D3DFORMAT           Format,
                                      D3DMULTISAMPLE_TYPE MultiSampleType,
                                      BOOL                bLockable,
                                      REF_TYPE            refType,
                                      IDirect3DSurface8 **ppSurface)
    {
        DWORD Usage = D3DUSAGE_RENDERTARGET;
        if (bLockable)
            Usage = D3DUSAGE_LOCK | D3DUSAGE_RENDERTARGET;

        return Create(pDevice, 
                      cpWidth,
                      cpHeight,
                      Usage,
                      Format,
                      MultiSampleType,
                      refType,
                      ppSurface);
    }

    // Creation method to allow creation of Z/Stencil buffers 
    static HRESULT CreateZStencil(CBaseDevice        *pDevice, 
                                  DWORD               cpWidth,
                                  DWORD               cpHeight,
                                  D3DFORMAT           Format,
                                  D3DMULTISAMPLE_TYPE MultiSampleType,
                                  REF_TYPE            refType,
                                  IDirect3DSurface8 **ppSurface)
    {
        return Create(pDevice, 
                      cpWidth,
                      cpHeight,
                      D3DUSAGE_DEPTHSTENCIL,
                      Format,
                      MultiSampleType,
                      refType,
                      ppSurface);
    }

    // Creation method for stand-along ImageSurface 
    static HRESULT CreateImageSurface(CBaseDevice        *pDevice,
                                      DWORD               cpWidth,
                                      DWORD               cpHeight,
                                      D3DFORMAT           Format,
                                      REF_TYPE            refType,
                                      IDirect3DSurface8 **ppSurface);

    // Destructor
    virtual ~CSurface();

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID  riid, 
                               VOID  **ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    // IBuffer methods
    STDMETHOD(SetPrivateData)(REFGUID riid, 
                              CONST VOID   *pvData, 
                              DWORD   cbData, 
                              DWORD   dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID riid, 
                              VOID   *pvData, 
                              DWORD  *pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD(GetContainer)(REFIID riid, 
                            void **ppContainer);

    STDMETHOD(GetDevice)(IDirect3DDevice8 **ppDevice);

    // IDirect3DSurface8 methods
    STDMETHOD(GetDesc)(D3DSURFACE_DESC *pDesc);

    STDMETHOD(LockRect)(D3DLOCKED_RECT  *pLockedRectData, 
                        CONST RECT      *pRect, 
                        DWORD            dwFlags) PURE;

    STDMETHOD(UnlockRect)() PURE;

    BOOL IsLockable() const
    {
        if (m_desc.Usage & D3DUSAGE_LOCK)
            return TRUE;
        else
            return FALSE;
    } // IsLockable

#ifdef DEBUG
    // DPF helper for explaining why lock failed
    void ReportWhyLockFailed(void) const;
#else  // !DEBUG
    void ReportWhyLockFailed(void) const
    {
        // Do Nothing In Retail
    } // ReportWhyLockFailed
#endif // !DEBUG

    D3DFORMAT GetUserFormat() const
    {
        return m_formatUser;
    } // GetUserFormat

    // BaseSurface methods
    virtual DWORD DrawPrimHandle() const
    {
        return BaseDrawPrimHandle();
    } // GetDrawPrimHandle
    virtual HANDLE KernelHandle() const
    {
        return BaseKernelHandle();
    } // GetKernelHandle

    virtual DWORD IncrementUseCount()
    {
        return CBaseObject::IncrementUseCount();
    } // IncrementUseCount

    virtual DWORD DecrementUseCount()
    {
        return CBaseObject::DecrementUseCount();
    } // DecrementUseCount

    virtual void Batch()
    {
        ULONGLONG qwBatch = static_cast<CD3DBase*>(Device())->CurrentBatch();        
        DXGASSERT(qwBatch >= m_qwBatchCount);
        m_qwBatchCount = qwBatch;
    } // Batch

    // Sync should be called before
    // any read or write access to the surface
    virtual void Sync()
    {
        static_cast<CD3DBase*>(Device())->Sync(m_qwBatchCount);
    } // Sync

    // OnDestroy function is called just
    // before an object is about to get deleted; we
    // use this to provide synching prior to deletion
    virtual void OnDestroy()
    {
        Sync();
    }; // OnDestroy

    virtual D3DSURFACE_DESC InternalGetDesc() const;

    virtual CBaseDevice * InternalGetDevice() const
    {
        return CBaseObject::Device();
    } // Device

    // Determines if a LOAD_ONCE surface has already
    // been loaded
    virtual BOOL IsLoaded() const
    {
        // These kinds of surfaces (RT/DS/Image) are never
        // load-once; so this should never be called.
        DXGASSERT(!(m_desc.Usage & D3DUSAGE_LOADONCE));
        DXGASSERT(FALSE);
        return FALSE;
    } // IsLoaded

    // End Of BaseSurface methods

protected:

    // Creation method to allow creation of render targets/zbuffers
    static HRESULT Create(CBaseDevice        *pDevice, 
                          DWORD               cpWidth,
                          DWORD               cpHeight,
                          DWORD               dwUsage,
                          D3DFORMAT           Format,
                          D3DMULTISAMPLE_TYPE MultiSampleType,
                          REF_TYPE            refType,
                          IDirect3DSurface8 **ppSurface);

    // Surface description
    D3DSURFACE_DESC m_desc;

    // Pool that User specified
    D3DPOOL         m_poolUser;

    // Format that User specified
    D3DFORMAT       m_formatUser;

    // Constructor returns an error code
    // if the object could not be fully
    // constructed
    CSurface(CBaseDevice *pDevice, 
             DWORD        cpWidth,
             DWORD        cpHeight,
             DWORD        dwUsage,
             D3DFORMAT    Format,
             REF_TYPE     refType,
             HRESULT     *phr
             );

private:
    // Batch count to make sure that the current
    // command buffer has been flushed
    // before read or write access to the
    // bits
    ULONGLONG m_qwBatchCount;

}; // class CSurface

// Derived class for system-memory version
class CSysMemSurface : public CSurface
{
    // CSurface is the master class and can access
    // whatever it wants
    friend CSurface;

public:
    // Constructor
    CSysMemSurface(CBaseDevice         *pDevice, 
                   DWORD                cpWidth,
                   DWORD                cpHeight,
                   DWORD                dwUsage,
                   D3DFORMAT            Format,
                   REF_TYPE             refType,
                   HRESULT             *phr
                   );

    //  destructor
    virtual ~CSysMemSurface();

    // Override Lock and Unlock
    STDMETHOD(LockRect)(D3DLOCKED_RECT *pLockedRectData, 
                        CONST RECT     *pRect, 
                        DWORD           dwFlags);

    STDMETHOD(UnlockRect)();

    // Internal lock functions bypass
    // parameter checking and also whether the
    // surface marked as Lockable or LockOnce
    // etc. (Methods of CBaseSurface)
    virtual HRESULT InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                     CONST RECT     *pRect, 
                                     DWORD           dwFlags);

    virtual HRESULT InternalUnlockRect();

private:
    BYTE  *m_rgbPixels;
}; // class CSysMemSurface

// Derived class for the driver allocated version
class CDriverSurface : public CSurface
{
    // CSurface is the master class and can access
    // whatever it wants
    friend CSurface;

public:
    // Constructor
    CDriverSurface(CBaseDevice          *pDevice, 
                   DWORD                 cpWidth,
                   DWORD                 cpHeight,
                   DWORD                 dwUsage,
                   D3DFORMAT             UserFormat,
                   D3DFORMAT             RealFormat,
                   D3DMULTISAMPLE_TYPE   MultiSampleType,
                   HANDLE                hKernelHandle,
                   REF_TYPE              refType,
                   HRESULT              *phr
                   );

    //  destructor
    virtual ~CDriverSurface();

    // Override Lock and Unlock
    STDMETHOD(LockRect)(D3DLOCKED_RECT *pLockedRectData, 
                        CONST RECT     *pRect, 
                        DWORD           dwFlags);

    STDMETHOD(UnlockRect)();

    // Internal lock functions bypass
    // parameter checking and also whether the
    // surface marked as Lockable or LockOnce
    // etc. (Methods of CBaseSurface)
    virtual HRESULT InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                     CONST RECT     *pRect, 
                                     DWORD           dwFlags);

    virtual HRESULT InternalUnlockRect();

}; // CDriverSurface


#endif // __SURFACE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\swapchan.cpp ===
//=============================================================================
// Copyright (c) 1999 Microsoft Corporation
//
// swapchan.cpp
//
// Direct3D swap chain implementation.
//
// Created 11/16/1999 johnstep (John Stephens)
//=============================================================================

#include "ddrawpr.h"
#include "swapchan.hpp"
#include "pixel.hpp"

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::QueryInterface"

//=============================================================================
// IUnknown::QueryInterface (public)
//
// Created 11/16/1999 johnstep
//=============================================================================

STDMETHODIMP
CSwapChain::QueryInterface(
    REFIID riid,
    void **ppInterface
  )
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppInterface))
    {
        DPF_ERR("Invalid ppvObj parameter passed to QueryInterface for a SwapChain");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for a SwapChain");
        return D3DERR_INVALIDCALL;
    }

    if ((riid == IID_IDirect3DSwapChain8) || (riid == IID_IUnknown))
    {
        AddRef();
        *ppInterface =
            static_cast<void *>(
                static_cast<IDirect3DSwapChain8 *>(this));
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to QueryInterface for a SwapChain");

    // Null out param
    *ppInterface = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::AddRef"

//=============================================================================
// IUnknown::AddRef (public)
//
// Created 11/16/1999 johnstep
//=============================================================================

STDMETHODIMP_(ULONG)
CSwapChain::AddRef()
{
    API_ENTER_NO_LOCK(Device());   
    
    return AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::Release"

//=============================================================================
// IUnknown::Release (public)
//
// Created 11/16/1999 johnstep
//=============================================================================

STDMETHODIMP_(ULONG)
CSwapChain::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());   
    
    return ReleaseImpl();
} // Release

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::CSwapChain"

//=============================================================================
// CSwapChain::CSwapChain
//
// Created 11/16/1999 johnstep
//=============================================================================

CSwapChain::CSwapChain(
    CBaseDevice         *pDevice,
    REF_TYPE            refType) :
        CBaseObject(pDevice, refType),
        m_pCursor(NULL),
        m_hGDISurface(NULL),
        m_pMirrorSurface(NULL),
        m_pPrimarySurface(NULL),
        m_ppBackBuffers(NULL),
        m_presentnext(0),
        m_cBackBuffers(0),
        m_bExclusiveMode(FALSE),
        m_pCursorShadow(NULL),
        m_pHotTracking(NULL),
        m_lIMEState(0),
        m_lSetIME(0),
        m_dwFlags(0),
        m_dwFlipCnt(0),
        m_dwFlipTime(0xffffffff),
        m_uiErrorMode(0)
{
    HKEY hKey;
    ZeroMemory(&m_BltData, sizeof m_BltData);
    m_BltData.hDD = Device()->GetHandle();
    m_BltData.bltFX.dwROP = SRCCOPY;
    m_BltData.ddRVal = E_FAIL;

    if (!RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD   type;
        DWORD   value;
        DWORD   cb = sizeof(value);

        if (!RegQueryValueEx(hKey, REGSTR_VAL_DDRAW_SHOWFRAMERATE, NULL, &type, (CONST LPBYTE)&value, &cb))
        {
	    DPF( 2, REGSTR_VAL_DDRAW_SHOWFRAMERATE" : %d", value );
            if (value)
            {
                m_dwFlags |= D3D_REGFLAGS_SHOWFRAMERATE;
            }
        }
#ifdef  WINNT
        cb = sizeof(value);
        if (!RegQueryValueEx(hKey, REGSTR_VAL_D3D_FLIPNOVSYNC, NULL, &type, (CONST LPBYTE)&value, &cb))
        {
	    DPF( 2, REGSTR_VAL_D3D_FLIPNOVSYNC" : %d", value );
            if (value)
            {
                m_dwFlags |= D3D_REGFLAGS_FLIPNOVSYNC;
            }
        }
        RegCloseKey(hKey);
    }
    m_dwForceRefreshRate = 0;
    if( !RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_DDRAW, &hKey ) )
    {
        DWORD   type;
        DWORD   value;
        DWORD   cb = sizeof(value);

	if( !RegQueryValueEx( hKey, REGSTR_VAL_DDRAW_FORCEREFRESHRATE, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
            m_dwForceRefreshRate = value;
	}
#endif
        RegCloseKey(hKey);
    }
}

void CSwapChain::Init(
    D3DPRESENT_PARAMETERS* pPresentationParams,
    HRESULT             *pHr
  )
{
    DXGASSERT(pHr != NULL);

    //the gamma ramp is initialized to 1:1
    for (int i=0;i<256;i++)
    {
        m_DesiredGammaRamp.red[i] =
        m_DesiredGammaRamp.green[i] =
        m_DesiredGammaRamp.blue[i] = static_cast<WORD>(i);
    }

    *pHr = Reset(
        pPresentationParams);

    return;
} // CSwapChain::CSwapChain

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::~CSwapChain"

//=============================================================================
// CSwapChain::~CSwapChain
//
// Created 11/16/1999 johnstep
//=============================================================================

CSwapChain::~CSwapChain()
{
    if (!m_PresentationData.Windowed)
    {
        m_PresentationData.Windowed = TRUE;
        // make sure we restore after a fullscreen
        SetCooperativeLevel();
    }
    Destroy();
} // CSwapChain::~CSwapChain

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::CreateWindowed"

//=============================================================================
// CSwapChain::CreateWindowed
//
// Created 11/16/1999 johnstep
//=============================================================================

HRESULT
CSwapChain::CreateWindowed(
    UINT width,
    UINT height,
    D3DFORMAT backBufferFormat,
    UINT cBackBuffers,
    D3DMULTISAMPLE_TYPE MultiSampleType,
    BOOL bDiscard,
    BOOL bLockable
  )
{
    // For the windowed case, we will currently create exactly 3 surfaces
    // in this order:
    //
    //   1. Primary Surface
    //   2. Back Buffer
    //   3. Z Buffer (by notifying the device)
    //
    // For now, all 3 surfaces must reside in local video memory. Later,
    // we may allow multiple back buffers, if there is interest, to allow
    // simulated fullscreen-style double buffering (alternate back buffer
    // surfaces after presenting).
    //
    // !!! The primary surface is actually optional because we can just use
    // DdGetDC and then GDI BitBlt. But, presumably, there are performance
    // advantages to using DirectDraw Blt. Of course, the problem with using
    // DirectDraw Blts is keeping in sync with the window manager (so we
    // don't write outside of the window, etc.). GDI BitBlt will also handle
    // format conversion for us, though slowly.

    DXGASSERT(m_pPrimarySurface == NULL);
    DXGASSERT(m_ppBackBuffers == NULL);
    DXGASSERT(m_cBackBuffers == 0);

    HRESULT hr;
    if (D3DSWAPEFFECT_FLIP == m_PresentationData.SwapEffect)
    {
        cBackBuffers = m_PresentationData.BackBufferCount + 1;
    }

    // 1. Create a simple primary surface. If we already have a primary
    //    surface, then don't bother to create a new one.
    if (this == Device()->SwapChain())
    {
        DWORD   dwUsage = D3DUSAGE_PRIMARYSURFACE | D3DUSAGE_LOCK;
        DWORD   Width = Device()->DisplayWidth();
        DWORD   Height = Device()->DisplayHeight();

        // D3DSWAPEFFECT_NO_PRESENT is a hack to allow our D3D test framework
        // to create a windowed REF device after they have created a fullscreen
        // HAL device.  We cannot create a second primary surface for the windowed
        // device, but we cannot leave m_pPrimarySurface equal to NULL (becaue then
        // we cannot cleanup the swap chain and Reset will fail), so instead we
        // create a dummy surface and call it the primary, with the understanding
        // that this device will never call Present or use the primary surface in
        // any way.  We also don't have to do much checking since this is not an
        // external feature.
        if (D3DSWAPEFFECT_NO_PRESENT == m_PresentationData.SwapEffect)
        {
            dwUsage = D3DUSAGE_OFFSCREENPLAIN | D3DUSAGE_LOCK;
            Width = 256;
            Height = 256;
        }

        m_pPrimarySurface = new CDriverSurface(
                Device(),
                Width,
                Height,
                dwUsage,
                Device()->DisplayFormat(),      // UserFormat
                Device()->DisplayFormat(),      // RealFormat
                D3DMULTISAMPLE_NONE,//of course, when windowed
                0,                          // hKernelHandle
                REF_INTERNAL,
                &hr);
    }
    else
    {
        // Additional SwapChain, it's already there
        m_pPrimarySurface = Device()->SwapChain()->PrimarySurface();
        hr = DD_OK;
    }

    // 2. Create the back buffer.

    if (m_pPrimarySurface == NULL)
    {
        return E_OUTOFMEMORY;
    }

    m_PresentUseBlt = TRUE;
    if (SUCCEEDED(hr))
    {
        if (m_ppBackBuffers = new CDriverSurface *[cBackBuffers])
        {
            DWORD Usage = D3DUSAGE_BACKBUFFER | D3DUSAGE_RENDERTARGET;
            if ((D3DMULTISAMPLE_NONE == m_PresentationData.MultiSampleType) &&
                bLockable)
            {
                Usage |= D3DUSAGE_LOCK;
            }
            if (bDiscard)
            {
                Usage |= D3DUSAGE_DISCARD;
            }

            for (; m_cBackBuffers < cBackBuffers; ++m_cBackBuffers)
            {
                m_ppBackBuffers[m_cBackBuffers] = new CDriverSurface(
                    Device(),
                    width,
                    height,
                    Usage,
                    backBufferFormat,             // UserFormat
                    backBufferFormat,           // RealFormat
                    MultiSampleType,
                    0,                          // hKernelHandle
                    REF_INTRINSIC,
                    &hr);
                if (m_ppBackBuffers[m_cBackBuffers] == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                if (FAILED(hr))
                {
                    m_ppBackBuffers[m_cBackBuffers]->DecrementUseCount();
                    m_ppBackBuffers[m_cBackBuffers] = NULL;
                    break;
                }
            }

            if (m_cBackBuffers == cBackBuffers)
            {
                m_BltData.hDestSurface = m_pPrimarySurface->KernelHandle();
                m_BltData.dwFlags = DDBLT_WINDOWCLIP | DDBLT_ROP | DDBLT_WAIT | DDBLT_DX8ORHIGHER;

                if (Device()->GetD3DCaps()->MaxStreams != 0)
                {
                    m_BltData.dwFlags |= DDBLT_PRESENTATION;
                }

                if (D3DSWAPEFFECT_COPY_VSYNC == m_PresentationData.SwapEffect)
                {
                    m_BltData.dwFlags |= DDBLT_COPYVSYNC;                    

                    // Need to let thunk layer know current refresh rate
                    if (Device()->DisplayRate() < 60)
                    {
                        // 60Hz = 16.666ms per frame
                        // 75Hz = 13.333ms
                        // 85Hz = 11.765ms
                        m_BltData.threshold = 13;
                    }
                    else
                    {
                        m_BltData.threshold = (DWORD)(1000.0f / (float)Device()->DisplayRate()); 
                    }

                }
                m_ClientWidth = 0;  // windowed client is updated in present
                m_ClientHeight = 0;
                return hr;
            }

            // Something went wrong, so clean up now.

            // 2. Destroy Back Buffers, if any.

            while (m_cBackBuffers > 0)
            {
                m_ppBackBuffers[--m_cBackBuffers]->DecrementUseCount();
            }
            delete [] m_ppBackBuffers;
            m_ppBackBuffers = NULL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // 1. Destroy Primary Surface.

    if (this == Device()->SwapChain())
        m_pPrimarySurface->DecrementUseCount();
    m_pPrimarySurface = NULL;
    return hr;
} // CreateWindowed

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::CreateFullScreen"

//=============================================================================
// CSwapChain::CreateFullscreen
//
// Created 11/16/1999 johnstep
//=============================================================================

HRESULT
CSwapChain::CreateFullscreen(
    UINT width,
    UINT height,
    D3DFORMAT backBufferFormat,
    UINT cBackBuffers,
    UINT PresentationRate,
    D3DMULTISAMPLE_TYPE MultiSampleType,
    BOOL bDiscard,
    BOOL bLockable
  )
{
    HRESULT hr = E_FAIL;
    DWORD i;
    BOOL    bMirrorBufferCreated, bNoDDrawSupport;
    UINT    Usage = 0;

    if (bLockable)
    {
        Usage |= D3DUSAGE_LOCK;
    }
    if (bDiscard)
    {
        Usage |= D3DUSAGE_DISCARD;
    }

    // If it's a hardware device, we want to create a primary surface and a
    // number of backbuffers.  We need to make this a single driver call,
    // however, in order for everything to get attached correctly.  Therefore,
    // what we do is call the DDI to create the primary chain, and it will
    // return the handles for each surface in the chain.  After that, we
    // will individually create each swap chain buffer, but we will supply
    // it with the required handles rather than having it call the DDI itself.

    // First, call the DDI to allocate the memory and the kernel handles
    DDSURFACEINFO SurfInfoArray[D3DPRESENT_BACK_BUFFERS_MAX + 2];
    ZeroMemory(SurfInfoArray, sizeof(SurfInfoArray));
    
    D3D8_CREATESURFACEDATA CreateSurfaceData;
    