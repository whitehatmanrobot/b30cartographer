  )
{
    FIBRECHANNEL_DEVICE_PATH UNALIGNED    *Fibre;

    Fibre = DevPath;
    CatPrint(Str, L"Fibre(%lx)", Fibre->WWN);
}

VOID
_DevPath1394 (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    F1394_DEVICE_PATH UNALIGNED       *F1394;

    F1394 = DevPath;
    CatPrint(Str, L"1394(%g)", &F1394->Guid);
}



VOID
_DevPathUsb (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    USB_DEVICE_PATH UNALIGNED         *Usb;

    Usb = DevPath;
    CatPrint(Str, L"Usb(%x)", Usb->Port);
}


VOID
_DevPathI2O (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    I2O_DEVICE_PATH UNALIGNED         *I2O;

    I2O = DevPath;
    CatPrint(Str, L"I2O(%x)", I2O->Tid);
}

VOID
_DevPathMacAddr (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    MAC_ADDR_DEVICE_PATH UNALIGNED    *MAC;
    UINTN                   HwAddressSize;
    UINTN                   Index;

    MAC = DevPath;

    HwAddressSize = sizeof(EFI_MAC_ADDRESS);
    if (MAC->IfType == 0x01 || MAC->IfType == 0x00) {
        HwAddressSize = 6;
    }
    
    CatPrint(Str, L"Mac(");

    for(Index = 0; Index < HwAddressSize; Index++) {
        CatPrint(Str, L"%02x",MAC->MacAddress.Addr[Index]);
    }
    CatPrint(Str, L")");
}

VOID
_DevPathIPv4 (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    IPv4_DEVICE_PATH UNALIGNED     *IP;

    IP = DevPath;
    CatPrint(Str, L"IPv4(not-done)");
}

VOID
_DevPathIPv6 (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    IPv6_DEVICE_PATH UNALIGNED     *IP;

    IP = DevPath;
    CatPrint(Str, L"IP-v6(not-done)");
}

VOID
_DevPathInfiniBand (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    INFINIBAND_DEVICE_PATH UNALIGNED  *InfiniBand;

    InfiniBand = DevPath;
    CatPrint(Str, L"InfiniBand(not-done)");
}

VOID
_DevPathUart (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    UART_DEVICE_PATH UNALIGNED  *Uart;
    CHAR8             Parity;

    Uart = DevPath;
    switch (Uart->Parity) {
        case 0  : Parity = 'D'; break;
        case 1  : Parity = 'N'; break;
        case 2  : Parity = 'E'; break;
        case 3  : Parity = 'O'; break;
        case 4  : Parity = 'M'; break;
        case 5  : Parity = 'S'; break;
        default : Parity = 'x'; break;
    }

    if (Uart->BaudRate == 0) {
        CatPrint(Str, L"Uart(DEFAULT %c",Uart->BaudRate,Parity);
    } else {
        CatPrint(Str, L"Uart(%d %c",Uart->BaudRate,Parity);
    }

    if (Uart->DataBits == 0) {
        CatPrint(Str, L"D");
    } else {
        CatPrint(Str, L"%d",Uart->DataBits);
    }

    switch (Uart->StopBits) {
        case 0  : CatPrint(Str, L"D)");   break;
        case 1  : CatPrint(Str, L"1)");   break;
        case 2  : CatPrint(Str, L"1.5)"); break;
        case 3  : CatPrint(Str, L"2)");   break;
        default : CatPrint(Str, L"x)");   break;
    }
}


VOID
_DevPathHardDrive (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    HARDDRIVE_DEVICE_PATH UNALIGNED   *Hd;

    Hd = DevPath;
    switch (Hd->SignatureType) {
        case SIGNATURE_TYPE_MBR:
            CatPrint(Str, L"HD(Part%d,Sig%08X)", 
                Hd->PartitionNumber,
                *((UINT32 *)(&(Hd->Signature[0])))
                );
            break;
        case SIGNATURE_TYPE_GUID:
            CatPrint(Str, L"HD(Part%d,Sig%g)", 
                Hd->PartitionNumber,
                (EFI_GUID *) &(Hd->Signature[0])     
                );
            break;
        default:
            CatPrint(Str, L"HD(Part%d,MBRType=%02x,SigType=%02x)", 
                Hd->PartitionNumber,
                Hd->MBRType,
                Hd->SignatureType
                );
            break;
    }
}

VOID
_DevPathCDROM (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    CDROM_DEVICE_PATH UNALIGNED       *Cd;

    Cd = DevPath;
    CatPrint(Str, L"CDROM(Entry%x)", Cd->BootEntry);
}

VOID
_DevPathFilePath (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    FILEPATH_DEVICE_PATH UNALIGNED    *Fp;   

    Fp = DevPath;
    CatPrint(Str, L"%s", Fp->PathName);
}

VOID
_DevPathMediaProtocol (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    MEDIA_PROTOCOL_DEVICE_PATH UNALIGNED  *MediaProt;

    MediaProt = DevPath;
    CatPrint(Str, L"%g", &MediaProt->Protocol);
}

VOID
_DevPathBssBss (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    BBS_BBS_DEVICE_PATH UNALIGNED     *Bss;
    CHAR16                  *Type;

    Bss = DevPath;
    switch (Bss->DeviceType) {
    case BBS_TYPE_FLOPPY:               Type = L"Floppy";       break;
    case BBS_TYPE_HARDDRIVE:            Type = L"Harddrive";    break;
    case BBS_TYPE_CDROM:                Type = L"CDROM";        break;
    case BBS_TYPE_PCMCIA:               Type = L"PCMCIA";       break;
    case BBS_TYPE_USB:                  Type = L"Usb";          break;
    case BBS_TYPE_EMBEDDED_NETWORK:     Type = L"Net";          break;
    default:                            Type = L"?";            break;
    }

    CatPrint(Str, L"Bss-%s(%a)", Type, Bss->String);
}


VOID
_DevPathEndInstance (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    CatPrint(Str, L",");
}

VOID
_DevPathNodeUnknown (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    CatPrint(Str, L"?");
}


struct {
    UINT8   Type;
    UINT8   SubType;
    VOID    (*Function)(UNICODE_STRING *, VOID *);    
} DevPathTable[] = {
    HARDWARE_DEVICE_PATH,   HW_PCI_DP,                        _DevPathPci,
    HARDWARE_DEVICE_PATH,   HW_PCCARD_DP,                     _DevPathPccard,
    HARDWARE_DEVICE_PATH,   HW_MEMMAP_DP,                     _DevPathMemMap,
    HARDWARE_DEVICE_PATH,   HW_VENDOR_DP,                     _DevPathVendor,
    HARDWARE_DEVICE_PATH,   HW_CONTROLLER_DP,                 _DevPathController,
    ACPI_DEVICE_PATH,       ACPI_DP,                          _DevPathAcpi,
    MESSAGING_DEVICE_PATH,  MSG_ATAPI_DP,                     _DevPathAtapi,
    MESSAGING_DEVICE_PATH,  MSG_SCSI_DP,                      _DevPathScsi,
    MESSAGING_DEVICE_PATH,  MSG_FIBRECHANNEL_DP,              _DevPathFibre,
    MESSAGING_DEVICE_PATH,  MSG_1394_DP,                      _DevPath1394,
    MESSAGING_DEVICE_PATH,  MSG_USB_DP,                       _DevPathUsb,
    MESSAGING_DEVICE_PATH,  MSG_I2O_DP,                       _DevPathI2O,
    MESSAGING_DEVICE_PATH,  MSG_MAC_ADDR_DP,                  _DevPathMacAddr,
    MESSAGING_DEVICE_PATH,  MSG_IPv4_DP,                      _DevPathIPv4,
    MESSAGING_DEVICE_PATH,  MSG_IPv6_DP,                      _DevPathIPv6,
    MESSAGING_DEVICE_PATH,  MSG_INFINIBAND_DP,                _DevPathInfiniBand,
    MESSAGING_DEVICE_PATH,  MSG_UART_DP,                      _DevPathUart,
    MESSAGING_DEVICE_PATH,  MSG_VENDOR_DP,                    _DevPathVendor,
    MEDIA_DEVICE_PATH,      MEDIA_HARDDRIVE_DP,               _DevPathHardDrive,
    MEDIA_DEVICE_PATH,      MEDIA_CDROM_DP,                   _DevPathCDROM,
    MEDIA_DEVICE_PATH,      MEDIA_VENDOR_DP,                  _DevPathVendor,
    MEDIA_DEVICE_PATH,      MEDIA_FILEPATH_DP,                _DevPathFilePath,
    MEDIA_DEVICE_PATH,      MEDIA_PROTOCOL_DP,                _DevPathMediaProtocol,
    BBS_DEVICE_PATH,        BBS_BBS_DP,                       _DevPathBssBss,
    END_DEVICE_PATH_TYPE,   END_INSTANCE_DEVICE_PATH_SUBTYPE, _DevPathEndInstance,
    0,                      0,                          NULL
};


#define ALIGN_SIZE(a)   ((a % MIN_ALIGNMENT_SIZE) ? MIN_ALIGNMENT_SIZE - (a % MIN_ALIGNMENT_SIZE) : 0)

EFI_DEVICE_PATH UNALIGNED *
UnpackDevicePath (
    IN EFI_DEVICE_PATH UNALIGNED *DevPath
    )
{
    EFI_DEVICE_PATH UNALIGNED     *Src, *Dest, *NewPath;
    UINTN               Size;
    
    /* 
     *  Walk device path and round sizes to valid boundries
     *      */

    Src = DevPath;
    Size = 0;
    for (; ;) {
        Size += DevicePathNodeLength(Src);
        Size += ALIGN_SIZE(Size);

        if (IsDevicePathEnd(Src)) {
            break;
        }

        Src = NextDevicePathNode(Src);
    }


    /* 
     *  Allocate space for the unpacked path
     */
    NewPath = NULL;
    EfiBS->AllocatePool(    
                EfiLoaderData,
                Size,
                (VOID **) &NewPath );
    
    if (NewPath) {
        RtlZeroMemory( NewPath, Size );

        ASSERT (((UINTN)NewPath) % MIN_ALIGNMENT_SIZE == 0);

        /* 
         *  Copy each node
         */

        Src = DevPath;
        Dest = NewPath;
        for (; ;) {
            Size = DevicePathNodeLength(Src);
            RtlCopyMemory (Dest, Src, Size);
            Size += ALIGN_SIZE(Size);
            SetDevicePathNodeLength (Dest, Size);
            Dest->Type |= EFI_DP_TYPE_UNPACKED;
            Dest = (EFI_DEVICE_PATH UNALIGNED *) (((UINT8 *) Dest) + Size);

            if (IsDevicePathEnd(Src)) {
                break;
            }

            Src = NextDevicePathNode(Src);
        }
    }

    return NewPath;
}



WCHAR DbgDevicePathStringBuffer[1000];

CHAR16 *
DevicePathToStr (
    EFI_DEVICE_PATH UNALIGNED *DevPath
    )
/*++

    Turns the Device Path into a printable string.  Allcoates
    the string from pool.  The caller must FreePool the returned
    string.

--*/
{
    UNICODE_STRING      Str;
    EFI_DEVICE_PATH UNALIGNED  *DevPathNode;
    VOID                (*DumpNode)(UNICODE_STRING *, VOID *);    
    UINTN               Index, NewSize;

    RtlZeroMemory(DbgDevicePathStringBuffer, sizeof(DbgDevicePathStringBuffer));
    Str.Buffer= DbgDevicePathStringBuffer;
    Str.Length = sizeof(DbgDevicePathStringBuffer);
    Str.MaximumLength = sizeof(DbgDevicePathStringBuffer);

    /* 
     *  Unpacked the device path
     */

    DevPath = UnpackDevicePath(DevPath);
    ASSERT (DevPath);


    /* 
     *  Process each device path node
     *      */

    DevPathNode = DevPath;
    while (!IsDevicePathEnd(DevPathNode)) {

        /* 
         *  Find the handler to dump this device path node
         */

        DumpNode = NULL;
        for (Index = 0; DevPathTable[Index].Function; Index += 1) {

            if (DevicePathType(DevPathNode) == DevPathTable[Index].Type &&
                DevicePathSubType(DevPathNode) == DevPathTable[Index].SubType) {
                DumpNode = DevPathTable[Index].Function;
                break;
            }
        }

        /* 
         *  If not found, use a generic function
         */

        if (!DumpNode) {
            DumpNode = _DevPathNodeUnknown;
        }

        /* 
         *   Put a path seperator in if needed
         */

        if (Str.Length  &&  DumpNode != _DevPathEndInstance) {
            CatPrint (&Str, L"/");
        }

        /* 
         *  Print this node of the device path
         */

        DumpNode (&Str, DevPathNode);

        /* 
         *  Next device path node
         */

        DevPathNode = NextDevicePathNode(DevPathNode);
    }

    /* 
     *  Shrink pool used for string allocation
     */

    EfiBS->FreePool (DevPath);

    return Str.Buffer;
}






PVOID
FindSMBIOSTable(
    UCHAR   RequestedTableType
    )
/*++

Routine Description:

    This routine searches through the SMBIOS tables for the specified table
    type.

Arguments:

    RequestedTableType - Which SMBIOS table are we looking for?

Return Value:

    NULL - THe specified table was not found.
    
    PVOID - A pointer to the specified table.

--*/
{
extern PVOID SMBiosTable;

    PUCHAR                          StartPtr = NULL;
    PUCHAR                          EndPtr = NULL;
    PSMBIOS_EPS_HEADER              SMBiosEPSHeader = NULL;
    PDMIBIOS_EPS_HEADER             DMIBiosEPSHeader = NULL;
    PSMBIOS_STRUCT_HEADER           SMBiosHeader = NULL;



    if( SMBiosTable == NULL ) {
        return NULL;
    }


    //
    // Set up our search pointers.
    //    
    SMBiosEPSHeader = (PSMBIOS_EPS_HEADER)SMBiosTable;
    DMIBiosEPSHeader = (PDMIBIOS_EPS_HEADER)&SMBiosEPSHeader->Signature2[0];

    StartPtr = (PUCHAR)ULongToPtr(DMIBiosEPSHeader->StructureTableAddress);
    EndPtr = StartPtr + DMIBiosEPSHeader->StructureTableLength;

    if( BdDebuggerEnabled ) { 
        DbgPrint( "FindSMBIOSTable: About to start searching for table type %d at address (%x)...\r\n",
              RequestedTableType,
              PtrToUlong(StartPtr) );
    }


    while( StartPtr < EndPtr ) {

        SMBiosHeader = (PSMBIOS_STRUCT_HEADER)StartPtr;

        if( SMBiosHeader->Type == RequestedTableType ) {

            // This is the table we're looking for.
            if( BdDebuggerEnabled ) {
                DbgPrint( "FindSMBIOSTable: Found requested table type %d at address %x\r\n",
                      RequestedTableType,
                      PtrToUlong(StartPtr) );
            }
            return (PVOID)StartPtr;
        } else {

            //
            // It's not him.  Go to the next table.
            //
            if( BdDebuggerEnabled ) {
                DbgPrint( "FindSMBIOSTable: Inspected table type %d at address %x\r\n",
                      SMBiosHeader->Type,
                      PtrToUlong(StartPtr) );
            }
        
            StartPtr += SMBiosHeader->Length;

            //
            // jump over any trailing string-list that may be appeneded onto the
            // end of this table.
            //
            while ( (*((USHORT UNALIGNED *)StartPtr) != 0)  &&
                    (StartPtr < EndPtr) ) {
                
                StartPtr++;
            }
            StartPtr += 2;

        }

    }

    return NULL;

}


VOID
EfiCheckFirmwareRevision(
    VOID
    )
/*++

Routine Description:

    This routine will retrieve the BIOS revision value then parse it to determine
    if the revision is new enough.
    
    If the revision is not new enough, we won't be returning from this function.

Arguments:

    None.

Return Value:

    None.

--*/
{
#define         FIRMWARE_MINIMUM_SOFTSUR (103)
#define         FIRMWARE_MINIMUM_LION (71)
    PUCHAR      FirmwareString = NULL;
    PUCHAR      VendorString = NULL;
    PUCHAR      TmpPtr = NULL;
    ULONG       FirmwareVersion = 0;
    ULONG       FirmwareMinimum = 0;
    BOOLEAN     IsSoftSur = FALSE;
    BOOLEAN     IsVendorIntel = FALSE;
    WCHAR       OutputBuffer[256];
    PSMBIOS_BIOS_INFORMATION_STRUCT BiosInfoHeader = NULL;
    ULONG       i = 0;
    


    BiosInfoHeader = (PSMBIOS_BIOS_INFORMATION_STRUCT)FindSMBIOSTable( SMBIOS_BIOS_INFORMATION_TYPE );

    if( BiosInfoHeader ) {
         
        
        //
        // Get the firmware version string.
        //
        if( (ULONG)BiosInfoHeader->Version > 0 ) {
 
         
            // Jump to the end of the formatted portion of the SMBIOS table.
            FirmwareString = (PUCHAR)BiosInfoHeader + BiosInfoHeader->Length;
                            
            
            //
            // Now jump over some number of strings to get to our string.
            //
            // This is a bit scary because we're trusting what SMBIOS
            // has handed us.  If he gave us something bogus, then
            // we're about run off the end of the world looking for NULL
            // string terminators.
            //
            for( i = 0; i < ((ULONG)BiosInfoHeader->Version-1); i++ ) {
                while( *FirmwareString != 0 ) {
                    FirmwareString++;
                }
                FirmwareString++;
            }


            //
            // Determine platform and firmware version.
            //
            // FirmwareString should look something like:
            // W460GXBS2.86E.0103B.P05.200103281759
            // --------      ----
            //    |            |
            //    |             ------- Firmware version
            //    |
            //     -------------------- Platform identifier.  "W460GXBS" means softsur.
            //                          Anything else means Lion.
            //
        
        

            //
            if( FirmwareString ) {

                IsSoftSur = !strncmp( FirmwareString, "W460GXBS", 8 );

                // Get the minimum firmware that's okay, based on the platform.
                FirmwareMinimum = (IsSoftSur) ? FIRMWARE_MINIMUM_SOFTSUR : FIRMWARE_MINIMUM_LION;

                
                // Get the version.
                TmpPtr = strchr( FirmwareString, '.' );
                if( TmpPtr ) {
                    TmpPtr++;
                    TmpPtr = strchr( TmpPtr, '.' );
                    if( TmpPtr ) {
                        TmpPtr++;
                        FirmwareVersion = strtoul( TmpPtr, NULL, 10 );

#if DBG


                        swprintf( OutputBuffer,
                                  L"EfiCheckFirmwareRevision: Successfully retrieved the Firmware String: %S\r\n",
                                  FirmwareString );
                        EfiST->ConOut->OutputString(EfiST->ConOut, OutputBuffer );


                        swprintf( OutputBuffer,
                                  L"EfiCheckFirmwareRevision: Detected platform: %S\r\n",
                                  IsSoftSur ? "Softsur" : "Lion" );
                        EfiST->ConOut->OutputString(EfiST->ConOut, OutputBuffer );


                        swprintf( OutputBuffer,
                                  L"EfiCheckFirmwareRevision: FirmwareVersion: %d\r\n",
                                  FirmwareVersion );
                        EfiST->ConOut->OutputString(EfiST->ConOut, OutputBuffer );


                        swprintf( OutputBuffer,
                                  L"EfiCheckFirmwareRevision: Minimum FirmwareVersion requirement: %d\r\n",
                                  FirmwareMinimum );
                        EfiST->ConOut->OutputString(EfiST->ConOut, OutputBuffer );


#endif

                    }
                }

            }
        }



        //
        // Get the BIOS vendor and see if it's Intel.
        //
        if( (ULONG)BiosInfoHeader->Vendor > 0 ) {
 
         
            // Jump to the end of the formatted portion of the SMBIOS table.
            VendorString = (PUCHAR)BiosInfoHeader + BiosInfoHeader->Length;
                            
            
            //
            // Now jump over some number of strings to get to our string.
            //
            for( i = 0; i < ((ULONG)BiosInfoHeader->Vendor-1); i++ ) {
                while( *VendorString != 0 ) {
                    VendorString++;
                }
                VendorString++;
            }


            //
            // Remember firmware vendor.
            //
            if( VendorString ) {
                IsVendorIntel = !_strnicmp( VendorString, "INTEL", 5 );
#if DBG
                swprintf( OutputBuffer,
                          L"EfiCheckFirmwareRevision: Firmware Vendor String: %S\r\n",
                          VendorString );
                EfiST->ConOut->OutputString(EfiST->ConOut, OutputBuffer );
#endif

            }
        }

    }




    if( (FirmwareVersion) &&
        (IsVendorIntel) ) {

        if( FirmwareVersion < FirmwareMinimum ) {

            swprintf(OutputBuffer, L"Your system's firmware version is less than %d.\n\r", FirmwareMinimum);
            EfiST->ConOut->OutputString(EfiST->ConOut, OutputBuffer);
            swprintf(OutputBuffer, L"You must upgrade your system firmware in order to proceed.\n\r" );
            EfiST->ConOut->OutputString(EfiST->ConOut, OutputBuffer);

            while( 1 );
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\envvar.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    envvar.c

Abstract:

    Provides routines to access EFI environment variables.

Author:

    Chuck Lenzmeier (chuckl) 10-Dec-2000

Revision History:

--*/

#include "arccodes.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#if defined(_IA64_)
#include "bootia64.h"
#endif
#include "efi.h"
#include "efip.h"

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

#include <efiboot.h>

ARC_STATUS
BlpGetPartitionFromDevicePath (
    IN EFI_DEVICE_PATH UNALIGNED *DevicePath,
    IN PUCHAR MaximumValidAddress,
    OUT PULONG DiskNumber,
    OUT PULONG PartitionNumber,
    OUT HARDDRIVE_DEVICE_PATH UNALIGNED **HarddriveDevicePath,
    OUT FILEPATH_DEVICE_PATH UNALIGNED **FilepathDevicePath
    );

//
// Externals
//

extern VOID FlipToVirtual();
extern VOID FlipToPhysical();
extern ULONGLONG CompareGuid();

extern BOOT_CONTEXT BootContext;
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;
extern EFI_GUID EfiDevicePathProtocol;
extern EFI_GUID EfiBlockIoProtocol;

EFI_STATUS
EfiGetVariable (
    IN CHAR16 *VariableName,
    IN EFI_GUID *VendorGuid,
    OUT UINT32 *Attributes OPTIONAL,
    IN OUT UINTN *DataSize,
    OUT VOID *Data
    )
{
    EFI_STATUS status;

    FlipToPhysical();

    status = EfiST->RuntimeServices->GetVariable(
                                        VariableName,
                                        VendorGuid,
                                        Attributes,
                                        DataSize,
                                        Data
                                        );

    FlipToVirtual();
    
    return status;

} // EfiGetVariable
    
EFI_STATUS
EfiSetVariable (
    IN CHAR16 *VariableName,
    IN EFI_GUID *VendorGuid,
    IN UINT32 Attributes,
    IN UINTN DataSize,
    IN VOID *Data
    )
{
    EFI_STATUS status;

    FlipToPhysical();

    status = EfiST->RuntimeServices->SetVariable(
                                        VariableName,
                                        VendorGuid,
                                        Attributes,
                                        DataSize,
                                        Data
                                        );

    FlipToVirtual();
    
    return status;

} // EfiSetVariable
    
EFI_STATUS
EfiGetNextVariableName (
    IN OUT UINTN *VariableNameSize,
    IN OUT CHAR16 *VariableName,
    IN OUT EFI_GUID *VendorGuid
    )
{
    EFI_STATUS status;

    FlipToPhysical();

    status = EfiST->RuntimeServices->GetNextVariableName(
                                        VariableNameSize,
                                        VariableName,
                                        VendorGuid
                                        );

    FlipToVirtual();
    
    return status;

} // EfiGetNextVariableName
    
LONG
SafeStrlen (
    PUCHAR String,
    PUCHAR Max
    )
{
    PUCHAR p = String;
    while ( (p < Max) && (*p != 0) ) {
        p++;
    }

    if ( p < Max ) {
        return (LONG)(p - String);
    }

    return -1;

} // SafeStrlen

LONG
SafeWcslen (
    PWCHAR String,
    PWCHAR Max
    )
{
    PWCHAR p = String;
    while ( (p < Max) && (*p != 0) ) {
        p++;
    }

    if ( p < Max ) {
        return (LONG)(p - String);
    }

    return -1;

} // SafeWclen

ARC_STATUS
BlGetEfiBootOptions (
    OUT PUCHAR Argv0String OPTIONAL,
    OUT PUCHAR SystemPartition OPTIONAL,
    OUT PUCHAR OsLoaderFilename OPTIONAL,
    OUT PUCHAR OsLoadPartition OPTIONAL,
    OUT PUCHAR OsLoadFilename OPTIONAL,
    OUT PUCHAR FullKernelPath OPTIONAL,
    OUT PUCHAR OsLoadOptions OPTIONAL
    )
{
    EFI_STATUS status;
    ARC_STATUS arcStatus;
    EFI_GUID EfiGlobalVariable = EFI_GLOBAL_VARIABLE;
    UCHAR variable[512];
    UCHAR syspart[100];
    UCHAR loader[100];
    UCHAR loadpart[100];
    UCHAR loadname[100];
    PEFI_LOAD_OPTION efiLoadOption;
    EFI_DEVICE_PATH UNALIGNED *devicePath;
    HARDDRIVE_DEVICE_PATH UNALIGNED *harddriveDp;
    FILEPATH_DEVICE_PATH UNALIGNED *filepathDp;
    WINDOWS_OS_OPTIONS UNALIGNED *osOptions;
    UINT16 bootCurrent;
    UINTN length;
    PUCHAR max;
    PUCHAR osloadpart;
    PUCHAR osloadname;
    PUCHAR osloadoptions;
    LONG l;
    BOOLEAN end;
    WCHAR UNALIGNED *fp;
    ULONG bootDisk;
    ULONG bootPartition;
    ULONG loadDisk;
    ULONG loadPartition;
    LONG i;
    PFILE_PATH loadFilePath;
    PWCHAR wideosloadoptions;
    WCHAR currentBootEntryName[9];

    //
    // Get the ordinal of the entry that was used to boot the system.
    //
    length = sizeof(bootCurrent);
    status = EfiGetVariable( L"BootCurrent", &EfiGlobalVariable, NULL, &length, &bootCurrent );
    if ( status != EFI_SUCCESS ) {
        return ENOENT;
    }

    //
    // Read the boot entry.
    //

    swprintf( currentBootEntryName, L"Boot%04x", bootCurrent );
    length = 512;
    status = EfiGetVariable( currentBootEntryName, &EfiGlobalVariable, NULL, &length, variable );
    if ( status != EFI_SUCCESS ) {
        return ENOENT;
    }

    //
    // Verify the boot entry.
    //

    max = variable + length;

    //
    // Is it long enough even to contain the base part of the EFI load option?
    //

    if ( length < sizeof(EFI_LOAD_OPTION) ) {
        return ENOENT;
    }

    //
    // Is the description properly terminated?
    //

    efiLoadOption = (PEFI_LOAD_OPTION)variable;
    l = SafeWcslen( efiLoadOption->Description, (PWCHAR)max );
    if ( l < 0 ) {
        return ENOENT;
    }

    devicePath = (EFI_DEVICE_PATH *)((PUCHAR)efiLoadOption +
                    FIELD_OFFSET(EFI_LOAD_OPTION,Description) +
                    ((l + 1) * sizeof(CHAR16)));
    osOptions = (WINDOWS_OS_OPTIONS UNALIGNED *)((PUCHAR)devicePath + efiLoadOption->FilePathLength);

    length -= (UINTN)((PUCHAR)osOptions - variable);

    //
    // Does the OsOptions structure look like a WINDOWS_OS_OPTIONS structure?
    //

    if ( (length < FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) ||
         (length != osOptions->Length) ||
         (WINDOWS_OS_OPTIONS_VERSION != osOptions->Version) ||
         (strcmp(osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) != 0) ) {
        return ENOENT;
    }

    //
    // Is the OsLoadOptions string properly terminated?
    //

    wideosloadoptions = (PWCHAR)osOptions->OsLoadOptions;
    l = SafeWcslen( wideosloadoptions, (PWCHAR)max );
    if ( l < 0 ) {
        return ENOENT;
    }

    //
    // Convert the OsLoadOptions string to ANSI.
    //

    osloadoptions = (PUCHAR)wideosloadoptions;
    for ( i = 1; i <= l; i++ ) {
        osloadoptions[i] = (UCHAR)wideosloadoptions[i];
    }
    
    //
    // Parse the device path to determine the OS load partition and directory.
    // Convert the directory name to ANSI.
    //

    loadFilePath = ADD_OFFSET( osOptions, OsLoadPathOffset );

#if 0
    //
    // turn this on to see the device path to the loader executable and device
    // path to the operating system
    //
    BlPrint(TEXT("Device Path = %s\r\n"), DevicePathToStr( devicePath ));
    BlPrint(TEXT("Embedded Device Path to OS = %s\r\n"), DevicePathToStr( (EFI_DEVICE_PATH UNALIGNED *)loadFilePath->FilePath ));
    DBG_EFI_PAUSE();
#endif
    arcStatus = BlpGetPartitionFromDevicePath(
                    (EFI_DEVICE_PATH UNALIGNED *)loadFilePath->FilePath,
                    max,
                    &loadDisk,
                    &loadPartition,
                    &harddriveDp,
                    &filepathDp
                    );
    if (arcStatus != ESUCCESS) {
        return arcStatus;
    }
    sprintf( loadpart,
             "multi(0)disk(0)rdisk(%d)partition(%d)",
             loadDisk,
             loadPartition );
    fp = filepathDp->PathName;
    l = 0;
    while ( (l < (99 - 9 - strlen(loadpart))) &&
            ((PUCHAR)fp < max) &&
            (*fp != 0) ) {
        loadname[l++] = (UCHAR)*fp++;
    }
    loadname[l] = 0;

    //
    // Translate loader device path to partition/path.
    //

    arcStatus = BlpGetPartitionFromDevicePath(
                    devicePath,
                    max,
                    &bootDisk,
                    &bootPartition,
                    &harddriveDp,
                    &filepathDp
                    );
    if (arcStatus != ESUCCESS) {
        return arcStatus;
    }

    //
    // Form the ARC name for the partition.
    //

    sprintf( syspart,
             "multi(0)disk(0)rdisk(%d)partition(%d)",
             bootDisk,
             bootPartition );

    //
    // Extract the path to the loader.
    //

    fp = filepathDp->PathName;
    l = 0;

    while ( (l < (99 - 9 - strlen(syspart))) &&
            ((PUCHAR)fp < max) &&
            (*fp != 0) ) {
        loader[l++] = (UCHAR)*fp++;
    }
    loader[l] = 0;

    //
    // Create the strings that the loader needs.
    //

    if ( Argv0String != NULL ) {
        sprintf( Argv0String, "%s%s", syspart, loader );
    }
    if ( OsLoaderFilename != NULL ) {
        sprintf( OsLoaderFilename, "OSLOADER=%s%s", syspart, loader );
    }
    if ( SystemPartition != NULL ) {
        sprintf( SystemPartition, "SYSTEMPARTITION=%s", syspart );
    }
    if ( OsLoadOptions != NULL ) {
        sprintf( OsLoadOptions, "OSLOADOPTIONS=%s", osloadoptions );
    }
    if ( OsLoadFilename != NULL ) {
        sprintf( OsLoadFilename, "OSLOADFILENAME=%s", loadname );
    }
    if ( FullKernelPath != NULL ) {
        sprintf( FullKernelPath, "%s%s", loadpart, loadname );
    }
    if ( OsLoadPartition != NULL ) {
        sprintf( OsLoadPartition, "OSLOADPARTITION=%s", loadpart );
    }

    return ESUCCESS;

} // BlGetEfiBootOptions

ARC_STATUS
BlpGetPartitionFromDevicePath (
    IN EFI_DEVICE_PATH UNALIGNED *DevicePath,
    IN PUCHAR MaximumValidAddress,
    OUT PULONG DiskNumber,
    OUT PULONG PartitionNumber,
    OUT HARDDRIVE_DEVICE_PATH UNALIGNED **HarddriveDevicePath,
    OUT FILEPATH_DEVICE_PATH UNALIGNED **FilepathDevicePath
    )
{
    ARC_STATUS status;
    EFI_DEVICE_PATH UNALIGNED *devicePath;
    HARDDRIVE_DEVICE_PATH UNALIGNED *harddriveDp;
    FILEPATH_DEVICE_PATH UNALIGNED *filepathDp;
    LOGICAL end;
    ULONG disk;
    ULONG partition;

    //
    // Find the MEDIA/HARDDRIVE and MEDIA/FILEPATH elements in the device path.
    //

    devicePath = DevicePath;
    harddriveDp = NULL;
    filepathDp = NULL;
    end = FALSE;

    while ( ((PUCHAR)devicePath < MaximumValidAddress) &&
            !end &&
            ((harddriveDp == NULL) || (filepathDp == NULL)) ) {

        switch( devicePath->Type ) {
        
        case END_DEVICE_PATH_TYPE:
            end = TRUE;
            break;

        case MEDIA_DEVICE_PATH:
            switch ( devicePath->SubType ) {
            
            case MEDIA_HARDDRIVE_DP:
                harddriveDp = (HARDDRIVE_DEVICE_PATH UNALIGNED *)devicePath;
                break;

            case MEDIA_FILEPATH_DP:
                filepathDp = (FILEPATH_DEVICE_PATH UNALIGNED *)devicePath;
                break;

            default:
                break;
            }

        default:
            break;
        }

        devicePath = (EFI_DEVICE_PATH UNALIGNED *)NextDevicePathNode( devicePath );
    }

    //
    // If the two necessary elements weren't found, we can't continue.
    //

    if ( (harddriveDp == NULL) || (filepathDp == NULL) ) {
        return ENOENT;
    }

    //
    // Determine the disk number of the disk by opening the given partition
    // number on each disk and checking the partition signature.
    //

    partition = harddriveDp->PartitionNumber;

    disk = 0;
    while ( TRUE ) {
        EFI_PARTITION_ENTRY UNALIGNED *partEntry;
        status = BlGetGPTDiskPartitionEntry( disk, (UCHAR)partition, &partEntry );
        if ( status == EINVAL ) {
            return ENOENT;
        }
        if ( status == ESUCCESS ) {
            if ( memcmp(partEntry->Id, harddriveDp->Signature, 16) == 0 ) {
                break;
            }
        }
        disk++;
    }

    //
    // Return information about this disk, and about the device path.
    //

    *DiskNumber = disk;
    *PartitionNumber = partition;
    *HarddriveDevicePath = harddriveDp;
    *FilepathDevicePath = filepathDp;

    return ESUCCESS;

} // BlpGetPartitionFromDevicePath
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\input.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    input.c

Author:

    Ken Reneris Oct-2-1997

Abstract:

--*/

#if defined (_IA64_)
#include "bootia64.h"
#endif

#if defined (_X86_)
#include "bldrx86.h"
#endif

#include "displayp.h"
#include "stdio.h"

#include "efi.h"
#include "efip.h"
#include "flop.h"

#include "bootefi.h"

//
// Externals
//
extern BOOT_CONTEXT BootContext;
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;
extern EFI_GUID EfiDevicePathProtocol;
extern EFI_GUID EfiBlockIoProtocol;

//
// Takes any pending input and converts it into a KEY value.  Non-blocking, returning 0 if no input available.
//
ULONG
BlGetKey()
{
    ULONG Key = 0;
    UCHAR Ch;
    ULONG Count;

    if (ArcGetReadStatus(BlConsoleInDeviceId) == ESUCCESS) {

        ArcRead(BlConsoleInDeviceId, &Ch, sizeof(Ch), &Count);

        if (Ch == ASCI_CSI_IN) {

            if (ArcGetReadStatus(BlConsoleInDeviceId) == ESUCCESS) {

                ArcRead(BlConsoleInDeviceId, &Ch, sizeof(Ch), &Count);

                //
                // All the function keys start with ESC-O
                //
                switch (Ch) {
                case 'O':

                    ArcRead(BlConsoleInDeviceId, &Ch, sizeof(Ch), &Count);  // will not or block, as the buffer is already filled

                    switch (Ch) {
                    case 'P': 
                        Key = F1_KEY;
                        break;

                    case 'Q': 
                        Key = F2_KEY;
                        break;

                    case 'w': 
                        Key = F3_KEY;
                        break;

                    case 't': 
                        Key = F5_KEY;
                        break;

                    case 'u': 
                        Key = F6_KEY;
                        break;

                    case 'r': 
                        Key = F8_KEY;
                        break;

                    case 'M':
                        Key = F10_KEY;
                        break;
                    }
                    break;

                case 'A':
                    Key = UP_ARROW;
                    break;

                case 'B':
                    Key = DOWN_ARROW;
                    break;

                case 'C':
                    Key = RIGHT_KEY;
                    break;

                case 'D':
                    Key = LEFT_KEY;
                    break;

                case 'H':
                    Key = HOME_KEY;
                    break;

                case 'K':
                    Key = END_KEY;
                    break;

                case '@':
                    Key = INS_KEY;
                    break;

                case 'P':
                    Key = DEL_KEY;
                    break;

                case TAB_KEY:
                    Key = BACKTAB_KEY;
                    break;

                }

            } else { // Single escape key, as no input is waiting.

                Key = ESCAPE_KEY;

            }

        } else if (Ch == 0x8) {

            Key = BKSP_KEY;

        } else {

            Key = (ULONG)Ch;

        }

    }

    return Key;
}


VOID
BlInputString(
    IN ULONG    Prompt,
    IN ULONG    CursorX,
    IN ULONG    PosY,
    IN PUCHAR   String,
    IN ULONG    MaxLength
    )
{
    PTCHAR      PromptString;
    ULONG       TextX, TextY;
    ULONG       Length, Index;
    _TUCHAR     CursorChar[2];
    ULONG       Key;
    _PTUCHAR    p;
    ULONG       i;
    ULONG       Count;
    _PTUCHAR    pString;
#ifdef UNICODE
    WCHAR       StringW[200];
    UNICODE_STRING uString;
    ANSI_STRING aString;
    pString = StringW;
    uString.Buffer = StringW;
    uString.MaximumLength = sizeof(StringW);
    RtlInitAnsiString(&aString, String );
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
#else
    pString = String;
#endif    


    PromptString = BlFindMessage(Prompt);
    Length = strlen(String);
    CursorChar[1] = TEXT('\0');

    //
    // Print prompt
    //

    BlEfiPositionCursor( PosY, CursorX );
    BlEfiEnableCursor( TRUE );
    ArcWrite(BlConsoleOutDeviceId, PromptString, _tcslen(PromptString)*sizeof(TCHAR), &Count);

    //
    // Indent cursor to right of prompt
    //

    CursorX += _tcslen(PromptString);
    TextX = CursorX;
    Key = 0;

    for (; ;) {

        TextY = TextX + Length;
        if (CursorX > TextY) {
            CursorX = TextY;
        }
        if (CursorX < TextX) {
            CursorX = TextX;
        }

        Index = CursorX - TextX;
        pString[Length] = 0;

        //
        // Display current string
        //

        BlEfiPositionCursor( TextY, TextX );
        ArcWrite(
            BlConsoleOutDeviceId, 
            pString, 
            _tcslen(pString)*sizeof(TCHAR), 
            &Count);
        ArcWrite(BlConsoleOutDeviceId, TEXT("  "), sizeof(TEXT("  ")), &Count);
        if (Key == 0x0d) {      // enter key?
            break ;
        }

        //
        // Display cursor
        //
        BlEfiPositionCursor( PosY, CursorX );
        BlEfiSetInverseMode( TRUE );
        CursorChar[0] = pString[Index] ? pString[Index] : TEXT(' ');
        ArcWrite(BlConsoleOutDeviceId, CursorChar, sizeof(_TUCHAR), &Count);
        BlEfiSetInverseMode( FALSE );
        BlEfiPositionCursor( PosY, CursorX );
        BlEfiEnableCursor(TRUE);
        
        //
        // Get key and process it
        //

        while (!(Key = BlGetKey())) ;

        switch (Key) {
            case HOME_KEY:
                CursorX = TextX;
                break;

            case END_KEY:
                CursorX = TextY;
                break;

            case LEFT_KEY:
                CursorX -= 1;
                break;

            case RIGHT_KEY:
                CursorX += 1;
                break;

            case BKSP_KEY:
                if (!Index) {
                    break;
                }

                CursorX -= 1;
                pString[Index-1] = CursorChar[0];
                // fallthough to DEL_KEY
            case DEL_KEY:
                if (Length) {
                    p = pString+Index;
                    i = Length-Index+1;
                    while (i) {
                        p[0] = p[1];
                        p += 1;
                        i -= 1;
                    }
                    Length -= 1;
                }
                break;

            case INS_KEY:
                if (Length < MaxLength) {
                    p = pString+Length;
                    i = Length-Index+1;
                    while (i) {
                        p[1] = p[0];
                        p -= 1;
                        i -= 1;
                    }
                    pString[Index] = TEXT(' ');
                    Length += 1;
                }
                break;

            default:
                Key = Key & 0xff;

                if (Key >= ' '  &&  Key <= 'z') {
                    if (CursorX == TextY  &&  Length < MaxLength) {
                        Length += 1;
                    }

                    pString[Index] = (_TUCHAR)Key;
                    pString[MaxLength] = 0;
                    CursorX += 1;
                }
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\exp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1998  Intel Corporation


Module Name:

    exp.c

Abstract:

	This file contains low level I/O functions that are implemented
        with BIOS calls.

Author:

    Allen Kay	(akay)	04-Aug-97

--*/

#include "bldr.h"
#include "sudata.h"
#if defined(_IA64_)
#include "bootia64.h"
#include "bldria64.h"
#endif
#include "efi.h"
#include "extern.h"


ARC_STATUS
RebootProcessor(
    )
{
#if DBG
    BlPrint(TEXT("About to call EfiRS->ResetSystem()"));
#endif

    FlipToPhysical();

    return( (ARC_STATUS) EfiRS->ResetSystem(EfiResetCold, 0, 0, NULL) );
}

ARC_STATUS
GetSector(
    ULONG Operation,
    ULONG Drive,
    ULONG Head,
    ULONG Cylinder,
    ULONG Sector,
    ULONG SectorCount,
    ULONG Buffer
    )
{
    //
    // NOTE!: Need to remove this function
    //
    return (0);
}

ARC_STATUS
GetEddsSector(
    EFI_HANDLE Handle,
    ULONG SectorNumberLow,
    ULONG SectorNumberHigh,
    ULONG SectorCount,
    PUCHAR Buffer,
    UCHAR  Write
    )
{
    EFI_BLOCK_IO *BlkDev;
    EFI_STATUS Status;
    ULONGLONG Lba;

    //
    // First go into physical mode since EFI calls can only be made in
    // physical mode.
    //
    FlipToPhysical();

    //
    // convert virtual address to physical if it is virtual.
    //

    if (((ULONGLONG)Buffer & KSEG0_BASE) == KSEG0_BASE) {
        Buffer = (PUCHAR) ((ULONGLONG)Buffer & ~KSEG0_BASE);
    }

    Lba = (SectorNumberHigh << 32) | SectorNumberLow;

    Status = EfiBS->HandleProtocol( Handle,
                                    &EfiBlockIoProtocol,
                                    &BlkDev);
    if (EFI_ERROR(Status)) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                     L"GetEddSector: HandleProtocol failed\n\r");
        return (EIO);
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }


    if (Write == 0x43) {
        Status = BlkDev->WriteBlocks( BlkDev,
                                      BlkDev->Media->MediaId,
                                      Lba,
                                      SectorCount * BlkDev->Media->BlockSize,
                                      Buffer);
    } else {
        Status = BlkDev->ReadBlocks( BlkDev,
                                     BlkDev->Media->MediaId,
                                     Lba,
                                     SectorCount * BlkDev->Media->BlockSize,
                                     Buffer);
    }


    if (EFI_ERROR(Status) && BlkDev->Media->RemovableMedia) {
            //
            // Restore virtual mode before returning.
            //
            FlipToVirtual();
            //
            // NOTE!: A more appropriate error status equivalent to "No Media Present"
            // needs to be returned
            //
            return (ENODEV);
    }
    else
    if (EFI_ERROR(Status)) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                     L"\nGetEddsSector: Error Reading Media!\r\n");
        return (EIO);
        //EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // Restore virtual mode before returning.
    //
    FlipToVirtual();

    return(ESUCCESS);
}

ULONG
GetKey(
    )
{
    SIMPLE_INPUT_INTERFACE      *Input;
    EFI_INPUT_KEY               Key;
    EFI_STATUS                  Status;
    ULONG                       Code;

    //
    // First go into physical mode since EFI calls can only be made in
    // physical mode.
    //
    FlipToPhysical();

    // BiVerifyCursorPosition();
    Input = EfiST->ConIn;

    Status = Input->ReadKeyStroke(Input, &Key);
    if (EFI_ERROR(Status)) {
        FlipToVirtual();
        return 0;
    }

    if (Key.UnicodeChar) {
        // truncate unicode char to ascii
        if (Key.UnicodeChar > 0xFF) {
            FlipToVirtual();
            return 0;
        }

        // Convert back spaces
        if (Key.UnicodeChar == 0x08) {
            Key.UnicodeChar = 0x0E08;
        }

        FlipToVirtual();
        return Key.UnicodeChar;
    }

    //
    // Convert EFI keys to dos key codes
    //

    Code = 0;
    switch (Key.ScanCode) {
#if 0
        case SCAN_UP:        Code = 0x4800;  break;
        case SCAN_DOWN:      Code = 0x5000;  break;
        case SCAN_RIGHT:     Code = 0x4d00;  break;
        case SCAN_LEFT:      Code = 0x4b00;  break;
        case SCAN_HOME:      Code = 0x4700;  break;
        case SCAN_INSERT:    Code = 0x5200;  break;
        case SCAN_DELETE:    Code = 0x5300;  break;
        case SCAN_PAGE_UP:   Code = 0x4900;  break;
        case SCAN_PAGE_DOWN: Code = 0x5100;  break;
        case SCAN_F1:        Code = 0x3b00;  break;
        case SCAN_F2:        Code = 0x3c00;  break;
        case SCAN_F3:        Code = 0x3d00;  break;
        case SCAN_F4:        Code = 0x3e00;  break;
        case SCAN_F5:        Code = 0x3f00;  break;
        case SCAN_F6:        Code = 0x4000;  break;
        case SCAN_F7:        Code = 0x4100;  break;
        case SCAN_F8:        Code = 0x4200;  break;
        case SCAN_F9:        Code = 0x4300;  break;
        case SCAN_F10:       Code = 0x4400;  break;
        case SCAN_ESC:       Code = 0x001d;  break;
#else
        case SCAN_UP:        Code = UP_ARROW;    break;
        case SCAN_DOWN:      Code = DOWN_ARROW;  break;
        case SCAN_RIGHT:     Code = RIGHT_KEY;   break;
        case SCAN_LEFT:      Code = LEFT_KEY;    break;
        case SCAN_HOME:      Code = HOME_KEY;    break;
        case SCAN_INSERT:    Code = INS_KEY;     break;
        case SCAN_DELETE:    Code = DEL_KEY;     break;
        // bugbug
        case SCAN_PAGE_UP:   Code = 0x4900;  break;
        // bugbug    
        case SCAN_PAGE_DOWN: Code = 0x5100;  break;
        case SCAN_F1:        Code = F1_KEY;      break;
        case SCAN_F2:        Code = F2_KEY;      break;
        case SCAN_F3:        Code = F3_KEY;      break;
        // bugbug
        case SCAN_F4:        Code = 0x3e00;      break;
        case SCAN_F5:        Code = F5_KEY;      break;
        case SCAN_F6:        Code = F6_KEY;      break;
        case SCAN_F7:        Code = F7_KEY;      break;
        case SCAN_F8:        Code = F8_KEY;      break;
        // bugbug
        case SCAN_F9:        Code = 0x4300;  break;
        case SCAN_F10:       Code = F10_KEY;     break;
        //bugbug different than 0x001d
        case SCAN_ESC:       Code = ESCAPE_KEY;  break;
#endif
    }

    //
    // Restore virtual mode before returning.
    //
    FlipToVirtual();

    return Code;
}

ULONG Counter = 0;

ULONG
GetCounter(
    )
{
    EFI_TIME        Time;
    UINTN           ms;
    static UINTN    BaseTick, LastMs;

    //
    // First go into physical mode since EFI calls can only be made in
    // physical mode.
    //
    FlipToPhysical();

    // NB. the NT loader only uses this to count seconds
    // this function only works if called at least every hour

    //
    // Get the current calendar time
    //

    EfiRS->GetTime (&Time, NULL);

    // Compute a millisecond value for the time
    ms = Time.Minute * 60 * 1000 + Time.Second * 1000 + Time.Nanosecond / 1000000;
    if (ms < LastMs) {
        BaseTick += 65520;          // 60 * 60 * 18.2
    }

    LastMs = ms;

    //
    // Restore virtual mode before returning.
    //
    FlipToVirtual();

    return (ULONG) (( (ms * 182) / 10000) + BaseTick);
}

//
// Transfer control to a loaded boot sector
//
VOID
Reboot(
    ULONG BootType
    )
{
    //
    // First go into physical mode since EFI calls can only be made in
    // physical mode.
    //
    FlipToPhysical();

    EfiBS->Exit(EfiImageHandle, 0, 0, 0);
}

VOID
HardwareCursor(
    ULONG YCoord,
    ULONG XCoord
    )
{
    //
    // NOTE!: Need to be implemented
    //
}

VOID
GetDateTime(
    PULONG Date,
    PULONG Time
    )
{
    //
    // NOTE!: Need to implement
    //
}

VOID
DetectHardware(
    ULONG HeapStart,
    ULONG HeapSize,
    ULONG ConfigurationTree,
    ULONG HeapUsed,
    ULONG OptionString,
    ULONG OptionStringLength
    )
{
    //
    // NOTE!: needed to remove
    //
}

VOID
ComPort(
    LONG Port,
    ULONG Function,
    UCHAR Arg
    )
{
    //
    // NOTE!: needed to remove
    //
}

ULONG
GetStallCount(
    )
{
#if defined(VPC_PHASE2)
    ULONGLONG Frequency;

    //
    // First go into physical mode since EFI calls can only be made in
    // physical mode.
    //
    FlipToPhysical();

    IA32RegisterState.esp = SAL_PROC_SP;
    IA32RegisterState.ss = SAL_PROC_SS;
    IA32RegisterState.eflags = SAL_PROC_EFLAGS;

    SAL_PROC(SAL_FREQ_BASE,0,0,0,0,0,0,0,RetVals);
    Frequency = RetVals->RetVal1;

    //
    // Restore virtual mode before returning.
    //
    FlipToVirtual();

    return ((ULONG) Frequency / 1000);     // Convert ticks/sec to ticks/usec
#else
    return ((ULONG) 1000000);     // Convert ticks/sec to ticks/usec
#endif
}

VOID
InitializeDisplayForNt(
    )
{
    //
    // NOTE!: Need to implement
    //
}

VOID
GetMemoryDescriptor(
    )
{
    //
    // NOTE!: need to remove
    //
}

BOOLEAN
GetElToritoStatus(
    PUCHAR Buffer,
    UCHAR DriveNum
    )
{
    //
    // NOTE!: need to remove
    //
    return(0);
}

BOOLEAN
GetExtendedInt13Params(
    PUCHAR Buffer,
    UCHAR Drive
    )
{
    return(1);
}

USHORT
NetPcRomServices(
    ULONG FunctionNumber,
    PVOID CommandPacket
    )
{
    return (USHORT)0;
}


ULONG
GetRedirectionData(
   ULONG Command
   )
/* ++

 Routine Name:

       BiosRedirectService

 Description:

       Get parameters of bios redirection.

 Arguments:

       Command - 1: Get Com Port Number
                 2: Get Baud Rate
                 3: Get Parity
                 4: Get Stop Bits

 Returns:

       Value, or -1 if an error.

--
*/
{
    //
    // should never call this from EFI app.
    //
    ASSERT(FALSE);
    return(-1);
}

VOID
APMAttemptReconect(
    VOID
    )
{
    //
    // should never call this from EFI app.
    //
    ASSERT(FALSE);
    return;
}


VOID
SuFillExportTable(
    )
{
    ExportEntryTable[ExRebootProcessor]        = (PVOID) &RebootProcessor;
    ExportEntryTable[ExGetSector]              = (PVOID) &GetSector;
    ExportEntryTable[ExGetKey]                 = (PVOID) &GetKey;
    ExportEntryTable[ExGetCounter]             = (PVOID) &GetCounter;
    ExportEntryTable[ExReboot]                 = (PVOID) &Reboot;
    ExportEntryTable[ExDetectHardware]         = (PVOID) &DetectHardware;
    ExportEntryTable[ExHardwareCursor]         = (PVOID) &HardwareCursor;
    ExportEntryTable[ExGetDateTime]            = (PVOID) &GetDateTime;
    ExportEntryTable[ExComPort]                = (PVOID) &ComPort;
    ExportEntryTable[ExGetStallCount]          = (PVOID) &GetStallCount;
    ExportEntryTable[ExInitializeDisplayForNt] = (PVOID) &InitializeDisplayForNt;
    ExportEntryTable[ExGetMemoryDescriptor]    = (PVOID) &GetMemoryDescriptor;
    ExportEntryTable[ExGetEddsSector]          = (PVOID) &GetEddsSector;
    ExportEntryTable[ExGetElToritoStatus]      = (PVOID) &GetElToritoStatus;
    ExportEntryTable[ExGetExtendedInt13Params] = (PVOID) &GetExtendedInt13Params;
    ExportEntryTable[ExNetPcRomServices]       = (PVOID) &NetPcRomServices;
    ExportEntryTable[ExAPMAttemptReconnect]    = (PVOID) &APMAttemptReconect;
    ExportEntryTable[ExBiosRedirectService]    = (PVOID) &GetRedirectionData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\netboot2.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    net.c

Abstract:

    This module implements the net boot file system used by the operating
    system loader.

    It only contains those functions which are firmware/BIOS dependent.

Author:

Revision History:

--*/

#include "..\bootlib.h"
#include "stdio.h"

#ifdef UINT16
#undef UINT16
#endif

#ifdef INT16
#undef INT16
#endif

#include <dhcp.h>
#include <netfs.h>
#include <pxe_cmn.h>

#include <pxe_api.h>

#include <udp_api.h>
#include <tftp_api.h>
#include "bldr.h"
#include "bootia64.h"
#include "efi.h"
#include "efip.h"
#include "bldria64.h"
#include "extern.h"
#include "smbios.h"

#ifndef BOOL
typedef int BOOL;
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE  1
#endif

#ifndef BYTE
typedef unsigned char BYTE;
#endif

#ifndef LPBYTE
typedef BYTE *LPBYTE;
#endif

#define MAX_PATH          260


//
// Define global data.
//

CHAR NetBootPath[129];

EFI_PXE_BASE_CODE              *PXEClient;
EFI_HANDLE                      PXEHandle;
ULONG                           NetLocalIpAddress;
ULONG                           NetLocalSubnetMask;

ULONG                           NetServerIpAddress;
ULONG                           NetGatewayIpAddress;
UCHAR                           NetLocalHardwareAddress[16];

UCHAR MyGuid[16];
ULONG MyGuidLength = sizeof(MyGuid);
BOOLEAN MyGuidValid = FALSE;


TFTP_RESTART_BLOCK              gTFTPRestartBlock;


VOID
EfiDumpBuffer(
    PVOID Buffer,
    ULONG BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    ULONG i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    PUCHAR BufferPtr = Buffer;


    BlPrint(TEXT("------------------------------------\r\n"));

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            BlPrint(TEXT("%x "), (UCHAR)BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            BlPrint(TEXT("  "));
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            BlPrint(TEXT("  %s\r\n"), TextBuffer);            
        }

    }

    BlPrint(TEXT("------------------------------------\r\n"));


#if 0
    //
    // enable this to make it pause after dumping the buffer.
    //
    DBG_EFI_PAUSE();
#endif
}


ARC_STATUS
GetParametersFromRom (
    VOID
    )
{
    UINTN           BufferSize = sizeof(EFI_HANDLE);
    INTN            Count = 0;
    EFI_GUID        PXEGuid = EFI_PXE_BASE_CODE_PROTOCOL;
    UINT16          layer = 0;
    EFI_STATUS      Status = EFI_UNSUPPORTED;
    PUCHAR          p;

    //
    // Get a pointer to all the PXE APIs.
    //
    FlipToPhysical();
    Status = EfiST->BootServices->LocateHandle( ByProtocol,
                                                &PXEGuid,
                                                NULL,
                                                &BufferSize,
                                                &PXEHandle );
    FlipToVirtual();
    if( Status != EFI_SUCCESS ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "GetParametersFromRom: LocateHandle failed (%d)\n", Status);
        }
        return (ARC_STATUS)Status;
    }


    FlipToPhysical();
    Status = EfiST->BootServices->HandleProtocol( PXEHandle,
                                                  &PXEGuid,
                                                  &PXEClient );
    FlipToVirtual();

    if( Status != EFI_SUCCESS ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "GetParametersFromRom: HandleProtocol failed (%d)\n", Status);
        }
        return (ARC_STATUS)Status;
    }


    //
    // Our IP address is down in:
    // PXEClient->Mode->StationIp.v4
    //
    // The server's IP address is down in:
    // PXEClient->Mode->ProxyOffer.Dhcpv4.BootpSiAddr
    //
    // Our NIC's GUID should be down in:
    // PXEClient->Mode->ProxyOffer.Dhcpv4.BootpHwAddr
    //
    NetServerIpAddress = 0;
    NetLocalIpAddress = 0;
    for( Count = 0; Count < 4; Count++ ) {
        NetServerIpAddress = (NetServerIpAddress << 8) + PXEClient->Mode->ProxyOffer.Dhcpv4.BootpSiAddr[Count];
        NetLocalIpAddress = (NetLocalIpAddress << 8) + PXEClient->Mode->StationIp.v4.Addr[Count];
    }


    memcpy( NetLocalHardwareAddress, PXEClient->Mode->ProxyOffer.Dhcpv4.BootpHwAddr, sizeof(NetLocalHardwareAddress) );

    //
    // Get the path where we were launched from.  We what to remove the
    // actual file name (oschoice.efi in this case), but leave that trailing
    // '\'.
    //
    strcpy( NetBootPath, PXEClient->Mode->ProxyOffer.Dhcpv4.BootpBootFile );
    p = strrchr( NetBootPath, '\\' );
    if( p ) {
        p++;
        *p = '\0';
    }

    return ESUCCESS;

}

VOID
EfiNetTerminate(
    VOID
    )
{
    FlipToPhysical();

    PXEClient->Stop( PXEClient );

    FlipToVirtual();
}


VOID
GetGuid(
    OUT PUCHAR *Guid,
    OUT PULONG GuidLength
    )

/*++

Routine Description:

    This routine returns the Guid of this machine.

Arguments:

    Guid - Place to store pointer to the guid.

    GuidLength - Place to store the length in bytes of the guid.

Return Value:

    None.

--*/

{
PSMBIOS_SYSTEM_INFORMATION_STRUCT SystemInfoHeader = NULL;

    *Guid = NULL;
    *GuidLength = 0;

    SystemInfoHeader = (PSMBIOS_SYSTEM_INFORMATION_STRUCT)FindSMBIOSTable( SMBIOS_SYSTEM_INFORMATION );

    if( SystemInfoHeader ) {

        if(BdDebuggerEnabled) { DbgPrint( "GetGuid: Failed Alloc.\r\n" ); }
        *Guid = (PUCHAR)BlAllocateHeap( SYSID_UUID_DATA_SIZE );
        if( *Guid ) {
            *GuidLength = SYSID_UUID_DATA_SIZE;
            
            RtlCopyMemory( *Guid,
                           SystemInfoHeader->Uuid,
                           SYSID_UUID_DATA_SIZE );

        } else {
            if(BdDebuggerEnabled) { DbgPrint( "GetGuid: Failed Alloc.\r\n" ); }
            *GuidLength = 0;
        }

    } else {
     
        if(BdDebuggerEnabled) { DbgPrint( "GetGuid: Failed to find a SMBIOS_SYSTEM_INFORMATION table.\n" ); }
    }
}


ULONG
CalculateChecksum(
    IN PLONG Block,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine calculates a simple two's-complement checksum of a block of
    memory. If the returned value is stored in the block (in a word that was
    zero during the calculation), then new checksum of the block will be zero.

Arguments:

    Block - Address of a block of data. Must be 4-byte aligned.

    Length - Length of the block. Must be a multiple of 4.

Return Value:

    ULONG - Two's complement additive checksum of the input block.

--*/

{
    LONG checksum = 0;

    ASSERT( ((ULONG_PTR)Block & 3) == 0 );
    ASSERT( (Length & 3) == 0 );

    for ( ; Length != 0; Length -= 4 ) {
        checksum += *Block;
        Block++;
    }

    return -checksum;
}


















UINTN
DevicePathSize (
    IN EFI_DEVICE_PATH  *DevPath
    )
{
    EFI_DEVICE_PATH     *Start;

    /* 
     *  Search for the end of the device path structure
     *      */

    Start = DevPath;
    while (!IsDevicePathEnd(DevPath)) {
        DevPath = NextDevicePathNode(DevPath);
    }

    /* 
     *  Compute the size
     */

    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
}

EFI_DEVICE_PATH *
DevicePathInstance (
    IN OUT EFI_DEVICE_PATH  **DevicePath,
    OUT UINTN               *Size
    )
{
    EFI_DEVICE_PATH         *Start, *Next, *DevPath;
    UINTN                   Count;

    DevPath = *DevicePath;
    Start = DevPath;

    if (!DevPath) {
        return NULL;
    }

    /* 
     *  Check for end of device path type
     *      */

    for (Count = 0; ; Count++) {
        Next = NextDevicePathNode(DevPath);

        if (IsDevicePathEndType(DevPath)) {
            break;
        }

        if (Count > 01000) {
            break;
        }

        DevPath = Next;
    }

    ASSERT (DevicePathSubType(DevPath) == END_ENTIRE_DEVICE_PATH_SUBTYPE ||
            DevicePathSubType(DevPath) == END_INSTANCE_DEVICE_PATH_SUBTYPE);

    /* 
     *  Set next position
     */

    if (DevicePathSubType(DevPath) == END_ENTIRE_DEVICE_PATH_SUBTYPE) {
        Next = NULL;
    }

    *DevicePath = Next;

    /* 
     *  Return size and start of device path instance
     */

    *Size = ((UINT8 *) DevPath) - ((UINT8 *) Start);
    return Start;
}

UINTN
DevicePathInstanceCount (
    IN EFI_DEVICE_PATH      *DevicePath
    )
{
    UINTN       Count, Size;

    Count = 0;
    while (DevicePathInstance(&DevicePath, &Size)) {
        Count += 1;
    }

    return Count;
}

EFI_DEVICE_PATH *
AppendDevicePath (
    IN EFI_DEVICE_PATH  *Src1,
    IN EFI_DEVICE_PATH  *Src2
    )
/*  Src1 may have multiple "instances" and each instance is appended
 *  Src2 is appended to each instance is Src1.  (E.g., it's possible
 *  to append a new instance to the complete device path by passing 
 *  it in Src2) */
{
    UINTN               Src1Size, Src1Inst, Src2Size, Size;
    EFI_DEVICE_PATH     *Dst, *Inst;
    UINT8               *DstPos;
    EFI_DEVICE_PATH     EndInstanceDevicePath[] = { END_DEVICE_PATH_TYPE,
                                                    END_INSTANCE_DEVICE_PATH_SUBTYPE,
                                                    END_DEVICE_PATH_LENGTH,
                                                    0 };

    EFI_DEVICE_PATH     EndDevicePath[] = { END_DEVICE_PATH_TYPE,
                                            END_ENTIRE_DEVICE_PATH_SUBTYPE,
                                            END_DEVICE_PATH_LENGTH,
                                            0 };

    Src1Size = DevicePathSize(Src1);
    Src1Inst = DevicePathInstanceCount(Src1);
    Src2Size = DevicePathSize(Src2);
    Size = Src1Size * Src1Inst + Src2Size;
    
    EfiST->BootServices->AllocatePool( EfiLoaderData,
                                       Size,
                                       (VOID **) &Dst );

    if (Dst) {
        DstPos = (UINT8 *) Dst;

        /* 
         *  Copy all device path instances
         */

        while (Inst = DevicePathInstance (&Src1, &Size)) {

            RtlCopyMemory(DstPos, Inst, Size);
            DstPos += Size;

            RtlCopyMemory(DstPos, Src2, Src2Size);
            DstPos += Src2Size;

            RtlCopyMemory(DstPos, EndInstanceDevicePath, sizeof(EFI_DEVICE_PATH));
            DstPos += sizeof(EFI_DEVICE_PATH);
        }

        /*  Change last end marker */
        DstPos -= sizeof(EFI_DEVICE_PATH);
        RtlCopyMemory(DstPos, EndDevicePath, sizeof(EFI_DEVICE_PATH));
    }

    return Dst;
}

NTSTATUS
NetSoftReboot(
    IN PUCHAR NextBootFile,
    IN ULONGLONG Param,
    IN PUCHAR RebootFile OPTIONAL,
    IN PUCHAR SifFile OPTIONAL,
    IN PUCHAR User OPTIONAL,
    IN PUCHAR Domain OPTIONAL,
    IN PUCHAR Password OPTIONAL,
    IN PUCHAR AdministratorPassword OPTIONAL
    )

/*++

Routine Description:

    This routine will load the specified file, build a parameter
    list and transfer control to the loaded file.

Arguments:

    NextBootFile - Fully qualified path name of the file to download.

    Param - Reboot parameter to set.

    RebootFile - String identifying the file to reboot to when after the current reboot is done.

    SifFile - Optional SIF file to pass to the next loader.

    User/Domain/Password/AdministratorPassword - Optional credentials to pass to the next loader.

Return Value:

    Should not return if successful.

--*/

{

    NTSTATUS                Status = STATUS_SUCCESS;
    EFI_DEVICE_PATH         *ldrDevicePath = NULL, *Eop = NULL;
    EFI_HANDLE              ImageHandle = NULL;
    UINTN                   i = 0;
    EFI_STATUS              EfiStatus = EFI_SUCCESS;
    WCHAR                   WideNextBootFile[MAX_PATH];
    FILEPATH_DEVICE_PATH    *FilePath = NULL;
    UNICODE_STRING          uString;
    ANSI_STRING             aString;
    EFI_GUID                EfiLoadedImageProtocol = LOADED_IMAGE_PROTOCOL;
    EFI_GUID                EfiDevicePathProtocol  = DEVICE_PATH_PROTOCOL;
    EFI_LOADED_IMAGE        *OriginalEfiImageInfo = NULL;
    EFI_LOADED_IMAGE        *LoadedEfiImageInfo = NULL;
    EFI_DEVICE_PATH         *OriginalEfiDevicePath = NULL;
    PTFTP_RESTART_BLOCK     restartBlock = NULL;
    PTFTP_RESTART_BLOCK_V1  restartBlockV1 = NULL;

    ULONG                   BootFileId = 0;
    PUCHAR                  LoadedImageAddress = NULL;
    ULONG                   LoadedImageSize = 0;


    //
    // Load the file we want to boot into memory.
    //
    Status = BlOpen( NET_DEVICE_ID,
                     NextBootFile,
                     ArcOpenReadOnly,
                     &BootFileId );
    if (Status != ESUCCESS) {
        return Status;
    }

    //
    // What memory address did he get loaded into?
    //
    LoadedImageAddress = BlFileTable[BootFileId].u.NetFileContext.InMemoryCopy;
    LoadedImageSize = BlFileTable[BootFileId].u.NetFileContext.FileSize;


    //
    // BUild a device path to the target file.  We'll do this by gathering
    // some information about ourselves, knowing that we're about to load/launch
    // an image from the server, just like where we came from.
    //

    //
    // Get image information on ourselves.
    //
    FlipToPhysical();
    EfiStatus = EfiST->BootServices->HandleProtocol( EfiImageHandle,
                                                     &EfiLoadedImageProtocol,
                                                     &OriginalEfiImageInfo );
    FlipToVirtual();

    if( EFI_ERROR(EfiStatus) ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "NetSoftReboot: HandleProtocol_1 failed (%d)\n", EfiStatus );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Get our DevicePath too.
    //
    FlipToPhysical();
    EfiStatus = EfiST->BootServices->HandleProtocol( OriginalEfiImageInfo->DeviceHandle,
                                                     &EfiDevicePathProtocol,
                                                     &OriginalEfiDevicePath );
    FlipToVirtual();

    if( EFI_ERROR(EfiStatus) ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "NetSoftReboot: HandleProtocol_2 failed (%d)\n", EfiStatus );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Now build a device path based on the DeviceHandle of ourselves, along
    // with the path to the image we want to load.
    //
    RtlInitString( &aString, NextBootFile );
    uString.MaximumLength = MAX_PATH;
    uString.Buffer = WideNextBootFile;
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );

    i = wcslen(uString.Buffer);
    FlipToPhysical();
    EfiStatus = EfiST->BootServices->AllocatePool( EfiLoaderData,
                                                   i + sizeof(FILEPATH_DEVICE_PATH) + sizeof(EFI_DEVICE_PATH),
                                                   (VOID **) &FilePath );
    FlipToVirtual();

    if( EFI_ERROR(EfiStatus) ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "NetSoftReboot: AllocatePool_1 failed (%d)\n", EfiStatus );
        }
        return STATUS_NO_MEMORY;
    }

    FilePath->Header.Type = MEDIA_DEVICE_PATH;
    FilePath->Header.SubType = MEDIA_FILEPATH_DP;
    SetDevicePathNodeLength (&FilePath->Header, i + sizeof(FILEPATH_DEVICE_PATH));
    RtlCopyMemory (FilePath->PathName, uString.Buffer, i);

    FlipToPhysical();
    Eop = NextDevicePathNode(&FilePath->Header);
    SetDevicePathEndNode(Eop);

    // 
    //  Append file path to device's device path
    //
    ldrDevicePath = (EFI_DEVICE_PATH *)FilePath;
    ldrDevicePath = AppendDevicePath ( OriginalEfiDevicePath,
                                       ldrDevicePath );
    FlipToVirtual();


    //
    // Load the image, then set its loadoptions in preparation
    // for launching it.
    //
    if( BdDebuggerEnabled ) {
        DbgPrint( "NetSoftReboot: About to LoadImage.\n" );
    }
    FlipToPhysical();
    EfiStatus = EfiST->BootServices->LoadImage( FALSE,
                                                EfiImageHandle,
                                                ldrDevicePath,
                                                LoadedImageAddress,
                                                LoadedImageSize,
                                                &ImageHandle );
    FlipToVirtual();


    if( EFI_ERROR(EfiStatus) ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "NetSoftReboot: LoadImage failed (%d)\n", EfiStatus );
        }
        return STATUS_NO_MEMORY;

    } else {
        if( BdDebuggerEnabled ) {
            DbgPrint( "NetSoftReboot: LoadImage worked (%d)\n", EfiStatus );
        }
    }



    //
    // allocate a chunk of memory, then load it up w/ all the boot options.
    //
    FlipToPhysical();
    EfiStatus = EfiST->BootServices->AllocatePool( EfiLoaderData,
                                                   sizeof(TFTP_RESTART_BLOCK),
                                                   (VOID **) &restartBlock );
    FlipToVirtual();

    restartBlockV1 = (PTFTP_RESTART_BLOCK_V1)(&restartBlock->RestartBlockV1);

    BlSetHeadlessRestartBlock(restartBlock);

    if (AdministratorPassword) {
        RtlMoveMemory(restartBlock->AdministratorPassword,AdministratorPassword, OSC_ADMIN_PASSWORD_LEN);        
    }

    restartBlockV1->RebootParameter = Param;

    if (RebootFile != NULL) {
        strcpy(restartBlockV1->RebootFile, RebootFile);
    }

    if (SifFile != NULL) {
        strcpy(restartBlockV1->SifFile, SifFile);
    }

    if (User != NULL) {
        strcpy(restartBlockV1->User, User);
    }
    if (Domain != NULL) {
        strcpy(restartBlockV1->Domain, Domain);
    }
    if (Password != NULL) {
        strcpy(restartBlockV1->Password, Password);
    }

    //
    // Set the tag in the restart block and calculate and store the checksum.
    //
    restartBlockV1->Tag = 'rtsR';
    restartBlockV1->Checksum = CalculateChecksum((PLONG)(restartBlockV1), 128);

    //
    // For all versions of RIS after NT5.0 we have a new datastructure which is
    // more adaptable for the future.  For this section we have a different checksum,
    // do that now.
    //
    restartBlock->TftpRestartBlockVersion = TFTP_RESTART_BLOCK_VERSION;
    restartBlock->NewCheckSumLength = sizeof(TFTP_RESTART_BLOCK);
    restartBlock->NewCheckSum = CalculateChecksum((PLONG)restartBlock,
                                                  restartBlock->NewCheckSumLength);

    

    //
    // We've got the command-line options all setup.  Now we need to
    // actually put them into ImageInfo->LoadOptions so they get
    // passed to the loaded image.
    //
    
    if( BdDebuggerEnabled ) {
        DbgPrint( "NetSoftReboot: About to EfiLoadedImageProtocol on the loadedImage.\n" );
    }
    FlipToPhysical();
    EfiStatus = EfiST->BootServices->HandleProtocol( ImageHandle,
                                                     &EfiLoadedImageProtocol,
                                                     &LoadedEfiImageInfo );
    FlipToVirtual();

    if( EFI_ERROR(EfiStatus) ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "NetSoftReboot: HandleProtocol_3 failed (%d)\n", EfiStatus );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    LoadedEfiImageInfo->LoadOptions = (PVOID)restartBlock;
    LoadedEfiImageInfo->LoadOptionsSize = sizeof(TFTP_RESTART_BLOCK);
#if DBG
    EfiDumpBuffer(LoadedEfiImageInfo->LoadOptions, sizeof(TFTP_RESTART_BLOCK));
#endif


    //
    // Since we loaded the image from a memory buffer, he's not
    // going to have a DeviceHandle set.  We'll fail quickly when
    // setupldr.efi starts.  We can just set it right here, and
    // we know exactly what it is because it's the same as the
    // network device handle for Oschoice.efi, wich we have
    // readily available.
    //
    LoadedEfiImageInfo->DeviceHandle = OriginalEfiImageInfo->DeviceHandle;
    LoadedEfiImageInfo->FilePath = ldrDevicePath;
    if( BdDebuggerEnabled ) {
        DbgPrint( "NetSoftReboot: LoadedEfiImageInfo->DeviceHandle: 0x%08lx\n", PtrToUlong(LoadedEfiImageInfo->DeviceHandle) );
        DbgPrint( "NetSoftReboot: LoadedEfiImageInfo->FilePath: 0x%08lx\n", PtrToUlong(LoadedEfiImageInfo->FilePath) );
    }

    //
    // We shouldn't return from this call!
    //
    if( BdDebuggerEnabled ) {
        DbgPrint( "NetSoftReboot: StartImage.\n" );
    }
    FlipToPhysical();
    EfiStatus = EfiST->BootServices->StartImage( ImageHandle,
                                                 0,
                                                 NULL );
    FlipToVirtual();



    if( EFI_ERROR(EfiStatus) ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "NetSoftReboot: StartImage failed (%d)\n", EfiStatus );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;

}

VOID
NetGetRebootParameters(
    OUT PULONGLONG Param OPTIONAL,
    OUT PUCHAR RebootFile OPTIONAL,
    OUT PUCHAR SifFile OPTIONAL,
    OUT PUCHAR User OPTIONAL,
    OUT PUCHAR Domain OPTIONAL,
    OUT PUCHAR Password OPTIONAL,
    OUT PUCHAR AdministratorPassword OPTIONAL,
    BOOLEAN ClearRestartBlock
    )

/*++

Routine Description:

    This routine reads the reboot parameters from the global TFTP_RESTART_BLOCK
    and returns them.

Arguments:

    Param - Space for returning the value.

    RebootFile - Optional space for storing the file to reboot to when done here. (size >= char[128])

    SifFile - Optional space for storing a SIF file passed from whoever
        initiated the soft reboot.

    User/Domain/Password/AdministratorPassword - Optional space to store credentials passed across
        the soft reboot.

    ClearRestartBlock - If set to TRUE, it wipes out the memory here - should be done exactly once, at the
        last call to this function.

Return Value:

    None.

--*/

{
BOOLEAN     restartBlockValid = FALSE;

#if DBG
    EfiDumpBuffer(&gTFTPRestartBlock, sizeof(TFTP_RESTART_BLOCK));
#endif

    //
    // See if the block is valid. If it's not, we create a temporary empty
    // one so the copy logic below doesn't have to keep checking.
    //
    if ((gTFTPRestartBlock.RestartBlockV1.Tag == 'rtsR') &&
        (CalculateChecksum((PLONG)(&gTFTPRestartBlock.RestartBlockV1), 128) == 0)) {
        restartBlockValid = TRUE;
    }


    //
    // Copy out the parameters that were in the original TFTP_RESTART_BLOCK structure.
    // These shipped in Win2K.
    //
    if (Param != NULL) {
        *Param = gTFTPRestartBlock.RestartBlockV1.RebootParameter;
    }

    if (RebootFile != NULL) {
        memcpy(RebootFile, gTFTPRestartBlock.RestartBlockV1.RebootFile, sizeof(gTFTPRestartBlock.RestartBlockV1.RebootFile));
    }

    if (SifFile != NULL) {
        memcpy(SifFile, gTFTPRestartBlock.RestartBlockV1.SifFile, sizeof(gTFTPRestartBlock.RestartBlockV1.SifFile));
    }

    if (User != NULL) {
        strcpy(User, gTFTPRestartBlock.RestartBlockV1.User);
    }
    if (Domain != NULL) {
        strcpy(Domain, gTFTPRestartBlock.RestartBlockV1.Domain);
    }
    if (Password != NULL) {
        strcpy(Password, gTFTPRestartBlock.RestartBlockV1.Password);
    }

    //
    // Now do a new check for all versions past Win2K
    //
    if (restartBlockValid) {

        if ((gTFTPRestartBlock.NewCheckSumLength == 0) ||
            (CalculateChecksum((PLONG)(&gTFTPRestartBlock), gTFTPRestartBlock.NewCheckSumLength) != 0)) {

            //
            // A pre-Win2K OsChooser has given us this block.  Clear out all fields
            // that are post-Win2K and continue.
            //
            RtlZeroMemory( &gTFTPRestartBlock, sizeof(TFTP_RESTART_BLOCK) );

        }

    }

    //
    // Now extract the parameters from the block.
    //
    if (gTFTPRestartBlock.TftpRestartBlockVersion == TFTP_RESTART_BLOCK_VERSION) {
        BlGetHeadlessRestartBlock(&gTFTPRestartBlock, restartBlockValid);

        if (AdministratorPassword) {
            RtlMoveMemory(AdministratorPassword,gTFTPRestartBlock.AdministratorPassword, OSC_ADMIN_PASSWORD_LEN);
        }
    }    

    if (restartBlockValid && ClearRestartBlock) {
        RtlZeroMemory(&gTFTPRestartBlock, sizeof(TFTP_RESTART_BLOCK));
    }

#if DBG
    BlPrint(TEXT("Done getting TFTP_RESTART_BLOCK.\r\n"));
#endif

    return;
}


ARC_STATUS
NetFillNetworkLoaderBlock (
    PNETWORK_LOADER_BLOCK NetworkLoaderBlock
    )
{
    SHORT status;
    t_PXENV_GET_BINL_INFO gbi;
    BOOTPLAYER packet;


    //
    // Get client IP address, server IP address, default gateway IP address,
    // and subnet mask from the DHCP ACK packet.
    //
    
    gbi.packet_type = PXENV_PACKET_TYPE_DHCP_ACK;
    gbi.buffer_size = sizeof(packet);
    gbi.buffer_offset = (USHORT)((ULONG_PTR)&packet & 0x0f);
    gbi.buffer_segment = (USHORT)(((ULONG_PTR)&packet >> 4) & 0xffff);

    status = NETPC_ROM_SERVICES( PXENV_GET_BINL_INFO, &gbi );
    if ( status != PXENV_EXIT_SUCCESS ) {
        DbgPrint("PXENV_GET_BINL_INFO(DHCPACK) failed with %x\n", status);
        return ENODEV;
    }

    NetworkLoaderBlock->DHCPServerACK = BlAllocateHeap(gbi.buffer_size);
    if (NetworkLoaderBlock->DHCPServerACK == NULL) {
        return ENOMEM;
    }

    memcpy( NetworkLoaderBlock->DHCPServerACK, &packet, gbi.buffer_size );
    NetworkLoaderBlock->DHCPServerACKLength = gbi.buffer_size;

    gbi.packet_type = PXENV_PACKET_TYPE_BINL_REPLY;
    gbi.buffer_size = sizeof(packet);
    gbi.buffer_offset = (USHORT)((ULONG_PTR)&packet & 0x0f);
    gbi.buffer_segment = (USHORT)(((ULONG_PTR)&packet >> 4) & 0xffff);

    status = NETPC_ROM_SERVICES( PXENV_GET_BINL_INFO, &gbi );
    if ( status != PXENV_EXIT_SUCCESS ) {
        DbgPrint("PXENV_GET_BINL_INFO(BINLREPLY) failed with %x\n", status);
    } else {

        NetworkLoaderBlock->BootServerReplyPacket = BlAllocateHeap(gbi.buffer_size);
        if (NetworkLoaderBlock->BootServerReplyPacket == NULL) {
            return ENOMEM;
        }

        memcpy( NetworkLoaderBlock->BootServerReplyPacket, &packet, gbi.buffer_size );
        NetworkLoaderBlock->BootServerReplyPacketLength = gbi.buffer_size;
    }

    return ESUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=boot

!IF "$(BUILD_DEBUG_LOADER)" != ""
!include $(PROJECT_ROOT)\boot\loader_dbg.inc
!ELSE
!include $(PROJECT_ROOT)\boot\loader.inc
!ENDIF

TARGETNAME=efi
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES= \
    $(SDK_INC_PATH);\
    $(DS_INC_PATH)\crypto;\
    $(PROJECT_ROOT)\hals;\
    $(PROJECT_ROOT)\hals\inc;\
    ..\inc;\
    ..\..\inc;\
    $(PROJECT_ROOT)\ntos\inc;\
    $(PROJECT_ROOT)\fs\fastfat;\
    $(PROJECT_ROOT)\fs\cdfs;\
    $(PROJECT_ROOT)\fs\udfs;\
    $(PROJECT_ROOT)\fs\cntfs;\
    $(PROJECT_ROOT)\ntos\config;\
    ..\$(TARGET_DIRECTORY);\
    $(DDK_INC_PATH);\
    $(HALKIT_INC_PATH)

!IF $(IA64)
INCLUDES = $(INCLUDES);..\..\lib\$(TARGET_DIRECTORY);..\inc\$(TARGET_DIRECTORY)
!ENDIF

!IF 0
NOTE : To force CD/DVD boot while starting setupldr from harddisk use
       FORCE_CD_BOOT
C_DEFINES=$(C_DEFINES) -DFORCE_CD_BOOT -DEFI

!ENDIF

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE -DEFI

SOURCES=..\arcemul.c  \
        ..\acpidtct.c \
        ..\arctree.c  \
        ..\biosdrv.c  \
        ..\display.c  \
        ..\efidisp.c  \
        ..\efiutil.c  \
        ..\entry.c    \
        ..\envvar.c   \
        ..\exp.c      \
        ..\input.c    \
        ..\port.c     \
        ..\sumain.c   \
        ..\netboot2.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\port.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This modules implements com port code to support reading/writing from com ports.

Author:

    Allen M. Kay (allen.m.kay@intel.com) 27-Jan-2000

Revision History:

--*/

#include "bldr.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#include "ntverp.h"
#include "efi.h"
#include "efip.h"
#include "bldria64.h"
#include "acpitabl.h"

#include "extern.h"

#if DBG

extern EFI_SYSTEM_TABLE        *EfiST;
#define DBG_TRACE(_X) EfiST->ConOut->OutputString(EfiST->ConOut, (_X))

#else

#define DBG_TRACE(_X) 

#endif // for FORCE_CD_BOOT




//
// Headless boot defines
//
ULONG BlTerminalDeviceId = 0;
BOOLEAN BlTerminalConnected = FALSE;
ULONG   BlTerminalDelay = 0;

HEADLESS_LOADER_BLOCK LoaderRedirectionInformation;

//
// Define COM Port registers.
//
#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10
#define COM_FE      0x08
#define COM_PE      0x04
#define COM_OE      0x02

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01

//
// Define Serial IO Protocol
//
EFI_GUID EfiSerialIoProtocol = SERIAL_IO_PROTOCOL;
SERIAL_IO_INTERFACE *SerialIoInterface;

//
// Define debugger port initial state.
//
typedef struct _CPPORT {
    PUCHAR Address;
    ULONG Baud;
    USHORT Flags;
} CPPORT, *PCPPORT;

#define PORT_DEFAULTRATE    0x0001      // baud rate not specified, using default
#define PORT_MODEMCONTROL   0x0002      // using modem controls

CPPORT Port[4] = {
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE}
                 };



//
// This is how we find table information from
// the ACPI table index.
//
extern PDESCRIPTION_HEADER
BlFindACPITable(
    IN PCHAR TableName,
    IN ULONG TableLength
    );



LOGICAL
BlRetrieveBIOSRedirectionInformation(
    VOID
    )

/*++

Routine Description:

    This functions retrieves the COM port information from the ACPI
    table.

Arguments:

    We'll be filling in the LoaderRedirectionInformation structure.

Returned Value:

    TRUE - If a debug port is found.

--*/

{

    PDEBUG_PORT_TABLE   pPortTable = NULL;
    LOGICAL             ReturnValue = FALSE;
    LOGICAL             FoundIt = FALSE;
    EFI_DEVICE_PATH     *DevicePath = NULL;
    EFI_DEVICE_PATH     *RootDevicePath = NULL;
    EFI_DEVICE_PATH     *StartOfDevicePath = NULL;
    EFI_STATUS          Status = EFI_UNSUPPORTED;
    ACPI_HID_DEVICE_PATH *AcpiDevicePath;
    UART_DEVICE_PATH    *UartDevicePath;
    EFI_DEVICE_PATH_ALIGNED DevicePathAligned;
    UINTN               reqd;
    EFI_GUID EfiGlobalVariable  = EFI_GLOBAL_VARIABLE;
    PUCHAR              CurrentAddress = NULL;
    UCHAR               Checksum;
    ULONG               i;
    ULONG               CheckLength;



    pPortTable = (PDEBUG_PORT_TABLE)BlFindACPITable( "SPCR",
                                                     sizeof(DEBUG_PORT_TABLE) );

    if( pPortTable ) {

        //
        // generate a checksum for later validation.
        //
        CurrentAddress = (PUCHAR)pPortTable;
        CheckLength = pPortTable->Header.Length;
        Checksum = 0;
        for( i = 0; i < CheckLength; i++ ) {
            Checksum += CurrentAddress[i];
        }


        if(
                                                // checksum is okay?
            (Checksum == 0) &&

                                                // device address defined?
            ((UCHAR UNALIGNED *)pPortTable->BaseAddress.Address.QuadPart != (UCHAR *)NULL) &&

                                                // he better be in system or memory I/O
                                                // note: 0 - systemI/O
                                                //       1 - memory mapped I/O
            ((pPortTable->BaseAddress.AddressSpaceID == 0) ||
             (pPortTable->BaseAddress.AddressSpaceID == 1))

         ) {


            if( pPortTable->BaseAddress.AddressSpaceID == 0 ) {
                LoaderRedirectionInformation.IsMMIODevice = TRUE;
            } else {
                LoaderRedirectionInformation.IsMMIODevice = FALSE;
            }


            //
            // We got the table.  Now dig out the information we want.
            // See definitiion of DEBUG_PORT_TABLE (acpitabl.h)
            //
            LoaderRedirectionInformation.UsedBiosSettings = TRUE;
            LoaderRedirectionInformation.PortNumber = 3;
            LoaderRedirectionInformation.PortAddress = (UCHAR UNALIGNED *)(pPortTable->BaseAddress.Address.QuadPart);

            if( pPortTable->BaudRate == 7 ) {
                LoaderRedirectionInformation.BaudRate = BD_115200;
            } else if( pPortTable->BaudRate == 6 ) {
                LoaderRedirectionInformation.BaudRate = BD_57600;
            } else if( pPortTable->BaudRate == 4 ) {
                LoaderRedirectionInformation.BaudRate = BD_19200;
            } else {
                LoaderRedirectionInformation.BaudRate = BD_9600;
            }

            LoaderRedirectionInformation.Parity = pPortTable->Parity;
            LoaderRedirectionInformation.StopBits = pPortTable->StopBits;
            LoaderRedirectionInformation.TerminalType = pPortTable->TerminalType;

            
            //
            // If this is a new DEBUG_PORT_TABLE, then it's got the PCI device
            // information.
            //
            if( pPortTable->Header.Length >= sizeof(DEBUG_PORT_TABLE) ) {

                LoaderRedirectionInformation.PciDeviceId = *((USHORT UNALIGNED *)(&pPortTable->PciDeviceId));
                LoaderRedirectionInformation.PciVendorId = *((USHORT UNALIGNED *)(&pPortTable->PciVendorId));
                LoaderRedirectionInformation.PciBusNumber = (UCHAR)pPortTable->PciBusNumber;
                LoaderRedirectionInformation.PciSlotNumber = (UCHAR)pPortTable->PciSlotNumber;
                LoaderRedirectionInformation.PciFunctionNumber = (UCHAR)pPortTable->PciFunctionNumber;
                LoaderRedirectionInformation.PciFlags = *((ULONG UNALIGNED *)(&pPortTable->PciFlags));
            } else {

                //
                // There's no PCI device information in this table.
                //
                LoaderRedirectionInformation.PciDeviceId = (USHORT)0xFFFF;
                LoaderRedirectionInformation.PciVendorId = (USHORT)0xFFFF;
                LoaderRedirectionInformation.PciBusNumber = 0;
                LoaderRedirectionInformation.PciSlotNumber = 0;
                LoaderRedirectionInformation.PciFunctionNumber = 0;
                LoaderRedirectionInformation.PciFlags = 0;
            }

            return TRUE;

        }

    }


    //
    // We didn't get anything from the ACPI table.  Look
    // for the ConsoleOutHandle and see if someone configured
    // the EFI firmware to redirect.  If so, we can pickup
    // those settings and carry them forward.
    //


    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: didn't find SPCR table\r\n");


    FoundIt = FALSE;
    //
    // Get the CONSOLE Device Paths.
    //
    
    reqd = 0;
    Status = EfiST->RuntimeServices->GetVariable(
                                        L"ConOut",
                                        &EfiGlobalVariable,
                                        NULL,
                                        &reqd,
                                        NULL );

    if( Status == EFI_BUFFER_TOO_SMALL ) {

        DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: GetVariable(ConOut) success\r\n");


#ifndef  DONT_USE_EFI_MEMORY
        Status = EfiBS->AllocatePool(
                            EfiLoaderData,
                            reqd,
                            (VOID **) &StartOfDevicePath);
        if( Status != EFI_SUCCESS ) {
            WCHAR DebugBuffer[120];
            wsprintf( DebugBuffer, L"BlRetreiveBIOSRedirectionInformation: AllocatePool returned (%x)\r\n", Status );
            DBG_TRACE( DebugBuffer );
            StartOfDevicePath = NULL;
        }

#else
        //
        // go back to virtual mode to allocate some memory
        //
        FlipToVirtual();
        StartOfDevicePath = BlAllocateHeapAligned( (ULONG)reqd );

        if( StartOfDevicePath ) {
            //
            // convert the address into a physical address
            //
            StartOfDevicePath = (EFI_DEVICE_PATH *) ((ULONGLONG)StartOfDevicePath & ~KSEG0_BASE);
        }

        //
        // go back into physical mode
        // 
        FlipToPhysical();
#endif

        if (StartOfDevicePath) {
            
            DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: allocated pool for variable\r\n");

            Status = EfiST->RuntimeServices->GetVariable(
                                                        L"ConOut",
                                                        &EfiGlobalVariable,
                                                        NULL,
                                                        &reqd,
                                                        (VOID *)StartOfDevicePath);

            DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: GetVariable returned\r\n");

        } else {
            DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: Failed to allocate memory for CONOUT variable.\r\n");
        }
    } else {
        WCHAR DebugBuffer[120];
        wsprintf( DebugBuffer, L"BlRetreiveBIOSRedirectionInformation: GetVariable returned (%x)\r\n", Status );
        DBG_TRACE( DebugBuffer );
        Status = EFI_BAD_BUFFER_SIZE;
    }



    if( !EFI_ERROR(Status) ) {

        DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: retrieved ConOut successfully\r\n");

        //
        // Preserve StartOfDevicePath so we can free the memory later.
        //
        DevicePath = StartOfDevicePath;

        EfiAlignDp(&DevicePathAligned,
                   DevicePath,
                   DevicePathNodeLength(DevicePath));



        //
        // Keep looking until we get to the end of the entire Device Path.
        //
        while( !((DevicePathAligned.DevPath.Type == END_DEVICE_PATH_TYPE) &&
                 (DevicePathAligned.DevPath.SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE)) &&
                (!FoundIt) ) {


            //
            // Remember the address he's holding.  This is the root
            // of this device path and we may need to look at this
            // guy again if down the path we find a UART.
            //
            RootDevicePath = DevicePath;



            //
            // Keep looking until we get to the end of this subpath.
            //
            while( !((DevicePathAligned.DevPath.Type == END_DEVICE_PATH_TYPE) &&
                     ((DevicePathAligned.DevPath.SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE) ||
                      (DevicePathAligned.DevPath.SubType == END_INSTANCE_DEVICE_PATH_SUBTYPE))) ) {


                if( (DevicePathAligned.DevPath.Type    == MESSAGING_DEVICE_PATH) &&
                    (DevicePathAligned.DevPath.SubType == MSG_UART_DP) &&
                    (FoundIt == FALSE) ) {


                    //
                    // We got a UART.  Pickup the settings.
                    //
                    UartDevicePath = (UART_DEVICE_PATH *)&DevicePathAligned;
                    LoaderRedirectionInformation.BaudRate = (ULONG)UartDevicePath->BaudRate;
                    LoaderRedirectionInformation.Parity = (BOOLEAN)UartDevicePath->Parity;
                    LoaderRedirectionInformation.StopBits = (UCHAR)UartDevicePath->StopBits;


                    //
                    // Fixup BaudRate if necessary.  If it's 0, then we're
                    // supposed to use the default for this h/w.  We're going
                    // to override to 9600 though.
                    //
                    if( LoaderRedirectionInformation.BaudRate == 0 ) {
                        LoaderRedirectionInformation.BaudRate = BD_9600;
                    }

                    if( LoaderRedirectionInformation.BaudRate > BD_115200 ) {
                        LoaderRedirectionInformation.BaudRate = BD_115200;
                    }

                    DBG_TRACE(L"BlRetrieveBIOSRedirectionInformation: found a UART\r\n");

                    //
                    // Remember that we found a UART and quit searching.
                    //
                    FoundIt = TRUE;

                }

                if( (FoundIt == TRUE) && // we already found a UART, so we're on the right track.
                    (DevicePathAligned.DevPath.Type    == MESSAGING_DEVICE_PATH) &&
                    (DevicePathAligned.DevPath.SubType == MSG_VENDOR_DP) ) {

                    VENDOR_DEVICE_PATH  *VendorDevicePath = (VENDOR_DEVICE_PATH *)&DevicePathAligned;
                    EFI_GUID            PcAnsiGuid = DEVICE_PATH_MESSAGING_PC_ANSI;

                    //
                    // See if the UART is a VT100 or ANSI or whatever.
                    //
                    if( memcmp( &VendorDevicePath->Guid, &PcAnsiGuid, sizeof(EFI_GUID)) == 0 ) {
                        LoaderRedirectionInformation.TerminalType = 3;
                    } else {

                        // Default to VT100
                        LoaderRedirectionInformation.TerminalType = 0;
                    }
                }


                //
                // Get the next structure in our packed array.
                //
                DevicePath = NextDevicePathNode( DevicePath );

                EfiAlignDp(&DevicePathAligned,
                           DevicePath,
                           DevicePathNodeLength(DevicePath));
            
            }


            //
            // Do we need to keep going?  Check to make sure we're not at the
            // end of the entire packed array of device paths.
            //
            if( !((DevicePathAligned.DevPath.Type == END_DEVICE_PATH_TYPE) &&
                  (DevicePathAligned.DevPath.SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE)) ) {

                //
                // Yes.  Get the next entry.
                //
                DevicePath = NextDevicePathNode( DevicePath );

                EfiAlignDp(&DevicePathAligned,
                           DevicePath,
                           DevicePathNodeLength(DevicePath));
            }

        }

    } else {
        DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: failed to get CONOUT variable\r\n");
    }


    if( FoundIt ) {


        //
        // We found a UART, but we were already too far down the list
        // in the device map to get the address, which is really what
        // we're after.  Start looking at the device map again from the
        // root of the path where we found the UART.
        //
        DevicePath = RootDevicePath;


        //
        // Reset this guy so we'll know if we found a reasonable
        // ACPI_DEVICE_PATH entry.
        //
        FoundIt = FALSE;
        EfiAlignDp(&DevicePathAligned,
                   RootDevicePath,
                   DevicePathNodeLength(DevicePath));


        //
        // Keep looking until we get to the end, or until we run
        // into our UART again.
        //
        while( (DevicePathAligned.DevPath.Type != END_DEVICE_PATH_TYPE) &&
               (!FoundIt) ) {

            if( DevicePathAligned.DevPath.Type == ACPI_DEVICE_PATH ) {

                //
                // Remember the address he's holding.
                //
                AcpiDevicePath = (ACPI_HID_DEVICE_PATH *)&DevicePathAligned;

                if( AcpiDevicePath->UID ) {

                    LoaderRedirectionInformation.PortAddress = (PUCHAR)ULongToPtr(AcpiDevicePath->UID);
                    LoaderRedirectionInformation.PortNumber = 3;

                    FoundIt = TRUE;
                }
            }


            //
            // Get the next structure in our packed array.
            //
            DevicePath = NextDevicePathNode( DevicePath );

            EfiAlignDp(&DevicePathAligned,
                       DevicePath,
                       DevicePathNodeLength(DevicePath));
        }

    }


    if( FoundIt ) {
        DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: returning TRUE\r\n");
        ReturnValue = TRUE;
    }



#ifndef  DONT_USE_EFI_MEMORY
    //
    // Free the memory we allocated for StartOfDevicePath.
    //
    if( StartOfDevicePath != NULL ) {
        EfiBS->FreePool( (VOID *)StartOfDevicePath );
    }
#endif


    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();


    return( ReturnValue );

}

LOGICAL
BlPortInitialize(
    IN ULONG BaudRate,
    IN ULONG PortNumber,
    IN PUCHAR PortAddress OPTIONAL,
    IN BOOLEAN ReInitialize,
    OUT PULONG BlFileId
    )

/*++

Routine Description:

    This functions initializes the com port.

Arguments:

    BaudRate - Supplies an optional baud rate.

    PortNumber - supplies an optinal port number.
    
    ReInitialize - Set to TRUE if we already have this port open, but for some
        reason need to completely reset the port.  Otw it should be FALSE.
    
    BlFileId - A place to store a fake file Id, if successful.

Returned Value:

    TRUE - If a debug port is found, and BlFileId will point to a location within Port[].

--*/

{
    UCHAR DebugMessage[80];
    LOGICAL Found = FALSE;

    ULONG HandleCount;
    EFI_HANDLE *SerialIoHandles;
    EFI_HANDLE DeviceHandle = NULL;
    EFI_DEVICE_PATH *DevicePath;
    EFI_DEVICE_PATH_ALIGNED DevicePathAligned;
    ACPI_HID_DEVICE_PATH *AcpiDevicePath;
    ULONG i;
    ULONG Control;
    EFI_STATUS Status;
    ARC_STATUS ArcStatus;

    ArcStatus = BlGetEfiProtocolHandles(
                                    &EfiSerialIoProtocol,
                                    &SerialIoHandles,
                                    &HandleCount
                                    );

    if (ArcStatus != ESUCCESS) {
        return FALSE;
    }

    //
    // If the baud rate is not specified, then default the baud rate to 19.2.
    //

    if (BaudRate == 0) {
        BaudRate = BD_19200;
    }


    
    //
    // If the user didn't send us a port address, then
    // guess based on the COM port number.
    //
    if( PortAddress == 0 ) {

        switch (PortNumber) {
            case 1:
                PortAddress = (PUCHAR)COM1_PORT;
                break;

            case 2:
                PortAddress = (PUCHAR)COM2_PORT;
                break;

            case 3:
                PortAddress = (PUCHAR)COM3_PORT;
                break;

            default:
                PortNumber = 4;
                PortAddress = (PUCHAR)COM4_PORT;
        }

    }
        
    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    //
    // Get the device path
    //
    for (i = 0; i < HandleCount; i++) {
        DBG_TRACE( L"About to HandleProtocol\r\n");
        Status = EfiBS->HandleProtocol (
                    SerialIoHandles[i],
                    &EfiDevicePathProtocol,
                    &DevicePath
                    );

        if (EFI_ERROR(Status)) {
            DBG_TRACE( L"HandleProtocol failed\r\n");
            Found = FALSE;
            goto e0;
        }

        EfiAlignDp(&DevicePathAligned,
                   DevicePath,
                   DevicePathNodeLength(DevicePath));

        AcpiDevicePath = (ACPI_HID_DEVICE_PATH *) &DevicePathAligned;

        if (PortNumber = 0) {
            Found = TRUE;
            break;
        } else if (AcpiDevicePath->UID == PtrToUlong(PortAddress)) {
            Found = TRUE;
            break;
        }
        
    }

    if (Found == TRUE) {
        DBG_TRACE( L"found the port device\r\n");
        //
        // Check if the port is already in use, and this is a first init.
        //
        if (!ReInitialize && (Port[PortNumber].Address != NULL)) {
            DBG_TRACE( L"found the port device but it's already in use\r\n");
            Found = FALSE;
            goto e0;
        }

        //
        // Check if someone tries to reinit a port that is not open.
        //
        if (ReInitialize && (Port[PortNumber].Address == NULL)) {
            DBG_TRACE( L"found the port device but we're reinitializing a port that hasn't been opened\r\n");
            Found = FALSE;
            goto e0;
        }

        DBG_TRACE( L"about to HandleProtocol for SerialIO\r\n");

        //
        // Get the interface for the serial IO protocol.
        //
        Status = EfiBS->HandleProtocol(SerialIoHandles[i],
                                       &EfiSerialIoProtocol,
                                       &SerialIoInterface
                                      );

        if (EFI_ERROR(Status)) {
            DBG_TRACE( L"HandleProtocol for SerialIO failed\r\n");
            Found = FALSE;
            goto e0;
        }

        Status = SerialIoInterface->SetAttributes(SerialIoInterface,
                                                  BaudRate,
                                                  0,
                                                  0,
                                                  DefaultParity,
                                                  0,
                                                  DefaultStopBits
                                                 );

        if (EFI_ERROR(Status)) {
            DBG_TRACE( L"SerialIO: SetAttributes failed\r\n");
            Found = FALSE;
            goto e0;
        }

        Control = EFI_SERIAL_DATA_TERMINAL_READY | EFI_SERIAL_CLEAR_TO_SEND;
        Status = SerialIoInterface->SetControl(SerialIoInterface,
                                               Control
                                              );
        if (EFI_ERROR(Status)) {
            DBG_TRACE( L"SerialIO: SetControl failed\r\n");
            Found = FALSE;
            goto e0;
        }

    } else {
        DBG_TRACE( L"didn't find a port device\r\n");    
        Found = FALSE;
        goto e0;
    }


    //
    // Initialize Port[] structure.
    //
    Port[PortNumber].Address = PortAddress;
    Port[PortNumber].Baud    = BaudRate;

    *BlFileId = PortNumber;


    DBG_TRACE( L"success, we're done.\r\n");    
e0:
    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();

    BlFreeDescriptor( (ULONG)((ULONGLONG)SerialIoHandles >> PAGE_SHIFT) );
    
    return Found;
}

VOID
BlInitializeHeadlessPort(
    VOID
    )

/*++

Routine Description:

    Does x86-specific initialization of a dumb terminal connected to a serial port.  Currently, 
    it assumes baud rate and com port are pre-initialized, but this can be changed in the future 
    by reading the values from boot.ini or someplace.

Arguments:

    None.

Return Value:

    None.

--*/

{
    UINTN               reqd;
    EFI_GUID EfiGlobalVariable  = EFI_GLOBAL_VARIABLE;
    EFI_STATUS          Status = EFI_UNSUPPORTED;

    if( (LoaderRedirectionInformation.PortNumber == 0) ||
        !(LoaderRedirectionInformation.PortAddress) ) {

        //
        // This means that no one has filled in the LoaderRedirectionInformation
        // structure, which means that we aren't redirecting right now.
        // See if the BIOS was redirecting.  If so, pick up those settings
        // and use them.
        //
        
        BlRetrieveBIOSRedirectionInformation();

        if( LoaderRedirectionInformation.PortNumber ) {


            //
            // We don't need to even bother telling anyone else in the
            // loader that we're going to need to redirect because if
            // EFI is redirecting, then the loader will be redirecting (as
            // it's just an EFI app).
            //
            BlTerminalConnected = FALSE;


            //
            // We really need to make sure there's an address associated with
            // this port and not just a port number.
            //
            if( LoaderRedirectionInformation.PortAddress == NULL ) {

                switch( LoaderRedirectionInformation.PortNumber ) {

                    case 4:
                        LoaderRedirectionInformation.PortAddress = (PUCHAR)COM4_PORT;
                        break;

                    case 3:
                        LoaderRedirectionInformation.PortAddress = (PUCHAR)COM3_PORT;
                        break;

                    case 2:
                        LoaderRedirectionInformation.PortAddress = (PUCHAR)COM2_PORT;
                        break;

                    case 1:
                    default:
                        LoaderRedirectionInformation.PortAddress = (PUCHAR)COM1_PORT;
                        break;
                }

            }

            //
            // Load in the machine's GUID
            //

            FlipToPhysical();
            reqd = sizeof(GUID);
            Status = EfiST->RuntimeServices->GetVariable( L"SystemGUID",
                                                          &EfiGlobalVariable,
                                                          NULL,
                                                          &reqd,
                                                          (VOID *)&LoaderRedirectionInformation.SystemGUID);

            FlipToVirtual();


        } else {

            BlTerminalConnected = FALSE;
        }

    }

}

LOGICAL
BlTerminalAttached(
    IN ULONG DeviceId
    )

/*++

Routine Description:

    This routine will attempt to discover if a terminal is attached.

Arguments:

    DeviceId - Value returned by BlPortInitialize()

Return Value:

    TRUE - Port seems to have something attached.

    FALSE - Port doesn't seem to have anything attached.

--*/

{
    ULONG Control;
    ULONG Flags;
    EFI_STATUS Status;
    BOOLEAN ReturnValue;
 
    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    Status = SerialIoInterface->GetControl(SerialIoInterface,
                                           &Control
                                          );
    if (EFI_ERROR(Status)) {
        FlipToVirtual();
        return FALSE;
    }

    Flags = EFI_SERIAL_DATA_SET_READY |
            EFI_SERIAL_CLEAR_TO_SEND  |
            EFI_SERIAL_CARRIER_DETECT;

    ReturnValue = ((Control & Flags) == Flags);

    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();

    return ReturnValue;
}

VOID
BlSetHeadlessRestartBlock(
    IN PTFTP_RESTART_BLOCK RestartBlock
    )

/*++

Routine Description:

    This routine will fill in the areas of the restart block that are appropriate 
    for the headless server effort.

Arguments:

    RestartBlock - The magic structure for holding restart information from oschoice
        to setupldr.

Return Value:

    None.

--*/

{

    if( LoaderRedirectionInformation.PortNumber ) {


        RestartBlock->HeadlessUsedBiosSettings = (ULONG)LoaderRedirectionInformation.UsedBiosSettings;
        RestartBlock->HeadlessPortNumber = (ULONG)LoaderRedirectionInformation.PortNumber;
        RestartBlock->HeadlessPortAddress = (PUCHAR)LoaderRedirectionInformation.PortAddress;
        RestartBlock->HeadlessBaudRate = (ULONG)LoaderRedirectionInformation.BaudRate;
        RestartBlock->HeadlessParity = (ULONG)LoaderRedirectionInformation.Parity;
        RestartBlock->HeadlessStopBits = (ULONG)LoaderRedirectionInformation.StopBits;
        RestartBlock->HeadlessTerminalType = (ULONG)LoaderRedirectionInformation.TerminalType;

        RestartBlock->HeadlessPciDeviceId = LoaderRedirectionInformation.PciDeviceId;
        RestartBlock->HeadlessPciVendorId = LoaderRedirectionInformation.PciVendorId;
        RestartBlock->HeadlessPciBusNumber = LoaderRedirectionInformation.PciBusNumber;
        RestartBlock->HeadlessPciSlotNumber = LoaderRedirectionInformation.PciSlotNumber;
        RestartBlock->HeadlessPciFunctionNumber = LoaderRedirectionInformation.PciFunctionNumber;
        RestartBlock->HeadlessPciFlags = LoaderRedirectionInformation.PciFlags;
    }
}

VOID
BlGetHeadlessRestartBlock(
    IN PTFTP_RESTART_BLOCK RestartBlock,
    IN BOOLEAN RestartBlockValid
    )

/*++

Routine Description:

    This routine will get all the information from a restart block    
    for the headless server effort.

Arguments:

    RestartBlock - The magic structure for holding restart information from oschoice
        to setupldr.
        
    RestartBlockValid - Is this block valid (full of good info)?

Return Value:

    None.

--*/

{

    LoaderRedirectionInformation.UsedBiosSettings = (BOOLEAN)RestartBlock->HeadlessUsedBiosSettings;
    LoaderRedirectionInformation.DataBits = 0;
    LoaderRedirectionInformation.StopBits = (UCHAR)RestartBlock->HeadlessStopBits;
    LoaderRedirectionInformation.Parity = (BOOLEAN)RestartBlock->HeadlessParity;
    LoaderRedirectionInformation.BaudRate = (ULONG)RestartBlock->HeadlessBaudRate;;
    LoaderRedirectionInformation.PortNumber = (ULONG)RestartBlock->HeadlessPortNumber;
    LoaderRedirectionInformation.PortAddress = (PUCHAR)RestartBlock->HeadlessPortAddress;
    LoaderRedirectionInformation.TerminalType = (UCHAR)RestartBlock->HeadlessTerminalType;

    LoaderRedirectionInformation.PciDeviceId = (USHORT)RestartBlock->HeadlessPciDeviceId;
    LoaderRedirectionInformation.PciVendorId = (USHORT)RestartBlock->HeadlessPciVendorId;
    LoaderRedirectionInformation.PciBusNumber = (UCHAR)RestartBlock->HeadlessPciBusNumber;
    LoaderRedirectionInformation.PciSlotNumber = (UCHAR)RestartBlock->HeadlessPciSlotNumber;
    LoaderRedirectionInformation.PciFunctionNumber = (UCHAR)RestartBlock->HeadlessPciFunctionNumber;
    LoaderRedirectionInformation.PciFlags = (ULONG)RestartBlock->HeadlessPciFlags;

}

ULONG
BlPortGetByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the port and return it.

Arguments:

    BlFileId - The port to read from.

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.

    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    ULONGLONG BufferSize = 1;
    EFI_STATUS Status;

    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    Status = SerialIoInterface->Read(SerialIoInterface,
                                     &BufferSize,
                                     Input
                                    );

    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();

    switch (Status) {
    case EFI_SUCCESS:
        return CP_GET_SUCCESS;
    case EFI_TIMEOUT:
        return CP_GET_NODATA;
    default:
        return CP_GET_ERROR;
    }
}

VOID
BlPortPutByte (
    IN ULONG BlFileId,
    IN UCHAR Output
    )

/*++

Routine Description:

    Write a byte to the port.

Arguments:

    BlFileId - The port to write to.

    Output - Supplies the output data byte.

Return Value:

    None.

--*/

{
    ULONGLONG BufferSize = 1;
    ULONG Control;
    EFI_STATUS Status;

    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    Status = SerialIoInterface->Write(SerialIoInterface,
                                      &BufferSize,
                                      &Output
                                     );
    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();

}

ULONG
BlPortPollByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the port and return it if one is available.

Arguments:

    BlFileId - The port to poll.

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    ULONGLONG BufferSize = 1;
    ULONG Control;
    EFI_STATUS Status;
 
    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    Status = SerialIoInterface->GetControl(SerialIoInterface,
                                           &Control
                                          );
    if (EFI_ERROR(Status)) {
        FlipToVirtual();
        return CP_GET_ERROR;
    }


    if (Control & EFI_SERIAL_INPUT_BUFFER_EMPTY) {
        FlipToVirtual();
        return CP_GET_NODATA;
    } else {
        Status = SerialIoInterface->Read(SerialIoInterface,
                                         &BufferSize,
                                         Input
                                        );
        FlipToVirtual();

        switch (Status) {
        case EFI_SUCCESS:
            return CP_GET_SUCCESS;
        case EFI_TIMEOUT:
            return CP_GET_NODATA;
        default:
            return CP_GET_ERROR;
        }
    }
}

ULONG
BlPortPollOnly (
    IN ULONG BlFileId
    )

/*++

Routine Description:

    Check if a byte is available

Arguments:

    BlFileId - The port to poll.

Return Value:

    CP_GET_SUCCESS is returned if a byte is ready.
    CP_GET_ERROR is returned if error encountered.
    CP_GET_NODATA is returned if timeout.

--*/

{
    EFI_STATUS Status;
    ULONG Control;
    ULONG RetVal;

    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    Status = SerialIoInterface->GetControl(SerialIoInterface,
                                           &Control
                                          );

    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();

    switch (Status) {
    case EFI_SUCCESS:
        if (Control & EFI_SERIAL_INPUT_BUFFER_EMPTY)
            return CP_GET_NODATA;
        else
            return CP_GET_SUCCESS;
    case EFI_TIMEOUT:
        return CP_GET_NODATA;
    default:
        return CP_GET_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\bootfont.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    bootfint.h

Abstract:

    Header file describing the bootfont.bin file used to provide
    dbcs support during system or setup bootstrap.

Author:

    tedm 11-July-1995

Revision History:

--*/


//
// Define maximum number of dbcs lead byte ranges we support.
//
#define MAX_DBCS_RANGE  5

//
// Define signature value.
//
#define BOOTFONTBIN_SIGNATURE 0x5465644d

//
// Define structure used as a header for the bootfont.bin file.
//
typedef struct _BOOTFONTBIN_HEADER {

    //
    // Signature. Must be BOOTFONTBIN_SIGNATURE.
    //
    ULONG Signature;

    //
    // Language id of the language supported by this font.
    // This should match the language id of resources in msgs.xxx.
    //
    ULONG LanguageId;

    //
    // Number of sbcs characters and dbcs characters contained in the file.
    //
    unsigned NumSbcsChars;
    unsigned NumDbcsChars;

    //
    // Offsets within the file to the images.
    //
    unsigned SbcsOffset;
    unsigned DbcsOffset;

    //
    // Total sizes of the images.
    //
    unsigned SbcsEntriesTotalSize;
    unsigned DbcsEntriesTotalSize;

    //
    // Dbcs lead byte table. Must contain a pair of 0's to indicate the end.
    //
    UCHAR DbcsLeadTable[(MAX_DBCS_RANGE+1)*2];

    //
    // Height values for the font.
    // CharacterImageHeight is the height in scan lines/pixels of the
    // font image. Each character is drawn with additional 'padding'
    // lines on the top and bottom, whose sizes are also contained here.
    //
    UCHAR CharacterImageHeight;
    UCHAR CharacterTopPad;
    UCHAR CharacterBottomPad;

    //
    // Width values for the font. These values contain the width in pixels
    // of a single byte character and double byte character.
    //
    // NOTE: CURRENTLY THE SINGLE BYTE WIDTH *MUST* BE 8 AND THE DOUBLE BYTE
    // WIDTH *MUST* BE 16!!!
    //
    UCHAR CharacterImageSbcsWidth;
    UCHAR CharacterImageDbcsWidth;

} BOOTFONTBIN_HEADER, *PBOOTFONTBIN_HEADER;

//
// Images themselves follow.
//
// First there are SbcsCharacters entries for single-byte chars.
// The first byte in each entry is the ascii char code. The next n bytes are
// the image. n is dependent on the width and height of an sbcs char.
//
// Following these are the dbcs images. The first 2 bytes are the dbcs
// character code (highbyte lowbyte) and the next n bytes are the image.
// n is dependent on the width and height of a dbcs char.
//
// Important note: the characters must be sorted in ascending order!
//

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\bootia64.h ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bootia64.h

Abstract:

    Header file for the Ia64 portions of the common boot library

Author:

    John Vert (jvert) 14-Oct-1993

Revision History:

    Allen Kay (akay) 26-Jan-1996          Ported to IA-64

--*/

#include "bldria64.h"
#include "..\bootlib.h"
#include "efi.h"

//
// Macro definition
//

//
// Macro for translation memory size in bytes to page size in TR format
//
#define MEM_SIZE_TO_PS(MemSize, TrPageSize)             \
                if (MemSize <= MEM_4K) {                \
                    TrPageSize = PS_4K;                 \
                } else if (MemSize <= MEM_8K)       {   \
                    TrPageSize = PS_8K;                 \
                } else if (MemSize <= MEM_16K)      {   \
                    TrPageSize = PS_16K;                \
                } else if (MemSize <= MEM_64K)      {   \
                    TrPageSize = PS_64K;                \
                } else if (MemSize <= MEM_256K)     {   \
                    TrPageSize = PS_256K;               \
                } else if (MemSize <= MEM_1M)       {   \
                    TrPageSize = PS_1M;                 \
                } else if (MemSize <= MEM_4M)       {   \
                    TrPageSize = PS_4M;                 \
                } else if (MemSize <= MEM_16M)      {   \
                    TrPageSize = PS_16M;                \
                } else if (MemSize <= MEM_64M)      {   \
                    TrPageSize = PS_64M;                \
                } else if (MemSize <= MEM_256M)     {   \
                    TrPageSize = PS_256M;               \
                }

extern PMEMORY_DESCRIPTOR MDArray;
extern ULONG             MaxDescriptors;
extern ULONG             NumberDescriptors;


VOID
InitializeMemoryDescriptors (
    VOID
    );

VOID
InsertDescriptor (
    ULONG BasePage,
    ULONG NumberOfPages,
    MEMORY_TYPE MemoryType
    );



//          B O O T   C O N T E X T   R E C O R D
//
//  Passed to the OS loader by the SU module or bootstrap
//  code, whatever the case. Constains all the basic machine
//  and environment information the OS loaders needs to get
//  itself going.
//

typedef enum {
    BootBusAtapi,
    BootBusScsi,
    BootBusVendor,
    BootBusMax
} BUS_TYPE;

typedef enum {
    BootMediaHardDisk,
    BootMediaCdrom,
    BootMediaFloppyDisk,
    BootMediaTcpip,
    BootMediaMax
} MEDIA_TYPE;

typedef struct _BOOT_DEVICE_ATAPI {
    UCHAR PrimarySecondary;
    UCHAR SlaveMaster;
    USHORT Lun;
} BOOT_DEVICE_ATAPI, *PBOOT_DEVICE_ATAPI;

typedef struct _BOOT_DEVICE_SCSI {
    USHORT Pun;
    USHORT Lun;
} BOOT_DEVICE_SCSI, *PBOOT_DEVICE_SCSI;

typedef struct _BOOT_DEVICE_FLOPPY {
    ULONG DriveNumber;
} BOOT_DEVICE_FLOPPY, *PBOOT_DEVICE_FLOPPY;

typedef struct _BOOT_DEVICE_IPv4 {
    USHORT RemotePort;
    USHORT LocalPort;
    EFI_IPv4_ADDRESS Ip;
} BOOT_DEVICE_IPv4, *PBOOT_DEVICE_IPv4;

typedef struct {
    UINT64 Ip[2];
} IPv6_ADDRESS;

typedef struct _BOOT_DEVICE_IPv6 {
    USHORT RemotePort;
    USHORT LocalPort;
    IPv6_ADDRESS Ip;
} BOOT_DEVICE_IPv6, *PBOOT_DEVICE_IPv6;

typedef struct {
    ULONG Data1;
    USHORT Data2;
    USHORT Data3;
    UCHAR Data4[8];
} BOOT_EFI_GUID;

typedef struct _BOOT_DEVICE_UNKNOWN {
    BOOT_EFI_GUID Guid;
    UCHAR LegacyDriveLetter;
} BOOT_DEVICE_UNKNOWN, *PBOOT_DEVICE_UNKNOWN;

typedef union _BOOT_DEVICE {
    BOOT_DEVICE_ATAPI BootDeviceAtapi;
    BOOT_DEVICE_SCSI BootDeviceScsi;
    BOOT_DEVICE_FLOPPY BootDeviceFloppy;
    BOOT_DEVICE_IPv4 BootDeviceIpv4;
    BOOT_DEVICE_IPv6 BootDeviceIpv6;
    BOOT_DEVICE_UNKNOWN BootDeviceUnknown;
} BOOT_DEVICE, *PBOOT_DEVICE;

typedef struct _BOOT_CONTEXT {
    ULONG BusType;
    ULONG MediaType;
    ULONG PartitionNumber;
    BOOT_DEVICE BootDevice;
    PEXTERNAL_SERVICES_TABLE ExternalServicesTable;
    ULONGLONG MachineType;
    ULONGLONG OsLoaderStart;
    ULONGLONG OsLoaderEnd;
    ULONGLONG ResourceDirectory;
    ULONGLONG ResourceOffset;
    ULONGLONG OsLoaderBase;
    ULONGLONG OsLoaderExports;
} BOOT_CONTEXT, *PBOOT_CONTEXT;

//
// Common function prototypes
//
VOID
InitializeDisplaySubsystem(
    VOID
    );

ARC_STATUS
InitializeMemorySubsystem(
    PBOOT_CONTEXT
    );

ARC_STATUS
XferPhysicalDiskSectors(
    IN  UCHAR     Int13UnitNumber,
    IN  ULONGLONG StartSector,
    IN  UCHAR     SectorCount,
    OUT PUCHAR    Buffer,
    IN  UCHAR     SectorsPerTrack,
    IN  USHORT    Heads,
    IN  USHORT    Cylinders,
    IN  BOOLEAN   AllowExtendedInt13,
    IN  BOOLEAN   Write
    );

#define ReadPhysicalSectors(d,a,n,p,s,h,c,f)                                \
                                                                            \
            XferPhysicalDiskSectors((d),(a),(n),(p),(s),(h),(c),(f),FALSE)

#define WritePhysicalSectors(d,a,n,p,s,h,c,f)                               \
                                                                            \
            XferPhysicalDiskSectors((d),(a),(n),(p),(s),(h),(c),(f),TRUE)


ARC_STATUS
XferExtendedPhysicalDiskSectors(
    IN  ULONGLONG DeviceHandle,
    IN  ULONGLONG StartSector,
    IN  USHORT    SectorCount,
    OUT PUCHAR    Buffer,
    IN  BOOLEAN   Write
    );

#define ReadExtendedPhysicalSectors(d,a,c,p)                                \
                                                                            \
            XferExtendedPhysicalDiskSectors((d),(a),(c),(p),FALSE)

#define WriteExtendedPhysicalSectors(d,a,c,p)                               \
                                                                            \
            XferExtendedPhysicalDiskSectors((d),(a),(c),(p),TRUE)

VOID
ResetDiskSystem(
    UCHAR Int13UnitNumber
    );

VOID
MdShutoffFloppy(
    VOID
    );


BOOLEAN
FwGetPathMnemonicKey(
    IN PCHAR OpenPath,
    IN PCHAR Mnemonic,
    IN PULONG Key
    );

PVOID
FwAllocateHeapAligned(
    IN ULONG Size
    );

PVOID
FwAllocatePool(
    IN ULONG Size
    );

PVOID
FwAllocateHeapPermanent(
    IN ULONG NumberPages
    );

VOID
FwStallExecution(
    IN ULONG Microseconds
    );

VOID
BlGetActivePartition(
    OUT PUCHAR PartitionName
    );

VOID
BlFillInSystemParameters(
    IN PBOOT_CONTEXT BootContextRecord
    );


//
// PS/2 ABIOS module  (in abiosc.c)
//
VOID
RemapAbiosSelectors(
    VOID
    );

//
// global data definitions
//

extern ULONG MachineType;
extern PCONFIGURATION_COMPONENT_DATA FwConfigurationTree;
extern ULONG HeapUsed;
ULONG PalFreeBase;

//
// page Table definition
//

#define HYPER_SPACE_BEGIN       0xC0000000
#define HYPER_PAGE_DIR          0xC0300000

#define GetPteOffset(va) \
  ( (((ULONG)(va)) << (32-PDI_SHIFT)) >> ((32-PDI_SHIFT) + PTI_SHIFT) )

//
// X86 Detection definitions
// The size is *ALWAYS* assumed to be 64K.
// N.B.  The definition *MUST* be the same as the ones defined in
//       startup\su.inc
//

#define DETECTION_LOADED_ADDRESS 0x10000

//
//  We need to allocate permanent and temporary memory for the page directory,
//  assorted page tables, and the memory descriptors before the blmemory
//  routines ever get control.  So we have two private heaps, one for permanent
//  data and one for temporary data.  There are two descriptors for this.  The
//  permanent heap descriptor starts out as zero-length at P.A. 0x30000.  The
//  temporary heap descriptor immediately follows the permanent heap in memory
//  and starts out as 128k long.  As we allocate permanent pages, we increase
//  the size of the permanent heap descriptor and increase the base (thereby
//  decreasing the size) of the temporary heap descriptor)
//
//  So the permanent heap starts at P.A. 0x30000 and grows upwards.  The
//  temporary heap starts at P.A. 0x5C000 and grows downwards.  This gives us
//  a total of 128k of combined permanent and temporary data.
//

//
// Heap starting locations (in pages)
//

#define PERMANENT_HEAP_START (0x1010000 >> PAGE_SHIFT)
#define TEMPORARY_HEAP_START (0x1040000 >> PAGE_SHIFT)

//
// Useful Macro Definitions
//
#define ROUND_UP(Num,Size)  (((Num) + Size - 1) & ~(Size -1))

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) { \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) { \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) { \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }


//
// Global definitions for the BIOS ARC Emulation
//

//
// Defines for the ARC name of console input and output
//

#define CONSOLE_INPUT_NAME "multi(0)key(0)keyboard(0)"
#define CONSOLE_OUTPUT_NAME "multi(0)video(0)monitor(0)"

//
// Define special character values.
//

#define ASCI_NUL 0x00
#define ASCI_BEL 0x07
#define ASCI_BS  0x08
#define ASCI_HT  0x09
#define ASCI_LF  0x0A
#define ASCI_VT  0x0B
#define ASCI_FF  0x0C
#define ASCI_CR  0x0D
#define ASCI_CSI 0x9B
#define ASCI_ESC 0x1B
#define ASCI_SYSRQ 0x80




//
// Device I/O prototypes
//

ARC_STATUS
BiosPartitionClose(
    IN ULONG FileId
    );

ARC_STATUS
BiosPartitionOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosPartitionRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosPartitionWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosPartitionSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
BiosDiskGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    );


ARC_STATUS
BiosPartitionGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    );

ARC_STATUS
BlArcNotYetImplemented(
    IN ULONG FileId
    );

ARC_STATUS
BiosConsoleOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosConsoleReadStatus(
    IN ULONG FileId
    );

ARC_STATUS
BiosConsoleRead (
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosConsoleWrite (
    IN ULONG FileId,
    OUT PWCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosDiskOpen(
    IN ULONG DriveId,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosDiskRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosElToritoDiskRead(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

BOOLEAN
BlIsElToritoCDBoot(
    UCHAR DriveNum
    );

ARC_STATUS
BiosDiskWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
HardDiskPartitionOpen(
    IN ULONG   FileId,
    IN ULONG   DiskId,
    IN UCHAR   PartitionNumber
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\displayp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    displayp.h

Abstract:

    Private header file for display routines.

Author:

    Ted Miller (tedm) 7-July-1995

Revision History:

--*/

//
// NOTICE
//
// Under no circumstances is anyone besides display.c to call these routines
// directly. This would break DBCS display for Far Eastern locales.
//

//
// Globals
//
extern USHORT TextColumn;
extern USHORT TextRow;
extern UCHAR TextCurrentAttribute;

//
// Vga text mode stuff
//
VOID
TextTmScrollDisplay(
    VOID
    );

VOID
TextTmClearDisplay(
    VOID
    );

VOID
TextTmClearToEndOfDisplay(
    VOID
    );

VOID
TextTmClearFromStartOfLine(
    VOID
    );

VOID
TextTmClearToEndOfLine(
    VOID
    );

VOID
TextTmFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    );

PUCHAR
TextTmCharOut(
    PUCHAR pc
    );

VOID
TextTmStringOut(
    IN PUCHAR String
    );

VOID
TextTmPositionCursor(
    USHORT Row,
    USHORT Column
    );

VOID
TextTmSetCurrentAttribute(
    IN UCHAR Attribute
    );

UCHAR
TextTmGetGraphicsChar(
    IN GraphicsChar WhichOne
    );

//
// Vga graphics mode stuff
//

VOID
TextGrScrollDisplay(
    VOID
    );

VOID
TextGrClearDisplay(
    VOID
    );

VOID
TextGrClearToEndOfDisplay(
    VOID
    );

VOID
TextGrClearFromStartOfLine(
    VOID
    );

VOID
TextGrClearToEndOfLine(
    VOID
    );

VOID
TextGrFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    );

PUCHAR
TextGrCharOut(
    PUCHAR pc
    );

VOID
TextGrStringOut(
    IN PUCHAR String
    );

VOID
TextGrPositionCursor(
    USHORT Row,
    USHORT Column
    );

VOID
TextGrSetCurrentAttribute(
    IN UCHAR Attribute
    );

UCHAR
TextGrGetGraphicsChar(
    IN GraphicsChar WhichOne
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\sumain.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1998  Intel Corporation


Module Name:

    sumain.c

Abstract:
    SuMain() sets up NT specific data structures for OsLoader.c.  This
    is necessary since we don't have the ARC firmware to do the work
    for us.  SuMain() is call by SuSetup() which is an assembly level
    routine that does IA64 specific setup.

Author:

    Allen Kay   (akay)  19-May-95

--*/

#include "bldr.h"
#include "sudata.h"
#include "sal.h"
#include "efi.h"
#include "efip.h"
#include "bootia64.h"
#include "smbios.h"


extern EFI_SYSTEM_TABLE *EfiST;

//
// External functions
//
extern VOID NtProcessStartup();
extern VOID SuFillExportTable();
extern VOID CpuSpecificWork();

extern EFI_STATUS
GetSystemConfigurationTable(
    IN EFI_GUID *TableGuid,
    IN OUT VOID **Table
    );

//
// Define export entry table.
//
PVOID ExportEntryTable[ExMaximumRoutine];

//          M E M O R Y   D E S C R I P T O R
//
// Memory Descriptor - each contiguous block of physical memory is
// described by a Memory Descriptor. The descriptors are a table, with
// the last entry having a BlockBase and BlockSize of zero.  A pointer
// to the beginning of this table is passed as part of the BootContext
// Record to the OS Loader.
//

BOOT_CONTEXT BootContext;

//
// Global EFI data
//

#define EFI_ARRAY_SIZE    100
#define EFI_PAGE_SIZE     4096
#define EFI_PAGE_SHIFT    12

#define MEM_4K         0x1000
#define MEM_8K         0x2000
#define MEM_16K        0x4000
#define MEM_64K        0x10000
#define MEM_256K       0x40000
#define MEM_1M         0x100000
#define MEM_4M         0x400000
#define MEM_16M        0x1000000
#define MEM_64M        0x4000000
#define MEM_256M       0x10000000

EFI_HANDLE               EfiImageHandle;
EFI_SYSTEM_TABLE        *EfiST;
EFI_BOOT_SERVICES       *EfiBS;
EFI_RUNTIME_SERVICES    *EfiRS;
PSST_HEADER              SalSystemTable;
PVOID                    AcpiTable;
PVOID                    SMBiosTable;

//
// contains the memory map key so we can compare the consistency of the memory map
// at loader entry time to loader exit time.
//
ULONGLONG                MemoryMapKey;

//
// EFI GUID defines
//
EFI_GUID EfiLoadedImageProtocol = LOADED_IMAGE_PROTOCOL;
EFI_GUID EfiDevicePathProtocol  = DEVICE_PATH_PROTOCOL;
EFI_GUID EfiDeviceIoProtocol    = DEVICE_IO_PROTOCOL;
EFI_GUID EfiBlockIoProtocol     = BLOCK_IO_PROTOCOL;
EFI_GUID EfiDiskIoProtocol  = DISK_IO_PROTOCOL;
EFI_GUID EfiFilesystemProtocol  = SIMPLE_FILE_SYSTEM_PROTOCOL;


EFI_GUID AcpiTable_Guid         = ACPI_TABLE_GUID;
EFI_GUID SmbiosTableGuid        = SMBIOS_TABLE_GUID;
EFI_GUID SalSystemTableGuid     = SAL_SYSTEM_TABLE_GUID;

//
// PAL, SAL, and IO port space data
//

ULONGLONG   PalProcVirtual;
ULONGLONG   PalProcPhysical;
ULONGLONG   PalPhysicalBase = 0;
ULONGLONG   PalTrPs;

ULONGLONG   IoPortPhysicalBase;
ULONGLONG   IoPortTrPs;

//
// Function Prototypes
//

VOID
GetPalProcEntryPoint(
    IN PSST_HEADER SalSystemTable
    );

ULONG
GetDevPathSize(
    IN EFI_DEVICE_PATH *DevPath
    );

VOID
ConstructMemoryDescriptors(
    VOID
    );

MEMORY_TYPE
EfiToArcType (
    UINT32 Type
    );

VOID
AdjustMemoryDescriptorSizes(
    VOID
    );


#if DBG
#define DBG_TRACE(_X) EfiST->ConOut->OutputString(EfiST->ConOut, (_X))
#else
#define DBG_TRACE(_X)
#endif

#ifdef FORCE_CD_BOOT

EFI_HANDLE
GetCd(
    );

EFI_HANDLE
GetCdTest(
    VOID
    );

#endif // for FORCE_CD_BOOT


VOID
SuMain(
    IN EFI_HANDLE          ImageHandle,
    IN EFI_SYSTEM_TABLE    *SystemTable
    )
/*++

Routine Description:

    Main entrypoint of the SU module. Control is passed from the boot
    sector to startup.asm which does some run-time fixups on the stack
    and data segments and then passes control here.

Arguments:

    None

Returns:

    Does not return. Passes control to the OS loader


--*/
{
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG NumberOfSections;
    BOOLEAN ResourceFound = FALSE;

    ULONGLONG Source,Destination;
    ULONGLONG VirtualSize;
    ULONGLONG SizeOfRawData;
    USHORT Section;

    EFI_GUID EfiLoadedImageProtocol = LOADED_IMAGE_PROTOCOL;
    EFI_HANDLE EfiHandleArray[EFI_ARRAY_SIZE];
    ULONG EfiHandleArraySize = EFI_ARRAY_SIZE * sizeof(EFI_HANDLE);
    EFI_DEVICE_PATH *EfiDevicePath;
    EFI_LOADED_IMAGE *EfiImageInfo;
    EFI_HANDLE DeviceHandle;
    EFI_STATUS Status;

    EFI_DEVICE_PATH *DevicePath, *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    HARDDRIVE_DEVICE_PATH *HdDevicePath;
    ACPI_HID_DEVICE_PATH *AcpiDevicePath;
    ATAPI_DEVICE_PATH *AtapiDevicePath;
    SCSI_DEVICE_PATH *ScsiDevicePath;
    IPv4_DEVICE_PATH *IpV4DevicePath;
    IPv6_DEVICE_PATH *IpV6DevicePath;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *UnknownDevicePath;

    UCHAR MemoryMap[EFI_PAGE_SIZE];
    ULONGLONG MemoryMapSize = EFI_PAGE_SIZE;
    EFI_MEMORY_DESCRIPTOR *EfiMd;    
    ULONGLONG DescriptorSize;
    ULONG DescriptorVersion;

    ULONG i;
    ULONGLONG PalSize;
    ULONGLONG PalEnd;
    ULONGLONG IoPortSize;
    ULONGLONG MdPhysicalEnd;

    PBOOT_DEVICE_ATAPI BootDeviceAtapi;
    PBOOT_DEVICE_SCSI BootDeviceScsi;
    PBOOT_DEVICE_FLOPPY BootDeviceFloppy;
    PBOOT_DEVICE_IPv4 BootDeviceIpV4;
    PBOOT_DEVICE_IPv6 BootDeviceIpV6;
    PBOOT_DEVICE_UNKNOWN BootDeviceUnknown;

    PSMBIOS_EPS_HEADER SMBiosEPSHeader;
    PUCHAR SMBiosEPSPtr;
    UCHAR CheckSum;


    //
    // EFI global variables
    //
    EfiImageHandle = ImageHandle;
    EfiST = SystemTable;
    EfiBS = SystemTable->BootServices;
    EfiRS = SystemTable->RuntimeServices;

    DBG_TRACE(L"SuMain: entry\r\n");

    //
    // Get the SAL System Table
    //
    Status = GetSystemConfigurationTable(&SalSystemTableGuid, &SalSystemTable);
    if (EFI_ERROR(Status)) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: HandleProtocol failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

#if 0
    //
    // Get the MPS Table
    //
    Status = GetSystemConfigurationTable(&MpsTableGuid, &MpsTable);
    if (EFI_ERROR(Status)) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: HandleProtocol failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }
#endif
    //
    // Get the ACPI Tables
    //

    //
    // Get the ACPI 2.0 Table, if present
    //
    //DbgPrint("Looking for ACPi 2.0\n");
    Status = GetSystemConfigurationTable(&AcpiTable_Guid, &AcpiTable);
    if (EFI_ERROR(Status)) {
        //DbgPrint("returned error\n");
        AcpiTable = NULL;
    }

  //DbgPrint("AcpiTable: %p\n", AcpiTable);

    if (!AcpiTable) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                            L"SuMain: HandleProtocol failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }


    //
    // Get the SMBIOS Table
    //
    Status = GetSystemConfigurationTable(&SmbiosTableGuid, &SMBiosTable);
    if (EFI_ERROR(Status)) {
        //DbgPrint("returned error\n");
        SMBiosTable = NULL;
    } else {
        //
        // Validate SMBIOS EPS Header
        //
        SMBiosEPSHeader = (PSMBIOS_EPS_HEADER)SMBiosTable;
        SMBiosEPSPtr = (PUCHAR)SMBiosTable;
        
        if ((*((PULONG)SMBiosEPSHeader->Signature) == SMBIOS_EPS_SIGNATURE) &&
            (SMBiosEPSHeader->Length >= sizeof(SMBIOS_EPS_HEADER)) &&
            (*((PULONG)SMBiosEPSHeader->Signature2) == DMI_EPS_SIGNATURE) && 
            (SMBiosEPSHeader->Signature2[4] == '_' ))
        {
            CheckSum = 0;
            for (i = 0; i < SMBiosEPSHeader->Length ; i++)
            {
                CheckSum += SMBiosEPSPtr[i];
            }

            if (CheckSum != 0)
            {
                DBG_TRACE(L"SMBios Table has bad checksum.....\n");
                SMBiosTable = NULL;
            } else {
                DBG_TRACE(L"SMBios Table has been validated.....\n");
            }
            
        } else {
            DBG_TRACE(L"SMBios Table is incorrectly formed.....\n");
            SMBiosTable = NULL;
        }       
    }                                                                     
    
    //
    // Get the image info for NTLDR
    //
    Status = EfiBS->HandleProtocol (
                ImageHandle,
                &EfiLoadedImageProtocol,
                &EfiImageInfo
                );

    if (EFI_ERROR(Status)) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: HandleProtocol failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // Get device path of the DeviceHandle associated with this image handle.
    //
    Status = EfiBS->HandleProtocol (
                EfiImageInfo->DeviceHandle,
                &EfiDevicePathProtocol,
                &DevicePath
                );

    if (EFI_ERROR(Status)) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: HandleProtocol failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // Get the MediaType and Partition information and save them in the
    // BootContext.
    //
    EfiAlignDp( &TestPathAligned,
                 DevicePath,
                 DevicePathNodeLength(DevicePath) );


    TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

    while (TestPath->Type != END_DEVICE_PATH_TYPE) {

        if (TestPath->Type == MESSAGING_DEVICE_PATH) {
            if (TestPath->SubType == MSG_ATAPI_DP) {
                AtapiDevicePath = (ATAPI_DEVICE_PATH *) TestPath;
                BootContext.BusType = BootBusAtapi;
                BootDeviceAtapi = (PBOOT_DEVICE_ATAPI) &(BootContext.BootDevice);

                BootDeviceAtapi->PrimarySecondary = AtapiDevicePath->PrimarySecondary;
                BootDeviceAtapi->SlaveMaster = AtapiDevicePath->SlaveMaster;
                BootDeviceAtapi->Lun = AtapiDevicePath->Lun;
            } else if (TestPath->SubType == MSG_SCSI_DP) {
                ScsiDevicePath = (SCSI_DEVICE_PATH *) TestPath;
                BootContext.BusType = BootBusScsi;
                BootDeviceScsi = (PBOOT_DEVICE_SCSI) &(BootContext.BootDevice);

                BootDeviceScsi->Pun = ScsiDevicePath->Pun;
                BootDeviceScsi->Lun = ScsiDevicePath->Lun;
            } else if (TestPath->SubType == MSG_MAC_ADDR_DP) {
                BootContext.MediaType = BootMediaTcpip;
            } else if (TestPath->SubType == MSG_IPv4_DP) {
                IpV4DevicePath = (IPv4_DEVICE_PATH *) TestPath;
                BootContext.MediaType = BootMediaTcpip;
                BootDeviceIpV4 = (PBOOT_DEVICE_IPv4) &(BootContext.BootDevice);

                BootDeviceIpV4->RemotePort = IpV4DevicePath->RemotePort;
                BootDeviceIpV4->LocalPort = IpV4DevicePath->LocalPort;
                RtlCopyMemory(&BootDeviceIpV4->Ip, &IpV4DevicePath->LocalIpAddress, sizeof(EFI_IPv4_ADDRESS));
            } else if (TestPath->SubType == MSG_IPv6_DP) {
                IpV6DevicePath = (IPv6_DEVICE_PATH *) TestPath;
                BootContext.MediaType = BootMediaTcpip;
                BootDeviceIpV6 = (PBOOT_DEVICE_IPv6) &(BootContext.BootDevice);

                BootDeviceIpV6->RemotePort = IpV6DevicePath->RemotePort;
                BootDeviceIpV6->LocalPort = IpV6DevicePath->LocalPort;
#if 0
                BootDeviceIpV6->Ip = IpV6DevicePath->Ip;
#endif
            }
        } else if (TestPath->Type == ACPI_DEVICE_PATH) {
            AcpiDevicePath = (ACPI_HID_DEVICE_PATH *) TestPath;
            if (AcpiDevicePath->HID == EISA_ID(PNP_EISA_ID_CONST, 0x0303)) {
                BootDeviceFloppy = (PBOOT_DEVICE_FLOPPY) &(BootContext.BootDevice);
                BootDeviceFloppy->DriveNumber = AcpiDevicePath->UID;
            }
        } else if (TestPath->Type == HARDWARE_DEVICE_PATH) {
            if (TestPath->SubType == HW_VENDOR_DP) {
                UnknownDevicePath = (UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *) TestPath;
                BootDeviceUnknown = (PBOOT_DEVICE_UNKNOWN) &(BootContext.BootDevice);
                RtlCopyMemory( &(BootDeviceUnknown->Guid),
                               &(UnknownDevicePath->DevicePath.Guid),
                               sizeof(EFI_GUID));

                BootContext.BusType = BootBusVendor;
                BootDeviceUnknown->LegacyDriveLetter = UnknownDevicePath->LegacyDriveLetter;
            }
        } else if (TestPath->Type == MEDIA_DEVICE_PATH) {
            BootContext.MediaType = TestPath->SubType;
            if (TestPath->SubType == MEDIA_HARDDRIVE_DP) {
                HdDevicePath = (HARDDRIVE_DEVICE_PATH *) TestPath;

                BootContext.MediaType = BootMediaHardDisk;
                BootContext.PartitionNumber = (UCHAR) HdDevicePath->PartitionNumber;
            } else if (TestPath->SubType == MEDIA_CDROM_DP) {
                BootContext.MediaType = BootMediaCdrom;
            }
        }

        DevicePath = NextDevicePathNode(DevicePath);
        EfiAlignDp( &TestPathAligned,
                      DevicePath,
                      DevicePathNodeLength(DevicePath) );
        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
    }

#ifdef  FORCE_CD_BOOT
    BootContext.MediaType = BootMediaCdrom;
#endif
    //
    // Fill out the rest of BootContext fields
    //

    DosHeader = EfiImageInfo->ImageBase;
    NtHeader = (PIMAGE_NT_HEADERS) ((PUCHAR) DosHeader + DosHeader->e_lfanew);
    FileHeader =  &(NtHeader->FileHeader);
    OptionalHeader = (PIMAGE_OPTIONAL_HEADER)
                     ((PUCHAR)FileHeader + sizeof(IMAGE_FILE_HEADER));
    SectionHeader = (PIMAGE_SECTION_HEADER) ((PUCHAR)OptionalHeader +
                                             FileHeader->SizeOfOptionalHeader);

    BootContext.ExternalServicesTable = (PEXTERNAL_SERVICES_TABLE)
                                        &ExportEntryTable;

    BootContext.MachineType          = MACHINE_TYPE_ISA;

    BootContext.OsLoaderBase         = (ULONG_PTR)EfiImageInfo->ImageBase;
    BootContext.OsLoaderExports = (ULONG_PTR)EfiImageInfo->ImageBase +
                                  OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

    //
    // Calculate the start address and the end address of OS loader.
    //

    BootContext.OsLoaderStart        = (ULONG_PTR)EfiImageInfo->ImageBase +
                                       SectionHeader->VirtualAddress;
    BootContext.OsLoaderEnd          = (ULONG_PTR)EfiImageInfo->ImageBase +
                                       SectionHeader->SizeOfRawData;

    for (Section=FileHeader->NumberOfSections ; Section-- ; SectionHeader++) {
        Destination = (ULONG_PTR)EfiImageInfo->ImageBase + SectionHeader->VirtualAddress;
        VirtualSize = SectionHeader->Misc.VirtualSize;
        SizeOfRawData = SectionHeader->SizeOfRawData;

        if (VirtualSize == 0) {
            VirtualSize = SizeOfRawData;
        }
        if (Destination < BootContext.OsLoaderStart) {
            BootContext.OsLoaderStart = Destination;
        }
        if (Destination+VirtualSize > BootContext.OsLoaderEnd) {
            BootContext.OsLoaderEnd = Destination+VirtualSize;
        }
    }

    //
    // Find .rsrc section
    //
    SectionHeader = (PIMAGE_SECTION_HEADER) ((PUCHAR)OptionalHeader +
                                             FileHeader->SizeOfOptionalHeader);
    NumberOfSections = FileHeader->NumberOfSections;
    while (NumberOfSections) {
        if (_stricmp(SectionHeader->Name, ".rsrc")==0) {
            BootContext.ResourceDirectory =
                    (ULONGLONG) ((ULONG_PTR)EfiImageInfo->ImageBase + SectionHeader->VirtualAddress);

            BootContext.ResourceOffset = (ULONGLONG)((LONG)SectionHeader->VirtualAddress);
            ResourceFound = TRUE;
        }

        ++SectionHeader;
        --NumberOfSections;
    }

    if (ResourceFound == FALSE) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: Resource section not found\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    DBG_TRACE( L"SuMain: About to call NtProcessStartup\r\n");


    //
    // See if someone called us w/ a TFTP restart block.
    //
    if( EfiImageInfo->LoadOptionsSize == (sizeof(TFTP_RESTART_BLOCK)) ) {
        
        //
        // Likely.  Make sure it's really a TFTP restart block and if so, go retrieve all
        // its contents.
        //
        if( EfiImageInfo->LoadOptions != NULL ) {

            extern TFTP_RESTART_BLOCK       gTFTPRestartBlock;
            PTFTP_RESTART_BLOCK             restartBlock = NULL;

            restartBlock = (PTFTP_RESTART_BLOCK)(EfiImageInfo->LoadOptions);

            RtlCopyMemory( &gTFTPRestartBlock,
                           restartBlock,
                           sizeof(TFTP_RESTART_BLOCK) );

            DBG_TRACE( L"SuMain: copied TFTP_RESTART_BLOCK into gTFTPRestartBlock\r\n");
        }
    }

    ConstructMemoryDescriptors( );

    GetPalProcEntryPoint( SalSystemTable );

    //
    // Applies CPU specific workarounds
    //

    CpuSpecificWork();

    SuFillExportTable( );

    NtProcessStartup( &BootContext );

}

VOID
ConstructMemoryDescriptors(
    VOID
    )
/*++

Routine Description:

    Builds up memory descriptors for the OS loader.  This routine queries EFI 
    for it's memory map (a variable sized array of EFI_MEMORY_DESCRIPTOR's).  
    It then allocates sufficient space for the MDArray global (a variable sized
    array of  ARC-based MEMORY_DESCRIPTOR's.)  The routine then maps the EFI
    memory map to the ARC memory map, carving out all of the conventional 
    memory space for the EFI loader to help keep the memory map intact.  We 
    must leave behind some amount of memory for the EFI boot services to use,
    which we allocate as conventional memory in our map.

Arguments:

    None

Returns:

    Nothing.  Fills in the MDArray global variable.  If this routine encounters
    an error, it is treated as fatal and the program exits.


--*/
{
    EFI_STATUS Status;
    ULONGLONG MemoryMapSize = 0;
    EFI_MEMORY_DESCRIPTOR *EfiMd;    
    ULONGLONG DescriptorSize;
    ULONG DescriptorVersion;

    ULONG i;
    ULONGLONG PalSize;
    ULONGLONG PalEnd;
    ULONGLONG IoPortSize;
    ULONGLONG MdPhysicalStart;
    ULONGLONG MdPhysicalEnd;
    ULONGLONG MdPhysicalSize;


    //
    // Get memory map info from EFI firmware
    //
    // To do this, we first find out how much space we need by calling
    // with an empty buffer.
    //
    EfiMd = NULL;

    Status = EfiBS->GetMemoryMap (
                &MemoryMapSize,
                EfiMd,
                &MemoryMapKey,
                &DescriptorSize,
                &DescriptorVersion
                );

    if (Status != EFI_BUFFER_TOO_SMALL) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: GetMemoryMap failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // We are going to make three extra allocations before we call GetMemoryMap
    // again, so add some extra space.
    //
    // 1. EfiMD
    // 2. MDarray
    // 3. Split out memory above and below 80MB (on ia64)
    //
    MemoryMapSize += 3*DescriptorSize;


    i = (ULONG) MemoryMapSize;

    //
    // now allocate space for the EFI-based memory map and assign it to the loader
    //
    Status = EfiBS->AllocatePool(EfiLoaderData,i,&EfiMd);
    if (EFI_ERROR(Status)) {
        DBG_TRACE( L"SuMain: AllocatePool failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }


    //
    // now Allocate and zero the MDArray, which is the native loader memory 
    // map which we need to map the EFI memory map to.
    //
    // The MDArray has one entry for each EFI_MEMORY_DESCRIPTOR, and each entry
    // is MEMORY_DESCRIPTOR large.
    //

    i=((ULONG)(MemoryMapSize / DescriptorSize)+1)*sizeof (MEMORY_DESCRIPTOR);

    Status = EfiBS->AllocatePool(EfiLoaderData,i,&MDArray);
    if (EFI_ERROR(Status)) {
        DBG_TRACE (L"SuMain: AllocatePool failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // caution, this is 0 based!
    //
    MaxDescriptors = (ULONG)((MemoryMapSize / DescriptorSize)+1);

    RtlZeroMemory (MDArray,i);

    if ((EfiMd == NULL)) {
        DBG_TRACE (L"SuMain: Failed to Allocate Memory for the descriptor lists\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // we have all of the memory allocated at this point, so retreive the
    // memory map again, which should succeed the second time.
    //
    Status = EfiBS->GetMemoryMap (
                &MemoryMapSize,
                EfiMd,
                &MemoryMapKey,
                &DescriptorSize,
                &DescriptorVersion
                );

    if (EFI_ERROR(Status)) {
        DBG_TRACE(L"SuMain: GetMemoryMap failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // now walk the EFI_MEMORY_DESCRIPTOR array, mapping each
    // entry to an arc-based MEMORY_DESCRIPTOR.
    //
    // MemoryMapSize contains actual size of the memory descriptor array.
    //
    for (i = 0; MemoryMapSize > 0; i++) {
#if DBG_MEMORY
            wsprintf( DebugBuffer, 
                      L"PageStart (%x), Size (%x), Type (%x)\r\n", 
                      (EfiMd->PhysicalStart >> EFI_PAGE_SHIFT), 
                      EfiMd->NumberOfPages,
                      EfiMd->Type);
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
            DBG_EFI_PAUSE();
#endif


        if (EfiMd->NumberOfPages > 0) {
            MdPhysicalStart = EfiMd->PhysicalStart;
            MdPhysicalEnd = EfiMd->PhysicalStart + (EfiMd->NumberOfPages << EFI_PAGE_SHIFT);
            MdPhysicalSize = MdPhysicalEnd - MdPhysicalStart;

#if DBG_MEMORY
            wsprintf( DebugBuffer, 
                      L"PageStart %x (%x), PageEnd %x (%x), Type (%x)\r\n", 
                      MdPhysicalStart, (EfiMd->PhysicalStart >> EFI_PAGE_SHIFT), 
                      MdPhysicalEnd, (EfiMd->PhysicalStart >>EFI_PAGE_SHIFT) + EfiMd->NumberOfPages,
                      EfiMd->Type);
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
            DBG_EFI_PAUSE();
#endif
            

            //
            // Insert conventional memory descriptors with WB flag set
            // into NT loader memory descriptor list.
            //
            if ( (EfiMd->Type == EfiConventionalMemory) &&
                 ((EfiMd->Attribute & EFI_MEMORY_WB) == EFI_MEMORY_WB) ) {
                ULONGLONG AmountOfMemory;
                ULONG NumberOfEfiPages;
                BOOLEAN FirstTime = TRUE;
                //
                // Allocate pages between the start and _80MB line for 
                // the loader to manage.  We don't use anything above this range, so 
                // just leave that memory alone
                //
                if ((MdPhysicalStart < (_80MB << PAGE_SHIFT)) &&
                    (MdPhysicalEnd > (_80MB << PAGE_SHIFT))) {
                    
                    AmountOfMemory = (_80MB << PAGE_SHIFT)  - EfiMd->PhysicalStart;
                    //
                    // record the pages in EFI page size
                    //
                    NumberOfEfiPages = (ULONG)(AmountOfMemory >> EFI_PAGE_SHIFT);
                    
                    //
                    // try to align it.
                    //
                    if ((NumberOfEfiPages % ((1 << PAGE_SHIFT) >> EFI_PAGE_SHIFT) != 0) && 
                        (NumberOfEfiPages + (PAGE_SHIFT - EFI_PAGE_SHIFT) <= EfiMd->NumberOfPages )) {
                        NumberOfEfiPages += (PAGE_SHIFT - EFI_PAGE_SHIFT);
                    }
                    
                    Status = EfiBS->AllocatePages ( AllocateAddress,
                                                EfiLoaderData,
                                                NumberOfEfiPages,
                                                &(EfiMd->PhysicalStart) );

#if DBG_MEMORY
                    wsprintf( DebugBuffer, 
                      L"allocate pages @ %x size = %x\r\n", 
                      (EfiMd->PhysicalStart >> EFI_PAGE_SHIFT), 
                      NumberOfEfiPages);
                    EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
                    DBG_EFI_PAUSE();
#endif


                    if (EFI_ERROR(Status)) {
                        EfiST->ConOut->OutputString(EfiST->ConOut,
                                                    L"SuMain: AllocPages failed\n");
                        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
                    }                    

                    MdPhysicalEnd = MdPhysicalStart + (NumberOfEfiPages << EFI_PAGE_SHIFT);
                    MdPhysicalSize = MdPhysicalEnd - MdPhysicalStart;

                    //
                    // If PalPhysicalBase is not 0, then do not report the memory
                    // from the end of PAL to the next larger page size to avoid
                    // memory aliasing in the kernel.
                    //
                    // we assume that we get the PAL memory in the memory map 
                    // before any conventional memory
                    //
                    while (1) {
                    
                        if (PalPhysicalBase != 0) {
                            //
                            // If the descriptor is completely before or after
                            // the PAL base, just insert it like a normal descriptor
                            //
                            if ( ((MdPhysicalStart < PalPhysicalBase) &&
                                  (MdPhysicalEnd <= PalPhysicalBase)) ||
                                  (MdPhysicalStart >= PalEnd)) {
                                InsertDescriptor( (ULONG)(MdPhysicalStart >> EFI_PAGE_SHIFT),
                                                  (ULONG)(MdPhysicalSize >> EFI_PAGE_SHIFT),
                                                  MemoryFirmwareTemporary ); 
                            }
                            //
                            // else the descriptors must somehow overlap (how 
                            // could this be possible?
                            //
                            else  {
                                if (MdPhysicalStart < PalPhysicalBase) {
                                    
                                    ASSERT( MdPhysicalEnd > PalPhysicalBase );
                                    
                                    EfiST->ConOut->OutputString(EfiST->ConOut,
                                                        L"SuMain: overlapping descriptor with PAL #1\n");
                                    //
                                    // Insert a descriptor from the start of 
                                    // the memory range to the start of the PAL
                                    // code
                                    //
                                    InsertDescriptor( (ULONG)(MdPhysicalStart >> EFI_PAGE_SHIFT),
                                                      (ULONG)((PalPhysicalBase - MdPhysicalStart) >> EFI_PAGE_SHIFT),
                                                      EfiToArcType(EfiMd->Type));
                                }
        
                                if (MdPhysicalEnd > PalEnd) {
                                    //
                                    // Insert a descriptor from the end of the
                                    // PAL code to the end of the memory range
                                    //
                                    InsertDescriptor( (ULONG)(PalEnd >> EFI_PAGE_SHIFT),
                                                      (ULONG)((MdPhysicalEnd - PalEnd) >> EFI_PAGE_SHIFT),
                                                      EfiToArcType(EfiMd->Type));
                                }
                            }
                        } else {
                            //
                            // Insert the descriptor
                            //
                            // hack -- set the memory type to "permanent" so that we
                            // don't merge it with the prior descriptor.  We'll set it 
                            // back to the correct type after we return.
                            //
                            InsertDescriptor( (ULONG)(MdPhysicalStart >> EFI_PAGE_SHIFT),
                                              (ULONG)((ULONGLONG)MdPhysicalSize >> EFI_PAGE_SHIFT),
                                              FirstTime? LoaderFree : LoaderFirmwarePermanent);
                                                        
                        }

                        if (!FirstTime) {
                            MDArray[NumberDescriptors-1].MemoryType = LoaderFirmwareTemporary;
                            break;
                        } else {
                            //
                            // go through again with the rest of the memory descriptor
                            // 
                            MdPhysicalEnd = MdPhysicalStart + (EfiMd->NumberOfPages << EFI_PAGE_SHIFT);
                            MdPhysicalStart += MdPhysicalSize;
                            MdPhysicalSize = MdPhysicalEnd - MdPhysicalStart;

#if DBG_MEMORY
                            wsprintf( DebugBuffer, 
                              L"change start @ %x --> @ %x size %x --> %x\r\n", 
                              (EfiMd->PhysicalStart >> EFI_PAGE_SHIFT),
                              (MdPhysicalStart >> EFI_PAGE_SHIFT),
                              EfiMd->NumberOfPages,
                              (EfiMd->NumberOfPages-NumberOfEfiPages) );
                            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
                            DBG_EFI_PAUSE();
#endif

                            FirstTime = FALSE;
                        }
                    }
                } else {
                    //
                    // just insert it
                    //
                    InsertDescriptor( (ULONG)(MdPhysicalStart >> EFI_PAGE_SHIFT),
                                      (ULONG)((ULONGLONG)MdPhysicalSize >> EFI_PAGE_SHIFT),
                                      EfiToArcType(EfiMd->Type));
                }
            } else if ( (EfiMd->Type == EfiLoaderCode) ||
                        (EfiMd->Type == EfiLoaderData) ) {
                //
                // just insert EfiLoaderCode and EfiLoaderData verbatim
                //
                InsertDescriptor( (ULONG)(MdPhysicalStart >> EFI_PAGE_SHIFT),
                                  (ULONG)(MdPhysicalSize >> EFI_PAGE_SHIFT),
                                  EfiToArcType(EfiMd->Type));
            } else if (EfiMd->Type == EfiPalCode)    {
                //
                // save off the Pal stuff for later
                //
                PalPhysicalBase = EfiMd->PhysicalStart;
                PalSize = EfiMd->NumberOfPages << EFI_PAGE_SHIFT;
                PalEnd = EfiMd->PhysicalStart + PalSize;
                MEM_SIZE_TO_PS(PalSize, PalTrPs);
            } else if (EfiMd->Type == EfiMemoryMappedIOPortSpace)    {
                //
                // save off the Io stuff for later
                //
                IoPortPhysicalBase = EfiMd->PhysicalStart;
                IoPortSize = EfiMd->NumberOfPages << EFI_PAGE_SHIFT;
                MEM_SIZE_TO_PS(IoPortSize, IoPortTrPs);
            } else if (EfiMd->Type == EfiMemoryMappedIO)    {
                //
                // just ignore this type since it's not real memory -- the 
                // system can use ACPI tables to get at this later on.
                //
            } else {
                //
                // some other type -- just insert it without any changes
                //
                InsertDescriptor( (ULONG)(MdPhysicalStart >> EFI_PAGE_SHIFT),
                                  (ULONG)(MdPhysicalSize >> EFI_PAGE_SHIFT),
                                  EfiToArcType(EfiMd->Type));
            }
        }

        EfiMd = (EFI_MEMORY_DESCRIPTOR *) ( (PUCHAR) EfiMd + DescriptorSize );
        MemoryMapSize -= DescriptorSize;

    }

    //
    // we've built the memory descriptors with EFI_PAGE_SIZE resolution.
    // if the page sizes don't match, we post-process it here to get the
    // resolution correct
    //
    if (PAGE_SHIFT != EFI_PAGE_SHIFT) {
        AdjustMemoryDescriptorSizes();
    }
}


VOID
GetPalProcEntryPoint(
    IN PSST_HEADER SalSystemTable
    )
{
    PVOID NextEntry;
    PPAL_SAL_ENTRY_POINT PalSalEntryPoint;
    PSAL_MEMORY_DESCRIPTOR PSalMem;
    ULONG PalFreeEnd;
    ULONGLONG PalProcOffset;
    ULONG i;

    //
    // Get PalProc entry point from SAL System Table
    //
    NextEntry = (PUCHAR) SalSystemTable + sizeof(SST_HEADER);
    for (i = 0; i < SalSystemTable->EntryCount; i++) {
        switch ( *(PUCHAR)NextEntry ) {
           case PAL_SAL_EP_TYPE:
               PalSalEntryPoint = (PPAL_SAL_ENTRY_POINT) NextEntry;
               PalProcPhysical = PalSalEntryPoint->PalEntryPoint;

               PalProcOffset = PalPhysicalBase - PalProcPhysical;
               PalProcVirtual = VIRTUAL_PAL_BASE + PalProcOffset;

               ((PPAL_SAL_ENTRY_POINT)NextEntry)++;
               break;
           case SAL_MEMORY_TYPE:
               ((PSAL_MEMORY_DESCRIPTOR)NextEntry)++;
               break;
           case PLATFORM_FEATURES_TYPE:
               ((PPLATFORM_FEATURES)NextEntry)++;
               break;
           case TRANSLATION_REGISTER_TYPE:
               ((PTRANSLATION_REGISTER)NextEntry)++;
               break;
           case PTC_COHERENCE_TYPE:
               ((PPTC_COHERENCE_DOMAIN)NextEntry)++;
               break;
           case AP_WAKEUP_TYPE:
               ((PAP_WAKEUP_DESCRIPTOR)NextEntry)++;
               break;
           default:
               EfiST->ConOut->OutputString(EfiST->ConOut,
                                           L"SST: Invalid SST entry\n");
               EfiBS->Exit(EfiImageHandle, 0, 0, 0);
        }
    }
}

ULONG
GetDevPathSize(
    IN EFI_DEVICE_PATH *DevPath
    )
{
    EFI_DEVICE_PATH *Start;

    //
    // Search for the end of the device path structure
    //
    Start = DevPath;
    while (DevPath->Type != END_DEVICE_PATH_TYPE) {
        DevPath = NextDevicePathNode(DevPath);
    }

    //
    // Compute the size
    //
    return ((UCHAR) DevPath - (UCHAR) Start);
}


MEMORY_TYPE
EfiToArcType (
    UINT32 Type
    )
/*++

Routine Description:

    Maps an EFI memory type to an Arc memory type.  We only care about a few
    kinds of memory, so this list is incomplete.

Arguments:

    Type - an EFI memory type

Returns:

    A MEMORY_TYPE enumerated type.

--*/
{
    MEMORY_TYPE typeRet=MemoryFirmwarePermanent;


    switch (Type) {
        case EfiLoaderCode:
                 {
                typeRet=MemoryLoadedProgram;       // This gets claimed later
                break;
             }
        case EfiLoaderData:
        case EfiBootServicesCode:
        case EfiBootServicesData:
             {
                 typeRet=MemoryFirmwareTemporary;
                 break;
             }
        case EfiConventionalMemory:
             {
                typeRet=MemoryFree;
                break;
             }
        case EfiUnusableMemory:
             {
                typeRet=MemoryBad;
                break;
             }
        default:
            //
            // all others are memoryfirmwarepermanent
            //
            break;
    }


    return typeRet;


}



VOID
InsertDescriptor (
    ULONG  BasePage,
    ULONG  NumberOfPages,
    MEMORY_TYPE MemoryType
    )

/*++

Routine Description:

    This routine inserts a descriptor into the correct place in the
    memory descriptor list.
    
    The descriptors come in in EFI_PAGE_SIZE pages and must be
    converted to PAGE_SIZE pages.  This significantly complicates things,
    as we must page align the start of descriptors and hte lengths of the
    descriptors.  
    
    What we do is the following: we store the descriptors in the MDArray with
    EFI_PAGE_SIZE resolution.  When we do an insertion, we check if we can
    coellesce the current entry with the prior entry (we assume our memory map
    is sorted), keeping in mind that we want to ensure our entries are always 
    modulo PAGE_SIZE.
    
    After we've added all of the entries with this routine, we have a post
    processing step that converts all of the (modulo PAGE_SIZE) MDArray entries
    into PAGE_SIZE resolution.

Arguments:

    BasePage      - Base page that the memory starts at.

    NumberOfPages - The number of pages starting at memory block to be inserted.
    
    MemoryType    - An arc memory type describing the memory.

Return Value:

    None.  Updates MDArray global memory array.

--*/

{
    MEMORY_DESCRIPTOR *CurrentEntry, *PriorEntry;
    ULONG NewBasePage, NewNumberOfPages;
    BOOLEAN MustCoellesce = FALSE;
    BOOLEAN ShrinkPrior;

    //
    // Search the spot to insert the new descriptor.
    //
    // We assume that there are no holes in our array.
    //
    CurrentEntry = (MEMORY_DESCRIPTOR *)&MDArray[NumberDescriptors];
    //
    // if this is the first entry, just insert it
    //
    if (NumberDescriptors == 0) {
        
        CurrentEntry->BasePage  = BasePage;
        CurrentEntry->PageCount = NumberOfPages;         
        CurrentEntry->MemoryType = MemoryType;

        //
        // The MDArray is already zeroed out so no need to zero out the next entry.
        //
        NumberDescriptors++;

#if DBG
        wsprintf( DebugBuffer, 
                  L"insert new descriptor #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n", 
                  NumberDescriptors, MaxDescriptors, BasePage, NumberOfPages, MemoryType);              
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);        
#endif
        return;  
    }

    PriorEntry = (MEMORY_DESCRIPTOR *)&MDArray[NumberDescriptors-1];

    //
    // The last entry had better be empty or the descriptor list is
    // somehow corrupted.
    //
    if (CurrentEntry->PageCount != 0) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: Inconsistent Descriptor count in InsertDescriptor!\r\n");
        EfiBS->Exit(EfiImageHandle, 0, 0, 0);
    }

    //
    // if the memory type matches the prior entry's memory type, just merge 
    // the two together
    //
    if (PriorEntry->MemoryType == MemoryType) {
        //
        // validate that the array is really sorted correctly
        //
        if (PriorEntry->BasePage + PriorEntry->PageCount != BasePage) {
#if DBG
            wsprintf( DebugBuffer, 
                      L"SuMain: Inconsistent descriptor, PriorEntry->BasePage %x, PriorEntry->PageCount %x, BasePage = %x, type = %x -- insert new descriptor\r\n", 
                      PriorEntry->BasePage,
                      PriorEntry->PageCount, 
                      BasePage, MemoryType);
            EfiST->ConOut->OutputString(EfiST->ConOut,DebugBuffer);
#endif
            CurrentEntry->BasePage  = BasePage;
            CurrentEntry->PageCount = NumberOfPages;
            CurrentEntry->MemoryType = MemoryType;
            NumberDescriptors++;
#if DBG
            wsprintf( DebugBuffer, 
                      L"insert new descriptor #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n", 
                      NumberDescriptors, MaxDescriptors, BasePage, NumberOfPages, MemoryType);              
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);            
#endif
            return;
        } else {
            PriorEntry->PageCount += NumberOfPages;
#if DBG
            wsprintf( DebugBuffer, 
                      L"merge descriptor #%x of %x, BasePage %x, NumberOfPages %x --> %x, Type (%x)\r\n", 
                      NumberDescriptors, 
                      MaxDescriptors, 
                      PriorEntry->BasePage, 
                      PriorEntry->PageCount - NumberOfPages, 
                      PriorEntry->PageCount, 
                      MemoryType);
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);            
#endif
            return;
        }
    }

    //
    // check if the current starting address is module PAGE_SIZE.  If it is,
    // then we know that we must try to coellesce it with the prior entry.
    //
    //
    NewBasePage = BasePage;
    NewNumberOfPages = NumberOfPages;
    if (BasePage % (1 << (PAGE_SHIFT - EFI_PAGE_SHIFT)) != 0) {
#if DBG
        wsprintf( DebugBuffer, 
                  L"must coellesce because base page %x isn't module PAGE_SIZE (%x mod %x = %x).\r\n", 
                  BasePage,
                  (PAGE_SHIFT - EFI_PAGE_SHIFT),
                  (1 << (PAGE_SHIFT - EFI_PAGE_SHIFT)),
                  BasePage % (1 << (PAGE_SHIFT - EFI_PAGE_SHIFT)) );
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
        MustCoellesce = TRUE;
    }

    if (PriorEntry->PageCount % (1 << (PAGE_SHIFT - EFI_PAGE_SHIFT)) != 0 ) {
#if DBG
        wsprintf( 
            DebugBuffer, 
            L"must coellesce because prior page count %x isn't module PAGE_SIZE (%x mod %x = %x).\r\n", 
            PriorEntry->PageCount,
            (PAGE_SHIFT - EFI_PAGE_SHIFT),
            (1 << (PAGE_SHIFT - EFI_PAGE_SHIFT)),
            PriorEntry->PageCount % (1 << (PAGE_SHIFT - EFI_PAGE_SHIFT)) );
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
        MustCoellesce = TRUE;
    }

    if (MustCoellesce) {
        if (PriorEntry->BasePage + PriorEntry->PageCount != BasePage) {
#if DBG
            wsprintf( DebugBuffer, 
                      L"SuMain: Inconsistent descriptor, PriorEntry->BasePage %x, PriorEntry->PageCount %x, BasePage = %x, type = %x -- insert new descriptor\r\n", 
                      PriorEntry->BasePage,
                      PriorEntry->PageCount, 
                      BasePage, MemoryType);
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
            MustCoellesce = FALSE;
        }
    }

    if (MustCoellesce) {
        
        switch( MemoryType ) {
            case MemoryFirmwarePermanent:
                //
                // if the current type is permanent, we must steal from the prior entry
                //
                ShrinkPrior = TRUE;
                break;
            case MemoryLoadedProgram:
                if (PriorEntry->MemoryType == MemoryFirmwarePermanent) {
                    ShrinkPrior = FALSE;
                } else {
                    ShrinkPrior = TRUE;
                }
                break;
            case MemoryFirmwareTemporary:
                if (PriorEntry->MemoryType == MemoryFirmwarePermanent ||
                    PriorEntry->MemoryType == MemoryLoadedProgram) {
                    ShrinkPrior = FALSE;
                } else {
                    ShrinkPrior = TRUE;
                }
                break;
            case MemoryFree:
                ShrinkPrior = FALSE;
                break;
            case MemoryBad:
                ShrinkPrior = TRUE;
                break;
            default:
                EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: bad memory type in InsertDescriptor\r\n");
                EfiBS->Exit(EfiImageHandle, 0, 0, 0);
        }

        if (ShrinkPrior) {
            //
            // If the prior entry is small enough, we just convert the whole
            // thing to the new type.
            //
            if (PriorEntry->PageCount <= (PAGE_SHIFT - EFI_PAGE_SHIFT)) {
                PriorEntry->PageCount += NumberOfPages;
                PriorEntry->MemoryType = MemoryType;
                
#if DBG
                wsprintf( DebugBuffer, 
                          L"adjust prior descriptor #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n", 
                          NumberDescriptors, 
                          MaxDescriptors, 
                          PriorEntry->BasePage, 
                          PriorEntry->PageCount , 
                          PriorEntry->MemoryType);              
                EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);                
#endif
                return;
            } else {
                //
                // we just steal part of the prior entry.
                //
                PriorEntry->PageCount -= (PAGE_SHIFT - EFI_PAGE_SHIFT);
                NewNumberOfPages += (PAGE_SHIFT - EFI_PAGE_SHIFT);
                NewBasePage -= (PAGE_SHIFT - EFI_PAGE_SHIFT);
                
#if DBG
                wsprintf( DebugBuffer, 
                          L"shrink earlier descriptor #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n", 
                          NumberDescriptors, 
                          MaxDescriptors, 
                          PriorEntry->BasePage, 
                          PriorEntry->PageCount, 
                          PriorEntry->MemoryType);              
                EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif

            }
        } else {
            //
            // If the current entry is small enough, we just convert the whole
            // thing to the prior type.
            //
            if (NumberOfPages <= (PAGE_SHIFT - EFI_PAGE_SHIFT)) {
                PriorEntry->PageCount += NumberOfPages;

#if DBG
                wsprintf( DebugBuffer, 
                          L"adjust prior descriptor #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n", 
                          NumberDescriptors, 
                          MaxDescriptors, 
                          PriorEntry->BasePage, 
                          PriorEntry->PageCount , 
                          PriorEntry->MemoryType);              
                EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
                return;
            } else {
                //
                // we just steal part of the new entry, adding it to the last
                // entry
                //
                PriorEntry->PageCount += (PAGE_SHIFT - EFI_PAGE_SHIFT);
                NewNumberOfPages -= (PAGE_SHIFT - EFI_PAGE_SHIFT);
                NewBasePage += (PAGE_SHIFT - EFI_PAGE_SHIFT);
#if DBG
                wsprintf( DebugBuffer, 
                          L"grow earlier descriptor #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n", 
                          NumberDescriptors, 
                          MaxDescriptors, 
                          PriorEntry->BasePage, 
                          PriorEntry->PageCount, 
                          PriorEntry->MemoryType);
                EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);                                
#endif
            }
        }        
    }

    //
    // we have now adjusted the prior entry, just insert whatever remains
    //

    CurrentEntry->BasePage  = NewBasePage;
    CurrentEntry->PageCount = NewNumberOfPages;
    CurrentEntry->MemoryType = MemoryType;
    NumberDescriptors++;
#if DBG
    wsprintf( DebugBuffer, 
              L"insert new descriptor #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n", 
              NumberDescriptors, 
              MaxDescriptors, 
              CurrentEntry->BasePage, 
              CurrentEntry->PageCount,
              CurrentEntry->MemoryType);              
    EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);    
#endif

    return;
    
}


#if 0

#define DBG_OUT(_X) \
    (EfiST->ConOut->OutputString(EfiST->ConOut, (_X))); \
    while (!BlGetKey());

void DbgOut(PWSTR Str) {
    if (Str)
        DBG_OUT(Str)
}

#endif

#ifdef FORCE_CD_BOOT

void EfiDbg(PWCHAR szStr) {
  DBG_TRACE(szStr);
}

#endif // for FORCE_CD_BOOT



VOID
AdjustMemoryDescriptorSizes(
    VOID
    )
/*++

Routine Description:

    If the EFI_PAGE_SIZE doesn't match PAGE_SIZE, this routine will
    adjust the page sizes to be in PAGE_SIZE resolution.
    
    We assume that the MDArray is already in modulo PAGE_SIZE chunks

Arguments:

    None.

Returns:

    None.  Adjusts MDArray global variable.

--*/
{
    ULONG i;
    MEMORY_DESCRIPTOR *CurrentEntry;
    ULONGLONG Scratch;
    
    for (i = 0; i < NumberDescriptors; i++ ) {
        CurrentEntry = (MEMORY_DESCRIPTOR *)&MDArray[i];

#if 1
        Scratch = (ULONGLONG)CurrentEntry->BasePage << EFI_PAGE_SHIFT;
        Scratch = Scratch >> PAGE_SHIFT;
        CurrentEntry->BasePage = (ULONG)Scratch;
        Scratch = (ULONGLONG)CurrentEntry->PageCount << EFI_PAGE_SHIFT;
        Scratch = Scratch >> PAGE_SHIFT;
        CurrentEntry->PageCount = (ULONG)Scratch;
        if (CurrentEntry->PageCount == 0) {
            wsprintf( DebugBuffer, 
                      L"SuMain: Invalid descriptor size smaller than PAGE_SIZE, BasePage %x, type = %x\r\n", 
                      CurrentEntry->BasePage,
                      CurrentEntry->MemoryType);
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
        }
#else
        CurrentEntry->BasePage = (ULONG)(ULONGLONG)(((ULONGLONG)(CurrentEntry->BasePage << EFI_PAGE_SHIFT)) >> PAGE_SHIFT);
        CurrentEntry->PageCount = (ULONG)((ULONGLONG)(CurrentEntry->PageCount << EFI_PAGE_SHIFT) >> PAGE_SHIFT);
#endif

    }




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\sudata.h ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1991  Microsoft Corporation


Module Name:

    sudata.h

Abstract:

	This file contains definition for ExportEntryTable and AbiosServices
        Table.

Author:

    Allen Kay	(akay)	14-Aug-97

--*/


typedef
VOID
(*PFUNCTION) (
    );

//
// define ntdetect.exe base address
//
#define DETECTION_ADDRESS 0x10000   // NTDETECT base address

//
// Define IO export functions.
//
typedef enum _EXPORT_ENTRY {
    ExRebootProcessor,
    ExGetSector,
    ExGetKey,
    ExGetCounter,
    ExReboot,
    ExAbiosServices,
    ExDetectHardware,
    ExHardwareCursor,
    ExGetDateTime,
    ExComPort,
    ExIsMcaMachine,
    ExGetStallCount,
    ExInitializeDisplayForNt,
    ExGetMemoryDescriptor,
    ExGetEddsSector,
    ExGetElToritoStatus,
    ExGetExtendedInt13Params,
	ExNetPcRomServices,
    ExAPMAttemptReconnect,
    ExBiosRedirectService,
    ExMaximumRoutine
} EXPORT_ENTRY;

//
// Define ABIOS services table.
//
typedef enum _ABIOS_SERVICES {
    FAbiosIsAbiosPresent,
    FAbiosGetMachineConfig,
    FAbiosInitializeSpt,
    FAbiosBuildInitTable,
    FAbiosInitializeDbsFtt,
    FAbiosMaximumRoutine
} ABIOS_SERVICES;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\chksum.s ===
#include "ksia64.h"

        LEAF_ENTRY (ChkSum)

        .prologue
        alloc    t21 = ar.pfs, 3, 0, 0, 0
        .save    ar.lc, t22
        mov      t22 = ar.lc
        zxt4     t3 = a2
        ;;

        cmp4.eq  pt0, pt1 = zero, a2
        add      t7 = 64, a1
        add      t3 = -1, t3
        ;;

(pt1)   ld2.nta  t0 = [a1], 2
        mov      ar.lc = t3
        cmp4.ne  pt2 = 1, a2

        mov      t10 = 0xffff
        zxt4     a0 = a0
(pt0)   br.cond.spnt cs20
        ;;

cs10:
(pt2)   ld2.nta  t4 = [a1], 2
        add      a2 = -1, a2
        add      a0 = t0, a0
        ;;

(pt1)   lfetch.nta [t7], 64
        extr.u   t1 = a0, 16, 16
        and      t2 = a0, t10
        ;;

        cmp4.ne  pt2 = 1, a2
        nop.f    0
        tbit.nz  pt1 = a1, 6
        
        mov      t0 = t4
        add      a0 = t1, t2
        br.cloop.dptk cs10
        ;;
        
cs20:
  
        nop.m    0
        extr.u   t1 = a0, 16, 16
        ;;
        add      a0 = t1, a0
        ;;

        mov      ar.lc = t22
        and      v0 = a0, t10
        br.ret.sptk brp

        LEAF_EXIT (ChkSum)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\flop.h ===
#if defined(NEC_98)
#define BYTE_PER_SECTOR  1024
#define SECTOR_PER_TRACK 8
#define TOTAL_CYLINDER   77
#define HEADS            2
#define MAX_FLOPPY_LEN (BYTE_PER_SECTOR*SECTOR_PER_TRACK*TOTAL_CYLINDER*HEADS)
// #define SCRATCH_BUFFER_SIZE (BYTE_PER_SECTOR * SECTOR_PER_TRACK)
#endif //NEC_98
//
// Optimize this constant so we are guaranteed to be able to transfer
// a whole track at a time from a 1.44 meg disk (sectors/track = 18 = 9K)
//
#define SCRATCH_BUFFER_SIZE 9216

//
// Buffer for temporary storage of data read from the disk that needs
// to end up in a location above the 1MB boundary.
//
// NOTE: it is very important that this buffer not cross a 64k boundary.
//
extern PUCHAR LocalBuffer;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\extern.h ===
/*++

Copyright (c) 1991  Microsoft Corporation


Module Name:

    sudata.h

Abstract:

    This file contains definition for ExportEntryTable and AbiosServices
        Table.

Author:

    Allen Kay   (allen.m.kay@intel.com) 12-Jan-2000

--*/

//
// EFI gloal variables
//

extern EFI_SYSTEM_TABLE        *EfiST;
extern EFI_BOOT_SERVICES       *EfiBS;
extern EFI_RUNTIME_SERVICES    *EfiRS;
extern EFI_HANDLE               EfiImageHandle;

//
// EFI GUID defines
//

extern EFI_GUID EfiLoadedImageProtocol;
extern EFI_GUID EfiDevicePathProtocol;
extern EFI_GUID EfiDeviceIoProtocol;
extern EFI_GUID EfiBlockIoProtocol;
extern EFI_GUID EfiFilesystemProtocol;

extern EFI_GUID MpsTableGuid;
extern EFI_GUID AcpiTableGuid;
extern EFI_GUID SmbiosTableGuid;
extern EFI_GUID SalSystemTableGuid;

//
// Other gloal variables
//
extern PVOID              ExportEntryTable[];
extern PVOID              AcpiTable;

extern ULONGLONG          PalProcVirtual;
extern ULONGLONG          PalPhysicalBase;
extern ULONGLONG          PalTrPs;

extern ULONGLONG          IoPortPhysicalBase;
extern ULONGLONG          IoPortTrPs;


//
// PAL, SAL, and IO port space data
//

typedef
EFI_STATUS
(EFIAPI *PAL_PROC) (
    IN ULONGLONG Index,
    IN ULONGLONG CacheType,
    IN ULONGLONG Invalidate,
    IN ULONGLONG PlatAck
    );

//
// Function Prototypes
//

ULONG
GetDevPathSize(
    IN EFI_DEVICE_PATH *DevPath
    );

BOOLEAN
ConstructMemoryDescriptors(
    );

BOOLEAN
ConstructCacheDescriptors (
    );

VOID
InsertDescriptor (
    );

VOID
FlipToPhysical (
    );

VOID
FlipToVirtual (
    );

VOID
BlInstTransOn (
    );

VOID
PioICacheFlush (
    );

VOID
ReadProcessorConfigInfo (
    PPROCESSOR_CONFIG_INFO ProcessorConfigInfo
    );

VOID
CheckForPreA2Processors(
    );

VOID
EnforcePostB2Processor(
    );

VOID
EnforcePostVersion16PAL(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\halnls.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    halnls.h

Abstract:

    Strings which are used in the HAL

    English

--*/

#define MSG_HARDWARE_ERROR1     "\n*** Hardware Malfunction\n\n"
#define MSG_HARDWARE_ERROR2     "Call your hardware vendor for support\n\n"
#define MSG_HALT                "\n*** The system has halted ***\n"
#define MSG_NMI_PARITY          "NMI: Parity Check / Memory Parity Error\n"
#define MSG_NMI_CHANNEL_CHECK   "NMI: Channel Check / IOCHK\n"
#define MSG_NMI_FAIL_SAFE       "NMI: Fail-safe timer\n"
#define MSG_NMI_BUS_TIMEOUT     "NMI: Bus Timeout\n"
#define MSG_NMI_SOFTWARE_NMI    "NMI: Software NMI generated\n"
#define MSG_NMI_EISA_IOCHKERR   "NMI: Eisa IOCHKERR board %\n"

#define MSG_DEBUG_ENABLE        "Kernel Debugger Using: COM%x (Port 0x%x, Baud Rate %d)\n"
#define MSG_DEBUG_9600          "Switching debugger to 9600 baud\n"
#define MSG_MCE_PENDING         "Machine Check Exception pending, MCE exceptions not enabled\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\i64ioasm.s ===
//	TITLE ("Memory Fences, Load Acquires and Store Acquires")

/*++

    Copyright (c) 1995  Intel Corporation

    Module Name:

     i64ioasm.s assembly routines for read and write I/O  

    Abstract:

     This module implements the I/O port access routines.

    Author:

      Bernard Lint, M. Jayakumar 17 Sep '97

    Environment:

      Kernel mode

    Revision History:

--*/

#include "ksia64.h"

#define HAL_RR_PS_VE 0x69
 
	.file "i64ioasm.s"



/*++

 VOID 
 HalpInsertTranslationRegister (
    IN UINT_PTR  IFA,
    IN ULONG     SlotNumber,
    IN ULONGLONG Attribute,
    IN ULONGLONG ITIR
    ) 


Routine Description:

   This function fills a fixed entry in TR 
 

    N.B.  It is assumed that the entry is not in the TB and therefore the TB 
        is not probed.

Arguements:

    (a0) - Supplies the virtual page number to be loaded into IFA.

    (a1) - Supplies the slot number to be used for Translation Register.

    (a2) - Supplies the attribute and portion of the physical address.

    (a3) - Supplies the value to be loaded into ITIR.


Return Value:

    None.

--*/


         LEAF_ENTRY(HalpInsertTranslationRegister)

         // Register aliases
         //

         rT1 = t3
         rT2 = t4 
 
         rPKR = t13
         rRR = t15 

 
         //	
         // rsm to reset PSR.i bit
         //


         rsm     1 << PSR_I    // reset PSR.i bit
         ;;
         rsm     1 << PSR_IC    // reset PSR.ic bit
         ;;
         srlz.d                 // serialize
    
         //
         // set RR[0],Region ID (HAL_ RID) = 0x7FFFFF,Page Size (PS) = 8K, 
         //  VHPT enabled (VE) = 1
         //  

  
         // dep.z       rRR= RR_IO_PORT, RR_INDEX, RR_INDEX_LEN

         dep.z          rRR = 5, RR_INDEX, RR_INDEX_LEN

         movl           rT2 = (0x7FFFFF << RR_RID) | HAL_RR_PS_VE
         ;;

         mov            rr[rRR] = rT2   // Initialize rr[RR_IOPort]
 

         // Protection Key Registers

         mov            rPKR = PKRNUM    // Total number of key registers
         ;;

         sub            rPKR = rPKR, zero,1 // Choose the last one

         movl           rT2 = (0x7FFFFF << RR_RID) | PKR_VALID
         ;;
  
         mov            pkr[rPKR] = rT2      
         ;;

         srlz.i
         mov cr.ifa   = a0
         mov cr.itir  = a3
         ;;
  
         itr.d dtr[a1]  = a2
         ssm     1 << PSR_IC             // set PSR.ic bit again
         ;;        
         srlz.d                          // serialize
         ssm     1 << PSR_I              // set PSR.i bit again
         LEAF_RETURN

         LEAF_EXIT(HalpInsertTranslationRegister)

/*++

VOID
HalpLoadBufferUCHAR (
   PUCHAR VirtualAddress,
   PUCHAR Buffer,
   UCHAR Count
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpLoadBufferUCHAR)

         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc

         sub a2 = a2,zero,1
         ;;

         PROLOGUE_END
 
         mov ar.lc = a2
         mf

LoadChar:
    
         ld1.acq t1 = [a0]
         ;;
         st1 [a1] = t1, 1
    
         br.cloop.dptk.few LoadChar 
         ;;

         mf.a
         mov ar.lc = t22
         LEAF_RETURN

         LEAF_EXIT (HalpLoadBufferUCHAR)
 

/*++

VOID
HalpLoadBufferUSHORT (
   PUSHORT VirtualAddress,
   PUSHORT Buffer,
   ULONG Count
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpLoadBufferUSHORT)

         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc

         sub a2 = a2,zero,1
         ;;

         PROLOGUE_END
 
         mov ar.lc = a2
         mf
 
LoadShort:
    
         ld2.acq t1 = [a0]
         ;;  
         st2 [a1] = t1, 2 

         br.cloop.dptk.few LoadShort 
         ;;

         mf.a
         mov ar.lc = t22
         LEAF_RETURN

         LEAF_EXIT (HalpLoadBufferUSHORT)
 
/*++

VOID
HalpLoadBufferULONG (
   PULONG VirtualAddress,
   PULONG Buffer,
   ULONG Count 
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpLoadBufferULONG)
    
         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc

         sub a2 = a2,zero,1
         ;;

         PROLOGUE_END
 
         mov ar.lc = a2
         mf
 
LoadLong:
    
         ld4.acq t1 = [a0]
         ;; 
         st4 [a1] = t1, 4

         br.cloop.dptk.few LoadLong 
         ;;

         mf.a
         mov ar.lc = t22
         LEAF_RETURN

         LEAF_EXIT (HalpLoadBufferULONG)
 
/*++

VOID
HalpLoadBufferULONGLONG (
   PULONGLONG VirtualAddress,
   PULONGLONG Buffer,
   ULONG      Count
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpLoadBufferULONGLONG)

         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc

         sub a2 = a2,zero,1
         ;;

         PROLOGUE_END
 
         mov ar.lc = a2
         mf

LoadLongLong:
    
         ld8.acq t1 = [a0]
         ;; 
         st8 [a1] = t1, 8
    
         br.cloop.dptk.few LoadLongLong 
         ;;

         mf.a
         mov ar.lc = t22
         LEAF_RETURN

         LEAF_EXIT (HalpLoadBufferULONGLONG)
 

/*++

VOID
HalpStoreBufferUCHAR (
   PUCHAR VirtualAddress,
   PUCHAR Buffer,
   ULONG Count 
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpStoreBufferUCHAR)

         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc

         sub a2 = a2,zero,1
         ;;

         PROLOGUE_END
 
         mov ar.lc = a2
 
StoreChar:
   
         ld1 t1 = [a1], 1 
         ;;
         st1.rel [a0] = t1 
    
         br.cloop.dptk.few StoreChar 
         ;;

         mf 

         mf.a

         mov ar.lc = t22

         LEAF_RETURN

         LEAF_EXIT (HalpStoreBufferUCHAR)
 
/*++

VOID
HalpStoreBufferUSHORT (
   PUSHORT VirtualAddress,
   PUSHORT Buffer,
   ULONG Count 
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpStoreBufferUSHORT)

         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc
    
         sub a2 = a2,zero,1
         ;;
 
         PROLOGUE_END

         mov ar.lc = a2
 
StoreShort:
    
         ld2 t1 = [a1], 2
         ;;
         st2.rel [a0] = t1 
    
         br.cloop.dptk.few StoreShort 
         ;;

         mf

         mf.a

         mov ar.lc = t22

         LEAF_RETURN

         LEAF_EXIT (HalpStoreBufferUSHORT)
 
/*++

VOID
HalpStoreBufferULONG (
   PULONG VirtualAddress,
   PULONG Buffer,
   ULONG Count 
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpStoreBufferULONG)
    
         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc
    
         sub a2 = a2,zero,1
         ;;

         PROLOGUE_END

         mov ar.lc = a2
 
StoreLong:
    
         ld4.s t1 = [a1],t0
         ;;
         st4.rel [a0] = t1,4 
    
         br.cloop.dptk.few StoreLong 
         ;;

         mf

         mf.a

         mov ar.lc = t22

         LEAF_RETURN

         LEAF_EXIT (HalpStoreBufferULONG)
 
/*++

VOID
HalpStoreBufferULONGLONG (
   PULONGLONG VirtualAddress,
   PULONGLONG Buffer,
   ULONG Count 
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpStoreBufferULONGLONG)

         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc

         sub a2 = a2,zero,1
         ;;

         PROLOGUE_END
 
         mov ar.lc = a2
 
StoreLongLong:
    
         ld8.s t1 = [a1],t0
         ;;
         st8.rel [a0] = t1, 8
    
         br.cloop.dptk.few StoreLongLong 
         ;;

         mf

         mf.a

         mov ar.lc = t22

         LEAF_RETURN

         LEAF_EXIT (HalpStoreBufferULONGLONG)
 

//++
//
// VOID
// ReadCpuLid(VOID);
//
// Routine Description:
//
// This function returns that value of cr.lid for this cpu
//
// Arguements:
//
// Return Value:
//
//    LID register contents
//
//--

         LEAF_ENTRY(ReadCpuLid)

         mov    v0 = cr.lid
         LEAF_RETURN

         LEAF_EXIT(ReadCpuLid)

//++
//
// VOID
// IsPsrDtOn(VOID);
//
// Routine Description:
//
// This function returns the value of cr.dt for this cpu
//
// Arguements:
//
// Return Value:
//
//    cr.dt
//
//--

         LEAF_ENTRY(IsPsrDtOn)

         mov    t0 = psr
         movl   t1 = 1 << PSR_DT
         ;;
         and    t2 = t0, t1
         ;;
         shr.u  v0 = t2, PSR_DT

         LEAF_RETURN

         LEAF_EXIT(IsPsrDtOn)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\i64bios.c ===
/*++

Copyright (c) 1996  Intel Corporation
Copyright (c) 1994  Microsoft Corporation

Module Name:

  i64bios.c  copied from hali64\x86bios.c

Abstract:


    This module implements the platform specific interface between a device
    driver and the execution of x86 ROM bios code for the device.

Author:

    William K. Cheung (wcheung) 20-Mar-1996

    based on the version by David N. Cutler (davec) 17-Jun-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"

//
// Define global data.
//

ULONG HalpX86BiosInitialized = FALSE;
ULONG HalpEnableInt10Calls = FALSE;



ULONG
HalpSetCmosData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/

{
    return 0;
}


ULONG
HalpGetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{
    return 0;
}


VOID
HalpAcquireCmosSpinLock (
    VOID
        )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{ 
    return;
}


VOID
HalpReleaseCmosSpinLock (
    VOID
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/

{
    return ;
}


HAL_DISPLAY_BIOS_INFORMATION
HalpGetDisplayBiosInformation (
    VOID
    )

/*++

Routine Description:


Arguements:


Return Value:

--*/




{
    return 8;
}


VOID
HalpInitializeCmos (
    VOID
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{
    return ;
}


VOID
HalpReadCmosTime (
    PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/

{
    return ;
}

VOID
HalpWriteCmosTime (
    PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{
    return;
}



VOID
HalpBiosDisplayReset (
    VOID
    )

/*++

Routine Description:


Arguements:


Return Value:

--*/

{
    return;
}


VOID
HalpInitializeX86DisplayAdapter(
    VOID
    )

/*++

Routine Description:

    This function initializes a display adapter using the x86 bios emulator.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if 0
    //
    // If I/O Ports or I/O memory could not be mapped, then don't
    // attempt to initialize the display adapter.
    //

    if (HalpIoControlBase == NULL || HalpIoMemoryBase == NULL) {
        return;
    }

    //
    // Initialize the x86 bios emulator.
    //

    x86BiosInitializeBios(HalpIoControlBase, HalpIoMemoryBase);
    HalpX86BiosInitialized = TRUE;

    //
    // Attempt to initialize the display adapter by executing its ROM bios
    // code. The standard ROM bios code address for PC video adapters is
    // 0xC000:0000 on the ISA bus.
    //

    if (x86BiosInitializeAdapter(0xc0000,
                                 NULL,
                                 (PVOID)HalpIoControlBase,
                                 (PVOID)HalpIoMemoryBase) != XM_SUCCESS) {



    HalpEnableInt10Calls = FALSE;
    return;
    }
#endif

    HalpEnableInt10Calls = TRUE;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\haldtect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    detecthw.c

Abstract:

    Routines for determining which drivers/HAL need to be loaded.

Author:

    John Vert (jvert) 20-Oct-1993

Revision History:

--*/
#include "haldtect.h"
#include <stdlib.h>


//
// detection function prototypes
//
#if 0
ULONG   DetectPicACPI_NEC98(PBOOLEAN);
ULONG   DetectMPS_NEC98(PBOOLEAN);
ULONG   DetectUPMPS_NEC98(PBOOLEAN);
ULONG   DetectTmr_NEC98(PBOOLEAN);
ULONG   DetectNonTmr_NEC98(PBOOLEAN);
ULONG   DetectSystemPro(PBOOLEAN);
ULONG   DetectWyse7(PBOOLEAN);
ULONG   NCRDeterminePlatform(PBOOLEAN);
ULONG   Detect486CStep(PBOOLEAN);
ULONG   DetectOlivettiMp(PBOOLEAN);
ULONG   DetectAST(PBOOLEAN);
ULONG   DetectCbusII(PBOOLEAN);
ULONG   DetectMPACPI(PBOOLEAN);
ULONG   DetectApicACPI(PBOOLEAN);
ULONG   DetectPicACPI(PBOOLEAN);
ULONG   DetectUPMPS(PBOOLEAN);
ULONG   DetectMPS(PBOOLEAN);
#endif
ULONG   DetectTrue(PBOOLEAN);

typedef struct _HAL_DETECT_ENTRY {
    INTERFACE_TYPE  BusType;
    ULONG           (*DetectFunction)(PBOOLEAN);
    PCHAR           Shortname;
} HAL_DETECT_ENTRY, *PHAL_DETECT_ENTRY;

HAL_DETECT_ENTRY DetectHal[] = {

#if 0
// First check for a HAL to match some specific hardware.
    Isa,            DetectPicACPI_NEC98,   "nec98acpipic_up",
    Isa,            DetectMPS_NEC98,       "nec98mps_mp",
    Isa,            DetectUPMPS_NEC98,     "nec98mps_up",
    Isa,            DetectTmr_NEC98,       "nec98tmr_up",
    Isa,            DetectNonTmr_NEC98,    "nec98Notmr_up",
    MicroChannel,   NCRDeterminePlatform,  "ncr3x_mp",
    Eisa,           DetectCbusII,          "cbus2_mp",
    Isa,            DetectCbusII,          "cbus2_mp",
    MicroChannel,   DetectCbusII,          "cbusmc_mp",
    Eisa,           DetectMPACPI,          "acpiapic_mp",
    Isa,            DetectMPACPI,          "acpiapic_mp",
    Eisa,           DetectApicACPI,        "acpiapic_up",
    Isa,            DetectApicACPI,        "acpiapic_up",
    Isa,            DetectPicACPI,         "acpipic_up",
    Eisa,           DetectMPS,             "mps_mp",
    Isa,            DetectMPS,             "mps_mp",
    MicroChannel,   DetectMPS,             "mps_mca_mp",
    Eisa,           DetectUPMPS,           "mps_up",
    Isa,            DetectUPMPS,           "mps_up",
    Eisa,           DetectSystemPro,       "syspro_mp", // check SystemPro last

// Before using default HAL make sure we don't need a special one
    Isa,            Detect486CStep,        "486c_up",
    Eisa,           Detect486CStep,        "486c_up",

// Use default hal for given bus type...
    Isa,            DetectTrue,            "e_isa_up",
    Eisa,           DetectTrue,            "e_isa_up",
    MicroChannel,   DetectTrue,            "mca_up",
#endif
    Isa,            DetectTrue,            "acpipic_up",
    Eisa,           DetectTrue,            "acpipic_up",
    MicroChannel,   DetectTrue,            "acpipic_up",
    0,       NULL,                   NULL
};


PCHAR
SlDetectHal(
    VOID
    )

/*++

Routine Description:

    Determines which HAL to load and returns the filename.

Arguments:

    None.

Return Value:

    PCHAR - pointer to the filename of the HAL to be loaded.

--*/

{
    PCONFIGURATION_COMPONENT_DATA Adapter;
    INTERFACE_TYPE BusType;
    BOOLEAN IsMpMachine;
    ULONG i;
    PCHAR MachineShortname;

    //
    // Determine the bus type by searching the ARC configuration tree
    //

    BusType = Isa;

    //
    // Check for Eisa
    //

    Adapter = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                       AdapterClass,
                                       EisaAdapter,
                                       NULL);
    if (Adapter != NULL) {
        BusType = Eisa;
    }

    //
    // Check for MCA
    //

    Adapter = NULL;
    for (; ;) {
        Adapter = KeFindConfigurationNextEntry (
                        BlLoaderBlock->ConfigurationRoot,
                        AdapterClass,
                        MultiFunctionAdapter,
                        NULL,
                        &Adapter
                        );
        if (!Adapter) {
            break;
        }

        if (_stricmp(Adapter->ComponentEntry.Identifier,"MCA")==0) {
            BusType = MicroChannel;
            break;
        }
    }

    //
    // Now go figure out machine and hal type.
    //

    for (i=0;;i++) {
        if (DetectHal[i].DetectFunction == NULL) {
            //
            // We reached the end of the list without
            // figuring it out!
            //
            SlFatalError(i);
            return(NULL);
        }

        if ((DetectHal[i].BusType == BusType) ||
            (DetectHal[i].BusType == Internal)) {

            IsMpMachine = FALSE;
            if ((DetectHal[i].DetectFunction)(&IsMpMachine) != 0) {

                //
                // Found the correct HAL.
                //

                MachineShortname = DetectHal[i].Shortname;
                break;
            }
        }
    }

    return(MachineShortname);
}


ULONG
DetectTrue(
    OUT PBOOLEAN IsMP
)
/*++

Routine Description:

    To Return TRUE

Return Value:

    TRUE

--*/
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\i64ioacc.c ===
/*++

 Copyright (c) 1995  Intel Corporation

 Module Name:

   i64ioacc.c

 Abstract:

   This module implements the I/O Register access routines.

 Author:

    Bernard Lint, M. Jayakumar  Sep 16 '97

 Environment:

    Kernel mode

 Revision History:

--*/




#include "halp.h"
#include "kxia64.h"
 
extern ULONGLONG IoPortPhysicalBase;

ULONGLONG HalpGetPortVirtualAddress(
	UINT_PTR Port
	)
{

/*++

Routine Description:
 
   This routine gives 32 bit virtual address for the I/O Port specified.

Arguements:

   PORT - Supplies PORT address of the I/O PORT.

Returned Value:

   PUCHAR - 32bit virtual address value.

--*/

    // 
    // PUCHAR VirtualIOBase;
    //
   
    UINT_PTR ShiftedPort,PortIndex; 
  
    //
    //  Shifting operation applicable to integrals only. ULONG for 32 bits 
    //

    ShiftedPort = (UINT_PTR)Port;

    //
    //  Limit arguement PORT to 16 bit quantity 
    //

    ShiftedPort =  ShiftedPort & IO_PORT_MASK;

    //
    //  Capture bits [11:0] 
    //
    
    PortIndex   =  ShiftedPort & BYTE_ADDRESS_MASK;

    //
    //  Position it to point to 32 bit boundary
    //

    ShiftedPort =  ShiftedPort & BYTE_ADDRESS_CLEAR;

    //
    //  Shifted to page boundary. ShiftedPORT[[1:0] are zero.
    //  PORT[15:2] shifted to ShiftedPort[25:12]
    //

    ShiftedPort =  ShiftedPort << 10;

    // 
    //  Bits 1:0 has now 4 byte PORT address
    //
 
    ShiftedPort = ShiftedPort | PortIndex;
    
    // return (VIRTUAL_IO_BASE | ShiftedPort);

    //
    // Assume 1-to-to mapping of IO ports.
    //
    if (IsPsrDtOn()) {
        return (VIRTUAL_IO_BASE | ShiftedPort);
    } else {
        return (IoPortPhysicalBase | ShiftedPort | 0x8000000000000000);
    }
}


VOID 
HalpFillTbForIOPortSpace(
   ULONGLONG PhysicalAddress, 
   UINT_PTR  VirtualAddress,
   ULONG     SlotNumber 
   )

 {

/*++

Routine Description:

   This routine fills the translation buffer for the translation requested

Arguements:


   PhysicalAddress - Supplies Physical Address to be mapped for the virtual 
                     address.

   VirtualAddress  - Supplies Virtual Address.


   SlotNumber      - Slot number of the Translation Buffer to be used.

--*/

     ULONGLONG IITR,Attribute;
     UINT_PTR  IFA;
     
     IFA  = VirtualAddress;
   
     IITR = PhysicalAddress & IITR_PPN_MASK;

     IITR  = IITR | (IO_SPACE_SIZE << IDTR_PS);

     Attribute   = PhysicalAddress & IITR_ATTRIBUTE_PPN_MASK;
   
     Attribute   = Attribute   | IO_SPACE_ATTRIBUTE;

     HalpInsertTranslationRegister(IFA,SlotNumber,Attribute,IITR);

     return;
  }
 
UCHAR
READ_PORT_UCHAR(
    PUCHAR Port
    )
{

/*++

Routine Description:

   Reads a byte location from the PORT

Arguements:

   PORT - Supplies the PORT address to read from

Return Value:

   UCHAR - Returns the byte read from the PORT specified.


--*/

    ULONGLONG VirtualPort;
    UCHAR LoadData;
 
    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);
    __mf();
    LoadData = *(volatile UCHAR *)VirtualPort;
    __mfa();

    return (LoadData);
}



USHORT
READ_PORT_USHORT (
    PUSHORT Port
    )
{
 
/*++

Routine Description:

   Reads a word location (16 bit unsigned value) from the PORT

Arguements:

   PORT - Supplies the PORT address to read from. 

Returned Value:

   USHORT - Returns the 16 bit unsigned value from the PORT specified.

--*/

    ULONGLONG VirtualPort;
    USHORT LoadData;
    
    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);
    __mf();
    LoadData = *(volatile USHORT *)VirtualPort;
    __mfa();

    return (LoadData);
}



ULONG
READ_PORT_ULONG (
    PULONG Port
    )
{

/*++

   Routine Description:

      Reads a longword location (32bit unsigned value) from the PORT.

   Arguements:

     PORT - Supplies PORT address to read from. 

   Returned Value:

     ULONG - Returns the 32 bit unsigned value (ULONG) from the PORT specified.

--*/ 

    ULONGLONG VirtualPort;
    ULONG LoadData;

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);
    __mf();
    LoadData = *(volatile ULONG *)VirtualPort;
    __mfa();

    return (LoadData);
}



VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )
{

/*++

   Routine Description:

     Reads multiple bytes from the specified PORT address into the 
     destination buffer.

   Arguements:

     PORT - The address of the PORT to read from.

     Buffer - A pointer to the buffer to fill with the data read from the PORT.

     Count - Supplies the number of bytes to read.

   Return Value:

     None.

--*/


    ULONGLONG VirtualPort;
    
    //
    // PUCHAR ReadBuffer = Buffer;
    //
    //
    // ULONG ReadCount;
    //
 
    VirtualPort =   HalpGetPortVirtualAddress((UINT_PTR)Port); 

    HalpLoadBufferUCHAR((PUCHAR)VirtualPort, Buffer, Count);

}



VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )
{

/*++

    Routine Description:

      Reads multiple words (16bits) from the speicified PORT address into
      the destination buffer.

    Arguements:

      Port - Supplies the address of the PORT to read from.

      Buffer - A pointer to the buffer to fill with the data 
               read from the PORT.
 
      Count  - Supplies the number of words to read.     

--*/

   ULONGLONG VirtualPort;
   
   //
   // PUSHORT ReadBuffer = Buffer;
   // ULONG ReadCount;
   //

   VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port); 

   //
   // We don't need memory fence in between INs?. 
   // So, it is out of the loop to improve performance.
   //

   HalpLoadBufferUSHORT((PUSHORT)VirtualPort, Buffer, Count);

}


VOID
READ_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )
{

 /*++

    Routine Description:

      Reads multiple longwords (32bits) from the speicified PORT 
      address into the destination buffer.

    Arguements:

      Port - Supplies the address of the PORT to read from.

      Buffer - A pointer to the buffer to fill with the data 
               read from the PORT.
 
      Count  - Supplies the number of long words to read.     

--*/

   ULONGLONG VirtualPort;
   PULONG ReadBuffer = Buffer;
   ULONG ReadCount;
 
 
   VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port); 

   //  
   // We don't need memory fence in between INs. 
   // So, it is out of the loop to improve performance.
   //

   HalpLoadBufferULONG((PULONG)VirtualPort, Buffer,Count);

}

VOID
WRITE_PORT_UCHAR (
    PUCHAR Port,
    UCHAR  Value
    )
{
 
/*++

   Routine Description:

      Writes a byte to the Port specified.

   Arguements:

      Port - The port address of the I/O Port.
 
      Value - The value to be written to the I/O Port.

   Return Value:

      None.

--*/ 
  
    ULONGLONG VirtualPort;

    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port); 
    *(volatile UCHAR *)VirtualPort = Value;
    __mf();
    __mfa();
}

VOID
WRITE_PORT_USHORT (
    PUSHORT Port,
    USHORT  Value
    )
{
 
/*++

   Routine Description:

      Writes a 16 bit SHORT Integer to the Port specified.

   Arguements:

      Port - The port address of the I/O Port.
 
      Value - The value to be written to the I/O Port.

   Return Value:

      None.

--*/ 
  
    ULONGLONG VirtualPort;

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port); 
    *(volatile USHORT *)VirtualPort = Value;
    __mf();
    __mfa();
}


VOID
WRITE_PORT_ULONG (
    PULONG Port,
    ULONG  Value
    )
{
 
/*++

   Routine Description:

      Writes a 32 bit Long Word to the Port specified.

   Arguements:

      Port - The port address of the I/O Port.
 
      Value - The value to be written to the I/O Port.

   Return Value:

      None.

--*/ 
  
    ULONGLONG VirtualPort;

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port); 
    *(volatile ULONG *)VirtualPort = Value;
    __mf();
    __mfa();
}



VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG   Count
    )
{

/*++

   Routine Description:

     Writes multiple bytes from the source buffer to the specified Port address.

   Arguements:

     Port  - The address of the Port to write to.

     Buffer - A pointer to the buffer containing the data to write to the Port.

     Count - Supplies the number of bytes to write.

   Return Value:

     None.

--*/


   ULONGLONG VirtualPort; 
   PUCHAR WriteBuffer = Buffer;
   ULONG WriteCount;

   VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);

   HalpStoreBufferUCHAR((PUCHAR)VirtualPort,Buffer,Count);

}


VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    )
{

/*++

   Routine Description:

     Writes multiple 16bit short integers from the source buffer to the specified Port address.

   Arguements:

     Port  - The address of the Port to write to.

     Buffer - A pointer to the buffer containing the data to write to the Port.

     Count - Supplies the number of (16 bit) words to write.

   Return Value:

     None.

--*/


   ULONGLONG VirtualPort; 
   PUSHORT WriteBuffer = Buffer;
   ULONG WriteCount;

   VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);
   
   
   HalpStoreBufferUSHORT((PUSHORT)VirtualPort,Buffer, Count);

}

VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG   Count
    )
{

/*++

   Routine Description:

     Writes multiple 32bit long words from the source buffer to the specified Port address.

   Arguements:

     Port  - The address of the Port to write to.

     Buffer - A pointer to the buffer containing the data to write to the Port.

     Count - Supplies the number of (32 bit) long words to write.

   Return Value:

     None.

--*/


   ULONGLONG VirtualPort; 
   PULONG WriteBuffer = Buffer;
   ULONG WriteCount;

   VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);

   HalpStoreBufferULONG((PULONG)VirtualPort,Buffer, Count); 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\ixbusdat.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixbusdat.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

Environment:

    Kernel mode

Revision History:


--*/

#include "bootia64.h"
#include "arc.h"
#include "ixfwhal.h"
#if defined(NEC_98)
#include "nec98.h"
#else  //NEC_98
#include "eisa.h"
#endif //NEC_98
#include "mca.h"
#include "ntconfig.h"

#if defined(NEC_98)
#else
ULONG
HalpGetCmosData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

ULONG
HalpGetPosData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpGetEisaData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );
#endif //!NEC_98

ULONG
HalpGetPCIData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpSetPCIData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpAssignPCISlotResources (
    IN ULONG                    BusNumber,
    IN ULONG                    Slot,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

/*
 *
 * Router functions.  Routes each call to specific handler
 *
 */


ULONG
HalGetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalGetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalGetBusDataByOffset (
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for GetBusData

--*/
{
    switch (BusDataType) {
#if defined(NEC_98)
#else
        case Cmos:
            if (Offset != 0) {
                return 0;
            }

            return HalpGetCmosData(BusNumber, Slot, Buffer, Length);

        case Pos:
            return HalpGetPosData(BusNumber, Slot, Buffer, Offset, Length);

        case EisaConfiguration:
            return HalpGetEisaData(BusNumber, Slot, Buffer, Offset, Length);
#endif //NEC_98

        case PCIConfiguration:
            return HalpGetPCIData(BusNumber, Slot, Buffer, Offset, Length);
    }
    return 0;
}

ULONG
HalSetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalSetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for SetBusData

--*/
{
    switch (BusDataType) {
        case PCIConfiguration:
            return HalpSetPCIData(BusNumber, Slot, Buffer, Offset, Length);
    }
    return 0;
}


NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    Dispatcher for AssignSlotResources

--*/
{
    switch (BusType) {
        case PCIBus:
            return HalpAssignPCISlotResources (
                        BusNumber,
                        SlotNumber,
                        AllocatedResources
                        );
        default:
            break;
    }
    return STATUS_NOT_FOUND;
}





/**
 **
 ** Standard PC bus functions
 **
 **/



BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusNumber          - Supplies the bus number.  This is ignored on
                         standard x86 systems

    BusAddress         - Supplies the bus-relative address

    AddressSpace       - Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => I/O space
                         AddressSpace == 1 => memory space

    TranslatedAddress - Pointer to a physical_address.

Return Value:

    System physical address corresponding to the supplied bus relative
    address and bus address number.

--*/

{
    TranslatedAddress->HighPart = 0;
    TranslatedAddress->LowPart = BusAddress.LowPart;
    return(TRUE);
}

#if defined(NEC_98)
#else
ULONG
HalpGetPosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG DOffset,
    IN ULONG Length
    )
/*--

Arguments:

    BusDataType - Supplies the type of bus.

    BusNumber - Indicates which bus.

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/
{
    PVOID McaRegisterBase = 0;
    ULONG Index = 0;
    PUCHAR DataBuffer = Buffer;
    ULONG DataLength = 0;
    PUCHAR PosBase;
    ULONG Offset;

    if (DOffset != 0  ||  MachineType != MACHINE_TYPE_MCA) {
        return 0;
    }

    PosBase = (PUCHAR) &((PMCA_CONTROL) McaRegisterBase)->Pos;

    //
    //  Place the specified adapter into setup mode.
    //

    WRITE_PORT_UCHAR((PVOID) &((PMCA_CONTROL) McaRegisterBase)->AdapterSetup,
                     (UCHAR) ( MCA_ADAPTER_SETUP_ON | SlotNumber ));

    while (DataLength < Length && DataLength < 6) {
        DataBuffer[DataLength] = READ_PORT_UCHAR( PosBase + DataLength );
        DataLength++;
    }

    while (DataLength < Length) {

        WRITE_PORT_UCHAR((PVOID) &((PPROGRAMMABLE_OPTION_SELECT)
            PosBase)->SubaddressExtensionLsb, (UCHAR) Index);

        WRITE_PORT_UCHAR((PVOID) &((PPROGRAMMABLE_OPTION_SELECT)
            PosBase)->SubaddressExtensionMsb, (UCHAR) (Index >> 8));

        DataBuffer[Index + 6] = READ_PORT_UCHAR(
            (PVOID) &((PPROGRAMMABLE_OPTION_SELECT)PosBase)->OptionSelectData2);

        DataLength++;

        if (DataLength < Length) {
            Offset = DataLength + ((Length - DataLength) / 2);
            DataBuffer[Offset] = READ_PORT_UCHAR(
                (PVOID) &((PPROGRAMMABLE_OPTION_SELECT)PosBase)->OptionSelectData3);
            DataLength++;
            Index++;
        }
    }

    //
    //  Disable adapter setup.
    //

    WRITE_PORT_UCHAR((PVOID) &((PMCA_CONTROL) McaRegisterBase)->AdapterSetup,
                     (UCHAR) ( MCA_ADAPTER_SETUP_OFF ));
    return 1;
}

ULONG
HalpGetEisaData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*--

Arguments:

    BusDataType - Supplies the type of bus.

    BusNumber - Indicates which bus.

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/
{

    ULONG DataLength = 0;
    ULONG i;
    ULONG TotalDataSize;
    ULONG SlotDataSize;
    ULONG PartialCount;
    ULONG Index = 0;
    PUCHAR DataBuffer = Buffer;
    PCONFIGURATION_COMPONENT_DATA ConfigData;
    PCM_EISA_SLOT_INFORMATION SlotInformation;
    PCM_PARTIAL_RESOURCE_LIST Descriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResource;
    BOOLEAN Found = FALSE;

    if (MachineType != MACHINE_TYPE_EISA) {
        return 0;
    }

    ConfigData = KeFindConfigurationEntry(
        FwConfigurationTree,
        AdapterClass,
        EisaAdapter,
        NULL
        );

    if (ConfigData == NULL) {
#if defined(ENABLE_LOADER_EBUG) 
        DbgPrint("HalGetBusData: KeFindConfigurationEntry failed\n");
#endif
        return(0);
    }

    Descriptor = ConfigData->ConfigurationData;
    PartialResource = Descriptor->PartialDescriptors;
    PartialCount = Descriptor->Count;

    for (i = 0; i < PartialCount; i++) {

        //
        // Do each partial Resource
        //

        switch (PartialResource->Type) {
            case CmResourceTypeNull:
            case CmResourceTypePort:
            case CmResourceTypeInterrupt:
            case CmResourceTypeMemory:
            case CmResourceTypeDma:

                //
                // We dont care about these.
                //

                PartialResource++;

                break;

            case CmResourceTypeDeviceSpecific:

                //
                // Bingo!
                //

                TotalDataSize = PartialResource->u.DeviceSpecificData.DataSize;

                SlotInformation = (PCM_EISA_SLOT_INFORMATION)
                                    ((PUCHAR)PartialResource +
                                     sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                while (((LONG)TotalDataSize) > 0) {

                    if (SlotInformation->ReturnCode == EISA_EMPTY_SLOT) {

                        SlotDataSize = sizeof(CM_EISA_SLOT_INFORMATION);

                    } else {

                        SlotDataSize = sizeof(CM_EISA_SLOT_INFORMATION) +
                                  SlotInformation->NumberFunctions *
                                  sizeof(CM_EISA_FUNCTION_INFORMATION);
                    }

                    if (SlotDataSize > TotalDataSize) {

                        //
                        // Something is wrong again
                        //

#if defined(ENABLE_LOADER_EBUG) 
                        DbgPrint("HalGetBusData: SlotDataSize > TotalDataSize\n");
#endif

                        return(0);

                    }

                    if (SlotNumber != 0) {

                        SlotNumber--;

                        SlotInformation = (PCM_EISA_SLOT_INFORMATION)
                            ((PUCHAR)SlotInformation + SlotDataSize);

                        TotalDataSize -= SlotDataSize;

                        continue;

                    }

                    //
                    // This is our slot
                    //

                    Found = TRUE;
                    break;

                }

                //
                // End loop
                //

                i = PartialCount;

                break;

            default:

#if defined(ENABLE_LOADER_EBUG) 
                DbgPrint("Bad Data in registry!\n");
#endif

                return(0);

        }

    }

    if (Found) {

        //
        // As a hack if the length is zero then the buffer points to a
        // PVOID where the pointer to the data should be stored.  This is
        // done in the loader because we quickly run out of heap scaning
        // all of the EISA configuration data.
        //

        if (Length == 0) {

            //
            // Return the pointer to the mini-port driver.
            //

            *((PVOID *)Buffer) = SlotInformation;
            return(SlotDataSize);
        }

        i = Length + Offset;
        if (i > SlotDataSize) {
            i = SlotDataSize;
        }

        DataLength = i - Offset;
        RtlMoveMemory(Buffer, ((PUCHAR) SlotInformation + Offset), DataLength);
    }

    return(DataLength);
}
#endif //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\halp.h ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    halp.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    interfaces, defines and structures.

Author:

    John Vert (jvert) 11-Feb-92


Revision History:

--*/
#ifndef _HALP_H_
#define _HALP_H_

#include "nthal.h"
#include "hal.h"

#define IPI_VECTOR 0xE1

#include "halnls.h"

#if 0
#ifndef _HALI_
#include "..\inc\hali.h"
#endif
#endif

#define HAL_MAXIMUM_PROCESSOR 0x20

/*
 * Default clock and profile timer intervals (in 100ns-unit)
 */
#define DEFAULT_CLOCK_INTERVAL 100000         // 10  ms
#define MINIMUM_CLOCK_INTERVAL 10000          //  1  ms
#define MAXIMUM_CLOCK_INTERVAL 100000         // 10  ms

//
// Define Realtime Clock register numbers.
//

#define RTC_SECOND 0                    // second of minute [0..59]
#define RTC_SECOND_ALARM 1              // seconds to alarm
#define RTC_MINUTE 2                    // minute of hour [0..59]
#define RTC_MINUTE_ALARM 3              // minutes to alarm
#define RTC_HOUR 4                      // hour of day [0..23]
#define RTC_HOUR_ALARM 5                // hours to alarm
#define RTC_DAY_OF_WEEK 6               // day of week [1..7]
#define RTC_DAY_OF_MONTH 7              // day of month [1..31]
#define RTC_MONTH 8                     // month of year [1..12]
#define RTC_YEAR 9                      // year [00..99]
#define RTC_CONTROL_REGISTERA 10        // control register A
#define RTC_CONTROL_REGISTERB 11        // control register B
#define RTC_CONTROL_REGISTERC 12        // control register C
#define RTC_CONTROL_REGISTERD 13        // control register D
#define RTC_REGNUMBER_RTC_CR1 0x6A      // control register 1



#define RTC_ISA_ADDRESS_PORT   0x070
 
#define RTC_ISA_DATA_PORT      0x071

extern PVOID HalpRtcAddressPort;

extern PVOID HalpRtcDataPort;

extern PLOADER_PARAMETER_BLOCK KeLoaderBlock; 

//
// Define Control Register A structure.
//

typedef struct _RTC_CONTROL_REGISTER_A {
    UCHAR RateSelect : 4;
    UCHAR TimebaseDivisor : 3;
    UCHAR UpdateInProgress : 1;
} RTC_CONTROL_REGISTER_A, *PRTC_CONTROL_REGISTER_A;

//
// Define Control Register B structure.
//

typedef struct _RTC_CONTROL_REGISTER_B {
    UCHAR DayLightSavingsEnable : 1;
    UCHAR HoursFormat : 1;
    UCHAR DataMode : 1;
    UCHAR SquareWaveEnable : 1;
    UCHAR UpdateInterruptEnable : 1;
    UCHAR AlarmInterruptEnable : 1;
    UCHAR TimerInterruptEnable : 1;
    UCHAR SetTime : 1;
} RTC_CONTROL_REGISTER_B, *PRTC_CONTROL_REGISTER_B;

//
// Define Control Register C structure.
//

typedef struct _RTC_CONTROL_REGISTER_C {
    UCHAR Fill : 4;
    UCHAR UpdateInterruptFlag : 1;
    UCHAR AlarmInterruptFlag : 1;
    UCHAR TimeInterruptFlag : 1;
    UCHAR InterruptRequest : 1;
} RTC_CONTROL_REGISTER_C, *PRTC_CONTROL_REGISTER_C;

//
// Define Control Register D structure.
//

typedef struct _RTC_CONTROL_REGISTER_D {
    UCHAR Fill : 7;
    UCHAR ValidTime : 1;
} RTC_CONTROL_REGISTER_D, *PRTC_CONTROL_REGISTER_D;




#define EISA_DMA_CHANNELS 8

extern UCHAR HalpDmaChannelMasks[];

//
// HalpOwnedDisplayBeforeSleep is defined in mpdat.c
//

extern BOOLEAN HalpOwnedDisplayBeforeSleep;

#define PIC_VECTORS 16

#define PRIMARY_VECTOR_BASE  0x30

/*
 * PCR address.
 * Temporary macros; should already be defined in ntddk.h for IA64
 */

#define PCR ((volatile KPCR * const)KIPCR)

#ifndef NEC_98

#define PIC_SLAVE_IRQ      2
#define PIC_SLAVE_REDIRECT 9
#else
#define PIC_SLAVE_IRQ      7
#define PIC_SLAVE_REDIRECT 8
#endif  //NEC_98

extern PVOID HalpSleepPageLock;
 
KIRQL
KfAcquireSpinLock (
   PKSPIN_LOCK SpinLock
    );

VOID
KfReleaseSpinLock (
   IN PKSPIN_LOCK SpinLock,
   IN KIRQL       NewIrql
   );

VOID
KeSetAffinityThread (
   PKTHREAD       Thread,
   KAFFINITY      HalpActiveProcessors
   );

KIRQL
KfRaiseIrql (
    KIRQL  NewIrql
    );

VOID
KfLowerIrql (
    KIRQL  NewIrql
    );

extern BOOLEAN
KdPollBreakIn (
    VOID
    );


VOID
HalpSavePicState (
    VOID
    );

VOID
HalpSaveDmaControllerState (
    VOID
    );


NTSTATUS
HalAllocateAdapterChannel (
    IN PADAPTER_OBJECT AdapterObject,
    IN PWAIT_CONTEXT_BLOCK Wcb,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine
    );

ULONG
HalReadDmaCounter (
   IN PADAPTER_OBJECT AdapterObject
   );


VOID
HalpSaveTimerState (
    VOID
    );

VOID
HalpRestorePicState (
    VOID
    );

VOID
HalpRestoreDmaControllerState (
    VOID
    );

VOID
HalpRestoreTimerState (
    VOID
    );

BOOLEAN
HalpIoSapicInitialize (
    VOID
    );

BOOLEAN
IsPsrDtOn (
    VOID
    );

BOOLEAN
HalpIoSapicConnectInterrupt (
    KIRQL Irql,
    IN ULONG Vector 
    );

NTSTATUS
HalacpiGetInterruptTranslator(
        IN INTERFACE_TYPE ParentInterfaceType,
        IN ULONG ParentBusNumber,
        IN INTERFACE_TYPE BridgeInterfaceType,
        IN USHORT Size,
        IN USHORT Version,
        OUT PTRANSLATOR_INTERFACE Translator,
        OUT PULONG BridgeBusNumber
        );

#ifdef notyet

typedef struct {
    UCHAR   MasterMask;
    UCHAR   SlaveMask;
    UCHAR   MasterEdgeLevelControl;
    UCHAR   SlaveEdgeLevelControl;
} PIC_CONTEXT, *PPIC_CONTEXT;

#define EISA_DMA_CHANNELS 8

typedef struct {
    UCHAR           Dma1ExtendedModePort;
    UCHAR           Dma2ExtendedModePort;
    DMA1_CONTROL    Dma1Control;
    DMA2_CONTROL    Dma2Control;
} DMA_CONTEXT, *PDMA_CONTEXT;

typedef struct {
    UCHAR   nothing;
} TIMER_CONTEXT, *PTIMER_CONTEXT;

typedef struct {
    PIC_CONTEXT     PicState;
    DMA_CONTEXT     DmaState;
} MOTHERBOARD_CONTEXT, *PMOTHERBOARD_CONTEXT;

extern MOTHERBOARD_CONTEXT  HalpMotherboardState;
extern UCHAR                HalpDmaChannelModes[];
extern PVOID                HalpSleepPageLock;
extern UCHAR                HalpDmaChannelMasks[];
extern BOOLEAN              HalpOwnedDisplayBeforeSleep;

#endif //notyet

VOID
HalpGetProcessorIDs (
   VOID
          );

VOID
HalpInitializeInterrupts (
    VOID
    );


VOID
HalInitializeProcessor (
     ULONG Number,
     PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpGetParameters (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
     );


VOID
HalpClearClock (
      VOID
     );


VOID
HalpClockInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
HalpClockInterruptPn(
   IN PKINTERRUPT_ROUTINE Interrupt,
   IN PKTRAP_FRAME TrapFrame  
  );



UCHAR
HalpReadClockRegister (
    UCHAR Register
    );

VOID
HalpWriteClockRegister (
    UCHAR Register,
    UCHAR Value
    );

// extern VOID
// HalpProfileInterrupt (
//    IN PKTRAP_FRAME TrapFrame
//    );

ULONGLONG
HalpReadIntervalTimeCounter (
    VOID
    );


VOID
HalpProgramIntervalTimerVector(
    ULONGLONG  IntervalTimerVector
          );

VOID
HalpClearITC (
    VOID );

VOID
HalpInitializeClock  (
    VOID
    );

VOID
HalpInitializeClockPn (
    VOID
    );

VOID
HalpInitializeClockInterrupts(
    VOID
    );

VOID
HalpSetInitialClockRate (
    VOID
    );

VOID
HalpInitializeTimerResolution (
    ULONG Rate
    );


VOID
HalpUpdateITM (
    IN ULONGLONG NewITMValue
    );

VOID
HalpSendIPI (
    IN USHORT ProcessorID,
    IN ULONGLONG Data
    );

VOID
HalpOSRendez (
    IN USHORT ProcessorID
    );

//
// Prototype for system bus handlers
//

NTSTATUS
HalpQuerySimBusSlots (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG                BufferSize,
    OUT PULONG              SlotNumbers,
    OUT PULONG              ReturnedLength
    );

ULONG
HalpGetSimBusInterruptVector (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

BOOLEAN
HalpTranslateSimBusAddress (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

VOID
HalpRegisterSimBusHandler (
    VOID
    );

ULONG
HalpGetSimBusData(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpSetSimBusData(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpAssignSimBusSlotResources (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

NTSTATUS
HalpAdjustSimBusResourceList (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

PDEVICE_HANDLER_OBJECT
HalpReferenceSimDeviceHandler (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN ULONG                SlotNumber
    );

NTSTATUS
HalpSimDeviceControl (
    IN PHAL_DEVICE_CONTROL_CONTEXT Context
    );

ULONG
HalGetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

ULONG
HalSetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

NTSTATUS
HalpHibernateHal (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler
    );

NTSTATUS
HalpResumeHal (
    IN PBUS_HANDLER  BusHandler,
    IN PBUS_HANDLER  RootHandler
    );


ULONG
HalpGetFeatureBits (
    VOID
    );

VOID
HalpInitMP(
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

#ifdef RtlMoveMemory
#undef RtlMoveMemory
#undef RtlCopyMemory
#undef RtlFillMemory
#undef RtlZeroMemory

#define RtlCopyMemory(Destination,Source,Length) RtlMoveMemory((Destination),(Source),(Length))
VOID
RtlMoveMemory (
   PVOID Destination,
   CONST VOID *Source,
   ULONG Length
   );

VOID
RtlFillMemory (
   PVOID Destination,
   ULONG Length,
   UCHAR Fill
   );

VOID
RtlZeroMemory (
   PVOID Destination,
   ULONG Length
   );

#endif


#if 0
#include "ixisa.h"
#endif

//
// Define map register translation entry structure.
//

typedef struct _TRANSLATION_ENTRY {
    PVOID VirtualAddress;
    ULONG PhysicalAddress;
    ULONG Index;
} TRANSLATION_ENTRY, *PTRANSLATION_ENTRY;

//
//


typedef struct _PcMpIoApicEntry  {
    UCHAR EntryType;
    UCHAR IoApicId;
    UCHAR IoApicVersion;
    UCHAR IoApicFlag;
    PVOID IoApicAddress;
} PCMPIOAPIC, *PPCMPIOAPIC;

//
// MP_INFO is defined in pcmp_nt.inc
//

// typedef struct _MP_INFO {
//    ULONG ApicVersion;      // 82489Dx or Not
//    ULONG ProcessorCount;   // Number of Enabled Processors
//    ULONG NtProcessors;     // Number of Running Processors
//    ULONG BusCount;         // Number of buses in system
//    ULONG IOApicCount;      // Number of Io Apics in system
//    ULONG IntiCount;        // Number of Io Apic interrupt input entries
//    ULONG LintiCount;       // Number of Local Apic interrupt input entries
//    ULONG IMCRPresent;      // Indicates if the IMCR is present
//    ULONG LocalApicBase;    // Base of local APIC
//    PULONG IoApicBase;     // The virtual addresses of the IoApic
//    PPCMPIOAPIC IoApicEntryPtr; // Ptr to 1st PC+MP IoApic entry 
//    ULONG  IoApicPhys[];        // The physical addresses of the IoApi

//}MP_INFO, *PMP_INFO;


extern USHORT LOCAL_ID[];

#define VECTOR_SIZE     8
#define IPI_ID_SHIFT    4
#define IpiTOKEN_SHIFT  20
#define IpiTOKEN    0xFFE

#define EID_MASK        0xFF00

#define OS_RENDEZ_VECTOR  0x11

#define RENDEZ_TIME_OUT  0X0FFFFFFFF

//
// Some devices require a phyicially contiguous data buffers for DMA transfers.
// Map registers are used give the appearance that all data buffers are
// contiguous.  In order to pool all of the map registers a master
// adapter object is used.  This object is allocated and saved internal to this
// file.  It contains a bit map for allocation of the registers and a queue
// for requests which are waiting for more map registers.  This object is
// allocated during the first request to allocate an adapter which requires
// map registers.
//
// In this system, the map registers are translation entries which point to
// map buffers.  Map buffers are physically contiguous and have physical memory
// addresses less than 0x01000000.  All of the map registers are allocated
// initialially; however, the map buffers are allocated base in the number of
// adapters which are allocated.
//
// If the master adapter is NULL in the adapter object then device does not
// require any map registers.
//

extern PADAPTER_OBJECT MasterAdapterObject;

extern POBJECT_TYPE *IoAdapterObjectType;

extern BOOLEAN LessThan16Mb;

extern BOOLEAN HalpEisaDma;

//
// Map buffer prameters.  These are initialized in HalInitSystem
//

extern PHYSICAL_ADDRESS HalpMapBufferPhysicalAddress;
extern ULONG HalpMapBufferSize;

extern ULONG HalpBusType;
extern ULONG HalpCpuType;
extern UCHAR HalpSerialLen;
extern UCHAR HalpSerialNumber[];

//
// The following macros are taken from mm\ia64\miia64.h.  We need them here
// so the HAL can map its own memory before memory-management has been
// initialized, or during a BugCheck.
//
// MiGetPdeAddress returns the address of the PDE which maps the
// given virtual address.
//

#if defined(_WIN64)

#define ADDRESS_BITS 64

#define NT_ADDRESS_BITS 32

#define NT_ADDRESS_MASK (((UINT_PTR)1 << NT_ADDRESS_BITS) -1)

#define MiGetPdeAddress(va) \
   ((PHARDWARE_PTE)(((((UINT_PTR)(va) & NT_ADDRESS_MASK) >> PDI_SHIFT) << PTE_SHIFT) + PDE_BASE))

#define MiGetPteAddress(va) \
   ((PHARDWARE_PTE)(((((UINT_PTR)(va) & NT_ADDRESS_MASK) >> PAGE_SHIFT) << PTE_SHIFT) + PTE_BASE))

#else

#define MiGetPdeAddress(va)  ((PHARDWARE_PTE)(((((ULONG)(va)) >> 22) << 2) + PDE_BASE))

//
// MiGetPteAddress returns the address of the PTE which maps the
// given virtual address.
//

#define MiGetPteAddress(va) ((PHARDWARE_PTE)(((((ULONG)(va)) >> 12) << 2) + PTE_BASE))

#endif // defined(_WIN64)

//
// Resource usage information
//

#pragma pack(1)
typedef struct {
    UCHAR   Flags;
    KIRQL   Irql;
    UCHAR   BusReleativeVector;
} IDTUsage;

typedef struct _HalAddressUsage{
    struct _HalAddressUsage *Next;
    CM_RESOURCE_TYPE        Type;       // Port or Memory
    UCHAR                   Flags;      // same as IDTUsage.Flags
    struct {
        ULONG   Start;
        ULONG   Length;
    }                       Element[];
} ADDRESS_USAGE;
#pragma pack()

//
// Added the following line
//

#define MAXIMUM_IDTVECTOR   0x0FF

//
// The following 3 lines are lifted from halp.h of halia64 directory 
// to clear the build error from i64timer.c
//

#define DEFAULT_CLOCK_INTERVAL 100000         // 10  ms
#define MINIMUM_CLOCK_INTERVAL 10000          //  1  ms
#define MAXIMUM_CLOCK_INTERVAL 100000         // 10  ms

// IO Port emulation defines 

#define IO_PORT_MASK 0x0FFFF;
#define BYTE_ADDRESS_MASK 0x00FFF;
#define BYTE_ADDRESS_CLEAR 0x0FFFC;

// #define ExtVirtualIOBase   0xFFFFFFFFFFC00000

   // #define VirtualIOBase      0xFFFFFFFFFFC00000i64
#define VirtualIOBase      (UINT_PTR)(KADDRESS_BASE+0xFFC00000)

// extern VOID *VirtualIOBase;


// #define PhysicalIOBase   0x80000000FFC00000i64
#define PhysicalIOBase     0x00000FFFFC000000i64

#define IDTOwned            0x01        // IDT is not available for others
#define InterruptLatched    0x02        // Level or Latched
#define InternalUsage       0x11        // Report usage on internal bus
#define DeviceUsage         0x21        // Report usage on device bus

extern IDTUsage         HalpIDTUsage[];
extern ADDRESS_USAGE   *HalpAddressUsageList;

#define HalpRegisterAddressUsage(a) \
    (a)->Next = HalpAddressUsageList, HalpAddressUsageList = (a);


VOID
HalpInsertTranslationRegister (
    IN UINT_PTR  IFA,
    IN ULONG     SlotNumber,
    IN ULONGLONG Attribute,
    IN ULONGLONG ITIR
    );

VOID
HalpFillTbForIOPortSpace (
    ULONGLONG PhysicalAddress,
    UINT_PTR  VirtualAddress,
    ULONG     SlotNumber
    );


//
// Temp definitions to thunk into supporting new bus extension format
//

VOID
HalpRegisterInternalBusHandlers (
    VOID
    );

PBUS_HANDLER
HalpAllocateBusHandler (
    IN INTERFACE_TYPE   InterfaceType,
    IN BUS_DATA_TYPE    BusDataType,
    IN ULONG            BusNumber,
    IN INTERFACE_TYPE   ParentBusDataType,
    IN ULONG            ParentBusNumber,
    IN ULONG            BusSpecificData
    );

#define HalpHandlerForBus   HaliHandlerForBus
#define HalpSetBusHandlerParent(c,p)    (c)->ParentHandler = p;

//
// Define function prototypes.
//

VOID
HalInitSystemPhase2(
    VOID
    );

KIRQL
HaliRaiseIrqlToDpcLevel (
   VOID
   );

BOOLEAN
HalpGrowMapBuffers(
    PADAPTER_OBJECT AdapterObject,
    ULONG Amount
    );

PADAPTER_OBJECT
HalpAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID MapRegisterBase
    );

VOID
HalpDisableAllInterrupts (
    VOID
    );

VOID
HalpProfileInterrupt(
    IN PKTRAP_FRAME TrapFrame 
    );

VOID
HalpInitializeClock(
    VOID
    );

VOID
HalpInitializeDisplay(
    VOID
    );

VOID
HalpInitializeStallExecution(
    IN CCHAR ProcessorNumber
    );

VOID
HalpRemoveFences (
    VOID
    );

VOID
HalpInitializePICs(
    VOID
    );

VOID
HalpIrq13Handler (
    VOID
   );

VOID
HalpFlushTLB (
    VOID
    );

VOID
HalpSerialize (
    VOID
    );


PVOID
HalMapPhysicalMemory(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    );


PVOID
HalpMapPhysicalMemory(
    IN PVOID PhysicalAddress,
    IN ULONG NumberPages
    );

PVOID
HalpMapPhysicalMemoryWriteThrough(
    IN PVOID  PhysicalAddress,
    IN ULONG  NumberPages
    );

ULONG
HalpAllocPhysicalMemory(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG MaxPhysicalAddress,
    IN ULONG NoPages,
    IN BOOLEAN bAlignOn64k
    );

VOID
HalpBiosDisplayReset(
    IN VOID
    );

HAL_DISPLAY_BIOS_INFORMATION
HalpGetDisplayBiosInformation (
    VOID
    );

VOID
HalpDisplayDebugStatus(
    IN PUCHAR   Status,
    IN ULONG    Length
    );

VOID
HalpInitializeCmos (
   VOID
   );

VOID
HalpReadCmosTime (
   PTIME_FIELDS TimeFields
   );

VOID
HalpWriteCmosTime (
   PTIME_FIELDS TimeFields
   );

VOID
HalpAcquireCmosSpinLock (
    VOID
    );

VOID
HalpReleaseCmosSpinLock (
    VOID
    );

VOID
HalpResetAllProcessors (
    VOID
    );

VOID
HalpCpuID (
    ULONG   InEax,
    PULONG  OutEax,
    PULONG  OutEbx,
    PULONG  OutEcx,
    PULONG  OutEdx
    );

ULONGLONG
FASTCALL
RDMSR (
    IN ULONG MsrAddress
    );

VOID
WRMSR (
    IN ULONG        MsrAddress,
    IN ULONGLONG    MsrValue
    );

VOID
HalpEnableInterruptHandler (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql,
    IN VOID   (*HalInterruptServiceRoutine)(VOID),
    IN KINTERRUPT_MODE InterruptMode
    );

VOID
HalpRegisterVector (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql
    );

VOID
HalpReportResourceUsage (
    IN PUNICODE_STRING  HalName,
    IN INTERFACE_TYPE   DeviceInterfaceToUse
    );

VOID
HalpYearIs(
    IN ULONG Year
    );

VOID
HalpRecordEisaInterruptVectors(
    VOID
    );

NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
);

NTSTATUS
HalIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

//
// Defines for HalpFeatureBits
//

#define HAL_PERF_EVENTS     0x00000001
#define HAL_NO_SPECULATION  0x00000002
#define HAL_MCA_PRESENT     0x00000004  // Intel MCA Available
#define HAL_MCE_PRESENT     0x00000008  // ONLY Pentium style MCE available

extern ULONG HalpFeatureBits;

//
// Added HalpPciIrqMask
//
   extern USHORT HalpPciIrqMask;
  
//
// Defines for Processor Features returned from CPUID instruction
//

#define CPUID_MCA_MASK  0x4000
#define CPUID_MCE_MASK  0x0080


// Added ITIR bit field masks
//
 
#define ITIR_PPN_MASK       0x7FFF000000000000
#define IoSpaceSize         0x14
#define Attribute_PPN_Mask 0x0000FFFFFFFFF000 

#define IoSpaceAttribute 0x0010000000000473

NTSTATUS
HalpGetMcaLog(
    OUT PMCA_EXCEPTION  Exception,
    OUT PULONG          ReturnedLength
    );

NTSTATUS
HalpMcaRegisterDriver(
    IN PMCA_DRIVER_INFO pMcaDriverInfo  // Info about registering driver
    );

VOID
HalpMcaInit(
    VOID
    );

//
// Disable the Local APIC on UP (PIC 8259) PentiumPro systems to work around
// spurious interrupt errata.
//
#define APIC_BASE_MSR       0x1B
#define APIC_ENABLED        0x0000000000000800


//
// PnP stuff
//

VOID
HalIrqTranslatorReference(
    PVOID Context
    );

VOID
HalIrqTranslatorDereference(
    PVOID Context
    );

NTSTATUS
HalIrqTranslateResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
);

ULONG
HalpGetIsaIrqState(
    ULONG   Vector
    );



// Definion for IA64 HalpVectorToINTI 

#define VECTOR  0xFF;
#define LEVEL   32;
extern UCHAR HalpVectorToINTI[];
extern UCHAR HalpVectorToIRQL[];

// Definition for IA64 complete


//
// ACPI specific stuff
//

// from detect\i386\acpibios.h
typedef struct _ACPI_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[8];             // "RSD PTR" (ascii)
    UCHAR Checksum;
    UCHAR OemId[6];                 // An OEM-supplied string
    UCHAR reserved;                 // must be 0
    ULONG RsdtAddress;              // 32-bit physical address of RSDT 
} ACPI_BIOS_INSTALLATION_CHECK, *PACPI_BIOS_INSTALLATION_CHECK;

NTSTATUS
HalpAcpiFindRsdt (
    OUT PACPI_BIOS_INSTALLATION_CHECK   RsdtPtr
    );
    
NTSTATUS
HalpAcpiFindRsdtPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );
    
NTSTATUS
HalpSetupAcpiPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

PVOID
HalpGetAcpiTable(
    ULONG   Signature
    );

VOID
HalpSleepS5(
    VOID
    );
    
VOID
HalProcessorThrottle (
    UCHAR
    );



VOID
HalpStoreBufferUCHAR (
    PUCHAR VirtualAddress,
    PUCHAR Buffer,
    ULONG Count
    );

VOID
HalpStoreBufferUSHORT (
    PUSHORT VirtualAddress,
    PUSHORT Buffer,
    ULONG Count
    );

VOID
HalpStoreBufferULONG (
    PULONG VirtualAddress,
    PULONG Buffer,
    ULONG  Count
    );

VOID
HalpStoreBufferULONGLONG (
    PULONGLONG VirtualAddress,
    PULONGLONG Buffer,
    ULONG Count
    );


VOID
HalpLoadBufferUCHAR (
    PUCHAR VirtualAddress,
    PUCHAR Buffer,
    ULONG Count
    );

VOID
HalpLoadBufferUSHORT (
    PUSHORT VirtualAddress,
    PUSHORT Buffer,
    ULONG Count
    );

VOID
HalpLoadBufferULONG (
    PULONG VirtualAddress,
    PULONG Buffer,
    ULONG Count
    );

VOID
HalpLoadBufferULONGLONG (
    PULONGLONG VirtualAddress,
    PULONGLONG Buffer,
    ULONG Count
    );




//
// I/O Port space
//
// IoSpaceSize = 0x14 for 2 power 0x14 is 1Meg space size.
//

#define IO_SPACE_SIZE 0x14

// Present bit       =    1B to wire the space.
// Memory Attributes = 1001B for UC Memory type
// Accessed Bit      =    1B to "enable" access without faulting.
// Dirty Bit         =    1B to "enable" write without faulting.
// Privilege Level   =   00B for kernel accesses
// Access Right      =  010B for read/write accesses
// Exception Deferral=    1B for Exception Deferral.
//                               Exceptions are deferred
//                           for speculative loads to pages with
//                               non-spec. mem. attributes anyway.

// Protection Key    =    0  for kernel mode

#define IO_SPACE_ATTRIBUTE 0x0010000000000473

#endif // _HALP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\ixhwsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixhwsup.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode

Revision History:


--*/

#include "bootia64.h"
#include "arc.h"
#include "ixfwhal.h"
#include "eisa.h"
#include "ntconfig.h"

#if !defined(NO_LEGACY_DRIVERS)
//
// This isn't used under EFI -- the HalPT is only setup immediately
// before calling ExitBootServices(), and is only necessary if you are
// using ntbootdd.sys
//
extern PHARDWARE_PTE HalPT;
#endif

PVOID HalpEisaControlBase;

//
// Define save area for ESIA adapter objects.
//

PADAPTER_OBJECT HalpEisaAdapter[8];

VOID
HalpCopyBufferMap(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );



VOID
HalpCopyBufferMap(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine copies the speicific data between the user's buffer and the
    map register buffer.  First a the user buffer is mapped if necessary, then
    the data is copied.  Finally the user buffer will be unmapped if
    neccessary.

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    TranslationEntry - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - The length of the transfer.  This determines the number of map
        registers that need to be written to map the transfer.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    None.

--*/
{
    PCCHAR bufferAddress;
    BOOLEAN mapped;

    //
    // Check to see if the buffer needs to be mapped.
    //


    if ((Mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0) {

        //
        // Map the buffer into system space.
        //

        bufferAddress = MmGetMdlVirtualAddress(Mdl);
        mapped = TRUE;

    } else {

        bufferAddress = Mdl->MappedSystemVa;
        mapped = FALSE;

    }

    //
    // Calculate the actual start of the buffer based on the system VA and
    // the current VA.
    //

    bufferAddress += (PCCHAR) CurrentVa - (PCCHAR) MmGetMdlVirtualAddress(Mdl);

    //
    // Copy the data between the user buffer and map buffer
    //

    if (WriteToDevice) {

        RtlMoveMemory( TranslationEntry->VirtualAddress, bufferAddress, Length);

    } else {

        RtlMoveMemory(bufferAddress, TranslationEntry->VirtualAddress, Length);

    }

}

PADAPTER_OBJECT
HalGetAdapter(
    IN PDEVICE_DESCRIPTION DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )

/*++

Routine Description:

    This function returns the appropriate adapter object for the device defined
    in the device description structure.  This code works for Isa and Eisa
    systems.

Arguments:

    DeviceDescriptor - Supplies a description of the deivce.

    NumberOfMapRegisters - Returns the maximum number of map registers which
        may be allocated by the device driver.

Return Value:

    A pointer to the requested adpater object or NULL if an adapter could not
    be created.

--*/

{
    PADAPTER_OBJECT adapterObject;
    PVOID adapterBaseVa;
    ULONG channelNumber;
    ULONG controllerNumber;
    DMA_EXTENDED_MODE extendedMode;
    UCHAR adapterMode;
    ULONG numberOfMapRegisters;
    BOOLEAN useChannel;
    ULONG maximumLength;


    //
    // Determine if the the channel number is important.  Master cards on
    // Eisa and Mca do not use a channel number.
    //

    if (DeviceDescriptor->InterfaceType != Isa &&
        DeviceDescriptor->Master) {

        useChannel = FALSE;
    } else {

        useChannel = TRUE;
    }

    //
    // Support for ISA local bus machines:
    // If the driver is a Master but really does not want a channel since it
    // is using the local bus DMA, just don't use an ISA channel.
    //

    if (DeviceDescriptor->InterfaceType == Isa &&
        DeviceDescriptor->DmaChannel > 7) {

        useChannel = FALSE;
    }

    //
    // Limit the maximum length to 2 GB this is done so that the BYTES_TO_PAGES
    // macro works correctly.
    //

    maximumLength = DeviceDescriptor->MaximumLength & 0x7fffffff;

    //
    // Channel 4 cannot be used since it is used for chaining. Return null if
    // it is requested.
    //

    if (DeviceDescriptor->DmaChannel == 4 && useChannel &&
        DeviceDescriptor->InterfaceType != MicroChannel) {
        return(NULL);
    }

    //
    // Determine the number of map registers for this device.
    //

    if (DeviceDescriptor->ScatterGather && DeviceDescriptor->InterfaceType == Eisa) {

        //
        // Since the device support scatter/Gather then map registers are not
        // required.
        //

        numberOfMapRegisters = 0;

    } else {

        //
        // Determine the number of map registers required based on the maximum
        // transfer length, up to a maximum number.
        //

        numberOfMapRegisters = BYTES_TO_PAGES(maximumLength)
            + 1;
        numberOfMapRegisters = numberOfMapRegisters > MAXIMUM_ISA_MAP_REGISTER ?
            MAXIMUM_ISA_MAP_REGISTER : numberOfMapRegisters;

    }

    //
    // Set the channel number number.
    //

    channelNumber = DeviceDescriptor->DmaChannel & 0x03;

    //
    // Set the adapter base address to the Base address register and controller
    // number.
    //

    if (!(DeviceDescriptor->DmaChannel & 0x04)) {

        controllerNumber = 1;
        adapterBaseVa = (PVOID) &((PEISA_CONTROL) HalpEisaControlBase)->Dma1BasePort;

    } else {

        controllerNumber = 2;
#if defined(NEC_98)
        adapterBaseVa = &((PEISA_CONTROL) HalpEisaControlBase)->InDirectAddress;
#else  //NEC_98
        adapterBaseVa = &((PEISA_CONTROL) HalpEisaControlBase)->Dma2BasePort;
#endif //NEC_98

    }

    //
    // Determine if a new adapter object is necessary.  If so then allocate it.
    //

    if (useChannel && HalpEisaAdapter[DeviceDescriptor->DmaChannel] != NULL) {

        adapterObject = HalpEisaAdapter[DeviceDescriptor->DmaChannel];

    } else {

        //
        // Allocate an adapter object.
        //

        adapterObject = (PADAPTER_OBJECT) IopAllocateAdapter(
            numberOfMapRegisters,
            adapterBaseVa,
            NULL
            );

        if (adapterObject == NULL) {

            return(NULL);

        }

        if (useChannel) {

            HalpEisaAdapter[DeviceDescriptor->DmaChannel] = adapterObject;

        }

        //
        // We never need map registers.
        //

        adapterObject->NeedsMapRegisters = FALSE;

        //
        // Set the maximum number of map registers for this channel bus on
        // the number requested and the type of device.
        //

        if (numberOfMapRegisters) {

            //
            // The speicified number of registers are actually allowed to be
            // allocated.
            //

            adapterObject->MapRegistersPerChannel = numberOfMapRegisters;

        } else {

            //
            // No real map registers were allocated.  If this is a master
            // device, then the device can have as may registers as it wants.
            //


            if (DeviceDescriptor->Master) {

                adapterObject->MapRegistersPerChannel = BYTES_TO_PAGES(
                    maximumLength
                    )
                    + 1;

            } else {

                //
                // The device only gets one register.  It must call
                // IoMapTransfer repeatedly to do a large transfer.
                //

                adapterObject->MapRegistersPerChannel = 1;
            }
        }
    }

    *NumberOfMapRegisters = adapterObject->MapRegistersPerChannel;

    //
    // If the channel number is not used then we are finished.  The rest of
    // the work deals with channels.
    //

    if (!useChannel) {
        return(adapterObject);
    }

    //
    // Setup the pointers to all the random registers.
    //

    adapterObject->ChannelNumber = (UCHAR) channelNumber;

    if (controllerNumber == 1) {

        switch ((UCHAR)channelNumber) {

        case 0:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel0;
            break;

        case 1:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel1;
            break;

        case 2:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel2;
            break;

        case 3:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel3;
            break;
        }

        //
        // Set the adapter number.
        //

        adapterObject->AdapterNumber = 1;

#if defined(NEC_98)
#else
        //
        // Save the extended mode register address.
        //

        adapterBaseVa =
            &((PEISA_CONTROL) HalpEisaControlBase)->Dma1ExtendedModePort;
#endif // !NEC_98

    } else {

#if defined(NEC_98)
#else  //NEC_98
        switch (channelNumber) {
        case 1:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel5;
            break;

        case 2:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel6;
            break;

        case 3:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel7;
            break;
        }

        //
        // Set the adapter number.
        //

        adapterObject->AdapterNumber = 2;

        //
        // Save the extended mode register address.
        //
        adapterBaseVa =
            &((PEISA_CONTROL) HalpEisaControlBase)->Dma2ExtendedModePort;
#endif //NEC_98

    }

    adapterObject->Width16Bits = FALSE;

    if (MachineType == MACHINE_TYPE_EISA) {

        //
        // Initialzie the extended mode port.
        //

        *((PUCHAR) &extendedMode) = 0;
        extendedMode.ChannelNumber = (UCHAR)channelNumber;

        switch (DeviceDescriptor->DmaSpeed) {
        case Compatible:
            extendedMode.TimingMode = COMPATIBLITY_TIMING;
            break;

        case TypeA:
            extendedMode.TimingMode = TYPE_A_TIMING;
            break;

        case TypeB:
            extendedMode.TimingMode = TYPE_B_TIMING;
            break;

        case TypeC:
            extendedMode.TimingMode = BURST_TIMING;
            break;

        default:
            return(NULL);

        }

        switch (DeviceDescriptor->DmaWidth) {
        case Width8Bits:
            extendedMode.TransferSize = BY_BYTE_8_BITS;
            break;

        case Width16Bits:
            extendedMode.TransferSize = BY_BYTE_16_BITS;

            //
            // Note Width16bits should not be set here because there is no need
            // to shift the address and the transfer count.
            //

            break;

        case Width32Bits:
            extendedMode.TransferSize = BY_BYTE_32_BITS;
            break;

        default:
            return(NULL);

        }

        WRITE_PORT_UCHAR( adapterBaseVa, *((PUCHAR) &extendedMode));

    } else if (!DeviceDescriptor->Master) {


#if defined(NEC_98)
#else
        switch (DeviceDescriptor->DmaWidth) {
        case Width8Bits:

            //
            // The channel must use controller 1.
            //

            if (controllerNumber != 1) {
                return(NULL);
            }

            break;

        case Width16Bits:

            //
            // The channel must use controller 2.
            //

            if (controllerNumber != 2) {
                return(NULL);
            }

            adapterObject->Width16Bits = TRUE;
            break;

        default:
            return(NULL);

        }
#endif //!NEC_98
    }


    //
    // Determine if this is an Isa adapter.
    //

    if (DeviceDescriptor->InterfaceType == Isa) {

        adapterObject->IsaDevice = TRUE;

    }

    //
    // Initialize the adapter mode register value to the correct parameters,
    // and save them in the adapter object.
    //

    adapterMode = 0;
    ((PDMA_EISA_MODE) &adapterMode)->Channel = adapterObject->ChannelNumber;

    adapterObject->MasterDevice = FALSE;

    if (DeviceDescriptor->Master) {

        adapterObject->MasterDevice = TRUE;

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = CASCADE_REQUEST_MODE;

        //
        // Set the mode, and enable the request.
        //

        if (adapterObject->AdapterNumber == 1) {

            //
            // This request is for DMA controller 1
            //

            PDMA1_CONTROL dmaControl;

            dmaControl = adapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

            //
            // Unmask the DMA channel.
            //

            WRITE_PORT_UCHAR(
                &dmaControl->SingleMask,
                 (UCHAR) (DMA_CLEARMASK | adapterObject->ChannelNumber)
                 );

        } else {

#if defined(NEC_98)
#else  //NEC_98
            //
            // This request is for DMA controller 1
            //

            PDMA2_CONTROL dmaControl;

            dmaControl = adapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

            //
            // Unmask the DMA channel.
            //

            WRITE_PORT_UCHAR(
                &dmaControl->SingleMask,
                 (UCHAR) (DMA_CLEARMASK | adapterObject->ChannelNumber)
                 );
#endif //NEC_98

        }

    } else if (DeviceDescriptor->DemandMode) {

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = DEMAND_REQUEST_MODE;

    } else {

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = SINGLE_REQUEST_MODE;

    }

    if (DeviceDescriptor->AutoInitialize) {

        ((PDMA_EISA_MODE) &adapterMode)->AutoInitialize = 1;

    }

    adapterObject->AdapterMode = adapterMode;

    return(adapterObject);
}

NTSTATUS
IoAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter object.
    This is accomplished by placing the device object of the driver that wants
    to allocate the adapter on the adapter's queue.  If the queue is already
    "busy", then the adapter has already been allocated, so the device object
    is simply placed onto the queue and waits until the adapter becomes free.

    Once the adapter becomes free (or if it already is), then the driver's
    execution routine is invoked.

    Also, a number of map registers may be allocated to the driver by specifying
    a non-zero value for NumberOfMapRegisters.  If this is the case, then the
    base address of the allocated map registers in the adapter is also passed
    to the driver's execution routine.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    DeviceObject - Pointer to the driver's device object that represents the
        device allocating the adapter.

    NumberOfMapRegisters - The number of map registers that are to be allocated
        from the channel, if any.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

Return Value:

    Returns STATUS_SUCESS unless too many map registers are requested.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/

{
    IO_ALLOCATION_ACTION action;

    //
    // Make sure the adapter if free.
    //

#if defined(ENABLE_LOADER_EBUG)
    if (AdapterObject->AdapterInUse) {
        DbgPrint("IoAllocateAdapterChannel: Called while adapter in use.\n");
    }
#endif

    //
    // Make sure there are enough map registers.
    //

    if (NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {

#if defined(ENABLE_LOADER_EBUG)
        DbgPrint("IoAllocateAdapterChannel:  Out of map registers.\n");
#endif
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    action = ExecutionRoutine( DeviceObject,
                               DeviceObject->CurrentIrp,
                               AdapterObject->MapRegisterBase,
                               Context );

    //
    // If the driver wishes to keep the map registers then
    // increment the current base and decrease the number of existing map
    // registers.
    //

    if (action == DeallocateObjectKeepRegisters &&
        AdapterObject->MapRegisterBase != NULL) {

        AdapterObject->MapRegistersPerChannel -= NumberOfMapRegisters;
        (PTRANSLATION_ENTRY) AdapterObject->MapRegisterBase  +=
            NumberOfMapRegisters;

    } else if (action == KeepObject) {

        AdapterObject->AdapterInUse = TRUE;

    }

    return(STATUS_SUCCESS);
}

VOID
IoFreeAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:

    This routine is invoked to deallocate the specified adapter object.
    Any map registers that were allocated are also automatically deallocated.
    No checks are made to ensure that the adapter is really allocated to
    a device object.  However, if it is not, then kernel will bugcheck.

    If another device is waiting in the queue to allocate the adapter object
    it will be pulled from the queue and its execution routine will be
    invoked.

Arguments:

    AdapterObject - Pointer to the adapter object to be deallocated.

Return Value:

    None.

--*/

{

    AdapterObject->AdapterInUse = FALSE;
}

PHYSICAL_ADDRESS
IoMapTransfer(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine is invoked to set up the map registers in the DMA controller
    to allow a transfer to or from a device.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel that has been allocated.

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    MapRegisterBase - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    Returns the logical address that should be used bus master controllers.

--*/

{
    BOOLEAN useBuffer;
    ULONG transferLength;
    ULONG logicalAddress;
    PULONG pageFrame;
    PUCHAR bytePointer;
    UCHAR adapterMode;
    UCHAR dataByte;
    PTRANSLATION_ENTRY translationEntry;
    BOOLEAN masterDevice;
    PHYSICAL_ADDRESS ReturnAddress;

    masterDevice = AdapterObject == NULL || AdapterObject->MasterDevice ?
        TRUE : FALSE;

    translationEntry = MapRegisterBase;
    transferLength = *Length;

    //
    // Determine if the data transfer needs to use the map buffer.
    //

    if (translationEntry && !masterDevice &&
        ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentVa, transferLength) > 1) {

        logicalAddress = translationEntry->PhysicalAddress;
        useBuffer = TRUE;

    } else {

        //
        // The transfer can only be done for one page.
        //



        transferLength = PAGE_SIZE - BYTE_OFFSET(CurrentVa);
        pageFrame = (PULONG)(Mdl+1);
        pageFrame += ((ULONG_PTR) CurrentVa - (ULONG_PTR) Mdl->StartVa) / PAGE_SIZE;
        logicalAddress = (*pageFrame << PAGE_SHIFT) + BYTE_OFFSET(CurrentVa);

        //
        // If the buffer is contigous and does not cross a 64 K bountry then
        // just extend the buffer.
        //

        while( transferLength < *Length ){

            if ( (*pageFrame + 1) != *(pageFrame + 1) ||
                 (*pageFrame & ~0x0ffff) != (*(pageFrame + 1) & ~0x0ffff)) {
                    break;
            }

            transferLength += PAGE_SIZE;
            pageFrame++;

        }


        transferLength = transferLength > *Length ? *Length : transferLength;

        useBuffer = FALSE;
    }

    //
    // Check to see if this device has any map registers allocated. If it
    // does, then it must require memory to be at less than 16 MB.  If the
    // logical address is greater than 16MB then map registers must be used
    //

    if (translationEntry && logicalAddress >= MAXIMUM_PHYSICAL_ADDRESS) {

        logicalAddress = (translationEntry + translationEntry->Index)->
            PhysicalAddress;
        useBuffer = TRUE;

    }

    //
    // Return the length.
    //

    *Length = transferLength;

    //
    // Copy the data if necessary.
    //

    if (useBuffer && WriteToDevice) {

        HalpCopyBufferMap(
            Mdl,
            translationEntry + translationEntry->Index,
            CurrentVa,
            *Length,
            WriteToDevice
            );

    }

    //
    // If there are map registers, then update the index to indicate
    // how many have been used.
    //

    if (translationEntry) {

        translationEntry->Index += ADDRESS_AND_SIZE_TO_SPAN_PAGES(
            CurrentVa,
            transferLength
            );

    }

    //
    // If no adapter was specificed then there is no more work to do so
    // return.
    //

    if (masterDevice) {

        //
        // We only support 32 bits, but the return is 64.  Just
        // zero extend
        //

        ReturnAddress.QuadPart = logicalAddress;
        return(ReturnAddress);
    }

    //
    // Determine the mode based on the transfer direction.
    //

    adapterMode = AdapterObject->AdapterMode;
    ((PDMA_EISA_MODE) &adapterMode)->TransferType = (UCHAR) (WriteToDevice ?
        WRITE_TRANSFER :  READ_TRANSFER);

    ReturnAddress.QuadPart = logicalAddress;
    bytePointer = (PUCHAR) &logicalAddress;

#if defined(NEC_98)
#else
    if (AdapterObject->Width16Bits) {

        //
        // If this is a 16 bit transfer then adjust the length and the address
        // for the 16 bit DMA mode.
        //

        transferLength >>= 1;

        //
        // In 16 bit DMA mode the low 16 bits are shifted right one and the
        // page register value is unchanged. So save the page register value
        // and shift the logical address then restore the page value.
        //

        dataByte = bytePointer[2];
        logicalAddress >>= 1;
        bytePointer[2] = dataByte;

    }
#endif //NEC_98

    //
    // Determine the controller number based on the Adapter number.
    //

    if (AdapterObject->AdapterNumber == 1) {

        //
        // This request is for DMA controller 1
        //

        PDMA1_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

        WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[0]
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[1]
            );

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageLowPort) +
            (UCHAR)AdapterObject->PagePort,
            bytePointer[2]
            );

#if 0
        //
        // Write the high page register with zero value. This enable a special mode
        // which allows ties the page register and base count into a single 24 bit
        // address register.
        //

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort) +
            (ULONG)AdapterObject->PagePort,
            0
            );
#endif

        //
        // Notify DMA chip of the length to transfer.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) & 0xff)
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) >> 8)
            );


        //
        // Set the DMA chip to read or write mode; and unmask it.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
             (UCHAR) (DMA_CLEARMASK | AdapterObject->ChannelNumber)
             );

    } else {

#if defined(NEC_98)
#else  //NEC_98
        //
        // This request is for DMA controller 2
        //

        PDMA2_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

        WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[0]
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[1]
            );

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageLowPort) +
            (UCHAR)AdapterObject->PagePort,
            bytePointer[2]
            );
#if 0

        //
        // Write the high page register with zero value. This enable a special mode
        // which allows ties the page register and base count into a single 24 bit
        // address register.
        //

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort) +
            (ULONG)AdapterObject->PagePort,
            0
            );

#endif
        //
        // Notify DMA chip of the length to transfer.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) & 0xff)
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) >> 8)
            );


        //
        // Set the DMA chip to read or write mode; and unmask it.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
             (UCHAR) (DMA_CLEARMASK | AdapterObject->ChannelNumber)
             );
#endif //NEC_98

    }

    return(ReturnAddress);
}

BOOLEAN
IoFlushAdapterBuffers(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine flushes the DMA adpater object buffers.  For the Jazz system
    its clears the enable flag which aborts the dma.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel.

    Mdl - A pointer to a Memory Descriptor List (MDL) that maps the locked-down
        buffer to/from which the I/O occured.

    MapRegisterBase - A pointer to the base of the map registers in the adapter
        or DMA controller.

    CurrentVa - The current virtual address in the buffer described the the Mdl
        where the I/O operation occurred.

    Length - Supplies the length of the transfer.

    WriteToDevice - Supplies a BOOLEAN value that indicates the direction of
        the data transfer was to the device.

Return Value:

    TRUE - No errors are detected so the transfer must succeed.

--*/

{
    PTRANSLATION_ENTRY translationEntry;
    PULONG pageFrame;
    ULONG transferLength;
    ULONG partialLength;
    BOOLEAN masterDevice;
    BOOLEAN mapped = FALSE;

    masterDevice = AdapterObject == NULL || AdapterObject->MasterDevice ?
        TRUE : FALSE;

    translationEntry = MapRegisterBase;

    //
    // Clear the index of used buffers.
    //

    if (translationEntry) {

        translationEntry->Index = 0;
    }

    //
    // Determine if the data needs to be copied to the orginal buffer.
    // This only occurs if the data tranfer is from the device, the
    // MapReisterBase is not NULL and the transfer spans a page.
    //

    if (!WriteToDevice && translationEntry) {

        //
        // If this is not a master device, then just transfer the buffer.
        //

        if (ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentVa, Length) > 1 &&
            !masterDevice) {

            HalpCopyBufferMap(
                Mdl,
                translationEntry,
                CurrentVa,
                Length,
                WriteToDevice
                );

        } else {

            //
            // Cycle through the pages of the transfer to determine if there
            // are any which need to be copied back.
            //

            transferLength = PAGE_SIZE - BYTE_OFFSET(CurrentVa);
            partialLength = transferLength;
            pageFrame = (PULONG)(Mdl+1);
            pageFrame += ((ULONG_PTR) CurrentVa - (ULONG_PTR) Mdl->StartVa) / PAGE_SIZE;

            while( transferLength <= Length ){

                if (*pageFrame >= BYTES_TO_PAGES(MAXIMUM_PHYSICAL_ADDRESS)) {

                    //
                    // Check to see that the MDL is mapped in system space.
                    // If is not mapped, then map it.  This ensures that the
                    // buffer will only have to be mapped at most once per I/O.
                    //

                    if ((Mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0) {

                        Mdl->MappedSystemVa = MmGetMdlVirtualAddress(Mdl);
                        Mdl->MdlFlags |= MDL_MAPPED_TO_SYSTEM_VA;
                        mapped = TRUE;

                    }

                    HalpCopyBufferMap(
                        Mdl,
                        translationEntry,
                        CurrentVa,
                        partialLength,
                        WriteToDevice
                        );

                }

                (PCCHAR) CurrentVa += partialLength;
                partialLength = PAGE_SIZE;

                //
                // Note that transferLength indicates the amount which will be
                // transfered after the next loop; thus, it is updated with the
                // new partial length.
                //

                transferLength += partialLength;
                pageFrame++;
                translationEntry++;
            }

            //
            // Process the any remaining residue.
            //

            partialLength = Length - transferLength + partialLength;
            if (partialLength && *pageFrame >= BYTES_TO_PAGES(MAXIMUM_PHYSICAL_ADDRESS)) {

                HalpCopyBufferMap(
                    Mdl,
                    translationEntry,
                    CurrentVa,
                    partialLength,
                    WriteToDevice
                    );

            }
        }

    }


    //
    // If this is a master device, then there is nothing more to do so return
    // TRUE.
    //

    if (masterDevice) {

        return(TRUE);

    }

    //
    // Mask the DMA request line so that DMA requests cannot occur.
    //

    if (AdapterObject->AdapterNumber == 1) {

        //
        // This request is for DMA controller 1
        //

        PDMA1_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
            (UCHAR) (DMA_SETMASK | AdapterObject->ChannelNumber)
            );

    } else {

        //
        // This request is for DMA controller 2
        //

#if defined(NEC_98)
#else  //NEC_98
        PDMA2_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
            (UCHAR) (DMA_SETMASK | AdapterObject->ChannelNumber)
            );
#endif //NEC_98

    }

    return TRUE;
}

VOID
IoFreeMapRegisters(
   PADAPTER_OBJECT AdapterObject,
   PVOID MapRegisterBase,
   ULONG NumberOfMapRegisters
   )
/*++

Routine Description:

   This routine deallocates the map registers for the adapter.  If there are
   any queued adapter waiting for an attempt is made to allocate the next
   entry.

Arguments:

   AdapterObject - The adapter object to where the map register should be
        returned.

   MapRegisterBase - The map register base of the registers to be deallocated.

   NumberOfMapRegisters - The number of registers to be deallocated.

Return Value:

   None

--+*/
{
    PTRANSLATION_ENTRY translationEntry;

    //
    // Determine if this was the last allocation from the adapter. If is was
    // then free the map registers by restoring the map register base and the
    // channel count; otherwise the registers are lost.  This handles the
    // normal case.
    //

    translationEntry = AdapterObject->MapRegisterBase;
    translationEntry -= NumberOfMapRegisters;

    if (translationEntry == MapRegisterBase) {

        //
        // The last allocated registers are being freed.
        //

        AdapterObject->MapRegisterBase = (PVOID) translationEntry;
        AdapterObject->MapRegistersPerChannel += NumberOfMapRegisters;
    }
}

PHYSICAL_ADDRESS
MmGetPhysicalAddress (
     IN PVOID BaseAddress
     )

/*++

Routine Description:

    This function returns the corresponding physical address for a
    valid virtual address.

Arguments:

    BaseAddress - Supplies the virtual address for which to return the
                  physical address.

Return Value:

    Returns the corresponding physical address.

Environment:

    Kernel mode.  Any IRQL level.

--*/

{
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG Index;

    PhysicalAddress.QuadPart = (ULONG_PTR)BaseAddress & ~KSEG0_BASE;

#if !defined(NO_LEGACY_DRIVERS)
//
// This is not used under EFI -- the HalPT is only setup immediately
// before calling ExitBootServices(), and this routine is really only
// necessary if you are using ntbootdd.sys.
//
    //
    // If the address is in the hal map range, get the physical
    // addressed mapped by the pte
    //

    if (((ULONG_PTR) BaseAddress) >= 0xe0000000ffc00000) {
        Index = (ULONG) ((PhysicalAddress.QuadPart >> PAGE_SHIFT) & 0x3ff);
        PhysicalAddress.QuadPart = HalPT[Index].PageFrameNumber << PAGE_SHIFT;
        PhysicalAddress.QuadPart |= (ULONG_PTR)BaseAddress & (PAGE_SIZE-1);
    }
#endif

    return(PhysicalAddress);
}

PVOID
MmAllocateNonCachedMemory (
    IN SIZE_T NumberOfBytes
    )

/*++

Routine Description:

    This function allocates a range of noncached memory in
    the non-paged portion of the system address space.

    This routine is designed to be used by a driver's initialization
    routine to allocate a noncached block of virtual memory for
    various device specific buffers.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - the specified request could not be satisfied.

    NON-NULL - Returns a pointer (virtual address in the nonpaged portion
               of the system) to the allocated phyiscally contiguous
               memory.

Environment:

    Kernel mode, IRQL of APC_LEVEL or below.

--*/

{
    PVOID BaseAddress;
    ULONG bytesToAllocate;

    bytesToAllocate = (ULONG)NumberOfBytes;

    //
    // Allocated the memory.
    //

    BaseAddress = BlAllocateHeap(bytesToAllocate);
    return BaseAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\mca.h ===
/*++

Copyright (c) 1990  Microsoft Corporation
Copyright (c) 1991  NCR Corporation

Module Name:

    mca.h

Abstract:

    This module contains the defines and structure definitions for
    Micro Channel machines.

Author:

    David Risner  (o-ncrdr) 21-Jul-1991

Revision History:


--*/

#ifndef _MCA_
#define _MCA_





//
// Define the DMA page register structure (for 8237 compatibility)
//
#if defined(NEC_98)
#else
#ifndef _EISA_
typedef struct _DMA_PAGE{
    UCHAR Reserved1;
    UCHAR Channel2;
    UCHAR Channel3;
    UCHAR Channel1;
    UCHAR Reserved2[3];
    UCHAR Channel0;
    UCHAR Reserved3;
    UCHAR Channel6;
    UCHAR Channel7;
    UCHAR Channel5;
    UCHAR Reserved4[3];
    UCHAR RefreshPage;
} DMA_PAGE, *PDMA_PAGE;

//
// Define DMA 1 address and count structure (for 8237 compatibility)
//

typedef struct _DMA1_ADDRESS_COUNT {
    UCHAR DmaBaseAddress;
    UCHAR DmaBaseCount;
} DMA1_ADDRESS_COUNT, *PDMA1_ADDRESS_COUNT;

//
// Define DMA 2 address and count structure (for 8237 compatibility)
//

typedef struct _DMA2_ADDRESS_COUNT {
    UCHAR DmaBaseAddress;
    UCHAR Reserved1;
    UCHAR DmaBaseCount;
    UCHAR Reserved2;
} DMA2_ADDRESS_COUNT, *PDMA2_ADDRESS_COUNT;

//
// Define DMA 1 control register structure (for 8237 compatibility)
//

typedef struct _DMA1_CONTROL {
    DMA1_ADDRESS_COUNT DmaAddressCount[4];
    UCHAR DmaStatus;
    UCHAR DmaRequest;
    UCHAR SingleMask;
    UCHAR Mode;
    UCHAR ClearBytePointer;
    UCHAR MasterClear;
    UCHAR ClearMask;
    UCHAR AllMask;
} DMA1_CONTROL, *PDMA1_CONTROL;

//
// Define DMA 2 control register structure (for 8237 compatibility)
//

typedef struct _DMA2_CONTROL {
    DMA2_ADDRESS_COUNT DmaAddressCount[4];
    UCHAR DmaStatus;
    UCHAR Reserved1;
    UCHAR DmaRequest;
    UCHAR Reserved2;    
    UCHAR SingleMask;
    UCHAR Reserved3;    
    UCHAR Mode;
    UCHAR Reserved4;    
    UCHAR ClearBytePointer;
    UCHAR Reserved5;    
    UCHAR MasterClear;
    UCHAR Reserved6;    
    UCHAR ClearMask;
    UCHAR Reserved7;    
    UCHAR AllMask;
    UCHAR Reserved8;    
} DMA2_CONTROL, *PDMA2_CONTROL;
#endif //_EISA_
#endif //NEC_98

typedef struct _MCA_DMA_CONTROLLER {
    UCHAR DmaFunctionLsb;               // Offset 0x018
    UCHAR DmaFunctionMsb;               // Offset 0x019
    UCHAR DmaFunctionData;              // Offset 0x01a
    UCHAR Reserved01;
    UCHAR ScbAttentionPort;             // Offset 0x01c
    UCHAR ScbCommandPort;               // Offset 0x01d
    UCHAR Reserved02;
    UCHAR ScbStatusPort;                // Offset 0x01f
} MCA_DMA_CONTROLLER, *PMCA_DMA_CONTROLLER;

//
// Define Programmable Option Select register set
//

typedef struct _PROGRAMMABLE_OPTION_SELECT {
    UCHAR AdapterIdLsb;
    UCHAR AdapterIdMsb;
    UCHAR OptionSelectData1;
    UCHAR OptionSelectData2;
    UCHAR OptionSelectData3;
    UCHAR OptionSelectData4;
    UCHAR SubaddressExtensionLsb;
    UCHAR SubaddressExtensionMsb;
} PROGRAMMABLE_OPTION_SELECT, *PPROGRAMMABLE_OPTION_SELECT;

//
// Define Micro Channel i/o address map
//

typedef struct _MCA_CONTROL {
    DMA1_CONTROL Dma1BasePort;          // Offset 0x000
    UCHAR Reserved0[8];
    UCHAR ExtendedDmaBasePort[8];       // Offset 0x018 
    UCHAR Interrupt1ControlPort0;       // Offset 0x020
    UCHAR Interrupt1ControlPort1;       // Offset 0x021
    UCHAR Reserved1[64 - 1];
    UCHAR SystemControlPortB;           // Offset 0x061
    UCHAR Reserved2[32 - 2];
    DMA_PAGE DmaPageLowPort;            // Offset 0x080
    UCHAR Reserved3;
    UCHAR CardSelectedFeedback;         // Offset 0x091
    UCHAR SystemControlPortA;           // Offset 0x092
    UCHAR Reserved4;
    UCHAR SystemBoardSetup;             // Offset 0x094
    UCHAR Reserved5;
    UCHAR AdapterSetup;                 // Offset 0x096
    UCHAR AdapterSetup2;                // Offset 0x097
    UCHAR Reserved7[8];
    UCHAR Interrupt2ControlPort0;       // Offset 0x0a0
    UCHAR Interrupt2ControlPort1;       // Offset 0x0a1
    UCHAR Reserved8[32-2];
#if defined(NEC_98)
#else
    DMA2_CONTROL Dma2BasePort;          // Offset 0x0c0
    UCHAR Reserved9[32];
    PROGRAMMABLE_OPTION_SELECT Pos;     // Offset 0x100
#endif //NEC_98
} MCA_CONTROL, *PMCA_CONTROL;

//
// Define POS adapter setup equates for use with AdapterSetup field above
//

#define MCA_ADAPTER_SETUP_ON  0x008
#define MCA_ADAPTER_SETUP_OFF 0x000

//
// Define DMA Extended Function register
//

typedef struct _DMA_EXTENDED_FUNCTION {
    UCHAR ChannelNumber : 3;
    UCHAR Reserved      : 1;
    UCHAR Command       : 4;
} DMA_EXTENDED_FUNCTION, *PDMA_EXTENDED_FUNCTION;

//
// Define Command values
//

#define WRITE_IO_ADDRESS         0x00   // write I/O address reg
#define WRITE_MEMORY_ADDRESS     0x20   // write memory address reg
#define READ_MEMORY_ADDRESS      0x30   // read memory address reg
#define WRITE_TRANSFER_COUNT     0x40   // write transfer count reg
#define READ_TRANSFER_COUNT      0x50   // read transfer count reg
#define READ_STATUS              0x60   // read status register
#define WRITE_MODE               0x70   // write mode register
#define WRITE_ARBUS              0x80   // write arbus register
#define SET_MASK_BIT             0x90   // set bit in mask reg
#define CLEAR_MASK_BIT           0xa0   // clear bit in mask reg
#define MASTER_CLEAR             0xd0   // master clear

//
// Define DMA Extended Mode register
//

typedef struct _DMA_EXTENDED_MODE_MCA {
    UCHAR ProgrammedIo      : 1;     // 0 = do not use programmed i/o address
    UCHAR Reserved0         : 1;
    UCHAR DmaOpcode         : 1;     // 0 = verify memory, 1 = data transfer
    UCHAR TransferDirection : 1;     // 0 = read memory, 1 = write memory
    UCHAR Reserved1         : 2;
    UCHAR DmaWidth          : 1;     // 0 = 8bit, 1 = 16bit
    UCHAR Reserved2         : 1;
} DMA_EXTENDED_MODE_MCA, *PDMA_EXTENDED_MODE_MCA;

//
// DMA Extended Mode equates for use with the _DMA_EXTENDED_MODE structure.
//

#define DMA_EXT_USE_PIO       0x01
#define DMA_EXT_NO_PIO        0x00
#define DMA_EXT_VERIFY        0x00
#define DMA_EXT_DATA_XFER     0x01
#define DMA_EXT_WIDTH_8_BIT   0x00
#define DMA_EXT_WIDTH_16_BIT  0x01

//
// DMA mode option definitions
//

#define DMA_MODE_READ          0x00   // read data into memory
#define DMA_MODE_WRITE         0x08   // write data from memory
#define DMA_MODE_VERIFY        0x00   // verify data
#define DMA_MODE_TRANSFER      0x04   // transfer data

// 
// DMA extended mode constants
//

#define MAX_MCA_DMA_CHANNEL_NUMBER  0x07 // maximum MCA DMA channel number
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\ixfwhal.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixfwhal.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    Intel x86 specific interfaces, defines and structures.

Author:

    Jeff Havens (jhavens) 20-Jun-91


Revision History:

--*/

#ifndef _IXHALP_
#define _IXHALP_


//
// The MAXIMUM_MAP_BUFFER_SIZE defines the maximum map buffers which the system
// will allocate for devices which require phyically contigous buffers.
//

#define MAXIMUM_MAP_BUFFER_SIZE  0x1000000

//
// Define the initial buffer allocation size for a map buffers.
//

#define INITIAL_MAP_BUFFER_SIZE 0x20000

//
// Define the incremental buffer allocation for a map buffers.
//

#define INCREMENT_MAP_BUFFER_SIZE 0x10000

//
// Define the maximum number of map registers that can be requested at one time
// if actual map registers are required for the transfer.
//

#define MAXIMUM_ISA_MAP_REGISTER  16

//
// Define the maximum physical address which can be handled by an Isa card.
//

#define MAXIMUM_PHYSICAL_ADDRESS 0x01000000

//
// Define adapter object structure.
//

typedef struct _ADAPTER_OBJECT {
    CSHORT Type;
    CSHORT Size;
    ULONG MapRegistersPerChannel;
    PVOID AdapterBaseVa;
    PVOID MapRegisterBase;
    ULONG NumberOfMapRegisters;
    UCHAR ChannelNumber;
    UCHAR AdapterNumber;
    UCHAR AdapterMode;
    UCHAR ExtendedModeFlags;
    USHORT DmaPortAddress;
    BOOLEAN NeedsMapRegisters;
    BOOLEAN IsaDevice;
    BOOLEAN MasterDevice;
    BOOLEAN Width16Bits;
    BOOLEAN AdapterInUse;
    PUCHAR PagePort;
} ADAPTER_OBJECT;

//
// Define map register translation entry structure.
//

typedef struct _TRANSLATION_ENTRY {
    PVOID VirtualAddress;
    ULONG PhysicalAddress;
    ULONG Index;
} TRANSLATION_ENTRY, *PTRANSLATION_ENTRY;

//
// Define External data structures.
//

//
// Some devices require a phyicially contiguous data buffers for DMA transfers.
// Map registers are used give the appearance that all data buffers are
// contiguous.  In order to pool all of the map registers a master
// adapter object is used.  This object is allocated and saved internal to this
// file.  It contains a bit map for allocation of the registers and a queue
// for requests which are waiting for more map registers.  This object is
// allocated during the first request to allocate an adapter which requires
// map registers.
//
// In this system, the map registers are translation entries which point to
// map buffers.  Map buffers are physically contiguous and have physical memory
// addresses less than 0x01000000.  All of the map registers are allocated
// initialially; however, the map buffers are allocated base in the number of
// adapters which are allocated.
//
// If the master adapter is NULL in the adapter object then device does not
// require any map registers.
//

extern PADAPTER_OBJECT MasterAdapterObject;

extern POBJECT_TYPE IoAdapterObjectType;

extern BOOLEAN LessThan16Mb;

//
// Define function prototypes.
//

BOOLEAN
HalpGrowMapBuffers(
    PADAPTER_OBJECT AdapterObject,
    ULONG Amount
    );

PADAPTER_OBJECT
IopAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID MapRegisterBase
    );

VOID
HalpInitializeDisplay(
    IN PUSHORT VideoBufferAddress
    );

#endif // _IXHALP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\memory.c ===
/*++


Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    memory.c

Abstract:

    This module sets up the memory subsystem so that virtual addresses map 1:1
    with physical addresses.  It also tweaks the EFI-supplied memory map for 
    use by the loader.  This mapping occurs as follows:

Memory Map used by NTLDR:

    0 - 1MB         Legacy BIOS area, marked as unusable
    
    16 MB - 32 MB   used for loading drivers
    32 MB - 48 MB   used for loading drivers
    
    48 MB - 64 MB   used for loading kernel and hal (the kernel must be loaded on a 16 MB boundary)
    
    64 MB - 80 MB   used for diamond decompression engine
    
    There are not enough TRs to map all memory, so any other memory has a 
    straight 1-1 translation.  Since we use KSEG for our addresses, this 
    means that these ranges are effectively unaddressable.
        
Author:

    John Vert (jvert) 18-Jun-1991        

Environment:

    Kernel Mode


Revision History:

    Andrew Ritz (andrewr) 15-Dec-2000  - added comments and major cleanup for
                                         running under EFI

--*/

#include "arccodes.h"
#include "bootia64.h"
#include "efi.h"

extern EFI_SYSTEM_TABLE *EfiST;

WCHAR DebugBuffer[512];


//
// Current heap start pointers (physical addresses)
// Note that 0x50000 to 0x5ffff is reserved for detection configuration memory
//

#if FW_HEAP
ULONG_PTR FwPermanentHeap = PERMANENT_HEAP_START * PAGE_SIZE;
ULONG_PTR FwTemporaryHeap = (TEMPORARY_HEAP_START * PAGE_SIZE) - 0x10000;

//
// Current pool pointers.  This is different than the temporary/permanent
// heaps, because it is not required to be under 1MB.  It is used by the
// SCSI miniports for allocating their extensions and for the dbcs font image.
//

#define FW_POOL_SIZE (0x40000/PAGE_SIZE)
ULONG_PTR FwPoolStart;
ULONG_PTR FwPoolEnd;

//
// This gets set to FALSE right before we call into the osloader, so we
// know that the fw memory descriptors can no longer be changed at will.
//
BOOLEAN FwDescriptorsValid = TRUE;
#endif
//
// External function prototypes
//
extern
ARC_STATUS
MempGoVirtual (
    VOID
    );

//
// Private function prototypes
//

ARC_STATUS
MempAllocDescriptor(
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    );

ARC_STATUS
MempSetDescriptorRegion (
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    );

//
// Global - memory management variables.
//

PHARDWARE_PTE PDE;
PHARDWARE_PTE HalPT;

//
// Global memory array that is used by the loader to construct the 
// MemoryDescriptorList which is passed into the OS.
//
PMEMORY_DESCRIPTOR MDArray;
//
// These help us keep track of the memory descriptor array and are used
// in the allocation and insertion routines
//
ULONG NumberDescriptors=0;
ULONG MaxDescriptors=0;

extern GoneVirtual;



ARC_STATUS
InitializeMemorySubsystem(
    PBOOT_CONTEXT BootContext
    )
/*++

Routine Description:

    The initial heap is mapped and allocated. Pointers to the
    Page directory and page tables are initialized.

Arguments:

    BootContext - Supplies basic information provided by SU module.

Returns:

    ESUCCESS - Memory succesfully initialized.

--*/

{
    ARC_STATUS Status = ESUCCESS;
    PMEMORY_DESCRIPTOR SuMemory;
    ULONG PageStart;
    ULONG PageEnd;
    ULONG LoaderStart;
    ULONG LoaderEnd;

    //
    // We already have memory descriptors that describe the physical memory
    // layout on the system.  We must walk this list and do some tweaking
    // to describe our memory layout.
    //

    SuMemory = MDArray;
    while (SuMemory->PageCount != 0) {
        PageStart = SuMemory->BasePage;
        PageEnd   = SuMemory->BasePage+SuMemory->PageCount;
#if DBG_MEMORY
        wsprintf( DebugBuffer, L"PageStart (%x), PageEnd (%x), Type (%x)\r\n", PageStart, PageEnd, SuMemory->MemoryType);
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
        DBG_EFI_PAUSE();
#endif

        //
        // we have no TRs for memory under 16MB so we can't use it in
        // the loader -- mark it as off limits
        //
        if ((PageStart < _16MB)  && 
            (PageStart >= _1MB)  &&
            (SuMemory->MemoryType == MemoryFree)) {
            ULONG TmpPageEnd = (PageEnd > _16MB) ? _16MB : PageEnd;

            Status = MempAllocDescriptor( PageStart, TmpPageEnd,
                                   MemoryFirmwareTemporary );

            if (Status != ESUCCESS) {
               break;
            }

            PageStart = TmpPageEnd;

            if (PageStart != PageEnd ) {
                SuMemory->PageCount -= (PageStart - SuMemory->BasePage);
                SuMemory->BasePage = PageStart;
            }

        }

        //
        // Move to the next memory descriptor
        //

        ++SuMemory;

    }

    if (Status != ESUCCESS) {
#if DBG
        wsprintf( DebugBuffer, TEXT("MempSetDescriptorRegion failed %lx\n"),Status);
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);    
#endif
        return(Status);
    }

    //
    // Describe the BIOS area.  We are essentially burning the 1st Meg so the OS
    // can do legacy INT emulation.
    //
    // Note: EFI marks the 1st Meg as "boot services data" so that it won't 
    // touch it.  Once we get into the OS, we need to preserve this same
    // hack (for video card frame buffer, etc).  We only really need to preserve
    // 640K - 1MB, but there is a dependency in the x86 emulation code in the
    // Hal upon this region being zero-based.  So we burn 640K, and that's life.
    //

#if DBG_MEMORY
    wsprintf( DebugBuffer,  L"Mark 'BIOS' region %x - %x as firmware permanent\r\n", 0, ROM_END_PAGE );
    EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
    MempSetDescriptorRegion(0, ROM_END_PAGE, MemoryFirmwarePermanent);

    //
    //  Make 48mb - 64mb reserved for OS loading
    //
    //  THIS IS A HACK - there is IA64 code in blmemory.c:BlMemoryInitialize that is dependent on 
    //  any descriptor which starts less than 48MB not extending beyond 48MB range. So we mark
    //  48-80 as "free" in order to split the existing (much larger) descriptor
    //
#if DBG_MEMORY
    wsprintf( DebugBuffer,  L"Mark region %x - %x for systemblock\r\n", _48MB, _80MB );
    EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
    Status = MempAllocDescriptor(_48MB,
                                 _80MB,
                                 MemoryFree);

    if (Status != ESUCCESS) {
#if DBG
        wsprintf( DebugBuffer,  L"Mark systemblock region failed %x\r\n", Status );
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
        return(Status);
    }

#if 0
#if DBG_MEMORY
     
    SuMemory = MDArray;
    while (SuMemory->PageCount != 0) {
        PageStart = SuMemory->BasePage;
        PageEnd   = SuMemory->BasePage+SuMemory->PageCount;

        wsprintf( DebugBuffer, L"dumpmem: PageStart (%x), PageEnd (%x), Type (%x)\r\n", PageStart, PageEnd, SuMemory->MemoryType);
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
        DBG_EFI_PAUSE();

        ++SuMemory;
    }

#endif
#endif

#if DBG
    EfiST->ConOut->OutputString( EfiST->ConOut, TEXT("About to Go Virtual\r\n") );
#endif

{
    extern BOOLEAN isOSCHOICE;
    if ((BootContext->MediaType == BootMediaTcpip) &&
        (isOSCHOICE == FALSE)) {
        Status = MempSetDescriptorRegion(_16MB,
                                         _48MB,
                                         MemoryFree);
        if( Status != ESUCCESS ) {
            EfiST->ConOut->OutputString( EfiST->ConOut, TEXT("Failed to reclaim 16MB to 48MB!!!"));
        }
    }

    //
    // Setup TR's used by the NT loader and go into virtual addressing mode.
    //
    if ((BootContext->MediaType != BootMediaTcpip) ||
        (isOSCHOICE == TRUE)) {        
#if DBG
        EfiST->ConOut->OutputString( EfiST->ConOut, TEXT("Really going virtual\r\n") );
#endif        
        Status = MempGoVirtual();
    }
}

    GoneVirtual = TRUE;

    if (Status != ESUCCESS) {
        return(Status);
    }

    return(Status);
}

ARC_STATUS
MempSetDescriptorRegion (
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    )
/*++

Routine Description:

    This function sets a range to the corresponding memory type.
    Descriptors will be removed, modified, inserted as needed to
    set the specified range.

Arguments:

    StartPage  - Supplies the beginning page of the new memory descriptor

    EndPage    - Supplies the ending page of the new memory descriptor

    MemoryType - Supplies the type of memory of the new memory descriptor

Return Value:

    ESUCCESS - Memory descriptor succesfully added to MDL array

    ENOMEM   - MDArray is full.

--*/
{
    ULONG           i;
    ULONG           sp, ep;
    TYPE_OF_MEMORY  mt;
    BOOLEAN         RegionAdded;

    if (EndPage <= StartPage) {
        //
        // This is a completely bogus memory descriptor. Ignore it.
        //

#ifdef LOADER_DEBUG
        wsprintf( DebugBuffer, TEXT("Attempt to create invalid memory descriptor %lx - %lx\n"),
                StartPage,EndPage);
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
        return(ESUCCESS);
    }

    RegionAdded = FALSE;

    //
    // Clip, remove, any descriptors in target area
    //

    for (i=0; i < NumberDescriptors; i++) {
        sp = MDArray[i].BasePage;
        ep = MDArray[i].BasePage + MDArray[i].PageCount;
        mt = MDArray[i].MemoryType;

        if (sp < StartPage) {
            if (ep > StartPage  &&  ep <= EndPage) {
                // truncate this descriptor
                ep = StartPage;
            }

            if (ep > EndPage) {
                //
                // Target area is contained totally within this
                // descriptor.  Split the descriptor into two ranges
                //

                if (NumberDescriptors == MaxDescriptors) {
#if DBG
                    wsprintf( DebugBuffer,  TEXT("ENOMEM returned %S %d\n"), __FILE__, __LINE__ );
                    EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
                    return(ENOMEM);
                }

                //
                // Add descriptor for EndPage - ep
                //

                MDArray[NumberDescriptors].MemoryType = mt;
                MDArray[NumberDescriptors].BasePage   = EndPage;
                MDArray[NumberDescriptors].PageCount  = ep - EndPage;
                NumberDescriptors += 1;

                //
                // Adjust current descriptor for sp - StartPage
                //

                ep = StartPage;
            }

        } else {
            // sp >= StartPage

            if (sp < EndPage) {
                if (ep < EndPage) {
                    //
                    // This descriptor is totally within the target area -
                    // remove it
                    //

                    ep = sp;

                }  else {
                    // bump begining page of this descriptor
                    sp = EndPage;
                }
            }
        }

        //
        // Check if the new range can be appended or prepended to
        // this descriptor
        //
        if (mt == MemoryType && !RegionAdded) {
            if (sp == EndPage) {
                // prepend region being set
                sp = StartPage;
                RegionAdded = TRUE;

            } else if (ep == StartPage) {
                // append region being set
                ep = EndPage;
                RegionAdded = TRUE;

            }
        }

        if (MDArray[i].BasePage == sp  &&  MDArray[i].PageCount == ep-sp) {

            //
            // Descriptor was not editted
            //

            continue;
        }

        //
        // Reset this descriptor
        //

        MDArray[i].BasePage  = sp;
        MDArray[i].PageCount = ep - sp;

        if (ep == sp) {

            //
            // Descriptor vanished - remove it
            //

            NumberDescriptors -= 1;
            if (i < NumberDescriptors) {
                MDArray[i] = MDArray[NumberDescriptors];
            }

            i--;        // backup & recheck current position
        }
    }

    //
    // If region wasn't already added to a neighboring region, then
    // create a new descriptor now
    //

    if (!RegionAdded  &&  MemoryType < LoaderMaximum) {
        if (NumberDescriptors == MaxDescriptors) {
#if DBG
            wsprintf( DebugBuffer,  TEXT("ENOMEM returned %S %d\n"), __FILE__, __LINE__ );
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
            return(ENOMEM);
        }

#ifdef LOADER_DEBUG
        wsprintf( DebugBuffer, TEXT("Adding '%lx - %lx, type %x' to descriptor list\n"),
                StartPage << PAGE_SHIFT,
                EndPage << PAGE_SHIFT,
                (USHORT) MemoryType
                );
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif

        MDArray[NumberDescriptors].MemoryType = MemoryType;
        MDArray[NumberDescriptors].BasePage   = StartPage;
        MDArray[NumberDescriptors].PageCount  = EndPage - StartPage;
        NumberDescriptors += 1;
    }
    return (ESUCCESS);
}

ARC_STATUS
MempAllocDescriptor(
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    )

/*++

Routine Description:

    This routine carves out a specific memory descriptor from the
    memory descriptors that have already been created.  The MD array
    is updated to reflect the new state of memory.

    The new memory descriptor must be completely contained within an
    already existing memory descriptor.  (i.e.  memory that does not
    exist should never be marked as a certain type)

Arguments:

    StartPage  - Supplies the beginning page of the new memory descriptor

    EndPage    - Supplies the ending page of the new memory descriptor

    MemoryType - Supplies the type of memory of the new memory descriptor

Return Value:

    ESUCCESS - Memory descriptor succesfully added to MDL array

    ENOMEM   - MDArray is full.

--*/
{
    ULONG i;

    //
    // Walk through the memory descriptors until we find one that
    // contains the start of the descriptor.
    //
    for (i=0; i<NumberDescriptors; i++) {
        if ((MDArray[i].MemoryType == MemoryFree) &&
            (MDArray[i].BasePage <= StartPage )     &&
            (MDArray[i].BasePage+MDArray[i].PageCount >  StartPage) &&
            (MDArray[i].BasePage+MDArray[i].PageCount >= EndPage)) {

            break;
        }
    }

    if (i==MaxDescriptors) {
#if DBG
        wsprintf( DebugBuffer,  TEXT("NumDescriptors filled (%x) ENOMEM returned %S %d\r\n"), MaxDescriptors, __FILE__, __LINE__ );
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
        return(ENOMEM);
    }

    if (MDArray[i].BasePage == StartPage) {

        if (MDArray[i].BasePage+MDArray[i].PageCount == EndPage) {

            //
            // The new descriptor is identical to the existing descriptor.
            // Simply change the memory type of the existing descriptor in
            // place.
            //
#if DBG_MEMORY
            wsprintf( DebugBuffer,  TEXT("descriptor (%x) matched -- change type from %x to %x\r\n"), MDArray[i].BasePage, MDArray[i].MemoryType, MemoryType  );
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
            MDArray[i].MemoryType = MemoryType;
        } else {

            //
            // The new descriptor starts on the same page, but is smaller
            // than the existing descriptor.  Shrink the existing descriptor
            // by moving its start page up, and create a new descriptor.
            //
            if (NumberDescriptors == MaxDescriptors) {
#if DBG_MEMORY
                wsprintf( DebugBuffer,  TEXT("out of descriptors trying to grow (%x) (%x total)\r\n"), MDArray[i].BasePage,NumberDescriptors  );
                EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
#if DBG
                wsprintf( DebugBuffer,  TEXT("ENOMEM returned %S %d\n"), __FILE__, __LINE__ );
                EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
                return(ENOMEM);
            }

#if DBG_MEMORY
            wsprintf( 
                DebugBuffer,  
                TEXT("split descriptor starting at %x into two (%x pagecount into %x (size %x) and %x size %x)\r\n"), 
                StartPage,
                MDArray[i].PageCount,
                EndPage,
                MDArray[i].PageCount - (EndPage-StartPage),
                StartPage,
                EndPage-StartPage  );
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif

            MDArray[i].BasePage = EndPage;
            MDArray[i].PageCount -= (EndPage-StartPage);

            MDArray[NumberDescriptors].BasePage = StartPage;
            MDArray[NumberDescriptors].PageCount = EndPage-StartPage;
            MDArray[NumberDescriptors].MemoryType = MemoryType;
            ++NumberDescriptors;

        }
    } else if (MDArray[i].BasePage+MDArray[i].PageCount == EndPage) {

        //
        // The new descriptor ends on the same page.  Shrink the existing
        // by decreasing its page count, and create a new descriptor.
        //
        if (NumberDescriptors == MaxDescriptors) {
#if DBG_MEMORY
            wsprintf( DebugBuffer,  TEXT("out of descriptors trying to shrink (%x) (%x total)\r\n"), MDArray[i].BasePage,NumberDescriptors  );
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
#if DBG
            wsprintf( DebugBuffer,  TEXT("ENOMEM returned %S %d\n"), __FILE__, __LINE__ );
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
            return(ENOMEM);
        }

#if DBG_MEMORY
        wsprintf( 
                DebugBuffer,  
                TEXT("shrink descriptor starting at %x into two (%x pagecount into %x (size %x) and %x size %x, type %x)\r\n"), 
                MDArray[i].BasePage,
                MDArray[i].PageCount,
                MDArray[i].BasePage,
                StartPage - MDArray[i].BasePage,
                StartPage,
                EndPage-StartPage,
                MemoryType  );
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif

        MDArray[i].PageCount = StartPage - MDArray[i].BasePage;

        MDArray[NumberDescriptors].BasePage = StartPage;
        MDArray[NumberDescriptors].PageCount = EndPage-StartPage;
        MDArray[NumberDescriptors].MemoryType = MemoryType;
        ++NumberDescriptors;
    } else {

        //
        // The new descriptor is in the middle of the existing descriptor.
        // Shrink the existing descriptor by decreasing its page count, and
        // create two new descriptors.
        //

        if (NumberDescriptors+1 >= MaxDescriptors) {
#if DBG_MEMORY
            wsprintf( DebugBuffer,  TEXT("out of descriptors trying to shrink (%x) (%x total)\r\n"), MDArray[i].BasePage,NumberDescriptors  );
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
#if DBG
            wsprintf( DebugBuffer,  TEXT("ENOMEM returned %S %d\n"), __FILE__, __LINE__ );
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
            return(ENOMEM);
        }

#if DBG_MEMORY
        wsprintf( 
            DebugBuffer,  
            TEXT("split descriptor starting at %x into 3 (%x pagecount into %x (size %x), %x size %x (memory free), %x size %x, type %x)\r\n"), 
            MDArray[i].BasePage,
            MDArray[i].PageCount,
            MDArray[i].BasePage,
            StartPage-MDArray[i].BasePage,
            EndPage,
            MDArray[i].PageCount - (EndPage-MDArray[i].BasePage),
            StartPage,
            EndPage-StartPage,
            MemoryType  );
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif

        MDArray[NumberDescriptors].BasePage = EndPage;
        MDArray[NumberDescriptors].PageCount = MDArray[i].PageCount -
                (EndPage-MDArray[i].BasePage);
        MDArray[NumberDescriptors].MemoryType = MemoryFree;
        ++NumberDescriptors;

        MDArray[i].PageCount = StartPage - MDArray[i].BasePage;

        MDArray[NumberDescriptors].BasePage = StartPage;
        MDArray[NumberDescriptors].PageCount = EndPage-StartPage;
        MDArray[NumberDescriptors].MemoryType = MemoryType;
        ++NumberDescriptors;
    }

    return(ESUCCESS);
}

#if FW_HEAP
PVOID
FwAllocateHeapPermanent(
    IN ULONG NumberPages
    )

/*++

Routine Description:

    This allocates pages from the private heap.  The memory descriptor for
    the LoaderMemoryData area is grown to include the returned pages, while
    the memory descriptor for the temporary heap is shrunk by the same amount.

    N.B.    DO NOT call this routine after we have passed control to
            BlOsLoader!  Once BlOsLoader calls BlMemoryInitialize, the
            firmware memory descriptors are pulled into the OS Loader heap
            and those are the descriptors passed to the kernel.  So any
            changes in the firmware private heap will be irrelevant.

            If you need to allocate permanent memory after the OS Loader
            has initialized, use BlAllocateDescriptor.

Arguments:

    NumberPages - size of memory to allocate (in pages)

Return Value:

    Pointer to block of memory, if successful.
    NULL, if unsuccessful.

--*/

{

    PVOID MemoryPointer;
    PMEMORY_DESCRIPTOR Descriptor;

    if (FwPermanentHeap + (NumberPages << PAGE_SHIFT) > FwTemporaryHeap) {

        //
        // Our heaps collide, so we are out of memory
        //

        wsprintf( DebugBuffer, TEXT("Out of permanent heap!\n"));
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
        while (1) {
        }

        return(NULL);
    }

    //
    // Find the memory descriptor which describes the LoaderMemoryData area,
    // so we can grow it to include the just-allocated pages.
    //
    Descriptor = MDArray;
    while (Descriptor->MemoryType != LoaderMemoryData) {
        ++Descriptor;
        if (Descriptor > MDArray+MaxDescriptors) {
            wsprintf( DebugBuffer, TEXT("ERROR - FwAllocateHeapPermanent couldn't find the LoaderMemoryData descriptor!\r\n"));
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);            
            return(NULL);
        }
    }
    Descriptor->PageCount += NumberPages;

    //
    // We know that the memory descriptor after this one is the firmware
    // temporary heap descriptor.  Since it is physically contiguous with our
    // LoaderMemoryData block, we remove the pages from its descriptor.
    //

    ++Descriptor;
    Descriptor->PageCount -= NumberPages;
    Descriptor->BasePage  += NumberPages;

    MemoryPointer = (PVOID)FwPermanentHeap;
    FwPermanentHeap += NumberPages << PAGE_SHIFT;

    return(MemoryPointer);
}


PVOID
FwAllocateHeap(
    IN ULONG Size
    )

/*++

Routine Description:

    Allocates memory from the "firmware" temporary heap.

Arguments:

    Size - Supplies size of block to allocate

Return Value:

    PVOID - Pointer to the beginning of the block
    NULL  - Out of memory

--*/

{
    ULONG i;
    ULONG SizeInPages;
    ULONG StartPage;
    ARC_STATUS Status;

    if (((FwTemporaryHeap - FwPermanentHeap) < Size) && (FwDescriptorsValid)) {
        //
        // Large allocations get their own descriptor so miniports that
        // have huge device extensions don't pull up all of the heap.
        //
        // Note that we can only do this while running in "firmware" mode.
        // Once we call into the osloader, it pulls all the memory descriptors
        // out of the "firmware" and changes to this list will not show
        // up there.
        //
        // We are looking for a descriptor that is MemoryFree and <16Mb.
        //
        SizeInPages = (Size+PAGE_SIZE-1) >> PAGE_SHIFT;

        for (i=0; i<NumberDescriptors; i++) {
            if ((MDArray[i].MemoryType == MemoryFree) &&
                (MDArray[i].BasePage <= _80MB_BOGUS) &&
                (MDArray[i].PageCount >= SizeInPages)) {
                break;
            }
        }

        if (i < NumberDescriptors) {
            StartPage = MDArray[i].BasePage+MDArray[i].PageCount-SizeInPages;
            Status = MempAllocDescriptor(StartPage,
                                         StartPage+SizeInPages,
                                         MemoryFirmwareTemporary);
            if (Status==ESUCCESS) {
                return((PVOID)(ULONG_PTR)(StartPage << PAGE_SHIFT));
            }
        }
    }

    FwTemporaryHeap -= Size;

    //
    // Round down to 16-byte boundary
    //

    FwTemporaryHeap &= ~((ULONG)0xf);

    if (FwTemporaryHeap < FwPermanentHeap) {
#if DBG
        wsprintf( DebugBuffer, TEXT("Out of temporary heap!\n"));
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
        return(NULL);
    }

    return((PVOID)FwTemporaryHeap);

}
#endif // FW_HEAP

#if FW_HEAP


PVOID
FwAllocatePool(
    IN ULONG Size
    )

/*++

Routine Description:

    This routine allocates memory from the firmware pool.  Note that
    this memory is NOT under the 1MB line, so it cannot be used for
    anything that must be accessed from real mode.  It is currently used
    only by the SCSI miniport drivers and dbcs font loader.
        
Arguments:

    Size - Supplies size of block to allocate.

Return Value:

    PVOID - pointer to the beginning of the block
    NULL - out of memory

--*/

{
    PVOID Buffer;
    ULONG NewSize;

    //
    // round size up to 16 byte boundary
    //
    NewSize = (Size + 15) & ~0xf;
    if ((FwPoolStart + NewSize) <= FwPoolEnd) {

        Buffer = (PVOID)FwPoolStart;
        FwPoolStart += NewSize;
        return(Buffer);

    } else {
        //
        // we've used up all our pool, try to allocate from the heap.
        //
        return(BlAllocateHeap(Size));
    }


}



PVOID
FwAllocateHeapAligned(
    IN ULONG Size
    )

/*++

Routine Description:

    Allocates memory from the "firmware" temporary heap.  This memory is
    always allocated on a page boundary, so it can readily be used for
    temporary page tables

Arguments:

    Size - Supplies size of block to allocate

Return Value:

    PVOID - Pointer to the beginning of the block
    NULL  - Out of memory

--*/

{

    FwTemporaryHeap -= Size;

    //
    // Round down to a page boundary
    //

    FwTemporaryHeap &= ~(PAGE_SIZE-1);

    if (FwTemporaryHeap < FwPermanentHeap) {
        wsprintf( DebugBuffer, TEXT("Out of temporary heap!\n")s);
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
        return(NULL);
    }
    RtlZeroMemory((PVOID)FwTemporaryHeap,Size);

    return((PVOID)FwTemporaryHeap);

}
#endif

#if !defined(NO_LEGACY_DRIVERS)
//
// This isn't used under EFI -- the HalPT is only setup immediately
// before calling ExitBootServices(), and this routine is really
// only present if ntbootdd.sys must be used.
//


PVOID
MmMapIoSpace (
     IN PHYSICAL_ADDRESS PhysicalAddress,
     IN SIZE_T NumberOfBytes,
     IN MEMORY_CACHING_TYPE CacheType
     )

/*++

Routine Description:

    This function returns the corresponding virtual address for a
    known physical address.

Arguments:

    PhysicalAddress - Supplies the phiscal address.

    NumberOfBytes - Unused.

    CacheType - Unused.

Return Value:

    Returns the corresponding virtual address.

Environment:

    Kernel mode.  Any IRQL level.

--*/

{
    ULONG i;
    ULONG j;
    ULONG NumberPages;

    NumberPages = (ULONG)((NumberOfBytes+PAGE_SIZE-1) >> PAGE_SHIFT);

    //
    // We use the HAL's PDE for mapping memory buffers.
    // Find enough free PTEs.
    //

    for (i=0; i<=1024-NumberPages; i++) {
        for (j=0; j < NumberPages; j++) {
            if ((((PULONG)HalPT))[i+j]) {
                break;
            }
        }

        if (j == NumberPages) {
            for (j=0; j<NumberPages; j++) {
                HalPT[i+j].PageFrameNumber =
                                (PhysicalAddress.LowPart >> PAGE_SHIFT)+j;
                HalPT[i+j].Valid = 1;
                HalPT[i+j].Write = 1;
            }

            return((PVOID)((ULONG_PTR)(0xffc00000 | (i<<12) | (PhysicalAddress.LowPart & 0xfff))));
        }

    }
    return(NULL);
}


VOID
MmUnmapIoSpace (
     IN PVOID BaseAddress,
     IN SIZE_T NumberOfBytes
     )

/*++

Routine Description:

    This function unmaps a range of physical address which were previously
    mapped via an MmMapIoSpace function call.

Arguments:

    BaseAddress - Supplies the base virtual address where the physical
                  address was previously mapped.

    NumberOfBytes - Supplies the number of bytes which were mapped.

Return Value:

    None.

Environment:

    Kernel mode, IRQL of DISPATCH_LEVEL or below.

--*/

{
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\miscc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    miscc.c

Abstract:

    This file contains misc. functions used by NTLDR.

Author:

    Allen Kay (akay) 03-Mar-1999

Environment:

    Kernel mode

Revision History:

--*/

#include "bldr.h"
#include "stdio.h"
#include "bootia64.h"
#include "efi.h"
#include "extern.h"

typedef struct _PAL_RETURN_VALUES {
    ULONGLONG ReturnValue0;
    ULONGLONG ReturnValue1;
    ULONGLONG ReturnValue2;
    ULONGLONG ReturnValue3;
} PAL_RETURN_VALUES, *PPAL_RETURN_VALUES;

typedef union _PAL_REVISION {
    struct {
        ULONGLONG PalBRevLower:4;
        ULONGLONG PalBRevUpper:4;
        ULONGLONG PalBModel:8;
        ULONGLONG Reserved0:8;
        ULONGLONG PalVendor:8;
        ULONGLONG PalARevision:8;
        ULONGLONG PalAModel:8;
        ULONGLONG Reserved1:16;
    };
    ULONGLONG PalVersion;
} PAL_REVISION;

extern
PAL_RETURN_VALUES
BlpPalProc(
    IN ULONGLONG FunctionIndex,
    IN ULONGLONG Arg1,
    IN ULONGLONG Arg2,
    IN ULONGLONG Arg3
);


VOID
CallPal(
    IN  ULONGLONG FunctionIndex,
    IN  ULONGLONG Argument0,
    IN  ULONGLONG Argument1,
    IN  ULONGLONG Argument2,
    OUT PULONGLONG ReturnValue0,
    OUT PULONGLONG ReturnValue1,
    OUT PULONGLONG ReturnValue2,
    OUT PULONGLONG ReturnValue3
    )
{
    PAL_RETURN_VALUES RetVal;

    RetVal = BlpPalProc(FunctionIndex, Argument0, Argument1, Argument2);
    *ReturnValue0 = RetVal.ReturnValue0;
    *ReturnValue1 = RetVal.ReturnValue1;
    *ReturnValue2 = RetVal.ReturnValue2;
    *ReturnValue3 = RetVal.ReturnValue3;
}

VOID
ReadProcessorConfigInfo(
    PPROCESSOR_CONFIG_INFO ProcessorConfigInfo
    )
{
    ULONGLONG Status;
    ULONGLONG Reserved;

    if ((PUCHAR) ProcessorConfigInfo >= (PUCHAR) KSEG0_BASE) {
        (PUCHAR) ProcessorConfigInfo -= KSEG0_BASE;
    }

    CallPal (
        PAL_VM_PAGE_SIZE,
        0,
        0,
        0,
        &Status,
        &ProcessorConfigInfo->InsertPageSizeInfo,
        &ProcessorConfigInfo->PurgePageSizeInfo,
        &Reserved
        );

    if (Status) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                 L"ReadProcessorConfigInfo: PAL call PAL_VM_PAGE_SIZE failed.\n\r");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CallPal (
        PAL_VM_SUMMARY,
        0,
        0,
        0,
        &Status,
        &ProcessorConfigInfo->VmSummaryInfo1.Ulong64,
        &ProcessorConfigInfo->VmSummaryInfo2.Ulong64,
        &Reserved
        );

    if (Status) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                 L"ReadProcessorConfigInfo: PAL call PAL_VM_SUMMARY failed.\n\r");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CallPal (
        PAL_RSE_INFO,
        0,
        0,
        0,
        &Status,
        &ProcessorConfigInfo->NumOfPhysStackedRegs,
        &ProcessorConfigInfo->RseHints,
        &Reserved
        );

    if (Status) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                 L"ReadProcessorConfigInfo: PAL call PAL_RSE_INFO failed.\n\r");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CallPal (
        PAL_PTCE_INFO,
        0,
        0,
        0,
        &Status,
        &ProcessorConfigInfo->PtceInfo.PtceBase,
        &ProcessorConfigInfo->PtceInfo.PtceTcCount.Ulong64,
        &ProcessorConfigInfo->PtceInfo.PtceStrides.Ulong64
        );

    if (Status) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                 L"ReadProcessorConfigInfo: PAL call PAL_PTCE_INFO failed.\n\r");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CallPal (
        PAL_PROC_GET_FEATURES,
        0,
        0,
        0,
        &Status,
        &ProcessorConfigInfo->FeaturesImplemented.Ulong64,
        &ProcessorConfigInfo->FeaturesCurSetting.Ulong64,
        &ProcessorConfigInfo->FeaturesSoftControl.Ulong64
        );

    if (Status) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                 L"ReadProcessorConfigInfo: PAL call PAL_PROC_GET_FEATURES failed.\n\r");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }
}


VOID
CpuSpecificWork(
    )
/*++

Routine Description:

    This routine checks for CPU ID and applies processor specific workarounds.

Arguments:

    None

Returns:

    None

--*/

{
    ULONGLONG CpuId;
    ULONGLONG CpuFamily;

    CpuId     = __getReg(CV_IA64_CPUID3);
    CpuFamily = (CpuId >> 24) & 0xff;

    //
    // if the processor is an Itanium...
    //
    if (CpuFamily == 7) {

        //
        // We must ensure that the processor and PAL are supported before continuing.
        //

        EnforcePostB2Processor();
        EnforcePostVersion16PAL();
        EfiCheckFirmwareRevision();

#if 0
        //
        // This is redundant since A2 < B3
        //
        CheckForPreA2Processors();
#endif
    }
}

VOID
EnforcePostB2Processor(
    )
/*++

Routine Description:

    This routine checks enforces that the system has a post B2 processor stepping.

Arguments:

    None

Returns:

    None

--*/

{
    ULONGLONG CpuId3;

    CpuId3    = __getReg(CV_IA64_CPUID3);

#if 0
    {
        WCHAR       Buffer[256];
        ULONGLONG   x;

        x = (CpuId3 >> 0) & 0xff;
        wsprintf(Buffer, L"Number = %x\r\n", x);
        EfiST->ConOut->OutputString(EfiST->ConOut, Buffer);

        x = (CpuId3 >> 8) & 0xff;
        wsprintf(Buffer, L"Revision = %x\r\n", x);
        EfiST->ConOut->OutputString(EfiST->ConOut, Buffer);

        x = (CpuId3 >> 16) & 0xff;
        wsprintf(Buffer, L"Model = %x\r\n", x);
        EfiST->ConOut->OutputString(EfiST->ConOut, Buffer);

        x = (CpuId3 >> 24) & 0xff;
        wsprintf(Buffer, L"Family = %x\r\n", x);
        EfiST->ConOut->OutputString(EfiST->ConOut, Buffer);

        x = (CpuId3 >> 32) & 0xff;
        wsprintf(Buffer, L"Archrev = %x\r\n", x);
        EfiST->ConOut->OutputString(EfiST->ConOut, Buffer);

        DBG_EFI_PAUSE();
    }
#endif

    //
    // Block Processor steppings below B3
    //
    // Note: this switch came from: ntos\ke\ia64\initkr.c
    //
    switch (CpuId3) {
    case 0x0007000004: // Itanium, A stepping
    case 0x0007000104: // Itanium, B0 stepping
    case 0x0007000204: // Itanium, B1 stepping
    case 0x0007000304: // Itanium, B2 stepping
        //
        // unsupported steppings
        //
        EfiST->ConOut->OutputString(EfiST->ConOut,
            L"Your Itanium system contains a pre-B3 stepping processor.\n\r");
        EfiST->ConOut->OutputString(EfiST->ConOut,
            L"You need to upgrade it to a B3 or later stepping to run Win64.\n\r");
        EfiBS->Exit(EfiImageHandle, 0, 0, 0);
        break;

    case 0x0007000404: // Itanium, B3 stepping
    case 0x0007000504: // Itanium, B4 stepping
    case 0x0007000604: // Itanium, C0 or later stepping
    default:
        //
        // supported steppings, do nothing
        //
        break;
    }

}

VOID
EnforcePostVersion16PAL(
    )

/*++

Routine Description:

    This routine enforces that the system has a PAL version >= 20.

    Note:

    The return value from get PAL version call has the
    PAL B model and revision has the least significant
    16 bits (Intel IA-64 Architecture Software Developer's Manual, Rav. 1.0, Page 11-109).
    We should be using this to determine a minimum PAL revision for the firmware.
    The first byte has the PAL_B_revision which is a monotonically increasing number
    and is 0x17 for Lion 71b and 0x20 for Softsur 103b.
    The PAL_B model indicates the stepping of the processor supported (We can ignore this one).
    So we need to be using PAL B revision for our minimum firmware test.

    Just an FYI:
    There is a disconnect in the PAL_REVISION structure and what appears to be the specified
    PAL revision layout.  We use PAL_B_REVISION to get the PAL version rather than PAL_A_REVISION.

Arguments:

    None

Returns:

    None

--*/

{
    ULONGLONG Status;
    PAL_REVISION MinimumPalVersion;
    PAL_REVISION CurrentPalVersion;
    ULONGLONG Reserved;

#define MIN_PAL_REVISION 0x23

    CallPal (
        PAL_VERSION,
        0,
        0,
        0,
        &Status,
        &MinimumPalVersion.PalVersion,
        &CurrentPalVersion.PalVersion,
        &Reserved
        );

    if (Status) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                 L"CheckForPreA2Processors: PAL call PAL_VERSION failed.\n\r");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

#if 0
    {
        WCHAR       Buffer[256];

        wsprintf(Buffer, L"PalBRevLower = %x\r\n", CurrentPalVersion.PalBRevLower);
        EfiST->ConOut->OutputString(EfiST->ConOut, Buffer);

        wsprintf(Buffer, L"PalBRevUpper = %x\r\n", CurrentPalVersion.PalBRevUpper);
        EfiST->ConOut->OutputString(EfiST->ConOut, Buffer);

        wsprintf(Buffer, L"PalBModel = %x\r\n", CurrentPalVersion.PalBModel);
        EfiST->ConOut->OutputString(EfiST->ConOut, Buffer);

        wsprintf(Buffer, L"Reserved0 = %x\r\n", CurrentPalVersion.Reserved0);
        EfiST->ConOut->OutputString(EfiST->ConOut, Buffer);

        wsprintf(Buffer, L"PalVendor = %x\r\n", CurrentPalVersion.PalVendor);
        EfiST->ConOut->OutputString(EfiST->ConOut, Buffer);

        wsprintf(Buffer, L"PalARevision = %x\r\n", CurrentPalVersion.PalARevision);
        EfiST->ConOut->OutputString(EfiST->ConOut, Buffer);

        wsprintf(Buffer, L"PalAModel = %x\r\n", CurrentPalVersion.PalAModel);
        EfiST->ConOut->OutputString(EfiST->ConOut, Buffer);

        wsprintf(Buffer, L"Reserved1 = %x\r\n", CurrentPalVersion.Reserved1);
        EfiST->ConOut->OutputString(EfiST->ConOut, Buffer);

        DBG_EFI_PAUSE();
    }
#endif

    if (CurrentPalVersion.PalARevision < MIN_PAL_REVISION) {
        WCHAR       Buffer[256];

        wsprintf(Buffer, L"Your Itanium system's PAL version is less than 0x%x.\n\r", MIN_PAL_REVISION);
        EfiST->ConOut->OutputString(EfiST->ConOut, Buffer);

        wsprintf(Buffer, L"You need to upgrade it to version 0x%x or later to run Win64.\n\r", MIN_PAL_REVISION);
        EfiST->ConOut->OutputString(EfiST->ConOut, Buffer);

        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

}



VOID
CheckForPreA2Processors(
    )
{
    ULONGLONG Status;
    PAL_REVISION MinimumPalVersion;
    PAL_REVISION CurrentPalVersion;
    ULONGLONG Reserved;

    CallPal (
        PAL_VERSION,
        0,
        0,
        0,
        &Status,
        &MinimumPalVersion.PalVersion,
        &CurrentPalVersion.PalVersion,
        &Reserved
        );

    if (Status) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                 L"CheckForPreA2Processors: PAL call PAL_VERSION failed.\n\r");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // If PalBRevUpper if 0, 1, 3 or 4 then it is A0/A1 stepping.
    //
    if (CurrentPalVersion.PalBModel == 0) {
        if ( (CurrentPalVersion.PalBRevUpper == 0) ||
             (CurrentPalVersion.PalBRevUpper == 1) ||
             (CurrentPalVersion.PalBRevUpper == 3) ||
             (CurrentPalVersion.PalBRevUpper == 4) ) {

            //
            // Since PAL version 27 supports A2 and A3 but
            // it returns 0, we need to special case this and
            // just return.
            //
            if ((CurrentPalVersion.PalBRevUpper == 0) &&
                (CurrentPalVersion.PalBRevLower == 0)    ) {
                return;
            }

            EfiST->ConOut->OutputString(EfiST->ConOut,
                 L"Your Itanium system contains an pre-A2 stepping processor.\n\r");
            EfiST->ConOut->OutputString(EfiST->ConOut,
                 L"You need to upgrade it to an A2 or later stepping to run Win64.\n\r");
            EfiBS->Exit(EfiImageHandle, Status, 0, 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\ixpcibus.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpcidat.c

Abstract:

    Get/Set bus data routines for the PCI bus

Author:

Environment:

    Kernel mode

Revision History:


--*/

#include "bootia64.h"
#include "arc.h"
#include "ixfwhal.h"
#include "ntconfig.h"

#include "pci.h"

//extern WCHAR rgzMultiFunctionAdapter[];
//extern WCHAR rgzConfigurationData[];
//extern WCHAR rgzIdentifier[];
//extern WCHAR rgzPCIIdentifier[];

//
// Hal specific PCI bus structures
//

typedef struct tagPCIPBUSDATA {
    union {
        struct {
            PULONG      Address;
            ULONG       Data;
        } Type1;
        struct {
            PUCHAR      CSE;
            PUCHAR      Forward;
            ULONG       Base;
        } Type2;
    } Config;

} PCIPBUSDATA, *PPCIPBUSDATA;

#define PciBitIndex(Dev,Fnc)    (Fnc*32 + Dev);
#define PCI_CONFIG_TYPE(PciData)    ((PciData)->HeaderType & ~PCI_MULTIFUNCTION)

#define BUSHANDLER  _BUSHANDLER
#define PBUSHANDLER _PBUSHANDLER

// thunk for NtLdr
typedef struct {
    ULONG           NoBuses;
    ULONG           BusNumber;
    PVOID           BusData;
    PCIPBUSDATA     theBusData;
} BUSHANDLER, *PBUSHANDLER;

#define HalpPCIPin2Line(bus,rbus,slot,pcidata)
#define HalpPCILine2Pin(bus,rbus,slot,pcidata,pcidata2)
#define ExAllocatePool(a,l) FwAllocatePool(l)
// thunk for NtLdr


typedef ULONG (*FncConfigIO) (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

typedef VOID (*FncSync) (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

typedef VOID (*FncReleaseSync) (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    );

typedef struct {
    FncSync         Synchronize;
    FncReleaseSync  ReleaseSynchronzation;
    FncConfigIO     ConfigRead[3];
    FncConfigIO     ConfigWrite[3];
} CONFIG_HANDLER, *PCONFIG_HANDLER;


//
// Prototypes
//

ULONG
HalpGetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpSetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

extern ULONG
HalpGetPCIInterruptVector (
    IN PBUSHANDLER BusHandler,
    IN PBUSHANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

NTSTATUS
HalpAdjustPCIResourceList (
    IN PBUSHANDLER BusHandler,
    IN PBUSHANDLER RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

NTSTATUS
HalpAssignPCISlotResources (
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

VOID
HalpInitializePciBuses (
    VOID
    );

//VOID
//HalpPCIPin2Line (
//    IN PBUSHANDLER         BusHandler,
//    IN PBUSHANDLER         RootHandler,
//    IN PCI_SLOT_NUMBER     Slot,
//    IN PPCI_COMMON_CONFIG  PciData
//    );
//
//VOID
//HalpPCILine2Pin (
//    IN PBUSHANDLER          BusHandler,
//    IN PBUSHANDLER          RootHandler,
//    IN PCI_SLOT_NUMBER      SlotNumber,
//    IN PPCI_COMMON_CONFIG   PciNewData,
//    IN PPCI_COMMON_CONFIG   PciOldData
//    );

BOOLEAN
HalpValidPCISlot (
    IN PBUSHANDLER     BusHandler,
    IN PCI_SLOT_NUMBER Slot
    );

VOID
HalpReadPCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


VOID
HalpWritePCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

PBUSHANDLER
HalpGetPciBusHandler (
    IN ULONG BusNumber
    );

//-------------------------------------------------

VOID HalpPCISynchronizeType1 (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

VOID HalpPCIReleaseSynchronzationType1 (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    );

ULONG HalpPCIReadUlongType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUcharType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUshortType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUlongType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUcharType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUshortType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

VOID HalpPCISynchronizeType2 (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

VOID HalpPCIReleaseSynchronzationType2 (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    );

ULONG HalpPCIReadUlongType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUcharType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUshortType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUlongType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUcharType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUshortType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );


//#define DISABLE_INTERRUPTS() //_asm { cli }
//#define ENABLE_INTERRUPTS()  //_asm { sti }


//
// Globals
//

ULONG               PCIMaxDevice;
BUSHANDLER          PCIBusHandler;

CONFIG_HANDLER      PCIConfigHandlers = {
    HalpPCISynchronizeType1,
    HalpPCIReleaseSynchronzationType1,
    {
        HalpPCIReadUlongType1,          // 0
        HalpPCIReadUcharType1,          // 1
        HalpPCIReadUshortType1          // 2
    },
    {
        HalpPCIWriteUlongType1,         // 0
        HalpPCIWriteUcharType1,         // 1
        HalpPCIWriteUshortType1         // 2
    }
};

CONFIG_HANDLER      PCIConfigHandlersType2 = {
    HalpPCISynchronizeType2,
    HalpPCIReleaseSynchronzationType2,
    {
        HalpPCIReadUlongType2,          // 0
        HalpPCIReadUcharType2,          // 1
        HalpPCIReadUshortType2          // 2
    },
    {
        HalpPCIWriteUlongType2,         // 0
        HalpPCIWriteUcharType2,         // 1
        HalpPCIWriteUshortType2         // 2
    }
};

UCHAR PCIDeref[4][4] = { {0,1,2,2},{1,1,1,1},{2,1,2,2},{1,1,1,1} };


VOID
HalpPCIConfig (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PUCHAR           Buffer,
    IN ULONG            Offset,
    IN ULONG            Length,
    IN FncConfigIO      *ConfigIO
    );


VOID
HalpInitializePciBus (
    VOID
    )
{
    PPCI_REGISTRY_INFO  PCIRegInfo;
    PPCIPBUSDATA        BusData;
    PBUSHANDLER         Bus;
    PCONFIGURATION_COMPONENT_DATA   ConfigData;
    PCM_PARTIAL_RESOURCE_LIST       Desc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PDesc;
    ULONG               i;
    ULONG               HwType;

    Bus = &PCIBusHandler;
    PCIBusHandler.BusData = &PCIBusHandler.theBusData;

    PCIRegInfo = NULL;      // not found
    ConfigData = NULL;      // start at begining
    do {
        ConfigData = KeFindConfigurationNextEntry (
            FwConfigurationTree,
            AdapterClass,
            MultiFunctionAdapter,
            NULL,
            &ConfigData
            );

        if (ConfigData == NULL) {
            // PCI info not found
            return ;
        }

        if (ConfigData->ComponentEntry.Identifier == NULL  ||
            _stricmp (ConfigData->ComponentEntry.Identifier, "PCI") != 0) {
            continue;
        }

        PCIRegInfo = NULL;
        Desc  = ConfigData->ConfigurationData;
        PDesc = Desc->PartialDescriptors;
        for (i = 0; i < Desc->Count; i++) {
            if (PDesc->Type == CmResourceTypeDeviceSpecific) {
                PCIRegInfo = (PPCI_REGISTRY_INFO) (PDesc+1);
                break;
            }
            PDesc++;
        }
    } while (!PCIRegInfo) ;

    //
    // PCIRegInfo describes the system's PCI support as indicated
    // by the BIOS.
    //

    HwType = PCIRegInfo->HardwareMechanism & 0xf;

    switch (HwType) {
        case 1:
            // this is the default case
            PCIMaxDevice = PCI_MAX_DEVICES;
            break;

        //
        // Type2 does not work MP, nor does the default type2
        // support more the 0xf device slots
        //

        case 2:
            RtlMoveMemory (&PCIConfigHandlers,
                           &PCIConfigHandlersType2,
                           sizeof (PCIConfigHandlersType2));
            PCIMaxDevice = 0x10;
            break;

        default:
            // unsupport type
            PCIRegInfo->NoBuses = 0;
    }

    PCIBusHandler.NoBuses = PCIRegInfo->NoBuses;
    if (PCIRegInfo->NoBuses) {

        BusData = (PPCIPBUSDATA) Bus->BusData;
        switch (HwType) {
            case 1:
                BusData->Config.Type1.Address = PCI_TYPE1_ADDR_PORT;
                BusData->Config.Type1.Data    = PCI_TYPE1_DATA_PORT;
                break;

            case 2:
                BusData->Config.Type2.CSE     = PCI_TYPE2_CSE_PORT;
                BusData->Config.Type2.Forward = PCI_TYPE2_FORWARD_PORT;
                BusData->Config.Type2.Base    = PCI_TYPE2_ADDRESS_BASE;
                break;
        }
    }
}


PBUSHANDLER
HalpGetPciBusHandler (
    IN ULONG BusNumber
    )
{
    if (PCIBusHandler.BusData == NULL) {
        HalpInitializePciBus ();
    }

    if (BusNumber > PCIBusHandler.NoBuses) {
        return NULL;
    }

    PCIBusHandler.BusNumber = BusNumber;
    return &PCIBusHandler;
}


ULONG
HalpGetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the Pci bus data for a device.

Arguments:

    BusNumber - Indicates which bus.

    VendorSpecificDevice - The VendorID (low Word) and DeviceID (High Word)

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

    If this PCI slot has never been set, then the configuration information
    returned is zeroed.


--*/
{
    PBUSHANDLER         BusHandler;
    PPCI_COMMON_CONFIG  PciData;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len;

    BusHandler = HalpGetPciBusHandler (BusNumber);
    if (!BusHandler) {
        return 0;
    }

    if (Length > sizeof (PCI_COMMON_CONFIG)) {
        Length = sizeof (PCI_COMMON_CONFIG);
    }

    Len = 0;
    PciData = (PPCI_COMMON_CONFIG) iBuffer;

    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // The user did not request any data from the common
        // header.  Verify the PCI device exists, then continue
        // in the device specific area.
        //

        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            return 0;
        }

    } else {

        //
        // Caller requested at least some data within the
        // common header.  Read the whole header, effect the
        // fields we need to and then copy the user's requested
        // bytes from the header
        //

        //
        // Read this PCI devices slot data
        //

        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, Len);

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            Len = 2;       // only return invalid id
        }

        //
        // Has this PCI device been configured?
        //

        BusData = (PPCIPBUSDATA) BusHandler->BusData;
        HalpPCIPin2Line (BusHandler, RootHandler, Slot, PciData);

        //
        // Copy whatever data overlaps into the callers buffer
        //

        if (Len < Offset) {
            // no data at caller's buffer
            return 0;
        }

        Len -= Offset;
        if (Len > Length) {
            Len = Length;
        }

        RtlMoveMemory(Buffer, iBuffer + Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and read from it.
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long & WORD aligned.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //

            HalpReadPCIConfig (BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return Len;
}

ULONG
HalpSetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the Pci bus data for a device.

Arguments:


    VendorSpecificDevice - The VendorID (low Word) and DeviceID (High Word)

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/
{
    PBUSHANDLER         BusHandler;
    PPCI_COMMON_CONFIG  PciData, PciData2;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    UCHAR               iBuffer2[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len;

    BusHandler = HalpGetPciBusHandler (BusNumber);
    if (!BusHandler) {
        return 0;
    }

    if (Length > sizeof (PCI_COMMON_CONFIG)) {
        Length = sizeof (PCI_COMMON_CONFIG);
    }

    Len = 0;
    PciData = (PPCI_COMMON_CONFIG) iBuffer;
    PciData2 = (PPCI_COMMON_CONFIG) iBuffer2;

    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // The user did not request any data from the common
        // header.  Verify the PCI device exists, then continue in
        // the device specific area.
        //

        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            return 0;
        }

    } else {

        //
        // Caller requested to set at least some data within the
        // common header.
        //

        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, Len);
        if (PciData->VendorID == PCI_INVALID_VENDORID  ||
            PCI_CONFIG_TYPE (PciData) != 0) {

            // no device, or header type unkown
            return 0;
        }

        //
        // Set this device as configured
        //

        BusData = (PPCIPBUSDATA) BusHandler->BusData;
        //
        // Copy COMMON_HDR values to buffer2, then overlay callers changes.
        //

        RtlMoveMemory (iBuffer2, iBuffer, Len);

        Len -= Offset;
        if (Len > Length) {
            Len = Length;
        }

        RtlMoveMemory (iBuffer2+Offset, Buffer, Len);

        // in case interrupt line or pin was editted
        HalpPCILine2Pin (BusHandler, RootHandler, Slot, PciData2, PciData);

        //
        // Set new PCI configuration
        //

        HalpWritePCIConfig (BusHandler, Slot, iBuffer2+Offset, Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and write it
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long & WORD aligned.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //

            HalpWritePCIConfig (BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return Len;
}

VOID
HalpReadPCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    if (!HalpValidPCISlot (BusHandler, Slot)) {
        //
        // Invalid SlotID return no data
        //

        RtlFillMemory (Buffer, Length, (UCHAR) -1);
        return ;
    }

    HalpPCIConfig (BusHandler, Slot, (PUCHAR) Buffer, Offset, Length,
                   PCIConfigHandlers.ConfigRead);
}

VOID
HalpWritePCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    if (!HalpValidPCISlot (BusHandler, Slot)) {
        //
        // Invalid SlotID do nothing
        //
        return ;
    }

    HalpPCIConfig (BusHandler, Slot, (PUCHAR) Buffer, Offset, Length,
                   PCIConfigHandlers.ConfigWrite);
}

BOOLEAN
HalpValidPCISlot (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot
    )
{
    PCI_SLOT_NUMBER                 Slot2;
    UCHAR                           HeaderType;
    ULONG                           i;

    if (Slot.u.bits.Reserved != 0) {
        return FALSE;
    }

    if (Slot.u.bits.DeviceNumber >= PCIMaxDevice) {
        return FALSE;
    }

    if (Slot.u.bits.FunctionNumber == 0) {
        return TRUE;
    }

    //
    // Non zero function numbers are only supported if the
    // device has the PCI_MULTIFUNCTION bit set in it's header
    //

    i = Slot.u.bits.DeviceNumber;

    //
    // Read DeviceNumber, Function zero, to determine if the
    // PCI supports multifunction devices
    //

    Slot2 = Slot;
    Slot2.u.bits.FunctionNumber = 0;

    HalpReadPCIConfig (
        BusHandler,
        Slot2,
        &HeaderType,
        FIELD_OFFSET (PCI_COMMON_CONFIG, HeaderType),
        sizeof (UCHAR)
        );

    if (!(HeaderType & PCI_MULTIFUNCTION) || HeaderType == 0xFF) {
        // this device doesn't exists or doesn't support MULTIFUNCTION types
        return FALSE;
    }

    return TRUE;
}


VOID
HalpPCIConfig (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PUCHAR           Buffer,
    IN ULONG            Offset,
    IN ULONG            Length,
    IN FncConfigIO      *ConfigIO
    )
{
    KIRQL               OldIrql;
    ULONG               i;
    UCHAR               State[20];
    PPCIPBUSDATA        BusData;

    BusData = (PPCIPBUSDATA) BusHandler->BusData;
    PCIConfigHandlers.Synchronize (BusHandler, Slot, &OldIrql, State);

    while (Length) {
        i = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];
        i = ConfigIO[i] (BusData, State, Buffer, Offset);

        Offset += i;
        Buffer += i;
        Length -= i;
    }

    PCIConfigHandlers.ReleaseSynchronzation (BusHandler, OldIrql);
}

VOID HalpPCISynchronizeType1 (
    IN PBUSHANDLER          BusHandler,
    IN PCI_SLOT_NUMBER      Slot,
    IN PKIRQL               Irql,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1
    )
{
    //
    // Initialize PciCfg1
    //

    PciCfg1->u.AsULONG = 0;
    PciCfg1->u.bits.BusNumber = BusHandler->BusNumber;
    PciCfg1->u.bits.DeviceNumber = Slot.u.bits.DeviceNumber;
    PciCfg1->u.bits.FunctionNumber = Slot.u.bits.FunctionNumber;
    PciCfg1->u.bits.Enable = TRUE;

    //
    // Synchronize with PCI type1 config space
    //

    //KeAcquireSpinLock (&HalpPCIConfigLock, Irql);
}

VOID HalpPCIReleaseSynchronzationType1 (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    )
{
    PCI_TYPE1_CFG_BITS  PciCfg1;
    PPCIPBUSDATA        BusData;

    //
    // Disable PCI configuration space
    //

    PciCfg1.u.AsULONG = 0;
    BusData = (PPCIPBUSDATA) BusHandler->BusData;
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1.u.AsULONG);

    //
    // Release spinlock
    //

    //KeReleaseSpinLock (&HalpPCIConfigLock, Irql);
}


ULONG
HalpPCIReadUcharType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *Buffer = READ_PORT_UCHAR ((PUCHAR)UlongToPtr((BusData->Config.Type1.Data + i)));
    return sizeof (UCHAR);
}

ULONG
HalpPCIReadUshortType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *((PUSHORT) Buffer) = READ_PORT_USHORT ((PUSHORT)ULongToPtr(BusData->Config.Type1.Data + i));
    return sizeof (USHORT);
}

ULONG
HalpPCIReadUlongType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *((PULONG) Buffer) = READ_PORT_ULONG ((PULONG)ULongToPtr(BusData->Config.Type1.Data));
    return sizeof (ULONG);
}


ULONG
HalpPCIWriteUcharType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_UCHAR ((PUCHAR)ULongToPtr(BusData->Config.Type1.Data + i), *Buffer);
    return sizeof (UCHAR);
}

ULONG
HalpPCIWriteUshortType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_USHORT ((PUSHORT)ULongToPtr(BusData->Config.Type1.Data + i), *((PUSHORT) Buffer));
    return sizeof (USHORT);
}

ULONG
HalpPCIWriteUlongType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_ULONG ((PULONG)ULongToPtr(BusData->Config.Type1.Data), *((PULONG) Buffer));
    return sizeof (ULONG);
}


VOID HalpPCISynchronizeType2 (
    IN PBUSHANDLER              BusHandler,
    IN PCI_SLOT_NUMBER          Slot,
    IN PKIRQL                   Irql,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr
    )
{
    PCI_TYPE2_CSE_BITS      PciCfg2Cse;
    PPCIPBUSDATA            BusData;

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    //
    // Initialize Cfg2Addr
    //

    PciCfg2Addr->u.AsUSHORT = 0;
    PciCfg2Addr->u.bits.Agent = (USHORT) Slot.u.bits.DeviceNumber;
    PciCfg2Addr->u.bits.AddressBase = (USHORT) BusData->Config.Type2.Base;

    //
    // Synchronize with type2 config space - type2 config space
    // remaps 4K of IO space, so we can not allow other I/Os to occur
    // while using type2 config space, hence the disable_interrupts.
    //

    //KeAcquireSpinLock (&HalpPCIConfigLock, Irql);
    //DISABLE_INTERRUPTS ();                      // is not MP safe

    PciCfg2Cse.u.AsUCHAR = 0;
    PciCfg2Cse.u.bits.Enable = TRUE;
    PciCfg2Cse.u.bits.FunctionNumber = (UCHAR) Slot.u.bits.FunctionNumber;
    PciCfg2Cse.u.bits.Key = 0xff;

    //
    // Select bus & enable type 2 configuration space
    //

    WRITE_PORT_UCHAR (BusData->Config.Type2.Forward, (UCHAR) BusHandler->BusNumber);
    WRITE_PORT_UCHAR (BusData->Config.Type2.CSE, PciCfg2Cse.u.AsUCHAR);
}


VOID HalpPCIReleaseSynchronzationType2 (
    IN PBUSHANDLER          BusHandler,
    IN KIRQL                Irql
    )
{
    PCI_TYPE2_CSE_BITS      PciCfg2Cse;
    PPCIPBUSDATA            BusData;

    //
    // disable PCI configuration space
    //

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    PciCfg2Cse.u.AsUCHAR = 0;
    WRITE_PORT_UCHAR (BusData->Config.Type2.CSE, PciCfg2Cse.u.AsUCHAR);

    //
    // Restore interrupts, release spinlock
    //

    //ENABLE_INTERRUPTS ();
    //KeReleaseSpinLock (&HalpPCIConfigLock, Irql);
}


ULONG
HalpPCIReadUcharType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    *Buffer = READ_PORT_UCHAR ((PUCHAR) PciCfg2Addr->u.AsUSHORT);
    return sizeof (UCHAR);
}

ULONG
HalpPCIReadUshortType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    *((PUSHORT) Buffer) = READ_PORT_USHORT ((PUSHORT) PciCfg2Addr->u.AsUSHORT);
    return sizeof (USHORT);
}

ULONG
HalpPCIReadUlongType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    *((PULONG) Buffer) = READ_PORT_ULONG ((PULONG) PciCfg2Addr->u.AsUSHORT);
    return sizeof(ULONG);
}


ULONG
HalpPCIWriteUcharType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_UCHAR ((PUCHAR) PciCfg2Addr->u.AsUSHORT, *Buffer);
    return sizeof (UCHAR);
}

ULONG
HalpPCIWriteUshortType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_USHORT ((PUSHORT) PciCfg2Addr->u.AsUSHORT, *((PUSHORT) Buffer));
    return sizeof (USHORT);
}

ULONG
HalpPCIWriteUlongType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_ULONG ((PULONG) PciCfg2Addr->u.AsUSHORT, *((PULONG) Buffer));
    return sizeof(ULONG);
}

NTSTATUS
HalpAssignPCISlotResources (
    IN ULONG                    BusNumber,
    IN ULONG                    Slot,
    IN OUT PCM_RESOURCE_LIST   *pAllocatedResources
    )
/*++

Routine Description:

    Reads the targeted device to determine it's required resources.
    Calls IoAssignResources to allocate them.
    Sets the targeted device with it's assigned resoruces
    and returns the assignments to the caller.

Arguments:

Return Value:

    STATUS_SUCCESS or error

--*/
{
    PBUSHANDLER                     BusHandler;
    UCHAR                           buffer[PCI_COMMON_HDR_LENGTH];
    UCHAR                           buffer2[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG              PciData, PciData2;
    PCI_SLOT_NUMBER                 PciSlot;
    ULONG                           i, j, length, type;
    PHYSICAL_ADDRESS                Address;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor;
    static PCM_RESOURCE_LIST        CmResList;

    BusHandler = HalpGetPciBusHandler (BusNumber);
    if (!BusHandler) {
        return 0;
    }

    *pAllocatedResources = NULL;

    PciData  = (PPCI_COMMON_CONFIG) buffer;
    PciData2 = (PPCI_COMMON_CONFIG) buffer2;
    PciSlot  = *((PPCI_SLOT_NUMBER) &Slot);
    BusNumber = BusHandler->BusNumber;

    //
    // Read the PCI device's configuration
    //

    HalpReadPCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    if (PciData->VendorID == PCI_INVALID_VENDORID) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Make a copy of the device's current settings
    //

    RtlMoveMemory (buffer2, buffer, PCI_COMMON_HDR_LENGTH);

    //
    // Set resources to all bits on to see what type of resources
    // are required.
    //

    for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
        PciData->u.type0.BaseAddresses[j] = 0xFFFFFFFF;
    }
    PciData->u.type0.ROMBaseAddress = 0xFFFFFFFF;

    PciData->Command &= ~(PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE);
    PciData->u.type0.ROMBaseAddress &= ~PCI_ROMADDRESS_ENABLED;
    HalpWritePCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    HalpReadPCIConfig  (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    HalpPCIPin2Line (BusHandler, RootHandler, PciSlot, PciData);

    //
    // Restore the device's settings in case we don't complete
    //

    HalpWritePCIConfig (BusHandler, PciSlot, buffer2, 0, PCI_COMMON_HDR_LENGTH);

    //
    // Build a CmResource descriptor list for the device
    //

    if (!CmResList) {
        // NtLdr pool is only allocated and never freed.  Allocate the
        // buffer once, and from then on just use the buffer over

        CmResList = ExAllocatePool (PagedPool,
            sizeof (CM_RESOURCE_LIST) +
            sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) * (PCI_TYPE0_ADDRESSES + 2)
            );
    }

    if (!CmResList) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory (CmResList,
        sizeof (CM_RESOURCE_LIST) +
        sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) * (PCI_TYPE0_ADDRESSES + 2)
        );

    *pAllocatedResources = CmResList;
    CmResList->List[0].InterfaceType = PCIBus;
    CmResList->List[0].BusNumber = BusNumber;

    CmDescriptor = CmResList->List[0].PartialResourceList.PartialDescriptors;
    if (PciData->u.type0.InterruptPin) {

        CmDescriptor->Type = CmResourceTypeInterrupt;
        CmDescriptor->ShareDisposition = CmResourceShareShared;
        CmDescriptor->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;

        // in the loader interrupts aren't actually enabled, so just
        // pass back the untranslated values
        CmDescriptor->u.Interrupt.Level = PciData->u.type0.InterruptLine;
        CmDescriptor->u.Interrupt.Vector =  PciData->u.type0.InterruptLine;
        CmDescriptor->u.Interrupt.Affinity = 1;

        CmResList->List[0].PartialResourceList.Count++;
        CmDescriptor++;
    }

    // clear last address index + 1
    PciData->u.type0.BaseAddresses[PCI_TYPE0_ADDRESSES] = 0;
    if (PciData2->u.type0.ROMBaseAddress & PCI_ROMADDRESS_ENABLED) {

        // put rom address in last index+1
        PciData->u.type0.BaseAddresses[PCI_TYPE0_ADDRESSES] =
            PciData->u.type0.ROMBaseAddress & ~PCI_ADDRESS_IO_SPACE;

        PciData2->u.type0.BaseAddresses[PCI_TYPE0_ADDRESSES] =
            PciData2->u.type0.ROMBaseAddress & ~PCI_ADDRESS_IO_SPACE;
    }

    for (j=0; j < PCI_TYPE0_ADDRESSES + 1; j++) {
        if (PciData->u.type0.BaseAddresses[j]) {
            i = PciData->u.type0.BaseAddresses[j];

            // scan for first set bit, that's the length & alignment
            length = 1 << (i & PCI_ADDRESS_IO_SPACE ? 2 : 4);
            Address.HighPart = 0;
            Address.LowPart = PciData2->u.type0.BaseAddresses[j] & ~(length-1);
            while (!(i & length)  &&  length) {
                length <<= 1;
            }

            // translate bus specific address
            type = (i & PCI_ADDRESS_IO_SPACE) ? 0 : 1;
            if (!HalTranslateBusAddress (
                    PCIBus,
                    BusNumber,
                    Address,
                    &type,
                    &Address )) {
                // translation failed, skip it
                continue;
            }

            // fill in CmDescriptor to return
            if (type == 0) {
                CmDescriptor->Type = CmResourceTypePort;
                CmDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                CmDescriptor->Flags = CM_RESOURCE_PORT_IO;
                CmDescriptor->u.Port.Length = length;
                CmDescriptor->u.Port.Start = Address;
            } else {
                CmDescriptor->Type = CmResourceTypeMemory;
                CmDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                CmDescriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
                CmDescriptor->u.Memory.Length = length;
                CmDescriptor->u.Memory.Start = Address;

                if (j == PCI_TYPE0_ADDRESSES) {
                    // this is a ROM address
                    CmDescriptor->Flags = CM_RESOURCE_MEMORY_READ_ONLY;
                }
            }

            CmResList->List[0].PartialResourceList.Count++;
            CmDescriptor++;

            if (i & PCI_TYPE_64BIT) {
                // skip upper half of 64 bit address.
                j++;
            }
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\miscs.s ===
//++
//
//  Module name
//      miscs.s
//  Author
//      Allen Kay    (allen.m.kay@intel.com)    Jun-12-95
//  Description
//      Misc. assembly functions.
//
//---

#include "ksia64.h"

        .file   "miscs.s"

        .global    PalProcPhysical
        .global    PalPhysicalBase
        .global    PalTrPs
        .global    IoPortPhysicalBase
        .global    IoPortTrPs
        .global    BdPcr

//
// Setup CPU state to go from physical to virtual
//

        LEAF_ENTRY(MempGoVirtual)

        rpT0       = t21
        rpT1       = t20
        rTrPs      = t19
        rPPN       = t18
        rPsr       = t17

        mov     ar.rsc = r0
        mov     rPsr = psr
        ;;

        rsm     (1 << PSR_I)
        ;;
        rsm     (1 << PSR_IC)
        ;;
        srlz.i
        ;;

        movl    t0 = FPSR_FOR_KERNEL
        ;;
        mov     ar.fpsr = t0                   // initialize fpsr
        ;;

        //
        // Initialize Region Registers
        //
        mov     t1 = (START_GLOBAL_RID << RR_RID) | (PAGE_SHIFT << RR_PS) | RR_PS_VE
        movl    t3 = KSEG0_BASE
        ;;
        mov     rr[t3] = t1

        //
        // Invalidate all protection key registers
        //
        mov     t1 = zero
        ;;

Bl_PKRLoop:
        mov     pkr[t1] = zero
        ;;
        add     t1 = 1, t1
        add     t2 = 1, t2
        ;;
        cmp.gtu pt0, pt1 = PKRNUM - 1, t1
        ;;
(pt0)   br.cond.sptk.few.clr Bl_PKRLoop
        ;;

#if 0
        //
        // Setup the 1-to-1 translation for the loader
        //
        movl    t0 = BL_16M
        ;;

        movl    t2 = ITIR_VALUE(0,PS_16M)
        mov     cr.ifa = t0
        ;;
        mov     cr.itir = t2
        ;;

        mov     t3 = BL_LOADER_INDEX
        movl    t2 = TR_VALUE(1,BL_16M,3,0,1,1,0,1)
        ;;

        itr.d   dtr[t3] = t2
        ;;
        itr.i   itr[t3] = t2

#endif

        //
        //
        // Setup the first 16MB translation for the drivers.
        //
        movl    t0 = KSEG0_BASE + BL_16M
        ;;

        movl    t2 = ITIR_VALUE(0,PS_16M)
        mov     cr.ifa = t0
        ;;
        mov     cr.itir = t2
        ;;

        mov     t3 = DTR_DRIVER0_INDEX
        movl    t2 = TR_VALUE(1,BL_16M,3,0,1,1,0,1)
        ;;

        itr.d   dtr[t3] = t2
        ;;
        itr.i   itr[t3] = t2

        //
        // Setup the second 16MB translation for the drivers.
        //
        movl    t0 = KSEG0_BASE + BL_32M;
        ;;

        movl    t2 = ITIR_VALUE(0,PS_16M)
        mov     cr.ifa = t0
        ;;
        mov     cr.itir = t2
        ;;

        mov     t3 = DTR_DRIVER1_INDEX
        movl    t2 = TR_VALUE(1,BL_32M,3,0,1,1,0,1)
        ;;

        itr.d   dtr[t3] = t2
        ;;
        itr.i   itr[t3] = t2


        //
        // Setup 16MB translation for kernel/hal binary.
        //
        movl    t0 = KSEG0_BASE + BL_48M;
        ;;

        movl    t2 = ITIR_VALUE(0,PS_16M)
        mov     cr.ifa = t0
        ;;
        mov     cr.itir = t2
        ;;

        mov     t3 = DTR_KERNEL_INDEX
        movl    t2 = TR_VALUE(1,BL_48M,3,0,1,1,0,1)
        ;;

        itr.d   dtr[t3] = t2
        ;;
        itr.i   itr[t3] = t2

        //
        // Setup 16MB translation for decompression buffer used by setupldr.
        //
        movl    t0 = KSEG0_BASE + BL_64M;
        ;;

        movl    t2 = ITIR_VALUE(0,PS_16M)
        mov     cr.ifa = t0
        ;;
        mov     cr.itir = t2
        ;;

        mov     t3 = BL_DECOMPRESS_INDEX
        movl    t2 = TR_VALUE(1,BL_64M,3,0,1,1,0,1)
        ;;

        itr.d   dtr[t3] = t2
        ;;
        itr.i   itr[t3] = t2

        //
        //
        // Setup translation for PAL.
        //
        movl    rpT0 = PalPhysicalBase               // PAL base addr
        movl    rpT1 = PalTrPs                       // PAL page size
        movl    t1 = VIRTUAL_PAL_BASE
        ;;

        ld8     t0 = [rpT0]
        ld8     rTrPs = [rpT1]
        mov     cr.ifa = t1

        movl    t4 = IITR_ATTRIBUTE_PPN_MASK         // construct GR[r]
        movl    t5 = TR_VALUE(1,0,3,0,1,1,0,1)
        ;;

        shl     t2 = rTrPs, ITIR_PS
        and     t6 = t0, t4                          // t6 is PPN in GR[r]
        ;;

        mov     cr.itir = t2
        ;;

        mov     t3 = DTR_HAL_INDEX                   // pre-assigned index
        or      t2 = t5, t6                          // t2 is now GR[r]
        ;;

        itr.d   dtr[t3] = t2

        //
        // Setup translation for I/O port space
        //
        movl    rpT0 = IoPortPhysicalBase            // IO Port base addr
        movl    rpT1 = IoPortTrPs                    // IO Port page size
        movl    t1 = VIRTUAL_IO_BASE
        ;;

        ld8     t0 = [rpT0]
        ld8     rTrPs = [rpT1]
        mov     cr.ifa = t1

        movl    t4 = IITR_ATTRIBUTE_PPN_MASK         // construct GR[r]
        movl    t5 = TR_VALUE(1,0,3,0,1,1,4,1)
        ;;

        shl     t2 = rTrPs, ITIR_PS
        and     t6 = t0, t4                          // t6 is PPN in GR[r]
        ;;

        mov     cr.itir = t2
        ;;

        mov     t3 = DTR_IO_PORT_INDEX               // pre-assigned index
        or      t2 = t5, t6                          // t2 is now GR[r]
        ;;

        itr.d   dtr[t3] = t2

        //
        // Setup translation for BdPcr
        //
        movl    t0 = BdPcr
        movl    rTrPs = PS_4M
        ;;

        mov     cr.ifa = t0

        movl    t4 = IITR_ATTRIBUTE_PPN_MASK         // construct GR[r]
        movl    t5 = TR_VALUE(1,0,3,0,1,1,0,1)
        ;;

        shl     t2 = rTrPs, ITIR_PS
        and     t6 = t0, t4                          // t6 is PPN in GR[r]
        ;;

        mov     cr.itir = t2
        ;;

        mov     t3 = DTR_KIPCR_INDEX
        or      t2 = t5, t6                          // t2 is now GR[r]
        ;;

        itr.d   dtr[t3] = t2

        //
        // Turn on address translation, interrupt, psr.ed, protection key.
        //
        movl    t1 = MASK_IA64(PSR_BN,1) | MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1) | MASK_IA64(PSR_IC,1) | MASK_IA64(PSR_AC,1) | MASK_IA64(PSR_DB,1)
        ;;
        or      t1 = t1, rPsr
        ;;
        mov     cr.ipsr = t1

        //
        // Initialize DCR to defer all speculation faults
        //
        mov     t0 = DCR_DEFER_ALL
        ;;
        mov     cr.dcr = t0

        //
        // Prepare to do RFI to return to the caller.
        //


        movl    t0 = return_label
        ;;

        mov     cr.iip = t0
        ;;

        mov     cr.ifs = r0
        ;;

        rfi
        ;;

return_label:
        mov     v0 = zero
        ;;

        LEAF_RETURN
        LEAF_EXIT(MempGoVirtual)


//
// Flip psr.it bit from virtual to physical addressing mode.
//

        LEAF_ENTRY(FlipToPhysical)

        rPsr    = t17

        rsm     (1 << PSR_I)
        ;;
        rsm     (1 << PSR_IC)
        ;;
        srlz.i
        ;;

        mov     rPsr = psr
        movl    t1 = MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1)
        movl    t2 = MASK_IA64(PSR_BN,1) | MASK_IA64(PSR_IC,1)
        ;;

        xor     t1 = t1, rPsr
        ;;
        or      t1 = t1, t2
        ;;
        mov     cr.ipsr = t1



        //
        // Prepare to do RFI to return to the caller.
        //


        movl    t0 = FlipToPhysicalReturn
        ;;

        mov     cr.iip = t0
        ;;

        mov     cr.ifs = r0
        ;;

        rfi
        ;;

FlipToPhysicalReturn:
        mov     v0 = zero
        ;;

        LEAF_RETURN
        LEAF_EXIT(FlipToPhysical)


//
// Flip psr.it bit from physical to virtual addressing mode.
//

        LEAF_ENTRY(FlipToVirtual)

        rPsr    = t17

        rsm     (1 << PSR_I)
        ;;
        rsm     (1 << PSR_IC)
        ;;
        srlz.i
        ;;

        mov     rPsr = psr
        movl    t1 = MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1) | MASK_IA64(PSR_BN,1) | MASK_IA64(PSR_IC,1)
        ;;

        or      t1 = t1, rPsr
        ;;
        mov     cr.ipsr = t1



        //
        // Prepare to do RFI to return to the caller.
        //


        movl    t0 = FlipToVirtualReturn
        ;;

        mov     cr.iip = t0
        ;;

        mov     cr.ifs = r0
        ;;

        rfi
        ;;

FlipToVirtualReturn:
        mov     v0 = zero
        ;;

        LEAF_RETURN
        LEAF_EXIT(FlipToVirtual)


//
// Clean up TR mappings used only by NT loader.
//

        LEAF_ENTRY(BlTrCleanUp)

        rpT0 = t22
        rPsr = t17

        //
        // purge BL_DECOMPRESS_INDEX
        //
        movl    t0 = PS_16M << PS_SHIFT
        movl    t1 = KSEG0_BASE + BL_64M
        ;;

        ptr.d   t1, t0
        ;;

#if 0
        //
        // purge BL_LOADER_INDEX
        //
        movl    t0 = PS_16M << PS_SHIFT
        movl    t1 = BL_16M
        ;;

        ptr.i   t1, t0
        ;;
        ptr.d   t1, t0

#endif

        //
        // purge BdPcr translation.
        //
        movl    t0 = BdPcr
        movl    t1 = PS_4M << PS_SHIFT
        ;;

        ptr.d   t0, t1
        ;;

        //
        // Turn on address translation, interrupt, psr.ed, protection key.
        //
        rsm     (1 << PSR_I)
        ;;
        rsm     (1 << PSR_IC)
        ;;
        srlz.i
        ;;

        //
        // At this point, turn on psr.it so that we can pass control to
        // the kernel.
        //
        mov     rPsr = psr
        movl    t1 = MASK_IA64(PSR_BN,1) | MASK_IA64(PSR_IT,1) | MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1) | MASK_IA64(PSR_IC,1) | MASK_IA64(PSR_AC,1) | MASK_IA64(PSR_DB,1)
        ;;
        or      t1 = t1, rPsr
        ;;
        mov     cr.ipsr = t1

        //
        // Prepare to do RFI to return to the caller.
        //

        movl    t0 = BlTrCleanupReturn
        ;;

        mov     cr.iip = t0
        ;;

        mov     cr.ifs = r0
        ;;

        rfi
        ;;

BlTrCleanupReturn:
        mov     v0 = zero
        ;;

        LEAF_RETURN
        LEAF_EXIT (BlTrCleanUp)


//++
//
//  VOID
//  BlpPalProc(
//      LONGLONG a0, /* PAL function ID */
//      LONGLONG a1, /* PAL argument    */
//      LONGLONG a2, /* PAL argument    */
//      LONGLONG a3  /* PAL argument    */
//      );
//
//  Routine Description
//      This routine sets up the correct registers for input into PAL depending on
//      if the call uses static or stacked registers, turns off interrupts, ensures
//      the correct bank registers are being used and calls into the PAL.
//
//  Return Values:
//      r8->r11 contain the 4 64-bit return values for PAL, r8 is the status
//--

        NESTED_ENTRY(BlpPalProc)
        NESTED_SETUP(4,3,4,0)
        PROLOGUE_END

        // For both the static and stacked register conventions, load r28 with FunctionID

        mov     r28 = a0

        // If static register calling convention (1-255, 512-767), copy arguments to r29->r31
        // Otherwise, copy to out0->out3 so they are in r32->r35 in PAL_PROC

        mov     t0 = a0
        ;;
        shr     t0 = t0, 8
        ;;
        tbit.z pt0, pt1 = t0, 0
        ;;

        //
        // Static proc: do br not call
        //
(pt0)   mov         r29 = a1
(pt0)   mov         r30 = a2
(pt0)   mov         r31 = a3

        //
        // Stacked call
        //
(pt1)   mov     out0 = a0
(pt1)   mov     out1 = a1
(pt1)   mov     out2 = a2
(pt1)   mov     out3 = a3

        // Load up the address of PAL_PROC and call it

        addl     t1 = @gprel(PalProcPhysical), gp
        ;;
        ld8      t0 = [t1]
        ;;
        mov      bt0 = t0

        // Call into PAL_PROC

(pt0)   addl t1 = @ltoff(PalReturn), gp
        ;;
(pt0)   ld8 t0 = [t1]
        ;;
(pt0)   mov brp = t0
        ;;
        // Disable interrupts

        DISABLE_INTERRUPTS(loc2)
        ;;
        srlz.d
        ;;
(pt0)   br.sptk.many bt0
        ;;
(pt1)   br.call.sptk brp = bt0        
        ;;
PalReturn:
        // Restore the interrupt state

        RESTORE_INTERRUPTS(loc2)
        ;;
        NESTED_RETURN
        NESTED_EXIT(BlpPalProc)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\ixphwsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixphwsup.c

Abstract:

    This module contains the IopXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would normally reside in the internal.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "bootia64.h"
#include "arc.h"
#include "ixfwhal.h"
#if defined(NEC_98)
#include "nec98.h"
#else  //NEC_98
#include "eisa.h"
#endif //NEC_98


PADAPTER_OBJECT
IopAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID ChannelNumber
    )

/*++

Routine Description:

    This routine allocates and initializes an adapter object to represent an
    adapter or a DMA controller on the system.  If no map registers are required
    then a standalone adapter object is allocated with no master adapter.

    If map registers are required, then a master adapter object is used to
    allocate the map registers.  For Isa systems these registers are really
    phyically contiguous memory pages.

Arguments:

    MapRegistersPerChannel - Specifies the number of map registers that each
        channel provides for I/O memory mapping.

    AdapterBaseVa - Address of the the DMA controller.

    ChannelNumber - Unused.

Return Value:

    The function value is a pointer to the allocate adapter object.

--*/

{

    PADAPTER_OBJECT AdapterObject;
    CSHORT Size;

    //
    // Determine the size of the adapter.
    //

    Size = sizeof( ADAPTER_OBJECT );

    //
    // Now create the adapter object.
    //

    AdapterObject = FwAllocateHeap(Size);

    //
    // If the adapter object was successfully created, then attempt to insert
    // it into the the object table.
    //

    if (AdapterObject) {

        RtlZeroMemory(AdapterObject, Size);

        //
        // Initialize the adapter object itself.
        //

        AdapterObject->Type = IO_TYPE_ADAPTER;
        AdapterObject->Size = Size;
        AdapterObject->MapRegistersPerChannel = 0;
        AdapterObject->AdapterBaseVa = AdapterBaseVa;
        AdapterObject->PagePort = NULL;
        AdapterObject->AdapterInUse = FALSE;

    } else {

        //
        // An error was incurred for some reason.  Set the return value
        // to NULL.
        //

        return(NULL);
    }

    return AdapterObject;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\pioflush.c ===
#define IcacheLineSize 32

void __fc (__int64);                     
#pragma intrinsic (__fc)                

void
PioICacheFlush (
    unsigned char *BaseAddress,
    unsigned int Length
    )
{
    unsigned char *EndAddress;
    unsigned long NumberOfLines;

    if (Length < IcacheLineSize) {
        Length = IcacheLineSize;
    }
    
    NumberOfLines = Length / IcacheLineSize;

    if (Length % IcacheLineSize != 0) {
        NumberOfLines = NumberOfLines+1;
    }

    EndAddress = (unsigned char *)(BaseAddress)+(NumberOfLines * IcacheLineSize);
    do {
       __fc((__int64)BaseAddress);
       BaseAddress += IcacheLineSize;
    } while (BaseAddress < EndAddress);

    __synci();
    __isrlz();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\ntsetup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntsetup.c

Abstract:

    This module is the tail-end of the OS loader program. It performs all
    IA64 specific allocations and initialize. The OS loader invokes this
    this routine immediately before calling the loaded kernel image.

Author:

    Allen Kay (akay) 19-May-1999
    based on MIPS version by John Vert (jvert) 20-Jun-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "bldr.h"
#include "stdio.h"
#include "bootia64.h"
#include "sal.h"
#include "efi.h"
#include "fpswa.h"
#include "extern.h"


//
// Define macro to round structure size to next 16-byte boundary
//

#undef ROUND_UP
#define ROUND_UP(x) ((sizeof(x) + 15) & (~15))
#define MIN(_a,_b) (((_a) <= (_b)) ? (_a) : (_b))
#define MAX(_a,_b) (((_a) <= (_b)) ? (_b) : (_a))

//
// Configuration Data Header
// The following structure is copied from fw\mips\oli2msft.h
// NOTE shielint - Somehow, this structure got incorporated into
//     firmware EISA configuration data.  We need to know the size of the
//     header and remove it before writing eisa configuration data to
//     registry.
//

typedef struct _CONFIGURATION_DATA_HEADER {
            USHORT Version;
            USHORT Revision;
            PCHAR  Type;
            PCHAR  Vendor;
            PCHAR  ProductName;
            PCHAR  SerialNumber;
} CONFIGURATION_DATA_HEADER;

#define CONFIGURATION_DATA_HEADER_SIZE sizeof(CONFIGURATION_DATA_HEADER)

//
// Global Definition: This structure value is setup in sumain.c
//
TR_INFO ItrInfo[8], DtrInfo[8];

extern ULONGLONG MemoryMapKey;

//
// Internal function references
//

VOID
BlQueryImplementationAndRevision (
    OUT PULONG ProcessorId,
    OUT PULONG FloatingId
    );

VOID
BlTrCleanUp (
    );


ARC_STATUS
BlSetupForNt(
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    )

/*++

Routine Description:

    This function initializes the IA64 specific kernel data structures
    required by the NT system.

Arguments:

    BlLoaderBlock - Supplies the address of the loader parameter block.

Return Value:

    ESUCCESS is returned if the setup is successfully complete. Otherwise,
    an unsuccessful status is returned.

--*/

{

    PCONFIGURATION_COMPONENT_DATA ConfigEntry;
    ULONG FloatingId;
    CHAR Identifier[256];
    ULONG KernelPage;
    ULONG LinesPerBlock;
    ULONG LineSize;
    PCHAR NewIdentifier;
    ULONGLONG PrcbPage;
    ULONG ProcessorId;
    ARC_STATUS Status;
    ULONG i;
    PULONG KernelStructureBase;
    PHARDWARE_PTE SelfMapPde;
    PHARDWARE_PTE Pde;
    PHARDWARE_PTE HalPT;
    PLIST_ENTRY NextMd;
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;

    EFI_MEMORY_DESCRIPTOR * MemoryMap = NULL;
    ULONGLONG MemoryMapSize = 0;    
    ULONGLONG MapKey;
    ULONGLONG DescriptorSize;
    ULONG DescriptorVersion;
    EFI_STATUS EfiStatus;

    EFI_GUID FpswaId = EFI_INTEL_FPSWA;
    EFI_HANDLE FpswaImage;
    FPSWA_INTERFACE *FpswaInterface;
    ULONGLONG BufferSize;
    BOOLEAN FpswaFound = FALSE;

    //
    // Allocate DPC stack pages for the boot processor.
    //

    Status = BlAllocateDescriptor(LoaderStartupDpcStack,
                                  0,
                                  (KERNEL_BSTORE_SIZE + KERNEL_STACK_SIZE) >> PAGE_SHIFT,
                                  &KernelPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    BlLoaderBlock->u.Ia64.InterruptStack =
                (KSEG0_BASE | (KernelPage << PAGE_SHIFT)) + KERNEL_STACK_SIZE;

    //
    // Allocate kernel stack pages for the boot processor idle thread.
    //

    Status = BlAllocateDescriptor(LoaderStartupKernelStack,
                                  0,
                                  (KERNEL_BSTORE_SIZE + KERNEL_STACK_SIZE) >> PAGE_SHIFT,
                                  &KernelPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    BlLoaderBlock->KernelStack =
                (KSEG0_BASE | (KernelPage << PAGE_SHIFT)) + KERNEL_STACK_SIZE;

    //
    // Allocate panic stack pages for the boot processor.
    //

    Status = BlAllocateDescriptor(LoaderStartupPanicStack,
                                  0,
                                  (KERNEL_BSTORE_SIZE + KERNEL_STACK_SIZE) >> PAGE_SHIFT,
                                  &KernelPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    BlLoaderBlock->u.Ia64.PanicStack =
                (KSEG0_BASE | (KernelPage << PAGE_SHIFT)) + KERNEL_STACK_SIZE;

    //
    // Allocate and zero two pages for the PCR.
    //

    Status = BlAllocateDescriptor(LoaderStartupPcrPage,
                                  0,
                                  2,
                                  (PULONG) &BlLoaderBlock->u.Ia64.PcrPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    BlLoaderBlock->u.Ia64.PcrPage2 = BlLoaderBlock->u.Ia64.PcrPage + 1;
    RtlZeroMemory((PVOID)(KSEG0_BASE | (BlLoaderBlock->u.Ia64.PcrPage << PAGE_SHIFT)),
                  PAGE_SIZE * 2);

    //
    // Allocate and zero four pages for the PDR and one page of memory for
    // the initial processor block, idle process, and idle thread structures.
    //

    Status = BlAllocateDescriptor(LoaderStartupPdrPage,
                                  0,
                                  3,
                                  (PULONG) &BlLoaderBlock->u.Ia64.PdrPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    RtlZeroMemory((PVOID)(KSEG0_BASE | (BlLoaderBlock->u.Ia64.PdrPage << PAGE_SHIFT)),
                  PAGE_SIZE * 3);

    //
    // The storage for processor control block, the idle thread object, and
    // the idle thread process object are allocated from the third page of the
    // PDR allocation. The addresses of these data structures are computed
    // and stored in the loader parameter block and the memory is zeroed.
    //

    PrcbPage = BlLoaderBlock->u.Ia64.PdrPage + 1;
    if ((PAGE_SIZE * 2) >= (ROUND_UP(KPRCB) + ROUND_UP(EPROCESS) + ROUND_UP(ETHREAD))) {
        BlLoaderBlock->Prcb = KSEG0_BASE | (PrcbPage << PAGE_SHIFT);
        BlLoaderBlock->Process = BlLoaderBlock->Prcb + ROUND_UP(KPRCB);
        BlLoaderBlock->Thread = BlLoaderBlock->Process + ROUND_UP(EPROCESS);

    } else {
        return(ENOMEM);
    }

    Status = BlAllocateDescriptor(LoaderStartupPdrPage,
                                  0,
                                  1,
                                  &KernelPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    RtlZeroMemory((PVOID)(KSEG0_BASE | ((ULONGLONG) KernelPage << PAGE_SHIFT)),
                   PAGE_SIZE * 1);

    //
    // Setup last two entries in the page directory table for HAL and
    // allocate page tables for them.
    //

    Pde = (PHARDWARE_PTE) (ULONG_PTR)( (BlLoaderBlock->u.Ia64.PdrPage) << PAGE_SHIFT);

    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].PageFrameNumber = (ULONG) KernelPage;
    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].Valid = 1;
    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].Cache = 0;
    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].Accessed = 1;
    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].Dirty = 1;
    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].Execute = 1;
    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].Write = 1;
    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].CopyOnWrite = 1;

    //
    // 0xFFC00000 is the starting virtual address of Pde[2046].
    //

    HalPT = (PHARDWARE_PTE)((ULONG_PTR) KernelPage << PAGE_SHIFT);
    HalPT[GetPteOffset(KI_USER_SHARED_DATA)].PageFrameNumber = BlLoaderBlock->u.Ia64.PcrPage2;
    HalPT[GetPteOffset(KI_USER_SHARED_DATA)].Valid = 1;
    HalPT[GetPteOffset(KI_USER_SHARED_DATA)].Cache = 0;
    HalPT[GetPteOffset(KI_USER_SHARED_DATA)].Accessed = 1;
    HalPT[GetPteOffset(KI_USER_SHARED_DATA)].Dirty = 1;
    HalPT[GetPteOffset(KI_USER_SHARED_DATA)].Execute = 1;
    HalPT[GetPteOffset(KI_USER_SHARED_DATA)].Write = 1;
    HalPT[GetPteOffset(KI_USER_SHARED_DATA)].CopyOnWrite = 1;

    //
    // Fill in the rest of the loader block fields.
    //
    BlLoaderBlock->u.Ia64.AcpiRsdt       = (ULONG_PTR) AcpiTable;

    //
    // Fill the ItrInfo and DtrInfo fields
    //
    BlLoaderBlock->u.Ia64.EfiSystemTable = (ULONG_PTR) EfiST;
    BlLoaderBlock->u.Ia64.PalProcVirtual = (ULONG_PTR) PalProcVirtual;

    //
    // Fill in ItrInfo and DtrInfo for DRIVER0
    //
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER0_INDEX].Index = ITR_DRIVER0_INDEX;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER0_INDEX].PageSize = PS_16M;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER0_INDEX].VirtualAddress = KSEG0_BASE + BL_16M;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER0_INDEX].PhysicalAddress = BL_16M;

    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER0_INDEX].Index = DTR_DRIVER0_INDEX;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER0_INDEX].PageSize = PS_16M;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER0_INDEX].VirtualAddress = KSEG0_BASE + BL_16M;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER0_INDEX].PhysicalAddress = BL_16M;

    //
    // Fill in ItrInfo and DtrInfo for DRIVER1
    //
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER1_INDEX].Index = ITR_DRIVER1_INDEX;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER1_INDEX].PageSize = PS_16M;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER1_INDEX].VirtualAddress = KSEG0_BASE + BL_32M;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER1_INDEX].PhysicalAddress = BL_32M;

    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER1_INDEX].Index = DTR_DRIVER1_INDEX;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER1_INDEX].PageSize = PS_16M;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER1_INDEX].VirtualAddress = KSEG0_BASE + BL_32M;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER1_INDEX].PhysicalAddress = BL_32M;

    //
    // Fill in ItrInfo and DtrInfo for KERNEL
    //
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_KERNEL_INDEX].Index = ITR_KERNEL_INDEX;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_KERNEL_INDEX].PageSize = PS_16M;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_KERNEL_INDEX].VirtualAddress = KSEG0_BASE + BL_48M;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_KERNEL_INDEX].PhysicalAddress = BL_48M;

    BlLoaderBlock->u.Ia64.DtrInfo[DTR_KERNEL_INDEX].Index = DTR_KERNEL_INDEX;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_KERNEL_INDEX].PageSize = PS_16M;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_KERNEL_INDEX].VirtualAddress = KSEG0_BASE + BL_48M;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_KERNEL_INDEX].PhysicalAddress = BL_48M;

    //
    // Fill in ItrInfo and DtrInfo for PAL
    //
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_PAL_INDEX].Index = ITR_PAL_INDEX;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_PAL_INDEX].PageSize = (ULONG) PalTrPs;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_PAL_INDEX].VirtualAddress = VIRTUAL_PAL_BASE;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_PAL_INDEX].PhysicalAddress = PalPhysicalBase;

    BlLoaderBlock->u.Ia64.DtrInfo[DTR_PAL_INDEX].Index = DTR_PAL_INDEX;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_PAL_INDEX].PageSize = (ULONG) PalTrPs;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_PAL_INDEX].VirtualAddress = VIRTUAL_PAL_BASE;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_PAL_INDEX].PhysicalAddress = PalPhysicalBase;

    //
    // Fill in ItrInfo and DtrInfo for IO port
    //
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_IO_PORT_INDEX].Index = DTR_IO_PORT_INDEX;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_IO_PORT_INDEX].PageSize = (ULONG) IoPortTrPs;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_IO_PORT_INDEX].VirtualAddress = VIRTUAL_IO_BASE;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_IO_PORT_INDEX].PhysicalAddress = IoPortPhysicalBase;

    //
    // Flush all caches.
    //

    if (SYSTEM_BLOCK->FirmwareVectorLength > (sizeof(PVOID) * FlushAllCachesRoutine)) {
        ArcFlushAllCaches();
    }

    //
    // make memory map by TR's unavailable for kernel use.
    //
    NextMd = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextMd != &BlLoaderBlock->MemoryDescriptorListHead) {
        MemoryDescriptor = CONTAINING_RECORD(NextMd,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);

        //
        // lock down pages we don't want the kernel to use.
        // NB. The only reason we need to lock down LoaderLoadedProgram because
        // there is static data in the loader image that the kernel uses. 
        //
        if ((MemoryDescriptor->MemoryType == LoaderLoadedProgram) ||
            (MemoryDescriptor->MemoryType == LoaderOsloaderStack)) {

            MemoryDescriptor->MemoryType = LoaderFirmwarePermanent;
        }

        //
        // we've marked lots of memory as off limits to trick our allocator
        // into allocating memory at a specific location (which is necessary to
        // get hte kernel loaded at the right location, etc.). We do this by 
        // marking the page type as LoaderSystemBlock.  Now that we're done 
        // allocating memory, we can restore all of the LoaderSystemBlock pages
        // to LoaderFree, so that the kernel can use this memory.
        //
        if (MemoryDescriptor->MemoryType == LoaderSystemBlock) {
            MemoryDescriptor->MemoryType = LoaderFree;
        }


        NextMd = MemoryDescriptor->ListEntry.Flink;

    }

    //
    // Go to physical mode before making EFI calls.
    //
    FlipToPhysical();

    //
    // Get processor configuration information
    //

    ReadProcessorConfigInfo( &BlLoaderBlock->u.Ia64.ProcessorConfigInfo );

    //
    // Get FP assist handle
    //
    BufferSize = sizeof(FpswaImage);
    EfiStatus = EfiBS->LocateHandle(ByProtocol,
                                    &FpswaId,
                                    NULL,
                                    &BufferSize,
                                    &FpswaImage
                                   );
    if (!EFI_ERROR(EfiStatus)) {
        //
        // Get FP assist protocol interface.
        //
        EfiStatus = EfiBS->HandleProtocol(FpswaImage, &FpswaId, &FpswaInterface);

        if (EFI_ERROR(EfiStatus)) {
            EfiST->ConOut->OutputString(
                EfiST->ConOut,
                L"BlSetupForNt: Could not get FP assist entry point\n"
                );
            EfiBS->Exit(EfiImageHandle, EfiStatus, 0, 0);
        }

        FpswaFound = TRUE;
    }

#if 1
//
// The following code must be fixed to handle ExitBootServices() failing 
// because the memory map has changed in between calls to GetMemoryMap and
// the call to ExitBootServices().  We should also walk the EFI memory map
// and correlate it against the MemoryDescriptorList to ensure that all of
// the memory is properly accounted for.
//

    //
    // Get memory map info from EFI firmware
    //
    EfiStatus = EfiBS->GetMemoryMap (
                &MemoryMapSize,
                MemoryMap,
                &MapKey,
                &DescriptorSize,
                &DescriptorVersion
                );

    if (EfiStatus != EFI_BUFFER_TOO_SMALL) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"BlSetupForNt: GetMemoryMap failed\r\n");
        EfiBS->Exit(EfiImageHandle, EfiStatus, 0, 0);
    }

    FlipToVirtual();
    
#if DBG
    DbgPrint( "About to call BlAllocateAlignedDescriptor for %x\r\n",
              MAX((MemoryMapSize >> 16), 1));
#endif

    Status = BlAllocateAlignedDescriptor(
                                  LoaderOsloaderHeap,
                                  0,
                                  (ULONG)(MAX((MemoryMapSize >> 16), 1)),
                                  0,
                                  &KernelPage);


    if (Status != ESUCCESS) {
        return(Status);
    }


    FlipToPhysical();

    //
    // We need a physical address for EFI, and the hal expects a physical
    // address as well.
    //
    MemoryMap = (PVOID)(ULONGLONG)((ULONGLONG)KernelPage << PAGE_SHIFT);

    EfiStatus = EfiBS->GetMemoryMap (
                &MemoryMapSize,
                MemoryMap,
                &MapKey,
                &DescriptorSize,
                &DescriptorVersion
                );

    if (EFI_ERROR(EfiStatus)) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"BlSetupForNt: GetMemoryMap failed\r\n");
        EfiBS->Exit(EfiImageHandle, EfiStatus, 0, 0);
    }

    //
    // Call EFI exit boot services.  No more Efi calls to boot services
    // API's will be called beyond this point.
    //
    EfiStatus = EfiBS->ExitBootServices (
                EfiImageHandle,
                MapKey
                );

    if (EFI_ERROR(EfiStatus)) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"BlSetupForNt: ExitBootServices failed\r\n");
        EfiBS->Exit(EfiImageHandle, EfiStatus, 0, 0);
    }
#endif

    //
    // Go back to virtual mode.
    //
    FlipToVirtual();

    //
    // Pass EFI memory descriptor Parameters to kernel through OS
    // loader block.
    //
    BlLoaderBlock->u.Ia64.EfiMemMapParam.MemoryMapSize = MemoryMapSize;
    BlLoaderBlock->u.Ia64.EfiMemMapParam.MemoryMap = (PUCHAR) MemoryMap;
    BlLoaderBlock->u.Ia64.EfiMemMapParam.MapKey = MapKey;
    BlLoaderBlock->u.Ia64.EfiMemMapParam.DescriptorSize = DescriptorSize;
    BlLoaderBlock->u.Ia64.EfiMemMapParam.DescriptorVersion = DescriptorVersion;

    if (FpswaFound) {
        BlLoaderBlock->u.Ia64.FpswaInterface = (ULONG_PTR) FpswaInterface;
    } else {
        BlLoaderBlock->u.Ia64.FpswaInterface = (ULONG_PTR) NULL;
    }

    //
    // Clean up TR's used by boot loader but not needed by ntoskrnl.
    //
    BlTrCleanUp();

    //
    // Flush the memory range where kernel, hal, and the drivers are
    // loaded into.
    //
    PioICacheFlush(KSEG0_BASE+BL_16M, BL_48M);

    return(ESUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\stubs.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This module implements stub routines for the boot code.

Author:

    David N. Cutler (davec) 7-Nov-1990

Environment:

    Kernel mode only.

Revision History:

--*/


#include "bootia64.h"
#include "stdio.h"
#include "stdarg.h"

VOID
KeBugCheck (
    IN ULONG BugCheckCode
    )

/*++

Routine Description:

    This function crashes the system in a controlled manner.

Arguments:

    BugCheckCode - Supplies the reason for the bug check.

Return Value:

    None.

--*/

{

    //
    // Print out the bug check code and break.
    //

    BlPrint(TEXT("\n*** BugCheck (%lx) ***\n\n"), BugCheckCode);
    while(TRUE) {
    };
}

VOID
RtlAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{

    BlPrint( TEXT("\n*** Assertion failed %S in %S line %d\n"),
            FailedAssertion,
            FileName,
            LineNumber );
    if (Message) {
        //bugbug UNICODE
        //BlPrint(Message);
    }

    while (TRUE) {
    }
}

VOID
KiCheckForSoftwareInterrupt (
    KIRQL RequestIrql
    )
{
    BlPrint( TEXT("\n*** Assertion in KiCheckForSoftwareInterrupt\n") );
}

VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    )
/*++

Routine Description:

   This function is similar to the kernel routine with the same name. It is
   very simplified relative to the kernel routine as during the boot process
   the environment is much more restrictive. Specifically, we boot
   as a uniprocessor and we always do DMA. Thus, we can simplify this
   code considerably.

   In the kernel, KeFlushIoBuffer() is used to flush the I-cache for the
   PIO cases.  Architecturally, it is required to perform a flush cache,
   sync.i, and srlz.i to invalidate the I-cache. This sequence should
   supports both UP and MP cases (though booting is a UP case only)

Arugements:

   Mdl - Supplies a pointer to a memory descriptor list that describes the
       I/O buffer location. [unused]

   ReadOperation - Supplies a boolean value that determines whether the I/O
       operation is a read into memory. [unused]

   DmaOperation - Supplies a boolean value that deternines whether the I/O
       operation is a DMA operation.

Return Value:

   None.

--*/
{
    //
    // If we are doing something besides a DMA operation, we
    // have a problem. This routine is not designed to handle anything
    // except DMA
    //

    if (!DmaOperation) {
        RtlAssert("!DmaOperation", __FILE__, __LINE__,
                  "Boot version of KeFlushIOBuffers can only handle DMA operations");
        // Never returns
    }
    __mf();
}


NTHALAPI
VOID
KeFlushWriteBuffer(
    VOID
    )

/*++

Routine Description:


    This function is similar to the kernel routine with the same name. It is
    very simplified relative to the kernel routine as during the boot process
    the environment is much more restrictive. Specifically, we boot
    as a uniprocessor.

    This routine is responsible for flushing all write buffers
    and/or other data storing or reordering
    hardware on the current processor.  This ensures that all previous
    writes will occur before any new reads or writes are completed.

    NOTE: In the simulation environment, there is no write buffer and
    nothing needs to be done.

Arguments:

    None

Return Value:

    None.

--*/
{
    //
    // NOTE: The real hardware may need more than this
    //
    __mf();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\susetup.s ===
//++
//
//  Module name
//      SuSetup.s
//  Author
//      Allen Kay    (akay)    Jun-12-95
//  Description
//      Startup module for Ia64 NT OS loader.
// Notes
//      This is the startup routine for Ia64 NT boot loader.  It sets up
//      the CPU state and turns on the address translation before calling
//      the C routine main() which then does some initial setup then passes
//      control to BlOsLoader().
//---

#include "ksia64.h"

        .file   "susetup.s"

        PublicFunction(SuMain)

#define FW_SPEC_PATCH


#if defined(FW_SPEC_PATCH)
	PublicFunction(RtlCopyMemory)
#endif

        .global    StackBase
        .global    StackLimit
        .global    BspLimit

        NESTED_ENTRY(main)
        NESTED_SETUP(2,6,3,0)

        ImageHandle     = loc2
        SystemTable     = loc3

        mov     ImageHandle = a0
        mov     SystemTable = a1

        movl    gp = _gp                       // setup gp register
        invala                                 // invalidate ALAT
        mov     ar.rsc = r0
        ;;

//
// Switch to our own sp and bspstore.
//
        loadrs
        movl    sp = StackBase
        ;;
        mov     ar.bspstore = sp
        add     sp = -STACK_SCRATCH_AREA, sp
        ;;

#if defined(FW_SPEC_PATCH)

//
// Set Unaligned fault Vector
//
        mov         loc4 = 0x5a00
        mov         loc5 = cr.iva
        movl        out1 = BldrFaultDeferStart
        movl        out2 = BldrFaultDeferEnd - BldrFaultDeferStart
        ;;

        add         out0 = loc4, loc5         // out0 = address of IVT vector
        ;;
        br.call.sptk brp = RtlCopyMemory
        ;;

//
// Set dirty bit fault Vector
//
        mov         loc4 = 0x2000
        mov         loc5 = cr.iva
        movl        out1 = BldrFaultDeferStart
        movl        out2 = BldrFaultDeferEnd - BldrFaultDeferStart
        ;;
        add         out0 = loc4, loc5         // out0 = address of IVT vector
        ;;

        br.call.sptk brp = RtlCopyMemory
        ;;

//
// Set instruction access bit fault Vector
//
        mov         loc4 = 0x2400
        mov         loc5 = cr.iva
        movl        out1 = BldrFaultDeferStart
        movl        out2 = BldrFaultDeferEnd - BldrFaultDeferStart
        ;;
        add         out0 = loc4, loc5         // out0 = address of IVT vector
        ;;

        br.call.sptk brp = RtlCopyMemory
        ;;
        sync.i
        ;;
        srlz.i
        ;;
#endif   // FW_SPEC_PATCH

//
// Transfer control to Sumain()
//
        mov    out0 = ImageHandle
        mov    out1 = SystemTable
        br.call.spnt brp = SuMain
        ;;

        NESTED_EXIT(main)

#if defined(FW_SPEC_PATCH)

BldrFaultDeferStart::
        mov       h28 = pr
        mov       h27 = cr.isr
        mov       h26 = cr.ipsr
        ;;
        tbit.nz   p6, p7 = h27, ISR_SP
        ;;
(p6)    dep       h26 = 1, h26, PSR_ED, 1
        ;;
(p6)    mov       cr.ipsr = h26
        ;;
        mov       pr = h28
        ;;
        rfi
        ;;
BldrFaultDeferEnd::

#endif

//
// Reserve memory for loader stack
//
        .section .StackBase = "wa", "progbits"
StackLimit::
        .skip 0x20000
StackBase::
        .skip 0x4000
BspLimit::

//
// Reserve memory for loader stack
//
         string " -section:.BdPcr,,align=PAGE_SIZE"
        .section .BdPcr = "wa", "progbits"
BdPcr::
        .skip PAGE_SIZE
        .skip PAGE_SIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\inc\efip.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    efip.h

Abstract:

    Private loader additions to efi that aren't in the standard
    efi header files.

Author:

    Scott Brenden (v-sbrend) 28 Feb 2000

Revision History:

--*/



#define DP_PADDING    10
typedef struct _EFI_DEVICE_PATH_ALIGNED {
        EFI_DEVICE_PATH                 DevPath;
        ULONGLONG                       Data[DP_PADDING];
} EFI_DEVICE_PATH_ALIGNED;

#define EfiAlignDp(out, in, length)     RtlCopyMemory(out, in, length);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\wakes.s ===
//      TITLE("Hibernation wake dispatcher")
//++
//
// Copyright (c) 1999  Intel Corporation
//
// Module Name:
//
//    wakes.s
//
// Abstract:
//
//
// Author:
//
//    Allen Kay (allen.m.kay@intel.com)    8 June, 1999
//
// Environment:
//
//    Firmware, OS Loader.  Position-independent.
//
// Revision History:
//
//--

#include "ksia64.h"
#include "paldef.h"

        .global HiberMapPage
        .global HiberRemapPage
        .global HiberWakeState
        .global HiberFirstRemap
        .global HiberLastRemap
        .global HiberImagePageSelf
        .global HiberBreakOnWake


// VOID
// WakeDispatcher(
//     VOID
//     )
//
// Routine description:
//
//      This code performs the final stages of restarting the hibernation
//      image.  Pages that were loaded in temporary buffer space because
//      the memory they belong in was in use by the firmware are copied
//      to their final destination; an IMB is issued after this to ensure
//      that the I-cache is coherent with any code that got copied; and
//      necessary context is loaded into registers and NT is reentered.
//
//      Because this code is part of the loader image that may be overwritten
//      by this copy process, it must itself have been copied to a free
//      page before it is executed.  Note that because there is presently
//      no mechanism for allocating multiple contiguous pages, this code cannot
//      exceed one page (8K).
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      Never returns.


        LEAF_ENTRY(WakeDispatcherStartLocal)

        .prologue
        .regstk    1, 30, 2, 0
        alloc      t4 = ar.pfs, 1, 30, 2, 0
        ARGPTR(a0)

        rMapPage        = loc11
        rRemapPage      = loc12
        rWakeState      = loc13
        rPageCount      = loc14
        rPageSelf       = loc15
        rBreakOnWake    = loc16
        src1            = loc17
        src2            = loc18
        tmp             = loc19
        rKSEG0          = loc20
        rpT0            = loc21
        rpT1            = loc22
        rpT2            = loc23
        rpT3            = loc24

//
// Get variables into registers before copying any pages, as they may be
// overwritten.
//
        movl    rpT0 = HiberMapPage     // pointer to source pages
        movl    rpT1 = HiberRemapPage   // pointer to target pages
        movl    rpT2 = HiberWakeState   // pointer to KPROCESSOR_STATE for
                                        // restarting the hibernation image
        ;;

        ld8     rMapPage   = [rpT0]     // load them
        ld8     rRemapPage = [rpT1]
        ld8     rWakeState = [rpT2]
        ;;
        
        movl    rpT0 = HiberFirstRemap  // first page index
        movl    rpT1 = HiberLastRemap   // last page index
        movl    rpT2 = HiberImagePageSelf // PFN where MemImage ends up
        movl    rpT3 = HiberBreakOnWake // "break on wake" flag
        ;;

        ld4     t0 = [rpT0]             // load them
        ld4     t1 = [rpT1]
        ld8     rPageSelf = [rpT2]
        ld1     rBreakOnWake = [rpT3]
        ;;

        sub     rPageCount = t1, t0            // number of pages to copy
        add     rMapPage = t0, rMapPage        // first source page
        add     rRemapPage = t0, rRemapPage    // first target page
        ;;
        cmp.eq  pt1, pt0 = rPageCount, zero    // nothing to copy
        ;;

(pt1)   br.cond.spnt CopyDone

//
// Copy pages.
//

NextPage:
        add     rPageCount = -1, rPageCount    // count page copied
        movl    rKSEG0 = KSEG0_BASE            // physical -> KSEG0

        ld8.fill    t0 = [rMapPage], 8         // source page number
        ;;
        shl     t0 = t0, PAGE_SHIFT            // page -> physical address
        ;;
        add     t0 = rKSEG0, t0                // physical -> KSEG0

        ld8.fill    t1 = [rRemapPage], 8       // destination address
        ;;
        shl     t1 = t1, PAGE_SHIFT            // page -> physical address
        ;;
        add     t1 = rKSEG0, t1                // physical -> KSEG0
        movl    t2 = 1024                      // 8KB = 1024 quadwords
        ;;

NextQuadWord:
        add     t2 = -1, t2                    // count quadword
        ld8.fill   t3 = [t0], 8                // load a quadword
        ;;
        st8.spill  [t1] = t3, 8                // store it
        ;;
        
        cmp.eq  pt0, pt1 = t2, zero
        ;;
(pt1)   br.cond.spnt NextQuadWord

        cmp.eq  pt0, pt1 = rPageCount, zero
        ;;
(pt1)   br.cond.spnt NextPage

//
// All necessary pages have been copied.  Check the break-on-wake flag,
// and change the signature NT will see when it wakes up if it was set.
//

CopyDone:
        cmp.eq  pt1, pt0 = rBreakOnWake, zero  // no flag set, do nothing
        ;;
(pt1)   br.cond.spnt SkipSigChange

        shl     rPageSelf = rPageSelf, PAGE_SHIFT   // convert to physical
        ;;
        add     rPageSelf = rKSEG0, rPageSelf       // make superpage address
        movl    t0 = 0x706b7262                     // 'brkp'
        ;;
        st4     [rPageSelf] = t0   // signature is first longword of MemImage
        
//
// Synchronize the I-cache, load essential NT context, and transfer control
// to the restored system.
//

SkipSigChange:
#if 0
        PublicFunction(PalProc)

        mov     out0 = PAL_CACHE_FLUSH         // call PAL cache flush routine
        mov     out1 = 1                       // flush I-cache only

        movl    rpT0 = PalProc
        ;;
        ld8     t0 = [rpT0]
        ;;
        mov     bt0 = t0
        ;;
        br.call.spnt brp = bt0
#endif

//
// Restore context.  Only the integer registers are restored; this code runs
// in the firmware environment, so floating point can't be used, and NT
// PALcode abstractions such as the PSR don't exist.  It is the responsibility
// of NT's code that saves the hibernation context to put enough information
// in the integer registers in the CONTEXT to be able to finish restoring
// context to restart NT.
//

        mov         a0 = rWakeState            // CONTEXT is the first thing
                                               //  in the KPROCESSOR_STATE
        ;;

//
// Restore all the registers.
//

        add         src1 = CxIntNats, a0
        add         src2 = CxPreds, a0
        add         tmp = CxIntGp, a0
        ;;

        ld8.nt1     t17 = [src1], CxBrRp - CxIntNats
        ld8.nt1     t16 = [src2], CxBrS0 - CxPreds
        shr         tmp = tmp, 3
        ;;

        ld8.nt1     t0 = [src1], CxBrS1 - CxBrRp
        ld8.nt1     t1 = [src2], CxBrS2 - CxBrS0
        and         tmp = 0x3f, tmp
        ;;

        ld8.nt1     t2 = [src1], CxBrS3 - CxBrS1
        ld8.nt1     t3 = [src2], CxBrS4 - CxBrS2
        cmp4.ge     pt1, pt0 = 1, tmp
        ;;

        ld8.nt1     t4 = [src1], CxBrT0 - CxBrS3
        ld8.nt1     t5 = [src2], CxBrT1 - CxBrS4
 (pt1)  sub         loc5 = 1, tmp
        ;;

        ld8.nt1     t6 = [src1], CxApUNAT - CxBrT0
        ld8.nt1     t7 = [src2], CxApLC - CxBrT1
 (pt0)  add         loc5 = -1, tmp
        ;;

        ld8.nt1     loc0 = [src1], CxApEC - CxApUNAT
        ld8.nt1     t8 = [src2], CxApCCV - CxApLC
 (pt0)  sub         loc6 = 65, tmp
        ;; 

        ld8.nt1     t9 = [src1], CxApDCR - CxApEC
        ld8.nt1     t10 = [src2], CxRsPFS - CxApCCV
 (pt1)  shr.u       t17 = t17, loc5
        ;;

        ld8.nt1     loc1 = [src1], CxRsBSP - CxApDCR
        ld8.nt1     t11 = [src2], CxRsRSC - CxRsPFS
 (pt0)  shl         loc7 = t17, loc5
        ;;

        ld8.nt1     loc2 = [src1], CxStIIP - CxRsBSP
        ld8.nt1     loc3 = [src2], CxStIFS - CxRsRSC
 (pt0)  shr.u       loc8 = t17, loc6
        ;;

        ld8.nt1     loc9 = [src1]
        ld8.nt1     loc10 = [src2]
 (pt0)  or          t17 = loc7, loc8
        ;;

        mov         ar.unat = t17
        add         src1 = CxFltS0, a0
        shr         t12 = loc2, 3
        ;;

        add         src2 = CxFltS1, a0
        and         t12 = 0x3f, t12             // current rnat save index
        and         t13 = 0x7f, loc10           // total frame size
        ;;

        mov         ar.ccv = t10
        add         t14 = t13, t12
        mov         ar.pfs = t11
        ;;

Rrc20:
        cmp4.gt     pt1, pt0 = 63, t14
        ;;
 (pt0)  add         t14 = -63, t14
 (pt0)  add         t13 = 1, t13
        ;;

        nop.m       0
 (pt1)  shl         t13 = t13, 3
 (pt0)  br.cond.spnt Rrc20
        ;;

        add         loc2 = loc2, t13
        nop.f       0
        mov         pr = t16, -1

        ldf.fill.nt1  fs0 = [src1], CxFltS2 - CxFltS0
        ldf.fill.nt1  fs1 = [src2], CxFltS3 - CxFltS1
        mov         brp = t0
        ;;
         
        ldf.fill.nt1  fs2 = [src1], CxFltT0 - CxFltS2
        ldf.fill.nt1  fs3 = [src2], CxFltT1 - CxFltS3
        mov         bs0 = t1
        ;;
        
        ldf.fill.nt1  ft0 = [src1], CxFltT2 - CxFltT0
        ldf.fill.nt1  ft1 = [src2], CxFltT3 - CxFltT1
        mov         bs1 = t2
        ;;
        
        ldf.fill.nt1  ft2 = [src1], CxFltT4 - CxFltT2
        ldf.fill.nt1  ft3 = [src2], CxFltT5 - CxFltT3
        mov         bs2 = t3
        ;;
        
        ldf.fill.nt1  ft4 = [src1], CxFltT6 - CxFltT4
        ldf.fill.nt1  ft5 = [src2], CxFltT7 - CxFltT5
        mov         bs3 = t4
        ;;
        
        ldf.fill.nt1  ft6 = [src1], CxFltT8 - CxFltT6
        ldf.fill.nt1  ft7 = [src2], CxFltT9 - CxFltT7
        mov         bs4 = t5
        ;;
        
        ldf.fill.nt1  ft8 = [src1], CxFltS4 - CxFltT8
        ldf.fill.nt1  ft9 = [src2], CxFltS5 - CxFltT9
        mov         bt0 = t6
        ;;

        ldf.fill.nt1  fs4 = [src1], CxFltS6 - CxFltS4
        ldf.fill.nt1  fs5 = [src2], CxFltS7 - CxFltS5
        mov         bt1 = t7
        ;;

        ldf.fill.nt1  fs6 = [src1], CxFltS8 - CxFltS6
        ldf.fill.nt1  fs7 = [src2], CxFltS9 - CxFltS7
        mov         ar.lc = t8
        ;;

        ldf.fill.nt1  fs8 = [src1], CxFltS10 - CxFltS8
        ldf.fill.nt1  fs9 = [src2], CxFltS11 - CxFltS9
        mov         ar.ec = t9
        ;;

        ldf.fill.nt1  fs10 = [src1], CxFltS12 - CxFltS10
        ldf.fill.nt1  fs11 = [src2], CxFltS13 - CxFltS11
        nop.i       0
        ;;

        ldf.fill.nt1  fs12 = [src1], CxFltS14 - CxFltS12
        ldf.fill.nt1  fs13 = [src2], CxFltS15 - CxFltS13
        add         loc6 = CxIntGp, a0
        ;;

        ldf.fill.nt1  fs14 = [src1], CxFltS16 - CxFltS14
        ldf.fill.nt1  fs15 = [src2], CxFltS17 - CxFltS15
        add         loc7 = CxIntT0, a0
        ;;

        ldf.fill.nt1  fs16 = [src1], CxFltS18 - CxFltS16
        ldf.fill.nt1  fs17 = [src2], CxFltS19 - CxFltS17
        add         t19 = CxRsRNAT, a0
        ;;

        ldf.fill.nt1  fs18 = [src1]
        ldf.fill.nt1  fs19 = [src2]
        add         t7 = CxStFPSR, a0
        ;;

        ld8.nt1     loc8 = [t7]                 // load fpsr from context
        ld8.nt1     loc5 = [t19]                // load rnat from context
        nop.i       0

        ld8.fill.nt1 gp = [loc6], CxIntT1 - CxIntGp
        ld8.fill.nt1 t0 = [loc7], CxIntS0 - CxIntT0
        ;;

        ld8.fill.nt1 t1 = [loc6], CxIntS1 - CxIntT1
        ld8.fill.nt1 s0 = [loc7], CxIntS2 - CxIntS0
        ;;

        ld8.fill.nt1 s1 = [loc6], CxIntS3 - CxIntS1
        ld8.fill.nt1 s2 = [loc7], CxIntV0 - CxIntS2
        ;;

        ld8.fill.nt1 s3 = [loc6], CxIntTeb - CxIntS3
        ld8.fill.nt1 v0 = [loc7], CxIntT2 - CxIntV0
        ;;

        ld8.fill.nt1 teb = [loc6], CxIntT3 - CxIntTeb
        ld8.fill.nt1 t2 = [loc7], CxIntSp - CxIntT2
        ;;

        ld8.fill.nt1 t3 = [loc6], CxIntT4 - CxIntT3
        ld8.fill.nt1 loc4 = [loc7], CxIntT5 - CxIntSp
        ;;

        ld8.fill.nt1 t4 = [loc6], CxIntT6 - CxIntT4
        ld8.fill.nt1 t5 = [loc7], CxIntT7 - CxIntT5
        ;;

        ld8.fill.nt1 t6 = [loc6], CxIntT8 - CxIntT6
        ld8.fill.nt1 t7 = [loc7], CxIntT9 - CxIntT7
        ;;

        ld8.fill.nt1 t8 = [loc6], CxIntT10 - CxIntT8
        ld8.fill.nt1 t9 = [loc7], CxIntT11 - CxIntT9
        ;;

        ld8.fill.nt1 t10 = [loc6], CxIntT12 - CxIntT10
        ld8.fill.nt1 t11 = [loc7], CxIntT13 - CxIntT11
        ;;

        ld8.fill.nt1 t12 = [loc6], CxIntT14 - CxIntT12
        ld8.fill.nt1 t13 = [loc7], CxIntT15 - CxIntT13
        ;;

        ld8.fill.nt1 t14 = [loc6], CxIntT16 - CxIntT14
        ld8.fill.nt1 t15 = [loc7], CxIntT17 - CxIntT15
        ;;

        ld8.fill.nt1 t16 = [loc6], CxIntT18 - CxIntT16
        ld8.fill.nt1 t17 = [loc7], CxIntT19 - CxIntT17
        ;;

        ld8.fill.nt1 t18 = [loc6], CxIntT20 - CxIntT18
        ld8.fill.nt1 t19 = [loc7], CxIntT21 - CxIntT19
        ;;

        ld8.fill.nt1 t20 = [loc6], CxIntT22 - CxIntT20
        ld8.fill.nt1 t21 = [loc7]
        ;;

        rsm         1 << PSR_I
        ld8.fill.nt1 t22 = [loc6] 
        ;;

        rsm         1 << PSR_IC
        movl        t0 = 1 << IFS_V
        ;;

        mov         ar.fpsr = loc8              // set fpsr
        mov         ar.unat = loc0
        ;;

        srlz.d
        or          loc10 = t0, loc10           // set ifs valid bit
        ;;

        mov         cr.iip = loc9
        mov         cr.ifs = loc10
        bsw.0
        ;;

        mov         cr.dcr = loc1
        mov         r17 = loc2                  // put BSP in a shadow reg
        or          r16 = 0x3, loc3             // put RSE in eager mode

        mov         ar.rsc = r0                 // put RSE in enforced lazy
        nop.m       0
        add         r20 = CxStIPSR, a0
        ;;

        ld8.nt1     r20 = [r20]                 // load IPSR
        mov         r18 = loc4                  // put SP in a shadow reg
        mov         r19 = loc5                  // put RNaTs in a shadow reg
        ;;

        alloc       t0 = 0, 0, 0, 0
        mov         cr.ipsr = r20
        mov         sp = r18
        ;;

        loadrs
        ;;
        mov         ar.bspstore = r17
        nop.i       0
        ;;

        mov         ar.rnat = r19               // set rnat register
        mov         ar.rsc = r16                // restore RSC
        bsw.1
        ;;

        invala
        nop.i       0
        rfi
        ;;


//
// This label is used to determine the size of the wake dispatcher code in the
// process of copying it to a free page.
//

WakeDispatcherEndLocal::
        LEAF_EXIT(WakeDispatcherEndLocal)


        .sdata
WakeDispatcherStart::
        data4    @secrel(WakeDispatcherStartLocal)
WakeDispatcherEnd::
        data4    @secrel(WakeDispatcherEndLocal)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\inc\fpswa.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    fpswa.h
    
Abstract:

    EFI driver wrapper for FPSWA

Revision History

--*/

//
// First define PAL_RETURN
//
typedef int PAL_RETURN;

//
// Global ID for fpswa driver & protocol
//



#define EFI_INTEL_FPSWA     \
    { 0xc41b6531, 0x97b9, 0x11d3, 0x9a, 0x29, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }

#define EFI_INTEL_FPSWA_REVISION    0x00010000

//
//
//

typedef 
PAL_RETURN
(EFIAPI *EFI_FPSWA) (
    IN struct _FPSWA_INTERFACE  *This,
    // IN UINTN                    TrapType,
    IN unsigned int		TrapType,
    IN OUT VOID                 *Bundle,
    IN OUT UINT64               *pipsr,
    IN OUT UINT64               *pfsr,
    IN OUT UINT64               *pisr,
    IN OUT UINT64               *ppreds,
    IN OUT UINT64               *pifs,
    IN OUT VOID                 *fp_state
    );


typedef struct _FPSWA_INTERFACE {
    UINT32      Revision;
    UINT32      Reserved;

    EFI_FPSWA   Fpswa;    
} FPSWA_INTERFACE;

//
// Prototypes
//

PAL_RETURN
FpswaEntry (
    IN FPSWA_INTERFACE          *This,
    // IN UINTN                    TrapType,
    IN unsigned int		TrapType,
    IN OUT VOID                 *Bundle,
    IN OUT UINT64               *pipsr,
    IN OUT UINT64               *pfsr,
    IN OUT UINT64               *pisr,
    IN OUT UINT64               *ppreds,
    IN OUT UINT64               *pifs,
    IN OUT VOID                 *fp_state
    );



//
// Globals
//

extern EFI_GUID FpswaId;
extern FPSWA_INTERFACE FpswaInterface;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\ia64\wake.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wake.c

Abstract:

    This module contains architecture dependent support for hibernation
    on IA-64.

Author:

    Allen Kay (allen.m.kay@intel.com)

Revision History:

--*/

#include <bldr.h>


#if defined (HIBER_DEBUG)
extern VOID HbPrint(PUCHAR);
extern VOID HbPrintNum(ULONG n);
extern VOID HbPrintHex(ULONG n);
extern VOID HbPause(VOID);
#define SHOWNUM(x) ((void) (HbPrint(#x " = "), HbPrintNum((ULONG) (x)), HbPrint("\r\n")))
#define SHOWHEX(x) ((void) (HbPrint(#x " = "), HbPrintHex((ULONG) (x)), HbPrint("\r\n")))
#endif


//
// When the hibernation image is read from disk each page must return to the
// same page frame it came from.  Some of those page frames are currently in
// use by firmware or OS Loader, so the pages that belong there must be
// loaded temporarily somewhere else and copied into place just before the
// saved image is restarted.
//
// The hibernation file contains a list of pages that were not in use by
// the saved image, and were allocated from memory marked as MemoryFree by
// firmware.  MapPage is initialized to point to this list; as pages are
// needed for relocation, they are chosen from this list.  RemapPage is
// a corresponding array of where each relocated page actually belongs.
//

PPFN_NUMBER HiberMapPage;
PPFN_NUMBER HiberRemapPage;

ULONG HiberCurrentMapIndex;


VOID
HbInitRemap(
    PPFN_NUMBER FreeList
    )
/*++

Routine Description:

    Initialize memory allocation and remapping.  Find a free page
    in the FreeList, copy the FreeList into it, and point HiberMapPage
    to it.  Find another free page and and point HiberRemapPage to it.
    Initialize HiberLastRemap.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HiberMapPage = HiberRemapPage = FreeList;   // so HbNextSharedPage will work
    HiberMapPage = HbNextSharedPage(0, 0);
    RtlCopyMemory(HiberMapPage, FreeList, PAGE_SIZE);
    HiberRemapPage = HbNextSharedPage(0, 0);
}


PVOID
HbMapPte (
    IN ULONG        PteToMap,
    IN PFN_NUMBER   Page
    )
/*++

Routine Description:

    Return a 32 superpage pointer to the specified physical page.
    (On x86, this function maps the page and returns a virtual address.)

Arguments:

    PteToMap    - unused, present only for x86 compatibility

    Page        - the physical page (page frame number) to map,
                  must be below 1 GB.

Return Value:

    32 bit superpage address of the page.

--*/
{
    ASSERT (Page < (1024L * 1024L * 1024L >> PAGE_SHIFT)) ;
    return (PVOID) ((Page << PAGE_SHIFT) + KSEG0_BASE) ;
}


PVOID
HbNextSharedPage (
    IN ULONG        PteToMap,
    IN PFN_NUMBER   RealPage
    )
/*++

Routine Description:

    Allocates the next available page in the free list and
    maps the Hiber pte to the page.   The allocated page
    is put onto the remap list.

Arguments:

    PteToMap    - unused, present only for x86 compatibility

    RealPage    - The page to enter into the remap table for
                  this allocation

Return Value:

    Virtual address of the mapping

--*/

{
    PFN_NUMBER  DestPage;
    ULONG       i;

#if defined (HIBER_DEBUG) && (HIBER_DEBUG & 2)
    HbPrint("HbNextSharedPage("); HbPrintHex(RealPage); HbPrint(")\r\n");
    SHOWNUM(HiberCurrentMapIndex);
    SHOWNUM(HiberNoMappings);
#endif

    //
    // Loop until we find a free page which is not in
    // use by the loader image, then map it
    //

    while (HiberCurrentMapIndex < HiberNoMappings) {
        DestPage = HiberMapPage[HiberCurrentMapIndex];
        HiberCurrentMapIndex += 1;

#if defined (HIBER_DEBUG) && (HIBER_DEBUG & 2)
        SHOWHEX(DestPage);
#endif

        i = HbPageDisposition (DestPage);
        if (i == HbPageInvalid) {
#if defined (HIBER_DEBUG) && (HIBER_DEBUG & 2)
            HbPrint("Invalid\n");
            HbPause();
#endif
            HiberIoError = TRUE;
            return HiberBuffer;
        }

        if (i == HbPageNotInUse) {
#if defined (HIBER_DEBUG) && (HIBER_DEBUG & 2)
            HbPrint("Not in use\r\n");
            HbPause();
#endif

#if defined (HIBER_DEBUG) && (HIBER_DEBUG & 4)
            HbPrint("\r\n"); HbPrintHex(RealPage); HbPrint(" at "); HbPrintHex(DestPage);
#endif
            HiberMapPage[HiberLastRemap] = DestPage;
            HiberRemapPage[HiberLastRemap] = RealPage;
            HiberLastRemap += 1;
            return HbMapPte(PteToMap, DestPage);
        }
#if defined (HIBER_DEBUG)
        SHOWNUM(i);  
#endif
    }
#if defined (HIBER_DEBUG)
    HbPrint("Out of remap\r\n");
    HbPause();
#endif
    HiberOutOfRemap = TRUE;
    return HiberBuffer;
}


VOID
HiberSetupForWakeDispatch (
    VOID
    )
{
    //
    // Make sure the I-cache is coherent with the wake dispatch code that was
    // copied to a free page.
    //

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\biboot.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    biboot.h

Abstract:

    Public IBI header files

Author:

    

Revision History

--*/


#include "bootia64.h"            // BUGBUG

// #define IBI32           1       // Building 32 bit IBI
#define IBI64           1       // Building 64 bit IBI

#include "ibi.h"

//
// Console functions
//


IBI_STATUS
BiOutputString (
    VOID        *Context,
    CHAR16      *Str
    );

IBI_STATUS
BiSetAttribute (
    VOID        *Context,
    UINTN       Attribute
    );

IBI_STATUS
BiSetCursorPosition (
    VOID        *Context,
    UINTN       Column,
    UINTN       Row
    );

VOID
BIASSERT (
    IN char     *str
    );

//
// Arc functions
//

ARC_STATUS
BiArcNotImplemented (
    IN ULONG    No
    );


ARC_STATUS
BiArcCloseNop (
    IN ULONG FileId
    );


IBI_STATUS
BiHandleToArcName (
    IN IBI_HANDLE       Handle,
    OUT PUCHAR          Buffer,
    IN UINTN            BufferSize
    );

IBI_STATUS
BiArcNameToHandle (
    IN PCHAR                        OpenPath,
    OUT IBI_ARC_OPEN_CONTEXT        *OpenContext,
    OUT PBL_DEVICE_ENTRY_TABLE      *ArcIo
    );


//
// Allocate and free IBI pool (not loader pool)
//

PVOID
BiAllocatePool (
    IN UINTN    Size
    );


VOID
BiFreePool (
    IN PVOID    Buffer
    );


WCHAR *
BiDupAscizToUnicode (
    PUCHAR      Str
    );

//
//
//

ARC_STATUS
BiArcCode (
    IN IBI_STATUS   Status
    );

//
// Externals
//

extern IBI_SYSTEM_TABLE         *IbiST;
extern IBI_BOOT_SERVICES        *IbiBS;
extern IBI_RUNTIME_SERVICES     *IbiRT;
extern IBI_LOADED_IMAGE         *IbiImageInfo;
extern IBI_HANDLE               IbiNtldr;

extern IBI_GUID IbiLoadedImageProtocol;
extern IBI_GUID IbiDevicePathProtocol;
extern IBI_GUID IbiBlockIoProtocol;
extern IBI_GUID IbiFilesystemProtocol;
extern IBI_GUID IbiDeviceIoProtocol;

extern IBI_GUID IbiFileInformation;
extern IBI_GUID IbiFileSystemInformation;

extern IBI_GUID VendorMicrosoft;

extern BL_DEVICE_ENTRY_TABLE    BiArcConsoleOut;
extern BL_DEVICE_ENTRY_TABLE    BiArcConsoleIn;
extern BL_DEVICE_ENTRY_TABLE    BiArcBlockIo;
extern BL_DEVICE_ENTRY_TABLE    BiArcFsDevIo;
extern PUCHAR                   BiClipBuffer;
extern UINTN                    BiClipBufferSize;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\inc\sal.h ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

//++
//
//  Module name
//	sal.h
//  Author
//	Allen Kay    (akay)    Jun-12-95
//  Description
//	Defines SAL data structures
//--

#ifndef __SUSAL__
#define __SUSAL__

typedef struct _IA32_BIOS_REGISTER_STATE {

    // general registers
    ULONG eax;    
    ULONG ecx;    
    ULONG edx;    
    ULONG ebx;    
    ULONG esp;    

    // stack registers
    ULONG ebp;    
    ULONG esi;    
    ULONG edi;    

    // eflags
    ULONG eflags;    

    // instruction pointer
    ULONG eip;

    // segment registers
    USHORT cs;    
    USHORT ds;    
    USHORT es;    
    USHORT fs;    
    USHORT gs;    
    USHORT ss;    

    ULONG Reserved1;
    ULONGLONG Reserved2;
} IA32_BIOS_REGISTER_STATE, *PIA32_BIOS_REGISTER_STATE;

typedef union _BIT32_AND_BIT16 {
    ULONG Part32;
    struct {
        USHORT LowPart16;
        USHORT HighPart16;
    };
    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
    };
} BIT32_AND_BIT16;

//
// EFLAG definition
//
#define CARRY_FLAG       0x1
#define PARITY_FLAG      0x2
#define AUXILARY_FLAG    0x4
#define ZERO_FLAG        0x8
#define SIGN_FLAG        0x10
#define TRAP_FLAG        0x11

//
// SAL descriptor types
//
typedef enum {
    PAL_SAL_EP_TYPE = 0,
    SAL_MEMORY_TYPE,
    PLATFORM_FEATURES_TYPE,
    TRANSLATION_REGISTER_TYPE,
    PTC_COHERENCE_TYPE,
    AP_WAKEUP_TYPE
};

//
//  Format of the SAL System Table (SST) Header. SAL Specs July 2000, Revision: 2.9.
//  The SST is followed by a variable number of entries with varying length.
//

typedef struct _SST_HEADER {
    ULONG   Signature;
    ULONG   Length;
    USHORT  SalRev;
    USHORT  EntryCount;
    UCHAR   CheckSum;
    UCHAR   Reserved1[7];
    USHORT  Sal_A_Version;
    USHORT  Sal_B_Version;
    UCHAR   OemId[32];
    UCHAR   ProductId[32];
    UCHAR   Reserved2[8];
} SST_HEADER, *PSST_HEADER;

//
// PAL and SAL entry point descriptor
//
typedef struct _PAL_SAL_ENTRY_POINT {
    UCHAR EntryType;
    UCHAR Reserved0[7];
    ULONGLONG PalEntryPoint;
    ULONGLONG SalEntryPoint;
    ULONGLONG GlobalPointer;
    UCHAR Reserved1[16];
} PAL_SAL_ENTRY_POINT, *PPAL_SAL_ENTRY_POINT;

//
// Memory descriptor
//
typedef struct _SAL_MEMORY_DESCRIPTOR {
    UCHAR EntryType;
    UCHAR NeedVaReg;
    UCHAR CurrentAttribute;
    UCHAR PageAccessRights;
    UCHAR SupportedAttribute;
    UCHAR Reserved1[1];
    UCHAR MemoryType;
    UCHAR MemoryUsage;
    ULONGLONG Address;
    ULONG Length;
    UCHAR Reserved[4];
    UCHAR OemReserved[8];
} SAL_MEMORY_DESCRIPTOR, *PSAL_MEMORY_DESCRIPTOR;

typedef struct _PLATFORM_FEATURES {
    UCHAR EntryType;
    UCHAR FeatureList;
    UCHAR Reserved[14];
} PLATFORM_FEATURES, *PPLATFORM_FEATURES;

typedef struct _TRANSLATION_REGISTER {
    UCHAR EntryType;
    UCHAR TRType;
    UCHAR TRNumber;
    UCHAR Reserved1[5];
    ULONGLONG VirtualAddress;
    ULONGLONG PageSize;
    UCHAR Reserved2[8];
} TRANSLATION_REGISTER, *PTRANSLATION_REGISTER;

typedef struct _PTC_COHERENCE_DOMAIN {
    UCHAR EntryType;
    UCHAR Reserved[3];
    ULONG NumberOfDomains;
    ULONGLONG CoherenceDomainInfo;
} PTC_COHERENCE_DOMAIN, *PPTC_COHERENCE_DOMAIN;

typedef struct _COHERENCE_DOMAIN_INFO {
    ULONGLONG NumberOfProcessors;
    ULONGLONG LocalIdRegisters;
} COHERENCE_DOMAIN_INFO, *PCOHERENCE_DOMAIN_INFO;

typedef struct _AP_WAKEUP_DESCRIPTOR {
    UCHAR EntryType;
    UCHAR WakeupMechanism;
    UCHAR Reserved[6];
    ULONGLONG WakeupVector;
} AP_WAKEUP_DESCRIPTOR, *PAP_WAKEUP_DESCRIPTOR;

typedef struct _BOOT_INFO_TABLE {
    ULONGLONG Signature;
    ULONG TableLength;
    UCHAR CheckSum;
    UCHAR DriveNumber;
    UCHAR OsRecord;
    UCHAR Reserved1[1];
    PULONGLONG OsBootDevice;
    UCHAR ConsoleInputNumber;
    UCHAR ConsoleOutputNumber;
    UCHAR Reserved2[6];
    ULONGLONG OsBootDeviceRecord;
    ULONGLONG ConsoleIn1DevInfo;
    ULONGLONG ConsoleOut1DevInfo;
} BOOT_INFO_TABLE, *PBOOT_INFO_TABLE;

//
//
// EDD Disk Address Packet definition
//
typedef struct _DISK_ADDRESS_PACKET {
    UCHAR PacketSize;
    UCHAR Reserved0;
    UCHAR BlocksToTransfer;
    UCHAR Reserved1;
    ULONG Buffer32;
    ULONGLONG LBA;
    PUCHAR Buffer64;
} DISK_ADDRESS_PACKET, *PDISK_ADDRESS_PACKET;

//
// SAL procedure function ID's
//
#define SAL_SYSTEM_RESET           0x01000000
#define SAL_SET_VECTORS            0x01000001
#define SAL_GET_STATE_INFO         0x01000002
#define SAL_GET_STATE_INFO_SIZE    0x01000003
#define SAL_CLEAR_STATE_INFO       0x01000004
#define SAL_MC_RENDEZ              0x01000005
#define SAL_MC_SET_PARAMS          0x01000006
#define SAL_VERSION                0x01000007
#define SAL_CACHE_FLUSH            0x01000010
#define SAL_CACHE_INIT             0x01000011
#define SAL_PCI_CONFIG_READ        0x01000030
#define SAL_PCI_CONFIG_WRITE       0x01000031
#define SAL_FREQ_BASE              0x01000032
#define SAL_EXT_ISR_ADD            0x01000033
#define SAL_EXT_ISR_DELETE         0x01000034
#define SAL_ALLOC_MEM              0x01000050
#define SAL_FREE_MEM               0x01000051
#define SAL_UPDATE_PAL             0x01000060

//
// Macro used by functions in exp.c
//
#define BCD_TO_BIN(BcdNumber)       (BcdNumber & 0xf0) + (BcdNumber & 0x0f)

//
// Structure definitions and equates for INT 15 function E820
//

typedef struct _E820_FRAME {
    ULONG ErrorFlag;
    ULONG Key;
    ULONG DescSize;

    ULONG BaseAddrLow;
    ULONG BaseAddrHigh;
    ULONG SizeLow;
    ULONG SizeHigh;
    ULONG MemoryType;
} E820_FRAME, *PE820_FRAME;

//
// Return value structure
//
typedef struct _SAL_RETURN_VALUES {
    ULONGLONG RetVal0;
    ULONGLONG RetVal1;
    ULONGLONG RetVal2;
    ULONGLONG RetVal3;
} SAL_RETURN_VALUES, *PSAL_RETURN_VALUES;

//
// SAL Handoff Parameters
//
typedef struct _SAL_HANDOFF_PARAMS {
    ULONG_PTR MPSConfigTable;
    ULONG_PTR SalSystemTable;
    ULONG_PTR BootInfoTable;
    ULONG_PTR PalProcEp;
    ULONG_PTR SalProcEp;
    ULONGLONG SalProcGp;
    ULONG_PTR AcpiRsdt;
} SAL_HANDOFF_PARAMS, *PSAL_HANDOFF_PARAMS;

//
// Defining entry point for SAL_PROC.
//
typedef
VOID
(*PTRANSFER_ROUTINE) ();

//
// Misc. definitions.
//
#define SAL_BLOCK_SIZE       0x1000    // SAL memory block size

#endif __SUSAL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\efi\inc\paldef.h ===
#ifndef _PALDEF_H_
#define _PALDEF_H_

// iA-64 defined PAL virtual mode function IDs in decimal format as in the PAL spec

#define PAL_CACHE_FLUSH                                       1
#define PAL_CACHE_INFO                                        2
#define PAL_CACHE_INIT                                        3
#define PAL_CACHE_PROT_INFO                                  38
#define PAL_CACHE_SUMMARY                                     4
#define PAL_PTCE_INFO                                         6
#define PAL_VM_INFO                                           7
#define PAL_VM_PAGE_SIZE                                     34
#define PAL_VM_SUMMARY                                        8
#define PAL_PERF_MON_INFO                                    15
#define PAL_MC_CLEAR_LOG                                     21
#define PAL_MC_DRAIN                                         22
#define PAL_MC_ERROR_INFO                                    25
#define PAL_HALT                                             28
#define PAL_HALT_INFO                                       257
#define PAL_HALT_LIGHT                                       29
#define PAL_SHUTDOWN                                         44

// iA-64 defined PAL physical mode function IDs in decimal format as in the PAL spec

#define PAL_VM_TR_READ                                      261
#define PAL_MEM_ATTRIB                                        5
#define PAL_BUS_GET_FEATURES                                  9
#define PAL_BUS_SET_FEATURES                                 10
#define PAL_DEBUG_INFO                                       11
#define PAL_FIXED_ADDR                                       12
#define PAL_FREQ_BASE                                        13
#define PAL_FREQ_RATIOS                                      14
#define PAL_PLATFORM_ADDR                                    16
#define PAL_PROC_GET_FEATURES                                17
#define PAL_PROC_SET_FEATURES                                18
#define PAL_REGISTER_INFO                                    39
#define PAL_RSE_INFO                                         19
#define PAL_VERSION                                          20
#define PAL_MC_DYNAMIC_STATE                                 24
#define PAL_MC_EXPECTED                                      23
#define PAL_MC_REGISTER_MEM                                  27
#define PAL_MC_RESUME                                        26
#define PAL_CACHE_LINE_INIT                                  31
#define PAL_CACHE_READ                                      259
#define PAL_CACHE_WRITE                                     260
#define PAL_MEM_FOR_TEST                                     37
#define PAL_TEST_PROC                                       258
#define PAL_COPY_INFO                                        30
#define PAL_COPY_PAL                                        256
#define PAL_ENTER_IA_32_ENV                                  33
#define PAL_PMI_ENTRYPOINT                                   32

//
// iA-64 defined PAL return values
//

#define PAL_STATUS_INVALID_CACHELINE                          1
#define PAL_STATUS_SUCCESS                                    0
#define PAL_STATUS_NOT_IMPLEMENTED                           -1
#define PAL_STATUS_INVALID_ARGUMENT                          -2
#define PAL_STATUS_ERROR                                     -3
#define PAL_STATUS_UNABLE_TO_INIT_CACHE_LEVEL_AND_TYPE       -4
#define PAL_STATUS_NOT_FOUND_IN_CACHE                        -5
#define PAL_STATUS_NO_ERROR_INFO_AVAILABLE                   -6

#endif  // PALDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\blcache.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blcache.h

Abstract:

    This module declares parameters, data structures and functions for
    a general purpose disk caching for the boot loader. Although it is
    mostly general purpose, it is mainly used for caching filesystem
    metadata, since that is the only frequently reaccessed data in the
    boot loader. In order to use caching on a device, you must make
    sure that there is only one unique BlFileTable entry for that
    device and the same device is not opened & cached simultaneously
    multiple times under different device ids. Otherwise there will be
    cache inconsistencies, since cached data and structures are
    maintained based on device id. Also you must make sure to stop
    caching when the device is closed.

Author:

    Cenk Ergan (cenke) 14-Jan-2000

Revision History:

--*/

#ifndef _BLCACHE_H
#define _BLCACHE_H

#include "bldr.h"
#include "blrange.h"

//
// Define boot loader disk cache parameters and data structures.
//

//
// Currently device id - cache header pairing is done using a global
// table. This determines maximum number of entries in this table. We
// really need just two entries, one for LoadDevice, one for
// SystemDevice. Caches for all devices share the same resources
// [e.g. cache blocks and Most Recently Used list etc.]
//

#define BL_DISKCACHE_DEVICE_TABLE_SIZE 2

//
// Size of ranges that are cached. We read & cache fixed size blocks
// from the devices which makes memory management easy, since we can't
// use boot loader's: there is no HeapFree, just HeapAlloc! BLOCK_SIZE
// has to be a power of two for alignment arithmetic to work.
//

#define BL_DISKCACHE_BLOCK_SIZE (32 * 1024)

//
// Maximum number of bytes cached in the disk cache [i.e. maximum size
// disk cache may grow to]. This should be a multiple of BLOCK_SIZE below.
//

#define BL_DISKCACHE_SIZE (64 * BL_DISKCACHE_BLOCK_SIZE)

//
// Maximum number of cache blocks / range entries there can be in the
// cache. There will be a range entry for each block, i.e. it should
// be cache size / block size.
//

#define BL_DISKCACHE_NUM_BLOCKS (BL_DISKCACHE_SIZE / BL_DISKCACHE_BLOCK_SIZE)

//
// Size of the buffer needed for storing maximum number of overlapping
// or distinct range entries for a 64KBs request given BLOCK_SIZE. We
// reserve this on the stack [i.e. buffer is a local variable] in
// BlDiskCacheRead: make sure it is not too big! We base it assuming
// that distincts buffer will be larger [since it is BLCRANGE entries
// instead where as overlaps buffer contains BLCRANGE_ENTRY pointers.]
//

#define BL_DISKCACHE_FIND_RANGES_BUF_SIZE \
    (((64 * 1024 / BL_DISKCACHE_BLOCK_SIZE) + 3) * (sizeof(BLCRANGE)))

//
// This is the header for the cache for a particular device. The
// cached ranges on this device are stored in the Ranges list.
//

typedef struct _BL_DISK_SUBCACHE
{
    BOOLEAN Initialized;
    ULONG DeviceId;
    BLCRANGE_LIST Ranges;
} BL_DISK_SUBCACHE, *PBL_DISK_SUBCACHE;

//
// Define structure for the global boot loader diskcache.
//

typedef struct _BL_DISKCACHE
{
    //
    // Table that contains cache headers. Cache - DeviceId pairing is
    // also done using this table.
    //

    BL_DISK_SUBCACHE DeviceTable[BL_DISKCACHE_DEVICE_TABLE_SIZE];

    //
    // Most recently used list for cached blocks [range
    // entries]. Entries are linked through the UserLink field in the
    // BLCRANGE_ENTRY. The least recently used block is at the very
    // end. Any entries placed on a cache's range list is also put on
    // this list. When removing a range from a cache's range list, the
    // callback removes it from this list too. BlDiskCacheRead updates
    // this list and prunes it if normal cache entry allocation fails.
    //

    LIST_ENTRY MRUBlockList;

    //
    // This is where cached data is stored. Its size is
    // BL_DISKCACHE_SIZE. It is divided up into BL_DISKCACHE_NUM_BLOCKS 
    // blocks. Nth block belongs to Nth entry in the EntryBuffer.
    //

    PUCHAR DataBuffer;

    //
    // Range entries to be put into the cache's range lists are
    // allocated from here. It has BL_DISKCACHE_NUM_BLOCKS elements.
    //

    PBLCRANGE_ENTRY EntryBuffer;

    //
    // This array is used for keeping track of the free range entries
    // in EntryBuffer. Free range entries get linked up on this list
    // using the UserLink field. Once the entry is allocated, the
    // UserLink field is usually used to link it up to the MRU list.
    //

    LIST_ENTRY FreeEntryList;

    //
    // Keep track of whether we are initialized or not.
    //
    
    BOOLEAN Initialized;

} BL_DISKCACHE, *PBL_DISKCACHE;

//
// Declare global variables.
//

//
// This is the boot loader disk cache with all its bells and whistles.
//

extern BL_DISKCACHE BlDiskCache;

//
// Debug defines. Use these to actively debug the disk cache. These
// are not turned on for checked build, because they would spew out
// too much to the console.
//

#ifdef BL_DISKCACHE_DEBUG
#define DPRINT(_x) DbgPrint _x;
#define DASSERT(_c) do { if (_c) DbgBreakPoint(); } while (0);
#else // BL_DISKCACHE_DEBUG
#define DPRINT(_x)
#define DASSERT(_c)
#endif // BL_DISKCACHE_DEBUG

//
// These two defines are used as the last parameter to BlDiskCacheRead.
// They specify whether any new data read from the disk should be put
// into the disk cache or not. In the boot loader file systems we usually 
// choose to cache new data if we are reading metadata, and not choose to 
// cache it if we are reading file data.
//

#define CACHE_NEW_DATA       (TRUE)
#define DONT_CACHE_NEW_DATA  (FALSE)

//
// Useful macros. Be mindful of expression reevaluation as with
// all macros.
//

#define BLCMIN(a,b) (((a) <= (b)) ? (a) : (b))
#define BLCMAX(a,b) (((a) >= (b)) ? (a) : (b))

//
// Cache function prototypes. See ntos\boot\lib\blcache.c for comments
// and implementation.
//

ARC_STATUS
BlDiskCacheInitialize(
    VOID
    );

VOID
BlDiskCacheUninitialize(
    VOID
    );

PBL_DISK_SUBCACHE
BlDiskCacheStartCachingOnDevice(
    ULONG DeviceId
    );

VOID
BlDiskCacheStopCachingOnDevice(
    ULONG DeviceId
    );

ARC_STATUS
BlDiskCacheRead (
    ULONG DeviceId,
    PLARGE_INTEGER pOffset,
    PVOID Buffer,
    ULONG Length,
    PULONG pCount,
    BOOLEAN CacheNewData
    );

ARC_STATUS
BlDiskCacheWrite (
    ULONG DeviceId,
    PLARGE_INTEGER pOffset,   
    PVOID Buffer,
    ULONG Length,
    PULONG pCount
    );

#endif // _BLCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\bldria64.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bldria64.h

Abstract:

    Contains definitions and prototypes specific to the IA64 NTLDR.

Author:

    John Vert (jvert) 20-Dec-1993

Revision History:

--*/

#ifndef _BLDRIA64_
#define _BLDRIA64_

#include "bldr.h"
#include "bootefi.h"
#include "efi.h"

VOID
AEInitializeStall(
    VOID
    );

ARC_STATUS
AEInitializeIo(
    IN ULONG DriveId
    );

//
// FIX: this routine is currently broken on IA64.
//
PVOID
FwAllocateHeap(
    IN ULONG Size
    );

PCHAR
BlSelectKernel(
    VOID
    );


BOOLEAN
BlDetectHardware(
    IN ULONG DriveId,
    IN PCHAR LoadOptions
    );

VOID
BlStartup(
    IN PCHAR PartitionName
    );

#ifndef EFI
//
// Arc routines for supporting common VGA I/O routines
//
#define ARC_DISPLAY_CLEAR_ESCAPE "\033[2J"
#define ARC_DISPLAY_CLEAR()  { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, ARC_DISPLAY_CLEAR_ESCAPE, \
              sizeof(ARC_DISPLAY_CLEAR_ESCAPE) - 1, &LocalCount); \
     }

#define ARC_DISPLAY_CLEAR_TO_EOD() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[0J", sizeof("\033[0J") - 1, &LocalCount); \
}

#define ARC_DISPLAY_CLEAR_TO_EOL() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[0K", sizeof("\033[0K") - 1, &LocalCount); \
}

#define ARC_DISPLAY_ATTRIBUTES_OFF() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[0m", sizeof("\033[0m") - 1, &LocalCount); \
}

#define ARC_DISPLAY_INVERSE_VIDEO() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[7m", sizeof("\033[7m") - 1, &LocalCount); \
}

#define ARC_DISPLAY_SET_COLOR(c) { \
     ULONG LocalCount; \
     UCHAR LocalBuffer[40]; \
     sprintf(LocalBuffer, "\033[%sm", c); \
     ArcWrite(BlConsoleOutDeviceId, LocalBuffer, strlen(LocalBuffer), &LocalCount); \
}

#define ARC_DISPLAY_POSITION_CURSOR(x, y) { \
     ULONG LocalCount; \
     UCHAR LocalBuffer[40]; \
     sprintf(LocalBuffer, "\033[%d;%dH", y + 1, x + 1); \
     ArcWrite(BlConsoleOutDeviceId, LocalBuffer, strlen(LocalBuffer), &LocalCount); \
}
#endif

//
// headless routines
//
extern BOOLEAN BlTerminalConnected;
extern ULONG BlTerminalDeviceId;
extern ULONG BlTerminalDelay;

LOGICAL
BlTerminalAttached(
    IN ULONG TerminalDeviceId
    );

//          E X T E R N A L   S E R V I C E S   T A B L E
//
// External Services Table - machine dependent services
// like reading a sector from the disk and finding out how
// much memory is installed are provided by a lower level
// module or a ROM BIOS. The EST provides entry points
// for the OS loader.
//

//**
// NOTE WELL
//      The offsets of entries in this structure MUST MATCH
//      the offsets of BOTH the ExportEntryTable in ....\startup\i386\sudata.asm
//      AND ...\startrom\i386\sudata.asm.  You must change all 3
//      locations together.
//**

typedef struct _EXTERNAL_SERVICES_TABLE {
    VOID (__cdecl *  RebootProcessor)(VOID);
    NTSTATUS (__cdecl * DiskIOSystem)(UCHAR,UCHAR,USHORT,USHORT,UCHAR,UCHAR,PUCHAR);
    ULONG (__cdecl * GetKey)(VOID);
    ULONG (__cdecl * GetCounter)(VOID);
    VOID (__cdecl * Reboot)(ULONG);
    ULONG (__cdecl * AbiosServices)(USHORT,PUCHAR,PUCHAR,PUCHAR,PUCHAR,USHORT,USHORT);
    VOID (__cdecl * DetectHardware)(ULONG, ULONG, PVOID, PULONG, PCHAR, ULONG);
    VOID (__cdecl * HardwareCursor)(ULONG,ULONG);
    VOID (__cdecl * GetDateTime)(PULONG,PULONG);
    VOID (__cdecl * ComPort)(LONG,ULONG,UCHAR);
    BOOLEAN (__cdecl * IsMcaMachine)(VOID);
    ULONG (__cdecl * GetStallCount)(VOID);
    VOID (__cdecl * InitializeDisplayForNt)(VOID);
    VOID (__cdecl * GetMemoryDescriptor)(P820FRAME);
    NTSTATUS (__cdecl * GetEddsSector)(ULONGLONG,ULONG,ULONG,USHORT,PUCHAR,UCHAR);
    NTSTATUS (__cdecl * GetElToritoStatus)(PUCHAR,UCHAR);
    BOOLEAN (__cdecl * GetExtendedInt13Params)(PUCHAR,UCHAR);
    USHORT (__cdecl * NetPcRomServices)(ULONG,PVOID);
    VOID (__cdecl * ApmAttemptReconnect)(VOID);
    ULONG (__cdecl * BiosRedirectService)(ULONG);
} EXTERNAL_SERVICES_TABLE, *PEXTERNAL_SERVICES_TABLE;
extern PEXTERNAL_SERVICES_TABLE ExternalServicesTable;

//**
// SEE NOTE AT TOP OF STRUCTURE
//**

//
// External Services Macros
//

#define REBOOT_PROCESSOR    (*ExternalServicesTable->RebootProcessor)
#define GET_SECTOR          (*ExternalServicesTable->DiskIOSystem)
#define RESET_DISK          (*ExternalServicesTable->DiskIOSystem)
#define BIOS_IO             (*ExternalServicesTable->DiskIOSystem)
#define GET_KEY             (*ExternalServicesTable->GetKey)
#define GET_COUNTER         (*ExternalServicesTable->GetCounter)
#define REBOOT              (*ExternalServicesTable->Reboot)
#define ABIOS_SERVICES      (*ExternalServicesTable->AbiosServices)
#define DETECT_HARDWARE     (*ExternalServicesTable->DetectHardware)
#define HW_CURSOR           (*ExternalServicesTable->HardwareCursor)
#define GET_DATETIME        (*ExternalServicesTable->GetDateTime)
#define COMPORT             (*ExternalServicesTable->ComPort)
#define ISMCA               (*ExternalServicesTable->IsMcaMachine)
#define GET_STALL_COUNT     (*ExternalServicesTable->GetStallCount)
#define SETUP_DISPLAY_FOR_NT (*ExternalServicesTable->InitializeDisplayForNt)
#define GET_MEMORY_DESCRIPTOR (*ExternalServicesTable->GetMemoryDescriptor)
#define GET_EDDS_SECTOR     (*ExternalServicesTable->GetEddsSector)
#define GET_ELTORITO_STATUS (*ExternalServicesTable->GetElToritoStatus)
#define GET_XINT13_PARAMS   (*ExternalServicesTable->GetExtendedInt13Params)
#define NETPC_ROM_SERVICES  (*ExternalServicesTable->NetPcRomServices)
#define APM_ATTEMPT_RECONNECT (*ExternalServicesTable->ApmAttemptReconnect)
#define BIOS_REDIRECT_SERVICE (*ExternalServicesTable->BiosRedirectService)

//
// Define special key input values
//
#define DOWN_ARROW  0x5000
#define UP_ARROW    0x4800
#define HOME_KEY    0x4700
#define END_KEY     0x4F00
#define LEFT_KEY    0x4B00
#define RIGHT_KEY   0x4D00
#define INS_KEY     0x5200
#define DEL_KEY     0x5300
#define BKSP_KEY    0x0E08
#define TAB_KEY     0x0009
#define BACKTAB_KEY 0x0F00
#define F1_KEY      0x3B00
#define F2_KEY      0x3C00
#define F3_KEY      0x3D00
#define F5_KEY      0x3F00
#define F6_KEY      0x4000
#define F7_KEY      0x4100
#define F8_KEY      0x4200
#define F10_KEY     0x4400
#define ENTER_KEY   0x000D
#define ESCAPE_KEY  0x011B

//
// define various memory segments that are needed by the ia64 loaders
//

//
// 1-megabyte boundary line (in pages)
//

#define _1MB ((ULONG)0x100000 >> PAGE_SHIFT)

//
// 16-megabyte boundary line (in pages)
//

#define _16MB ((ULONG)0x1000000 >> PAGE_SHIFT)

//
// 48-megabyte boundary line (in pages)
//

#define _48MB ((ULONG)0x3000000 >> PAGE_SHIFT)
#define _64MB ((ULONG)0x4000000 >> PAGE_SHIFT)
#define _80MB ((ULONG)0x5000000 >> PAGE_SHIFT)

//
// Bogus memory line.  (We don't ever want to use the memory that is in
// the 0x40 pages just under the 80MB line.)
//
#define _80MB_BOGUS (((ULONG)0x5000000-0x80000) >> PAGE_SHIFT)

#define ROM_START_PAGE (0x0A0000 >> PAGE_SHIFT)
#define ROM_END_PAGE   (0x100000 >> PAGE_SHIFT)

//
// Define specific ranges where parts of the system should be loaded
//
#define BL_KERNEL_RANGE_LOW  _48MB
#define BL_KERNEL_RANGE_HIGH _64MB

#define BL_DRIVER_RANGE_LOW  _16MB
#define BL_DRIVER_RANGE_HIGH _48MB

#define BL_DECOMPRESS_RANGE_LOW  _64MB
#define BL_DECOMPRESS_RANGE_HIGH _80MB

#define BL_DISK_CACHE_RANGE_LOW   BlUsableBase
#define BL_DISK_CACHE_RANGE_HIGH  BlUsableLimit

#define BL_XIPROM_RANGE_LOW   BlUsableBase
#define BL_XIPROM_RANGE_HIGH  0xffffffff


//
// x86-specific video support
//
VOID
TextGetCursorPosition(
    OUT PULONG X,
    OUT PULONG Y
    );

VOID
TextSetCursorPosition(
    IN ULONG X,
    IN ULONG Y
    );

VOID
TextSetCurrentAttribute(
    IN UCHAR Attribute
    );

UCHAR
TextGetCurrentAttribute(
    VOID
    );

VOID
TextClearDisplay(
    VOID
    );

VOID
TextClearToEndOfDisplay(
    VOID
    );

VOID
TextClearFromStartOfLine(
    VOID
    );

VOID
TextClearToEndOfLine(
    VOID
    );

VOID
TextStringOut(
    IN PWCHAR String
    );

VOID
TextCharOut(
    IN PWCHAR pc
    );

VOID
TextFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    );


#define BlPuts(str) TextStringOut(str)

ULONG
BlGetKey(
    VOID
    );

VOID
BlInputString(
    IN ULONG Prompt,
    IN ULONG CursorX,
    IN ULONG CursorY,
    IN PUCHAR String,
    IN ULONG MaxLength
    );

EFI_STATUS
EfiGetVariable(
    IN CHAR16 *VariableName,
    IN EFI_GUID *VendorGuid,
    OUT UINT32 *Attributes OPTIONAL,
    IN OUT UINTN *DataSize,
    OUT VOID *Data
    );
    
EFI_STATUS
EfiSetVariable (
    IN CHAR16 *VariableName,
    IN EFI_GUID *VendorGuid,
    IN UINT32 Attributes,
    IN UINTN DataSize,
    IN VOID *Data
    );
    
EFI_STATUS
EfiGetNextVariableName (
    IN OUT UINTN *VariableNameSize,
    IN OUT CHAR16 *VariableName,
    IN OUT EFI_GUID *VendorGuid
    );

PVOID
FindSMBIOSTable(
    UCHAR   RequestedTableType
    );

VOID
EfiCheckFirmwareRevision(
    VOID
    );

#endif // _BLDRIA64_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\bldrx86.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bldrx86.h

Abstract:

    Contains definitions and prototypes specific to the x86 NTLDR.

Author:

    John Vert (jvert) 20-Dec-1993

Revision History:

--*/

#ifndef _BLDRX86_
#define _BLDRX86_

#include "bldr.h"

//
// Define specific ranges where parts of the system should be loaded
//
//
// X86 is limited to the first 512MB of physical address space
// We also try to pack kernel and HAL into a single 4MB page
//
#define _16MB ((16*1024*1024) >> PAGE_SHIFT)
#define BL_KERNEL_RANGE_LOW  (((BlVirtualBias) ? (12*1024*1024) : (4*1024*1024)) >> PAGE_SHIFT)
#define BL_KERNEL_RANGE_HIGH (((BlVirtualBias) ? (16*1024*1024) : (8*1024*1024)) >> PAGE_SHIFT)

//
// Specific range for the disk cache since this is allocated before the 
// kernel and HAL are loaded and we want to keep its 2MB out of the 4MB
// page we are trying to cram the kernel and HAL into.
//
#define BL_DISK_CACHE_RANGE_LOW   ((8*1024*1024) >> PAGE_SHIFT)
#define BL_DISK_CACHE_RANGE_HIGH  ((16*1024*1024) >> PAGE_SHIFT)

#define BL_DRIVER_RANGE_LOW  0
#define BL_DRIVER_RANGE_HIGH (512*1024*1024 >> PAGE_SHIFT)

#define BL_DECOMPRESS_RANGE_LOW  (0)
#define BL_DECOMPRESS_RANGE_HIGH (512*1024*1024 >> PAGE_SHIFT)

#define BL_XIPROM_RANGE_LOW   BlUsableBase
#define BL_XIPROM_RANGE_HIGH  (512*1024*1024 >> PAGE_SHIFT)

#define OLD_ALTERNATE (0xe1000000 - 64 * 1024 * 1024)

VOID
AEInitializeStall(
    VOID
    );

ARC_STATUS
AEInitializeIo(
    IN ULONG DriveId
    );

VOID
AEGetArcDiskInformation(
    VOID
    );

PVOID
FwAllocateHeap(
    IN ULONG Size
    );

VOID
MdShutoffFloppy(
    VOID
    );

PCHAR
BlSelectKernel(
    IN ULONG DriveId,
    IN PCHAR BootFile,
    OUT PCHAR *LoadOptions,
    IN BOOLEAN UseTimeOut
    );


BOOLEAN
BlDetectHardware(
    IN ULONG DriveId,
    IN PCHAR LoadOptions
    );

VOID
BlStartup(
    IN PCHAR PartitionName
    );

//
// Arc routines for supporting common VGA I/O routines
//
#define ARC_DISPLAY_CLEAR_ESCAPE "\033[2J"
#define ARC_DISPLAY_CLEAR()  { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, ARC_DISPLAY_CLEAR_ESCAPE, \
              sizeof(ARC_DISPLAY_CLEAR_ESCAPE) - 1, &LocalCount); \
     }

#define ARC_DISPLAY_CLEAR_TO_EOD() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[0J", sizeof("\033[0J") - 1, &LocalCount); \
}

#define ARC_DISPLAY_CLEAR_TO_EOL() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[0K", sizeof("\033[0K") - 1, &LocalCount); \
}

#define ARC_DISPLAY_ATTRIBUTES_OFF() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[0m", sizeof("\033[0m") - 1, &LocalCount); \
}

#define ARC_DISPLAY_INVERSE_VIDEO() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[7m", sizeof("\033[7m") - 1, &LocalCount); \
}

#define ARC_DISPLAY_SET_COLOR(c) { \
     ULONG LocalCount; \
     UCHAR LocalBuffer[40]; \
     sprintf(LocalBuffer, "\033[%sm", c); \
     ArcWrite(BlConsoleOutDeviceId, LocalBuffer, strlen(LocalBuffer), &LocalCount); \
}

#define ARC_DISPLAY_POSITION_CURSOR(x, y) { \
     ULONG LocalCount; \
     UCHAR LocalBuffer[40]; \
     sprintf(LocalBuffer, "\033[%d;%dH", y + 1, x + 1); \
     ArcWrite(BlConsoleOutDeviceId, LocalBuffer, strlen(LocalBuffer), &LocalCount); \
}

extern BOOLEAN BlTerminalConnected;
extern ULONG BlTerminalDeviceId;
extern ULONG BlTerminalDelay;


LOGICAL
BlTerminalAttached(
    IN ULONG TerminalDeviceId
    );


//
// Routine for checking if a character is the lead byt to a double-byte
//
BOOLEAN
GrIsDBCSLeadByte(
    IN UCHAR c
    );

VOID
UTF8Encode(
    USHORT  InputValue,
    PUCHAR UTF8Encoding
    );

VOID
GetDBCSUtf8Translation(
    PUCHAR InputChar,
    PUCHAR UTF8Encoding
    );


VOID
GetSBCSUtf8Translation(
    PUCHAR InputChar,
    PUCHAR UTF8Encoding
    );

ARC_STATUS
MempAllocDescriptor(
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    );

typedef struct {
    ULONG       ErrorFlag;
    ULONG       Key;
    ULONG       Size;
    struct {
        ULONG       BaseAddrLow;
        ULONG       BaseAddrHigh;
        ULONG       SizeLow;
        ULONG       SizeHigh;
        ULONG       MemoryType;
    } Descriptor;
} E820FRAME, *PE820FRAME;


//          E X T E R N A L   S E R V I C E S   T A B L E
//
// External Services Table - machine dependent services
// like reading a sector from the disk and finding out how
// much memory is installed are provided by a lower level
// module or a ROM BIOS. The EST provides entry points
// for the OS loader.
//

//**
// NOTE WELL
//      The offsets of entries in this structure MUST MATCH
//      the offsets of BOTH the ExportEntryTable in ....\startup\i386\sudata.asm
//      AND ...\startrom\i386\sudata.asm.  You must change all 3
//      locations together.
//**

typedef struct _EXTERNAL_SERVICES_TABLE {
    VOID (__cdecl *  RebootProcessor)(VOID);
    NTSTATUS (__cdecl * DiskIOSystem)(UCHAR,UCHAR,USHORT,USHORT,UCHAR,UCHAR,PUCHAR);
    ULONG (__cdecl * GetKey)(VOID);
    ULONG (__cdecl * GetCounter)(VOID);
    VOID (__cdecl * Reboot)(ULONG);
    VOID (__cdecl * DetectHardware)(ULONG, ULONG, PVOID, PULONG, PCHAR, ULONG);
    VOID (__cdecl * HardwareCursor)(ULONG,ULONG);
    VOID (__cdecl * GetDateTime)(PULONG,PULONG);
    VOID (__cdecl * ComPort)(LONG,ULONG,UCHAR);
    ULONG (__cdecl * GetStallCount)(VOID);
    VOID (__cdecl * InitializeDisplayForNt)(VOID);
    VOID (__cdecl * GetMemoryDescriptor)(P820FRAME);
    NTSTATUS (__cdecl * GetEddsSector)(UCHAR,ULONG,ULONG,USHORT,PUCHAR,UCHAR);
    NTSTATUS (__cdecl * GetElToritoStatus)(PUCHAR,UCHAR);
    BOOLEAN (__cdecl * GetExtendedInt13Params)(PUCHAR,UCHAR);
    USHORT (__cdecl * NetPcRomServices)(ULONG,PVOID);
    VOID (__cdecl * ApmAttemptReconnect)(VOID);
    ULONG (__cdecl * BiosRedirectService)(ULONG);
} EXTERNAL_SERVICES_TABLE, *PEXTERNAL_SERVICES_TABLE;
extern PEXTERNAL_SERVICES_TABLE ExternalServicesTable;

//**
// SEE NOTE AT TOP OF STRUCTURE
//**

//
// External Services Macros
//

#define REBOOT_PROCESSOR    (*ExternalServicesTable->RebootProcessor)
#define GET_SECTOR          (*ExternalServicesTable->DiskIOSystem)
#define RESET_DISK          (*ExternalServicesTable->DiskIOSystem)
#define BIOS_IO             (*ExternalServicesTable->DiskIOSystem)
#define GET_KEY             (*ExternalServicesTable->GetKey)
#define GET_COUNTER         (*ExternalServicesTable->GetCounter)
#define REBOOT              (*ExternalServicesTable->Reboot)
#define DETECT_HARDWARE     (*ExternalServicesTable->DetectHardware)
#define HW_CURSOR           (*ExternalServicesTable->HardwareCursor)
#define GET_DATETIME        (*ExternalServicesTable->GetDateTime)
#define COMPORT             (*ExternalServicesTable->ComPort)
#define GET_STALL_COUNT     (*ExternalServicesTable->GetStallCount)
#define SETUP_DISPLAY_FOR_NT (*ExternalServicesTable->InitializeDisplayForNt)
#define GET_MEMORY_DESCRIPTOR (*ExternalServicesTable->GetMemoryDescriptor)
#define GET_EDDS_SECTOR     (*ExternalServicesTable->GetEddsSector)
#define GET_ELTORITO_STATUS (*ExternalServicesTable->GetElToritoStatus)
#define GET_XINT13_PARAMS   (*ExternalServicesTable->GetExtendedInt13Params)
#define NETPC_ROM_SERVICES  (*ExternalServicesTable->NetPcRomServices)
#define APM_ATTEMPT_RECONNECT (*ExternalServicesTable->ApmAttemptReconnect)
#define BIOS_REDIRECT_SERVICE (*ExternalServicesTable->BiosRedirectService)

//
// Define special key input values
//
#define DOWN_ARROW  0x5000
#define UP_ARROW    0x4800
#define HOME_KEY    0x4700
#define END_KEY     0x4F00
#define LEFT_KEY    0x4B00
#define RIGHT_KEY   0x4D00
#define INS_KEY     0x5200
#define DEL_KEY     0x5300
#define BKSP_KEY    0x0E08
#define TAB_KEY     0x0009
#define BACKTAB_KEY 0x0F00
#define F1_KEY      0x3B00
#define F2_KEY      0x3C00
#define F3_KEY      0x3D00
#define F5_KEY      0x3F00
#define F6_KEY      0x4000
#define F7_KEY      0x4100
#define F8_KEY      0x4200
#define F10_KEY     0x4400
#define F11_KEY     0xD900
#define F12_KEY     0xDA00
#define ENTER_KEY   0x000D
#define ESCAPE_KEY  0x011B



//
// x86-specific video support
//
VOID
TextGetCursorPosition(
    OUT PULONG X,
    OUT PULONG Y
    );

VOID
TextSetCursorPosition(
    IN ULONG X,
    IN ULONG Y
    );

VOID
TextSetCurrentAttribute(
    IN UCHAR Attribute
    );

UCHAR
TextGetCurrentAttribute(
    VOID
    );

VOID
TextClearDisplay(
    VOID
    );

VOID
TextClearToEndOfDisplay(
    VOID
    );

VOID
TextClearFromStartOfLine(
    VOID
    );

VOID
TextClearToEndOfLine(
    VOID
    );

VOID
TextStringOut(
    IN PUCHAR String
    );

PUCHAR
TextCharOut(
    IN PUCHAR pc
    );

VOID
TextFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    );

VOID
TextGrInitialize(
    IN ULONG DiskId,
    OUT PULONG ImageLength
    );

VOID
TextGrTerminate(
    VOID
    );

#define BlPuts(str) TextStringOut(str)

ULONG
BlGetKey(
    VOID
    );

VOID
BlInputString(
    IN ULONG Prompt,
    IN ULONG CursorX,
    IN ULONG CursorY,
    IN PUCHAR String,
    IN ULONG MaxLength
    );

#endif // _BLDRX86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\blrange.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blrange.h

Abstract:

    This module declares ranges, rangelists and their methods. These
    can be used to keep track of cached ranges of a disk for instance.

Author:

    Cenk Ergan (cenke) 11-Jan-2000

Revision History:

--*/

#ifndef _BLRANGE_H
#define _BLRANGE_H

#include "bldr.h"

//
// Define range & range list data structures. 
//

//
// NOTE: BLCRANGE's Start is inclusive and End is exclusive. E.g.
// 200-400 contains 200th but does not contain 400th byte, apple, 
// meter etc. This allows a single subtraction to determine the 
// number of elements in the range.
//

//
// NOTE: BLCRANGE's Start should be less than or equal to its End.
//

//
// Representing ranges with start and end instead of start and length
// seems to simplify the code and remove a lot of addition and
// subtractions. We could maybe use a ULONG Length, which would save 4
// bytes per range, but lists make it hard to have thousands of ranges
// and even if you had 10 thousand ranges, you'd save only 40KB, which
// seemed to be insignificant to the cons above when I began changing
// the code to have Length instead of End. With both Start and End
// ULONGLONG more data can be represented by ranges, e.g. 64bit
// offsets [memory or disk] where 4GB Length may not be enough.
//

typedef struct _BLCRANGE
{
    ULONGLONG Start;
    ULONGLONG End;
} BLCRANGE, *PBLCRANGE;

typedef struct _BLCRANGE_ENTRY
{
    LIST_ENTRY Link;
    BLCRANGE Range;
    PVOID UserData;      // UserData field is not used by range functions.
    LIST_ENTRY UserLink; // UserLink field is not used by range functions.
} BLCRANGE_ENTRY, *PBLCRANGE_ENTRY;

//
// Define range entry merging routine type. This routine should
// perform the necessary operations to merge the user controlled /
// maintained Data field of the pSrcEntry to pDestEntry's Data
// field. It should not manipulate any other BLCRANGE_ENTRT fields. It
// should return FALSE if there was an error and it could not merge
// the two Data fields, TRUE otherwise. If it returns FALSE, it should
// undo its modifications to pDestEntry and pSrcEntry.
//

typedef 
BOOLEAN
(*PBLCRANGE_MERGE_ROUTINE) (
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry
    );

//
// Define range entry free'ing routine type. This routine should free
// all the resources & memory allocated for a range entry.
//

typedef
VOID
(*PBLCRANGE_FREE_ROUTINE) (
    PBLCRANGE_ENTRY pRangeEntry
    );

//
// BLCRANGE_LIST maintains a sorted list of non-overlapping range
// entries off its Head field.
//

typedef struct _BLCRANGE_LIST
{
    LIST_ENTRY Head;
    ULONG NumEntries;
    PBLCRANGE_MERGE_ROUTINE MergeRoutine;
    PBLCRANGE_FREE_ROUTINE FreeRoutine;
} BLCRANGE_LIST, *PBLCRANGE_LIST;

//
// Useful macros. Be mindful of expression reevaluation as with
// all macros.
//

#define BLRGMIN(a,b) (((a) <= (b)) ? (a) : (b))
#define BLRGMAX(a,b) (((a) >= (b)) ? (a) : (b))

//
// Range function prototypes. See ntos\boot\lib\blrange.c for comments
// and implementation.
//

VOID
BlRangeListInitialize (
    PBLCRANGE_LIST pRangeList,
    OPTIONAL PBLCRANGE_MERGE_ROUTINE pMergeRoutine,
    OPTIONAL PBLCRANGE_FREE_ROUTINE pFreeRoutine
    );

BOOLEAN
BlRangeListAddRange (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE_ENTRY pRangeEntry
    );

BOOLEAN
BlRangeListFindOverlaps (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE pRange,
    PBLCRANGE_ENTRY *pOverlapsBuffer,
    ULONG OverlapsBufferSize,
    OUT ULONG *pNumOverlaps
    );

BOOLEAN
BlRangeListFindDistinctRanges (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE pRange,
    PBLCRANGE pDistinctRanges,
    ULONG BufferSize,
    OUT ULONG *pNumRanges
    );

VOID
BlRangeListRemoveRange (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE pRange
);

VOID
BlRangeListRemoveAllRanges (
    PBLCRANGE_LIST pRangeList
);

BOOLEAN
BlRangeListMergeRangeEntries (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry
    );

BOOLEAN
BlRangeEntryMerge (
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry,
    OPTIONAL PBLCRANGE_MERGE_ROUTINE pMergeRoutine
    );

#endif // _BLRANGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\bldr.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    bldr.h

Abstract:

    This module is the header file for the NT boot loader.

Author:

    David N. Cutler (davec) 10-May-1991

Revision History:

--*/

#ifndef _BLDR_
#define _BLDR_

#include "ntos.h"
#include "arccodes.h"
#include "setupblk.h"
#include "hdlsblk.h"
#include "remboot.h"
#include "oscpkt.h"
#include "bootstatus.h"

#include <TCHAR.H>

#ifndef _PTUCHAR
typedef _TUCHAR  *_PTUCHAR;
#endif

//
// DoApmAttemptReconnect does nothing on non x86 machines.
// On x86 machines, it attempts an APM reconnect, and lives in initx86.c
//
#if defined(_X86_)
VOID DoApmAttemptReconnect();
#else
#define DoApmAttemptReconnect()
#endif

//
// The Alpha OS Loader and Setup Loader run in the environment of the host
// firmware. This environment is restricted to a 32-bit address space and
// cannot result in pointer significance greater than 32-bits. The 64-bit
// OS Loader, however, is compiled using 64-bit pointers for non-firmware
// interfaces and constructs data structures used to pass information to the
// NT kernel using 64-bit pointers. This leads to a large number of false
// pointer truncation warnings. Therefore, pointer truncation warnings are
// turned off in the OS and Setup Loaders for 64-bit Alpha systems.
//

#if defined(_AXP64_)

#pragma warning(4:4244)                 // turn off pointer trunction

#endif

//
// Define boot file id.
//

#define BOOT_FILEID 2                   // boot partition file id

//
// Define image type.
//

#if defined(_X86_)

#define TARGET_IMAGE IMAGE_FILE_MACHINE_I386

#endif

#if defined(_ALPHA_)

#if defined(_AXP64_)

#define TARGET_IMAGE IMAGE_FILE_MACHINE_AXP64

#else

#define TARGET_IMAGE IMAGE_FILE_MACHINE_ALPHA

#endif

#endif

#if defined(_IA64_)

#define TARGET_IMAGE IMAGE_FILE_MACHINE_IA64

#endif

//
// Make headless defines
//

#if defined(_X86_)

#define BlIsTerminalConnected() BlTerminalConnected


#endif

#if defined(_ALPHA_)

#if defined(_AXP64_)

#define BlIsTerminalConnected() FALSE

#else

#define BlIsTerminalConnected() FALSE

#endif

#endif

#if defined(_IA64_)

#define BlIsTerminalConnected() BlTerminalConnected

#endif

BOOLEAN
BlTerminalHandleLoaderFailure(
    VOID
    );




//
// Define size of sector.
//

#define SECTOR_SIZE 512                 // size of disk sector
#define SECTOR_SHIFT 9                  // sector shift value

#define STALE_GPT_PARTITION_ENTRY   0xEE    // The stale MBR partition entry for GPT disks

//
// Define heap allocation block granularity.
//

#define BL_GRANULARITY 8

//
// Define number of entries in file table.
//

#define BL_FILE_TABLE_SIZE 48

//
// Define size of memory allocation table.
//

#define BL_MEMORY_TABLE_SIZE 16

//
// Define number of loader heap and stack pages.
//

#define BL_HEAP_PAGES 16
#define BL_STACK_PAGES 8

//
// Define buffer alignment macro.
//

#define ALIGN_BUFFER(Buffer) (PVOID) \
        ((((ULONG_PTR)(Buffer) + BlDcacheFillSize - 1)) & (~((ULONG_PTR)BlDcacheFillSize - 1)))

#define ALIGN_BUFFER_WITH_SIZE(Buffer, Size) (PVOID) \
        ((((ULONG_PTR)(Buffer) + (Size) - 1)) & (~((ULONG_PTR)(Size) - 1)))



//
// Useful defines for COM ports.
//
#define COM1_PORT (0x3f8)
#define COM2_PORT (0x2f8)
#define COM3_PORT (0x3e8)
#define COM4_PORT (0x2e8)

#define BD_150      150
#define BD_300      300
#define BD_600      600
#define BD_1200     1200
#define BD_2400     2400
#define BD_4800     4800
#define BD_9600     9600
#define BD_14400    14400
#define BD_19200    19200
#define BD_57600    57600
#define BD_115200   115200




typedef
ARC_STATUS
(*PRENAME_ROUTINE)(
    IN ULONG FileId,
    IN CHAR * FIRMWARE_PTR NewName
    );

typedef struct _BOOTFS_INFO {
    WCHAR * FIRMWARE_PTR DriverName;
} BOOTFS_INFO, * FIRMWARE_PTR PBOOTFS_INFO;


//
// Device entry table structure.
//

typedef struct _BL_DEVICE_ENTRY_TABLE {
    PARC_CLOSE_ROUTINE Close;
    PARC_MOUNT_ROUTINE Mount;
    PARC_OPEN_ROUTINE Open;
    PARC_READ_ROUTINE Read;
    PARC_READ_STATUS_ROUTINE GetReadStatus;
    PARC_SEEK_ROUTINE Seek;
    PARC_WRITE_ROUTINE Write;
    PARC_GET_FILE_INFO_ROUTINE GetFileInformation;
    PARC_SET_FILE_INFO_ROUTINE SetFileInformation;
    PRENAME_ROUTINE Rename;
    PARC_GET_DIRECTORY_ENTRY_ROUTINE GetDirectoryEntry;
    PBOOTFS_INFO BootFsInfo;
} BL_DEVICE_ENTRY_TABLE, *PBL_DEVICE_ENTRY_TABLE;

//
// Many functions in the boot loader take a set of paths. Every path is divided
// into two parts, a "Source" and a "PathOffset".
//
// A source is described by the PATH_SOURCE structure. This structure contains
// three parts, the device handle to use for I/O, the ARC name of the device,
// and the offset off the root for that ARC device.
//
// The PATH_SET structures encapsulates up to three different sources. The
// field AliasName optionally points to a PE namespace description of the
// sources (eg \SystemRoot).
//
// Finally, the biggest PATH_SET structure (FULL_PATH_SET) is limited to
// MAX_PATH_COUNT sources so that those using this structure can manipulate
// local stack copies.
//
// Putting it all together, during a last known good boot the PATH_SET
// describing \Winnt\System32 would be:
//      PathCount = 3
//      AliasName = \SystemRoot\
//      PathOffset = System32\
//          Source[0].DirectoryPath = \Winnt\LastGood.tmp
//          Source[1].DirectoryPath = \Winnt\LastGood
//          Source[2].DirectoryPath = \Winnt\
//
#define MAX_PATH_SOURCES    3

typedef struct {

    ULONG   DeviceId;
    LPCSTR  DeviceName;
    PSTR    DirectoryPath; // Should have trailing '\'

} PATH_SOURCE, *PPATH_SOURCE;

typedef struct {

    ULONG       PathCount;
    LPCSTR      AliasName;
    CHAR        PathOffset[256];  // Should have trailing '\' if non-empty
    PATH_SOURCE Source[0];

} SPARSE_PATH_SET, *PSPARSE_PATH_SET;

typedef struct {

    ULONG       PathCount;
    LPCSTR      AliasName;
    CHAR        PathOffset[256];  // Should have trailing '\' if non-empty
    PATH_SOURCE Source[MAX_PATH_SOURCES];

} FULL_PATH_SET, *PFULL_PATH_SET;

//
// A PPATH_SET points to a path set with an undetermined count of paths. We
// make this an alias of PFULL_PATH_SET so as to cut down on casting.
//
typedef PFULL_PATH_SET PPATH_SET;


//
// Define main entrypoint.
//

ARC_STATUS
BlOsLoader (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Envp
    );

ARC_STATUS
BlInitStdio (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv
    );


extern UCHAR OsLoaderVersion[];
extern WCHAR OsLoaderVersionW[];
extern UCHAR OsLoaderName[];
extern CHAR KernelFileName[8+1+3+1];
extern CHAR HalFileName[8+1+3+1];

//
// Define boot debugger function prototype.
//

VOID
BdInitDebugger (
    IN PCHAR LoaderName,
    IN PVOID LoaderBase,
    IN PCHAR Options
    );

extern LOGICAL BdDebuggerEnabled;

VOID
BdInitializeTraps (
    VOID
    );

ULONG
BdComPortNumber (
    VOID
    );

ARC_STATUS
BdPullRemoteFile(
    IN PCHAR FileName,
    IN ULONG FileAttributes,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN ULONG FileId
    );



//
// Define com port I/O prototypes.
//
LOGICAL
BlPortInitialize(
    IN ULONG BaudRate,
    IN ULONG PortNumber,
    IN PUCHAR PortAddress OPTIONAL,
    IN BOOLEAN ReInitialize,
    OUT PULONG BlFileId
    );

VOID
BlInitializeHeadlessPort(
    VOID
    );

ULONG
BlPortGetByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    );

VOID
BlPortPutByte (
    IN ULONG BlFileId,
    IN UCHAR Output
    );

ULONG
BlPortPollByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    );

ULONG
BlPortPollOnly (
    IN ULONG BlFileId
    );

VOID
BlSetHeadlessRestartBlock(
    IN PTFTP_RESTART_BLOCK RestartBlock
    );

VOID
BlGetHeadlessRestartBlock(
    IN PTFTP_RESTART_BLOCK RestartBlock,
    IN BOOLEAN RestartBlockValid
    );

LOGICAL
BlRetrieveBIOSRedirectionInformation();

extern HEADLESS_LOADER_BLOCK LoaderRedirectionInformation;


//
// Define file I/O prototypes.
//

ARC_STATUS
BlIoInitialize (
    VOID
    );

ARC_STATUS
BlClose (
    IN ULONG FileId
    );

PBOOTFS_INFO
BlGetFsInfo(
    IN ULONG DeviceId
    );

ARC_STATUS
BlMount (
    IN PCHAR MountPath,
    IN MOUNT_OPERATION Operation
    );

ARC_STATUS
BlOpen (
    IN ULONG DeviceId,
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BlRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BlReadAtOffset(
    IN ULONG FileId,
    IN ULONG Offset,
    IN ULONG Length,
    OUT PVOID Data
    );

ARC_STATUS
BlRename (
    IN ULONG FileId,
    IN PCHAR NewName
    );

ARC_STATUS
BlGetReadStatus (
    IN ULONG FileId
    );

ARC_STATUS
BlSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
BlWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BlGetFileInformation (
    IN ULONG FileId,
    IN PFILE_INFORMATION FileInformation
    );

ARC_STATUS
BlSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

#ifdef DBLSPACE_LEGAL
VOID
BlSetAutoDoubleSpace (
    IN BOOLEAN Enable
    );
#endif

//
// Define image manipulation routine prototyupes.
//
#define BlLoadImage(_id_,_memtype_,_file_,_imagetype_,_base_) \
        BlLoadImageEx(_id_,_memtype_,_file_,_imagetype_,0,0,_base_)

ARC_STATUS
BlLoadImageEx(
    IN ULONG DeviceId,
    IN TYPE_OF_MEMORY MemoryType,
    IN PCHAR LoadFile,
    IN USHORT ImageType,
    IN OPTIONAL ULONG PreferredAlignment,
    IN OPTIONAL ULONG PreferredBasePage,
    OUT PVOID *ImageBase
    );

ARC_STATUS
BlLoadDeviceDriver(
    IN PPATH_SET               PathSet,
    IN PCHAR                   DriverName,
    IN PTCHAR                  DriverDescription OPTIONAL,
    IN ULONG                   DriverFlags,
    OUT PKLDR_DATA_TABLE_ENTRY *DriverDataTableEntry
    );

ARC_STATUS
BlLoadNLSData(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PUNICODE_STRING AnsiCodepage,
    IN PUNICODE_STRING OemCodepage,
    IN PUNICODE_STRING LanguageTable,
    OUT PCHAR BadFileName
    );

ARC_STATUS
BlLoadOemHalFont(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PUNICODE_STRING OemHalFont,
    OUT PCHAR BadFileName
    );



PVOID
BlImageNtHeader (
    IN PVOID Base
    );

ARC_STATUS
BlSetupForNt(
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    );

ARC_STATUS
BlScanImportDescriptorTable (
    IN PPATH_SET                PathSet,
    IN PKLDR_DATA_TABLE_ENTRY    ScanEntry,
    IN TYPE_OF_MEMORY           MemoryType
    );

ARC_STATUS
BlScanOsloaderBoundImportTable (
    IN PKLDR_DATA_TABLE_ENTRY ScanEntry
    );

#if defined(_ALPHA_)

ARC_STATUS
BlAllocateAnyMemory (
    IN TYPE_OF_MEMORY MemoryType,
    IN ULONG BasePage,
    IN ULONG PageCount,
    OUT PULONG ActualBase
    );

ARC_STATUS
BlGeneratePalName(
    IN PCHAR PalFIleName
    );

ARC_STATUS
BlLoadPal(
    IN ULONG DeviceId,
    IN TYPE_OF_MEMORY MemoryType,
    IN PCHAR LoadPath,
    IN USHORT ImageType,
    OUT PVOID *ImageBase,
    IN PCHAR LoadDevice
    );

VOID
BlSetGranularityHints (
    IN PHARDWARE_PTE PageTableArray,
    IN ULONG PageTableCount
    );

#endif

#if defined(_PPC_)

ARC_STATUS
BlPpcInitialize (
    VOID
    );

#endif // defined(_PPC)

//
// Define configuration allocation prototypes.
//


ARC_STATUS
BlConfigurationInitialize (
    IN PCONFIGURATION_COMPONENT Parent,
    IN PCONFIGURATION_COMPONENT_DATA ParentEntry
    );

//
// define routines for searching the ARC firmware tree
//
typedef
BOOLEAN
(*PNODE_CALLBACK)(
    IN PCONFIGURATION_COMPONENT_DATA FoundComponent
    );

BOOLEAN
BlSearchConfigTree(
    IN PCONFIGURATION_COMPONENT_DATA Node,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN ULONG Key,
    IN PNODE_CALLBACK CallbackRoutine
    );

VOID
BlGetPathnameFromComponent(
    IN PCONFIGURATION_COMPONENT_DATA Component,
    OUT PCHAR ArcName
    );

BOOLEAN
BlGetPathMnemonicKey(
    IN PCHAR OpenPath,
    IN PCHAR Mnemonic,
    IN PULONG Key
    );

ARC_STATUS
BlGetArcDiskInformation(
    IN BOOLEAN XInt13Support
    );

BOOLEAN
BlReadSignature(
    IN PCHAR DiskName,
    IN BOOLEAN IsCdRom
    );

BOOLEAN
BlGetDiskSignature(
    IN PCHAR Name,
    IN BOOLEAN IsCdRom,
    PARC_DISK_SIGNATURE Signature
    );

#if defined(REMOTE_BOOT) 
ARC_STATUS
BlCheckMachineReplacement (
    IN PCHAR SystemDevice,
    IN ULONG SystemDeviceId,
    IN ULONGLONG NetRebootParameter,
    IN PUCHAR OsLoader
    );

#endif

//
// Define memory allocation prototypes.
//

extern ULONG BlUsableBase;
extern ULONG BlUsableLimit;

typedef enum _ALLOCATION_POLICY {
    BlAllocateLowestFit,
    BlAllocateBestFit,
    BlAllocateHighestFit
} ALLOCATION_POLICY, *PALLOCATION_POLICY;

extern ALLOCATION_POLICY BlMemoryAllocationPolicy;
extern ALLOCATION_POLICY BlHeapAllocationPolicy;

VOID
BlSetAllocationPolicy (
    IN ALLOCATION_POLICY MemoryAllocationPolicy,
    IN ALLOCATION_POLICY HeapAllocationPolicy
    );

ARC_STATUS
BlMemoryInitialize (
    VOID
    );

ARC_STATUS
BlAllocateDataTableEntry (
    IN PCHAR BaseDllName,
    IN PCHAR FullDllName,
    IN PVOID ImageHeader,
    OUT PKLDR_DATA_TABLE_ENTRY *Entry
    );

#define BlAllocateDescriptor(_MemoryType, _BasePage, _PageCount, _ActualBase)   \
            BlAllocateAlignedDescriptor((_MemoryType),                          \
                                        (_BasePage),                            \
                                        (_PageCount),                           \
                                        1,                                      \
                                        (_ActualBase))

#if defined (_X86_)
#define BlpCheckMapping(_page,_npages) MempCheckMapping (_page,_npages)
#else
#define BlpCheckMapping(_page,_npages) ESUCCESS
#endif

ARC_STATUS
BlAllocateAlignedDescriptor (
    IN TYPE_OF_MEMORY MemoryType,
    IN ULONG BasePage,
    IN ULONG PageCount,
    IN ULONG Alignment,
    OUT PULONG ActualBase
    );

ARC_STATUS
BlFreeDescriptor (
    IN ULONG BasePage
    );

PVOID
BlAllocateHeapAligned (
    IN ULONG Size
    );

PVOID
BlAllocateHeap (
    IN ULONG Size
    );

VOID
BlStartConfigPrompt(
    VOID
    );

BOOLEAN
BlEndConfigPrompt(
    VOID
    );

BOOLEAN
BlCheckForLoadedDll (
    IN PCHAR DllName,
    OUT PKLDR_DATA_TABLE_ENTRY *FoundEntry
    );

PMEMORY_ALLOCATION_DESCRIPTOR
BlFindMemoryDescriptor(
    IN ULONG BasePage
    );

ARC_STATUS
BlInitResources(
    IN PCHAR StartCommand
    );

PTCHAR
BlFindMessage(
    IN ULONG Id
    );

//
// Define debug function to write on the display console.
//

VOID
BlPrint(
    PTCHAR cp,
    ...
    );

#if DBG
#define DBGTRACE   BlPrint
#else
#define DBGTRACE
#endif


ARC_STATUS
BlGenerateDescriptor (
    IN PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor,
    IN MEMORY_TYPE MemoryType,
    IN ULONG BasePage,
    IN ULONG PageCount
    );

VOID
BlInsertDescriptor (
    IN PMEMORY_ALLOCATION_DESCRIPTOR NewDescriptor
    );

#if defined (_X86_)


ARC_STATUS
MempCheckMapping (
    ULONG StartPage,
    ULONG NumberPages
    );

ARC_STATUS
MempRemoveMapping (
    ULONG StartPage,
    ULONG NumberPages
    );

#endif

#define BlRemoveDescriptor(_md_) RemoveEntryList(&(_md_)->ListEntry)



ARC_STATUS
BlGenerateDeviceNames (
    IN PCHAR ArcDeviceName,
    OUT PCHAR ArcCanonicalName,
    OUT OPTIONAL PCHAR NtDevicePrefix
    );

PCHAR
BlGetArgumentValue (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv,
    IN PCHAR ArgumentName
    );

PCHAR
BlSetArgumentValue (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv,
    IN PCHAR ArgumentName,
    IN PCHAR NewValue
    );

//
// Defines for doing console I/O
//
#define ASCII_CR 0x0d
#define ASCII_LF 0x0a
#define ESC 0x1B
#define SGR_INVERSE 7
#define SGR_INTENSE 1
#define SGR_NORMAL 0

extern ULONG ScreenWidth;
extern ULONG ScreenHeight;

//
// Define I/O prototypes.
//

VOID
BlClearScreen(
    VOID
    );

VOID
BlClearToEndOfScreen(
    VOID
    );

VOID
BlClearToEndOfLine(
    VOID
    );

VOID
BlPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    );

VOID
BlSetInverseMode(
    IN BOOLEAN InverseOn
    );

VOID
BlOutputLoadMessage (
    IN PCHAR DeviceName,
    IN PCHAR FileName,
    IN PTCHAR FileDescription OPTIONAL
    );

ULONG
BlCountLines(
    IN PTCHAR Lines
    );

//
// advanced boot menu prototypes
//

LONG
BlDoAdvancedBoot(
    IN ULONG MenuTitleId,
    IN LONG DefaultBootOption,
    IN BOOLEAN AutoAdvancedBoot,
    IN UCHAR Timeout
    );

PTSTR
BlGetAdvancedBootDisplayString(
    LONG BootOption
    );

PSTR
BlGetAdvancedBootLoadOptions(
    LONG BootOption
    );

VOID
BlDoAdvancedBootLoadProcessing(
    LONG BootOption
    );

ULONG
BlGetAdvancedBootOption(
    VOID
    );


//
// Define file structure recognition prototypes.
//

PBL_DEVICE_ENTRY_TABLE
IsCdfsFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    );

#ifdef DBLSPACE_LEGAL
PBL_DEVICE_ENTRY_TABLE
IsDblsFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    );
#endif

PBL_DEVICE_ENTRY_TABLE
IsFatFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    );

PBL_DEVICE_ENTRY_TABLE
IsHpfsFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    );

PBL_DEVICE_ENTRY_TABLE
IsNtfsFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    );

#if defined(ELTORITO)
PBL_DEVICE_ENTRY_TABLE
IsEtfsFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    );
#endif

PBL_DEVICE_ENTRY_TABLE
IsNetFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    );

//
// Define registry prototypes
//

ARC_STATUS
BlLoadSystemHive(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PCHAR HiveName
    );

ARC_STATUS
BlLoadSystemHiveLog(
    IN  ULONG       DeviceId,
    IN  PCHAR       DeviceName,
    IN  PCHAR       DirectoryPath,
    IN  PCHAR       HiveName,
    OUT PULONG_PTR  LogData
    );

ARC_STATUS
BlLoadAndScanSystemHive(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PWSTR BootFileSystem,
    IN OUT BOOLEAN *LastKnownGoodBoot,
    OUT BOOLEAN *ServerHive,
    OUT PCHAR BadFileName
    );

ARC_STATUS
BlLoadAndInitSystemHive(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PCHAR HiveName,
    IN BOOLEAN IsAlternate,
    OUT PBOOLEAN RestartSetup,
    OUT PBOOLEAN LogPresent
    );

ARC_STATUS
BlLoadBootDrivers(
    IN  PPATH_SET   DefaultPathSet,
    IN  PLIST_ENTRY BootDriverListHead,
    OUT PCHAR       BadFileName
    );

PTCHAR
BlScanRegistry(
    IN PWSTR BootFileSystemPath,
    IN OUT BOOLEAN *LastKnownGoodBoot,
    OUT PLIST_ENTRY BootDriverListHead,
    OUT PUNICODE_STRING AnsiCodepage,
    OUT PUNICODE_STRING OemCodepage,
    OUT PUNICODE_STRING LanguageTable,
    OUT PUNICODE_STRING OemHalFont,
#ifdef _WANT_MACHINE_IDENTIFICATION
    OUT PUNICODE_STRING Biosinfo,
#endif
    OUT PSETUP_LOADER_BLOCK SetupLoaderBlock,
    OUT BOOLEAN *ServerHive
    );

ARC_STATUS
BlAddToBootDriverList(
    IN PLIST_ENTRY BootDriverListHead,
    IN PWSTR DriverName,
    IN PWSTR Name,
    IN PWSTR Group,
    IN ULONG Tag,
    IN ULONG ErrorControl,
    IN BOOLEAN InsertAtHead
    );

//
// Define hibernation prototypes
//

ULONG
BlHiberRestore (
    IN ULONG DriveId,
    OUT OPTIONAL PCHAR *BadLinkName
    );

VOID
HbAllocatePtes (
    IN ULONG NumberPages,
    OUT PVOID *PteAddress,
    OUT PVOID *MappedAddress
    );

VOID
HbInitRemap (
    PPFN_NUMBER FreeList
    );

PVOID
HbMapPte (
    IN ULONG        PteToMap,
    IN PFN_NUMBER   Page
    );

PVOID
HbNextSharedPage (
    IN ULONG        PteToMap,
    IN PFN_NUMBER   RealPage
    );

VOID
HbSetPte (
    IN PVOID Va,
    IN PHARDWARE_PTE Pte,
    IN ULONG Index,
    IN ULONG PageNumber
    );

ULONG
HbPageDisposition (
    IN PFN_NUMBER Page
    );

#define HbPageNotInUse          0
#define HbPageInUseByLoader     1
#define HbPageInvalid           2


VOID
HiberSetupForWakeDispatch (
    VOID
    );

typedef
VOID
(*PHIBER_WAKE_DISPATCH)(
    VOID
    );


//
// PTEs reserved for hiberfile (one set used while in
// the loader, and another set provided in the kernels
// memory image)
//

#define PTE_SOURCE              0   // Attention! These defines and
#define PTE_DEST                1   // equates in ntos\boot\lib\i386\wakea.asm
#define PTE_MAP_PAGE            2   // must be the same !!!
#define PTE_REMAP_PAGE          3
#define PTE_HIBER_CONTEXT       4
#define PTE_TRANSFER_PDE        5
#define PTE_WAKE_PTE            6
#define PTE_DISPATCHER_START    7
#define PTE_DISPATCHER_END      8
#define PTE_XPRESS_DEST_FIRST   9
#define PTE_XPRESS_DEST_LAST    (PTE_XPRESS_DEST_FIRST + XPRESS_MAX_PAGES)


// Attention: should be the same as POP_MAX_MDL_SIZE in ntos\po\pop.h !!!
#define HIBER_PTES              (16 + XPRESS_MAX_PAGES)

extern PUCHAR HiberBuffer;
extern PVOID HiberPtes;
extern PUCHAR HiberVa;
extern PVOID HiberIdentityVa;
extern ULONG HiberPageFrames[HIBER_PTES];


//
// Define routines for secrets.
//

#define SECPKG_CRED_OWF_PASSWORD  0x00000010

#if defined(REMOTE_BOOT)
ARC_STATUS
BlOpenRawDisk(
    PULONG FileId
    );

ARC_STATUS
BlCloseRawDisk(
    ULONG FileId
    );

ARC_STATUS
BlCheckForFreeSectors (
    ULONG FileId
    );

ARC_STATUS
BlReadSecret(
    ULONG FileId,
    PRI_SECRET Secret
    );

ARC_STATUS
BlWriteSecret(
    ULONG FileId,
    PRI_SECRET Secret
    );
#endif // defined(REMOTE_BOOT)

VOID
BlInitializeSecret(
    IN PUCHAR Domain,
    IN PUCHAR User,
    IN PUCHAR LmOwfPassword1,
    IN PUCHAR NtOwfPassword1,
#if defined(REMOTE_BOOT)
    IN PUCHAR LmOwfPassword2 OPTIONAL,
    IN PUCHAR NtOwfPassword2 OPTIONAL,
#endif // defined(REMOTE_BOOT)
    IN PUCHAR Sid,
    IN OUT PRI_SECRET Secret
    );

#if defined(REMOTE_BOOT_SECURITY)
VOID
BlParseSecret(
    IN OUT PUCHAR Domain,
    IN OUT PUCHAR User,
    IN OUT PUCHAR LmOwfPassword1,
    IN OUT PUCHAR NtOwfPassword1,
    IN OUT PUCHAR LmOwfPassword2,
    IN OUT PUCHAR NtOwfPassword2,
    IN OUT PUCHAR Sid,
    IN PRI_SECRET Secret
    );
#endif // defined(REMOTE_BOOT_SECURITY)

VOID
BlOwfPassword(
    IN PUCHAR Password,
    IN PUNICODE_STRING UnicodePassword,
    IN OUT PUCHAR LmOwfPassword,
    IN OUT PUCHAR NtOwfPassword
    );


//
// Define external references.
//

extern ULONG BlConsoleOutDeviceId;
extern ULONG BlConsoleInDeviceId;
extern ULONG BlDcacheFillSize;
extern ULONG_PTR BlHeapFree;
extern ULONG_PTR BlHeapLimit;
extern PLOADER_PARAMETER_BLOCK BlLoaderBlock;
extern ULONG DbcsLangId;
extern BOOLEAN BlRebootSystem;
extern ULONG BlVirtualBias;
extern BOOLEAN BlBootingFromNet;
extern BOOLEAN BlUsePae;
extern BOOLEAN BlOldKernel;
extern BOOLEAN BlKernelChecked;
extern BOOLEAN BlRestoring;

#if defined(_ALPHA_) || defined(_IA64_)

extern ULONG HiberNoMappings;
extern ULONG HiberFirstRemap;
extern ULONG HiberLastRemap;
extern BOOLEAN HiberOutOfRemap;
extern BOOLEAN HiberIoError;

#endif
//
// Special linker-defined symbols.  osloader_EXPORTS is the RVA of the
// export table in the osloader.exe image.
// header is the base address of the osloader image.
//
// This allows the OsLoader to export entry points for SCSI miniport drivers.
//

#if defined(_X86_)

extern ULONG OsLoaderBase;
extern ULONG OsLoaderExports;

#endif

#if defined(_IA64_)

extern LONG_PTR OsLoaderBase;
extern LONG_PTR OsLoaderExports;

#endif

//
// Routine to get graphics characters.
//

typedef enum {
    GraphicsCharDoubleRightDoubleDown = 0,
    GraphicsCharDoubleLeftDoubleDown,
    GraphicsCharDoubleRightDoubleUp,
    GraphicsCharDoubleLeftDoubleUp,
    GraphicsCharDoubleVertical,
    GraphicsCharDoubleHorizontal,
#ifdef EFI
    GraphicsCharFullBlock,
    GraphicsCharLightShade,
#endif
    GraphicsCharMax
} GraphicsChar;

_TUCHAR
GetGraphicsChar(
    IN GraphicsChar WhichOne
    );

_TUCHAR
TextGetGraphicsCharacter(
    IN GraphicsChar WhichOne
    );

//
// Control sequence introducer.
//
// On x86 machines the loaders support dbcs and so using
// 0x9b for output is no good (that value is a dbcs lead byte
// in several codepages). Escape-leftbracket is a synonym for CSI
// in the emulated ARC console on x86 (and on many ARC machines too
// but since we can't be sure all the machines out there support
// this we use the old-style csi on non-x86).
//
// We ignore this issue for characters read from the ARC console
// since we don't ask for any text to be typed in, just arrow keys,
// escape, F#, enter, etc.
//

#define ASCI_CSI_IN     0x9b
#if defined(_X86_) || defined(_IA64_)
#define ASCI_CSI_OUT    TEXT("\033[")     // escape-leftbracket
#else
#define ASCI_CSI_OUT    TEXT("\233")      // 0x9b
#endif

//
// Define OS/2 executable resource information structure.
//

#define FONT_DIRECTORY 0x8007
#define FONT_RESOURCE 0x8008

typedef struct _RESOURCE_TYPE_INFORMATION {
    USHORT Ident;
    USHORT Number;
    LONG Proc;
} RESOURCE_TYPE_INFORMATION, *PRESOURCE_TYPE_INFORMATION;

//
// Define OS/2 executable resource name information structure.
//

typedef struct _RESOURCE_NAME_INFORMATION {
    USHORT Offset;
    USHORT Length;
    USHORT Flags;
    USHORT Ident;
    USHORT Handle;
    USHORT Usage;
} RESOURCE_NAME_INFORMATION, *PRESOURCE_NAME_INFORMATION;

//
// Support for reading compressed files directly (single-file MS-ZIP cabinets)
//
VOID
DecompEnableDecompression(
    IN BOOLEAN Enable
    );

ULONG
DecompPrepareToReadCompressedFile(
    IN LPCSTR Filename,
    IN ULONG  FileId
    );

BOOLEAN
DecompGenerateCompressedName(
    IN  LPCSTR Filename,
    OUT LPSTR  CompressedName
    );

//
// Define debug logging macros and functions.
//

#if !DBG && !BLLOGENABLED

#define BlLogInitialize(_x_)
#define BlLogTerminate()
#define BlLog(_x_)
#define BlLogArcDescriptors(_x_)
#define BlLogMemoryDescriptors(_x_)
#define BlLogWaitForKeystroke()

#else

VOID
BlLogInitialize (
    IN ULONG LogfileDeviceId
    );

VOID
BlLogTerminate (
    VOID
    );

#define BlLog(_x_) BlLogPrint _x_

#define LOG_DISPLAY     0x0001
#define LOG_LOGFILE     0x0002
#define LOG_DEBUGGER    0x0004
#define LOG_WAIT        0x8000
#define LOG_ALL         (LOG_DISPLAY | LOG_LOGFILE | LOG_DEBUGGER)
#define LOG_ALL_W       (LOG_ALL | LOG_WAIT)

VOID
BlLogPrint (
    ULONG Targets,
    PCHAR Format,
    ...
    );

VOID
BlLogArcDescriptors (
    ULONG Targets
    );

VOID
BlLogMemoryDescriptors (
    ULONG Targets
    );

VOID
BlLogWaitForKeystroke (
    VOID
    );

#endif // DBG

VOID
BlWaitForReboot (
    VOID
    );

//
// Machine identification related functions.
//

#ifdef _WANT_MACHINE_IDENTIFICATION

#define BlLoadBiosinfoInf(id,n,d,f,i,is,bn) BlLoadFileImage(id,n,d,f,LoaderRegistryData,i,is,bn)

#endif

#define BlLoadDrvDB(id,n,d,f,i,is,bn) BlLoadFileImage(id,n,d,f,LoaderRegistryData,i,is,bn)

ARC_STATUS
BlLoadFileImage(
    IN  ULONG           DeviceId,
    IN  PCHAR           DeviceName,
    IN  PCHAR           Directory,
    IN  PUNICODE_STRING FileName,
    IN  TYPE_OF_MEMORY  MemoryType,
    OUT PVOID           *Image,
    OUT PULONG          ImageSize,
    OUT PCHAR           BadFileName
    );

#if defined(_X86_)
BOOLEAN
BlFindDiskSignature(
    IN PCHAR DiskName,
    IN PARC_DISK_SIGNATURE Signature
    );

VOID
AETerminateIo(
    VOID
    );

BOOLEAN
BlDetectLegacyFreeBios(
    VOID
    );

#endif

//
//
// N.B. We can speed up the boot time, by not
// querying the device for all the possible file systems
// for every open call. This saves approximately 30 secs
// on CD-ROM / DVD-ROM boot time. To disable this feature
// just undef CACHE_DEVINFO below
//
//
#define CACHE_DEVINFO  1

#ifdef CACHE_DEVINFO

//
// NB: make sure that the arc close now invalidates the
// device to filesystem cache entry
//
#ifdef ArcClose

ARC_STATUS
ArcCacheClose(
    IN ULONG DeviceId
    );

//
// Redefine the arc close
//
#undef ArcClose
#define ArcClose(_x) ArcCacheClose(_x)


//
// File system cache clearing hook
//
typedef
VOID
(*PARC_DEVICE_CLOSE_NOTIFICATION) (
    IN ULONG DeviceId
    );

//
// Maximum entities which can register for device close
// notification
//
#define MAX_DEVICE_CLOSE_NOTIFICATION_SIZE   5

extern PARC_DEVICE_CLOSE_NOTIFICATION
DeviceCloseNotify[MAX_DEVICE_CLOSE_NOTIFICATION_SIZE];

ARC_STATUS
ArcRegisterForDeviceClose(
    PARC_DEVICE_CLOSE_NOTIFICATION FlushRoutine
    );

ARC_STATUS
ArcDeRegisterForDeviceClose(
    PARC_DEVICE_CLOSE_NOTIFICATION FlushRoutine
    );

#endif //ArcClose

#endif // CACHE_DEVINFO


//
// progress bar functions
// (in blload.c)
//
VOID
BlUpdateBootStatus(
    VOID
    );

VOID
BlRedrawProgressBar(
    VOID
    );

VOID
BlUpdateProgressBar(
    ULONG fPercentage
    );

VOID
BlOutputStartupMsg(
    ULONG   uMsgID
    );

VOID
BlOutputStartupMsgStr(
    PCTSTR MsgStr
    );

VOID
BlOutputTrailerMsg(
    ULONG   uMsgID
    );

VOID
BlOutputTrailerMsgStr(
    PCTSTR MsgStr
    );

VOID
BlSetProgBarCharacteristics(
    IN  ULONG   FrontCharMsgID,
    IN  ULONG   BackCharMsgID
    );

//
// The following routines are used by the loader to translate signature-based
// arcnames to scsi-based names.
//

PCONFIGURATION_COMPONENT
ScsiGetFirstConfiguredTargetComponent(
    IN ULONG ScsiNumber
    );

PCONFIGURATION_COMPONENT
ScsiGetNextConfiguredTargetComponent(
    IN PCONFIGURATION_COMPONENT TargetComponent
    );

PCONFIGURATION_COMPONENT
ScsiGetFirstConfiguredLunComponent(
    IN PCONFIGURATION_COMPONENT TargetComponent
    );

PCONFIGURATION_COMPONENT
ScsiGetNextConfiguredLunComponent(
    IN PCONFIGURATION_COMPONENT LunComponent
    );

BOOLEAN
ScsiGetDevicePath(
    IN ULONG ScsiNumber,
    IN PCONFIGURATION_COMPONENT TargetComponent,
    IN PCONFIGURATION_COMPONENT LunComponent,
    OUT PCHAR DevicePath
    );

//
// Boot Status Data support functions.
//

ULONG
BlGetLastBootStatus(
    IN PVOID DataHandle,
    OUT BSD_LAST_BOOT_STATUS *LastBootStatus
    );

VOID
BlAutoAdvancedBoot(
    IN OUT PCHAR *LoadOptions, 
    IN BSD_LAST_BOOT_STATUS LastBootStatus,
    IN ULONG AdvancedMode
    );

VOID
BlWriteBootStatusFlags(
    IN ULONG SystemPartitionId,
    IN PUCHAR SystemDirectory,
    IN BOOLEAN LastBootGood, 
    IN BOOLEAN LastBootShutdown
    );

ARC_STATUS
BlLockBootStatusData(
    IN ULONG SystemPartitionId,
    IN PCHAR SystemPartition,
    IN PCHAR SystemDirectory,
    OUT PVOID *DataHandle
    );

ARC_STATUS
BlGetSetBootStatusData(
    IN PVOID DataHandle,
    IN BOOLEAN Get,
    IN RTL_BSD_ITEM_TYPE DataItem,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength,
    OUT PULONG BytesReturned OPTIONAL
    );

VOID
BlUnlockBootStatusData(
    IN PVOID DataHandle
    );

#if defined(_IA64_) || defined(_X86_)

#define EFI_PARTITION_SUPPORT   1

#endif

#if defined(_IA64_)
extern BOOLEAN BlUsePrivateDescriptor;
#endif

//
// Boot Flags. These are passed from the startup module (startup.com,
// startrom.com or any of the other flavors) to NTLDR. NTDLR will use
// this flag to control different boot options, such as, whether
// to reboot on an NTDLR failure.
//

// upon any startup / ntldr failures the machine will reboot
// instead of waiting for a key press
#define BOOTFLAG_REBOOT_ON_FAILURE      0x000000001

#endif // _BLDR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\bootefi.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bootefi.h

Abstract:

    Contains definitions and prototypes specific to EFI based os loaders.

Author:

    Andrew Ritz (andrewr) 21-Nov-2000

Revision History:

--*/

#ifndef _BOOTEFI_
#define _BOOTEFI_

#include "efi.h"
//
// these are ARC constants, used for mapping ARC attributes to EFI
// attributes
//
#define ATT_FG_BLACK        0
#define ATT_FG_RED          1
#define ATT_FG_GREEN        2
#define ATT_FG_YELLOW       3
#define ATT_FG_BLUE         4
#define ATT_FG_MAGENTA      5
#define ATT_FG_CYAN         6
#define ATT_FG_WHITE        7

#define ATT_BG_BLACK       (ATT_FG_BLACK   << 4)
#define ATT_BG_BLUE        (ATT_FG_BLUE    << 4)
#define ATT_BG_GREEN       (ATT_FG_GREEN   << 4)
#define ATT_BG_CYAN        (ATT_FG_CYAN    << 4)
#define ATT_BG_RED         (ATT_FG_RED     << 4)
#define ATT_BG_MAGENTA     (ATT_FG_MAGENTA << 4)
#define ATT_BG_YELLOW      (ATT_FG_YELLOW  << 4)
#define ATT_BG_WHITE       (ATT_FG_WHITE   << 4)

#define ATT_FG_INTENSE      8
#define ATT_BG_INTENSE     (ATT_FG_INTENSE << 4)

#define DEFIATT   (ATT_FG_WHITE | ATT_BG_BLUE | ATT_FG_INTENSE)
// intense red on blue doesn't show up on all monitors.
//#define DEFERRATT (ATT_FG_RED   | ATT_BG_BLUE | ATT_FG_INTENSE)
#define DEFERRATT DEFATT
#define DEFSTATTR (ATT_FG_BLACK | ATT_BG_WHITE)
#define DEFDLGATT (ATT_FG_RED   | ATT_BG_WHITE)




//
// EFI utility prototypes
//                
VOID
FlipToPhysical();

VOID
FlipToVirtual();

//
// display related prototypes
//      
BOOLEAN
BlEfiClearDisplay(
    VOID
    );

BOOLEAN
BlEfiClearToEndOfDisplay(
    VOID
    );

BOOLEAN
BlEfiClearToEndOfLine(
    VOID
    );

ULONG
BlEfiGetColumnsPerLine(
    VOID
    );

ULONG
BlEfiGetLinesPerRow(
    VOID
    );


BOOLEAN
BlEfiGetCursorPosition(
    OUT PULONG x, OPTIONAL
    OUT PULONG y OPTIONAL
    );

BOOLEAN
BlEfiPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    );

BOOLEAN
BlEfiEnableCursor(
    BOOLEAN bVisible
    );

BOOLEAN
BlEfiSetAttribute(
    ULONG Attribute
    );

BOOLEAN
BlEfiSetInverseMode(
    BOOLEAN fInverseOn
    );

USHORT
BlEfiGetGraphicsChar(
    IN GraphicsChar WhichOne
    );

VOID
DBG_EFI_PAUSE(
    VOID
    );

VOID
EFITRACE( PTCHAR p, ... );


UINT16
__cdecl
wsprintf(
    CHAR16 *buf,
    const CHAR16 *fmt,
    ...);

extern WCHAR DebugBuffer[512];

CHAR16*
DevicePathToStr(
    EFI_DEVICE_PATH UNALIGNED *DevPath
    );

VOID
DisableEFIWatchDog(
    VOID
    );

ARC_STATUS
BlGetEfiProtocolHandles(
    IN EFI_GUID *ProtocolType,
    OUT EFI_HANDLE **pHandleArray,
    OUT ULONG *NumberOfDevices
    );

#endif // _BOOTEFI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\cdfsboot.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    CdfsBoot.h

Abstract:

    This module defines globally used procedure and data structures used
    by Cdfs boot.

Author:

    Brian Andrew    [BrianAn]   05-Aug-1991

Revision History:

--*/

#ifndef _CDFSBOOT_
#define _CDFSBOOT_

#define MAX_CDROM_READ                  (16 * CD_SECTOR_SIZE)

typedef struct _CDFS_STRUCTURE_CONTEXT {

    //
    //  The following field is the sector offset of the start of
    //  directory data.
    //

    ULONG RootDirSectorOffset;

    //
    //  The following field is the start of the sector containing the
    //  this directory.
    //

    ULONG RootDirDiskOffset;

    //
    //  The following field is the size of the directory.
    //

    ULONG RootDirSize;

    //
    //  The following field is the sector offset of the start of
    //  directory data.
    //

    ULONG DirSectorOffset;

    //
    //  The following field is the start of the sector containing the
    //  this directory.
    //

    ULONG DirDiskOffset;

    //
    //  The following field is the size of the directory.
    //

    ULONG DirSize;

    //
    //  The following field indicates the size of the disk Logical Blocks.
    //

    ULONG LbnBlockSize;

    //
    //  The following field indicates the number of logical blocks on the
    //  disk.
    //

    ULONG LogicalBlockCount;

    //
    //  The following indicates whether this is an Iso or Hsg disk.
    //

    BOOLEAN IsIsoVol;

} CDFS_STRUCTURE_CONTEXT, *PCDFS_STRUCTURE_CONTEXT;

//
// Define Cdfs file context structure.
//

typedef struct _CDFS_FILE_CONTEXT {

    //
    //  The following is the disk offset of the read position for the
    //  start of the file.  This may include the above number of non-file
    //  bytes.
    //

    ULONG DiskOffset;

    //
    //  The following field contains the size of the file, in bytes.
    //

    ULONG FileSize;

    //
    //  The following field indicates whether this is a directory.
    //

    BOOLEAN IsDirectory;

} CDFS_FILE_CONTEXT, *PCDFS_FILE_CONTEXT;

//
// Define file I/O prototypes.
//

ARC_STATUS
CdfsClose (
    IN ULONG FileId
    );

ARC_STATUS
CdfsOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    );

ARC_STATUS
CdfsRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
CdfsSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
CdfsWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
CdfsGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    );

ARC_STATUS
CdfsSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

ARC_STATUS
CdfsInitialize(
    VOID
    );

#endif // _CDFSBOOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\bootp.h ===
/*
 *
 * Modifications:   $Header:   W:/LCS/ARCHIVES/preboot/lsa2/inc/bootp.h_v   1.4   Apr 04 1997 13:57:00   GRGUSTAF  $
 *
 * Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
 *
 */

#ifndef __BOOTP_H
#define __BOOTP_H


#include "ip.h"

#define BOOTP_VENDOR    64      /* BOOTP standard vendor field size */
#define BOOTP_DHCPVEND  312     /* DHCP standard vendor field size */
#define BOOTP_EXVENDOR  1024    /* .. our max. size (MTU 1500) */

/* BOOTstrap Protocol (BOOTP) header */
typedef struct bootph {
	UINT8   opcode,                 /* operation code */
		hardware,               /* hardware type */
		hardlen,                /* length of hardware address */
		gatehops;               /* gateways hops */
	UINT32  ident;                  /* transaction identification */
	UINT16  seconds,                /* seconds elapsed since boot began */
		flags;                  /* flags */
	UINT8   cip[IPLEN],             /* client IP address */
		yip[IPLEN],             /* your IP address */
		sip[IPLEN],             /* server IP address */
		gip[IPLEN];             /* gateway IP address */
	UINT8   caddr[16],              /* client hardware address */
		sname[64],              /* server name */
		bootfile[128];          /* bootfile name */
	union {
		UINT8   d[BOOTP_EXVENDOR];      /* vendor-specific stuff */
		struct {
			UINT8   magic[4];       /* magic number */
			UINT32  flags;          /* flags/opcodes etc */
			UINT8   pad[56];        /* padding chars */
		} v;
	} vendor;
} BOOTPLAYER;

#define VM_RFC1048      0x63538263L     /* RFC1048 magic number (in network order) */

#define BOOTP_SPORT     67              /* BOOTP server port */
#define BOOTP_CPORT     68              /* .. client port */

#define BOOTP_REQ       1               /* BOOTP request */
#define BOOTP_REP       2               /* .. reply */

/* BOOTP flags field */
#define BOOTP_BCAST     0x8000          /* BOOTP broadcast flag */
#define BOOTP_FLAGS     BOOTP_BCAST     /* .. for FDDI address transl. */


#endif /* __BOOTP_H */

/* EOF - $Workfile:   bootp.h  $ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\haldtect.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    haldtect.h

Abstract:

    Common header file for HAL detection routines

Author:

    John Vert (jvert) 6-Oct-1993

Environment:

    ARC environment

Revision History:

--*/
#include "bldr.h"
#include "setupblk.h"
#include "parseini.h"
#include "stdio.h"
#include "stdarg.h"



PCHAR
SlDetectHal(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\dockinfo.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dockinfo.h

Abstract:

    This file defines a structure that is used to pass docking
    station info from NTDETECT to NTLDR. See PNP BIOS Specification
    Function 5 - "Get Docking Station Info" for details.

Author:

    Doug Fritz     [DFritz]    01-Oct-1997

Environment:

    Both 16-bit real mode and 32-bit protected mode.

Revision History:

--*/

#ifndef _DOCKINFO_
#define _DOCKINFO_


//
// FW_DOCKINFO_NOT_CALLED is used by NTLDR to detect the case where
//   NTDETECT never called BIOS to get docking station info.
//   (e.g., BIOS was not PnP). SUCCESS and NOT_DOCKED are from
//   the Plug and Play BIOS Specification appendix E.
//

#define FW_DOCKINFO_SUCCESS                 0x0000
#define FW_DOCKINFO_FUNCTION_NOT_SUPPORTED  0x0082
#define FW_DOCKINFO_SYSTEM_NOT_DOCKED       0x0087
#define FW_DOCKINFO_DOCK_STATE_UNKNOWN      0x0089
#define FW_DOCKINFO_BIOS_NOT_CALLED         0xffff

//
// Define FAR macro appropriately based on whether we're compiling 16-bit
// or 32-bit.
//
#ifdef X86_REAL_MODE

#ifndef FAR
#define FAR far
#endif

#else  // not x86 real mode

#ifndef FAR
#define FAR
#endif

#endif // not x86 real mode

typedef struct {
    ULONG       DockID;
    ULONG       SerialNumber;
    USHORT      Capabilities;
    USHORT      ReturnCode;     // initialize with FW_DOCKINFO_NOT_CALLED
} DOCKING_STATION_INFO, FAR * FPDOCKING_STATION_INFO, * PDOCKING_STATION_INFO;

#endif // _DOCKINFO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\dhcp.h ===
/*
 *
 * Modifications:   $Header:   V:/archives/include/dhcp.h_v   1.1   Apr 16 1997 11:39:12   PWICKERX  $
 *
 * Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
 *
 */

#define DHCP_PAD		 0	/* DHCP pad character */
#define DHCP_SUBNET		 1 	/* DHCP subnet mask */
#define DHCP_TOFFSET		 2	/* DHCP time offset */
#define DHCP_ROUTER		 3	/* DHCP router option */
#define DHCP_TSRV		 4	/* DHCP time server */
#define DHCP_NSRV		 5	/* DHCP name server */
#define DHCP_DNSRV		 6	/* DHCP domain name server */
#define DHCP_LSRV		 7	/* DHCP log server */
#define DHCP_CSRV		 8	/* DHCP cookie server */
#define DHCP_HNAME		12	/* DHCP hostname */
#define DHCP_DNAME		15	/* DHCP domainname */
#define DHCP_VENDOR		43	/* DHCP vendor specific */
#define DHCP_REQIP		50	/* DHCP requested IP address */
#define DHCP_LEASE		51	/* DHCP IP addr lease time */
#define DHCP_OVRLOAD	52	/* DHCP Option overload */

#define DHCP_MSGTYPE	53	/* DHCP message type opcode */
	#define DHCP_DISCOVER	0x01	/* DHCP discover package */
	#define DHCP_OFFER		0x02	/* DHCP offer package */
	#define DHCP_REQUEST	0x03	/* DHCP offer request */
	#define DHCP_DECLINE	0x04	/* DHCP invalid config */
	#define DHCP_ACK		0x05	/* DHCP ACK */
	#define DHCP_NAK		0x06	/* DHCP NAK */
	#define DHCP_RELEASE	0x07	/* DHCP release IP addr */

#define DHCP_SRVID		54	/* DHCP server ID */
#define DHCP_PREQLST	55	/* DHCP parameter request list */
#define DHCP_MESSAGE	56	/* DHCP message */
#define DHCP_MAXMSG		57	/* DHCP maximum message size */
#define DHCP_CLASS		60  /* DHCP class identifier */
#define DHCP_CLIENTID  	61  /* DHCP client identifier */
	/* sample number assigned for new client ID type */
	#define DHCP_CLIENTID_GUID  85  /* new type for DHCP_CLIENTID option */

/* sample numbers assigned for new options */
#define DHCP_SYSARCH       	90	/* DHCP system architecture */
	/* sample numbers assigned for system architecture types */
	#define DHCP_STD_X86	0x00
	#define DHCP_PC98_X86	0x01
#define DHCP_NICIF	   	91	/* NIC Interface specifier */
	/* sample numbers assigned for NIC Interface types */
	#define DHCP_UNDI	0x01  /* followed by two bytes of data */
	#define DHCP_PCI	0x02  /* followed by eight bytes of data */
	#define DHCP_PNP	0x03  /* followed by seven bytes of data */
#define DHCP_CLIENT_GUID   	97	/* Guid of the client */

/* 

"Private use" options from 128 - 254 

*/ 

/* Path to NTLDR that will be downloaded by startrom.com */
#define DHCP_LOADER_PATH            251

/* Multicast Download options. Used in the same manner as vendor 
   options for PXE. Specifically the following are 
   the enacapsulated options within this field:

        Tag #1 PXE_MTFTP_IP        - Multicast IP address for loader
        Tag #2 PXE_MTFTP_CPORT     - UDP port the client should monitor
        Tag #3 PXE_MTFTP_SPORT     - UDP port the MTFTP server are listening on
        Tag #4 PXE_MTFTP_TMOUT     - Number of seconds client must listen for activity
        Tag #5 PXE_MTFTP_DELAY     - Number of seconds client must listen before restarting
   
*/
#define DHCP_LOADER_MCAST_OPTIONS   252 

/* Contents of the boot.ini file. Each DHCP option is limited to 255 bytes.
   This option can have multiple instances in the same DHCP packet and the
   client is expected to concatenate them for larger boot.ini files.
   
   From RFC 2131:
   The values to be passed in an 'option' tag may be too long to fit in
   the 255 octets available to a single option (e.g., a list of routers
   in a 'router' option [21]).  Options may appear only once, unless
   otherwise specified in the options document.  The client concatenates
   the values of multiple instances of the same option into a single
   parameter list for configuration.

*/
#define DHCP_LOADER_BOOT_INI        253

/* Path to boot.ini file if greater than 255 bytes in length */
#define DHCP_LOADER_BOOT_INI_PATH   254 /* Path to boot.ini */

/* EOF - $Workfile:   dhcp.h  $ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\hpfsboot.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    HpfsBoot.h

Abstract:

    This module defines globally used procedure and data structures used
    by Hpfs boot.

Author:

    Gary Kimura     [GaryKi]    19-Jul-1991

Revision History:

--*/

#ifndef _HPFSBOOT_
#define _HPFSBOOT_

typedef ULONG LBN;
typedef LBN *PLBN;

typedef ULONG VBN;
typedef VBN *PVBN;


//
// The following structure is a context block used by the exported
// procedures in the Hpfs boot package.  The context contains our cached
// part of the boot mcb structure.  The max number must not be smaller than
// the maximum number of leafs possible in a pinball allocation sector plus
// one.
//

#define MAXIMUM_NUMBER_OF_BOOT_MCB       (41)

typedef struct _HPFS_BOOT_MCB {

    //
    //  The following fields indicate the number of entries in use by
    //  the boot mcb. and the boot mcb itself.  The boot mcb is
    //  just a collection of vbn - lbn pairs.  The last InUse entry
    //  Lbn's value is ignored, because it is only used to give the
    //  length of the previous run.
    //

    ULONG InUse;

    VBN Vbn[ MAXIMUM_NUMBER_OF_BOOT_MCB ];
    LBN Lbn[ MAXIMUM_NUMBER_OF_BOOT_MCB ];

} HPFS_BOOT_MCB, *PHPFS_BOOT_MCB;

typedef struct _HPFS_STRUCTURE_CONTEXT {

    //
    //  The following field contains the fnode lbn of the file
    //

    LBN Fnode;

    //
    //  The following field contains the cached mcb
    //

    HPFS_BOOT_MCB BootMcb;

} HPFS_STRUCTURE_CONTEXT, *PHPFS_STRUCTURE_CONTEXT;

//
// Define Hpfs file context structure.
//

typedef struct _HPFS_FILE_CONTEXT {

    //
    //  The following field contains the size of the file, in bytes.
    //

    ULONG FileSize;

} HPFS_FILE_CONTEXT, *PHPFS_FILE_CONTEXT;

//
// HPFS file system structures
//
typedef ULONG SIGNATURE;
typedef SIGNATURE *PSIGNATURE;

typedef ULONG PINBALL_TIME;
typedef PINBALL_TIME *PPINBALL_TIME;
//
//  There are only three sectors on the disk that have fixed locations.  They
//  are the boot sector, the super sector, and the spare sector.
//

#define BOOT_SECTOR_LBN                  (0)
#define SUPER_SECTOR_LBN                 (16)
#define SPARE_SECTOR_LBN                 (17)

typedef struct _SUPER_SECTOR {

    //
    //  The Super Sector starts with a double signature.
    //

    SIGNATURE Signature1;                           // offset = 0x000   0
    SIGNATURE Signature2;                           // offset = 0x004   4

    //
    //  The version and functional version describe the version of
    //  the on-disk file system structures and the oldest version of the
    //  file system that can understand this disk.
    //

    UCHAR Version;                                  // offset = 0x008   8
    UCHAR FunctionalVersion;                        // offset = 0x009   9
    USHORT Unused1;                                 // offset = 0x00A  10

    //
    //  This field denotes the sector containing the FNODE for the root
    //  directory for the volume.
    //

    LBN RootDirectoryFnode;                         // offset = 0x00C  12

    //
    //  The follow two fields indicate the number of total sectors on the
    //  volume (good and bad), and the number of bad sectors on the volume.
    //

    ULONG NumberOfSectors;                          // offset = 0x010  16
    ULONG NumberOfBadSectors;                       // offset = 0x014  20

    //
    //  This field denotes the sector containing the first level of the
    //  volumes bitmap table.
    //

    LBN BitMapIndirect;                             // offset = 0x018  24
    ULONG Unused2;                                  // offset = 0x01C  28

    //
    //  This field denotes the sector containing the first bad sector disk
    //  buffer for the volume.
    //

    LBN BadSectorList;                              // offset = 0x020  32
    ULONG Unused3;                                  // offset = 0x024  36

    //
    //  The following two dates are the time of the last execution of
    //  chkdsk and disk optimize on the volume.
    //

    PINBALL_TIME ChkdskDate;                        // offset = 0x028  40
    PINBALL_TIME DiskOptimizeDate;                  // offset = 0x02C  44

    //
    //  The following four fields describe the directory disk buffer pool.
    //  It is a contiguous run on of sectors on the disk set aside for
    //  holding directory disk buffers.  PoolSize is the total number of
    //  sectors in the pool.  First and Last Sector denote the boundaries
    //  of the pool, and BitMap denotes the start of a small bitmap used to
    //  describe the directory disk buffer pool's current allocation.  The
    //  bitmap is 4 contiguous sectors in size, and each bit in the map
    //  corresponds to 1 Directory Disk Buffer (i.e., 4 Sectors worth)
    //

    ULONG DirDiskBufferPoolSize;                    // offset = 0x030  48
    LBN DirDiskBufferPoolFirstSector;               // offset = 0x034  52
    LBN DirDiskBufferPoolLastSector;                // offset = 0x038  56
    LBN DirDiskBufferPoolBitMap;                    // offset = 0x03C  60

    //
    //  The following field contains the name of the volume
    //

    UCHAR VolumeName[32];                           // offset = 0x040  64

    //
    //  The following field denotes the start of the Small ID (SID) table
    //  which is used to store the Small ID to GUID mappings used on the
    //  volume.  The SID table is 8 contiguous sectors in size.
    //

    LBN SidTable;                                   // offset = 0x060  96
    UCHAR Unused4[512-100];                         // offset = 0x064 100

} SUPER_SECTOR;                                     // sizeof = 0x200 512
typedef SUPER_SECTOR *PSUPER_SECTOR;

//
//  Super Sector signatures
//

#define SUPER_SECTOR_SIGNATURE1          (0xf995e849)
#define SUPER_SECTOR_SIGNATURE2          (0xfa53e9c5)

//
//  Super Sector versions
//

#define SUPER_SECTOR_VERSION             (0x02)
#define SUPER_SECTOR_FUNC_VERSION        (0x02)

typedef struct _SPARE_SECTOR {

    //
    //  The Spare Sector starts with a double signature.
    //

    SIGNATURE Signature1;                           // offset = 0x000   0
    SIGNATURE Signature2;                           // offset = 0x004   4

    //
    //  The flags field describe how "clean" the volume is.
    //

    UCHAR Flags;                                    // offset = 0x008   8
    UCHAR Unused1[3];                               // offset = 0x009   9

    //
    //  The following three fields describe the hotfix structure for the
    //  volume.  The List field is denotes the disk buffer used to store
    //  the hotfix table.  The InUse describes how many hotfixes are
    //  currently being used, and MaxSize is the total number of hotfixes
    //  that can be in use at any one time.
    //

    LBN HotFixList;                                 // offset = 0x00C  12
    ULONG HotFixInUse;                              // offset = 0x010  16
    ULONG HotFixMaxSize;                            // offset = 0x014  20

    //
    //  The following two fields describe the "emergency" pool of spare
    //  directory disk buffers.  Free describes how many spare directory
    //  disk buffers are currently available for use.  MaxSize is the total
    //  number of spare directory disk buffers available.  The actual location
    //  of the spare directory disk buffers is denoted in the table at the
    //  end of the spare sector (i.e., field SpareDirDiskBuffer).
    //

    ULONG SpareDirDiskBufferAvailable;              // offset = 0x018  24
    ULONG SpareDirDiskBufferMaxSize;                // offset = 0x01C  28

    //
    //  The following two fields describe the code page information used
    //  on the volume.  The InfoSector field is the sector of the beginning
    //  Code Page Information Sector, and the InUse field is the total number
    //  of code pages currently in use on the volume.
    //

    LBN CodePageInfoSector;                         // offset = 0x020  32
    ULONG CodePageInUse;                            // offset = 0x024  36
    ULONG Unused2[17];                              // offset = 0x028  40

    //
    //  The following field is an array of LBN's for the spare directory
    //  disk buffers that are for "emergency" use.
    //

    LBN SpareDirDiskBuffer[101];                    // offset = 0x06C 108

} SPARE_SECTOR;                                     // sizeof = 0x200 512
typedef SPARE_SECTOR *PSPARE_SECTOR;

//
//  Spare Sector signatures
//

#define SPARE_SECTOR_SIGNATURE1          (0xf9911849)
#define SPARE_SECTOR_SIGNATURE2          (0xfa5229c5)


//
//  The on-disk allocation structure is defined using B-Trees.  For every
//  B-Tree block there is an Allocation Header, followed by a list of
//  either Allocation Leafs or Allocation Nodes.  This structure will either
//  appear in an FNODE or in an AllocationSector.
//
//  The allocation header (called Allocation Block in earlier implementations)
//  describes a B-tree block.
//

typedef struct _ALLOCATION_HEADER {

    //
    //  The following flag describes the state of the B-tree block (e.g.,
    //  indicates if the block is a leaf or an internal node.
    //

    UCHAR Flags;                                    // offset = 0x000  0
    UCHAR Unused[3];                                // offset = 0x001  1

    //
    //  The following two fields denote the number of free records in the
    //  B-Tree block, and the number of records that are currently in use
    //

    UCHAR FreeCount;                                // offset = 0x004  4
    UCHAR OccupiedCount;                            // offset = 0x005  5

    //
    //  The next field contains the offset (in bytes) from the beginning
    //  of the allocation header to the first free byte in the B-Tree block
    //

    USHORT FirstFreeByte;                           // offset = 0x006  6

} ALLOCATION_HEADER;                                // sizeof = 0x008  8
typedef ALLOCATION_HEADER *PALLOCATION_HEADER;

//
//  Allocation header flags
//
//      NODE - if set this indicates that the B-Tree block contains internal
//          nodes and not leaf entries.
//
//      BINARY_SEARCH - if set this suggest that a binary search should be used
//          to search the B-Tree block.
//
//      FNODE_PARENT - if set this indicates that the sector which is the
//          parent of the sector with this header (not this sector), is an
//          FNODE.
//

#define ALLOCATION_BLOCK_NODE            (0x80)
#define ALLOCATION_BLOCK_BINARY          (0x40)
#define ALLOCATION_BLOCK_FNODE_PARENT    (0x20)

//
//  Immediately following an allocation header are one or more allocation nodes
//  of allocation leafs.
//

typedef struct _ALLOCATION_NODE {

    //
    //  All children of this allocation node will have values less than
    //  the following VBN field.
    //

    VBN Vbn;                                        // offset = 0x000  0

    //
    //  This is the LBN of the allocation sector refered to by this node
    //

    LBN Lbn;                                        // offset = 0x004  4

} ALLOCATION_NODE;                                  // sizeof = 0x008  8
typedef ALLOCATION_NODE *PALLOCATION_NODE;

typedef struct _ALLOCATION_LEAF {

    //
    //  The following field has the starting VBN for this run
    //

    VBN Vbn;                                        // offset = 0x000  0

    //
    //  This is the length of the run in sectors
    //

    ULONG Length;                                   // offset = 0x004  4

    //
    //  This is the starting LBN of the run
    //

    LBN Lbn;                                        // offset = 0x008  8

} ALLOCATION_LEAF;                                  // sizeof = 0x00C 12
typedef ALLOCATION_LEAF *PALLOCATION_LEAF;

//
//  An allocation sector is an on-disk structure that contains allocation
//  information.  It contains some bookkeeping information, an allocation
//  header and then an array of either allocation leafs or allocation nodes.
//
//       AllocationSector
//      +-------------------+
//      | bookkeeping       |
//      +- - - - - - - - - -+
//      | Allocation Header |
//      +- - - - - - - - - -+
//      | Allocation Leafs  |
//      |        or         |
//      | Allocation Nodes  |
//      +-------------------+
//
//  where the number of allocation leafs that can be stored in a sector is
//  40 and the number of nodes is 60.
//

#define ALLOCATION_NODES_PER_SECTOR      (60)
#define ALLOCATION_LEAFS_PER_SECTOR      (40)

typedef struct _ALLOCATION_SECTOR {

    //
    //  The allocation sector starts off with a signature field
    //

    SIGNATURE Signature;                            // offset = 0x000   0

    //
    //  This following two fields contains the LBN of this allocation
    //  sector itself, and the LBN of the parent of this sector (the
    //  parent is either an FNODE or another allocation sector)
    //

    LBN Lbn;                                        // offset = 0x004   4
    LBN ParentLbn;                                  // offset = 0x008   8

    //
    //  The allocation header for the sector
    //

    ALLOCATION_HEADER AllocationHeader;             // offset = 0x00C  12

    //
    //  The remainder of the sector is either an array of allocation leafs
    //  of allocation nodes
    //

    union {                                         // offset = 0x014  20
        ALLOCATION_NODE Node[ ALLOCATION_NODES_PER_SECTOR ];
        ALLOCATION_LEAF Leaf[ ALLOCATION_LEAFS_PER_SECTOR ];
    } Allocation;

    UCHAR Unused[12];                               // offset = 0x1F4 500

} ALLOCATION_SECTOR;                                // sizeof = 0x200 512
typedef ALLOCATION_SECTOR *PALLOCATION_SECTOR;

//
//  The allocation sector signature
//

#define ALLOCATION_SECTOR_SIGNATURE      (0x37e40aae)

//
//  The on-disk FNODE structure is used to describe both files and directories
//  It contains some fixed data information, the EA and ACL lookup information,
//  allocation information and then a free space for storing some EAs and
//  ACLs that fit in the sector
//

#define ALLOCATION_NODES_PER_FNODE       (12)
#define ALLOCATION_LEAFS_PER_FNODE       (8)

typedef struct _FNODE_SECTOR {

    //
    //  The sector starts with a signature field
    //

    SIGNATURE Signature;                            // offset = 0x000   0

    //
    //  The following fields was for history tracking, but in NT Pinball
    //  doesn't need this information.
    //

    ULONG Unused1[2];                               // offset = 0x004   4

    //
    //  The following two fields contain the file name length, and the first
    //  15 bytes of the filename, as stored in the dirent that references
    //  this fnode.  For the root directory theses values are all zeros.
    //

    UCHAR FileNameLength;                           // offset = 0x00C  12
    UCHAR FileName[15];                             // offset = 0x00D  13

    //
    //  The following field denotes the parent directory's FNODE
    //

    LBN ParentFnode;                                // offset = 0x01C  28

    //
    //  The following four fields describe the ACL for the file/directory.
    //
    //  AclDiskAllocationLength holds the number of bytes in the ACL that
    //      are stored outside of this FNODE.  If this value is not zero
    //      then AclFnodeLength must be equal to zero.
    //
    //  AclLbn points to the first sector of the data run or the allocation
    //      sector containing describing the ACL.  AclFlags indicates if
    //      it is a data run or an allocation sector. AclLbn is only used
    //      if AclDiskAllocationLength is not zero.
    //
    //  AclFnodeLength holds the number of bytes in the ACL that are
    //      stored within this FNODE.  If value is not zero then
    //      AclDiskAllocationLength must be equal to zero.  The ACL, if stored
    //      in the FNODE, is located at AclEaFnodeBuffer in this FNODE sector.
    //
    //  AclFlags if the data is outside the FNODE this flag indicates whether
    //      ACL is stored in a single data run (AclFlags == 0) or via an
    //      allocation sector (AclFlags != 0).  AclFlags is only used if
    //      AclDiskAllocationLength is not zero.
    //

    ULONG AclDiskAllocationLength;                  // offset = 0x020  32
    LBN AclLbn;                                     // offset = 0x024  36
    USHORT AclFnodeLength;                          // offset = 0x028  40
    UCHAR AclFlags;                                 // offset = 0x02A  42

    //
    //  The following field was used for the number of valid history
    //  bits but we don't need this field of NT Pinball
    //

    UCHAR Unused2;                                  // offset = 0x02B  43

    //
    //  The following four fields describe the EA for the file/directory.
    //
    //  EaDiskAllocationLength holds the number of bytes in the EA that
    //      are stored outside of this FNODE.  If this value is not zero
    //      then EaFnodeLength must be equal to zero.
    //
    //  EaLbn points to the first sector of the data run or the allocation
    //      sector containing describing the EA.  EaFlags indicates if
    //      it is a data run or an allocation sector.  EaLbn is only used
    //      if EaDiskAllocationLength is not zero.
    //
    //  EaFnodeLength holds the number of bytes in the EA that are
    //      stored within this FNODE.  If value is not zero then
    //      EaDiskAllocationLength must be equal to zero.  The EA, if stored
    //      in the FNODE, is located immediately after the ACL stored in the
    //      AclEaFnodeBuffer.
    //
    //  EaFlags if the data is outside the FNODE this flag indicates whether
    //      EA is stored in a single data run (EaFlags == 0) or via an
    //      allocation sector (EaFlags != 0).  EaFlags is only used if
    //      EaDiskAllocationLength is not zero.
    //

    ULONG EaDiskAllocationLength;                   // offset = 0x02C  44
    LBN EaLbn;                                      // offset = 0x030  48
    USHORT EaFnodeLength;                           // offset = 0x034  52
    UCHAR EaFlags;                                  // offset = 0x036  54

    //
    //  The following byte contains the FNODE flags
    //

    UCHAR Flags;                                    // offset = 0x037  55

    //
    //  The following two fields describe the top level allocation for
    //  this file/directory
    //

    ALLOCATION_HEADER AllocationHeader;             // offset = 0x038  56

    union {                                         // offset = 0x040  64
        ALLOCATION_NODE Node[ ALLOCATION_NODES_PER_FNODE ];
        ALLOCATION_LEAF Leaf[ ALLOCATION_LEAFS_PER_FNODE ];
    } Allocation;

    //
    //  The following field contains the valid length of the file.  The size
    //  of the file is stored in the dirent.  The difference between these two
    //  values is that the file size is the actual size allocated and visible
    //  to the user.  The Valid length is the number of bytes that have
    //  had their data zeroed out or modified.  (i.e., if a read request
    //  is greater than valid length but less than file size then the file
    //  system must first zero out the data in the file up to and including
    //  data being read.
    //

    ULONG ValidDataLength;                          // offset = 0x0A0 160

    //
    //  The following field contains the number of EAs in this file that have
    //  the need ea attribute set.
    //

    ULONG NeedEaCount;                              // offset = 0x0A4 164
    UCHAR Unused3[16];                              // offset = 0x0A8 168

    //
    //  The following field contains the offset, in bytes, from the start of
    //  FNODE to the first ACE stored in the FNODE
    //

    USHORT AclBase;                                 // offset = 0x0B8 184
    UCHAR Unused4[10];                              // offset = 0x0BA 186

    //
    //  The following buffer is used to store acl/ea in the FNODE
    //

    UCHAR AclEaFnodeBuffer[316];                    // offset = 0x0C4 196

} FNODE_SECTOR;                                     // sizeof = 0x200 512
typedef FNODE_SECTOR *PFNODE_SECTOR;

//
//  The FNODE Sector signature
//

#define FNODE_SECTOR_SIGNATURE           (0xf7e40aae)

//
//  The on-disk directory disk buffer is used to contain directory entries.
//  It contains a fixed header followed by a collection of one or more
//  dirents.  Dirents are variable so size we cannot use a simply C struct
//  declartion for the entire disk buffer.
//

typedef struct _DIRECTORY_DISK_BUFFER {

    //
    //  The disk buffer starts with a signature field
    //

    SIGNATURE Signature;                            // offset = 0x000    0

    //
    //  The following field is the offset to the first free byte in this
    //  disk buffer
    //

    ULONG FirstFree;                                // offset = 0x004    4

    //
    //  The following field is a change count that is kept around for
    //  bookkeeping purposes.  It is incremented whenever we move any
    //  of the entries in this disk buffer.  This means for any file if we
    //  remember its offset and its change count we will be able to quickly
    //  locate the dirent again without needing to search from the top
    //  of the directory again. (i.e., only if the remembered change count
    //  and the current change count match).  For this to work the file system
    //  in memory will need to keep track of whenever it removes a Directory
    //  Disk Buffer from a directory, and have each saved dirent location
    //  keep this Directory change count, the Directory Disk Buffer Change
    //  Count, LBN and Offset.
    //
    //  In addition we overload the bit in this value to indicate if this
    //  is the topmost directory disk buffer for the directory (low order bit
    //  = 1) or if it is a lower lever buffer (low order bit = 0).
    //

    ULONG ChangeCount;                              // offset = 0x008    8

    //
    //  The following field contains the LBN of either the parent
    //  directory disk buffer containing this disk buffer or the FNODE.
    //  It is the FNODE if this is a topmost disk buffer and a parent
    //  directory disk buffer otherwise.
    //

    LBN Parent;                                     // offset = 0x00C   12

    //
    //  The following field is the LBN of the sector containing the
    //  start of this disk buffer
    //

    LBN Sector;                                     // offset = 0x010   16

    //
    //  This following buffer contains the dirents stored in this disk buffer
    //

    UCHAR Dirents[2028];                            // offset = 0x014   20

} DIRECTORY_DISK_BUFFER;                            // sizeof = 0x800 2048
typedef DIRECTORY_DISK_BUFFER *PDIRECTORY_DISK_BUFFER;

//
// Size of Directory Disk Buffer in sectors.
//

#define DIRECTORY_DISK_BUFFER_SECTORS    (4)

//
//  Directory Disk Buffer Signature
//

#define DIRECTORY_DISK_BUFFER_SIGNATURE  (0x77e40aae)

typedef struct _PBDIRENT {

    USHORT DirentSize;                              // offset = 0x000  0
    UCHAR Flags;                                    // offset = 0x002  2
    UCHAR FatFlags;                                 // offset = 0x003  3

    LBN Fnode;                                      // offset = 0x004  4

    PINBALL_TIME LastModificationTime;              // offset = 0x008  8

    ULONG FileSize;                                 // offset = 0x00C 12

    PINBALL_TIME LastAccessTime;                    // offset = 0x010 16

    PINBALL_TIME FnodeCreationTime;                 // offset = 0x014 20

    ULONG EaLength;                                 // offset = 0x018 24

    UCHAR ResidentAceCount;                         // offset = 0x01C 28
    UCHAR CodePageIndex;                            // offset = 0x01D 29
    UCHAR FileNameLength;                           // offset = 0x01E 30
    UCHAR FileName[1];                              // offset = 0x01F 31

} PBDIRENT;                                           // sizeof = 0x020 32
typedef PBDIRENT *PPBDIRENT;

//
// Define sizes of .. and End PBDIRENT.
//

#define SIZEOF_DIR_DOTDOT                (sizeof(PBDIRENT) + sizeof(LONG))
#define SIZEOF_DIR_END                   (sizeof(PBDIRENT))
#define SIZEOF_DIR_MAXPBDIRENT             (sizeof(PBDIRENT) + 256 + \
                                          (3*sizeof(PINBALL_ACE)) + sizeof(LBN))

#define DIRENT_FIRST_ENTRY               (0x0001)
#define DIRENT_ACL                       (0x0002)
#define DIRENT_BTREE_POINTER             (0x0004)
#define DIRENT_END                       (0x0008)
#define DIRENT_EXPLICIT_ACL              (0x0040)
#define DIRENT_NEED_EA                   (0x0080)
#define DIRENT_NEW_NAMING_RULES          (0x4000)
//
//  The following macros are used to help locate dirents within a Directory
//  Disk Buffer.  GetFirstDirent returns a pointer to the first dirent entry
//  in the directory disk buffer.  GetNextDirent returns a pointer to the
//  next dirent entry in a directory disk buffer, without checking for the
//  end of the Directory Disk Buffer.
//
//      PDIRENT
//      GetFirstDirent (
//          IN PDIRECTORY_DISK_BUFFER DirectoryDiskBuffer
//          );
//
//      PDIRENT
//      GetNextDirent (
//          IN PDIRENT Dirent
//          );
//

#define GetFirstDirent(DIR) (   \
    (PDIRENT)&(DIR)->Dirents[0] \
)

//
//  This macro blindly returns a pointer to the next Dirent, without checking
//  for the end of the Directory Disk Buffer, i.e., callers must always check
//  for the End record in the Directory Disk Buffer.  If GetNextDirent is
//  called with the End record as input, it will return the next free byte
//  in the buffer.
//

#define GetNextDirent(ENT) (                        \
    (PDIRENT)((PUCHAR)(ENT)+(ENT)->DirentSize)      \
)
//
//  The following macros are used to help retrieve the variable fields
//  within a dirent.  GetAceInDirent returns a pointer to the ACE within
//  the dirent corresponding to the supplied index, or NULL if there isn't
//  a corresponding ACE.  GetBtreePointerInDirent returns the LBN field of
//  the down B-tree pointer stored in the dirent, or it returns a value of
//  zero if there isn't a down pointer.  SetBtreePointerInDirent sets the
//  LBN downpointer field.
//
//      PPINBALL_ACE
//      GetAceInDirent (
//          IN PDIRENT Dirent,
//          IN ULONG Index // (0, 1, or 2)
//          );
//
//      LBN
//      GetBtreePointerInDirent (
//          IN PDIRENT Dirent
//          );
//
//      VOID
//      SetBtreePointerInDirent (
//          IN OUT PDIRENT Dirent,
//          IN LBN Blbn
//          );
//
//
//
//  To return a pointer to an ACE in a dirent we need to check to see if the
//  index is within the resident ace count.  The first ace is the address of
//  the first longword after the filename, the second ace is the second long
//  word.
//

#define GetAceInDirent(ENT,I) (                                          \
    ((I) >= 0 && (I) < (ENT)->ResidentAceCount ?                         \
        (PPINBALL_ACE)(                                                  \
            (LONG)LongAlign((ENT)->FileName[(ENT)->FileNameLength]) +    \
            (I)*sizeof(PINBALL_ACE)                                      \
        )                                                                \
    :                                                                    \
        NULL                                                             \
    )                                                                    \
)

//
//  To return the Btree pointer we need to first check to see if there
//  is Btree pointer field, otherwise we return NULL.  The field, if present,
//  is located 4 bytes back from the end of the dirent.
//

#define GetBtreePointerInDirent(ENT) (                              \
    (FlagOn((ENT)->Flags,DIRENT_BTREE_POINTER) ?                    \
        *(PLBN)(((PUCHAR)(ENT)) + (ENT)->DirentSize - sizeof(LBN))  \
    :                                                               \
        0                                                           \
    )                                                               \
)

//
//  To set the Btree pointer we assume there is a Btree pointer field.
//  The field is located 4 bytes back from the end of the dirent.
//

#define SetBtreePointerInDirent(ENT,BLBN) (                             \
    *(PLBN)(((PUCHAR)(ENT)) + (ENT)->DirentSize - sizeof(LBN)) = (BLBN) \
)

//
// Define file I/O prototypes.
//

ARC_STATUS
HpfsClose (
    IN ULONG FileId
    );

ARC_STATUS
HpfsOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    );

ARC_STATUS
HpfsRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
HpfsSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
HpfsWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
HpfsGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    );

ARC_STATUS
HpfsSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

ARC_STATUS
HpfsInitialize(
    VOID
    );

#endif // _HPFSBOOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\fatboot.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    fatboot.h

Abstract:

    This module defines globally used procedure and data structures used
    by fat boot.

Author:

    Gary Kimura (garyki) 29-Aug-1989

Revision History:

--*/

#ifndef _FATBOOT_
#define _FATBOOT_
#include "fat.h"


//
//  The following structure is used to define the local mcb structure used within
//  the fat boot loader to maintain a small cache of the retrieval information
//  for a single file/directory
//

#define FAT_MAXIMUM_MCB                  (41)

typedef struct _FAT_MCB {

    //
    //  The following fields indicate the number of entries in use by
    //  the boot mcb. and the boot mcb itself.  The boot mcb is
    //  just a collection of [vbo, lbo] pairs.  The last InUse entry
    //  Lbo's value is ignored, because it is only used to give the
    //  length of the previous run.
    //

    ULONG InUse;

    VBO Vbo[ FAT_MAXIMUM_MCB ];
    LBO Lbo[ FAT_MAXIMUM_MCB ];

} FAT_MCB, *PFAT_MCB;

//
//  The following structure is used to define the geometry of the fat volume
//  There is one for every mounted volume.  It describes the size/configuration
//  of the volume, contains a small cached mcb for the last file being accessed
//  on the volume, and contains a small cache of the fat.  Given a FileId we
//  can access the structure context through the structure context field in the
//  global BlFileTable (e.g., BlFileTable[FileId].StructureContext).
//

//
//  The following constant is used to determine how much of the fat we keep
//  cached in memory at any one time.  It must be a multiple of 6 bytes in order to
//  hold complete 12 and 16 bit fat entries in the cache at any one time.
//

#define FAT_CACHE_SIZE                   (512*3)

typedef struct _FAT_STRUCTURE_CONTEXT {

    //
    //  The following field contains an unpacked copy of the bios parameter block
    //  for the mounted volume
    //

    BIOS_PARAMETER_BLOCK Bpb;

    //
    //  The following two fields contain current file id of the file/directory
    //  whose mcb we are keeping around, and the second field is the mcb itself
    //

    ULONG FileId;
    FAT_MCB Mcb;

    //
    //  The following fields describe/contain the current cached fat.  The vbo
    //  is the smallest vbo of the fat currently in the cache, and cached fat
    //  is a pointer to the cached data.  The extra buffer/indirectiion is needed
    //  to keep everything aligned properly.  The dirty flag is used to indicate
    //  if the current cached fat has been modified and needs to be flushed to disk.
    //  Vbo is used because this allows us to do a lot of our computations having
    //  already biased lbo offset to the first fat table.
    //

    BOOLEAN CachedFatDirty;
    VBO CachedFatVbo;
    PUCHAR CachedFat;
    UCHAR CachedFatBuffer[ FAT_CACHE_SIZE + 256 ];

} FAT_STRUCTURE_CONTEXT, *PFAT_STRUCTURE_CONTEXT;

//
//  The following structure is used to define the location and size of each
//  opened file.  There is one of these of every opened file.  It is part of
//  the union of a BL_FILE_TABLE structuure.  Given a FileId we can access the
//  file context via the BlFileTable (e.g., BlFileTable[FileId].u.FatFileContext)
//

typedef struct _FAT_FILE_CONTEXT {

    //
    //  The following two fields describe where on the disk the dirent for the
    //  file is located and also contains a copy of the dirent
    //

    LBO DirentLbo;
    DIRENT Dirent;

} FAT_FILE_CONTEXT, *PFAT_FILE_CONTEXT;


//
// Define file I/O prototypes.
//

ARC_STATUS
FatClose (
    IN ULONG FileId
    );

ARC_STATUS
FatOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    );

ARC_STATUS
FatRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
FatSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
FatWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
FatGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    );

ARC_STATUS
FatSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

ARC_STATUS
FatRename(
    IN ULONG FileId,
    IN CHAR * FIRMWARE_PTR NewFileName
    );

ARC_STATUS
FatGetDirectoryEntry (
    IN ULONG FileId,
    IN DIRECTORY_ENTRY * FIRMWARE_PTR DirEntry,
    IN ULONG NumberDir,
    OUT ULONG * FIRMWARE_PTR CountDir
    );

ARC_STATUS
FatInitialize(
    VOID
    );

#endif // _FATBOOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\ip.h ===
/*
 *
 * Modifications:   $Header:   W:/LCS/ARCHIVES/preboot/lsa2/inc/ip.h_v   1.3   Apr 04 1997 13:57:08   GRGUSTAF  $
 *
 * Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
 *
 */

#ifndef _IP_H
#define _IP_H


#define	IPLEN		4		/* length of an IP address */
#define	PROTUDP		17		/* IP package type is UDP */
#define	PROTIGMP	2		/* .. is IGMP */
#define	FR_MF		0x2000		/* .. fragment bit */
#define	FR_OFS		0x1fff		/* .. fragment offset */

/* Internet Protocol (IP) header */
typedef struct iph {

	UINT8	version; 		/* version and hdr length */
					/* each half is four bits */
	UINT8	service;		/* type of service for IP */
	UINT16	length,			/* total length of IP packet */
		ident,			/* transaction identification */
		frags;			/* combination of flags and value */

	UINT8	ttl,    		/* time to live */
		protocol;		/* higher level protocol type */

	UINT16	chksum;			/* header checksum */

	UINT8	source[IPLEN],		/* IP addresses */
		dest[IPLEN];

} IPLAYER;

struct in_addr {			/* INTERNET address */
	UINT32	s_addr;
};


#endif /* _IP_H */

/* EOF - $Workfile:   ip.h  $ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\netfs.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    netfs.h

Abstract:

    This module defines globally used procedure and data structures used
    by net boot.

Author:

    Chuck Lenzmeier (chuckl) 09-Jan-1997

Revision History:

--*/

#ifndef _NETFS_
#define _NETFS_

#include <undi_api.h>

//
// Progress bar update function
//

VOID
BlUpdateProgressBar(
    ULONG fPercentage
    );


//////////////////////////////////////////////////////////////////////////////
//
// ROM layer definitions.
//
//////////////////////////////////////////////////////////////////////////////

extern UCHAR NetLocalHardwareAddress[16];

extern USHORT NetUnicastUdpDestinationPort;

#if 0
extern USHORT NetMulticastUdpDestinationPort;
extern ULONG NetMulticastUdpDestinationAddress;
extern USHORT NetMulticastUdpSourcePort;
extern ULONG NetMulticastUdpSourceAddress;
#endif

VOID
RomSetBroadcastStatus(
    BOOLEAN Enable
    );

VOID
RomSetReceiveStatus (
    IN USHORT UnicastUdpDestinationPort
#if 0
    ,
    IN USHORT MulticastUdpDestinationPort,
    IN ULONG MulticastUdpDestinationAddress,
    IN USHORT MulticastUdpSourcePort,
    IN ULONG MulticastUdpSourceAddress
#endif
    );

ULONG
RomSendUdpPacket (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG RemoteHost,
    IN USHORT RemotePort
    );

ULONG
RomReceiveUdpPacket (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG Timeout,
    OUT PULONG RemoteHost,
    OUT PUSHORT RemotePort
    );

ULONG
RomGetNicType (
    OUT t_PXENV_UNDI_GET_NIC_TYPE *NicType
    );

ULONG
RomMtftpReadFile (
    IN PUCHAR FileName,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN ULONG ServerIPAddress, // network byte order
    IN ULONG MCastIPAddress, // network byte order
    IN USHORT MCastCPort, // network byte order
    IN USHORT MCastSPort, // network byte order
    IN USHORT Timeout,
    IN USHORT Delay,
    OUT PULONG DownloadSize
    );

//////////////////////////////////////////////////////////////////////////////
//
// TFTP layer definitions.
//
//////////////////////////////////////////////////////////////////////////////

typedef struct _TFTP_REQUEST {
    PUCHAR RemoteFileName;
    ULONG ServerIpAddress;
    PUCHAR MemoryAddress;
    ULONG MaximumLength;
    ULONG BytesTransferred;
    USHORT Operation;
#if defined(REMOTE_BOOT_SECURITY)
    ULONG SecurityHandle;
#endif // defined(REMOTE_BOOT_SECURITY)
    TYPE_OF_MEMORY MemoryType;

    // If TRUE will update the progress bar
    BOOLEAN ShowProgress;
    
} TFTP_REQUEST, *PTFTP_REQUEST;

NTSTATUS
TftpInit (
    VOID
    );

NTSTATUS
TftpGetPut (
    IN PTFTP_REQUEST Request
    );

#if defined(REMOTE_BOOT_SECURITY)
NTSTATUS
TftpLogin (
    IN PUCHAR Domain,
    IN PUCHAR Name,
    IN PUCHAR OwfPassword,
    IN ULONG ServerIpAddress,
    OUT PULONG LoginHandle
    );

NTSTATUS
TftpLogoff (
    IN ULONG ServerIpAddress,
    IN ULONG LoginHandle
    );

NTSTATUS
TftpSignString (
    IN PUCHAR String,
    OUT PUCHAR * Sign,
    OUT ULONG * SignLength
    );
#endif // defined(REMOTE_BOOT_SECURITY)

//
// This file contains the definitions for the TFTP connection control
// block, which contains all the information pertaining to a connection.
// A conn structure is allocated at connection open time and retained
// until the connection is closed.  The routines in the file conn.c
// are sufficient for dealing with connections.
// It also contains the structure definition for tftp packets.
//

//
// Connection control block.
//

typedef struct _CONNECTION {

    ULONG BlockSize;                // block size for transfer

    PVOID LastSentPacket;           // previous packet sent
    ULONG LastSentLength;           // size of previous packet

    ULONG NextRetransmit;           // when to retransmit
    ULONG Retransmissions;          // number of retransmits
    ULONG Timeout;                  // retransmit timeout

    PVOID CurrentPacket;            // current packet (send or rcv)
    ULONG CurrentLength;            // current packet len

    PVOID LastReceivedPacket;       // last received packet
    ULONG LastReceivedLength;       // size of last rcvd. packet

    ULONG RemoteHost;               // remote host IP address
    USHORT RemotePort;              // remote port for connection
    USHORT LocalPort;               // local port for connection

    USHORT Operation;               // direction of transfer
    USHORT BlockNumber;             // next block number
    BOOLEAN Synced;                 // conn synchronized flag

} CONNECTION, *PCONNECTION;

#include <packon.h>

#define ETHERNET_ADDRESS_LENGTH 6

#define COPY_ETHERNET_ADDRESS(_d,_s) RtlCopyMemory( (_d), (_s), ETHERNET_ADDRESS_LENGTH );

#define COPY_IP_ADDRESS(_d,_s) RtlCopyMemory( (_d), (_s), sizeof(ULONG) )
#define COMPARE_IP_ADDRESSES(_a,_b) RtlEqualMemory( (_a), (_b), sizeof(ULONG) )

typedef struct _TFTP_HEADER {
    USHORT Opcode;                      // packet type
    USHORT BlockNumber;                 // block number
} TFTP_HEADER, *PTFTP_HEADER;

typedef struct _TFTP_PACKET {
    TFTP_HEADER ;
    UCHAR Data[1];
} TFTP_PACKET, *PTFTP_PACKET;

#include <packoff.h>

//
// Connection constants.
//

#define TFTP_PORT 0x4500                // big-endian 69

#define TIMEOUT         1               // initial retransmit timeout
#define INITIAL_TIMEOUT 1               // initial connection timeout
#define MAX_TIMEOUT     8               // max. retransmit timeout
#define MAX_RETRANS     8               // max. no. of retransmits

#define DEFAULT_BLOCK_SIZE 1432         // size of data portion of tftp pkt

//
// ideally this should be the commented out size.  But we overload the
// use of this constant to also be the size we use for udp receives.
// Since we can receive larger packets than this when we get the driver
// info packet, we need to bump up this buffer size.  ideally we would
// allocate enough space at runtime, but this is a safer fix at this point
// in the product.
//
//#define MAXIMUM_TFTP_PACKET_LENGTH (sizeof(TFTP_HEADER) + DEFAULT_BLOCK_SIZE)
#define MAXIMUM_TFTP_PACKET_LENGTH (4096)

#define SWAP_WORD(_w) (USHORT)((((_w) << 8) & 0xff00) | (((_w) >> 8) & 0x00ff))
#define SWAP_DWORD(_dw) (ULONG)((((_dw) << 24) & 0xff000000) | \
                                (((_dw) << 8) & 0x00ff0000) | \
                                (((_dw) >> 8) & 0x0000ff00) | \
                                (((_dw) >> 24) & 0x000000ff))

//
// Packet types.
//
// N.B. The constants below are defined as big-endian USHORTs.
//

#define TFTP_RRQ        0x0100          // Read Request
#define TFTP_WRQ        0x0200          // Write Request
#define TFTP_DATA       0x0300          // Data block
#define TFTP_DACK       0x0400          // Data Acknowledge
#define TFTP_ERROR      0x0500          // Error
#define TFTP_OACK       0x0600          // Options Acknowledge

//
// Values for error codes in ERROR packets.
//
// N.B. The constants below are defined as big-endian USHORTs.
//

#define TFTP_ERROR_UNDEFINED            0x0000
#define TFTP_ERROR_FILE_NOT_FOUND       0x0100
#define TFTP_ERROR_ACCESS_VIOLATION     0x0200
#define TFTP_ERROR_DISK_FULL            0x0300
#define TFTP_ERROR_ILLEGAL_OPERATION    0x0400
#define TFTP_ERROR_UNKNOWN_TRANSFER_ID  0x0500
#define TFTP_ERROR_FILE_EXISTS          0x0600
#define TFTP_ERROR_NO_SUCH_USER         0x0700
#define TFTP_ERROR_OPTION_NEGOT_FAILED  0x0800

//
// Global variables.
//

extern CONNECTION NetTftpConnection;
extern UCHAR NetTftpPacket[3][MAXIMUM_TFTP_PACKET_LENGTH];

//
// External declarations.
//

NTSTATUS
ConnInitialize (
    OUT PCONNECTION *Connection,
    IN USHORT Operation,
    IN ULONG RemoteHost,
    IN USHORT RemotePort,
    IN PUCHAR Filename,
    IN ULONG BlockSize,
#if defined(REMOTE_BOOT_SECURITY)
    IN OUT PULONG SecurityHandle,
#endif // defined(REMOTE_BOOT_SECURITY)
    IN OUT PULONG FileSize
    );

NTSTATUS
ConnReceive (
    IN PCONNECTION Connection,
    OUT PTFTP_PACKET *Packet
    );

PTFTP_PACKET
ConnPrepareSend (
    IN PCONNECTION Connection
    );

VOID
ConnAck (
    IN PCONNECTION Connection
    );

VOID
ConnSendPacket (
    IN PCONNECTION Connection,
    IN PVOID Packet,
    IN ULONG Length
    );

NTSTATUS
ConnWait (
    IN PCONNECTION Connection,
    IN USHORT Opcode,
    OUT PTFTP_PACKET *Packet OPTIONAL
    );

BOOLEAN
ConnRetransmit (
    IN PCONNECTION Connection,
    IN BOOLEAN Timeout
    );

NTSTATUS
ConnSend (
    IN PCONNECTION Connection,
    IN ULONG Length
    );

NTSTATUS
ConnWaitForFinalAck (
    IN PCONNECTION Connection
    );

VOID
ConnError (
    PCONNECTION Connection,
    ULONG RemoteHost,
    USHORT RemotePort,
    USHORT ErrorCode,
    PUCHAR ErrorMessage
    );

ULONG
ConnSafeAtol (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd
    );

ULONG
ConnItoa (
    IN ULONG Value,
    OUT PUCHAR Buffer
    );

//
// UDP definitions.
//

extern USHORT UdpUnicastDestinationPort;

USHORT
UdpAssignUnicastPort (
    VOID
    );

#if 0
VOID
UdpSetMulticastPort (
    IN USHORT DestinationPort,
    IN ULONG DestinationAddress,
    IN USHORT SourcePort,
    IN ULONG SourceAddress
    );
#endif

ULONG
UdpReceive (
    IN PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG RemoteHost,
    OUT PUSHORT RemotePort,
    IN ULONG Timeout
    );

ULONG
UdpSend (
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN ULONG RemoteHost,
    IN USHORT RemotePort
    );

ULONG
tcpxsum (
    IN ULONG cksum,
    IN PUCHAR buf,
    IN ULONG len
    );

#define SysGetRelativeTime ArcGetRelativeTime

//////////////////////////////////////////////////////////////////////////////
//
// Debugging package definitions.
//
//////////////////////////////////////////////////////////////////////////////

#if DBG

extern ULONG NetDebugFlag;

#define DEBUG_ERROR              0x00000001
#define DEBUG_CONN_ERROR         0x00000002
#define DEBUG_LOUD               0x00000004
#define DEBUG_REAL_LOUD          0x00000008
#define DEBUG_STATISTICS         0x00000010
#define DEBUG_SEND_RECEIVE       0x00000020
#define DEBUG_TRACE              0x00000040
#define DEBUG_ARP                0x00000080
#define DEBUG_OSC                0x00000100
#define DEBUG_INITIAL_BREAK      0x80000000

#undef IF_DEBUG
#define IF_DEBUG(_f) if ( (NetDebugFlag & DEBUG_ ## _f) != 0 )

#define DPRINT(_f,_a) IF_DEBUG(_f) DbgPrint _a

#define DEBUG if ( TRUE )

#else // DBG

#undef IF_DEBUG
#define IF_DEBUG(_f) if ( FALSE )
#define DPRINT(_f,_a)
#define DEBUG if ( FALSE )

#endif // else DBG

#endif // _NETFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\netboot.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    netboot.h

Abstract:

    This module defines globally used procedure and data structures used
    by net boot.

Author:

    Chuck Lenzmeier (chuckl) 09-Jan-1997

Revision History:

--*/

#ifndef _NETBOOT_
#define _NETBOOT_

#include <oscpkt.h>    // defines NET_CARD_INFO

#ifdef EFI
#include <efi.h>
#endif

#define NET_DEVICE_ID 'dten'


//
//  The following structure is used to define the parameters of the net
//  volume.  Given a FileId we can access the structure context through
//  the structure context field in the global BlFileTable (e.g.,
//  BlFileTable[FileId].StructureContext).
//

typedef struct _NET_STRUCTURE_CONTEXT {

    ULONG Dummy;

} NET_STRUCTURE_CONTEXT, *PNET_STRUCTURE_CONTEXT;

//
//  The following structure is used to define the location and size of each
//  opened file.  There is one of these of every opened file.  It is part of
//  the union of a BL_FILE_TABLE structuure.  Given a FileId we can access the
//  file context via the BlFileTable (e.g., BlFileTable[FileId].u.NetFileContext)
//

typedef struct _NET_FILE_CONTEXT {

    PUCHAR InMemoryCopy;
    ULONG FileSize;

#if defined(REMOTE_BOOT)
    BOOLEAN CachedFile;
    ULONG CachedFileId;
#endif // defined(REMOTE_BOOT)

} NET_FILE_CONTEXT, *PNET_FILE_CONTEXT;


#if defined(REMOTE_BOOT)
//
// The following defines are for parameter passing between loaders, when switching.
// Each parameter contains a 4-byte quantity which is completely random, and then a
// 4 byte checksum generated by the following formula:
//   CkSum = (((b1 * 2) + b2) * 2) + b3) * 2 + b4
//
#define NET_REBOOT_WRITE_SECRET_ONLY           0x53A590F10000073D
#define NET_REBOOT_DISK_SECRET_VALID           0xE32C78B70000096F
#endif // defined(REMOTE_BOOT)
#define NET_REBOOT_COMMAND_CONSOLE_ONLY        0x83CDA43F000008D3
#define NET_REBOOT_ASR                         0x9cb2521700000863

//
// Global variables available outside of the "network file system" part
// of the loader.
//

extern ULONG NetLocalIpAddress;
extern ULONG NetLocalSubnetMask;

extern ULONG NetServerIpAddress;
extern ULONG NetGatewayIpAddress;

extern CHAR NetBootPath[129];
extern PCHAR NetServerShare;

extern UCHAR NetBootIniContents[1020 + 1];
extern UCHAR NetBootIniPath[256 + 1];

extern USHORT NetMaxTranUnit; // MTU
extern USHORT NetHwAddrLen; // actual length of hardware address
extern USHORT NetHwType; // Type of protocol at the hardware level from rfc1010

extern BOOLEAN NetBootTftpUsedPassword2;

#if defined(_IA64_)
extern EFI_PXE_BASE_CODE *PXEClient;
extern EFI_HANDLE         PXEHandle;
#endif

#if defined(REMOTE_BOOT)

extern BOOLEAN NetBootRepin;
extern BOOLEAN NetworkBootRom;
extern BOOLEAN NetBootCSC;

extern CHAR NetBootActivePartitionName[80];
extern CHAR NetBootCSCPartitionName[80];
extern BOOLEAN NetBootSearchedForCSC;

#endif // defined(REMOTE_BOOT)


//
// Define ARC hooks.
//

ARC_STATUS
NetArcClose (
    IN ULONG FileId
    );

ARC_STATUS
NetArcOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    );

//
// Define file I/O prototypes.
//

ARC_STATUS
NetClose (
    IN ULONG FileId
    );

ARC_STATUS
NetMount (
    IN CHAR * FIRMWARE_PTR MountPath,
    IN MOUNT_OPERATION Operation
    );

ARC_STATUS
NetOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    );

ARC_STATUS
NetRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
NetGetReadStatus (
    IN ULONG FileId
    );

ARC_STATUS
NetSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
NetWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
NetGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    );

ARC_STATUS
NetSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

ARC_STATUS
NetRename (
    IN ULONG FileId,
    IN CHAR * FIRMWARE_PTR NewFileName
    );

ARC_STATUS
NetGetDirectoryEntry (
    IN ULONG FileId,
    IN DIRECTORY_ENTRY * FIRMWARE_PTR DirEntry,
    IN ULONG NumberDir,
    OUT ULONG * FIRMWARE_PTR CountDir
    );

ARC_STATUS
NetInitialize (
    VOID
    );

VOID
NetTerminate (
    VOID
    );

//
//
// Define network helper functions for the loaders.
//

NTSTATUS
NetQueryCardInfo(
    IN OUT PNET_CARD_INFO CardInfo
    );

NTSTATUS
NetQueryDriverInfo(
    IN PNET_CARD_INFO CardInfo,
    IN PCHAR SetupPath,
    IN PCHAR NtBootPathName,
    IN OUT PWCHAR HardwareId,
    IN ULONG HardwareIdLength,  // in bytes
    IN OUT PWCHAR DriverName,
    IN OUT PCHAR DriverNameAnsi,
    IN ULONG DriverNameLength,  // in bytes
    IN OUT PWCHAR ServiceName,
    IN ULONG ServiceNameLength, // in bytes
    OUT PCHAR * Registry,
    OUT ULONG * RegistryLength
    );

#if defined(REMOTE_BOOT)
NTSTATUS
NetCopyHalAndKernel(
    IN PCHAR HalName,
    IN PCHAR Guid,
    IN ULONG GuidLength
    );

NTSTATUS
NetPrepareIpsec(
    IN ULONG InboundSpi,
    OUT ULONG * SessionKey,
    OUT ULONG * OutboundSpi
    );
#endif // defined(REMOTE_BOOT)

VOID
GetGuid(
    OUT PUCHAR *Guid,
    OUT PULONG GuidLength
    );

VOID
NetGetRebootParameters(
    OUT PULONGLONG Param OPTIONAL,
    OUT PUCHAR RebootFile OPTIONAL,
    OUT PUCHAR SifFile OPTIONAL,
    OUT PUCHAR User OPTIONAL,
    OUT PUCHAR Domain OPTIONAL,
    OUT PUCHAR Password OPTIONAL,
    OUT PUCHAR AdministratorPassword OPTIONAL,
    IN BOOLEAN ClearRestartBlock
    );

NTSTATUS
NetSoftReboot(
    IN PUCHAR NextBootFile,
    IN ULONGLONG Param,
    IN PUCHAR RebootFile OPTIONAL,
    IN PUCHAR SifFile OPTIONAL,
    IN PUCHAR User OPTIONAL,
    IN PUCHAR Domain OPTIONAL,
    IN PUCHAR Password OPTIONAL,
    IN PUCHAR AdministratorPassword OPTIONAL
    );

ARC_STATUS
NetFillNetworkLoaderBlock (
    PNETWORK_LOADER_BLOCK NetworkLoaderBlock
    );

#if defined(_ALPHA_)
#define NetFindCSCPartitionName() FALSE
#else
BOOLEAN
NetFindCSCPartitionName(
    VOID
    );
#endif

#endif // _NETBOOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\parseini.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    parseini.h

Abstract:

    Common header file for parsing .ini files

Author:

    John Vert (jvert) 6-Oct-1993

Environment:

    ARC environment

Revision History:

--*/
#include "bldr.h"
#include "setupblk.h"
#include "stdio.h"
#include "stdarg.h"


//
// Defines for *externally* fulfilled error handling routines.  setupldr and osloader each
// have different versions of these routines.
//

#if DEVL

#define SlError(x) SlErrorBox(x , __LINE__, __FILE__ )

#else

#define SlError(x)

#endif

#define SlNoMemoryError() SlNoMemError(__LINE__, __FILE__ )

VOID
SlNoMemError(
    IN ULONG Line,
    IN PCHAR File
    );

VOID
SlBadInfLineError(
    IN ULONG Line,
    IN PCHAR INFFile
    );

VOID
SlErrorBox(
    IN ULONG MessageId,
    IN ULONG Line,
    IN PCHAR File
    );

VOID
SlFatalError(
    IN ULONG MessageId,
    ...
    );

VOID
SlFriendlyError(
    IN ULONG uStatus,
    IN PCHAR pchBadFile,
    IN ULONG uLine,
    IN PCHAR pchCodeFile
    );



//
// Routines for parsing the setupldr.ini file
//

#define SIF_FILENAME_INDEX 0

extern PVOID InfFile;
extern PVOID WinntSifHandle;

ARC_STATUS
SlInitIniFile(
   IN  PCHAR   DevicePath,
   IN  ULONG   DeviceId,
   IN  PCHAR   INFFile,
   OUT PVOID  *pINFHandle,
   OUT PVOID  *pINFBuffer OPTIONAL,
   OUT PULONG  INFBufferSize OPTIONAL,
   OUT PULONG  ErrorLine
   );

PCHAR
SlGetIniValue(
    IN PVOID InfHandle,
    IN PCHAR SectionName,
    IN PCHAR KeyName,
    IN PCHAR Default
    );

#ifdef UNICODE
PWCHAR
SlGetIniValueW(
    IN PVOID InfHandle,
    IN PCHAR SectionName,
    IN PCHAR KeyName,
    IN PWCHAR Default
    );
#endif


PCHAR
SlGetKeyName(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    );

#ifdef UNICODE
PWCHAR
SlGetKeyNameW(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    );
#endif

ULONG
SlGetSectionKeyOrdinal(
    IN  PVOID INFHandle,
    IN  PCHAR SectionName,
    IN  PCHAR Key
    );

PCHAR
SlGetSectionKeyIndex (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN PCHAR Key,
   IN ULONG ValueIndex
   );

#ifdef UNICODE
PWCHAR
SlGetSectionKeyIndexW (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN PCHAR Key,
   IN ULONG ValueIndex
   );
#endif

PTCHAR
SlCopyString(
    IN PTCHAR String
    );

PCHAR
SlCopyStringA(
    IN PCSTR String
    );

PWCHAR
SlCopyStringAW(
    IN PCHAR String
    );

#ifdef UNICODE
#define SlCopyStringAT  SlCopyStringAW
#else
#define SlCopyStringAT  SlCopyStringA
#endif

PCHAR
SlGetSectionLineIndex (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN ULONG LineIndex,
   IN ULONG ValueIndex
   );

#ifdef UNICODE
PWCHAR
SlGetSectionLineIndexW (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN ULONG LineIndex,
   IN ULONG ValueIndex
   );
#endif


ULONG
SlCountLinesInSection(
    IN PVOID INFHandle,
    IN PCHAR SectionName
    );

BOOLEAN
SpSearchINFSection (
   IN PVOID INFHandle,
   IN PCHAR SectionName
   );

PCHAR
SlSearchSection(
    IN PCHAR SectionName,
    IN PCHAR TargetName
    );

ARC_STATUS
SpFreeINFBuffer (
   IN PVOID INFHandle
   );


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\ntfsboot.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsBoot.h

Abstract:

    This module defines globally used procedure and data structures used by Ntfs boot.

Author:

    Gary Kimura     [GaryKi]    10-Apr-1992

Revision History:

--*/

#ifndef _NTFSBOOT_
#define _NTFSBOOT_


//
//  Some important manifest constants.  These are the maximum byte size we'll ever
//  see for a file record or an index allocation buffer.
//

#define MAXIMUM_FILE_RECORD_SIZE         (4096)

#define MAXIMUM_INDEX_ALLOCATION_SIZE    (4096)

#define MAXIMUM_COMPRESSION_UNIT_SIZE    (65536)

//
//  The following structure is an mcb structure for storing cached retrieval pointer
//  information.
//

#define MAXIMUM_NUMBER_OF_MCB_ENTRIES    (16)

typedef struct _NTFS_MCB {

    //
    //  The following fields indicate the number of entries in use by the mcb. and
    //  the mcb itself.  The mcb is just a collection of vbo - lbo pairs.  The last
    //  InUse entry Lbo's value is ignored, because it is only used to give the
    //  length of the previous run.
    //

    ULONG InUse;

    LONGLONG Vbo[ MAXIMUM_NUMBER_OF_MCB_ENTRIES ];
    LONGLONG Lbo[ MAXIMUM_NUMBER_OF_MCB_ENTRIES ];

} NTFS_MCB, *PNTFS_MCB;
typedef const NTFS_MCB *PCNTFS_MCB;

//
//  Define the Ntfs file context structure and the attribute context structure.
//

typedef struct _NTFS_FILE_CONTEXT {

    //
    //  The following field indicates the type of attribute opened
    //

    ULONG TypeCode;

    //
    //  The following field indicates the size of the data portion of the attribute
    //

    LONGLONG DataSize;

    //
    //  The following two fields identify and locate the attribute on the volume.
    //  The first number is the file record where the attribute header is located and
    //  the second number is the offset in the file record of the attribute header
    //

    LONGLONG FileRecord;
    USHORT FileRecordOffset;

    //
    //  The following field indicates if the attribute is resident
    //

    BOOLEAN IsAttributeResident;

    //
    //  The following fields are only used if the data stream is compressed.
    //  If it is compressed then the CompressionFormat field is not zero, and
    //  contains the value to pass to the decompression engine.  CompressionUnit
    //  is the number of bytes in each unit of compression.
    //

    USHORT  CompressionFormat;
    ULONG CompressionUnit;

} NTFS_FILE_CONTEXT, *PNTFS_FILE_CONTEXT;
typedef NTFS_FILE_CONTEXT NTFS_ATTRIBUTE_CONTEXT, *PNTFS_ATTRIBUTE_CONTEXT;
typedef const NTFS_FILE_CONTEXT *PCNTFS_ATTRIBUTE_CONTEXT;

//
//  Define the Ntfs volume structure context
//

typedef struct _NTFS_STRUCTURE_CONTEXT {

    //
    //  This is the device that we talk to
    //

    ULONG DeviceId;

    //
    //  Some volume specific constants that describe the size of various records
    //

    ULONG BytesPerCluster;
    ULONG BytesPerFileRecord;

    //
    //  The following three fields describe the $DATA stream for the the MFT.  We
    //  need two Mcbs one holds the base of the mft and the other to hold any excess
    //  retrival information.  I.e., we must not loose the base mcb otherwise we
    //  can't find anything.
    //

    NTFS_ATTRIBUTE_CONTEXT MftAttributeContext;
    NTFS_MCB MftBaseMcb;

    //
    //  The following three fields hold a cached mcb that we use for non-resident
    //  attributes other than the mft data stream.  The first two fields identify the
    //  attribute and the third field contains the cached mcb.
    //

    LONGLONG CachedMcbFileRecord[16];
    USHORT CachedMcbFileRecordOffset[16];
    NTFS_MCB CachedMcb[16];

} NTFS_STRUCTURE_CONTEXT, *PNTFS_STRUCTURE_CONTEXT;
typedef const NTFS_STRUCTURE_CONTEXT *PCNTFS_STRUCTURE_CONTEXT;


//
// Define file I/O prototypes.
//

ARC_STATUS
NtfsClose (
    IN ULONG FileId
    );

ARC_STATUS
NtfsOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    );

ARC_STATUS
NtfsRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
NtfsSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
NtfsWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
NtfsGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    );

ARC_STATUS
NtfsSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

ARC_STATUS
NtfsInitialize(
    VOID
    );

#endif // _NTFSBOOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\ramdisk.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ramdisk.h

Abstract:

    Provides the ARC emulation routines for I/O to a RAM disk device.

Author:

    Chuck Lenzmeier (chuckl) 29-Apr-2001

Revision History:

--*/


//
// Ramdisk error Codes. These are defined in \bldr\msg.* or 
// \setup\msgs.*. They are redefined here since ramdisk.c
// is in \lib and is used in both osloader and setupldr.
//
#define RAMDISK_GENERAL_FAILURE             15000
#define RAMDISK_INVALID_OPTIONS             15001
#define RAMDISK_BUILD_FAILURE               15002
#define RAMDISK_BOOT_FAILURE                15003
#define RAMDISK_BUILD_DISCOVER              15004
#define RAMDISK_BUILD_REQUEST               15005
#define RAMDISK_BUILD_PROGRESS_TIMEOUT      15006
#define RAMDISK_BUILD_PROGRESS_PENDING      15007
#define RAMDISK_BUILD_PROGRESS_ERROR        15008
#define RAMDISK_BUILD_PROGRESS              15009
#define RAMDISK_DOWNLOAD                    15010
#define RAMDISK_DOWNLOAD_NETWORK            15011
#define RAMDISK_DOWNLOAD_NETWORK_MCAST      15012

//
// Ramdisk Initialization
//

ARC_STATUS
RamdiskInitialize(
    IN PCHAR LoadOptions,
    IN BOOLEAN SdiBoot
    );

#if defined(_X86_)
VOID
RamdiskSdiBoot(
    PCHAR SdiFile
    );
#endif

//
// ARC I/O functions
//

ARC_STATUS
RamdiskClose(
    IN ULONG FileId
    );

ARC_STATUS
RamdiskMount(
    IN CHAR * FIRMWARE_PTR MountPath,
    IN MOUNT_OPERATION Operation
    );

ARC_STATUS
RamdiskOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
RamdiskRead(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
RamdiskReadStatus(
    IN ULONG FileId
    );

ARC_STATUS
RamdiskSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
RamdiskWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
RamdiskGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION Finfo
    );

ARC_STATUS
RamdiskSetFileInfo (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

ARC_STATUS
RamdiskRename (
    IN ULONG FileId,
    IN CHAR * FIRMWARE_PTR NewName
    );

ARC_STATUS
RamdiskGetDirectoryEntry (
    IN ULONG FileId,
    OUT PDIRECTORY_ENTRY Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

//
// Global variables
//

ULONG_PTR SdiAddress;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\pxe.h ===
/*
 *
 * Modifications:   $Header:   V:/archives/INCLUDE/pxe.h_v   1.1   Apr 16 1997 15:55:56   PWICKERX  $
 *
 * Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
 *
 */

/* Sample PXE Constants for Extensions to DHCP Protocol */

/* All numbers are temporary for testing and subject to review */

/* sample UDP port assigned to PXE/BINL */
#define PXE_BINL_PORT		256

#define PXE_CLS_CLIENT		"PXEClient"

#define PXE_LCMSERVER_TAG	179 /* Option tag for Server. */
#define PXE_LCMDOMAIN_TAG	180 /* Option tag for Domain. */
#define PXE_LCMNICOPT0_TAG	181 /* Option tag for NIC option 0. */
#define PXE_LCMWRKGRP_TAG	190 /* Option tag for Work group. */

/* 43 options used by bstrap.1 */
#define	PXE_NIC_PATH		64	/* 64,len,'name',0 */
#define	PXE_MAN_INFO		65	/* 65,len,ip2,ip3,'name',0 */
#define	PXE_OS_INFO			66	/* 66,len,ip2,ip3,'name',0,'text',0 */

/* externally specified "PXEClient" class 43 options */
#define PXE_MTFTP_IP		1
#define PXE_MTFTP_CPORT		2
#define PXE_MTFTP_SPORT		3
#define PXE_MTFTP_TMOUT		4
#define PXE_MTFTP_DELAY		5

/* EOF - $Workfile:   pxe.h  $ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\scsiboot.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    scsiboot.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    the common SCSI boot port driver.

Author:

    Jeff Havens  (jhavens) 28-Feb-1991
    Mike Glass

Revision History:

--*/

#include "ntddscsi.h"

//
// SCSI Get Configuration Information
//
// LUN Information
//

typedef struct _LUNINFO {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    BOOLEAN DeviceClaimed;
    PVOID DeviceObject;
    struct _LUNINFO *NextLunInfo;
    UCHAR InquiryData[INQUIRYDATABUFFERSIZE];
} LUNINFO, *PLUNINFO;

typedef struct _SCSI_BUS_SCAN_DATA {
    USHORT Length;
    UCHAR InitiatorBusId;
    UCHAR NumberOfLogicalUnits;
    PLUNINFO LunInfoList;
} SCSI_BUS_SCAN_DATA, *PSCSI_BUS_SCAN_DATA;

typedef struct _SCSI_CONFIGURATION_INFO {
    UCHAR NumberOfBuses;
    PSCSI_BUS_SCAN_DATA BusScanData[1];
} SCSI_CONFIGURATION_INFO, *PSCSI_CONFIGURATION_INFO;

#define MAXIMUM_RETRIES 4

//
// SCSI device timeout values in seconds
//

#define SCSI_DISK_TIMEOUT   10
#define SCSI_CDROM_TIMEOUT  10
#define SCSI_TAPE_TIMEOUT  120

//
// Adapter object transfer information.
//

typedef struct _ADAPTER_TRANSFER {
    PSCSI_REQUEST_BLOCK Srb;
    PVOID LogicalAddress;
    ULONG Length;
}ADAPTER_TRANSFER, *PADAPTER_TRANSFER;

typedef struct _SRB_SCATTER_GATHER {
    ULONG PhysicalAddress;
    ULONG Length;
}SRB_SCATTER_GATHER, *PSRB_SCATTER_GATHER;

//
// Srb Structure plus extra storage for the port driver.
//

#define IRP_STACK_SIZE 2

typedef struct _FULL_SCSI_REQUEST_BLOCK {
    SCSI_REQUEST_BLOCK Srb;
    PVOID PreviousIrp;
    IRP Irp;
    IO_STACK_LOCATION IrpStack[IRP_STACK_SIZE];
    ULONG SrbExtensionSize;
    MDL Mdl;
    ULONG PageFrame[20];
}FULL_SCSI_REQUEST_BLOCK, *PFULL_SCSI_REQUEST_BLOCK;

//
// Logical unit extension
//

typedef struct _LOGICAL_UNIT_EXTENSION {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    ULONG Flags;
    PIRP CurrentRequest;
    KSPIN_LOCK CurrentRequestSpinLock;
    PVOID SpecificLuExtension;
    struct _LOGICAL_UNIT_EXTENSION *NextLogicalUnit;
    KDEVICE_QUEUE RequestQueue;
    KSPIN_LOCK RequestQueueSpinLock;
    LONG RequestTimeoutCounter;
    ULONG RetryCount;
    UCHAR NumberOfLogicalUnits;
    PVOID MapRegisterBase;
    ULONG NumberOfMapRegisters;
    SRB_SCATTER_GATHER ScatterGather[17];
} LOGICAL_UNIT_EXTENSION, *PLOGICAL_UNIT_EXTENSION;

//
// Device extension
//

typedef struct _DEVICE_EXTENSION {

    PDEVICE_OBJECT DeviceObject;

    //
    // Dma Adapter information.
    //

    PVOID MapRegisterBase;
    PADAPTER_OBJECT DmaAdapterObject;
    ADAPTER_TRANSFER FlushAdapterParameters;

    //
    // Number of SCSI buses
    //

    UCHAR NumberOfBuses;

    //
    // Maximum targets per bus
    //

    UCHAR MaximumTargetIds;

    //
    // SCSI Capabilities structure
    //

    IO_SCSI_CAPABILITIES Capabilities;

    //
    // SCSI port driver flags
    //

    ULONG Flags;

    //
    // SCSI port interrupt flags
    //

    ULONG InterruptFlags;

    //
    // List head for singlely linked list of complete IRPs.
    //

    PIRP CompletedRequests;

    //
    // Adapter object transfer parameters.
    //

    ADAPTER_TRANSFER MapTransferParameters;

    KSPIN_LOCK SpinLock;

    //
    // Miniport Initialization Routine
    //

    PHW_INITIALIZE HwInitialize;

    //
    // Miniport Start IO Routine
    //

    PHW_STARTIO HwStartIo;

    //
    // Miniport Interrupt Service Routine
    //

    PHW_INTERRUPT HwInterrupt;

    //
    // Miniport Reset Routine
    //

    PHW_RESET_BUS HwReset;

    //
    // Miniport DMA started Routine
    //

    PHW_DMA_STARTED HwDmaStarted;

    //
    // Buffers must be mapped into system space.
    //

    BOOLEAN MapBuffers;

    //
    // Is this device a bus master and does it require map registers.
    //

    BOOLEAN MasterWithAdapter;
    //
    // Device extension for miniport routines.
    //

    PVOID HwDeviceExtension;

    //
    // Miniport request interrupt enabled/disable routine.
    //

    PHW_INTERRUPT HwRequestInterrupt;

    //
    // Miniport timer request routine.
    //

    PHW_INTERRUPT HwTimerRequest;

    //
    // Adapter control routine.
    //

    PHW_ADAPTER_CONTROL HwAdapterControl;

    //
    // SCSI configuration information from inquiries.
    //

    PSCSI_CONFIGURATION_INFO ScsiInfo;

    //
    // Miniport noncached device extension
    //

    PVOID NonCachedExtension;

    //
    // The length of the non-cached extension
    //

    ULONG NonCachedExtensionSize;

    //
    // SrbExtension Zone Pool
    //

    PVOID SrbExtensionZonePool;
    PCHAR SrbExtensionPointer;

    //
    // Physical address of zone pool
    //

    ULONG PhysicalZoneBase;

    //
    // Size of Srb extension.
    //

    ULONG SrbExtensionSize;

    //
    // Spinlock for zoned hash table entries
    //

    KSPIN_LOCK ZoneSpinLock;

    //
    // Logical Unit Extension
    //

    ULONG HwLogicalUnitExtensionSize;

    PLOGICAL_UNIT_EXTENSION LogicalUnitList;


    ULONG TimerValue;

    //
    // Port timing count.
    //

    LONG PortTimeoutCounter;

    //
    // Shutdown Information.
    //

    BOOLEAN HasShutdown;
    BOOLEAN HasSetBoot;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define DEVICE_EXTENSION_SIZE sizeof(DEVICE_EXTENSION)

//
// Port driver extension flags.
//

#define PD_CURRENT_IRP_VALID         0X0001
#define PD_RESET_DETECTED            0X0002
#define PD_NOTIFICATION_IN_PROGRESS  0X0004
#define PD_READY_FOR_NEXT_REQUEST    0X0008
#define PD_FLUSH_ADAPTER_BUFFERS     0X0010
#define PD_MAP_TRANSFER              0X0020
#define PD_CALL_DMA_STARTED          0X01000
#define PD_DISABLE_CALL_REQUEST      0X02000
#define PD_DISABLE_INTERRUPTS        0X04000
#define PD_ENABLE_CALL_REQUEST       0X08000
#define PD_TIMER_CALL_REQUEST        0X10000

//
// Logical unit extension flags.
//

#define PD_QUEUE_FROZEN              0X0001
#define PD_LOGICAL_UNIT_IS_ACTIVE    0X0002
#define PD_CURRENT_REQUEST_COMPLETE  0X0004
#define PD_LOGICAL_UNIT_IS_BUSY      0X0008

//
// The timer interval for the miniport timer routine specified in
// units of 100 nanoseconds.
//
#define PD_TIMER_INTERVAL (250 * 1000 * 10)   // 250 ms

#define PD_TIMER_RESET_HOLD_TIME    4

//
// The define the interloop stall.
//

#define PD_INTERLOOP_STALL 5

#define MINIMUM_SRB_EXTENSIONS 8
#define COMPLETION_DELAY 10

//
// Port driver error logging
//

#define ERROR_LOG_ENTRY_LENGTH 8

typedef struct _ERROR_LOG_ENTRY {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    ULONG ErrorCode;
    ULONG UniqueId;
} ERROR_LOG_ENTRY, *PERROR_LOG_ENTRY;


//
// Define global data structures
//

extern ULONG ScsiPortCount;
extern FULL_SCSI_REQUEST_BLOCK PrimarySrb;
extern FULL_SCSI_REQUEST_BLOCK AbortSrb;

#define MAXIMUM_NUMBER_OF_SCSIPORT_OBJECTS 16
extern PDEVICE_OBJECT ScsiPortDeviceObject[MAXIMUM_NUMBER_OF_SCSIPORT_OBJECTS];

extern PREAD_CAPACITY_DATA ReadCapacityBuffer;
extern PUCHAR SenseInfoBuffer;

//
// Support routine.
//

PIRP
InitializeIrp(
   PFULL_SCSI_REQUEST_BLOCK FullSrb,
   CCHAR MajorFunction,
   PVOID DeviceObject,
   PVOID BufferPointer,
   ULONG BufferSize
   );


ARC_STATUS
GetAdapterCapabilities(
    IN PDEVICE_OBJECT PortDeviceObject,
    OUT PIO_SCSI_CAPABILITIES *PortCapabilities
    );

ARC_STATUS
GetInquiryData(
    IN PDEVICE_OBJECT PortDeviceObject,
    IN PSCSI_CONFIGURATION_INFO *ConfigInfo
    );

ARC_STATUS
ReadDriveCapacity(
    IN PPARTITION_CONTEXT PartitionContext
    );

ARC_STATUS
ScsiClassIoComplete(
    IN PPARTITION_CONTEXT PartitionContext,
    IN PIRP Irp,
    IN PVOID Context
    );

ARC_STATUS
SendSrbSynchronous(
        PPARTITION_CONTEXT PartitionContext,
        PSCSI_REQUEST_BLOCK Srb,
        PVOID BufferAddress,
        ULONG BufferLength,
        BOOLEAN WriteToDevice
        );

BOOLEAN
InterpretSenseInfo(
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT ARC_STATUS *Status,
    PPARTITION_CONTEXT PartitionContext
    );

VOID
RetryRequest(
    PPARTITION_CONTEXT PartitionContext,
    PIRP Irp
    );

PIRP
BuildRequest(
    IN PPARTITION_CONTEXT PartitionContext,
    IN PMDL Mdl,
    IN ULONG LogicalBlockAddress,
    IN BOOLEAN Operation
    );


//
// Define the necessary functions to simulate the I/O environment.
//

#define ExAllocatePool(Type, Size) FwAllocatePool(Size)

#if !defined(_MIPS_) && !defined(_ALPHA_) && !defined(_PPC_)
#define PAUSE while (!GET_KEY());

typedef struct _DRIVER_LOOKUP_ENTRY {
    PCHAR                    DevicePath;
    PBL_DEVICE_ENTRY_TABLE   DispatchTable;
} DRIVER_LOOKUP_ENTRY, *PDRIVER_LOOKUP_ENTRY;
#undef ASSERT
#define ASSERT( exp ) { \
    if (!(#exp)) {         \
        BlPrint("ASSERT File: %s line: %lx\n", __FILE__, __LINE__); \
    PAUSE; \
    }   \
}

VOID
ScsiPortExecute(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#endif

#if defined ExFreePool
#undef ExFreePool
#endif
#define ExFreePool(Size)

#ifdef IoCallDriver
#undef IoCallDriver
#endif
#define IoCallDriver(DeviceObject, Irp) (       \
    DeviceObject->CurrentIrp = Irp,             \
    Irp->Tail.Overlay.CurrentStackLocation--,   \
    ScsiPortExecute(DeviceObject, Irp),         \
    Irp->Tail.Overlay.CurrentStackLocation++ )
#ifdef IoCompleteRequest
#undef IoCompleteRequest
#endif
#define IoCompleteRequest(Irp, Boost) Irp->PendingReturned = FALSE
#define IoAllocateErrorLogEntry(DeviceObject, Length) NULL
#define IoWriteErrorLogEntry(Entry)
#ifdef KeAcquireSpinLock
#undef KeAcquireSpinLock
#endif
#define KeAcquireSpinLock(Lock, Irql)
#ifdef KeReleaseSpinLock
#undef KeReleaseSpinLock
#endif
#define KeReleaseSpinLock(Lock, Irql)
#define KiAcquireSpinLock(Lock)
#ifdef KiReleaseSpinLock
#undef KiReleaseSpinLock
#endif
#define KiReleaseSpinLock(Lock)
#define KeSynchronizeExecution(InterruptObject, ExecutionRoutine, Context) \
    (ExecutionRoutine)(Context)

#ifdef KeRaiseIrql
#undef KeRaiseIrql
#endif
#define KeRaiseIrql(NewLevel, OldLevel)
#ifdef KeLowerIrql
#undef KeLowerIrql
#endif
#define KeLowerIrql(Level)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\pxe_cmn.h ===
/*
 *
 * Modifications:   $Header:   H:/ARCHIVES/preboot/lsa2/inc/pxe_cmn.h_v   1.3   May 09 1997 08:50:12   vprabhax  $
 *
 * Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
 *
 */

#ifndef _PXENV_CMN_H
#define _PXENV_CMN_H

/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* PXENV.H - PXENV/TFTP/UNDI API common, Version 2.x, 97-Jan-17
 *
 * Constant and type definitions used in other PXENV API header files.
 */


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* Parameter/Result structure storage types.
 */
#ifndef _BASETSD_H_
typedef signed char INT8;
typedef signed short INT16;
typedef signed long INT32;
typedef unsigned char UINT8;
typedef unsigned short UINT16;
typedef unsigned long UINT32;
#endif

/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* Result codes returned in AX by a PXENV API service.
 */
#define PXENV_EXIT_SUCCESS	0x0000
#define PXENV_EXIT_FAILURE	0x0001
#define	PXENV_EXIT_CHAIN		0xFFFF	/* used internally */


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* CPU types
 */
#define	PXENV_CPU_X86		0
#define	PXENV_CPU_ALPHA		1
#define	PXENV_CPU_PPC		2


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* Bus types
 */
#define	PXENV_BUS_ISA		0
#define	PXENV_BUS_EISA		1
#define	PXENV_BUS_MCA		2
#define	PXENV_BUS_PCI		3
#define	PXENV_BUS_VESA		4
#define	PXENV_BUS_PCMCIA		5


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* Status codes returned in the status word of PXENV API parameter structures.
 */

/* General errors */
#define PXENV_STATUS_SUCCESS	0x00
#define	PXENV_STATUS_FAILURE	0x01	/* General failure. */
#define	PXENV_STATUS_BAD_FUNC	0x02	/* Invalid function number. */
#define	PXENV_STATUS_UNSUPPORTED	0x03	/* Function is not yet supported. */
#define	PXENV_STATUS_1A_HOOKED	0x04	/* Int 1Ah cannot be unhooked. */

/* ARP errors */
#define	PXENV_STATUS_ARP_TIMEOUT				0x11

/* TFTP errors */
#define	PXENV_STATUS_TFTP_CANNOT_ARP_ADDRESS		0x30
#define	PXENV_STATUS_TFTP_OPEN_TIMEOUT			0x32
#define	PXENV_STATUS_TFTP_UNKNOWN_OPCODE			0x33
#define	PXENV_STATUS_TFTP_ERROR_OPCODE			0x34
#define	PXENV_STATUS_TFTP_READ_TIMEOUT			0x35
#define	PXENV_STATUS_TFTP_WRITE_TIMEOUT			0x37
#define	PXENV_STATUS_TFTP_CANNOT_OPEN_CONNECTION		0x38
#define	PXENV_STATUS_TFTP_CANNOT_READ_FROM_CONNECTION	0x39
#define	PXENV_STATUS_TFTP_CANNOT_WRITE_TO_CONNECTION	0x3A

/* BOOTP errors */
#define	PXENV_STATUS_BOOTP_TIMEOUT			0x41
#define	PXENV_STATUS_BOOTP_NO_CLIENT_OR_SERVER_IP		0x42
#define	PXENV_STATUS_BOOTP_NO_BOOTFILE_NAME		0x43
#define	PXENV_STATUS_BOOTP_CANNOT_ARP_REDIR_SRVR		0x44

/* DHCP errors */
#define	PXENV_STATUS_DHCP_TIMEOUT				0x51

#define PXENV_STATUS_UNDI_MEDIATEST_FAILED 		0x61

/* MTFTP errors */
#define	PXENV_STATUS_MTFTP_CANNOT_ARP_ADDRESS		0x90
#define	PXENV_STATUS_MTFTP_OPEN_TIMEOUT			0x92
#define	PXENV_STATUS_MTFTP_UNKNOWN_OPCODE			0x93
#define	PXENV_STATUS_MTFTP_READ_TIMEOUT			0x95
#define	PXENV_STATUS_MTFTP_WRITE_TIMEOUT			0x97
#define	PXENV_STATUS_MTFTP_CANNOT_OPEN_CONNECTION		0x98
#define	PXENV_STATUS_MTFTP_CANNOT_READ_FROM_CONNECTION	0x99
#define	PXENV_STATUS_MTFTP_CANNOT_WRITE_TO_CONNECTION	0x9A
#define	PXENV_STATUS_MTFTP_CANNOT_INIT_NIC_FOR_MCAST	0x9B
#define	PXENV_STATUS_MTFTP_TOO_MANY_PACKAGES		0x9C
#define	PXENV_STATUS_MTFTP_MCOPY_PROBLEM		0x9D


#endif /* _PXENV_CMN_H */

/* EOF - $Workfile:   pxe_cmn.h  $ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\tftp_api.h ===
/*
 * Modifications:   $Header:   W:/LCS/ARCHIVES/preboot/lsa2/inc/tftp_api.h_v   1.15   Apr 09 1997 21:27:50   vprabhax  $
 *
 * Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
 *
 */

/* TFTP_API.H
 *	Parameter structure and type definitions for TFTP API version 2.x
 *
 *	PXENV.H needs to be #included before this file.
 *
 *	None of the TFTP API services are available after the stack
 *	has been unloaded.
 */

#ifndef _TFTP_API_H
#define _TFTP_API_H


#include "pxe_cmn.h"


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* #defines and constants
 */

/* One of the following command op-codes needs to be loaded into the
 * op-code register (BX) before making a call a TFTP API service.
 */
#define PXENV_TFTP_OPEN			0x20
#define PXENV_TFTP_CLOSE		0x21
#define PXENV_TFTP_READ			0x22
#define PXENV_TFTP_READ_FILE	0x23


/* Definitions of TFTP API parameter structures.
 */

typedef struct s_PXENV_TFTP_OPEN {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
	UINT8 ServerIPAddress[4]; 	/* In: 32-bit server IP */
					/*     address. Big-endian. */
	UINT8 GatewayIPAddress[4]; 	/* In: 32-bit gateway IP */
					/*     address. Big-endian. */
	UINT8 FileName[128];		
	UINT16 TFTPPort; 		/* In: Socket endpoint at */
					/*     which the TFTP server is */
					/*     listening to requests. */
					/*     Big-endian. */
} t_PXENV_TFTP_OPEN;


typedef struct s_PXENV_TFTP_CLOSE {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
} t_PXENV_TFTP_CLOSE;


typedef struct s_PXENV_TFTP_READ {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
	UINT16 PacketNumber;		/* Out: 16-bit packet number. */
	UINT16 BufferSize;		/* In: Size of the receive */
					/*     buffer in bytes. */
					/* Out: Size of the packet */
					/*      written into the buffer. */
	UINT16 BufferOffset;		/* In: Segment/Selector and */
	UINT16 BufferSegment;		/*     offset of the receive buffer. */
					/* Out: Unchanged */
} t_PXENV_TFTP_READ;

#include <pshpack2.h>

typedef struct s_PXENV_TFTP_READ_FILE {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
	UINT8 FileName[128];		/* In: file to be read */
	UINT32 BufferSize;		/* In: Size of the receive */
					/*     buffer in bytes. */
					/* Out: Size of the file */
					/*      written into the buffer. */
	UINT32 BufferOffset;		/* In: 32-bit physical address of the */
					/*     buffer to load the file into. */
	UINT8 ServerIPAddress[4]; 	/* In: 32-bit server IP */
					/*     address. Big-endian. */
	UINT8 GatewayIPAddress[4]; 	/* In: 32-bit gateway IP */
					/*     address. Big-endian. */
	UINT8 McastIPAddress[4]; 	/* In: 32-bit multicast IP address */
					/*     on which file can be received */
					/*     can be null for unicast */
	UINT16 TFTPClntPort; 		/* In: Socket endpoint on the Client */
					/*     at which the file can be */
					/*     received in case of Multicast */
	UINT16 TFTPSrvPort; 		/* In: Socket endpoint at which */
					/*     server listens for requests. */
	UINT16 TFTPOpenTimeOut;		/* In: Timeout value in seconds to be */
					/*     used for receiving data or ACK */
					/*     packets.  If zero, default */
					/*     TFTP-timeout is used. */
	UINT16 TFTPReopenDelay;		/* In: wait time in seconds to delay */
					/*     a reopen request in case of */
					/*     multicast. */
} t_PXENV_TFTP_READ_FILE;

#include <poppack.h>

/* Note:
	If the McastIPAddress specifies a non-zero value, the TFTP_ReadFile call
	tries to listen for multicast packets on the TFTPClntPort before
	opening a TFTP/MTFTP connection to the server.
	If it receives any packets (and not all) or if does not receive any,
	it waits for specified time and tries to reopen a multicast connection
	to the server.
	If the server supports multicast, it notifies the acknowledging client
	with a unicast and starts sending (multicast) the file.
	If the multicast open request times out, the client tries to connect to
	the server at TFTP server port for a unicast transfer.
*/


#endif /* _TFTP_API_H */

/* EOF - $Workfile:   tftp_api.h  $ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\pxe_api.h ===
/*
 *
 * Modifications:   $Header:   J:/Archives/preboot/lsa2/inc/pxe_api.h_v   1.0   May 02 1997 17:01:00   MJOHNSOX  $
 *
 * Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
 *
 */

#ifndef _PXENV_API_H
#define	_PXENV_API_H

/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/*	Parameter structure and type definitions for PXENV API version 2.x
 *
 *	PXENV.H needs to be #included before this file.
 *
 *	None of the PXENV API services are available after the stack
 *	has been unloaded.
 */

#include "bootp.h"			/* Defines BOOTPLAYER */


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* Format of PXENV entry point structure.
 */
typedef struct s_PXENV_ENTRY {
	UINT8 signature[6];		/* 'PXENV+' */
	UINT16 version;			/* MSB=major, LSB=minor */
	UINT8 length;			/* sizeof(struct s_PXENV_ENTRY) */
	UINT8 checksum;			/* 8-bit checksum off structure, */
					/* including this bytes should */
					/* be 0. */
	UINT16 rm_entry_off;		/* 16-bit real-mode offset and */
	UINT16 rm_entry_seg;		/* segment of the PXENV API entry */
					/* point. */
	UINT16 pm_entry_off;		/* 16-bit protected-mode offset */
	UINT32 pm_entry_seg;		/* and segment base address of */
					/* the PXENV API entry point. */
    /* The PROM stack, base code and data segment selectors are only */
    /* required until the base code (TFTP API) layer is removed from */
    /* memory (this can only be done in real mode). */
    UINT16 stack_sel;           /* PROM stack segment. Will be set */
    UINT16 stack_size;          /* to 0 when removed from memory. */
    UINT16 base_cs_sel;         /* Base code segment. Will be set */
    UINT16 base_cs_size;        /* to 0 when removed from memory. */
    UINT16 base_ds_sel;         /* Base data segment. Will be set */
    UINT16 base_ds_size;        /* to 0 when removed from memory. */
    UINT16 mlid_ds_sel;         /* MLID data segment. Will be set */
    UINT16 mlid_ds_size;        /* to 0 when removed from memory. */
    UINT16 mlid_cs_sel;         /* MLID code segment. Will be set */
    UINT16 mlid_cs_size;        /* to 0 when removed from memory. */
#if 0
    UINT16 unknown1;            /* The V1.0 beta ROM added two extra unknown fields. */
    UINT16 unknown2;            /* They are not included in the definition here in   */
                                /* order to allow startrom\main.c\PxenvVerifyEntry   */
                                /* to work with older ROMs.                          */
#endif
} t_PXENV_ENTRY;

#define	PXENV_ENTRY_SIG			"PXENV+"


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* One of the following command op-codes needs to be loaded into the
 * op-code register (BX) before making a call a PXENV API service.
 */
#define PXENV_UNLOAD_STACK		0x70
#define PXENV_GET_BINL_INFO		0x71
#define	PXENV_RESTART_DHCP		0x72
#define	PXENV_RESTART_TFTP		0x73
#define	PXENV_GET_RAMD_INFO		0x74


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* PXENV API parameter structure typedefs.
 */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
typedef struct s_PXENV_UNLOAD_STACK {
	UINT16 status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
	UINT16 rm_entry_off;		/* Out: 16-bit real-mode segment and */
	UINT16 rm_entry_seg;		/*      offset of PXENV Entry Point */
					/*      structure. */
	UINT16 pm_entry_off;		/* Out: 16-bit protected-mode offset */
	UINT32 pm_entry_base;		/*      and segment base address of */
					/*      PXENV Entry Point structure. */
} t_PXENV_UNLOAD_STACK;


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
/* Packet types that can be requested in the s_PXENV_GET_BINL_INFO structure. */
#define PXENV_PACKET_TYPE_DHCP_DISCOVER  1
#define PXENV_PACKET_TYPE_DHCP_ACK       2
#define PXENV_PACKET_TYPE_BINL_REPLY     3

/* Three packets are preserved and available through this interface: 1) The
 * DHCP Discover packet sent by the client, 2) the DHCP acknowledgement
 * packet returned by the DHCP server, and 3) the reply packet from the BINL
 * server.  If the DHCP server provided the image bootfile name, the
 * DHCP_ACK and BINL_REPLY packets will identical.
 */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
typedef struct s_PXENV_GET_BINL_INFO {
	UINT16 status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
	UINT16 packet_type;		/* In: See PXENV_PACKET_TYPE_xxx */
					/*     constants */
	UINT16 buffer_size;		/* In: Size of the buffer in */
					/*     bytes.  Specifies the maximum */
					/*     amount of data that will be */
					/*     copied by the service.  A size */
					/*     of zero is valid. */
					/* Out: Amount of BINL data, in */
					/*      bytes, that was copied into */
					/*      the buffer.  For an input */
					/*      size of zero, no data will be */
					/*      copied and buffer_size will */
					/*      be set to the maximum amount */
					/*      of data available to be */
					/*      copied. */
	UINT16 buffer_offset;		/* In: 16-bit offset and segment */
	UINT16 buffer_segment;		/*     selector of a buffer where the */
					/*     requested packet will be */
					/*     copied. */
} t_PXENV_GET_BINL_INFO;


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
typedef struct s_PXENV_RESTART_DHCP {
	UINT16 status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
} t_PXENV_RESTART_DHCP;


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
#define	s_PXENV_RESTART_TFTP	s_PXENV_TFTP_READ_FILE
#define	t_PXENV_RESTART_TFTP	t_PXENV_TFTP_READ_FILE


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
typedef struct s_PXENV_GET_RAMD_INFO {
	UINT16 status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
	UINT32 ramd_info;		/* Out: Far pointer to RAMDisk */
					/*      information structure. */
} t_PXENV_GET_RAMD_INFO;


typedef struct s_PXENV_RAMD_INFO {
	UINT16 orig_fbms;		/* Original free base memory size. */
	UINT32 ramd_addr;		/* RAMDisk physical address. */
	UINT32 orig_int13;		/* Original Int 13h ISR. */
	UINT32 orig_int1A;		/* Original Int 1Ah ISR. */
	UINT32 orig_pxenv;
	UINT16 dhcp_discover_seg;	/* Segment address & length of */
	UINT16 dhcp_discover_len;	/* DHCP discover packet. */
	UINT16 dhcp_ack_seg;		/* Segment address & length of */
	UINT16 dhcp_ack_len;		/* DHCP ack packet. */
	UINT16 binl_reply_seg;		/* Segment address & length of */
	UINT16 binl_reply_len;		/* BINL reply packet. */
	UINT16 flags;			/* RAMDisk operation flags. */
	UINT16 xms_page;		/* XMS page number of relocated */
					/* RAMDisk image.  0 == use Int 87h. */
	UINT32 xms_entry;		/* XMS API entry point. */
} t_PXENV_RAMD_INFO;


#define	PXENV_RAMD_FLAG_DISABLE		0x0001
#define	PXENV_RAMD_FLAG_PROTECTED	0x0002


#endif /* _PXENV_API_H */

/* EOF - $Workfile:   pxe_api.h  $ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\udfsboot.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    UDFSBoot.h

Abstract:

    This module defines globally used procedure and data structures used
    by CD/DVD boot for UDF images.

Author:

	Vijayachandran Jayaseelan (vijayj@microsoft.com)

Revision History:

--*/

#ifndef _UDFSBOOT_
#define _UDFSBOOT_

#include <udf.h>

#ifdef __cplusplus
extern "C" {
#endif

#define UDF_BLOCK_SIZE	2048
#define UDF_MAX_VOLUMES	1

//
// forward declarations
//
typedef struct _UDF_VOLUME* PUDF_VOLUME;
typedef struct _UDF_CACHE_ENTRY* PUDF_CACHE_ENTRY;
typedef struct _UDF_FILE_DIRECTORY* PUDF_FILE_DIRECTORY;
typedef PVOID PUDF_BLOCK;

//
// Volume abstraction
//
typedef struct _UDF_VOLUME {
  PUDF_CACHE_ENTRY  Cache;
  ULONG             StartBlk;
  ULONG             BlockSize;
  ULONG             DeviceId;
  ULONG             RootDirBlk;
} UDF_VOLUME;


ARC_STATUS
UDFSVolumeOpen(
  IN PUDF_VOLUME	Volume,
  IN ULONG 		DeviceId
  );

ARC_STATUS
UDFSVolumeReadBlock(
  IN PUDF_VOLUME Volume,
  IN ULONG BlockIdx, 
  OUT PUDF_BLOCK Block
  );

//
// File or Directory abstraction
//
typedef struct _UDF_FILE_IDENTIFIER {
  ULONG   BlockIdx;
  USHORT  Offset;		// inside the block
} UDF_FILE_IDENTIFIER, * PUDF_FILE_IDENTIFIER;


typedef struct _UDF_FILE_DIRECTORY {
  PUDF_VOLUME           Volume;
  ULONGLONG             Size;
  ULONG                 IcbBlk;
  ULONG                 StartDataBlk;	
  UDF_FILE_IDENTIFIER   FileId;
  UCHAR                 NumExtents;
  BOOLEAN               IsDirectory;
} UDF_FILE_DIRECTORY;


ARC_STATUS
UDFSDirGetFirstFID(
  IN PUDF_FILE_DIRECTORY Dir, 
  OUT PUDF_FILE_IDENTIFIER File,
  OUT PUDF_BLOCK Block
  );

ARC_STATUS
UDFSDirGetNextFID(
  IN PUDF_FILE_DIRECTORY Dir,
  IN OUT PUDF_FILE_IDENTIFIER File,
  IN OUT PUDF_BLOCK Block
  );

ARC_STATUS
UDFSDirGetFile(
  IN PUDF_FILE_DIRECTORY Dir,
  IN PCHAR Name,
  OUT PUDF_FILE_DIRECTORY File
  );

ARC_STATUS
UDFSFileReadBlock(
  IN PUDF_FILE_DIRECTORY  File,
  IN ULONG BlockIdx,
  IN ULONG Size,
  OUT PUDF_BLOCK Block
  );
	

ARC_STATUS
UDFSFileRead(
  IN PUDF_FILE_DIRECTORY File,
  IN PVOID Buffer,
  IN ULONG BufferSize,
  OUT PULONG Transfer
  );

ARC_STATUS	
UDFSFileSeek(
  IN PUDF_FILE_DIRECTORY File,
  IN PLARGE_INTEGER Offset,
  IN SEEK_MODE SeekMode
  );

ARC_STATUS
UDFSFileClose(
  IN PUDF_FILE_DIRECTORY File
  );

//
// Cache abstractions
//
#define UDF_MAX_PATH_LEN		256
#define UDF_MAX_CACHE_ENTRIES	48

typedef struct _UDF_CACHE_ENTRY {
  CHAR                Name[UDF_MAX_PATH_LEN];
  USHORT              Usage;
  UDF_FILE_DIRECTORY  File;
} UDF_CACHE_ENTRY;


ULONG
UDFCachePutEntry(
  IN OUT PUDF_CACHE_ENTRY Cache,
  IN PCHAR Name, 
  IN PUDF_FILE_DIRECTORY File
  );

ULONG
UDFCacheGetEntryByName(
  IN PUDF_CACHE_ENTRY Cache,
  IN PCHAR Name,
  IN BOOLEAN Increment
  );

VOID
UDFCacheFreeEntry(
  IN OUT PUDF_CACHE_ENTRY Cache,
  IN ULONG Idx
  );

VOID
UDFCacheIncrementUsage(
  IN OUT PUDF_CACHE_ENTRY Cache,
  IN ULONG Idx
  );

VOID
UDFCacheDecrementUsage(
  IN OUT PUDF_CACHE_ENTRY Cache,
  IN ULONG Idx
  );

//
// abstractions used by outside (loader) world
//
typedef struct _UDFS_STRUCTURE_CONTEXT {
  PUDF_VOLUME Volume;
} UDFS_STRUCTURE_CONTEXT, *PUDFS_STRUCTURE_CONTEXT;

//
// Define UDFS file context structure.
//
typedef struct _UDFS_FILE_CONTEXT {
  ULONG CacheIdx;
} UDFS_FILE_CONTEXT, *PUDFS_FILE_CONTEXT;

//
// Define file I/O prototypes.
//
PBL_DEVICE_ENTRY_TABLE
IsUDFSFileStructure (
  IN ULONG DeviceId,
  IN PVOID StructureContext
  );

ARC_STATUS
UDFSOpen (
  IN CHAR * FIRMWARE_PTR OpenPath,
  IN OPEN_MODE OpenMode,
  OUT ULONG * FIRMWARE_PTR FileId
  );

ARC_STATUS
UDFSClose (
  IN ULONG FileId
  );
    
ARC_STATUS
UDFSRead (
  IN ULONG FileId,
  OUT VOID * FIRMWARE_PTR Buffer,
  IN ULONG Length,
  OUT ULONG * FIRMWARE_PTR Count
  );

ARC_STATUS
UDFSSeek (
  IN ULONG FileId,
  IN LARGE_INTEGER * FIRMWARE_PTR Offset,
  IN SEEK_MODE SeekMode
  );

ARC_STATUS
UDFSWrite (
  IN ULONG FileId,
  IN VOID * FIRMWARE_PTR Buffer,
  IN ULONG Length,
  OUT ULONG * FIRMWARE_PTR Count
  );

ARC_STATUS
UDFSGetFileInformation (
  IN ULONG FileId,
  OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
  );

ARC_STATUS
UDFSSetFileInformation (
  IN ULONG FileId,
  IN ULONG AttributeFlags,
  IN ULONG AttributeMask
  );

ARC_STATUS
UDFSInitialize(
  VOID
  );

#ifdef __cplusplus
}
#endif

#endif // _UDFSBOOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\udp_api.h ===
#ifndef _UDP_API_H
#define _UDP_API_H


#include "pxe_cmn.h"


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* #defines and constants
 */

/* One of the following command op-codes needs to be loaded into the
 * op-code register (BX) before making a call a UDP API service.
 */
#define PXENV_UDP_OPEN			0x30
#define PXENV_UDP_CLOSE		0x31
#define PXENV_UDP_READ			0x32
#define PXENV_UDP_WRITE	0x33


typedef struct s_PXENV_UDP_OPEN {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
    UINT8 SrcIp[4];         /* Out: 32-bit IP address of this station. */
} t_PXENV_UDP_OPEN;


typedef struct s_PXENV_UDP_CLOSE {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
} t_PXENV_UDP_CLOSE;


typedef struct s_PXENV_UDP_READ {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx #defines. */
    UINT8 SrcIp[4];         /* Out: See description below */
    UINT8 DestIp[4];        /* In/Out: See description below */
    UINT16 SrcPort;         /* Out: See description below */
    UINT16 DestPort;        /* In/Out: See description below */
    UINT16 BufferSize;      /* In: Size of receive buffer. */
                            /* Out: Length of packet written into */
                            /*      receive buffer. */
    UINT16 BufferOffset;    /* In: Segment/Selector and offset */
    UINT16 BufferSegment;   /*     of receive buffer. */
} t_PXENV_UDP_READ;

/*
src_ip: (Output)
======
UDP_READ fills this value on return with the 32-bit IP address
of the sender.

dest_ip: (Input/Output)
=======
If this field is non-zero then UDP_READ will filter the incoming
packets and accept those that are sent to this IP address.

If this field is zero then UDP_READ will accept any incoming
packet and return it's destination IP address in this field.

s_port: (Output)
=======
UDP_READ fills this value on return with the UDP port number
of the sender.

d_port: (Input/Output)
=======
If this field is non-zero then UDP_READ will filter the incoming
packets and accept those that are sent to this UDP port.

If this field is zero then UDP_READ will accept any incoming
packet and return it's destination UDP port in this field.

*/


typedef struct s_PXENV_UDP_WRITE {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
    UINT8 DestIp[4];        /* In: 32-bit server IP address. */
    UINT8 GatewayIp[4];     /* In: 32-bit gateway IP address. */
    UINT16 SrcPort;         /* In: Source UDP port. */
    UINT16 DestPort;        /* In: Destination UDP port. */
	UINT16 BufferSize;		/* In: Length of packet in buffer. */
	UINT16 BufferOffset;		/* In: Segment/Selector and */
	UINT16 BufferSegment;		/*     offset of transmit buffer. */
} t_PXENV_UDP_WRITE;


#endif /* _UDP_API_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\ximagdef.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ximagdef.h

Abstract:

    This file contains image definitions and for both 32-bit and 64-bit
    images.

Author:

    Forrest C. Foltz (forrestf) 23-May-2000

Revision History:

--*/

#if defined(_X86AMD64_)

#undef IMAGE_ORDINAL_FLAG 
#undef IMAGE_ORDINAL
#undef IMAGE_THUNK_DATA
#undef PIMAGE_THUNK_DATA
#undef IMAGE_SNAP_BY_ORDINAL
#undef IMAGE_TLS_DIRECTORY
#undef PIMAGE_TLS_DIRECTORY
#undef IMAGE_NT_HEADERS
#undef PIMAGE_NT_HEADERS


#if IMAGE_DEFINITIONS == 32

#define IMAGE_ORDINAL_FLAG             IMAGE_ORDINAL_FLAG32
#define IMAGE_ORDINAL(x)               IMAGE_ORDINAL32(x)
#define IMAGE_THUNK_DATA               IMAGE_THUNK_DATA32
#define PIMAGE_THUNK_DATA              PIMAGE_THUNK_DATA32
#define IMAGE_SNAP_BY_ORDINAL(x)       IMAGE_SNAP_BY_ORDINAL32(x)
#define IMAGE_TLS_DIRECTORY            IMAGE_TLS_DIRECTORY32
#define PIMAGE_TLS_DIRECTORY           PIMAGE_TLS_DIRECTORY32
#define IMAGE_NT_HEADERS               IMAGE_NT_HEADERS32
#define PIMAGE_NT_HEADERS              PIMAGE_NT_HEADERS32

#elif IMAGE_DEFINITIONS == 64

#define IMAGE_ORDINAL_FLAG             IMAGE_ORDINAL_FLAG64
#define IMAGE_ORDINAL(x)               IMAGE_ORDINAL64(x)
#define IMAGE_THUNK_DATA               IMAGE_THUNK_DATA64
#define PIMAGE_THUNK_DATA              PIMAGE_THUNK_DATA64
#define IMAGE_SNAP_BY_ORDINAL(x)       IMAGE_SNAP_BY_ORDINAL64(x)
#define IMAGE_TLS_DIRECTORY            IMAGE_TLS_DIRECTORY64
#define PIMAGE_TLS_DIRECTORY           PIMAGE_TLS_DIRECTORY64
#define IMAGE_NT_HEADERS               IMAGE_NT_HEADERS64
#define PIMAGE_NT_HEADERS              PIMAGE_NT_HEADERS64

#endif

#define IMAGE_NT_HEADER(x) ((PIMAGE_NT_HEADERS)RtlImageNtHeader(x))

#ifndef _XIMAGDEF_H_
#define _XIMAGDEF_H_

//
// Macros used to determine whether an image is 32-bit or 64-bit, and an
// assert to make sure the Magic field has the same offset in both.
//

#define IMAGE_64BIT( ntheader )                                     \
    (((PIMAGE_NT_HEADERS32)(ntheader))->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)

#define IMAGE_32BIT( ntheader )                                     \
    (((PIMAGE_NT_HEADERS32)(ntheader))->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)

C_ASSERT( FIELD_OFFSET(IMAGE_NT_HEADERS32, OptionalHeader.Magic) ==
          FIELD_OFFSET(IMAGE_NT_HEADERS64, OptionalHeader.Magic) );


#endif  // _XIMAGDEF_H_

#endif  // _X86AMD64_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\vmode.h ===
#ifndef __VMODE_H__

#include "bldr.h"

#define TXT_MOD 0x3
#define GFX_MOD 0x12
#define SET_VMODE(x) HW_CURSOR(0x80000000,x)

void DummyDebugDelay (VOID);
VOID BlRedrawGfxProgressBar(VOID);	//	Redraws the progress bar (with the last percentage) 
VOID BlUpdateGfxProgressBar(ULONG fPercentage);
VOID LoadBootLogoBitmap (IN ULONG DriveId, PCHAR path);	//	Loads ntldr bitmap and initializes
VOID DrawBitmap (VOID);
VOID PaletteOff (VOID);
VOID PaletteOn (VOID);
VOID PrepareGfxProgressBar (VOID);
VOID VgaEnableVideo();

extern BOOLEAN DisplayLogoOnBoot;
extern BOOLEAN GraphicsMode;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\kd1394\kd1394.h ===
/*++
Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    kd1394.h

Abstract:

    1394 Kernel Debugger DLL

Author:

    Peter Binder (pbinder)

Revision   History:
Date       Who       What
---------- --------- ------------------------------------------------------------
06/21/2001 pbinder   having fun...
--*/

//
// boot.ini parameters
//
#define BUSPARAMETERS_OPTION            "BUSPARAMS"
#define CHANNEL_OPTION                  "CHANNEL"
#define BUS_OPTION                      "NOBUS"

// global 1394 debug controller data
#define DBG_BUS1394_CROM_BUFFER_SIZE    64

#define TIMEOUT_COUNT                   1024*500
#define MAX_REGISTER_READS              400000

typedef struct _DEBUG_1394_DATA {

    //
    // our config rom - must be 1k aligned
    //
    ULONG                       CromBuffer[DBG_BUS1394_CROM_BUFFER_SIZE];

    //
    // our ohci register map
    //
    POHCI_REGISTER_MAP          BaseAddress;

    //
    // our config for this session
    //
    DEBUG_1394_CONFIG           Config;

    //
    // our send packet (isoch packet)
    //
    DEBUG_1394_SEND_PACKET      SendPacket;

    //
    // our receive packet
    //
    DEBUG_1394_RECEIVE_PACKET   ReceivePacket;

} DEBUG_1394_DATA, *PDEBUG_1394_DATA;

//
// Debug 1394 Parameters
//
typedef struct _DEBUG_1394_PARAMETERS {

    //
    // device descriptor (pci slot, bus, etc)
    //
    DEBUG_DEVICE_DESCRIPTOR     DbgDeviceDescriptor;

    //
    // is the debugger active?
    //
    BOOLEAN                     DebuggerActive;

    //
    // should we disable 1394bus?
    //
    ULONG                       NoBus;

    //
    // Id for this target
    //
    ULONG                       Id;

} DEBUG_1394_PARAMETERS, *PDEBUG_1394_PARAMETERS;

//
// Global Data Structures
//
#ifdef _KD1394_C

DEBUG_1394_PARAMETERS           Kd1394Parameters;
PDEBUG_1394_DATA                Kd1394Data;

#else

extern DEBUG_1394_PARAMETERS    Kd1394Parameters;
extern PDEBUG_1394_DATA         Kd1394Data;

#endif

//
// kd1394.c
//
BOOLEAN
Kd1394pInitialize(
    IN PDEBUG_1394_PARAMETERS   DebugParameters,
    IN PLOADER_PARAMETER_BLOCK  LoaderBlock
    );

NTSTATUS
KdD0Transition(
    void
    );

NTSTATUS
KdD3Transition(
    void
    );

NTSTATUS
KdDebuggerInitialize0(
    IN PLOADER_PARAMETER_BLOCK  LoaderBlock
    );

NTSTATUS
KdDebuggerInitialize1(
    IN PLOADER_PARAMETER_BLOCK  LoaderBlock
    );

NTSTATUS
KdSave(
    IN BOOLEAN  KdSleepTransition
    );

NTSTATUS
KdRestore(
    IN BOOLEAN  KdSleepTransition
    );

//
// kd1394io.c
//
ULONG
KdpComputeChecksum(
    IN PUCHAR   Buffer,
    IN ULONG    Length
    );

void
KdpSendControlPacket(
    IN USHORT   PacketType,
    IN ULONG    PacketId OPTIONAL
    );

ULONG
KdReceivePacket (
    IN ULONG            PacketType,
    OUT PSTRING         MessageHeader,
    OUT PSTRING         MessageData,
    OUT PULONG          DataLength,
    IN OUT PKD_CONTEXT  KdContext
    );

void
KdSendPacket(
    IN ULONG            PacketType,
    IN PSTRING          MessageHeader,
    IN PSTRING          MessageData OPTIONAL,
    IN OUT PKD_CONTEXT  KdContext
    );

//
// ohci1394.c
//
ULONG
FASTCALL
Dbg1394_ByteSwap(
    IN ULONG Source
    );

ULONG
Dbg1394_CalculateCrc(
    IN PULONG Quadlet,
    IN ULONG length
    );

ULONG
Dbg1394_Crc16(
    IN ULONG data,
    IN ULONG check
    );

NTSTATUS
Dbg1394_ReadPhyRegister(
    PDEBUG_1394_DATA    DebugData,
    ULONG               Offset,
    PUCHAR              pData
    );

NTSTATUS
Dbg1394_WritePhyRegister(
    PDEBUG_1394_DATA    DebugData,
    ULONG               Offset,
    UCHAR               Data
    );

BOOLEAN
Dbg1394_InitializeController(
    IN PDEBUG_1394_DATA         DebugData,
    IN PDEBUG_1394_PARAMETERS   DebugParameters
    );

ULONG
Dbg1394_StallExecution(
    ULONG   LoopCount
    );

void
Dbg1394_EnablePhysicalAccess(
    IN PDEBUG_1394_DATA     DebugData
    );

ULONG
Dbg1394_ReadPacket(
    PDEBUG_1394_DATA    DebugData,
    OUT PKD_PACKET      PacketHeader,
    OUT PSTRING         MessageHeader,
    OUT PSTRING         MessageData,
    BOOLEAN             Wait
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\kd1394\kd1394.c ===
/*++
Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    kd1394.c

Abstract:

    1394 Kernel Debugger DLL

Author:

    George Chrysanthakopoulos (georgioc) Feb-2000

Revision   History:
Date       Who       What
---------- --------- ------------------------------------------------------------
06/19/2001 pbinder   cleanup
--*/

#define _KD1394_C
#include "pch.h"
#undef _KD1394_C

BOOLEAN
Kd1394pInitialize(
    IN PDEBUG_1394_PARAMETERS   DebugParameters,
    IN PLOADER_PARAMETER_BLOCK  LoaderBlock
    )
/*++

Routine Description:

    This routine enumerates the bus controller of DebugParameters.BusType, using
    the appropriate ClassCode (generic enumeration). If PCI addressing info was
    found on the Options String passed by the Loader, will use this and go directly
    to that bus number, slot, function to setup that controller.

Arguments:

    DebugParameters - Supplies Debug parameters parsed from Options string

    LoaderBlock - Supplies a pointer to the LOADER_PARAMETER_BLOCK passed
                  in from the OS Loader.

Return Value:

    None.

--*/
{
    NTSTATUS    ntStatus;
    ULONG       maxPhys;

    //
    // Find the controller, setup the PCI registers for it
    // and do bus specific initialization
    //
    DebugParameters->DbgDeviceDescriptor.Memory.Length = sizeof(DEBUG_1394_DATA);

    ntStatus = KdSetupPciDeviceForDebugging( LoaderBlock,
                                             &DebugParameters->DbgDeviceDescriptor
                                             );
    if (!NT_SUCCESS(ntStatus)) {

        return(FALSE);
    }

    Kd1394Data = DebugParameters->DbgDeviceDescriptor.Memory.VirtualAddress;
    RtlZeroMemory(Kd1394Data, sizeof(DEBUG_1394_DATA));

    return(Dbg1394_InitializeController(Kd1394Data, DebugParameters));
} // Kd1394pInitialize

NTSTATUS
KdD0Transition(
    void
    )
/*++

Routine Description:

    The PCI driver (or relevant bus driver) will call this API after it
    processes a D0 IRP for this device

Arguments:

    None

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    LOADER_PARAMETER_BLOCK  LoaderBlock = {0};

    // see if we need to activate the debugger
    if (Kd1394Parameters.DebuggerActive == FALSE) {

        if (Kd1394pInitialize(&Kd1394Parameters, &LoaderBlock)) {

            Kd1394Parameters.DebuggerActive = TRUE;
        }            
    }        

    return(STATUS_SUCCESS);
} // KdD0Transition

NTSTATUS
KdD3Transition(
    void
    )
/*++

Routine Description:

    The PCI driver (or relevant bus driver) will call this API before it
    processes a D3 IRP for this device

Arguments:

    None

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    Kd1394Parameters.DebuggerActive = FALSE;
    return(STATUS_SUCCESS);
} // KdD3Transition

NTSTATUS
KdDebuggerInitialize0(
    IN PLOADER_PARAMETER_BLOCK  LoaderBlock
    )
/*++

Routine Description:

    This API allows the debugger DLL to parse the boot.ini strings and
    perform any initialization.  It cannot be assumed that the entire NT
    kernel has been initialized at this time.  Memory management services,
    for example, will not be available.  After this call has returned, the
    debugger DLL may receive requests to send and receive packets.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS                    ntStatus = STATUS_UNSUCCESSFUL;
    PCHAR                       Options;
    PCHAR                       BusParametersOption;
    PCHAR                       ChannelOption;
    PCHAR                       BusOption;
    PCI_SLOT_NUMBER             slotNumber;
    PDEBUG_DEVICE_DESCRIPTOR    DbgDeviceDescriptor = &Kd1394Parameters.DbgDeviceDescriptor;

    // first time is called with valid LoaderBlock
    if (LoaderBlock != NULL) {

        // set the debugger as inactive
        Kd1394Parameters.DebuggerActive = FALSE;

        if (LoaderBlock->LoadOptions != NULL) {

            Options = LoaderBlock->LoadOptions;
            _strupr(Options);

            // retrieve the channel number
            // CHANGE: this is actually an instance id and should be changed.
            ChannelOption = strstr(Options, CHANNEL_OPTION);

            if (ChannelOption) {

                ChannelOption += strlen(CHANNEL_OPTION);
                while (*ChannelOption == ' ') {
                    ChannelOption++;
                }

                if (*ChannelOption != '\0') {
                    Kd1394Parameters.Id = atol(ChannelOption + 1);
                }
            }
            else {

                // default to channel 0 - there should be no default???
                Kd1394Parameters.Id = 0;
            }

            // set vendor/class
            DbgDeviceDescriptor->VendorID = -1;
            DbgDeviceDescriptor->DeviceID = -1;
            DbgDeviceDescriptor->BaseClass = PCI_CLASS_SERIAL_BUS_CTLR;
            DbgDeviceDescriptor->SubClass = PCI_SUBCLASS_SB_IEEE1394;

            // support only ohci controllers
            DbgDeviceDescriptor->ProgIf = 0x10; 
            DbgDeviceDescriptor->Bus = -1;
            DbgDeviceDescriptor->Slot = -1;

            // now find PCI addressing information
            BusParametersOption = strstr(Options, BUSPARAMETERS_OPTION);

            if (BusParametersOption) {

                do {

                    BusParametersOption += strlen(BUSPARAMETERS_OPTION);
                    while (*BusParametersOption == ' ') {
                        BusParametersOption++;
                    }

                    // first get the pci bus number
                    if ((*BusParametersOption != '\0')) {

                        DbgDeviceDescriptor->Bus = atol(BusParametersOption+1);
                    }
                    else {

                        break;
                    }

                    // now find the device number
                    while ((*BusParametersOption != '.') && (*BusParametersOption != '\0')) {
                        BusParametersOption++;
                    }

                    if ((*BusParametersOption != '\0')) {

                        slotNumber.u.AsULONG = 0;
                        slotNumber.u.bits.DeviceNumber = atol(++BusParametersOption);
                    }
                    else {

                        break;
                    }

                    // now find the function number
                    while ((*BusParametersOption != '.') && (*BusParametersOption != '\0')) {
                        BusParametersOption++;
                    }

                    if ((*BusParametersOption != '\0')) {

                        slotNumber.u.bits.FunctionNumber = atol(BusParametersOption+1);
                    }
                    else {

                        break;
                    }

                    DbgDeviceDescriptor->Slot = slotNumber.u.AsULONG;

                } while (FALSE);
            }

            // see if the nobus flag is set
            BusOption = strstr(Options, BUS_OPTION);

            if (BusOption) {

                Kd1394Parameters.NoBus = TRUE;
            }
            else {

                Kd1394Parameters.NoBus = FALSE;
            }

            // find and configure the pci controller and do 1394 specific init
            if (Kd1394pInitialize(&Kd1394Parameters, LoaderBlock)) {

                Kd1394Parameters.DebuggerActive = TRUE;
                ntStatus = STATUS_SUCCESS;
            }
        }

        // hmmm...what happens if LoaderBlock->LoadOptions == NULL??
    }
    else {

        ntStatus = STATUS_SUCCESS;
    }

    return(ntStatus);
} // KdDebuggerInitialize0

NTSTATUS
KdDebuggerInitialize1(
    IN PLOADER_PARAMETER_BLOCK  LoaderBlock
    )
/*++

Routine Description:

    This API allows the debugger DLL to do any initialization that it needs
    to do after the NT kernel services are available.  Mm and registry APIs
    will be guaranteed to be available at this time.  If the specific
    debugger DLL implementation uses a PCI device, it will set a registry
    key (discussed later) that notifies the PCI driver that a specific PCI
    device is being used for debugging.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    WCHAR                           Buffer[16];
    OBJECT_ATTRIBUTES               ObjectAttributes;
    UNICODE_STRING                  UnicodeString;
    HANDLE                          BaseHandle = NULL;
    HANDLE                          Handle = NULL;
    ULONG                           disposition, i;
    ULONG                           ulLength, ulResult;
    NTSTATUS                        ntStatus;
    PHYSICAL_ADDRESS                physAddr;
    ULONG                           BusNumber;
    ULONG                           SlotNumber;
    PKEY_VALUE_PARTIAL_INFORMATION  PartialInfo;

    // make sure we are active, if not, exit
    if (Kd1394Parameters.DebuggerActive == FALSE) {

        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Open PCI Debug service key.
    //
    RtlInitUnicodeString( &UnicodeString,
                          L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\SERVICES\\PCI\\DEBUG"
                          );

    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                (PSECURITY_DESCRIPTOR)NULL
                                );

    ntStatus = ZwOpenKey(&BaseHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(ntStatus)) {

        return(STATUS_SUCCESS);
    }

    for (i=0; i<MAX_DEBUGGING_DEVICES_SUPPORTED; i++) {

        swprintf(Buffer, L"%d", i);

        RtlInitUnicodeString(&UnicodeString, Buffer);

        InitializeObjectAttributes( &ObjectAttributes,
                                    &UnicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    BaseHandle,
                                    (PSECURITY_DESCRIPTOR)NULL
                                    );

        ntStatus = ZwOpenKey(&Handle, KEY_READ, &ObjectAttributes);

        if (NT_SUCCESS(ntStatus)) {

            ulLength = sizeof(KEY_VALUE_FULL_INFORMATION)+sizeof(ULONG);
            PartialInfo = ExAllocatePoolWithTag(NonPagedPool, ulLength, '31kd');

            if (PartialInfo == NULL) {

                ZwClose(Handle);
                continue;
            }

            RtlInitUnicodeString (&UnicodeString, L"Bus");

            ntStatus = ZwQueryValueKey( Handle,
                                        &UnicodeString,
                                        KeyValuePartialInformation,
                                        PartialInfo,
                                        ulLength,
                                        &ulResult
                                        );

            if (NT_SUCCESS(ntStatus)) {

                RtlCopyMemory(&BusNumber, &PartialInfo->Data, sizeof(ULONG));
            }

            RtlInitUnicodeString (&UnicodeString, L"Slot");

            ntStatus = ZwQueryValueKey( Handle,
                                        &UnicodeString,
                                        KeyValuePartialInformation,
                                        PartialInfo,
                                        ulLength,
                                        &ulResult
                                        );

            if (NT_SUCCESS(ntStatus)) {

                RtlCopyMemory(&SlotNumber, &PartialInfo->Data, sizeof(ULONG));
            }

            ExFreePool(PartialInfo);

            if ((Kd1394Parameters.DbgDeviceDescriptor.Bus == BusNumber) &&
                (Kd1394Parameters.DbgDeviceDescriptor.Slot == SlotNumber)) {

                // we found our instance, let's add our keys...
                physAddr = MmGetPhysicalAddress(&Kd1394Data->Config);

                RtlInitUnicodeString (&UnicodeString, L"DebugAddress");

                ntStatus = ZwSetValueKey( Handle,
                                          &UnicodeString,
                                          0,
                                          REG_QWORD,
                                          &physAddr,
                                          sizeof(ULARGE_INTEGER)
                                          );

                RtlInitUnicodeString (&UnicodeString, L"NoBus");

                ntStatus = ZwSetValueKey( Handle,
                                          &UnicodeString,
                                          0,
                                          REG_DWORD,
                                          &Kd1394Parameters.NoBus,
                                          sizeof(ULONG)
                                          );
            }

            ZwClose(Handle);
        }
    }

    ZwClose(BaseHandle);

    return(STATUS_SUCCESS);
} // KdDebuggerInitialize1

NTSTATUS
KdSave(
    IN BOOLEAN  KdSleepTransition
    )
/*++

Routine Description:

    The HAL calls this function as late as possible before putting the
    machine to sleep.

Arguments:

    KdSleepTransition - TRUE when transitioning to/from sleep state

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    return(STATUS_SUCCESS);
} // KdSave

NTSTATUS
KdRestore(
    IN BOOLEAN  KdSleepTransition
    )
/*++

Routine Description:

    The HAL calls this function as early as possible after resuming from a
    sleep state.

Arguments:

    KdSleepTransition - TRUE when transitioning to/from sleep state

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    return(STATUS_SUCCESS);
} // KdRestore
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\inc\undi_api.h ===
#ifndef _UNDI_API_H
#define _UNDI_API_H


#include "pxe_cmn.h"


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* #defines and constants
 */

/* One of the following command op-codes needs to be loaded into the
 * op-code register (BX) before making a call an UNDI API service.
 */
#define PXENV_UNDI_SHUTDOWN     0x05
#define PXENV_UNDI_OPEN			0x06
#define PXENV_UNDI_CLOSE		0x07
#define PXENV_UNDI_SET_PACKET_FILTER 0x0B
#define PXENV_UNDI_GET_NIC_TYPE	0x12
#define PXENV_UNDI_GET_INFORMATION	0x000C

#define ADDR_LEN 16
#define MAXNUM_MCADDR 8


typedef struct s_PXENV_UNDI_MCAST_ADDR {
	UINT16 MCastAddrCount;
    UINT8 MCastAddr[MAXNUM_MCADDR][ADDR_LEN];
} t_PXENV_UNDI_MCAST_ADDR;


typedef struct s_PXENV_UNDI_SHUTDOWN {
	UINT16 Status;
} t_PXENV_UNDI_SHUTDOWN;

typedef struct s_PXENV_UNDI_OPEN {
	UINT16 Status;
    UINT16 OpenFlag;
    UINT16 PktFilter;
    t_PXENV_UNDI_MCAST_ADDR McastBuffer;
} t_PXENV_UNDI_OPEN;

#define FLTR_DIRECTED 0x0001
#define FLTR_BRDCST   0x0002
#define FLTR_PRMSCS   0x0004
#define FLTR_SRC_RTG  0x0008

typedef struct s_PXENV_UNDI_SET_PACKET_FILTER {
    UINT16 Status;
    UINT8 filter;
} t_PXENV_UNDI_SET_PACKET_FILTER;

typedef struct s_PXENV_UNDI_CLOSE {
	UINT16 Status;
} t_PXENV_UNDI_CLOSE;

#include <pshpack1.h>

typedef struct s_PXENV_UNDI_GET_NIC_TYPE {
    UINT16 Status;  /* OUT: See PXENV_STATUS_xxx constants */
    UINT8 NicType;  /* OUT: 2=PCI, 3=PnP */
    union{
        struct{
            UINT16 Vendor_ID;   /* OUT:  */
            UINT16 Dev_ID;  /* OUT:  */
            UINT8 Base_Class;   /* OUT: */
            UINT8 Sub_Class;    /* OUT: */
            UINT8 Prog_Intf;    /* OUT: program interface */
            UINT8 Rev;  /* OUT: Revision number */
            UINT16 BusDevFunc;  /* OUT: Bus, Device */
            UINT32 Subsys_ID;   /* OUT: Subsystem ID */
            /* & Function numbers */
        }pci;
        struct{
            UINT32 EISA_Dev_ID; /* Out:  */
            UINT8 Base_Class;   /* OUT: */
            UINT8 Sub_Class;    /* OUT: */
            UINT8 Prog_Intf;    /* OUT: program interface */
            UINT16 CardSelNum;  /* OUT: Card Selector Number */
        }pnp;
    }pci_pnp_info;

} t_PXENV_UNDI_GET_NIC_TYPE;


typedef struct s_PXENV_UNDI_GET_INFORMATION {
	UINT16 Status;			/* Out: PXENV_STATUS_xxx */
	UINT16 BaseIo;			/* Out: Adapter's Base IO */
	UINT16 IntNumber;		/* Out: IRQ number */
	UINT16 MaxTranUnit;		/* Out: MTU	*/
	UINT16  HwType;			/* Out: type of protocol at hardware level */

#define ETHER_TYPE	1
#define EXP_ETHER_TYPE	2
#define IEEE_TYPE	6
#define ARCNET_TYPE	7

    /*  other numbers can  be obtained from  rfc1010 for "Assigned
    Numbers".  This number may not be validated by the application
    and hence adding new numbers to the list should be fine at any
    time.  */

	UINT16 HwAddrLen;		/* Out: actual length of hardware address */
	UINT8 CurrentNodeAddress[ADDR_LEN]; /* Out: Current hardware address*/
	UINT8 PermNodeAddress[ADDR_LEN]; /* Out: Permanent hardware address*/
	UINT16 ROMAddress;		/* Out: ROM address */
	UINT16 RxBufCt;			/* Out: receive Queue length	*/
	UINT16 TxBufCt;			/* Out: Transmit Queue length */
} t_PXENV_UNDI_GET_INFORMATION;



#include <poppack.h>

#endif /* _UNDI_API_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\kd1394\kd1394io.c ===
/*++
Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    kd1394io.c

Abstract:

    1394 Kernel Debugger DLL

Author:

    George Chrysanthakopoulos (georgioc) Nov-1999

Revision   History:
Date       Who       What
---------- --------- ------------------------------------------------------------
06/19/2001 pbinder   cleanup
--*/

#define _KD1394IO_C
#include "pch.h"
#undef _KD1394IO_C

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpComputeChecksum)
#pragma alloc_text(PAGEKD, KdpSendControlPacket)
#pragma alloc_text(PAGEKD, KdReceivePacket)
#pragma alloc_text(PAGEKD, KdSendPacket)
#endif

//
// KdpRetryCount controls the number of retries before we give
// up and assume kernel debugger is not present.
// KdpNumberRetries is the number of retries left.  Initially,
// it is set to 5 such that booting NT without debugger won't be
// delayed to long.
//
ULONG KdCompNumberRetries = 5;
ULONG KdCompRetryCount = 5;

ULONG KdPacketId = 0;

ULONG
KdpComputeChecksum(
    IN PUCHAR   Buffer,
    IN ULONG    Length
    )
/*++

Routine Description:

    This routine computes the checksum for the string passed in.

Arguments:

    Buffer - Supplies a pointer to the string.

    Length - Supplies the length of the string.

Return Value:

    A ULONG is return as the checksum for the input string.

--*/
{
    ULONG   Checksum = 0;

    while (Length > 0) {

        Checksum = Checksum + (ULONG)*Buffer++;
        Length--;
    }

    return(Checksum);
} // KdpComputeChecksum

void
KdpSendControlPacket(
    IN USHORT   PacketType,
    IN ULONG    PacketId OPTIONAL
    )
/*++

Routine Description:

    This routine sends a control packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    PacketId - Supplies packet id, optionally.

Return Value:

    None.

--*/
{
    KD_PACKET   PacketHeader;

    //
    // Initialize and send the packet header.
    //
    PacketHeader.PacketLeader = CONTROL_PACKET_LEADER;

    if (ARGUMENT_PRESENT((PVOID)(ULONG_PTR)PacketId)) {

        PacketHeader.PacketId = PacketId;
    }
    PacketHeader.PacketId = 0;
    PacketHeader.ByteCount = 0;
    PacketHeader.Checksum = 0;
    PacketHeader.PacketType = PacketType;

    // setup our send packet
    RtlZeroMemory(&Kd1394Data->SendPacket, sizeof(DEBUG_1394_SEND_PACKET));
    Kd1394Data->SendPacket.Length = 0;

    RtlCopyMemory( &Kd1394Data->SendPacket.PacketHeader[0],
                   &PacketHeader,
                   sizeof(KD_PACKET)
                   );

    Kd1394Data->SendPacket.TransferStatus = STATUS_PENDING;

    return;
} // KdpSendControlPacket

ULONG
KdReceivePacket(
    IN ULONG            PacketType,
    OUT PSTRING         MessageHeader,
    OUT PSTRING         MessageData,
    OUT PULONG          DataLength,
    IN OUT PKD_CONTEXT  KdContext
    )
/*++

Routine Description:

    This routine receives a packet from the host machine that is running
    the kernel debugger UI.  This routine is ALWAYS called after packet being
    sent by caller.  It first waits for ACK packet for the packet sent and
    then waits for the packet desired.

    N.B. If caller is KdPrintString, the parameter PacketType is
       PACKET_TYPE_KD_ACKNOWLEDGE.  In this case, this routine will return
       right after the ack packet is received.

Arguments:

    PacketType - Supplies the type of packet that is excepted.

    MessageHeader - Supplies a pointer to a string descriptor for the input
        message.

    MessageData - Supplies a pointer to a string descriptor for the input data.

    DataLength - Supplies pointer to ULONG to receive length of recv. data.

    KdContext - Supplies a pointer to the kernel debugger context.

Return Value:

    KDP_PACKET_RESEND - if resend is required.  = 2 = CP_GET_ERROR
    KDP_PACKET_TIMEOUT - if timeout.            = 1 = CP_GET_NODATA
    KDP_PACKET_RECEIVED - if packet received.   = 0 = CP_GET_SUCCESS

--*/
{
    UCHAR       Input;
    ULONG       MessageLength;
    KD_PACKET   PacketHeader;
    ULONG       ReturnCode;
    ULONG       Checksum;
    ULONG       Status;

// this dispatch gets called with PacketType != PACKET_TYPE_KD_POLL_BREAKIN for
// the number of times specified in KdCompNumberRetries (??). if we always timeout
// then we'll get called with PacketType == PACKET_TYPE_KD_POLL_BREAKIN

    // make sure our link is enabled..
    Dbg1394_EnablePhysicalAccess(Kd1394Data);

    //
    // Just check for breakin packet and return
    //
    if (PacketType == PACKET_TYPE_KD_POLL_BREAKIN) {

        // let's peak into our receive packet and see if it's a breakin
        if ((Kd1394Data->ReceivePacket.TransferStatus == STATUS_PENDING) &&
            (Kd1394Data->ReceivePacket.Packet[0] == BREAKIN_PACKET_BYTE)) {

            *KdDebuggerNotPresent = FALSE;
            SharedUserData->KdDebuggerEnabled |= 0x00000002;

            // we have a breakin packet
            Kd1394Data->ReceivePacket.TransferStatus = STATUS_SUCCESS;
            return(KDP_PACKET_RECEIVED);
        }
        else {

            return(KDP_PACKET_TIMEOUT);
        }
    }

WaitForPacketLeader:

    // read in our packet, if available...
    ReturnCode = Dbg1394_ReadPacket( Kd1394Data,
                                     &PacketHeader,
                                     MessageHeader,
                                     MessageData,
                                     TRUE
                                     );


    //
    // If we can successfully read packet leader, it has high possibility that
    // kernel debugger is alive.  So reset count.
    //
    if (ReturnCode != KDP_PACKET_TIMEOUT) {

        KdCompNumberRetries = KdCompRetryCount;
    }

    if (ReturnCode != KDP_PACKET_RECEIVED) {

        // see if it's a breakin packet...
        if ((PacketHeader.PacketLeader & 0xFF) == BREAKIN_PACKET_BYTE) {

            KdContext->KdpControlCPending = TRUE;
            return(KDP_PACKET_RESEND);
        }

        return(ReturnCode);
    }

    //
    // if the packet we received is a resend request, we return true and
    // let caller resend the packet.
    //
    if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER &&
        PacketHeader.PacketType == PACKET_TYPE_KD_RESEND) {

        return(KDP_PACKET_RESEND);
    }

    //
    // Check ByteCount received is valid
    //
    MessageLength = MessageHeader->MaximumLength;

    if ((PacketHeader.ByteCount > (USHORT)PACKET_MAX_SIZE) ||
        (PacketHeader.ByteCount < (USHORT)MessageLength)) {

        goto SendResendPacket;
    }
    *DataLength = PacketHeader.ByteCount - MessageLength;

    MessageData->Length = (USHORT)*DataLength;
    MessageHeader->Length = (USHORT)MessageLength;

    //
    // Check PacketType is what we are waiting for.
    //
    if (PacketType != PacketHeader.PacketType) {

        goto SendResendPacket;
    }

    //
    // Check checksum is valid.
    //
    Checksum = KdpComputeChecksum(MessageHeader->Buffer, MessageHeader->Length);
    Checksum += KdpComputeChecksum(MessageData->Buffer, MessageData->Length);

    if (Checksum != PacketHeader.Checksum) {

        goto SendResendPacket;
    }

    return(KDP_PACKET_RECEIVED);

SendResendPacket:

    KdpSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);
    goto WaitForPacketLeader;
} // KdReceivePacket

void
KdSendPacket(
    IN ULONG            PacketType,
    IN PSTRING          MessageHeader,
    IN PSTRING          MessageData OPTIONAL,
    IN OUT PKD_CONTEXT  KdContext
    )
/*++

Routine Description:

    This routine sends a packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    MessageHeader - Supplies a pointer to a string descriptor that describes
        the message information.

    MessageData - Supplies a pointer to a string descriptor that describes
        the optional message data.

    KdContext - Supplies a pointer to the kernel debugger context.

Return Value:

    None.

--*/
{
    KD_PACKET                   PacketHeader;
    ULONG                       MessageDataLength;
    ULONG                       ReturnCode;
    PDBGKD_DEBUG_IO             DebugIo;
    PDBGKD_WAIT_STATE_CHANGE64  StateChange;
    PDBGKD_FILE_IO              FileIo;
    BOOLEAN                     bException = FALSE;

    PacketHeader.Checksum = 0;

    if (ARGUMENT_PRESENT(MessageData)) {

        MessageDataLength = MessageData->Length;
        PacketHeader.Checksum = KdpComputeChecksum(MessageData->Buffer, MessageData->Length);
    }
    else {

        MessageDataLength = 0;
        PacketHeader.Checksum = 0;
    }

    PacketHeader.Checksum += KdpComputeChecksum(MessageHeader->Buffer, MessageHeader->Length);

    //
    // Initialize and send the packet header.
    //
    PacketHeader.PacketLeader = PACKET_LEADER;
    PacketHeader.ByteCount = (USHORT)(MessageHeader->Length + MessageDataLength);
    PacketHeader.PacketType = (USHORT)PacketType;

    PacketHeader.PacketId = KdPacketId;

    KdPacketId++;

    KdCompNumberRetries = KdCompRetryCount;

    // setup our send packet
    RtlZeroMemory(&Kd1394Data->SendPacket, sizeof(DEBUG_1394_SEND_PACKET));
    Kd1394Data->SendPacket.Length = 0;

    // copy our packet header...
    RtlCopyMemory( &Kd1394Data->SendPacket.PacketHeader[0],
                   &PacketHeader,
                   sizeof(KD_PACKET)
                   );

    // setup our message header
    if (MessageHeader) {

        RtlCopyMemory( &Kd1394Data->SendPacket.Packet[0],
                       MessageHeader->Buffer,
                       MessageHeader->Length
                       );

        Kd1394Data->SendPacket.Length += MessageHeader->Length;
    }

    // setup our message data
    if (ARGUMENT_PRESENT(MessageData)) {

        RtlCopyMemory( &Kd1394Data->SendPacket.Packet[Kd1394Data->SendPacket.Length],
                       MessageData->Buffer,
                       MessageData->Length
                       );

        Kd1394Data->SendPacket.Length += MessageData->Length;
    }

    Kd1394Data->SendPacket.TransferStatus = STATUS_PENDING;

    do {

        // make sure our link is enabled..
        Dbg1394_EnablePhysicalAccess(Kd1394Data);

        if (KdCompNumberRetries == 0) {

            //
            // If the packet is not for reporting exception, we give up
            // and declare debugger not present.
            //
            if (PacketType == PACKET_TYPE_KD_DEBUG_IO) {

                DebugIo = (PDBGKD_DEBUG_IO)MessageHeader->Buffer;

                if (DebugIo->ApiNumber == DbgKdPrintStringApi) {

                    *KdDebuggerNotPresent = TRUE;
                    SharedUserData->KdDebuggerEnabled &= ~0x00000002;

                    Kd1394Data->SendPacket.TransferStatus = STATUS_SUCCESS;
                    return;
                }
            }
            else if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64) {

                StateChange = (PDBGKD_WAIT_STATE_CHANGE64)MessageHeader->Buffer;

                if (StateChange->NewState == DbgKdLoadSymbolsStateChange) {

                    *KdDebuggerNotPresent = TRUE;
                    SharedUserData->KdDebuggerEnabled &= ~0x00000002;

                    Kd1394Data->SendPacket.TransferStatus = STATUS_SUCCESS;
                    return;
                }
            }
            else if (PacketType == PACKET_TYPE_KD_FILE_IO) {
                
                FileIo = (PDBGKD_FILE_IO)MessageHeader->Buffer;

                if (FileIo->ApiNumber == DbgKdCreateFileApi) {

                    *KdDebuggerNotPresent = TRUE;
                    SharedUserData->KdDebuggerEnabled &= ~0x00000002;

                    Kd1394Data->SendPacket.TransferStatus = STATUS_SUCCESS;
                    return;
                }
            }
            else {

                bException = TRUE;
            }
        }

        ReturnCode = KDP_PACKET_TIMEOUT;

        {
            ULONG                   count = 0;
            volatile NTSTATUS       *pStatus;

            pStatus = &Kd1394Data->ReceivePacket.TransferStatus;

            //
            // now sit here and poll for a response from the target machine
            //
            do {

                // make sure our link is enabled..
                Dbg1394_EnablePhysicalAccess(Kd1394Data);

                //
                // while in this loop check if the host layed in a request.
                // If they did, mark it read and double buffer it
                //
                count++;
                if (Kd1394Data->SendPacket.TransferStatus != STATUS_PENDING) {

                    ReturnCode = KDP_PACKET_RECEIVED;
                    break;
                }

                if ((*pStatus == STATUS_PENDING) && (!bException)) {

                    ReturnCode = KDP_PACKET_RECEIVED;
                    break;
                }

            } while (count < TIMEOUT_COUNT);
        }

        if (ReturnCode == KDP_PACKET_TIMEOUT) {

            KdCompNumberRetries--;
        }

    } while (ReturnCode != KDP_PACKET_RECEIVED);

    //
    // Since we are able to talk to debugger, the retrycount is set to
    // maximum value.
    //
    KdCompRetryCount = KdContext->KdpDefaultRetries;

    return;
} // KdSendPacket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\kd1394\ohci1394.h ===
/*++
Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    ohci1394.h

Abstract:

    1394 Kernel Debugger DLL

Author:

    George Chrysanthakopoulos (georgioc) 31-October-1999

Revision   History:
Date       Who       What
---------- --------- ------------------------------------------------------------
06/19/2001 pbinder   cleanup
--*/

//
// Various OHCI definitions
//

#define min(a,b)                            (((a) < (b)) ? (a) : (b))
#define max(a,b)                            (((a) > (b)) ? (a) : (b))

#define PHY_CABLE_POWER_STATUS              0x01        // CPS @ Address 0
#define PHY_LOCAL_NODE_ROOT                 0x02        // R @ Address 0
#define PHY_PHYSICAL_ID_MASK                0xFC        // Physical ID @ Address 0

#define PHY_ROOT_HOLD_OFF_BIT               0x80        // RHB @ Address 1
#define PHY_INITIATE_BUS_RESET              0x40        // IBR @ Address 1
#define PHY_MAX_GAP_COUNT                   0x3f        // GC  @ Address 1

#define OHCI_REGISTER_MAP_SIZE              0x800
#define OHCI_SELFID_BUFFER_SZ               2048
#define OHCI_CONFIG_ROM_SIZE                1024

#define OHCI_SELFID_DELAY                   0
#define OHCI_SELFID_POWER_CLASS             4

//
// IntEvent OHCI Register Bit Masks
//
#define MASTER_INT_ENABLE                   0x80000000
#define VENDOR_SPECIFIC_INT                 0x40000000
#define PHY_REG_RECEIVED_INT                0x04000000
#define CYCLE_TOO_LONG_INT                  0x02000000
#define UNRECOVERABLE_ERROR_INT             0x01000000
#define CYCLE_INCONSISTENT_INT              0x00800000
#define CYCLE_LOST_INT                      0x00400000
#define CYCLE_64_SECS_INT                   0x00200000
#define CYCLE_SYNCH_INT                     0x00100000
#define PHY_INT                             0x00080000
#define PHY_BUS_RESET_INT                   0x00020000
#define SELF_ID_COMPLETE_INT                0x00010000
#define LOCK_RESP_ERR_INT                   0x00000200
#define POSTED_WRITE_ERR_INT                0x00000100
#define ISOCH_RX_INT                        0x00000080
#define ISOCH_TX_INT                        0x00000040
#define RSPKT_INT                           0x00000020
#define RQPKT_INT                           0x00000010
#define ARRS_INT                            0x00000008
#define ARRQ_INT                            0x00000004
#define RESP_TX_COMPLETE_INT                0x00000002
#define REQ_TX_COMPLETE_INT                 0x00000001


#define USED_INT_MASK               (RESP_TX_COMPLETE_INT | REQ_TX_COMPLETE_INT | RSPKT_INT | RQPKT_INT |       \
                                     ISOCH_RX_INT | ISOCH_TX_INT | PHY_BUS_RESET_INT | SELF_ID_COMPLETE_INT |   \
                                     MASTER_INT_ENABLE | CYCLE_TOO_LONG_INT | CYCLE_INCONSISTENT_INT)

//
// DMA Async Context numbers
//
#define AT_REQ_DMA_CONTEXT                  0
#define AT_RSP_DMA_CONTEXT                  1
#define AR_REQ_DMA_CONTEXT                  2
#define AR_RSP_DMA_CONTEXT                  3
#define NUM_DMA_CONTEXTS                    4

//
// DMA Context Commands
//
#define OUTPUT_MORE_CMD                     0
#define OUTPUT_MORE_IMMEDIATE_CMD           0
#define OUTPUT_LAST_CMD                     1
#define OUTPUT_LAST_IMMEDIATE_CMD           1
#define INPUT_MORE_CMD                      2
#define INPUT_LAST_CMD                      3
#define STORE_VALUE_CMD                     8

//
// DMA context descriptor header values
//
#define DESC_KEY                            0
#define DESC_IMMEDIATE_KEY                  2

#define DESC_INPUT_MORE_IMM_BRANCH_CONTROL  0
#define DESC_OUT_MORE_BRANCH_CONTROL        0
#define DESC_OUT_LAST_BRANCH_CONTROL        3
#define DESC_INPUT_MORE_BRANCH_CONTROL      3
#define DESC_INPUT_LAST_BRANCH_CONTROL      3

#define DESC_WAIT_CONTROL_ON                3
#define DESC_WAIT_CONTROL_OFF               0

#define DESC_GENERATE_INT                   3
#define DESC_NO_INT                         0

//
// command descriptors XfreStatus field masks
//
#define DESC_XFER_STATUS_ACTIVE             0x0400
#define DESC_XFER_STATUS_DEAD               0x0800

//
// OHCI EVENT CODEs
//
#define OHCI_EVT_MISSING_ACK                0x03
#define OHCI_EVT_UNDERRUN                   0x04
#define OHCI_EVT_OVERRUN                    0x05
#define OHCI_EVT_TIMEOUT                    0x0a
#define OHCI_EVT_FLUSHED                    0x0F
#define OHCI_EVT_BUS_RESET                  0x09

//
// each packet must have up to 7 fragments ( including first and last descriptors)
//
#define MAX_OHCI_COMMAND_DESCRIPTOR_BLOCKS  8

//
// max buffer size one cmd descriptor can address
//
#define MAX_CMD_DESC_DATA_LENGTH            65535

//
// OHCI Register definitions
//
typedef struct _VERSION_REGISTER {

        ULONG       Revision:8;             // bits 0-7
        ULONG       Reserved:8;             // bits 8-15
        ULONG       Version:8;              // bits 16-23
        ULONG       GUID_ROM:1;             // bit 24
        ULONG       Reserved1:7;            // bits 25-31

} VERSION_REGISTER, *PVERSION_REGISTER;

typedef struct _VENDOR_ID_REGISTER {

        ULONG       VendorCompanyId:24;     // Bits 0-23
        ULONG       VendorUnique:8;         // Bits 24-31

} VENDOR_ID_REGISTER, *PVENDOR_ID_REGISTER;

typedef struct _GUID_ROM_REGISTER {

        ULONG       Reserved0:16;           // bits 0-15
        ULONG       RdData:8;               // bits 16-23
        ULONG       Reserved1:1;            // bit 24
        ULONG       RdStart:1;              // bit 25
        ULONG       Reserved2:5;            // bits 26-30
        ULONG       AddrReset:1;            // bits 31

} GUID_ROM_REGISTER, *PGUID_ROM_REGISTER;

typedef struct _AT_RETRIES_REGISTER {

        ULONG       MaxATReqRetries:4;      // bits 0-3
        ULONG       MaxATRespRetries:4;     // bits 4-7
        ULONG       MaxPhysRespRetries:4;   // bits 8-11
        ULONG       Reserved:4;             // bits 12-15
        ULONG       CycleLimit:13;          // bits 16-28
        ULONG       SecondLimit:3;          // bits 29-31

} AT_RETRIES_REGISTER, *PAT_RETRIES_REGISTER;

typedef struct _CSR_CONTROL_REGISTER {

        ULONG       CsrSel:2;               // bits 0-1
        ULONG       Reserved:29;            // bits 2-30;
        ULONG       CsrDone:1;              // bit 31

} CSR_CONTROL_REGISTER, *PCSR_CONTROL_REGISTER;

typedef struct _CONFIG_ROM_HEADER_REGISTER {

        ULONG       Rom_crc_value:16;       // bits 0-15
        ULONG       Crc_length:8;           // bits 16-23
        ULONG       Info_length:8;          // bits 24-31

} CONFIG_ROM_HEADER_REGISTER, *PCONFIG_ROM_HEADER_REGISTER;

typedef struct _BUS_OPTIONS_REGISTER {

        ULONG       Link_spd:3;             // bits 0-2
        ULONG       Reserved0:3;            // bits 3-5
        ULONG       g:2;                    // bits 6-7
        ULONG       Reserved1:4;            // bits 8-11
        ULONG       Max_rec:4;              // bits 12-15
        ULONG       Cyc_clk_acc:8;          // bits 16-23
        ULONG       Reserved2:3;            // bits 24-26
        ULONG       Pmc:1;                  // bit 27
        ULONG       Bmc:1;                  // bit 28
        ULONG       Isc:1;                  // bit 29
        ULONG       Cmc:1;                  // bit 30
        ULONG       Irmc:1;                 // bit 31

} BUS_OPTIONS_REGISTER, *PBUS_OPTIONS_REGISTER;

typedef struct _HC_CONTROL_REGISTER {

        ULONG       Reserved:16;            // Bit 0-15
        ULONG       SoftReset:1;            // Bit 16
        ULONG       LinkEnable:1;           // Bit 17
        ULONG       PostedWriteEnable:1;    // Bit 18
        ULONG       Lps:1;                  // bit 19
        ULONG       Reserved2:2;            // Bits 20-21
        ULONG       APhyEnhanceEnable:1;    // bit 22
        ULONG       ProgramPhyEnable:1;     // bit 23
        ULONG       Reserved3:6;            // bits 24-29
        ULONG       NoByteSwapData:1;       // Bit 30
        ULONG       Reserved4:1;            // Bit 31

} HC_CONTROL_REGISTER, *PHC_CONTROL_REGISTER;

typedef struct _FAIRNESS_CONTROL_REGISTER {

    ULONG       Pri_req:8;                  // Bits 0-7
    ULONG       Reserved0:24;                // Bit 8-31

} FAIRNESS_CONTROL_REGISTER;

typedef struct _LINK_CONTROL_REGISTER {

        ULONG       Reserved0:4;            // Bits 0-3
        ULONG       CycleSyncLReqEnable:1;  // Bit 4
        ULONG       Reserved1:4;            // Bits 5-8
        ULONG       RcvSelfId:1;            // Bit 9
        ULONG       RcvPhyPkt:1;            // Bit 10
        ULONG       Reserved2:9;            // Bits 11-19
        ULONG       CycleTimerEnable:1;     // Bit 20
        ULONG       CycleMaster:1;          // Bit 21
        ULONG       CycleSource:1;          // Bit 22
        ULONG       Reserved3:9;            // Bits 23-31

} LINK_CONTROL_REGISTER, *PLINK_CONTROL_REGISTER;

typedef struct _NODE_ID_REGISTER {
        ULONG       NodeId:6;               // Bits 0-5
        ULONG       BusId:10;               // Bits 6-15
        ULONG       Reserved1:11;           // Bits 16-26;
        ULONG       Cps:1;                  // Bit  27;
        ULONG       Reserved2:2;            // Bits 28-29
        ULONG       Root:1;                 // Bit  30
        ULONG       IdValid:1;              // Bit  31

} NODE_ID_REGISTER, *PNODE_ID_REGISTER;

typedef struct _SELF_ID_BUFFER_REGISTER {
        union {

            ULONG   SelfIdBufferPointer;

            struct {
                ULONG   Reserved0:11;       // bits 0-10
                ULONG   SelfIdBuffer:21;    // Bits 11-32
            } bits; 

        } u;

} SELF_ID_BUFFER_REGISTER, *PSELF_ID_BUFFER_REGISTER;

typedef struct _SELF_ID_COUNT_REGISTER {

        ULONG       Reserved0:2;            // bits 0-1
        ULONG       SelfIdSize:11;          // Bits 2-12
        ULONG       Reserved1:3;            // bits 13-15
        ULONG       SelfIdGeneration:8;     // bits 16-23
        ULONG       Reserved2:7;            // bits 24-30
        ULONG       SelfIdError:1;          // bit 31

} SELF_ID_COUNT_REGISTER, *PSELF_ID_COUNT_REGISTER;

typedef struct _PHY_CONTROL_REGISTER {

    ULONG   WrData:8;                       // bits 0-7
    ULONG   RegAddr:4;                      // bits 8-11
    ULONG   Reserved0:2;                    // bits 12-13
    ULONG   WrReg:1;                        // bit 14
    ULONG   RdReg:1;                        // bit 15
    ULONG   RdData:8;                       // bits 16-23
    ULONG   RdAddr:4;                       // bits 24-27
    ULONG   Reserved1:3;                    // bits 28-30
    ULONG   RdDone:1;                       // bit 31

} PHY_CONTROL_REGISTER, *PPHY_CONTROL_REGISTER;

typedef struct _ISOCH_CYCLE_TIMER_REGISTER {

    ULONG   CycleOffset:12;                 // bits 0-11
    ULONG   CycleCount:13;                  // bits 12-24
    ULONG   CycleSeconds:7;                 // bits 25-31

} ISOCH_CYCLE_TIMER_REGISTER, *PISOCH_CYCLE_TIMER_REGISTER;

typedef struct _INT_EVENT_MASK_REGISTER {
        ULONG       ReqTxComplete:1;        // Bit 0
        ULONG       RspTxComplete:1;        // Bit 1
        ULONG       ARRQ:1;                 // Bit 2
        ULONG       ARRS:1;                 // Bit 3
        ULONG       RQPkt:1;                // Bit 4
        ULONG       RSPPkt:1;               // Bit 5
        ULONG       IsochTx:1;              // Bit 6
        ULONG       IsochRx:1;              // Bit 7
        ULONG       PostedWriteErr:1;       // Bit 8
        ULONG       LockRespErr:1;          // Bit 9
        ULONG       Reserved0:6;            // Bits 10-15
        ULONG       SelfIdComplete:1;       // Bit 16
        ULONG       BusReset:1;             // Bit 17
        ULONG       Reserved1:1;            // Bit 18
        ULONG       Phy:1;                  // Bit 19
        ULONG       CycleSynch:1;           // Bit 20
        ULONG       Cycle64Secs:1;          // Bit 21
        ULONG       CycleLost:1;            // Bit 22
        ULONG       CycleInconsistent:1;    // Bit 23
        ULONG       UnrecoverableError:1;   // Bit 24
        ULONG       CycleTooLong:1;         // Bit 25
        ULONG       PhyRegRcvd:1;           // Bit 26
        ULONG       Reserved2:3;            // Bits 27-29
        ULONG       VendorSpecific:1;       // Bit 30
        ULONG       MasterIntEnable:1;      // Bit 31
} INT_EVENT_MASK_REGISTER, *PINT_EVENT_MASK_REGISTER;


typedef struct COMMAND_POINTER_REGISTER {

        ULONG       Z:4;                    // bits 0-3
        ULONG       DescriptorAddr:28;      // bits 4-31

} COMMAND_POINTER_REGISTER, *PCOMMAND_POINTER_REGISTER;

typedef struct CONTEXT_CONTROL_REGISTER {

        ULONG       EventCode:5;            // bits 0-4
        ULONG       Spd:3;                  // bits 5-7
        ULONG       Reserved0:2;            // bits 8-9
        ULONG       Active:1;               // bit 10
        ULONG       Dead:1;                 // bit 11
        ULONG       Wake:1;                 // bit 12
        ULONG       Reserved1:2;            // bits 13-14
        ULONG       Run:1;                  // bit 15
        ULONG       Reserved2:16;           // bits 16-31

} CONTEXT_CONTROL_REGISTER, *PCONTEXT_CONTROL_REGISTER;

typedef struct IT_CONTEXT_CONTROL_REGISTER {

        ULONG       EventCode:5;            // bits 0-4
        ULONG       Spd:3;                  // bits 5-7
        ULONG       Reserved0:2;            // bits 8-9
        ULONG       Active:1;               // bit 10
        ULONG       Dead:1;                 // bit 11
        ULONG       Wake:1;                 // bit 12
        ULONG       Reserved1:2;            // bits 13-14
        ULONG       Run:1;                  // bit 15
        ULONG       CycleMatch:15;          // bits 16-30
        ULONG       CycleMatchEnable:1;     // bit 31

} IT_CONTEXT_CONTROL_REGISTER, *PIT_CONTEXT_CONTROL_REGISTER;

typedef struct IR_CONTEXT_CONTROL_REGISTER {

        ULONG       EventCode:5;            // bits 0-4
        ULONG       Spd:3;                  // bits 5-7
        ULONG       Reserved0:2;            // bits 8-9
        ULONG       Active:1;               // bit 10
        ULONG       Dead:1;                 // bit 11
        ULONG       Wake:1;                 // bit 12
        ULONG       Reserved1:2;            // bits 13-14
        ULONG       Run:1;                  // bit 15
        ULONG       CycleMatch:12;          // bits 16-27
        ULONG       MultiChanMode:1;        // bit 28
        ULONG       CycleMatchEnable:1;     // bit 29
        ULONG       IsochHeader:1;          // bit 30
        ULONG       BufferFill:1;           // bit 31

} IR_CONTEXT_CONTROL_REGISTER, *PIR_CONTEXT_CONTROL_REGISTER;

typedef struct _CONTEXT_MATCH_REGISTER {

        ULONG       ChannelNumber:6;        // bits 0-5
        ULONG       Reserved:1;             // bit 6
        ULONG       Tag1SyncFilter:1;       // bit 7
        ULONG       Sync:4;                 // bits 8-11
        ULONG       CycleMatch:13;          // bits 12-24
        ULONG       Reserved1:3;            // bits 25-27
        ULONG       Tag:4;                  // bit 28-31

} CONTEXT_MATCH_REGISTER, *PCONTEXT_MATCH_REGISTER;

typedef struct _DMA_CONTEXT_REGISTERS {

        CONTEXT_CONTROL_REGISTER    ContextControlSet; 
        CONTEXT_CONTROL_REGISTER    ContextControlClear;
        ULONG                       Reserved0[1];      
        COMMAND_POINTER_REGISTER    CommandPtr;   
        ULONG                       Reserved1[4]; 

} DMA_CONTEXT_REGISTERS, *PDMA_CONTEXT_REGISTERS;

typedef struct _DMA_ISOCH_RCV_CONTEXT_REGISTERS {

        IR_CONTEXT_CONTROL_REGISTER ContextControlSet; 
        IR_CONTEXT_CONTROL_REGISTER ContextControlClear;
        ULONG                       Reserved0[1];      
        COMMAND_POINTER_REGISTER    CommandPtr;   
        CONTEXT_MATCH_REGISTER      ContextMatch; 
        ULONG                       Reserved1[3];

} DMA_ISOCH_RCV_CONTEXT_REGISTERS, *PDMA_ISOCH_RCV_CONTEXT_REGISTERS;

typedef struct _DMA_ISOCH_XMIT_CONTEXT_REGISTERS {

        IT_CONTEXT_CONTROL_REGISTER ContextControlSet; 
        IT_CONTEXT_CONTROL_REGISTER ContextControlClear;
        ULONG                       Reserved0[1];      
        COMMAND_POINTER_REGISTER    CommandPtr;   

} DMA_ISOCH_XMIT_CONTEXT_REGISTERS, *PDMA_ISOCH_XMIT_CONTEXT_REGISTERS;

typedef struct _OHCI_REGISTER_MAP {

        VERSION_REGISTER            Version;                // @ 0
        GUID_ROM_REGISTER           GUID_ROM;               // @ 4
        AT_RETRIES_REGISTER         ATRetries;              // @ 8
        ULONG                       CsrData;                // @ C
        ULONG                       CsrCompare;             // @ 10
        CSR_CONTROL_REGISTER        CsrControl;             // @ 14
        CONFIG_ROM_HEADER_REGISTER  ConfigRomHeader;        // @ 18
        ULONG                       BusId;                  // @ 1C
        BUS_OPTIONS_REGISTER        BusOptions;             // @ 20
        ULONG                       GuidHi;                 // @ 24
        ULONG                       GuidLo;                 // @ 28
        ULONG                       Reserved0[2];           // @ 2C
        ULONG                       ConfigRomMap;           // @ 34

        ULONG                       PostedWriteAddressLo;   // @ 38
        ULONG                       PostedWriteAddressHi;   // @ 3C

        VENDOR_ID_REGISTER          VendorId;               // @ 40
        ULONG                       Reserved1[3];           // @ 44

        HC_CONTROL_REGISTER         HCControlSet;           // @ 50
        HC_CONTROL_REGISTER         HCControlClear;         // @ 54

        ULONG                       Reserved2[3];           // @ 58

        SELF_ID_BUFFER_REGISTER     SelfIdBufferPtr;        // @ 64
        SELF_ID_COUNT_REGISTER      SelfIdCount;            // @ 68

        ULONG                       Reserved3[1];           // @ 6C

        ULONG                       IRChannelMaskHiSet;     // @ 70
        ULONG                       IRChannelMaskHiClear;   // @ 74
        ULONG                       IRChannelMaskLoSet;     // @ 78
        ULONG                       IRChannelMaskLoClear;   // @ 7C

        INT_EVENT_MASK_REGISTER     IntEventSet;            // @ 80
        INT_EVENT_MASK_REGISTER     IntEventClear;          // @ 84

        INT_EVENT_MASK_REGISTER     IntMaskSet;             // @ 88
        INT_EVENT_MASK_REGISTER     IntMaskClear;           // @ 8C

        ULONG                       IsoXmitIntEventSet;     // @ 90
        ULONG                       IsoXmitIntEventClear;   // @ 94

        ULONG                       IsoXmitIntMaskSet;      // @ 98
        ULONG                       IsoXmitIntMaskClear;    // @ 9C

        ULONG                       IsoRecvIntEventSet;     // @ A0
        ULONG                       IsoRecvIntEventClear;   // @ A4

        ULONG                       IsoRecvIntMaskSet;      // @ A8
        ULONG                       IsoRecvIntMaskClear;    // @ AC

        ULONG                       Reserved4[11];          // @ B0

        FAIRNESS_CONTROL_REGISTER   FairnessControl;        // @ DC

        LINK_CONTROL_REGISTER       LinkControlSet;         // @ E0
        LINK_CONTROL_REGISTER       LinkControlClear;       // @ E4

        NODE_ID_REGISTER            NodeId;                 // @ E8
        PHY_CONTROL_REGISTER        PhyControl;             // @ EC

        ISOCH_CYCLE_TIMER_REGISTER  IsochCycleTimer;        // @ F0

        ULONG                       Reserved5[3];           // @ F4

        ULONG                       AsynchReqFilterHiSet;   // @ 100
        ULONG                       AsynchReqFilterHiClear; // @ 104

        ULONG                       AsynchReqFilterLoSet;   // @ 108
        ULONG                       AsynchReqFilterLoClear; // @ 10C

        ULONG                       PhyReqFilterHiSet;      // @ 110
        ULONG                       PhyReqFilterHiClear;    // @ 114

        ULONG                       PhyReqFilterLoSet;      // @ 118
        ULONG                       PhyReqFilterLoClear;    // @ 11C

        ULONG                       PhysicalUpperBound;     // @ 120
        ULONG                       Reserved6[23];          // @ 124

        DMA_CONTEXT_REGISTERS       AsynchContext[4];       // @ 180
        // ATRsp_Context;   // @ 1A0
        // ARReq_Context;   // @ 1C0
        // ARRsp_Context;   // @ 1E0

        DMA_ISOCH_XMIT_CONTEXT_REGISTERS IT_Context[32];    // @ 200

        DMA_ISOCH_RCV_CONTEXT_REGISTERS IR_Context[32];     // @ 400

} OHCI_REGISTER_MAP, *POHCI_REGISTER_MAP;

typedef struct _OHCI1394_PHY_REGISTER_MAP {

        UCHAR       Cable_Power_Status:1;           // @ reg 0
        UCHAR       Root:1;
        UCHAR       Physical_ID:6;
        UCHAR       Gap_Count:6;                    // @ reg 1
        UCHAR       Initiate_BusReset:1;
        UCHAR       Root_Hold_Off:1;
        UCHAR       Number_Ports:4;                 // @ reg 2
        UCHAR       Reserved:2;
        UCHAR       Speed:2;
        UCHAR       Reserved1:2;                    // @ reg 3
        UCHAR       Connected1:1;
        UCHAR       Child1:1;
        UCHAR       BStat1:2;
        UCHAR       AStat1:2;
        UCHAR       Reserved2:2;                    // @ reg 4
        UCHAR       Connected2:1;
        UCHAR       Child2:1;
        UCHAR       BStat2:2;
        UCHAR       AStat2:2;                       // in 1394A, bit 0 of Astat, is the contender bit
        UCHAR       Reserved3:2;                    // @ reg 5
        UCHAR       Connected3:1;
        UCHAR       Child3:1;
        UCHAR       BStat3:2;
        UCHAR       AStat3:2;
        UCHAR       Manager_Capable:1;              // @ reg 6
        UCHAR       Reserved4:3;
        UCHAR       Initiated_Reset:1;
        UCHAR       Cable_Power_Stat:1;
        UCHAR       Cable_Power_Status_Int:1;
        UCHAR       Loop_Int:1;

} OHCI1394_PHY_REGISTER_MAP, *POHCI1394_PHY_REGISTER_MAP;

typedef struct _OHCI1394A_PHY_REGISTER_MAP {

        UCHAR       Cable_Power_Status:1;           // @ reg 0
        UCHAR       Root:1;
        UCHAR       Physical_ID:6;
        UCHAR       Gap_Count:6;                    // @ reg 1
        UCHAR       Initiate_BusReset:1;
        UCHAR       Root_Hold_Off:1;
        UCHAR       Number_Ports:4;                 // @ reg 2
        UCHAR       Reserved1:1;
        UCHAR       Extended:3;
        UCHAR       Delay:4;                        // @ reg 3
        UCHAR       Reserved2:1;
        UCHAR       Max_Speed:3;                        
        UCHAR       Pwr:3;                          // @ reg 4
        UCHAR       Jitter:3;
        UCHAR       Contender:1;
        UCHAR       Link_Active:1;
        UCHAR       Enab_Multi:1;                   // @ reg 5
        UCHAR       Enab_Accel:1;
        UCHAR       Port_event:1;
        UCHAR       Timeout:1;
        UCHAR       Pwr_Fail:1;
        UCHAR       Loop:1;
        UCHAR       ISBR:1;
        UCHAR       Resume_int:1;
        UCHAR       Reg6Reserved:8;                 // @ reg 6
        UCHAR       PortSelect:4;                   // @ reg 7
        UCHAR       Reserved3:1;
        UCHAR       PageSelect:3;
        UCHAR       Register0:8;
        UCHAR       Register1:8;
        UCHAR       Register2:8;
        UCHAR       Register3:8;
        UCHAR       Register4:8;
        UCHAR       Register5:8;
        UCHAR       Register6:8;
        UCHAR       Register7:8;

} OHCI1394A_PHY_REGISTER_MAP, *POHCI1394A_PHY_REGISTER_MAP;

typedef struct _OHCI_SELF_ID_PACKET_HEADER {

            ULONG       TimeStamp:16;       // bits 0-15
            ULONG       SelfIdGeneration:8; // bits 16-23
            ULONG       Reserved:8;         // bits 24-31

} OHCI_SELF_ID_PACKET_HEADER, *POHCI_SELF_ID_PACKET_HEADER;

typedef struct _OHCI_IT_ISOCH_HEADER {

            ULONG       OHCI_Sy:4;          // bits 0-3
            ULONG       OHCI_Tcode:4;       // bits 4-7
            ULONG       OHCI_ChanNum:6;     // bits 8-13
            ULONG       OHCI_Tag:2;         // bits 14-15
            ULONG       OHCI_Spd:3;         // bits 16-18
            ULONG       OHCI_Reserved:13;   // bits 19-31

            USHORT      OHCI_Reserved1;
            USHORT      OHCI_DataLength;
            
} OHCI_IT_ISOCH_HEADER, *POHCI_IT_ISOCH_HEADER;

typedef struct _BUS1394_NODE_ADDRESS {
    USHORT              NA_Node_Number:6;       // Bits 10-15
    USHORT              NA_Bus_Number:10;       // Bits 0-9
} BUS1394_NODE_ADDRESS, *PBUS1394_NODE_ADDRESS;

//
// Definition of Command Descriptor Lists (CDL's)
//
typedef struct _COMMAND_DESCRIPTOR {

    struct {

        ULONG       ReqCount:16;            // bits 0-15
        ULONG       w:2;                    // bits 16-17
        ULONG       b:2;                    // bits 18-19
        ULONG       i:2;                    // bits 20-21
        ULONG       Reserved1:1;            // bit 22
        ULONG       p:1;                    // bit 23
        ULONG       Key:3;                  // bits 24-26
        ULONG       Status:1;               // bit 27
        ULONG       Cmd:4;                  // bits 28-31

    } Header;

    ULONG   DataAddress;

    union {

        ULONG BranchAddress;

        struct {

            ULONG   Z:4;                    // bits 0-3
            ULONG   Reserved:28;            // bits 4-31

        } z;

    } u;
    
    struct {
        
        union {
            USHORT  TimeStamp:16;           // bits 0-15
            USHORT  ResCount:16;            // bits 0-15
        } u;
        
        USHORT XferStatus;              // bits 16-31

    } Status;

} COMMAND_DESCRIPTOR, *PCOMMAND_DESCRIPTOR;

typedef struct _OHCI_ASYNC_PACKET {


    USHORT              OHCI_Reserved3:4;      
    USHORT              OHCI_tCode:4;        
    USHORT              OHCI_rt:2;            
    USHORT              OHCI_tLabel:6;        

    union {

        struct {
           BUS1394_NODE_ADDRESS        OHCI_Destination_ID; // 1st quadlet
        } Rx;

        struct {

            USHORT              OHCI_spd:3;         // 1st quadlet
            USHORT              OHCI_Reserved2:4;
            USHORT              OHCI_srcBusId:1;
            USHORT              OHCI_Reserved:8;          

        } Tx;

    } u;
    
    union {

        USHORT          OHCI_Offset_High;     
        struct {

            USHORT      OHCI_Reserved2:8;
            USHORT      OHCI_Reserved1:4;
            USHORT      OHCI_Rcode:4;

        } Response;

    } u2;

    union {
        struct {
            BUS1394_NODE_ADDRESS        OHCI_Destination_ID;    // 2nd quadlet
        } Tx;

        struct {
            BUS1394_NODE_ADDRESS        OHCI_Source_ID;         // 2nd quadlet
        } Rx;
        
    } u1;
    
    ULONG               OHCI_Offset_Low;     // 3rd quadlet

    union {
        struct {

            USHORT      OHCI_Extended_tCode;  
            USHORT      OHCI_Data_Length;    // 4th quadlet

        } Block;
        ULONG           OHCI_Quadlet_Data;   // 4th quadlet
    } u3;
        
} OHCI_ASYNC_PACKET, *POHCI_ASYNC_PACKET;


typedef struct _DESCRIPTOR_BLOCK {

    union {

        COMMAND_DESCRIPTOR CdArray[MAX_OHCI_COMMAND_DESCRIPTOR_BLOCKS];

        struct {
            COMMAND_DESCRIPTOR Cd;
            OHCI_ASYNC_PACKET  Pkt;
        } Imm;
        

    }u;
    
} DESCRIPTOR_BLOCK, *PDESCRIPTOR_BLOCK;

//
// phy access operations
//

#define OHCI_PHY_ACCESS_SET_CONTENDER           0x01000000
#define OHCI_PHY_ACCESS_SET_GAP_COUNT           0x02000000
#define OHCI_PHY_ACCESS_RAW_READ                0x10000000
#define OHCI_PHY_ACCESS_RAW_WRITE               0x20000000

//
// 1394 Speed codes
//

#define SCODE_100_RATE                          0
#define SCODE_200_RATE                          1
#define SCODE_400_RATE                          2
#define SCODE_800_RATE                          3
#define SCODE_1600_RATE                         4
#define SCODE_3200_RATE                         5

#define TCODE_WRITE_REQUEST_QUADLET             0           // 0000b
#define TCODE_WRITE_REQUEST_BLOCK               1           // 0001b
#define TCODE_WRITE_RESPONSE                    2           // 0010b
#define TCODE_RESERVED1                         3
#define TCODE_READ_REQUEST_QUADLET              4           // 0100b
#define TCODE_READ_REQUEST_BLOCK                5           // 0101b
#define TCODE_READ_RESPONSE_QUADLET             6           // 0110b
#define TCODE_READ_RESPONSE_BLOCK               7           // 0111b
#define TCODE_CYCLE_START                       8           // 1000b
#define TCODE_LOCK_REQUEST                      9           // 1001b
#define TCODE_ISOCH_DATA_BLOCK                  10          // 1010b
#define TCODE_LOCK_RESPONSE                     11          // 1011b
#define TCODE_RESERVED2                         12
#define TCODE_RESERVED3                         13
#define TCODE_SELFID                            14
#define TCODE_RESERVED4                         15

//
// IEEE 1212 Configuration Rom header definition
//
typedef struct _CONFIG_ROM_INFO {
    union {
        USHORT          CRI_CRC_Value:16;
        struct {
            UCHAR       CRI_Saved_Info_Length;
            UCHAR       CRI_Saved_CRC_Length;
        } Saved;
    } u;
    UCHAR               CRI_CRC_Length;
    UCHAR               CRI_Info_Length;
} CONFIG_ROM_INFO, *PCONFIG_ROM_INFO;

//
// IEEE 1212 Immediate entry definition
//
typedef struct _IMMEDIATE_ENTRY {
    ULONG               IE_Value:24;
    ULONG               IE_Key:8;
} IMMEDIATE_ENTRY, *PIMMEDIATE_ENTRY;

//
// IEEE 1212 Directory definition
//
typedef struct _DIRECTORY_INFO {
    union {
        USHORT          DI_CRC;
        USHORT          DI_Saved_Length;
    } u;
    USHORT              DI_Length;
} DIRECTORY_INFO, *PDIRECTORY_INFO;

//
// IEEE 1212 Node Capabilities entry definition
//
typedef struct _NODE_CAPABILITES {
    ULONG               NC_Init:1;                  // These can be found
    ULONG               NC_Ded:1;                   // in the IEEE 1212 doc
    ULONG               NC_Off:1;
    ULONG               NC_Atn:1;
    ULONG               NC_Elo:1;
    ULONG               NC_Reserved1:1;
    ULONG               NC_Drq:1;
    ULONG               NC_Lst:1;
    ULONG               NC_Fix:1;
    ULONG               NC_64:1;
    ULONG               NC_Prv:1;
    ULONG               NC_Bas:1;
    ULONG               NC_Ext:1;
    ULONG               NC_Int:1;
    ULONG               NC_Ms:1;
    ULONG               NC_Spt:1;
    ULONG               NC_Reserved2:8;
    ULONG               NC_Key:8;
} NODE_CAPABILITIES, *PNODE_CAPABILITIES;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\kd1394\pch.h ===
/*++
Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    1394 Kernel Debugger DLL

Author:

    Peter Binder (pbinder)

Revision   History:
Date       Who       What
---------- --------- ------------------------------------------------------------
06/21/2001 pbinder   having fun...
--*/

#include "nthal.h"
#include "kdbg1394.h"

#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "stdlib.h"
#include "kddll.h"
#include "stdio.h"
#include "pci.h"
#include "ohci1394.h"
#include "kd1394.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\kd1394\ohci1394.c ===
/*++
Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    ohci1394.c

Abstract:

    1394 Kernel Debugger DLL

Author:

    Peter Binder (pbinder)

Revision   History:
Date       Who       What
---------- --------- ------------------------------------------------------------
06/21/2001 pbinder   having fun...
--*/

#define _OHCI1394_C
#include "pch.h"
#undef _OHCI1394_C

ULONG
FASTCALL
Dbg1394_ByteSwap(
    IN ULONG Source
    )
/*++

Routine Description:

    The RtlUlongByteSwap function exchanges byte pairs 0:3 and 1:2 of
    Source and returns the resulting ULONG.

Arguments:

    Source - 32-bit value to byteswap.

Return Value:

    Swapped 32-bit value.

--*/
{
    ULONG swapped;

    swapped = ((Source)              << (8 * 3)) |
              ((Source & 0x0000FF00) << (8 * 1)) |
              ((Source & 0x00FF0000) >> (8 * 1)) |
              ((Source)              >> (8 * 3));

    return swapped;
} // Dbg1394_ByteSwap

ULONG
Dbg1394_CalculateCrc(
    IN PULONG Quadlet,
    IN ULONG length
    )
/*++

Routine Description:

    This routine calculates a CRC for the pointer to the Quadlet data.

Arguments:

    Quadlet - Pointer to data to CRC

    length - length of data to CRC

Return Value:

    returns the CRC

--*/
{
    LONG temp;
    ULONG index;

    temp = index = 0;

    while (index < length) {

        temp = Dbg1394_Crc16(Quadlet[index++], temp);
    }

    return (temp);
} // Dbg1394_CalculateCrc

ULONG
Dbg1394_Crc16(
    IN ULONG data,
    IN ULONG check
    )
/*++

Routine Description:

    This routine derives the 16 bit CRC as defined by IEEE 1212
    clause 8.1.5.  (ISO/IEC 13213) First edition 1994-10-05.

Arguments:

    data - ULONG data to derive CRC from

    check - check value

Return Value:

    Returns CRC.

--*/
{
    LONG shift, sum, next;

    for (next = check, shift = 28; shift >= 0; shift -= 4) {

        sum = ((next >> 12) ^ (data >> shift)) & 0xf;
        next = (next << 4) ^ (sum << 12) ^ (sum << 5) ^ (sum);
    }

    return(next & 0xFFFF);
} // Dbg1394_Crc16

NTSTATUS
Dbg1394_ReadPhyRegister(
    PDEBUG_1394_DATA    DebugData,
    ULONG               Offset,
    PUCHAR              pData
    )
{
    union {
        ULONG                   AsUlong;
        PHY_CONTROL_REGISTER    PhyControl;
    } u;

    ULONG   retry = 0;

    u.AsUlong = 0;
    u.PhyControl.RdReg = TRUE;
    u.PhyControl.RegAddr = Offset;

    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyControl, u.AsUlong);

    retry = MAX_REGISTER_READS;

    do {

        u.AsUlong = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyControl);

    } while ((!u.PhyControl.RdDone) && --retry);


    if (!retry) {

        return(STATUS_UNSUCCESSFUL);
    }

    *pData = (UCHAR)u.PhyControl.RdData;
    return(STATUS_SUCCESS);
} // Dbg1394_ReadPhyRegister

NTSTATUS
Dbg1394_WritePhyRegister(
    PDEBUG_1394_DATA    DebugData,
    ULONG               Offset,
    UCHAR               Data
    )
{
    union {
        ULONG                   AsUlong;
        PHY_CONTROL_REGISTER    PhyControl;
    } u;

    ULONG   retry = 0;

    u.AsUlong = 0;
    u.PhyControl.WrReg = TRUE;
    u.PhyControl.RegAddr = Offset;
    u.PhyControl.WrData = Data;

    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyControl, u.AsUlong);

    retry = MAX_REGISTER_READS;

    do {

        u.AsUlong = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyControl);

    } while (u.PhyControl.WrReg && --retry);

    if (!retry) {

        return(STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);
} // Dbg1394_WritePhyRegister

BOOLEAN
Dbg1394_InitializeController(
    IN PDEBUG_1394_DATA         DebugData,
    IN PDEBUG_1394_PARAMETERS   DebugParameters
    )
{
    BOOLEAN             bReturn = TRUE;

    ULONG               ulVersion;
    UCHAR               MajorVersion;
    UCHAR               MinorVersion;

    ULONG               ReadRetry;

    PHYSICAL_ADDRESS    physAddr;

    UCHAR               Data;
    NTSTATUS            ntStatus;

    union {
        ULONG                       AsUlong;
        HC_CONTROL_REGISTER         HCControl;
        LINK_CONTROL_REGISTER       LinkControl;
        NODE_ID_REGISTER            NodeId;
        CONFIG_ROM_INFO             ConfigRomHeader;
        BUS_OPTIONS_REGISTER        BusOptions;
        IMMEDIATE_ENTRY             CromEntry;
        DIRECTORY_INFO              DirectoryInfo;
    } u;

    // initialize our bus info
    DebugData->Config.Tag = DEBUG_1394_CONFIG_TAG;
    DebugData->Config.MajorVersion = DEBUG_1394_MAJOR_VERSION;
    DebugData->Config.MinorVersion = DEBUG_1394_MINOR_VERSION;
    DebugData->Config.Id = DebugParameters->Id;
    DebugData->Config.BusPresent = FALSE;
    DebugData->Config.SendPacket = MmGetPhysicalAddress(&DebugData->SendPacket);
    DebugData->Config.ReceivePacket = MmGetPhysicalAddress(&DebugData->ReceivePacket);

    // get our base address
    DebugData->BaseAddress = \
        (POHCI_REGISTER_MAP)DebugParameters->DbgDeviceDescriptor.BaseAddress[0].TranslatedAddress;

    // get our version
    ulVersion = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->Version);

    MajorVersion = (UCHAR)(ulVersion >> 16);
    MinorVersion = (UCHAR)ulVersion;

    // make sure we have a valid version
    if (MajorVersion != 1) { // INVESTIGATE

        bReturn = FALSE;
        goto Exit_Dbg1394_InitializeController;
    }

    // soft reset to initialize the controller
    u.AsUlong = 0;
    u.HCControl.SoftReset = TRUE;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->HCControlSet, u.AsUlong);

    // wait until reset complete - ??
    ReadRetry = 1000; // ??

    do {

        u.AsUlong = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->HCControlSet);
        Dbg1394_StallExecution(1);

    } while ((u.HCControl.SoftReset) && (--ReadRetry));

    // see if reset succeeded
    if (ReadRetry == 0) {

        bReturn = FALSE;
        goto Exit_Dbg1394_InitializeController;
    }

    // what's this do???
    u.AsUlong = 0;
    u.HCControl.Lps = TRUE;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->HCControlSet, u.AsUlong);

    Dbg1394_StallExecution(20);

    // initialize HCControl register
    u.AsUlong = 0;
    u.HCControl.NoByteSwapData = TRUE;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->HCControlClear, u.AsUlong);

    u.AsUlong = 0;
    u.HCControl.PostedWriteEnable = TRUE;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->HCControlSet, u.AsUlong);

    // setup the link control
    u.AsUlong = 0x0;
    u.LinkControl.CycleTimerEnable = TRUE;
    u.LinkControl.CycleMaster = TRUE;
    u.LinkControl.RcvPhyPkt = TRUE;
    u.LinkControl.RcvSelfId = TRUE;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->LinkControlClear, u.AsUlong);

    u.AsUlong = 0;
    u.LinkControl.CycleTimerEnable = TRUE;
    u.LinkControl.CycleMaster = TRUE;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->LinkControlSet, u.AsUlong);

    // set the bus number (hardcoded to 0x3FF) - ??? what about node id??
    u.AsUlong = 0;
    u.NodeId.BusId = (USHORT)0x3FF;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->NodeId, u.AsUlong);

    // ???????????????
    // IA64 BUGBUG assumes that our global buffers, that were loaded with our 
    // image are placed < 32bit memory
    // ???????????????

    // do something with the crom...

    // 0xf0000404 - bus id register
    DebugData->CromBuffer[1] = 0x31333934;

    // 0xf0000408 - bus options register
    u.AsUlong = Dbg1394_ByteSwap(READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->BusOptions));
    u.BusOptions.Pmc = FALSE;
    u.BusOptions.Bmc = FALSE;
    u.BusOptions.Isc = FALSE;
    u.BusOptions.Cmc = FALSE;
    u.BusOptions.Irmc = FALSE;
    u.BusOptions.g = 1;
    DebugData->CromBuffer[2] = Dbg1394_ByteSwap(u.AsUlong);

    // 0xf000040c - global unique id hi
    u.AsUlong = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->GuidHi);
    DebugData->CromBuffer[3] = u.AsUlong;

    // 0xf0000410 - global unique id lo
    u.AsUlong = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->GuidLo);
    DebugData->CromBuffer[4] = u.AsUlong;

    // 0xf0000400 - config rom header - set last to calculate CRC!
    u.AsUlong = 0;
    u.ConfigRomHeader.CRI_Info_Length = 4;
    u.ConfigRomHeader.CRI_CRC_Length = 4;
    u.ConfigRomHeader.u.CRI_CRC_Value = (USHORT)Dbg1394_CalculateCrc( &DebugData->CromBuffer[1],
                                                                      u.ConfigRomHeader.CRI_CRC_Length
                                                                      );
    DebugData->CromBuffer[0] = u.AsUlong;

    // 0xf0000418 - node capabilities
    DebugData->CromBuffer[6] = 0xC083000C;

    // 0xf000041C - module vendor id
    DebugData->CromBuffer[7] = 0xF2500003;

    // 0xf0000420 - extended key
    DebugData->CromBuffer[8] = 0xF250001C;

    // 0xf0000424 - debug key
    DebugData->CromBuffer[9] = 0x0200001D;

    // 0xf0000428 - debug value
    physAddr = MmGetPhysicalAddress(&DebugData->Config);
    u.AsUlong = (ULONG)physAddr.LowPart;
    u.CromEntry.IE_Key = 0x1E;
    DebugData->CromBuffer[10] = Dbg1394_ByteSwap(u.AsUlong);

    // 0xf0000414 - root directory header - set last to calculate CRC!
    u.AsUlong = 0;
    u.DirectoryInfo.DI_Length = 5;
    u.DirectoryInfo.u.DI_CRC = (USHORT)Dbg1394_CalculateCrc( &DebugData->CromBuffer[6],
                                                             u.DirectoryInfo.DI_Length
                                                             );
    DebugData->CromBuffer[5] = Dbg1394_ByteSwap(u.AsUlong);

    // write the first few registers
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->ConfigRomHeader, DebugData->CromBuffer[0]);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->BusId, DebugData->CromBuffer[1]);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->BusOptions, DebugData->CromBuffer[2]);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->GuidHi, DebugData->CromBuffer[3]);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->GuidLo, DebugData->CromBuffer[4]);

    // set our crom
    physAddr = MmGetPhysicalAddress(&DebugData->CromBuffer);

    u.AsUlong = (ULONG)physAddr.LowPart; // FIXFIX quadpart to ulong??
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->ConfigRomMap, u.AsUlong);

    // disable all interrupts. wdm driver will enable them later - ??
    u.AsUlong = 0xFFFFFFFF;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->IntMaskClear, u.AsUlong);

    // enable the link
    u.AsUlong = 0;
    u.HCControl.LinkEnable = TRUE;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->HCControlSet, u.AsUlong);

    Dbg1394_StallExecution(1000);

    // enable access filters to all nodes
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->AsynchReqFilterLoSet, 0xFFFFFFFF);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->AsynchReqFilterHiSet, 0xFFFFFFFF);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyReqFilterHiSet, 0xFFFFFFFF);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyReqFilterLoSet, 0xFFFFFFFF);

    // hard reset on the bus
    ntStatus = Dbg1394_ReadPhyRegister(DebugData, 1, &Data);

    if (NT_SUCCESS(ntStatus)) {

        Data |= PHY_INITIATE_BUS_RESET;
        Dbg1394_WritePhyRegister(DebugData, 1, Data);

        Dbg1394_StallExecution(1000);
    }
    else {

        bReturn = FALSE;
    }

Exit_Dbg1394_InitializeController:

    return(bReturn);
} // Dbg1394_InitializeController

ULONG // ?? need to look into this
Dbg1394_StallExecution(
    ULONG   LoopCount
    )
{
    ULONG i,j,b,k,l;

    b = 1;

    for (k=0;k<LoopCount;k++) {

        for (i=1;i<100000;i++) {

            PAUSE_PROCESSOR
            b=b* (i>>k);
        }
    };

    return(b);
} // Dbg1394_StallExecution

void
Dbg1394_EnablePhysicalAccess(
    IN PDEBUG_1394_DATA     DebugData
    )
{
    union {
        ULONG                       AsUlong;
        INT_EVENT_MASK_REGISTER     IntEvent;
        HC_CONTROL_REGISTER         HCControl;
    } u;

    // see if ohci1394 is being loaded...
    u.AsUlong = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->HCControlSet);

    if (!u.HCControl.LinkEnable || !u.HCControl.Lps || u.HCControl.SoftReset) {

        return;
    }

    // only clear the bus reset interrupt if ohci1394 isn't loaded...
//    if (DebugData->Config.BusPresent == FALSE) {

        // if the bus reset interrupt is not cleared, we have to clear it...
        u.AsUlong = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->IntEventSet);

        if (u.IntEvent.BusReset) {

            WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->IntEventClear, PHY_BUS_RESET_INT);
        }
//    }

    // we might need to reenable physical access, if so, do it.
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->AsynchReqFilterHiSet, 0xFFFFFFFF);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->AsynchReqFilterLoSet, 0xFFFFFFFF);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyReqFilterHiSet, 0xFFFFFFFF);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyReqFilterLoSet, 0xFFFFFFFF);

    return;
} // Dbg1394_EnablePhysicalAccess

ULONG
Dbg1394_ReadPacket(
    PDEBUG_1394_DATA    DebugData,
    OUT PKD_PACKET      PacketHeader,
    OUT PSTRING         MessageHeader,
    OUT PSTRING         MessageData,
    BOOLEAN             Wait
    )
//    KDP_PACKET_RESEND - if resend is required.  = 2 = CP_GET_ERROR
//    KDP_PACKET_TIMEOUT - if timeout.            = 1 = CP_GET_NODATA
//    KDP_PACKET_RECEIVED - if packet received.   = 0 = CP_GET_SUCCESS
{
    ULONG   timeoutLimit = 0;

    do {

        // make sure our link is enabled..
        Dbg1394_EnablePhysicalAccess(Kd1394Data);

        if (DebugData->ReceivePacket.TransferStatus == STATUS_PENDING) {

            *KdDebuggerNotPresent = FALSE;
            SharedUserData->KdDebuggerEnabled |= 0x00000002;

            RtlCopyMemory( PacketHeader,
                           &DebugData->ReceivePacket.Packet[0],
                           sizeof(KD_PACKET)
                           );

            // make sure we have a valid PacketHeader
            if (DebugData->ReceivePacket.Length < sizeof(KD_PACKET)) {

                // short packet, we are done...
                DebugData->ReceivePacket.TransferStatus = STATUS_SUCCESS;
                return(KDP_PACKET_RESEND);
            }

            if (MessageHeader) {

                RtlCopyMemory( MessageHeader->Buffer,
                               &DebugData->ReceivePacket.Packet[sizeof(KD_PACKET)],
                               MessageHeader->MaximumLength
                               );

                if (DebugData->ReceivePacket.Length <= (USHORT)(sizeof(KD_PACKET)+MessageHeader->MaximumLength)) {

                    DebugData->ReceivePacket.TransferStatus = STATUS_SUCCESS;
                    return(KDP_PACKET_RECEIVED);
                }

                if (MessageData) {

                    RtlCopyMemory( MessageData->Buffer,
                                   &DebugData->ReceivePacket.Packet[sizeof(KD_PACKET) + MessageHeader->MaximumLength],
                                   DebugData->ReceivePacket.Length - (sizeof(KD_PACKET) + MessageHeader->MaximumLength)
                                   );
                }
            }

            DebugData->ReceivePacket.TransferStatus = STATUS_SUCCESS;
            return(KDP_PACKET_RECEIVED);
        }

        timeoutLimit++;

        if (Wait == FALSE) {

            return(KDP_PACKET_RESEND);
        }

    } while (timeoutLimit <= TIMEOUT_COUNT);

    return(KDP_PACKET_TIMEOUT);
} // Dbg1394_ReadPacket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\kdcom\kdcom.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    kdcom.c

Abstract:

    Kernel Debugger HW Extension DLL com port debugger support module

Author:

    Eric F. Nelson (enelson) 7-Jan-99

Revision History:

--*/

#include "kdcomp.h"

#define BAUD_OPTION "BAUDRATE"
#define PORT_OPTION "DEBUGPORT"

DEBUG_PARAMETERS KdCompDbgParams = {0, 0};

VOID
SleepResetKd(
    VOID
    );


NTSTATUS
KdD0Transition(
    VOID
    )
/*++

Routine Description:

    The PCI driver (or relevant bus driver) will call this API after it
    processes a D0 IRP for this device

Arguments:

    None

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    return STATUS_SUCCESS;
}



NTSTATUS
KdD3Transition(
    VOID
    )
/*++

Routine Description:

    The PCI driver (or relevant bus driver) will call this API before it
    processes a D3 IRP for this device

Arguments:

    None

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    return STATUS_SUCCESS;
}



NTSTATUS
KdDebuggerInitialize0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This API allows the debugger DLL to parse the boot.ini strings and
    perform any initialization.  It cannot be assumed that the entire NT
    kernel has been initialized at this time.  Memory management services,
    for example, will not be available.  After this call has returned, the
    debugger DLL may receive requests to send and receive packets.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    PCHAR Options;
    NTSTATUS Status;
    PCHAR BaudOption;
    PCHAR PortOption;

    if (LoaderBlock != NULL) {
        if (LoaderBlock->LoadOptions != NULL) {
            Options = LoaderBlock->LoadOptions;
         
            _strupr(Options);

            PortOption = strstr(Options, PORT_OPTION);
            BaudOption = strstr(Options, BAUD_OPTION);

            if (PortOption) {
                PortOption = strstr(PortOption, "COM");
                if (PortOption) {
                    KdCompDbgParams.CommunicationPort = atol(PortOption + 3);
                }
            }

            if (BaudOption) {
                BaudOption += strlen(BAUD_OPTION);
                while (*BaudOption == ' ') {
                    BaudOption++;
                }

                if (*BaudOption != '\0') {
                    KdCompDbgParams.BaudRate = atol(BaudOption + 1);
                }
            }
        }
    }

    Status = KdCompInitialize(&KdCompDbgParams, LoaderBlock);

    //
    // Initialize ID for NEXT packet to send and Expect ID of next incoming
    // packet.
    //
    if (NT_SUCCESS(Status)) {
        KdCompNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
        KdCompPacketIdExpected = INITIAL_PACKET_ID;
    }

    return Status;
}



NTSTATUS
KdDebuggerInitialize1(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This API allows the debugger DLL to do any initialization that it needs
    to do after the NT kernel services are available.  Mm and registry APIs
    will be guaranteed to be available at this time.  If the specific
    debugger DLL implementation uses a PCI device, it will set a registry
    key (discussed later) that notifies the PCI driver that a specific PCI
    device is being used for debugging.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    KdCompInitialize1();
    return STATUS_SUCCESS;
}



NTSTATUS
KdSave(
    IN BOOLEAN KdSleepTransition
    )
/*++

Routine Description:

    The HAL calls this function as late as possible before putting the
    machine to sleep.

Arguments:

    KdSleepTransition - TRUE when transitioning to/from sleep state

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    KdCompSave();

    return STATUS_SUCCESS;
}



NTSTATUS
KdRestore(
    IN BOOLEAN KdSleepTransition
    )
/*++

Routine Description:

    The HAL calls this function as early as possible after resuming from a
    sleep state.

Arguments:

    KdSleepTransition - TRUE when transitioning to/from sleep state

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    //
    // Force resync when transitioning to/from sleep state
    //
    if (KdSleepTransition) {
#ifdef ALPHA
        SleepResetKd();
#else
        KdCompDbgPortsPresent = FALSE;
#endif
    } else {
        KdCompRestore();
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\kdcom\kdcomio.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdcomio.c

Abstract:

    This module implements the I/O comunications for the portable kernel
    debugger.

Author:

    David N. Cutler 27-July-1990

Revision History:

--*/

#include "kdcomp.h"


ULONG
KdpComputeChecksum (
    IN PUCHAR Buffer,
    IN ULONG Length
    );

ULONG
KdpReceiveString (
    OUT PCHAR Destination,
    IN ULONG Length
    );

VOID
KdpSendString (
    IN PCHAR Source,
    IN ULONG Length
    );

VOID
KdpSendControlPacket (
    IN USHORT PacketType,
    IN ULONG PacketId OPTIONAL
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpComputeChecksum)
#pragma alloc_text(PAGEKD, KdCompReceivePacketLeader)
#pragma alloc_text(PAGEKD, KdpReceiveString)
#pragma alloc_text(PAGEKD, KdpSendString)
#pragma alloc_text(PAGEKD, KdpSendControlPacket)
#pragma alloc_text(PAGEKD, KdReceivePacket)
#pragma alloc_text(PAGEKD, KdSendPacket)
#endif

ULONG KdCompPacketIdExpected = 0;
ULONG KdCompNextPacketIdToSend = 0;

//
// KdpRetryCount controls the number of retries before we give
// up and assume kernel debugger is not present.
// KdpNumberRetries is the number of retries left.  Initially,
// it is set to 5 such that booting NT without debugger won't be
// delayed to long.
//
ULONG KdCompNumberRetries = 5;
ULONG KdCompRetryCount = 5;


ULONG
KdpComputeChecksum (
    IN PUCHAR Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine computes the checksum for the string passed in.

Arguments:

    Buffer - Supplies a pointer to the string.

    Length - Supplies the length of the string.

Return Value:

    A ULONG is return as the checksum for the input string.

--*/

{

    ULONG Checksum = 0;

    while (Length > 0) {
        Checksum = Checksum + (ULONG)*Buffer++;
        Length--;
    }
    return Checksum;
}

USHORT
KdCompReceivePacketLeader (
    IN ULONG PacketType,
    OUT PULONG PacketLeader,
    IN OUT PKD_CONTEXT KdContext
    )

/*++

Routine Description:

    This routine waits for a packet header leader.

Arguments:

    PacketType - supplies the type of packet we are expecting.

    PacketLeader - supplies a pointer to a ulong variable to receive
                   packet leader bytes.

Return Value:

    KDP_PACKET_RESEND - if resend is required.
    KDP_PAKCET_TIMEOUT - if timeout.
    KDP_PACKET_RECEIVED - if packet received.

--*/

{

    UCHAR Input, PreviousByte = 0;
    ULONG PacketId = 0;
    ULONG Index;
    ULONG ReturnCode;
    BOOLEAN BreakinDetected = FALSE;

    //
    // NOTE - With all the interrupts being off, it is very hard
    // to implement the actual timeout code. (Maybe, by reading the CMOS.)
    // Here we use a loop count to wait about 3 seconds.  The CpGetByte
    // will return with error code = CP_GET_NODATA if it cannot find data
    // byte within 1 second. Kernel debugger's timeout period is 5 seconds.
    //

    Index = 0;
    do {
        ReturnCode = KdCompGetByte(&Input);
        if (ReturnCode == CP_GET_NODATA) {
            if (BreakinDetected) {
                KdContext->KdpControlCPending = TRUE;
                return KDP_PACKET_RESEND;
            } else {
                return KDP_PACKET_TIMEOUT;
            }
        } else if (ReturnCode == CP_GET_ERROR) {
            Index = 0;
            continue;
        } else {                    // if (ReturnCode == CP_GET_SUCCESS)
            if ( Input == PACKET_LEADER_BYTE ||
                 Input == CONTROL_PACKET_LEADER_BYTE ) {
                if ( Index == 0 ) {
                    PreviousByte = Input;
                    Index++;
                } else if (Input == PreviousByte ) {
                    Index++;
                } else {
                    PreviousByte = Input;
                    Index = 1;
                }
            } else {

                //
                // If we detect breakin character, we need to verify it
                // validity.  (It is possible that we missed a packet leader
                // and the breakin character is simply a data byte in the
                // packet.)
                // Since kernel debugger send out breakin character ONLY
                // when it is waiting for State Change packet.  The breakin
                // character should not be followed by any other character
                // except packet leader byte.
                //

                if ( Input == BREAKIN_PACKET_BYTE ) {
                    BreakinDetected = TRUE;
                } else {

                    //
                    // The following statement is ABSOLUTELY necessary.
                    //

                    BreakinDetected = FALSE;
                }
                Index = 0;
            }
        }
    } while ( Index < 4 );

    if (BreakinDetected) {
        KdContext->KdpControlCPending = TRUE;
    }

    //
    // return the packet leader and FALSE to indicate no resend is needed.
    //

    if ( Input == PACKET_LEADER_BYTE ) {
        *PacketLeader = PACKET_LEADER;
    } else {
        *PacketLeader = CONTROL_PACKET_LEADER;
    }

    *KdDebuggerNotPresent = FALSE;
    SharedUserData->KdDebuggerEnabled |= 0x00000002;
    return KDP_PACKET_RECEIVED;
}

ULONG
KdpReceiveString (
    OUT PCHAR Destination,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine reads a string from the kernel debugger port.

Arguments:

    Destination - Supplies a pointer to the input string.

    Length - Supplies the length of the string to be read.

Return Value:

    CP_GET_SUCCESS is returned if string is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{

    UCHAR Input;
    ULONG ReturnCode;

    //
    // Read bytes until either a error is encountered or the entire string
    // has been read.
    //
    while (Length > 0) {
        ReturnCode = KdCompGetByte(&Input);
        if (ReturnCode != CP_GET_SUCCESS) {
            return ReturnCode;
        } else {
            *Destination++ = Input;
            Length -= 1;
        }
    }
    return CP_GET_SUCCESS;
}

VOID
KdpSendString (
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine writes a string to the kernel debugger port.

Arguments:

    Source - Supplies a pointer to the output string.

    Length - Supplies the length of the string to be written.

Return Value:

    None.

--*/

{

    UCHAR Output;

    //
    // Write bytes to the kernel debugger port.
    //

    while (Length > 0) {
        Output = *Source++;
        KdCompPutByte(Output);
        Length -= 1;
    }
    return;
}

VOID
KdpSendControlPacket (
    IN USHORT PacketType,
    IN ULONG PacketId OPTIONAL
    )

/*++

Routine Description:

    This routine sends a control packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    PacketId - Supplies packet id, optionally.

Return Value:

    None.

--*/

{

    KD_PACKET PacketHeader;

    //
    // Initialize and send the packet header.
    //

    PacketHeader.PacketLeader = CONTROL_PACKET_LEADER;
    if (ARGUMENT_PRESENT( (PVOID)(ULONG_PTR) PacketId )) {
        PacketHeader.PacketId = PacketId;
    }
    PacketHeader.ByteCount = 0;
    PacketHeader.Checksum = 0;
    PacketHeader.PacketType = PacketType;
    KdpSendString((PCHAR)&PacketHeader, sizeof(KD_PACKET));

    return;
}

ULONG
KdReceivePacket (
    IN ULONG PacketType,
    OUT PSTRING MessageHeader,
    OUT PSTRING MessageData,
    OUT PULONG DataLength,
    IN OUT PKD_CONTEXT KdContext
    )

/*++

Routine Description:

    This routine receives a packet from the host machine that is running
    the kernel debugger UI.  This routine is ALWAYS called after packet being
    sent by caller.  It first waits for ACK packet for the packet sent and
    then waits for the packet desired.

    N.B. If caller is KdPrintString, the parameter PacketType is
       PACKET_TYPE_KD_ACKNOWLEDGE.  In this case, this routine will return
       right after the ack packet is received.

Arguments:

    PacketType - Supplies the type of packet that is excepted.

    MessageHeader - Supplies a pointer to a string descriptor for the input
        message.

    MessageData - Supplies a pointer to a string descriptor for the input data.

    DataLength - Supplies pointer to ULONG to receive length of recv. data.

    KdContext - Supplies a pointer to the kernel debugger context.

Return Value:

    KDP_PACKET_RESEND - if resend is required.
    KDP_PAKCET_TIMEOUT - if timeout.
    KDP_PACKET_RECEIVED - if packet received.

--*/

{

    UCHAR Input;
    ULONG MessageLength;
    KD_PACKET PacketHeader;
    ULONG ReturnCode;
    ULONG Checksum;
    ULONG Status;

    //
    // Just check for breakin packet and return
    //
    if (PacketType == PACKET_TYPE_KD_POLL_BREAKIN) {
        Status = KdCompPollByte(&Input);
        return ((Status == CP_GET_SUCCESS) && (Input == BREAKIN_PACKET_BYTE)) ?
            KDP_PACKET_RECEIVED: KDP_PACKET_TIMEOUT;
    }

WaitForPacketLeader:

    //
    // Read Packet Leader
    //

    ReturnCode = KdCompReceivePacketLeader(PacketType, &PacketHeader.PacketLeader, KdContext);

    //
    // If we can successfully read packet leader, it has high possibility that
    // kernel debugger is alive.  So reset count.
    //

    if (ReturnCode != KDP_PACKET_TIMEOUT) {
        KdCompNumberRetries = KdCompRetryCount;
    }
    if (ReturnCode != KDP_PACKET_RECEIVED) {
        return ReturnCode;
    }

    //
    // Read packet type.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.PacketType,
                                  sizeof(PacketHeader.PacketType));
    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {

            //
            // If read error and it is for a control packet, simply
            // preptend that we have not seen this packet.  Hopefully
            // we will receive the packet we desire which automatically acks
            // the packet we just sent.
            //

            goto WaitForPacketLeader;
        } else {

            //
            // if read error while reading data packet, we have to ask
            // kernel debugger to resend us the packet.
            //

            goto SendResendPacket;
        }
    }

    //
    // if the packet we received is a resend request, we return true and
    // let caller resend the packet.
    //

    if ( PacketHeader.PacketLeader == CONTROL_PACKET_LEADER &&
         PacketHeader.PacketType == PACKET_TYPE_KD_RESEND ) {
        return KDP_PACKET_RESEND;
    }

    //
    // Read data length.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.ByteCount,
                                  sizeof(PacketHeader.ByteCount));
    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // Read Packet Id.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.PacketId,
                                  sizeof(PacketHeader.PacketId));

    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // Read packet checksum.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.Checksum,
                                  sizeof(PacketHeader.Checksum));
    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // A complete packet header is received.  Check its validity and
    // perform appropriate action depending on packet type.
    //

    if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER ) {
        if (PacketHeader.PacketType == PACKET_TYPE_KD_ACKNOWLEDGE ) {

            //
            // If we received an expected ACK packet and we are not
            // waiting for any new packet, update outgoing packet id
            // and return.  If we are NOT waiting for ACK packet
            // we will keep on waiting.  If the ACK packet
            // is not for the packet we send, ignore it and keep on waiting.
            //

            if (PacketHeader.PacketId !=
                (KdCompNextPacketIdToSend & ~SYNC_PACKET_ID))  {
                goto WaitForPacketLeader;
            } else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {
                KdCompNextPacketIdToSend ^= 1;
                return KDP_PACKET_RECEIVED;
            } else {
                goto WaitForPacketLeader;
            }
        } else if (PacketHeader.PacketType == PACKET_TYPE_KD_RESET) {

            //
            // if we received Reset packet, reset the packet control variables
            // and resend earlier packet.
            //

            KdCompNextPacketIdToSend = INITIAL_PACKET_ID;
            KdCompPacketIdExpected = INITIAL_PACKET_ID;
            KdpSendControlPacket(PACKET_TYPE_KD_RESET, 0L);
            return KDP_PACKET_RESEND;
        } else if (PacketHeader.PacketType == PACKET_TYPE_KD_RESEND) {
            return KDP_PACKET_RESEND;
        } else {

            //
            // Invalid packet header, ignore it.
            //

            goto WaitForPacketLeader;
        }

    //
    // The packet header is for data packet (not control packet).
    //

    } else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {

        //
        // if we are waiting for ACK packet ONLY
        // and we receive a data packet header, check if the packet id
        // is what we expected.  If yes, assume the acknowledge is lost (but
        // sent), ask sender to resend and return with PACKET_RECEIVED.
        //

        if (PacketHeader.PacketId == KdCompPacketIdExpected) {
            KdpSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            KdCompNextPacketIdToSend ^= 1;
            return KDP_PACKET_RECEIVED;
        } else {
            KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                 PacketHeader.PacketId
                                 );
            goto WaitForPacketLeader;
        }
    }

    //
    // we are waiting for data packet and we received the packet header
    // for data packet. Perform the following checkings to make sure
    // it is the packet we are waiting for.
    //

    //
    // Check ByteCount received is valid
    //

    MessageLength = MessageHeader->MaximumLength;
    if ((PacketHeader.ByteCount > (USHORT)PACKET_MAX_SIZE) ||
        (PacketHeader.ByteCount < (USHORT)MessageLength)) {
        goto SendResendPacket;
    }
    *DataLength = PacketHeader.ByteCount - MessageLength;

    //
    // Read the message header.
    //

    ReturnCode = KdpReceiveString(MessageHeader->Buffer, MessageLength);
    if (ReturnCode != CP_GET_SUCCESS) {
        goto SendResendPacket;
    }
    MessageHeader->Length = (USHORT)MessageLength;

    //
    // Read the message data.
    //

    ReturnCode = KdpReceiveString(MessageData->Buffer, *DataLength);
    if (ReturnCode != CP_GET_SUCCESS) {
        goto SendResendPacket;
    }
    MessageData->Length = (USHORT)*DataLength;

    //
    // Read packet trailing byte
    //

    ReturnCode = KdCompGetByte(&Input);
    if (ReturnCode != CP_GET_SUCCESS || Input != PACKET_TRAILING_BYTE) {
        goto SendResendPacket;
    }

    //
    // Check PacketType is what we are waiting for.
    //

    if (PacketType != PacketHeader.PacketType) {
        KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                             PacketHeader.PacketId
                             );
        goto WaitForPacketLeader;
    }

    //
    // Check PacketId is valid.
    //

    if (PacketHeader.PacketId == INITIAL_PACKET_ID ||
        PacketHeader.PacketId == (INITIAL_PACKET_ID ^ 1)) {
        if (PacketHeader.PacketId != KdCompPacketIdExpected) {
            KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                 PacketHeader.PacketId
                                 );
            goto WaitForPacketLeader;
        }
    } else {
        goto SendResendPacket;
    }

    //
    // Check checksum is valid.
    //

    Checksum = KdpComputeChecksum(
                            MessageHeader->Buffer,
                            MessageHeader->Length
                            );

    Checksum += KdpComputeChecksum(
                            MessageData->Buffer,
                            MessageData->Length
                            );
    if (Checksum != PacketHeader.Checksum) {
        goto SendResendPacket;
    }

    //
    // Send Acknowledge byte and the Id of the packet received.
    // Then, update the ExpectId for next incoming packet.
    //

    KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                         PacketHeader.PacketId
                         );

    //
    // We have successfully received the packet so update the
    // packet control variables and return sucess.
    //

    KdCompPacketIdExpected ^= 1;
    return KDP_PACKET_RECEIVED;

SendResendPacket:
    KdpSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);
    goto WaitForPacketLeader;
}

VOID
KdSendPacket (
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL,
    IN OUT PKD_CONTEXT KdContext
    )

/*++

Routine Description:

    This routine sends a packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    MessageHeader - Supplies a pointer to a string descriptor that describes
        the message information.

    MessageData - Supplies a pointer to a string descriptor that describes
        the optional message data.

    KdContext - Supplies a pointer to the kernel debugger context.

Return Value:

    None.

--*/

{

    KD_PACKET PacketHeader;
    ULONG MessageDataLength;
    ULONG ReturnCode;
    PDBGKD_DEBUG_IO DebugIo;
    PDBGKD_WAIT_STATE_CHANGE64 StateChange;

    if ( ARGUMENT_PRESENT(MessageData) ) {
        MessageDataLength = MessageData->Length;
        PacketHeader.Checksum = KdpComputeChecksum(
                                        MessageData->Buffer,
                                        MessageData->Length
                                        );
    } else {
        MessageDataLength = 0;
        PacketHeader.Checksum = 0;
    }

    PacketHeader.Checksum += KdpComputeChecksum (
                                    MessageHeader->Buffer,
                                    MessageHeader->Length
                                    );

    //
    // Initialize and send the packet header.
    //

    PacketHeader.PacketLeader = PACKET_LEADER;
    PacketHeader.ByteCount = (USHORT)(MessageHeader->Length + MessageDataLength);
    PacketHeader.PacketType = (USHORT)PacketType;
    KdCompNumberRetries = KdCompRetryCount;
    do {
        if (KdCompNumberRetries == 0) {

            //
            // If the packet is not for reporting exception, we give up
            // and declare debugger not present.
            //

            if (PacketType == PACKET_TYPE_KD_DEBUG_IO) {
                DebugIo = (PDBGKD_DEBUG_IO)MessageHeader->Buffer;
                if (DebugIo->ApiNumber == DbgKdPrintStringApi) {
                    *KdDebuggerNotPresent = TRUE;
                    SharedUserData->KdDebuggerEnabled &= ~0x00000002;
                    KdCompNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    KdCompPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }
            } else if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64) {
                StateChange = (PDBGKD_WAIT_STATE_CHANGE64)MessageHeader->Buffer;
                if (StateChange->NewState == DbgKdLoadSymbolsStateChange) {
                    *KdDebuggerNotPresent = TRUE;
                    SharedUserData->KdDebuggerEnabled &= ~0x00000002;
                    KdCompNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    KdCompPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }
            } else if (PacketType == PACKET_TYPE_KD_FILE_IO) {
                PDBGKD_FILE_IO FileIo;
                
                FileIo = (PDBGKD_FILE_IO)MessageHeader->Buffer;
                if (FileIo->ApiNumber == DbgKdCreateFileApi) {
                    *KdDebuggerNotPresent = TRUE;
                    SharedUserData->KdDebuggerEnabled &= ~0x00000002;
                    KdCompNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    KdCompPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }
            }
        }

        //
        // Setting PacketId has to be in the do loop in case Packet Id was
        // reset.
        //

        PacketHeader.PacketId = KdCompNextPacketIdToSend;
        KdpSendString((PCHAR)&PacketHeader, sizeof(KD_PACKET));

        //
        // Output message header.
        //

        KdpSendString(MessageHeader->Buffer, MessageHeader->Length);

        //
        // Output message data.
        //

        if ( MessageDataLength ) {
            KdpSendString(MessageData->Buffer, MessageData->Length);
        }

        //
        // Output a packet trailing byte
        //

        KdCompPutByte(PACKET_TRAILING_BYTE);

        //
        // Wait for the Ack Packet
        //

        ReturnCode = KdReceivePacket(
                         PACKET_TYPE_KD_ACKNOWLEDGE,
                         NULL,
                         NULL,
                         NULL,
                         KdContext
                         );
        if (ReturnCode == KDP_PACKET_TIMEOUT) {
            KdCompNumberRetries--;
        }
    } while (ReturnCode != KDP_PACKET_RECEIVED);

    //
    // Reset Sync bit in packet id.  The packet we sent may have Sync bit set
    //

    KdCompNextPacketIdToSend &= ~SYNC_PACKET_ID;

    //
    // Since we are able to talk to debugger, the retrycount is set to
    // maximum value.
    //

    KdCompRetryCount = KdContext->KdpDefaultRetries;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\kdcom\kdcomp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation    
    
Module Name:

    kdcomp.h

Abstract:
    
    Private Kernel Debugger HW Extension DLL com port definitions

Author:

    Eric Nelson (enelson) 1/10/2000

Revision History:

--*/

#include "nthal.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "string.h"
#include "stdlib.h"
#include "kddll.h"
#include "acpitabl.h"

#ifndef __KDCOMP_H__
#define __KDCOMP_H__

extern ULONG KdCompPacketIdExpected;
extern ULONG KdCompNextPacketIdToSend;
extern BOOLEAN KdCompDbgPortsPresent;

//
// Local functions 
//
ULONG
KdCompGetByte(
    OUT PUCHAR Input
    );

NTSTATUS
KdCompInitialize(
    PDEBUG_PARAMETERS DebugParameters,
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
KdCompInitialize1(
    VOID
    );

ULONG
KdCompPollByte (
    OUT PUCHAR Input
    );

VOID
KdCompPutByte(
    IN UCHAR Output
    );

USHORT
KdCompReceivePacketLeader(
    IN ULONG PacketType,
    OUT PULONG PacketLeader,
    IN OUT PKD_CONTEXT KdContext
    );

VOID
KdCompRestore(
    VOID
    );

VOID
KdCompSave(
    VOID
    );

VOID
CpWritePortUchar(
	IN PUCHAR Address, 
	IN UCHAR Value
	);

UCHAR
CpReadPortUchar(
	IN PUCHAR Address
	);

VOID
CpWriteRegisterUchar(
	IN PUCHAR Address,
	IN UCHAR Value
	);

UCHAR
CpReadRegisterUchar(
	IN PUCHAR Address
	);

ULONG
KdCompGetDebugTblBaudRate(
	UCHAR	BaudRateFlag
	);

typedef
VOID
(*pKWriteUchar) (
	IN PUCHAR Address,
	IN UCHAR  Value
	);

typedef
UCHAR
(*pKReadUchar) (
	IN PUCHAR Address
	);

#endif // __KDCOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\kdcom\ixkdcom.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixkdcom.c

Abstract:

    This module contains a very simply package to do com I/O on machines
    with standard AT com-ports.  It is C code derived from the debugger's
    com code.  Likely does not work on a PS/2.  (Only rewrote the thing
    into C so we wouldn't have to deal with random debugger macros.)

    Procedures to init a com object, set and query baud rate, output
    character, input character.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-1990

Revision History:

    John Vert (jvert) 12-Jun-1991
        Added ability to check for com-port's existence and hook onto the
        highest com-port available.

    John Vert (jvert) 19-Jul-1991
        Moved into HAL

--*/

#include <nthal.h>
#include <hal.h>
#include "kdcomp.h"
#include "kdcom.h"
#include "inbv.h"
#define     TIMEOUT_COUNT  1024 * 200

UCHAR CpReadLsr (PCPPORT, UCHAR);

BOOLEAN KdCompDbgPortsPresent = TRUE;
UCHAR   KdCompDbgErrorCount = 0;

#define DBG_ACCEPTABLE_ERRORS   25

static UCHAR   LastLsr, LastMsr;

extern pKWriteUchar KdWriteUchar;
extern pKReadUchar  KdReadUchar;


VOID
CpInitialize (
    PCPPORT Port,
    PUCHAR  Address,
    ULONG  Rate
    )

/*++

    Routine Description:

        Fill in the com port port object, set the initial baud rate,
        turn on the hardware.

    Arguments:

        Port - address of port object

        Address - port address of the com port
                    (CP_COM1_PORT, CP_COM2_PORT)

        Rate - baud rate  (CP_BD_150 ... CP_BD_19200)

--*/

{
    PUCHAR hwport;
    UCHAR   mcr, ier;

    Port->Address = Address;
    Port->Baud = 0;

    CpSetBaud(Port, Rate);

    //
    // Assert DTR, RTS.
    //

    hwport = Port->Address;
    hwport += COM_MCR;

    mcr = MC_DTRRTS;
    KdWriteUchar(hwport, mcr);

    hwport = Port->Address;
    hwport += COM_IEN;

    ier = 0;
    KdWriteUchar(hwport, ier);
}




VOID
CpSetBaud (
    PCPPORT  Port,
    ULONG   Rate
    )

/*++

    Routine Description:

        Set the baud rate for the port and record it in the port object.

    Arguments:

        Port - address of port object

        Rate - baud rate  (CP_BD_150 ... CP_BD_56000)

--*/

{
    ULONG   divisorlatch;
    PUCHAR  hwport;
    UCHAR   lcr;

    //
    // compute the divsor
    //

    divisorlatch = CLOCK_RATE / Rate;

    //
    // set the divisor latch access bit (DLAB) in the line control reg
    //

    hwport = Port->Address;
    hwport += COM_LCR;                  // hwport = LCR register

    lcr = KdReadUchar(hwport);

    lcr |= LC_DLAB;
    KdWriteUchar(hwport, lcr);

    //
    // set the divisor latch value.
    //

    hwport = Port->Address;
    hwport += COM_DLM;                  // divisor latch msb
    KdWriteUchar(hwport, (UCHAR)((divisorlatch >> 8) & 0xff));

    hwport--;                           // divisor latch lsb
    KdWriteUchar(hwport, (UCHAR)(divisorlatch & 0xff));


    //
    // Set LCR to 3.  (3 is a magic number in the original assembler)
    //

    hwport = Port->Address;
    hwport += COM_LCR;
    KdWriteUchar(hwport, 3);


    //
    // Remember the baud rate
    //

    Port->Baud = Rate;
}



USHORT
CpQueryBaud (
    PCPPORT  Port
    )

/*++

    Routine Description:

        Return the last value baud rate was set to.

    Arguments:

        Port - address of cpport object which describes the hw port of interest.

    Return Value:

        Baud rate.  0 = none has been set.

--*/

{
    return  (USHORT) Port->Baud;
}

VOID
CpSendModemString (
    PCPPORT Port,
    IN PUCHAR   String
    )
/*++

    Routine Description:

        Sends a command string to the modem.
        This is down in order to aid the modem in determining th
        baud rate the local connect is at.

    Arguments:

        Port - Address of CPPORT
        String - String to send to modem

--*/
{
    static ULONG    Delay;
    TIME_FIELDS CurrentTime;
    UCHAR   i;
    ULONG   l;

    if (Port->Flags & PORT_SENDINGSTRING)
        return ;

    Port->Flags |= PORT_SENDINGSTRING;
    if (!Delay) {
        // see how long 1 second is
        HalQueryRealTimeClock (&CurrentTime);
        l = CurrentTime.Second;
        while (l == (ULONG) CurrentTime.Second) {
            CpReadLsr(Port, 0);
            HalQueryRealTimeClock (&CurrentTime);
            Delay++;
        }
        Delay = Delay / 3;
    }

    l = Delay;
    while (*String) {
        HalQueryRealTimeClock (&CurrentTime);
        i = CpReadLsr (Port, 0);
        if (i & COM_OUTRDY) {
            if ((--l) == 0) {
                KdWriteUchar(Port->Address+COM_DAT, *String);
                String++;
                l = Delay;
            }
        }
        if (i & COM_DATRDY)
            KdReadUchar(Port->Address + COM_DAT);
    }
    Port->Flags &= ~PORT_SENDINGSTRING;
}

UCHAR
CpReadLsr (
    PCPPORT Port,
    UCHAR   waiting
    )

/*++

    Routine Description:

        Read LSR byte from specified port.  If HAL owns port & display
        it will also cause a debug status to be kept up to date.

        Handles entering & exiting modem control mode for debugger.

    Arguments:

        Port - Address of CPPORT

    Returns:

        Byte read from port

--*/
{
    static  UCHAR   ringflag = 0;
    static  UCHAR   diagout[3];
    static  ULONG   diagmsg[3] = { 'TRP ', 'LVO ', 'MRF ' };
    static  UCHAR   ModemString[] = "\n\rAT\n\r";
    TIME_FIELDS CurrentTime;
    UCHAR   lsr, msr, i;
    ULONG   diagstr[12];

    lsr = KdReadUchar(Port->Address + COM_LSR);

    //
    // Check to see if the port still exists.
    //
    if (lsr == SERIAL_LSR_NOT_PRESENT) {
        
        KdCompDbgErrorCount++;
        
        if (KdCompDbgErrorCount >= DBG_ACCEPTABLE_ERRORS) {
            KdCompDbgPortsPresent = FALSE;
            KdCompDbgErrorCount = 0;
        }
        return SERIAL_LSR_NOT_PRESENT;
    }

    if (lsr & COM_PE)
        diagout[0] = 8;         // Parity error

    if (lsr & COM_OE)
        diagout[1] = 8;         // Overflow error

    if (lsr & COM_FE)
        diagout[2] = 8;         // Framing error

    if (lsr & waiting) {
        LastLsr = ~COM_DATRDY | (lsr & COM_DATRDY);
        return lsr;
    }

    msr = KdReadUchar (Port->Address + COM_MSR);

    if (Port->Flags & PORT_MODEMCONTROL) {
        if (msr & SERIAL_MSR_DCD) {

            //
            // In modem control mode with carrier detect
            // Reset carrier lost time
            //

            Port->Flags |= PORT_NOCDLTIME | PORT_MDM_CD;

        } else {

            //
            // In modem control mode, but no carrier detect.  After
            // 60 seconds drop out of modem control mode
            //

            if (Port->Flags & PORT_NOCDLTIME) {
                HalQueryRealTimeClock (&Port->CarrierLostTime);
                Port->Flags &= ~PORT_NOCDLTIME;
                ringflag = 0;
            }

            HalQueryRealTimeClock (&CurrentTime);
            if (CurrentTime.Minute != Port->CarrierLostTime.Minute  &&
                CurrentTime.Second >= Port->CarrierLostTime.Second) {

                //
                // It's been at least 60 seconds - drop out of
                // modem control mode until next RI
                //

                Port->Flags &= ~PORT_MODEMCONTROL;
                CpSendModemString (Port, ModemString);
            }

            if (Port->Flags & PORT_MDM_CD) {

                //
                // We had a connection - if it's the connection has been
                // down for a few seconds, then send a string to the modem
                //

                if (CurrentTime.Second < Port->CarrierLostTime.Second)
                    CurrentTime.Second += 60;

                if (CurrentTime.Second > Port->CarrierLostTime.Second + 10) {
                    Port->Flags &= ~PORT_MDM_CD;
                    CpSendModemString (Port, ModemString);
                }
            }
        }
    }

    if (!(Port->Flags & PORT_SAVED)) {
        return lsr;
    }

    KdCheckPowerButton();

    if (lsr == LastLsr  &&  msr == LastMsr) {
        return lsr;
    }

    ringflag |= (msr & SERIAL_MSR_RI) ? 1 : 2;
    if (ringflag == 3) {

        //
        // The ring indicate line has toggled
        // Use modem control from now on
        //

        ringflag = 0;
        Port->Flags |= PORT_MODEMCONTROL | PORT_NOCDLTIME;
        Port->Flags &= ~PORT_MDM_CD;

        if (Port->Flags & PORT_DEFAULTRATE  &&  Port->Baud != BD_9600) {

            //
            // Baud rate was never specified switch
            // to 9600 baud as default (for modem usage).
            //

            InbvDisplayString (MSG_DEBUG_9600);
            CpSetBaud (Port, BD_9600);
            //Port->Flags |= PORT_DISBAUD;
        }
    }

    for (i=0; i < 3; i++) {
        if (diagout[i]) {
            diagout[i]--;
            diagstr[10-i] = diagmsg[i];
        } else {
            diagstr[10-i] = '    ';
        }
    }

    diagstr[7] = (LastLsr & COM_DATRDY) ? 'VCR ' : '    ';
    diagstr[6] = (lsr & COM_OUTRDY)     ? '    ' : 'DNS ';
    diagstr[5] = (msr & 0x10) ? 'STC ' : '    ';
    diagstr[4] = (msr & 0x20) ? 'RSD ' : '    ';
    diagstr[3] = (msr & 0x40) ? ' IR ' : '    ';
    diagstr[2] = (msr & 0x80) ? ' DC ' : '    ';
    diagstr[1] = (Port->Flags & PORT_MODEMCONTROL) ? 'MDM ' : '    ';
    diagstr[0] = '    ';
#if 0
    if (Port->Flags & PORT_DISBAUD) {
        switch (Port->Baud) {
            case BD_9600:   diagstr[0] = ' 69 ';    break;
            case BD_14400:  diagstr[0] = 'K41 ';    break;
            case BD_19200:  diagstr[0] = 'K91 ';    break;
            case BD_56000:  diagstr[0] = 'K65 ';    break;
        }
    }
#endif

    //HalpDisplayDebugStatus ((PUCHAR) diagstr, 11*4);
    LastLsr = lsr;
    LastMsr = msr;
    return lsr;
}




VOID
CpPutByte (
    PCPPORT  Port,
    UCHAR   Byte
    )

/*++

    Routine Description:

        Write a byte out to the specified com port.

    Arguments:

        Port - Address of CPPORT object

        Byte - data to emit

--*/

{
    UCHAR   msr, lsr;
    
    if (KdCompDbgPortsPresent == FALSE) {
        return;
    }
    
    //
    // If modem control, make sure DSR, CTS and CD are all set before
    // sending any data.
    //

    while ((Port->Flags & PORT_MODEMCONTROL)  &&
           (msr = KdReadUchar(Port->Address + COM_MSR) & MS_DSRCTSCD) != MS_DSRCTSCD) {

        //
        // If no CD, and there's a charactor ready, eat it
        //

        lsr = CpReadLsr (Port, 0);
        if ((msr & MS_CD) == 0  && (lsr & COM_DATRDY) == COM_DATRDY) {
            KdReadUchar(Port->Address + COM_DAT);
        }
    }

    //
    //  Wait for port to not be busy
    //

    while (!(CpReadLsr(Port, COM_OUTRDY) & COM_OUTRDY)) ;

    //
    // Send the byte
    //

    KdWriteUchar(Port->Address + COM_DAT, Byte);
}

USHORT
CpGetByte (
    PCPPORT  Port,
    PUCHAR Byte,
    BOOLEAN WaitForByte
    )

/*++

    Routine Description:

        Fetch a byte and return it.

    Arguments:

        Port - address of port object that describes hw port

        Byte - address of variable to hold the result

        WaitForByte - flag indicates wait for byte or not.

    Return Value:

        CP_GET_SUCCESS if data returned.

        CP_GET_NODATA if no data available, but no error.

        CP_GET_ERROR if error (overrun, parity, etc.)

--*/

{
    UCHAR   lsr;
    UCHAR   value;
    ULONG   limitcount;

    //
    //  Make sure DTR and CTS are set
    //
    //  (What does CTS have to do with reading from a full duplex line???)


    //
    // Check to make sure the CPPORT we were passed has been initialized.
    // (The only time it won't be initialized is when the kernel debugger
    // is disabled, in which case we just return.)
    //
    if (Port->Address == NULL) {
        KdCheckPowerButton();
        return(CP_GET_NODATA);
    }

    if (KdCompDbgPortsPresent == FALSE) {
        
        if (CpReadLsr(Port, COM_DATRDY) == SERIAL_LSR_NOT_PRESENT) {

            return(CP_GET_NODATA);
        } else {
            
            CpSetBaud(Port, Port->Baud);
            KdCompDbgPortsPresent = TRUE;
        }
    }
    
    limitcount = WaitForByte ? TIMEOUT_COUNT : 1;
    while (limitcount != 0) {
        limitcount--;

        lsr = CpReadLsr(Port, COM_DATRDY);
        
        if (lsr == SERIAL_LSR_NOT_PRESENT) {
            return(CP_GET_NODATA); 
        }
        
        if ((lsr & COM_DATRDY) == COM_DATRDY) {

            //
            // Check for errors
            //
            if (lsr & (COM_FE | COM_PE | COM_OE)) {
                *Byte = 0;
                return(CP_GET_ERROR);
            }

            //
            // fetch the byte
            //

            value = KdReadUchar(Port->Address + COM_DAT);

            if (Port->Flags & PORT_MODEMCONTROL) {

                //
                // Using modem control.  If no CD, then skip this byte.
                //

                if ((KdReadUchar(Port->Address + COM_MSR) & MS_CD) == 0) {
                    continue;
                }
            }

            *Byte = value & (UCHAR)0xff;
            return CP_GET_SUCCESS;
        }
    }

    LastLsr = 0;
    CpReadLsr (Port, 0);
    return CP_GET_NODATA;
}



BOOLEAN
CpDoesPortExist(
    IN PUCHAR Address
    )

/*++

Routine Description:

    This routine will attempt to place the port into its
    diagnostic mode.  If it does it will twiddle a bit in
    the modem control register.  If the port exists this
    twiddling should show up in the modem status register.

    NOTE: This routine must be called before the device is
          enabled for interrupts, this includes setting the
          output2 bit in the modem control register.

    This is blatantly stolen from TonyE's code in ntos\dd\serial\serial.c.

Arguments:

    Address - address of hw port.

Return Value:

    TRUE - Port exists.  Party on.

    FALSE - Port doesn't exist.  Don't use it.

--*/

{
    UCHAR OldModemStatus;
    UCHAR ModemStatus;
    BOOLEAN ReturnValue = TRUE;

    //
    // Save the old value of the modem control register.
    //

    OldModemStatus = KdReadUchar(Address+COM_MCR);

    //
    // Set the port into diagnostic mode.
    //

    KdWriteUchar(
        Address+COM_MCR,
        SERIAL_MCR_LOOP
        );

    //
    // Bang on it again to make sure that all the lower bits
    // are clear.
    //

    KdWriteUchar(
        Address+COM_MCR,
        SERIAL_MCR_LOOP
        );

    //
    // Read the modem status register.  The high for bits should
    // be clear.
    //

    ModemStatus = KdReadUchar(Address+COM_MSR);

    if (ModemStatus & (SERIAL_MSR_CTS | SERIAL_MSR_DSR |
                       SERIAL_MSR_RI  | SERIAL_MSR_DCD)) {

        ReturnValue = FALSE;
        goto AllDone;

    }

    //
    // So far so good.  Now turn on OUT1 in the modem control register
    // and this should turn on ring indicator in the modem status register.
    //

    KdWriteUchar(
        Address+COM_MCR,
        (SERIAL_MCR_OUT1 | SERIAL_MCR_LOOP)
        );

    ModemStatus = KdReadUchar(Address+COM_MSR);

    if (!(ModemStatus & SERIAL_MSR_RI)) {

        ReturnValue = FALSE;
        goto AllDone;

    }

AllDone: ;

    //
    // Put the modem control back into a clean state.
    //

    KdWriteUchar(
        Address+COM_MCR,
        OldModemStatus
        );

    return ReturnValue;
}

VOID
CpWritePortUchar(
    IN PUCHAR Address, 
    IN UCHAR Value
)
{
    WRITE_PORT_UCHAR(Address, Value); 
} // CpWritePortUchar()

UCHAR
CpReadPortUchar(
    IN PUCHAR Address
    )
{
    return READ_PORT_UCHAR(Address); 
} // CpReadPortUchar()

VOID
CpWriteRegisterUchar(
    IN PUCHAR Address,
    IN UCHAR Value
    )
{
    WRITE_REGISTER_UCHAR(Address, Value);
} // CpWriteRegisterValue()

UCHAR
CpReadRegisterUchar(
    IN PUCHAR Address
    )
{
    return READ_REGISTER_UCHAR(Address); 
} // CpReadRegisterUchar()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\blacpi.c ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved

Module Name:

    acpisetd.c

Abstract:

    This module detects an ACPI system.  It
    is included into setup so that setup
    can figure out which HAL to load

Author:

    Jake Oshins (jakeo) - August 24, 2000.

Environment:

    Textmode setup.

Revision History:

    split from i386\acpidtct.c so that the code could be used on IA64
    

--*/

#include "bootlib.h"
#include "stdlib.h"
#include "string.h"
#include "acpitabl.h"

VOID
BlFindRsdp (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\arcdisk.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    arcdisk.c

Abstract:

    Provides the routines for collecting the disk information for all the ARC
    disks visible in the ARC environment.

Author:

    John Vert (jvert) 3-Nov-1993

Revision History:

   Vijay Jayaseelan (vijayj)    2-April-2000
   
        -   Added EFI partition table support

--*/
#include "bootlib.h"

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#ifdef EFI_PARTITION_SUPPORT

//
// EFI partition entries
//
UNALIGNED EFI_PARTITION_ENTRY EfiPartitionBuffer[128] = {0};

#endif

BOOLEAN
BlpEnumerateDisks(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    );


#if defined(_X86_) && !defined(ARCI386)

static
VOID
BlpEnumerateXInt13(
    VOID
    )
/*++

Routine Description:

    This routine will go through all the enumerated disks and record
    their ability to support xInt13.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR Partition[100];
    ULONG DiskId;
    ARC_STATUS Status;
    PARC_DISK_SIGNATURE DiskSignature;
    PARC_DISK_INFORMATION DiskInfo;
    PLIST_ENTRY Entry;

    DiskInfo = BlLoaderBlock->ArcDiskInformation;
    Entry = DiskInfo->DiskSignatures.Flink;

    while (Entry != &DiskInfo->DiskSignatures) {
        DiskSignature = CONTAINING_RECORD(Entry,ARC_DISK_SIGNATURE,ListEntry);

        //
        // Open partition0 on the disk and get it's device ID.
        //
        strcpy(Partition, DiskSignature->ArcName);
        strcat(Partition, "partition(0)");

        Status = ArcOpen(Partition, ArcOpenReadOnly, &DiskId);

        if( Status == ESUCCESS ) {
            //
            // Now we've got the DiskId.  Fortunately, someone
            // has been keeping track of all the DiskIds on the
            // machine and whether or not they've got xint13 support.
            // All we need to do now is go lookup our diskid in
            // that database and get the xint13 BOOLEAN.
            //
            DiskSignature->xInt13 = BlFileTable[DiskId].u.DriveContext.xInt13;

            //
            // We don't need you anymore.
            //
            ArcClose(DiskId);
        } else {
            DiskSignature->xInt13 = FALSE;

        }

        Entry = Entry->Flink;
    }

}

#endif // for defined(_X86_) && !defined(ARCI386)

ARC_STATUS
BlGetArcDiskInformation(
    BOOLEAN XInt13Support
    )

/*++

Routine Description:

    Enumerates the ARC disks present in the system and collects the identifying disk
    information from each one.

Arguments:

    XInt13Support  :  Indicates whether to find XInt13 support or not

Return Value:

    None.

--*/

{
    PARC_DISK_INFORMATION DiskInfo;

    DiskInfo = BlAllocateHeap(sizeof(ARC_DISK_INFORMATION));
    if (DiskInfo==NULL) {
        return(ENOMEM);
    }

    InitializeListHead(&DiskInfo->DiskSignatures);

    BlLoaderBlock->ArcDiskInformation = DiskInfo;

    BlSearchConfigTree(BlLoaderBlock->ConfigurationRoot,
                       PeripheralClass,
                       DiskPeripheral,
                       (ULONG)-1,
                       BlpEnumerateDisks);

#if defined(_X86_) && !defined(ARCI386)

    //
    // Enumerate XInt13 support on X86 only if asked for
    //
    if (XInt13Support) {
        BlpEnumerateXInt13();
    }

#endif    
    
    return(ESUCCESS);

}


BOOLEAN
BlpEnumerateDisks(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    )

/*++

Routine Description:

    Callback routine for enumerating the disks in the ARC firmware tree.  It
    reads all the necessary information from the disk to uniquely identify
    it.

Arguments:

    ConfigData - Supplies a pointer to the disk's ARC component data.

Return Value:

    TRUE - continue searching

    FALSE - stop searching tree.

--*/

{
    CHAR DiskName[100];

    BlGetPathnameFromComponent(ConfigData, DiskName);
    return(BlReadSignature(DiskName,FALSE));
}


BOOLEAN
BlReadSignature(
    IN PCHAR DiskName,
    IN BOOLEAN IsCdRom
    )

/*++

Routine Description:

    Given an ARC disk name, reads the MBR and adds its signature to the list of
    disks.

Arguments:

    Diskname - Supplies the name of the disk.

    IsCdRom - Indicates whether the disk is a CD-ROM.

Return Value:

    TRUE - Success

    FALSE - Failure

--*/

{
    PARC_DISK_SIGNATURE Signature;
    BOOLEAN Status = FALSE;

    Signature = BlAllocateHeap(sizeof(ARC_DISK_SIGNATURE));
    if (Signature==NULL) {
        return(FALSE);
    }

    Signature->ArcName = BlAllocateHeap(strlen(DiskName)+2);
    if (Signature->ArcName==NULL) {
        return(FALSE);
    }

#if defined(i386) 
    Status = BlFindDiskSignature(DiskName, Signature);
#endif

    if(!Status) {
        Status = BlGetDiskSignature(DiskName, IsCdRom, Signature);
    }

    if (Status) {
        InsertHeadList(&BlLoaderBlock->ArcDiskInformation->DiskSignatures,
                       &Signature->ListEntry);

    }

    return(TRUE);

}

BOOLEAN
ArcDiskGPTDiskReadCallback(
    ULONGLONG StartingLBA,
    ULONG    BytesToRead,
    PVOID     pContext,
    UNALIGNED PVOID OutputBuffer
    )
/*++

Routine Description:

    This routine is a callback for reading data for a routine that
    validates the GPT partition table.
    
    NOTE: This routine changes the seek position on disk, and you must seek
          back to your original seek position if you plan on reading from the
          disk after making this call.

Arguments:

    StartingLBA - starting logical block address to read from.

    BytesToRead - Indicates how many bytes are to be read.

    pContext - context pointer for hte function (in this case, a pointer to the disk id.)
    
    OutputBuffer - a buffer that receives the data.  It's assumed that it is at least
                   BytesToRead big enough.

Return Value:

    TRUE - success, data has been read

    FALSE - failed, data has not been read.

--*/
{
    ARC_STATUS          Status;
    LARGE_INTEGER       SeekPosition;
    PUSHORT DataPointer;
    ULONG DiskId;
    ULONG ReadCount = 0;
    

    DiskId = *((PULONG)pContext);
    //
    // read the second LBA on the disk
    //
    SeekPosition.QuadPart = StartingLBA * SECTOR_SIZE;
    
    Status = ArcSeek(DiskId,
                      &SeekPosition,
                      SeekAbsolute );

    if (Status != ESUCCESS) {
        return FALSE;
    }

    DataPointer = OutputBuffer;

    Status = ArcRead(
                DiskId,
                DataPointer,
                BytesToRead,
                &ReadCount);

    if ((Status == ESUCCESS) && (ReadCount == BytesToRead)) {
        return(TRUE);
    }
    
    return(FALSE);

}



BOOLEAN
BlGetDiskSignature(
    IN PCHAR DiskName,
    IN BOOLEAN IsCdRom,
    PARC_DISK_SIGNATURE Signature
    )

/*++

Routine Description:

    This routine gets the NTFT disk signature for a specified partition or
    path.

Arguments:

    DiskName - Supplies the arcname of the partition or drive.

    IsCdRom - Indicates whether the disk is a CD-ROM.

    Signature - Returns a full ARC_DISK_SIGNATURE.

Return Value:

    TRUE - success, Signature will be filled in.

    FALSE - failed, Signature will not be filled in.

--*/

{
    UCHAR SectorBuffer[2048+256] = {0};
    UCHAR Partition[100];
    ULONG DiskId;
    ULONG Status;
    LARGE_INTEGER SeekValue;
    PUCHAR Sector;
    ULONG i;
    ULONG Sum;
    ULONG Count;
    ULONG SectorSize;
    EFI_PARTITION_TABLE *EfiHdr;

    if (IsCdRom) {
        SectorSize = 2048;
    } else {
        SectorSize = 512;
    }

#if defined(_i386_)
    //
    // NTDETECT creates an "eisa(0)..." arcname for detected
    // BIOS disks on an EISA machine.  Change this to "multi(0)..."
    // in order to be consistent with the rest of the system
    // (particularly the arcname in boot.ini)
    //
    if (_strnicmp(DiskName,"eisa",4)==0) {
        strcpy(Signature->ArcName,"multi");
        strcpy(Partition,"multi");
        strcat(Signature->ArcName,DiskName+4);
        strcat(Partition,DiskName+4);
    } else {
        strcpy(Signature->ArcName, DiskName);
        strcpy(Partition, DiskName);
    }
#else
    strcpy(Signature->ArcName, DiskName);
    strcpy(Partition, DiskName);
#endif

    strcat(Partition, "partition(0)");

    Status = ArcOpen(Partition, ArcOpenReadOnly, &DiskId);
    if (Status != ESUCCESS) {
        return(FALSE);
    }

    //
    // Read in the first sector
    //
    Sector = ALIGN_BUFFER(SectorBuffer);
    if (IsCdRom) {
        //
        // For a CD-ROM, the interesting data starts at 0x8000.
        //
        SeekValue.QuadPart = 0x8000;
    } else {
        SeekValue.QuadPart = 0;
    }
    Status = ArcSeek(DiskId, &SeekValue, SeekAbsolute);
    if (Status == ESUCCESS) {
        Status = ArcRead(DiskId,
                         Sector,
                         SectorSize,
                         &Count);
    }
    if (Status != ESUCCESS) {
        ArcClose(DiskId);
        return(FALSE);
    }
       

    //
    // Check to see whether this disk has a valid partition table signature or not.
    //
    if (((PUSHORT)Sector)[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {
        Signature->ValidPartitionTable = FALSE;
    } else {
        Signature->ValidPartitionTable = TRUE;
    }

    Signature->Signature = ((PULONG)Sector)[PARTITION_TABLE_OFFSET/2-1];

    //
    // compute the checksum
    //
    Sum = 0;
    for (i=0; i<(SectorSize/4); i++) {
        Sum += ((PULONG)Sector)[i];
    }
    Signature->CheckSum = ~Sum + 1;

    //
    // Check for GPT disk.
    //
    Signature->IsGpt = FALSE;

    if (!IsCdRom) {
        SeekValue.QuadPart = 1 * SectorSize;
        Status = ArcSeek(DiskId, &SeekValue, SeekAbsolute);
        if (Status == ESUCCESS) {
            Status = ArcRead(DiskId,
                             Sector,
                             SectorSize,
                             &Count);
            if (Status == ESUCCESS) {
                ULONG tmpDiskId = DiskId;
    
                //
                // verify EFI partition table
                //
                EfiHdr = (EFI_PARTITION_TABLE *)Sector;
    
                if (BlIsValidGUIDPartitionTable(
                            EfiHdr,
                            1,
                            &tmpDiskId,
                            ArcDiskGPTDiskReadCallback)) {
                    Signature->IsGpt = TRUE;
                    memcpy(
                        Signature->GptSignature, 
                        EfiHdr->DiskGuid,
                        sizeof(EfiHdr->DiskGuid) );
                }
            }
        }
    }        

    ArcClose(DiskId);
    return(TRUE);
}


#ifdef EFI_PARTITION_SUPPORT



/*
void DbgOut(PWSTR Str);

//#define DBG_PRINT(x)    DbgOut(x);
ULONG BlGetKey();

#if defined(_IA64_)

#define STR_PREFIX  L

#define DBG_PRINT(x)    DbgOut(x)    

#else

#define STR_PREFIX  

#define DBG_PRINT(x)    \
{\
    BlPrint(x); \
    while (!BlGetKey()); \
} 

#endif  // _IA64_
*/

#define DBG_PRINT(x)
#define STR_PREFIX

UNALIGNED EFI_PARTITION_ENTRY *
BlLocateGPTPartition(
    IN UCHAR PartitionNumber,
    IN UCHAR MaxPartitions,
    IN PUCHAR ValidPartCount
    )
{
    UNALIGNED EFI_PARTITION_ENTRY *PartEntry = NULL;    
    UCHAR NullGuid[16] = {0};
    UCHAR PartIdx = 0;
    UCHAR PartCount = 0;

#if 0
    BlPrint("BlLocateGPTPartition(%d,%d,%d)\r\n",
                PartitionNumber,
                MaxPartitions,
                ValidPartCount ? *ValidPartCount : 0);
    while (!BlGetKey());                
#endif    

    if (ARGUMENT_PRESENT(ValidPartCount)) {
        PartCount = *ValidPartCount;
    }        

    PartitionNumber++;  // convert to one based index
    
    //
    // Locate the requested valid partition
    //    
    while ((PartIdx < MaxPartitions) && (PartCount < PartitionNumber)) {
        DBG_PRINT(STR_PREFIX"Verifying GPT Partition Entry\r\n");

        PartEntry = (UNALIGNED EFI_PARTITION_ENTRY *)(EfiPartitionBuffer + PartIdx);
        
        if ((memcmp(PartEntry->Type, NullGuid, 16)) &&
            (memcmp(PartEntry->Id, NullGuid, 16)) &&
            (PartEntry->StartingLBA != 0) && (PartEntry->EndingLBA != 0)) {
            DBG_PRINT(STR_PREFIX"Found Valid GPT Partition Entry\r\n");
            PartCount++;

            if (ARGUMENT_PRESENT(ValidPartCount)) {
                (*ValidPartCount)++;
            }                

            //
            // Get hold of the partition entry
            //
            if (PartCount == PartitionNumber) {
                break;
            } else {
                PartEntry = NULL;
            }                
        } else {
            PartEntry = NULL;
        }            

        PartIdx++;
    }   

    return PartEntry;
}

BOOLEAN
BlDiskOpenGPTDiskReadCallback(
    ULONGLONG StartingLBA,
    ULONG    BytesToRead,
    PVOID     pContext,
    UNALIGNED PVOID OutputBuffer
    )
/*++

Routine Description:

    This routine is a callback for reading data for a routine that
    validates the GPT partition table.

Arguments:

    StartingLBA - starting logical block address to read from.

    BytesToRead - Indicates how many bytes are to be read.

    pContext - context pointer for hte function (in this case, a pointer to the disk id.)
    
    OutputBuffer - a buffer that receives the data.  It's assumed that it is at least
                   BytesToRead big enough.

Return Value:

    TRUE - success, data has been read

    FALSE - failed, data has not been read.

--*/
{
    ARC_STATUS          Status;
    LARGE_INTEGER       SeekPosition;
    PUSHORT DataPointer;
    ULONG DiskId;
    ULONG ReadCount = 0;
    

    DiskId = *((PULONG)pContext);
    //
    // read the second LBA on the disk
    //
    SeekPosition.QuadPart = StartingLBA * SECTOR_SIZE;
    
    Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                          &SeekPosition,
                                                          SeekAbsolute );

    if (Status != ESUCCESS) {
        return FALSE;
    }

    DataPointer = OutputBuffer;

    Status = (BlFileTable[DiskId].DeviceEntryTable->Read)(DiskId,
                                                          DataPointer,
                                                          BytesToRead,
                                                          &ReadCount);

    if ((Status == ESUCCESS) && (ReadCount == BytesToRead)) {
        return(TRUE);
    }
    
    return(FALSE);

}



ARC_STATUS
BlOpenGPTDiskPartition(
    IN ULONG FileId,
    IN ULONG DiskId,
    IN UCHAR PartitionNumber
    )
{
    ARC_STATUS          Status;
    LARGE_INTEGER       SeekPosition;
    UCHAR               DataBuffer[SECTOR_SIZE * 2] = {0};
    ULONG               ReadCount = 0;
    UCHAR               NullGuid[16] = {0};
    UCHAR               PartIdx;
    UCHAR               PartCount;
    UNALIGNED EFI_PARTITION_TABLE  *EfiHdr;
    UNALIGNED EFI_PARTITION_ENTRY *PartEntry;
    ULONG               tmpDiskId = DiskId;


    if (PartitionNumber >= 128)
        return EINVAL;

    DBG_PRINT(STR_PREFIX"Seeking GPT PT\r\n");
    
    //
    // read the second LBA on the disk
    //
    SeekPosition.QuadPart = 1 * SECTOR_SIZE;
    
    Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                          &SeekPosition,
                                                          SeekAbsolute );

    if (Status != ESUCCESS)
        return Status;

    DBG_PRINT(STR_PREFIX"Reading GPT PT\r\n");
    
    Status = (BlFileTable[DiskId].DeviceEntryTable->Read)(DiskId,
                                                          DataBuffer,
                                                          SECTOR_SIZE,
                                                          &ReadCount);
                                                          
    if (Status != ESUCCESS)
        return Status;

    if (ReadCount != SECTOR_SIZE) {
        Status = EIO;

        return Status;
    }        

    EfiHdr = (UNALIGNED EFI_PARTITION_TABLE *)DataBuffer;
                                                          
    DBG_PRINT(STR_PREFIX"Verifying GPT PT\r\n");
    
    //
    // verify EFI partition table
    //
    if (!BlIsValidGUIDPartitionTable(
                            EfiHdr,
                            1,
                            &tmpDiskId,
                            BlDiskOpenGPTDiskReadCallback)) {    
        Status = EBADF;
        return Status;
    }        

    //
    // Locate and read the partition entry
    // which is requested
    //
    SeekPosition.QuadPart = EfiHdr->PartitionEntryLBA * SECTOR_SIZE;
        
    DBG_PRINT(STR_PREFIX"Seeking GPT Partition Entries\r\n");
    
    Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                          &SeekPosition,
                                                          SeekAbsolute );

    if (Status != ESUCCESS)
        return Status;

    RtlZeroMemory(EfiPartitionBuffer, sizeof(EfiPartitionBuffer));        

    DBG_PRINT(STR_PREFIX"Reading GPT Partition Entries\r\n");
    
    Status = (BlFileTable[DiskId].DeviceEntryTable->Read)(DiskId,
                                                          EfiPartitionBuffer,
                                                          sizeof(EfiPartitionBuffer),
                                                          &ReadCount);
                                                          
    if (Status != ESUCCESS)
        return Status;

    if (ReadCount != sizeof(EfiPartitionBuffer)) {
        Status = EIO;

        return Status;
    }  

    DBG_PRINT(STR_PREFIX"Locating the correct GPT partition entry\r\n");
    
    PartEntry = (UNALIGNED EFI_PARTITION_ENTRY *)BlLocateGPTPartition(PartitionNumber, 128, NULL);

    if (PartEntry) {
        DBG_PRINT(STR_PREFIX"Verifying GPT Partition Entry\r\n");
    
        if ((memcmp(PartEntry->Type, NullGuid, 16)) &&
            (memcmp(PartEntry->Id, NullGuid, 16)) &&
            (PartEntry->StartingLBA != 0) && (PartEntry->EndingLBA != 0)) {
            PPARTITION_CONTEXT PartContext = &(BlFileTable[FileId].u.PartitionContext);
            ULONG   SectorCount = (ULONG)(PartEntry->EndingLBA - PartEntry->StartingLBA);

            DBG_PRINT(STR_PREFIX"Initializing GPT Partition Entry Context\r\n");

            //
            // Fill the partition context structure
            //
            PartContext->PartitionLength.QuadPart = SectorCount * SECTOR_SIZE;
            PartContext->StartingSector = (ULONG)(PartEntry->StartingLBA);
            PartContext->EndingSector = (ULONG)(PartEntry->EndingLBA);
            PartContext->DiskId = (UCHAR)DiskId;

            BlFileTable[FileId].Position.QuadPart = 0;

#if 0
            BlPrint("GPT Partition opened:L:%ld,%ld:%ld,SS:%ld,ES:%ld\n",
                    PartitionNumber,
                    (ULONG)PartContext->PartitionLength.QuadPart,
                    (ULONG)PartContext->StartingSector,
                    (ULONG)PartContext->EndingSector);

            while (!GET_KEY());                
#endif        

            Status = ESUCCESS;
        } else {
            Status = EBADF;
        }
    } else {
        Status = EBADF;
    }        

    DBG_PRINT(STR_PREFIX"Returning from BlOpenGPTDiskPartition(...)\r\n");

    return Status;
}

#endif //   for EFI_PARTITION_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\kdcom\xxkdsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    xxkdsup.c

Abstract:

    Com support.  Code to init a com port, store port state, map
    portable procedures to x86 procedures.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

    Shielin Tzong (shielint) 10-Apr-91
                Add packet control protocol.

    John Vert (jvert) 11-Jul-1991
        Moved from KD/i386 to HAL

    Eric Nelson (enelson) 1-Jan-00
        Move from HAL into DLL

--*/

#include "kdcomp.h"
#include "kdcom.h"
#include "stdio.h"
#include "acpitabl.h"

#if DBG && IA64
CHAR KdProtocolTraceIn[4096];
ULONG KdProtocolIndexIn;
CHAR KdProtocolTraceOut[4096];
ULONG KdProtocolIndexOut;
#endif

PDEBUG_PORT_TABLE HalpDebugPortTable;

//
// This MUST be initialized to zero so we know not to do anything when
// CpGetByte is called when the kernel debugger is disabled.
//

CPPORT Port = {NULL, 0, PORT_DEFAULTRATE };

//
// Remember the debugger port information
//

CPPORT PortInformation = {NULL, 0, PORT_DEFAULTRATE};
ULONG ComPort = 0;
PHYSICAL_ADDRESS DbgpKdComPhysicalAddress; // ACPI DBGP KdCom physical address.

//
// Default debugger port in IO space.
//

UCHAR KdComAddressID = 1;                     // port debugger ident. : MMIO or IO space. Def:IO.
pKWriteUchar KdWriteUchar = CpWritePortUchar; // stub to real function: MMIO or IO space. Def:IO.
pKReadUchar  KdReadUchar  = CpReadPortUchar;  // stub to real function: MMIO or IO space. Def:IO.

//
//      We need this so the serial driver knows that the kernel debugger
//      is using a particular port.  The serial driver then knows not to
//      touch this port.  KdInitCom fills this in with the number of the
//      COM port it is using (1 or 2)
//
//      This will go in the registry as soon as the registry is working.
//

extern PUCHAR *KdComPortInUse;

BOOLEAN HalpGetInfoFromACPI = FALSE;



NTSTATUS
KdCompInitialize(
    PDEBUG_PARAMETERS DebugParameters,
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This procedure checks for which COM port should be used by kernel
    debugger.  If DebugParameter specifies a COM port, we will use it
    even if we can not find it (we trust user).  Otherwise, if COM2
    is present and there is no mouse attaching to it, we use COM2.
    If COM2 is not availabe, we check COM1.  If both COM1 and COM2 are
    not present, we give up and return false.

Arguments:

    DebugParameters - Supplies a pointer a structure which optionally
                      sepcified the debugging port information.

    LoaderBlock - supplies a pointer to the loader parameter block.

Returned Value:

    TRUE - If a debug port is found.

--*/
{

    PCONFIGURATION_COMPONENT_DATA ConfigurationEntry, ChildEntry;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor;
    PCM_PARTIAL_RESOURCE_LIST List;
    ULONG MatchKey, i;
    ULONG BaudRate = BD_19200;
    PUCHAR PortAddress = NULL;
    UCHAR Irq = 0;
    ULONG Com = 0;

    if (LoaderBlock && KdGetAcpiTablePhase0) {
        HalpDebugPortTable =
            KdGetAcpiTablePhase0(LoaderBlock, DBGP_SIGNATURE);
    }

    if (HalpDebugPortTable) {

        KdComAddressID = HalpDebugPortTable->BaseAddress.AddressSpaceID; 

        //
        // Debug ports are supported in memory and IO space only.
        //

        if ((KdComAddressID == 0) ||
            (KdComAddressID == 1)) {

            DbgpKdComPhysicalAddress = HalpDebugPortTable->BaseAddress.Address;

            if(KdComAddressID == 0) {

                //
                // The address is memory, map it.
                //

                if (KdMapPhysicalMemory64) {
                    PortInformation.Address =
                        KdMapPhysicalMemory64(DbgpKdComPhysicalAddress, 1);
                }
            } else {

                // 
                // The address is in IO space.
                //

                PortInformation.Address = (PUCHAR)UlongToPtr(DbgpKdComPhysicalAddress.LowPart);
            }

            Port.Flags &= ~(PORT_MODEMCONTROL | PORT_DEFAULTRATE);
            HalpGetInfoFromACPI = TRUE;

            if (HalpDebugPortTable->InterfaceType == 0) {

                //
                // This is actually a 16550.  So pay attention
                // to the baud rate requested by the user.
                //

                if(DebugParameters->BaudRate != 0){
                    // Baud rate set by user so use it
                    PortInformation.Baud = DebugParameters->BaudRate;
                } else if(HalpDebugPortTable->BaudRate != 0){
                    // not specified by user so get it out of the debug table
                    PortInformation.Baud = KdCompGetDebugTblBaudRate(HalpDebugPortTable->BaudRate);
                } else {
                    // No debug table information available so use default
                    PortInformation.Baud = BD_57600;
                }

            } else {

                //
                // This is not a 16550.  So we must use
                // the fixed baud rate of 57600.
                //

                PortInformation.Baud = BD_57600;
            }
        }
    }

    //
    // Check if Port and baudrate have been determined.
    //

    if ((PortInformation.Address == NULL) && !HalpGetInfoFromACPI) {

        //
        // First see if the DebugParameters contains debugging port info.
        //

        if (DebugParameters->BaudRate != 0) {
            BaudRate = DebugParameters->BaudRate;
            Port.Flags &= ~PORT_DEFAULTRATE;
        }

        if (DebugParameters->CommunicationPort != 0) {

            //
            // Find the configuration information of the specified serial port.
            //

            Com = DebugParameters->CommunicationPort;
            MatchKey = Com - 1;
            if (LoaderBlock != NULL) {
                ConfigurationEntry = KeFindConfigurationEntry(LoaderBlock->ConfigurationRoot,
                                                              ControllerClass,
                                                              SerialController,
                                                              &MatchKey);

            } else {
                ConfigurationEntry = NULL;
            }

        } else {

            //
            // Check if COM2 is present and make sure no mouse attaches to it.
            //

            MatchKey = 1;
            if (LoaderBlock != NULL) {
                ConfigurationEntry = KeFindConfigurationEntry(LoaderBlock->ConfigurationRoot,
                                                              ControllerClass,
                                                              SerialController,
                                                              &MatchKey);

            } else {
                ConfigurationEntry = NULL;
            }

            if (ConfigurationEntry != NULL) {
                ChildEntry = ConfigurationEntry->Child;
                if ((ChildEntry != NULL) &&
                    (ChildEntry->ComponentEntry.Type == PointerPeripheral)) {
                    ConfigurationEntry = NULL;
                }
            }

            //
            // If COM2 does not exist or a serial mouse attaches to it, try
            // COM1.  If COM1 exists, we will use it no matter what is on
            // it.
            //

            if (ConfigurationEntry == NULL) {
                MatchKey = 0;
                if (LoaderBlock != NULL) {
                    ConfigurationEntry = KeFindConfigurationEntry(LoaderBlock->ConfigurationRoot,
                                                                  ControllerClass,
                                                                  SerialController,
                                                                  &MatchKey);

                } else {
                    ConfigurationEntry = NULL;
                }

                if (ConfigurationEntry != NULL) {
                    Com = 1;
                } else if (CpDoesPortExist((PUCHAR)COM2_PORT)) {
                    PortAddress = (PUCHAR)COM2_PORT;
                    Com = 2;
                } else if (CpDoesPortExist((PUCHAR)COM1_PORT)) {
                    PortAddress = (PUCHAR)COM1_PORT;
                    Com = 1;
                } else {
                    return STATUS_NOT_FOUND;
                }
            } else {
                Com = 2;
            }
        }

        //
        // Get Comport address from the component configuration data.
        // (If we find the ComponentEntry associated with the com port)
        //

        if (ConfigurationEntry) {
            List = (PCM_PARTIAL_RESOURCE_LIST)ConfigurationEntry->ConfigurationData;
            for (i = 0; i < List->Count ; i++ ) {
                Descriptor = &List->PartialDescriptors[i];
                if (Descriptor->Type == CmResourceTypePort) {
                    PortAddress = (PUCHAR)UlongToPtr(Descriptor->u.Port.Start.LowPart);
                }
            }
        }

        //
        // If we can not find the port address for the comport, simply use
        // default value.
        //

        if (PortAddress == NULL) {
            switch (Com) {
            case 1:
               PortAddress = (PUCHAR)COM1_PORT;
               break;
            case 2:
               PortAddress = (PUCHAR)COM2_PORT;
               break;
            case 3:
               PortAddress = (PUCHAR)COM3_PORT;
               break;
            case 4:
               PortAddress = (PUCHAR)COM4_PORT;
            }
        }

        //
        // Initialize the port structure.
        //

        ComPort = Com;
        PortInformation.Address = PortAddress;
        PortInformation.Baud = BaudRate;
    }

    if (KdComAddressID == 0) { // MMIO
        KdWriteUchar = CpWriteRegisterUchar;
        KdReadUchar  = CpReadRegisterUchar;
    }

    CpInitialize(&Port,
                 PortInformation.Address,
                 PortInformation.Baud
                 );

    //
    // The following should be reworked in conjunction with the serial
    // driver.   The serial driver doesn't understand the concept of
    // ports being memory so we need to have it believe we are using 
    // the IO port even though we are using a memory mapped equivalent.
    //

    if (HalpDebugPortTable && (KdComAddressID == 0))  {
        *KdComPortInUse = (UCHAR *)((ULONG_PTR)(*KdComPortInUse) & (PAGE_SIZE-1));
    }
    else  {
        *KdComPortInUse = PortInformation.Address;
    }

    return STATUS_SUCCESS;
}



ULONG
KdCompGetByte(
    OUT PUCHAR Input
    )
/*++

Routine Description:

    Fetch a byte from the debug port and return it.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/
{
    ULONG status = CpGetByte(&Port, Input, TRUE);
#if DBG && IA64
    KdProtocolTraceIn[KdProtocolIndexIn++%4096]=*Input;
#endif
    return status;
}



ULONG
KdCompPollByte(
    OUT PUCHAR Input
    )
/*++

Routine Description:

    Fetch a byte from the debug port and return it if one is available.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/
{
    ULONG status = CpGetByte(&Port, Input, FALSE);
#if DBG && IA64
    KdProtocolTraceIn[KdProtocolIndexIn++%4096]=*Input;
#endif
    return status;
}



VOID
KdCompPutByte(
    IN UCHAR Output
    )
/*++

Routine Description:

    Write a byte to the debug port.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Output - Supplies the output data byte.

Return Value:

    None.

--*/
{
#if DBG && IA64
    KdProtocolTraceOut[KdProtocolIndexOut++%4096]=Output;
#endif
    CpPutByte(&Port, Output);
}



VOID
KdCompRestore(
    VOID
    )
/*++

Routine Description:

    This routine does NOTHING on the x86.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Port.Flags &= ~PORT_SAVED;
}



VOID
KdCompSave(
    VOID
    )
/*++

Routine Description:

    This routine does NOTHING on the x86.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Port.Flags |= PORT_SAVED;
}


VOID
KdCompInitialize1(
    VOID
    )
{
    if(KdComAddressID == 0) {  // MMIO
       Port.Address    = (PUCHAR)MmMapIoSpace(DbgpKdComPhysicalAddress,8,MmNonCached);
       *KdComPortInUse = Port.Address;
    }
} // KdCompInitialize1()

ULONG
KdCompGetDebugTblBaudRate(
    UCHAR BaudRateFlag
    )
{
    ULONG Rate = BD_57600; // default.

    switch(BaudRateFlag) {
        case 3:
             Rate = BD_9600;
             break;
        case 4:
             Rate = BD_19200;
             break;
        case 7:
             Rate = BD_115200;
             break;
    }

    return Rate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\blbind.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blbind.c

Abstract:

    This module contains the code that implements the funtions required
    to relocate an image and bind DLL entry points.

Author:

    David N. Cutler (davec) 21-May-1991

Revision History:

--*/

#include "bldr.h"
#include "ctype.h"
#include "string.h"

//
// Define local procedure prototypes.
//

ARC_STATUS
BlpBindImportName (
    IN PVOID DllBase,
    IN PVOID ImageBase,
    IN PIMAGE_THUNK_DATA ThunkEntry,
    IN PIMAGE_EXPORT_DIRECTORY ExportDirectory,
    IN ULONG ExportSize,
    IN BOOLEAN SnapForwarder
    );

BOOLEAN
BlpCompareDllName (
    IN PCHAR Name,
    IN PUNICODE_STRING UnicodeString
    );

ARC_STATUS
BlpScanImportAddressTable(
    IN PVOID DllBase,
    IN PVOID ImageBase,
    IN PIMAGE_THUNK_DATA ThunkTable
    );

#include "blbindt.c"


BOOLEAN
BlCheckForLoadedDll (
    IN PCHAR DllName,
    OUT PKLDR_DATA_TABLE_ENTRY *FoundEntry
    )

/*++

Routine Description:

    This routine scans the loaded DLL list to determine if the specified
    DLL has already been loaded. If the DLL has already been loaded, then
    its reference count is incremented.

Arguments:

    DllName - Supplies a pointer to a null terminated DLL name.

    FoundEntry - Supplies a pointer to a variable that receives a pointer
        to the matching data table entry.

Return Value:

    If the specified DLL has already been loaded, then TRUE is returned.
    Otherwise, FALSE is returned.

--*/

{

    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    PLIST_ENTRY NextEntry;

    //
    // Scan the loaded data table list to determine if the specified DLL
    // has already been loaded.
    //

    NextEntry = BlLoaderBlock->LoadOrderListHead.Flink;
    while (NextEntry != &BlLoaderBlock->LoadOrderListHead) {
        DataTableEntry = CONTAINING_RECORD(NextEntry,
                                           KLDR_DATA_TABLE_ENTRY,
                                           InLoadOrderLinks);

        if (BlpCompareDllName(DllName, &DataTableEntry->BaseDllName) != FALSE) {
            *FoundEntry = DataTableEntry;
            DataTableEntry->LoadCount += 1;
            return TRUE;
        }

        NextEntry = NextEntry->Flink;
    }

    return FALSE;
}

BOOLEAN
BlpCompareDllName (
    IN PCHAR DllName,
    IN PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine compares a zero terminated character string with a unicode
    string. The UnicodeString's extension is ignored.

Arguments:

    DllName - Supplies a pointer to a null terminated DLL name.

    UnicodeString - Supplies a pointer to a Unicode string descriptor.

Return Value:

    If the specified name matches the Unicode name, then TRUE is returned.
    Otherwise, FALSE is returned.

--*/

{

    PWSTR Buffer;
    ULONG Index;
    ULONG Length;

    //
    // Compute the length of the DLL Name and compare with the length of
    // the Unicode name. If the DLL Name is longer, the strings are not
    // equal.
    //

    Length = strlen(DllName);
    if ((Length * sizeof(WCHAR)) > UnicodeString->Length) {
        return FALSE;
    }

    //
    // Compare the two strings case insensitive, ignoring the Unicode
    // string's extension.
    //

    Buffer = UnicodeString->Buffer;
    for (Index = 0; Index < Length; Index += 1) {
        if (toupper(*DllName) != toupper((CHAR)*Buffer)) {
            return FALSE;
        }

        DllName += 1;
        Buffer += 1;
    }
    if ((UnicodeString->Length == Length * sizeof(WCHAR)) ||
        (*Buffer == L'.')) {
        //
        // Strings match exactly or match up until the UnicodeString's extension.
        //
        return(TRUE);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\blconfig.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blconfig.c

Abstract:

    This module implements the OS loader configuration initialization.

Author:

    David N. Cutler (davec) 9-Sep-1991

Revision History:

--*/
#include "bootlib.h"
#include "stdio.h"
#include "stdlib.h"

ULONG
BlMatchToken (
    IN PCHAR TokenValue,
    IN CHAR * FIRMWARE_PTR TokenArray[]
    );

PCHAR
BlGetNextToken (
    IN PCHAR TokenString,
    OUT PCHAR OutputToken,
    OUT PULONG UnitNumber
    );

//
// Define types of adapters that can be booted from.
//

typedef enum _ADAPTER_TYPES {
    AdapterEisa,
    AdapterScsi,
    AdapterMulti,
    AdapterNet,
    AdapterRamdisk,
    AdapterMaximum
    } ADAPTER_TYPES;

//
// Define type of controllers that can be booted from.
//

typedef enum _CONTROLLER_TYPES {
    ControllerDisk,
    ControllerCdrom,
    ControllerMaximum
    } CONTROLLER_TYPES;

//
// Define type of peripheral that can be booted from.
//

typedef enum _PERIPHERAL_TYPES {
    PeripheralRigidDisk,
    PeripheralFloppyDisk,
#if defined(ELTORITO)
    PeripheralElTorito,
#endif
    PeripheralMaximum
    } PERIPHERAL_TYPES;

//
// Define the ARC pathname mnemonics.
//

CHAR * FIRMWARE_PTR MnemonicTable[] = {
    "arc",
    "cpu",
    "fpu",
    "pic",
    "pdc",
    "sic",
    "sdc",
    "sc",
    "eisa",
    "tc",
    "scsi",
    "dti",
    "multi",
    "disk",
    "tape",
    "cdrom",
    "worm",
    "serial",
    "net",
    "video",
    "par",
    "point",
    "key",
    "audio",
    "other",
    "rdisk",
    "fdisk",
    "tape",
    "modem",
    "monitor",
    "print",
    "pointer",
    "keyboard",
    "term",
    "other"
    };

CHAR * FIRMWARE_PTR BlAdapterTypes[AdapterMaximum + 1] = {"eisa","scsi","multi","net","ramdisk",NULL};
CHAR * FIRMWARE_PTR BlControllerTypes[ControllerMaximum + 1] = {"disk","cdrom",NULL};
#if defined(ELTORITO)
CHAR * FIRMWARE_PTR BlPeripheralTypes[PeripheralMaximum + 1] = {"rdisk","fdisk","cdrom",NULL};
#else
CHAR * FIRMWARE_PTR BlPeripheralTypes[PeripheralMaximum + 1] = {"rdisk","fdisk",NULL};
#endif


ARC_STATUS
BlConfigurationInitialize (
    IN PCONFIGURATION_COMPONENT Parent,
    IN PCONFIGURATION_COMPONENT_DATA ParentEntry
    )

/*++

Routine Description:

    This routine traverses the firmware configuration tree from the specified
    parent entry and constructs the corresponding NT configuration tree.

Arguments:

    None.

Return Value:

    ESUCCESS is returned if the initialization is successful. Otherwise,
    an unsuccessful status that describes the error is returned.

--*/

{

    PCONFIGURATION_COMPONENT Child;
    PCONFIGURATION_COMPONENT_DATA ChildEntry;
    PCHAR ConfigurationData;
    PCONFIGURATION_COMPONENT_DATA PreviousSibling;
    PCONFIGURATION_COMPONENT Sibling;
    PCONFIGURATION_COMPONENT_DATA SiblingEntry;
    ARC_STATUS Status;

    //
    // Traverse the child configuration tree and allocate, initialize, and
    // construct the corresponding NT configuration tree.
    //

    Child = ArcGetChild(Parent);
    while (Child != NULL) {

        //
        // Allocate an entry of the appropriate size to hold the child
        // configuration information.
        //

        ChildEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap(
                                        sizeof(CONFIGURATION_COMPONENT_DATA) +
                                            Child->IdentifierLength +
                                                Child->ConfigurationDataLength);

        if (ChildEntry == NULL) {
            return ENOMEM;
        }

        //
        // Initialize the tree pointers and copy the component data.
        //

        if (ParentEntry == NULL) {
            BlLoaderBlock->ConfigurationRoot = ChildEntry;

        } else {
            ParentEntry->Child = ChildEntry;
        }

        ChildEntry->Parent = ParentEntry;
        ChildEntry->Sibling = NULL;
        ChildEntry->Child = NULL;
        RtlMoveMemory((PVOID)&ChildEntry->ComponentEntry,
                      (PVOID)Child,
                      sizeof(CONFIGURATION_COMPONENT));

        ConfigurationData = (PCHAR)(ChildEntry + 1);

        //
        // If configuration data is specified, then copy the configuration
        // data.
        //

        if (Child->ConfigurationDataLength != 0) {
            ChildEntry->ConfigurationData = (PVOID)ConfigurationData;
            Status = ArcGetConfigurationData((PVOID)ConfigurationData,
                                             Child);

            if (Status != ESUCCESS) {
                return Status;
            }

            ConfigurationData += Child->ConfigurationDataLength;

        } else {
            ChildEntry->ConfigurationData = NULL;
        }

        //
        // If identifier data is specified, then copy the identifier data.
        //

        if (Child->IdentifierLength !=0) {
            ChildEntry->ComponentEntry.Identifier = ConfigurationData;
            RtlMoveMemory((PVOID)ConfigurationData,
                          (PVOID)Child->Identifier,
                          Child->IdentifierLength);

        } else {
            ChildEntry->ComponentEntry.Identifier = NULL;
        }

        //
        // Traverse the sibling configuration tree and allocate, initialize,
        // and construct the corresponding NT configuration tree.
        //

        PreviousSibling = ChildEntry;
        Sibling = ArcGetPeer(Child);
        while (Sibling != NULL) {

            //
            // Allocate an entry of the appropriate size to hold the sibling
            // configuration information.
            //

            SiblingEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap(
                                    sizeof(CONFIGURATION_COMPONENT_DATA) +
                                        Sibling->IdentifierLength +
                                            Sibling->ConfigurationDataLength);

            if (SiblingEntry == NULL) {
                return ENOMEM;
            }

            //
            // Initialize the tree pointers and copy the component data.
            //

            SiblingEntry->Parent = ParentEntry;
            SiblingEntry->Sibling = NULL;
            ChildEntry->Child = NULL;
            RtlMoveMemory((PVOID)&SiblingEntry->ComponentEntry,
                          (PVOID)Sibling,
                          sizeof(CONFIGURATION_COMPONENT));

            ConfigurationData = (PCHAR)(SiblingEntry + 1);

            //
            // If configuration data is specified, then copy the configuration
            // data.
            //

            if (Sibling->ConfigurationDataLength != 0) {
                SiblingEntry->ConfigurationData = (PVOID)ConfigurationData;
                Status = ArcGetConfigurationData((PVOID)ConfigurationData,
                                                 Sibling);

                if (Status != ESUCCESS) {
                    return Status;
                }

                ConfigurationData += Sibling->ConfigurationDataLength;

            } else {
                SiblingEntry->ConfigurationData = NULL;
            }

            //
            // If identifier data is specified, then copy the identifier data.
            //

            if (Sibling->IdentifierLength !=0) {
                SiblingEntry->ComponentEntry.Identifier = ConfigurationData;
                RtlMoveMemory((PVOID)ConfigurationData,
                              (PVOID)Sibling->Identifier,
                              Sibling->IdentifierLength);

            } else {
                SiblingEntry->ComponentEntry.Identifier = NULL;
            }

            //
            // If the sibling has a child, then generate the tree for the
            // child.
            //

            if (ArcGetChild(Sibling) != NULL) {
                Status = BlConfigurationInitialize(Sibling, SiblingEntry);
                if (Status != ESUCCESS) {
                    return Status;
                }
            }

            //
            // Set new sibling pointers and get the next sibling tree entry.
            //

            PreviousSibling->Sibling = SiblingEntry;
            PreviousSibling = SiblingEntry;
            Sibling = ArcGetPeer(Sibling);
        }

        //
        // Set new parent pointers and get the next child tree entry.
        //

        Parent = Child;
        ParentEntry = ChildEntry;
        Child = ArcGetChild(Child);
    }

    return ESUCCESS;
}



BOOLEAN
BlSearchConfigTree(
    IN PCONFIGURATION_COMPONENT_DATA Node,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN ULONG Key,
    IN PNODE_CALLBACK CallbackRoutine
    )
/*++

Routine Description:

    Conduct a depth-first search of the firmware configuration tree starting
    at a given node, looking for nodes that match a given class and type.
    When a matching node is found, call a callback routine.

Arguments:

    CurrentNode - node at which to begin the search.

    Class - configuration class to match, or -1 to match any class

    Type - configuration type to match, or -1 to match any class

    Key - key to match, or -1 to match any key

    FoundRoutine - pointer to a routine to be called when a node whose
        class and type match the class and type passed in is located.
        The routine takes a pointer to the configuration node and must
        return a boolean indicating whether to continue with the traversal.

Return Value:

    FALSE if the caller should abandon the search.
--*/
{
    PCONFIGURATION_COMPONENT_DATA Child;

    do {
        if (Child = Node->Child) {
            if (!BlSearchConfigTree(Child,
                                     Class,
                                     Type,
                                     Key,
                                     CallbackRoutine)) {
                return(FALSE);
            }
        }

        if (((Class == -1) || (Node->ComponentEntry.Class == Class))
          &&((Type == -1) || (Node->ComponentEntry.Type == Type))
          &&((Key == (ULONG)-1) || (Node->ComponentEntry.Key == Key))) {

              if (!CallbackRoutine(Node)) {
                  return(FALSE);
              }
        }

        Node = Node->Sibling;

    } while ( Node != NULL );

    return(TRUE);
}


VOID
BlGetPathnameFromComponent(
    IN PCONFIGURATION_COMPONENT_DATA Component,
    OUT PCHAR ArcName
    )

/*++

Routine Description:

    This function builds an ARC pathname for the specified component.

Arguments:

    Component - Supplies a pointer to a configuration component.

    ArcName - Returns the ARC name of the specified component.  Caller must
        provide a large enough buffer.

Return Value:

    None.

--*/
{

    if (Component->Parent != NULL) {
        BlGetPathnameFromComponent(Component->Parent,ArcName);
        //
        // append our segment to the arcname
        //

        sprintf(ArcName+strlen(ArcName),
                "%s(%d)",
                MnemonicTable[Component->ComponentEntry.Type],
                Component->ComponentEntry.Key);

    } else {
        //
        // We are the parent, initialize the string and return
        //
        ArcName[0] = '\0';
    }

    return;
}


BOOLEAN
BlGetPathMnemonicKey(
    IN PCHAR OpenPath,
    IN PCHAR Mnemonic,
    IN PULONG Key
    )

/*++

Routine Description:

    This routine looks for the given Mnemonic in OpenPath.
    If Mnemonic is a component of the path, then it converts the key
    value to an integer wich is returned in Key.

Arguments:

    OpenPath - Pointer to a string that contains an ARC pathname.

    Mnemonic - Pointer to a string that contains a ARC Mnemonic

    Key      - Pointer to a ULONG where the Key value is stored.


Return Value:

    FALSE  if mnemonic is found in path and a valid key is converted.
    TRUE   otherwise.

--*/

{

    PCHAR Tmp;
    CHAR  Digits[9];
    ULONG i;
    CHAR  String[16];

    //
    // Construct a string of the form ")mnemonic("
    //
    String[0]=')';
    for(i=1;*Mnemonic;i++) {
        String[i] = * Mnemonic++;
    }
    String[i++]='(';
    String[i]='\0';

    if ((Tmp=strstr(OpenPath,&String[1])) == NULL) {
        return TRUE;
    }

    if (Tmp != OpenPath) {
        if ((Tmp=strstr(OpenPath,String)) == NULL) {
            return TRUE;
        }
    } else {
        i--;
    }
    //
    // skip the mnemonic and convert the value in between parentheses to integer
    //
    Tmp+=i;
    for (i=0;i<sizeof(Digits) - 1;i++) {
        if (*Tmp == ')') {
            Digits[i] = '\0';
            break;
        }
        Digits[i] = *Tmp++;
    }
    Digits[i]='\0';
    *Key = atoi(Digits);
    return FALSE;
}


ARC_STATUS
BlGenerateDeviceNames (
    IN PCHAR ArcDeviceName,
    OUT PCHAR ArcCanonicalName,
    OUT OPTIONAL PCHAR NtDevicePrefix
    )

/*++

Routine Description:

    This routine generates an NT device name prefix and a canonical ARC
    device name from an ARC device name.

Arguments:

    ArcDeviceName - Supplies a pointer to a zero terminated ARC device
        name.

    ArcCanonicalName - Supplies a pointer to a variable that receives the
        ARC canonical device name.

    NtDevicePrefix - If present, supplies a pointer to a variable that receives the
        NT device name prefix.

Return Value:

    ESUCCESS is returned if an NT device name prefix and the canonical
    ARC device name are successfully generated from the ARC device name.
    Otherwise, an invalid argument status is returned.

--*/

{

    CHAR AdapterPath[64];
    CHAR AdapterName[32];
    ULONG AdapterNumber;
    CHAR ControllerName[32];
    ULONG ControllerNumber;
    ULONG MatchIndex;
    CHAR PartitionName[32];
    ULONG PartitionNumber;
    CHAR PeripheralName[32];
    ULONG PeripheralNumber;
    CHAR TokenValue[32];

    //
    // Get the adapter and make sure it is valid.
    //

    ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                   &AdapterName[0],
                                   &AdapterNumber);

    if (ArcDeviceName == NULL) {
        return EINVAL;
    }

    MatchIndex = BlMatchToken(&AdapterName[0], &BlAdapterTypes[0]);
    if (MatchIndex == AdapterMaximum) {
        return EINVAL;
    }

    sprintf(AdapterPath, "%s(%d)", AdapterName, AdapterNumber);
    if ((MatchIndex == AdapterNet) || (MatchIndex == AdapterRamdisk)) {
        strcpy(ArcCanonicalName, AdapterPath);
        if (ARGUMENT_PRESENT(NtDevicePrefix)) {
            *NtDevicePrefix = 0;
        }
        return ESUCCESS;
    }

    //
    // The next token is either another adapter or a controller.  ARC
    // names can have multiple adapters.  (e.g. "multi(0)scsi(0)disk(0)...")
    // Iterate until we find a token that is not an adapter.
    //

    do {
        ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                       &ControllerName[0],
                                       &ControllerNumber);

        if (ArcDeviceName == NULL) {
            return EINVAL;
        }

        MatchIndex = BlMatchToken(&ControllerName[0], &BlAdapterTypes[0]);
        if (MatchIndex == AdapterMaximum) {
            //
            // If it is not an adapter, we must have reached the last
            // adapter in the name.  Fall through to the controller logic.
            //
            break;
        } else {
            //
            // We have found another adapter, add it to
            // the canonical adapter path
            //

            sprintf(AdapterPath+strlen(AdapterPath),
                    "%s(%d)",
                    ControllerName,
                    ControllerNumber);

        }

    } while ( TRUE );

    MatchIndex = BlMatchToken(&ControllerName[0], &BlControllerTypes[0]);
    switch (MatchIndex) {

        //
        // Cdrom controller.
        //
        // Get the peripheral name and make sure it is valid.
        //

    case ControllerCdrom:
        ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                       &PeripheralName[0],
                                       &PeripheralNumber);

        if (ArcDeviceName == NULL) {
            return EINVAL;
        }

        if (_stricmp(&PeripheralName[0], "fdisk") != 0) {
            return EINVAL;
        }

        ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                       &TokenValue[0],
                                       &MatchIndex);

        if (ArcDeviceName != NULL) {
            return EINVAL;
        }

        sprintf(ArcCanonicalName,
                "%s%s(%d)%s(%d)",
                &AdapterPath[0],
                &ControllerName[0],
                ControllerNumber,
                &PeripheralName[0],
                PeripheralNumber);

        if (ARGUMENT_PRESENT(NtDevicePrefix)) {
            strcpy(NtDevicePrefix, "\\Device\\CDRom");
        }
        break;

        //
        // Disk controller.
        //
        // Get the peripheral and make sure it is valid.
        //

    case ControllerDisk:
        ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                       &PeripheralName[0],
                                       &PeripheralNumber);

        if (ArcDeviceName == NULL) {
            return EINVAL;
        }

        MatchIndex = BlMatchToken(&PeripheralName[0], &BlPeripheralTypes[0]);
        switch (MatchIndex) {

            //
            // Rigid Disk.
            //
            // If a partition is specified, then parse the partition number.
            //

        case PeripheralRigidDisk:
            ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                           &PartitionName[0],
                                           &PartitionNumber);

            if (ArcDeviceName == NULL) {
                strcpy(&PartitionName[0], "partition");
                PartitionNumber = 1;

            } else {
                if (_stricmp(&PartitionName[0], "partition") != 0) {
                    return EINVAL;
                }

                ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                               &TokenValue[0],
                                               &MatchIndex);

                if (ArcDeviceName != NULL) {
                    return EINVAL;
                }
            }

            sprintf(ArcCanonicalName,
                    "%s%s(%d)%s(%d)%s(%d)",
                    &AdapterPath[0],
                    &ControllerName[0],
                    ControllerNumber,
                    &PeripheralName[0],
                    PeripheralNumber,
                    &PartitionName[0],
                    PartitionNumber);

            if (ARGUMENT_PRESENT(NtDevicePrefix)) {
                strcpy(NtDevicePrefix, "\\Device\\Harddisk");
            }
            break;

            //
            // Floppy disk.
            //

        case PeripheralFloppyDisk:
#if defined(ARCI386)
            ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                           &PartitionName[0],
                                           &PartitionNumber);

            if (ArcDeviceName == NULL) {
                strcpy(&PartitionName[0], "partition");
                PartitionNumber = 1;

            } else {
                if (_stricmp(&PartitionName[0], "partition") != 0) {
                    return EINVAL;
                }

                ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                               &TokenValue[0],
                                               &MatchIndex);

                if (ArcDeviceName != NULL) {
                    return EINVAL;
                }
            }

            sprintf(ArcCanonicalName,
                    "%s%s(%d)%s(%d)%s(%d)",
                    &AdapterPath[0],
                    &ControllerName[0],
                    ControllerNumber,
                    &PeripheralName[0],
                    PeripheralNumber,
                    &PartitionName[0],
                    PartitionNumber);
#else
            ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                           &TokenValue[0],
                                           &MatchIndex);

            if (ArcDeviceName != NULL) {
                return EINVAL;
            }

            sprintf(ArcCanonicalName,
                    "%s%s(%d)%s(%d)",
                    &AdapterPath[0],
                    &ControllerName[0],
                    ControllerNumber,
                    &PeripheralName[0],
                    PeripheralNumber);

#endif  // defined(NEC_98)

            if (ARGUMENT_PRESENT(NtDevicePrefix)) {
                strcpy(NtDevicePrefix, "\\Device\\Floppy");
            }
            break;

#if defined(ELTORITO)
            //
            // El Torito CD-ROM.
            //

        case PeripheralElTorito:
            ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                           &TokenValue[0],
                                           &MatchIndex);

            if (ArcDeviceName != NULL) {
                return EINVAL;
            }

            sprintf(ArcCanonicalName,
                    "%s%s(%d)%s(%d)",
                    &AdapterPath[0],
                    &ControllerName[0],
                    ControllerNumber,
                    &PeripheralName[0],
                    PeripheralNumber);

            if (ARGUMENT_PRESENT(NtDevicePrefix)) {
                strcpy(NtDevicePrefix, "\\Device\\CDRom");
            }
            break;
#endif

            //
            // Invalid peripheral.
            //

        default:
            return EINVAL;
        }

        break;

        //
        // Invalid controller.
        //

    default:
        return EINVAL;
    }

    return ESUCCESS;
}

PCHAR
BlGetNextToken (
    IN PCHAR TokenString,
    OUT PCHAR OutputToken,
    OUT PULONG UnitNumber
    )

/*++

Routine Description:

    This routine scans the specified token string for the next token and
    unit number. The token format is:

        name[(unit)]

Arguments:

    TokenString - Supplies a pointer to a zero terminated token string.

    OutputToken - Supplies a pointer to a variable that receives the next
        token.

    UnitNumber - Supplies a pointer to a variable that receives the unit
        number.

Return Value:

    If another token exists in the token string, then a pointer to the
    start of the next token is returned. Otherwise, a value of NULL is
    returned.

--*/

{

    //
    // If there are more characters in the token string, then parse the
    // next token. Otherwise, return a value of NULL.
    //

    if (*TokenString == '\0') {
        return NULL;

    } else {
        while ((*TokenString != '\0') && (*TokenString != '(')) {
            *OutputToken++ = *TokenString++;
        }

        *OutputToken = '\0';

        //
        // If a unit number is specified, then convert it to binary.
        // Otherwise, default the unit number to zero.
        //

        *UnitNumber = 0;
        if (*TokenString == '(') {
            TokenString += 1;
            while ((*TokenString != '\0') && (*TokenString != ')')) {
                *UnitNumber = (*UnitNumber * 10) + (*TokenString++ - '0');
            }

            if (*TokenString == ')') {
                TokenString += 1;
            }
        }
    }

    return TokenString;
}

ULONG
BlMatchToken (
    IN PCHAR TokenValue,
    IN CHAR * FIRMWARE_PTR TokenArray[]
    )

/*++

Routine Description:

    This routine attempts to match a token with an array of possible
    values.

Arguments:

    TokenValue - Supplies a pointer to a zero terminated token value.

    TokenArray - Supplies a pointer to a vector of pointers to null terminated
        match strings.

Return Value:

    If a token match is located, then the index of the matching value is
    returned as the function value. Otherwise, an index one greater than
    the size of the match array is returned.

--*/

{

    ULONG Index;
    PCHAR MatchString;
    PCHAR TokenString;

    //
    // Scan the match array until either a match is found or all of
    // the match strings have been scanned.
    //

    Index = 0;
    while (TokenArray[Index] != NULL) {
        MatchString = TokenArray[Index];
        TokenString = TokenValue;
        while ((*MatchString != '\0') && (*TokenString != '\0')) {
            if (toupper(*MatchString) != toupper(*TokenString)) {
                break;
            }

            MatchString += 1;
            TokenString += 1;
        }

        if ((*MatchString == '\0') && (*TokenString == '\0')) {
            break;
        }

        Index += 1;
    }

    return Index;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\blcache.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blcache.c

Abstract:

    This module implements general purpose disk caching based on
    ranges [blrange.c] but it is used mainly for the file system
    metadata caching on load & system devices. In order to use caching
    on a device, you must make sure that there is only one unique
    BlFileTable entry for that device and the same device is not
    opened & cached simultaneously multiple times under different
    device ids. Otherwise there will be cache inconsistencies, since
    cached data and structures are maintained based on device id. Also
    you must make sure to stop caching when the device is closed.

Author:

    Cenk Ergan (cenke) 14-Jan-2000

Revision History:

--*/

#include "blcache.h"
#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

//
// Define global variables.
//

//
// This is the boot loader disk cache with all its bells and whistles.
//

BL_DISKCACHE BlDiskCache = {0};

//
// Useful defines for alignment and size in memory allocations.
//

//
// This define is used with BlAllocateAlignedDescriptor to allocate 64KB
// aligned memory. It is the number of pages for 64KB.
//

#define BL_DISKCACHE_64KB_ALIGNED  (0x10000 >> PAGE_SHIFT)

//
// Prototypes for internal functions.
//

PBL_DISK_SUBCACHE
BlDiskCacheFindCacheForDevice(
    ULONG DeviceId
    );

BOOLEAN
BlDiskCacheMergeRangeRoutine (
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry
    );

VOID
BlDiskCacheFreeRangeRoutine (
    PBLCRANGE_ENTRY pRangeEntry
    );

PBLCRANGE_ENTRY
BlDiskCacheAllocateRangeEntry (
    VOID
    );

VOID
BlDiskCacheFreeRangeEntry (
    PBLCRANGE_ENTRY pEntry
    );

//
// Disk cache functions' implementation.
//

ARC_STATUS
BlDiskCacheInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the global state for the boot loader
    disk cache, allocates the necessary memory etc.

Arguments:

    None. 

Return Value:

    ESUCCESS - Disk caching is initialized and is on line.

    ARC_STATUS - There was a problem. Disk caching is not online.

--*/

{
    ARC_STATUS Status = ESUCCESS;
    ULONG DevIdx;
    ULONG BlockIdx;
    ULONG EntryIdx;
    ULONG ActualBase;
    ULONG SizeInPages;
    ULONG OldUsableBase, OldUsableLimit;
    
    //
    // If we have already initialized, return success right away
    // denoting that the disk cache is on line. Returning failure 
    // from this function when called after the disk cache has already
    // been initialized may be ambiguous, i.e. as if the disk cache 
    // failed to initialize and is not started. So we return ESUCCESS.
    //

    if (BlDiskCache.Initialized)
    {
        return ESUCCESS;
    }

    //
    // Try to allocate the tables & buffers for caching. We don't
    // allocate them together in one big allocation, because it may be
    // harder for the memory manager to give us that. This way
    // although some memory may be wasted [since returned memory is
    // multiple of PAGE_SIZE], two seperate free memory blocks may be
    // utilized.
    //
    OldUsableBase = BlUsableBase;
    OldUsableLimit = BlUsableLimit;
    BlUsableBase = BL_DISK_CACHE_RANGE_LOW;
    BlUsableLimit = BL_DISK_CACHE_RANGE_HIGH;
    
    Status = BlAllocateAlignedDescriptor(LoaderOsloaderHeap,
                                         0,
                                         (BL_DISKCACHE_SIZE >> PAGE_SHIFT) + 1,
                                         BL_DISKCACHE_64KB_ALIGNED,
                                         &ActualBase);

    if (Status != ESUCCESS) goto cleanup;

    BlDiskCache.DataBuffer = (PVOID) (KSEG0_BASE | (ActualBase << PAGE_SHIFT));

    SizeInPages = (BL_DISKCACHE_NUM_BLOCKS * sizeof(BLCRANGE_ENTRY) >> PAGE_SHIFT) + 1;
    Status = BlAllocateDescriptor(LoaderOsloaderHeap,
                                  0,
                                  SizeInPages,
                                  &ActualBase);

    if (Status != ESUCCESS) goto cleanup;

    BlDiskCache.EntryBuffer = (PVOID) (KSEG0_BASE | (ActualBase << PAGE_SHIFT));

    //
    // Make sure all entries in the device cache lookup table are
    // marked uninitialized.
    //

    for (DevIdx = 0; DevIdx < BL_DISKCACHE_DEVICE_TABLE_SIZE; DevIdx++)
    {
        BlDiskCache.DeviceTable[DevIdx].Initialized = FALSE;
    }

    //
    // Initialize free entry list.
    //

    InitializeListHead(&BlDiskCache.FreeEntryList);

    //
    // Initialize EntryBuffer used for "allocating" & "freeing" 
    // range entries for the cached range lists.
    //

    for (EntryIdx = 0; EntryIdx < BL_DISKCACHE_NUM_BLOCKS; EntryIdx++)
    {
        //
        // Add this entry to the free list.
        //
        
        InsertHeadList(&BlDiskCache.FreeEntryList, 
                       &BlDiskCache.EntryBuffer[EntryIdx].UserLink);

        //
        // Point the UserData field to a BLOCK_SIZE chunk of the
        // DataBuffer.
        //
        
        BlDiskCache.EntryBuffer[EntryIdx].UserData = 
            BlDiskCache.DataBuffer + (EntryIdx * BL_DISKCACHE_BLOCK_SIZE);
    }

    //
    // Initialize the MRU blocks list head.
    //

    InitializeListHead(&BlDiskCache.MRUBlockList);

    //
    // Mark ourselves initialized.
    //

    BlDiskCache.Initialized = TRUE;

    Status = ESUCCESS;

    DPRINT(("DK: Disk cache initialized.\n"));

 cleanup:
    
    BlUsableBase = OldUsableBase;
    BlUsableLimit = OldUsableLimit;
    if (Status != ESUCCESS) {
        if (BlDiskCache.DataBuffer) {
            ActualBase = (ULONG)((ULONG_PTR)BlDiskCache.DataBuffer & (~KSEG0_BASE)) >>PAGE_SHIFT;
            BlFreeDescriptor(ActualBase);
        }

        if (BlDiskCache.EntryBuffer) {
            ActualBase = (ULONG)((ULONG_PTR)BlDiskCache.EntryBuffer & (~KSEG0_BASE)) >>PAGE_SHIFT;
            BlFreeDescriptor(ActualBase);
        }

        DPRINT(("DK: Disk cache initialization failed.\n"));
    }

    return Status;
}

VOID
BlDiskCacheUninitialize(
    VOID
    )

/*++

Routine Description:

    This routine uninitializes the boot loader disk cache: flushes &
    disables caches, free's allocated memory etc.

Arguments:

    None. 

Return Value:

    None.

--*/

{
    ULONG DevIdx;
    ULONG ActualBase;

    //
    // Stop caching for all devices.
    //

    for (DevIdx = 0; DevIdx < BL_DISKCACHE_DEVICE_TABLE_SIZE; DevIdx++)
    {
        if (BlDiskCache.DeviceTable[DevIdx].Initialized)
        {
            BlDiskCacheStopCachingOnDevice(DevIdx);
        }
    }

    //
    // Free allocated memory.
    //

    if (BlDiskCache.DataBuffer)
    {
        ActualBase = (ULONG)((ULONG_PTR)BlDiskCache.DataBuffer & (~KSEG0_BASE)) >> PAGE_SHIFT;
        BlFreeDescriptor(ActualBase);
    }

    if (BlDiskCache.EntryBuffer)
    {
        ActualBase = (ULONG)((ULONG_PTR)BlDiskCache.EntryBuffer & (~KSEG0_BASE)) >> PAGE_SHIFT;
        BlFreeDescriptor(ActualBase);
    }

    //
    // Mark the disk cache uninitialized.
    //

    BlDiskCache.Initialized = FALSE;

    DPRINT(("DK: Disk cache uninitialized.\n"));

    return;
}

PBL_DISK_SUBCACHE
BlDiskCacheFindCacheForDevice(
    ULONG DeviceId
    )

/*++

Routine Description:

    Return a cache header for a device id.

Arguments:

    DeviceId - Device that we want to access cached.

Return Value:

    Pointer to cache header or NULL if one could not be found.

--*/

{
    ULONG CurIdx;
    PBL_DISK_SUBCACHE pFreeEntry = NULL;

    //
    // If we have not done global disk cache initialization or we
    // could not allocate memory for caching data we could not have
    // started caching.
    //

    if ((!BlDiskCache.Initialized) || (BlDiskCache.DataBuffer == NULL))
    {
        return NULL;
    }

    //
    // Go through the table to see if there is an intialized cache for
    // this device.
    //

    for (CurIdx = 0; CurIdx < BL_DISKCACHE_DEVICE_TABLE_SIZE; CurIdx++)
    {
        if (BlDiskCache.DeviceTable[CurIdx].Initialized &&
            BlDiskCache.DeviceTable[CurIdx].DeviceId == DeviceId)
        {
            return &BlDiskCache.DeviceTable[CurIdx];
        }
    }

    //
    // Could not find an initialized cache for this device.
    //

    return NULL;
}

PBL_DISK_SUBCACHE
BlDiskCacheStartCachingOnDevice(
    ULONG DeviceId
    )

/*++

Routine Description:

    Attempt at start caching on the specified device by allocating a
    cache header and initializing it. If caching is already enabled
    on that device, return existing cache header.

Arguments:

    DeviceId - Device that we want to access cached.

Return Value:

    Pointer to created / found cache header or NULL if there was a
    problem.

--*/

{
    ULONG CurIdx;
    PBL_DISK_SUBCACHE pFoundEntry;
    PBL_DISK_SUBCACHE pFreeEntry = NULL;

    //
    // If we have not done global disk cache initialization or we
    // could not allocate memory for caching data, we could not have
    // started caching.
    //

    if ((!BlDiskCache.Initialized) || (BlDiskCache.DataBuffer == NULL))
    {
        return NULL;
    }

    //
    // First see if we already cache this device.
    //

    if (pFoundEntry = BlDiskCacheFindCacheForDevice(DeviceId))
    {
        return pFoundEntry;
    }

    //
    // Go through the device table to find an empty slot.
    //

    for (CurIdx = 0; CurIdx < BL_DISKCACHE_DEVICE_TABLE_SIZE; CurIdx++)
    {
        if (!BlDiskCache.DeviceTable[CurIdx].Initialized)
        {
            pFreeEntry = &BlDiskCache.DeviceTable[CurIdx];
            break;
        }
    }
    
    if (!pFreeEntry)
    {
        //
        // There were no free entries.
        //

        return NULL;
    }

    //
    // Initialize & return cache entry.
    //

    pFreeEntry->DeviceId = DeviceId;

    BlRangeListInitialize(&pFreeEntry->Ranges, 
                          BlDiskCacheMergeRangeRoutine, 
                          BlDiskCacheFreeRangeRoutine);

    pFreeEntry->Initialized = TRUE;

    DPRINT(("DK: Started cache on device %u.\n", DeviceId));

    return pFreeEntry;
}

VOID
BlDiskCacheStopCachingOnDevice(
    ULONG DeviceId
    )

/*++

Routine Description:

    Stop caching for DeviceId if we are and flush the cache.

Arguments:

    DeviceId - Device that we want to stop caching.

Return Value:

    None.

--*/

{
    PBL_DISK_SUBCACHE pCache;

    //
    // If we have not done global disk cache initialization or we
    // could not allocate memory for caching data, we could not have
    // started caching.
    //

    if ((!BlDiskCache.Initialized) || (BlDiskCache.DataBuffer == NULL))
    {
        return;
    }

    //
    // Find the cache.
    //

    pCache = BlDiskCacheFindCacheForDevice(DeviceId);

    if (pCache)
    {
        //
        // Free all the allocated ranges.
        //

        BlRangeListRemoveAllRanges(&pCache->Ranges);

        //
        // Mark the cache entry free.
        //

        pCache->Initialized = FALSE;

        DPRINT(("DK: Stopped cache on device %u.\n", DeviceId));
    }
}

ARC_STATUS
BlDiskCacheRead (
    ULONG DeviceId,
    PLARGE_INTEGER pOffset,
    PVOID Buffer,
    ULONG Length,
    PULONG pCount,
    BOOLEAN CacheNewData
    )

/*++

Routine Description:

    Perform a cached read from the device. Copy over parts that are in
    the cache, and perform ArcRead on DeviceId for parts that are
    not. The data read by ArcRead will be added to the cache if
    CacheNewData is TRUE.

    NOTE. Do not call this function directly with Length > 64KB. It
    uses a fixed size buffer for containing list of overlapping cached
    ranges, and if they don't all fit into the buffer, it bails out and
    calls ArcRead directly [i.e. non-cached].

Arguments:

    DeviceId - Device to read from.

    Offset - Offset to read from.

    Buffer - To read data into.

    Length - Number of bytes to read into Buffer from Offset on DeviceId.
    
    pCount - Number of bytes read.

    CacheNewData - Data that is not in the cache but was read from the
        disk is added to the cache.

Return Value:

    Status. 

    NOTE: DeviceId's (Seek) Position is undefined after this call.

--*/

{
    PBL_DISK_SUBCACHE pCache;
    ARC_STATUS Status;
    LARGE_INTEGER LargeEndOffset;
    BLCRANGE ReadRange;
    
    //
    // We use ResultsBuffer for both finding overlapping range entries and
    // distinct ranges.
    //

    UCHAR ResultsBuffer[BL_DISKCACHE_FIND_RANGES_BUF_SIZE];
    ULONG ResultsBufferSize = BL_DISKCACHE_FIND_RANGES_BUF_SIZE;

    PBLCRANGE_ENTRY *pOverlaps = (PBLCRANGE_ENTRY *) ResultsBuffer;
    ULONG NumOverlaps;
    PBLCRANGE pDistinctRanges = (PBLCRANGE) ResultsBuffer;
    ULONG NumDistincts;

    ULONG OverlapIdx;
    ULONG DistinctIdx;

    ULONGLONG StartOffset;
    ULONGLONG EndOffset;
    ULONGLONG ReadOffset;
    LARGE_INTEGER LIReadOffset;
    PUCHAR pSrc;
    PUCHAR pDest;
    PUCHAR pDestEnd;
    ULONG CopyLength;
    ULONG ReadLength;
    ULONG BytesRead;
    PUCHAR EndOfCallersBuffer = ((PUCHAR) Buffer) + Length;
    LIST_ENTRY *pLastMRUEntrysLink;
    PBLCRANGE_ENTRY pNewCacheEntry;
    PBLCRANGE_ENTRY pLastMRUEntry;
    ULONGLONG HeadBlockOffset;
    ULONGLONG TailBlockOffset;
    ULONG HeadBytesOffset;
    ULONG NumTailBytes;

    DPRINT(("DK: READ(%5u,%016I64x,%08x,%8u,%d)\n", DeviceId, 
            pOffset->QuadPart, Buffer, Length, (DWORD)CacheNewData));

    //
    // Reset the number of bytes read.
    //

    *pCount = 0;

    //
    // Note where the device's position has to be after a successful
    // completion of the request.
    //

    LargeEndOffset.QuadPart = pOffset->QuadPart + Length;

    //
    // Look for a cache for this device.
    //

    pCache = BlDiskCacheFindCacheForDevice(DeviceId);
    
    if (pCache)
    {
        //
        // Determine read range.
        //

        ReadRange.Start = pOffset->QuadPart;
        ReadRange.End = ReadRange.Start + Length;

        //
        // If any part of the read range is in the cache, copy it over
        // into the buffer. First find out all cache entries that
        // contain data for this range. This function returns an array
        // of pointers to overlapping entries.
        //

        if (!BlRangeListFindOverlaps(&pCache->Ranges, 
                                     &ReadRange, 
                                     pOverlaps, 
                                     ResultsBufferSize, 
                                     &NumOverlaps))
        {
            goto SkipCache;
        }

        for (OverlapIdx = 0; OverlapIdx < NumOverlaps; OverlapIdx++)
        {
            //
            // Move this cache entry to the head of the MRU list.
            //

            RemoveEntryList(&pOverlaps[OverlapIdx]->UserLink);
            InsertHeadList(&BlDiskCache.MRUBlockList,
                           &pOverlaps[OverlapIdx]->UserLink);

            //
            // Copy cached part. This is the overlap between the readrange
            // and this overlapping range, i.e. max of starts, min of ends.
            //
            
            StartOffset = BLCMAX(pOverlaps[OverlapIdx]->Range.Start, 
                                 (ULONGLONG) pOffset->QuadPart);
            EndOffset = BLCMIN(pOverlaps[OverlapIdx]->Range.End, 
                               ((ULONGLONG) pOffset->QuadPart) + Length);
            CopyLength = (ULONG) (EndOffset - StartOffset);

            pSrc = ((PUCHAR) pOverlaps[OverlapIdx]->UserData) +
                (StartOffset - pOverlaps[OverlapIdx]->Range.Start);
            pDest = ((PUCHAR) Buffer) + 
                (StartOffset - (ULONGLONG) pOffset->QuadPart);
            
            DPRINT(("DK:  CopyCached:%08x,%08x,%d\n", pDest, pSrc, CopyLength)); 
            DASSERT((pDest < (PUCHAR) Buffer) ||
                    (pDest + CopyLength > EndOfCallersBuffer));

            RtlCopyMemory(pDest, pSrc, CopyLength);

            *pCount += CopyLength;
        }

        if (*pCount == Length)
        {
            //
            // The full request was satisfied from the cache. Seek to
            // where the device position should be if the request was
            // read from the device.
            //
            
            if (ArcSeek(DeviceId, &LargeEndOffset, SeekAbsolute) != ESUCCESS)
            {
                goto SkipCache;
            }

            return ESUCCESS;
        }

        //
        // Identify distinct ranges that are not in the cache.
        //
        
        if (!BlRangeListFindDistinctRanges(&pCache->Ranges, 
                                           &ReadRange, 
                                           pDistinctRanges, 
                                           ResultsBufferSize, 
                                           &NumDistincts))
        {
            goto SkipCache;
        }

        //
        // Read the distinct ranges from the disk and copy them into
        // caller's buffer. This function returns an array of
        // BLCRANGE's that are subranges of the requested range that
        // do not overlap with any ranges in the cache.
        //

        for (DistinctIdx = 0; DistinctIdx < NumDistincts; DistinctIdx++)
        {
            if (CacheNewData)
            {
                //
                // Not only do we have to read uncached parts from the disk,
                // we also have to add them to our cache.
                //

                StartOffset = pDistinctRanges[DistinctIdx].Start;
                EndOffset = pDistinctRanges[DistinctIdx].End;
                pDest = ((PUCHAR) Buffer) + 
                    (StartOffset - pOffset->QuadPart);

                ReadLength = BL_DISKCACHE_BLOCK_SIZE;
                ReadOffset = StartOffset & (~(BL_DISKCACHE_BLOCK_SIZE - 1));

                //
                // Make note of Head & Tail block offsets and number
                // of bytes, so it is easy to recognize that we will
                // copy only a part of the data we read from the disk
                // into the callers buffer. Setting these up here, we
                // don't have to handle the four cases seperately: i.e.
                // - when the block we read is the head [i.e. first] block 
                //   and the range starts from an offset into the block
                // - when the block we read is the tail [i.e. last] block
                //   and the range extends only a number of bytes into it.
                // - when the block we read is both the head and the tail.
                // - when the block we read is from the middle of the range
                //   and all of it is in the range.
                //
                
                HeadBlockOffset = StartOffset & (~(BL_DISKCACHE_BLOCK_SIZE - 1));
                TailBlockOffset = EndOffset   & (~(BL_DISKCACHE_BLOCK_SIZE - 1));

                HeadBytesOffset = (ULONG)(StartOffset & (BL_DISKCACHE_BLOCK_SIZE - 1));
                NumTailBytes = (ULONG)(EndOffset & (BL_DISKCACHE_BLOCK_SIZE - 1));

                //
                // We need to read this range from the disk in
                // BLOCK_SIZE aligned BLOCK_SIZE chunks, build new
                // cache entries to add to the cached ranges list and
                // copy it to the target buffer.
                //

                pDestEnd = ((PUCHAR)Buffer) + (EndOffset - pOffset->QuadPart);
                while (pDest < pDestEnd)
                {
                    //
                    // First get our hands on a new cache entry.
                    //
                    
                    pNewCacheEntry = BlDiskCacheAllocateRangeEntry();
                    
                    if (!pNewCacheEntry)
                    {
                        //
                        // We will free the last MRU entry and use that.
                        //

                        if (IsListEmpty(&BlDiskCache.MRUBlockList))
                        {                           
                            goto SkipCache;
                        }

                        //
                        // Identify the last MRU entry.
                        //

                        pLastMRUEntrysLink = BlDiskCache.MRUBlockList.Blink;
                        pLastMRUEntry = CONTAINING_RECORD(pLastMRUEntrysLink, 
                                                          BLCRANGE_ENTRY, 
                                                          UserLink);

                        //
                        // Remove the entry from cached list. When the
                        // entry is freed, it is removed from MRU and
                        // put onto the free list.
                        //
                        
                        BlRangeListRemoveRange(&pCache->Ranges,
                                               &pLastMRUEntry->Range);

                        //
                        // Now try allocating a new entry.
                        //

                        pNewCacheEntry = BlDiskCacheAllocateRangeEntry();

                        if (!pNewCacheEntry) {
                            goto SkipCache;
                        }

                    }

                    //
                    // Read BLOCK_SIZE from device into the cache
                    // entry's buffer.
                    //
                    
                    pNewCacheEntry->Range.Start = ReadOffset;
                    pNewCacheEntry->Range.End = ReadOffset + ReadLength;
                    
                    LIReadOffset.QuadPart = ReadOffset;
                    
                    if (ArcSeek(DeviceId, 
                                &LIReadOffset, 
                                SeekAbsolute) != ESUCCESS)
                    {
                        BlDiskCacheFreeRangeEntry(pNewCacheEntry);
                        goto SkipCache;
                    }
                    
                    if (ArcRead(DeviceId, 
                                pNewCacheEntry->UserData, 
                                ReadLength, 
                                &BytesRead) != ESUCCESS)
                    {
                        BlDiskCacheFreeRangeEntry(pNewCacheEntry);
                        goto SkipCache;
                    }

                    if (BytesRead != ReadLength)
                    {
                        BlDiskCacheFreeRangeEntry(pNewCacheEntry);
                        goto SkipCache;
                    }

                    //
                    // Add this range to cached ranges.
                    //
                    
                    if (!BlRangeListAddRange(&pCache->Ranges, pNewCacheEntry))
                    {
                        BlDiskCacheFreeRangeEntry(pNewCacheEntry);
                        goto SkipCache;
                    }
                    
                    //
                    // Put this cache entry at the head of MRU.
                    //

                    InsertHeadList(&BlDiskCache.MRUBlockList,
                                   &pNewCacheEntry->UserLink);

                    //
                    // Now copy read data into callers buffer. Adjust
                    // the source pointer and the number of bytes to
                    // copy depending on whether the block we are going
                    // to copy from is the head or tail block, or both.
                    //
                    
                    CopyLength = ReadLength;
                    pSrc = pNewCacheEntry->UserData;

                    if (ReadOffset == HeadBlockOffset)
                    {
                        CopyLength -= HeadBytesOffset;
                        pSrc += HeadBytesOffset;
                    }

                    if (ReadOffset == TailBlockOffset)
                    {
                        CopyLength -= (BL_DISKCACHE_BLOCK_SIZE - NumTailBytes);
                    }

                    DPRINT(("DK:  CopyNew:%08x,%08x,%d\n", pDest, pSrc, CopyLength)); 
                    DASSERT((pDest < (PUCHAR) Buffer) ||
                            (pDest + CopyLength > EndOfCallersBuffer));

                    RtlCopyMemory(pDest, pSrc, CopyLength);

                    //
                    // Set new ReadOffset.
                    //

                    ReadOffset += ReadLength;

                    //
                    // Update pDest & number of bytes we've filled in
                    // so far.
                    //

                    pDest += CopyLength;
                    *pCount += CopyLength;
                }
            }
            else
            {
                //
                // We don't need to cache what we read. Just read the
                // range from the disk.
                //
            
                StartOffset = pDistinctRanges[DistinctIdx].Start;
                pDest = ((PUCHAR) Buffer) + 
                    (StartOffset - pOffset->QuadPart);
                ReadLength = (ULONG) (pDistinctRanges[DistinctIdx].End - 
                                      pDistinctRanges[DistinctIdx].Start);
                LIReadOffset.QuadPart = StartOffset;

                if (ArcSeek(DeviceId, 
                            &LIReadOffset, 
                            SeekAbsolute) != ESUCCESS)
                {
                    goto SkipCache;
                }
            
                DPRINT(("DK:  ReadDistinct:%016I64x,%08x,%8d\n", 
                        LIReadOffset.QuadPart, pDest, ReadLength)); 
                
                if (ArcRead(DeviceId, 
                            pDest, 
                            ReadLength, 
                            &BytesRead) != ESUCCESS)
                {
                    goto SkipCache;
                }
            
                if (BytesRead != ReadLength)
                {
                    goto SkipCache;
                }

                *pCount += BytesRead;
            }
        }

        //
        // We should have read Length bytes.
        //
        
        ASSERT(*pCount == Length);
            
        //
        // Seek to where the device position should be if the request was
        // read from the device.
        //

        if (ArcSeek(DeviceId, &LargeEndOffset, SeekAbsolute) != ESUCCESS)
        {
            goto SkipCache;
        }
        
        return ESUCCESS;   
    }

    //
    // If we hit a problem satisfying the request through the cache,
    // we'll jump here to try the normal read.
    //

 SkipCache:

    //
    // Reset the number of bytes read.
    //

    *pCount = 0;

    //
    // If no cache was found or data could not be read from the cache,
    // hand over to ArcRead.
    //
    
    if ((Status = ArcSeek(DeviceId, pOffset, SeekAbsolute)) != ESUCCESS)
    {
        return Status;
    }
    
    DPRINT(("DK:  SkipCacheRead:%016I64x,%08x,%d\n", 
            LIReadOffset.QuadPart, pDest, CopyLength)); 

    Status = ArcRead(DeviceId, Buffer, Length, pCount);  

    return Status;
}

ARC_STATUS
BlDiskCacheWrite (
    ULONG DeviceId,
    PLARGE_INTEGER pOffset,   
    PVOID Buffer,
    ULONG Length,
    PULONG pCount
    )

/*++

Routine Description:

    Perform a write to the cached device. Currently simply invalidate
    any cached data around that range and call ArcWrite.

Arguments:

    DeviceId - Device to write to.

    Offset - Offset to write beginning from.

    Buffer - Data to write.

    Length - Number of bytes to write.
    
    pCount - Number of bytes written.

Return Value:

    Status. 

    NOTE: DeviceId's (Seek) Position is undefined after this call.

--*/

{
    PBL_DISK_SUBCACHE pCache;
    ARC_STATUS Status;
    BLCRANGE WriteRange;

    DPRINT(("DK: WRITE(%5u,%016I64x,%08x,%8u)\n", 
            DeviceId, pOffset->QuadPart, Buffer, Length));

    pCache = BlDiskCacheFindCacheForDevice(DeviceId);
    
    //
    // If a cache was found, invalidate cached data around
    // the range.
    //

    if (pCache)
    {
        WriteRange.Start = pOffset->QuadPart;
        WriteRange.End = WriteRange.Start + Length;
        
        //
        // The free-range-entry routine we initialized the rangelist
        // with will remove entries from the MRU list in addition to
        // free'ing them. So all we have to do is to call RemoveRange.
        //

        BlRangeListRemoveRange(&pCache->Ranges, &WriteRange);
    }

    if ((Status = ArcSeek(DeviceId, pOffset, SeekAbsolute)) != ESUCCESS)
    {
        return Status;
    }
    
    Status = ArcWrite(DeviceId, Buffer, Length, pCount);
    
    return Status;
}

BOOLEAN
BlDiskCacheMergeRangeRoutine (
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry
    )

/*++

Routine Description:

    This routine is passed to rangelist initialization, so rangelist
    functions can use it to merge two cache blocks that are
    consecutive.

Arguments:

    pDestEntry, pSrcEntry - Two entries to merge.    

Return Value:

    FALSE.

--*/
    
{

    //
    // We don't want anything to get merged, because our block size is
    // fixed. So we always return FALSE.
    // 

    return FALSE;
}

VOID
BlDiskCacheFreeRangeRoutine (
    PBLCRANGE_ENTRY pRangeEntry
    )

/*++

Routine Description:

    This routine is passed to rangelist initialization, so rangelist
    functions can use it to free a cache block entry and its data.

Arguments:

    pRangeEntry - Range entry to free.

Return Value:

    None. 

--*/
    
{

    //
    // Remove from the MRU list.
    //

    RemoveEntryList(&pRangeEntry->UserLink);

    //
    // Call the function to free the range entry.
    //

    BlDiskCacheFreeRangeEntry(pRangeEntry);

    return;
}

PBLCRANGE_ENTRY
BlDiskCacheAllocateRangeEntry (
    VOID
    )

/*++

Routine Description:

    This routine allocates a range entry used to describe a cached
    range on a device. Its UserData points to a BLOCK_SIZE of memory
    to contain the cached data.

Arguments:

    None.

Return Value:

    Pointer to a range entry or NULL if out of memory.

--*/

{
    PBLCRANGE_ENTRY pFreeEntry = NULL;
    LIST_ENTRY *pFreeEntryLink;

    //
    // If the free list is not empty, remove an entry and return it.
    //

    if (!IsListEmpty(&BlDiskCache.FreeEntryList))
    {
        pFreeEntryLink = RemoveHeadList(&BlDiskCache.FreeEntryList);
        pFreeEntry = CONTAINING_RECORD(pFreeEntryLink,
                                       BLCRANGE_ENTRY,
                                       UserLink);
    }

    return pFreeEntry;
}

VOID
BlDiskCacheFreeRangeEntry (
    PBLCRANGE_ENTRY pEntry
    )

/*++

Routine Description:

    This routine frees a range entry. Currently it simply inserts it
    back on the FreeList, so it can be "allocated" when we need
    another range entry.

Arguments:

    pEntry - Pointer to the entry to be freed.

Return Value:

    None.

--*/

{
    //
    // Insert this entry back on the free list.
    //
        
    InsertHeadList(&BlDiskCache.FreeEntryList, 
                   &pEntry->UserLink);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\blgpt.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blgpt.c

Abstract:

    This module implements routines relating to GPT partitions.

Author:

    Andrew Ritz (andrewr) 20-March-2001

Revision History:

    Andrew Ritz (andrewr) 20-March-2001 - Created based on existing code.

--*/

#include "bldr.h"  // defines EFI_PARTITION_SUPPORT
#ifdef EFI_PARTITION_SUPPORT

#include "bootlib.h"

#ifndef MIN
#define MIN(a,b)  ((a < b) ? a : b)
#endif

#if 0 && DBG

ULONG
BlGetKey(
    VOID
    );

#define DBG_PRINT(x)  BlPrint(x);
//{\
//    BlPrint(x); \
//    while (!BlGetKey()); \
//}
#else
#define DBG_PRINT(x)
#endif

#ifdef UNICODE
#define STR_PREFIX  L
#else
#define STR_PREFIX
#endif

UCHAR GptScratchBuffer[1024*17];
//
// we read 16K chunks at a time.
//
#define GPT_READ_SIZE 1024*16
UCHAR GptScratchBuffer2[1024];



BOOLEAN
BlIsValidGUIDPartitionTableHelper(
    IN UNALIGNED EFI_PARTITION_TABLE  *PartitionTableHeader,
    IN ULONGLONG LBAOfPartitionTable,
    IN PVOID Context,
    IN PGPT_READ_CALLBACK DiskReadFunction
    )
/*++

Routine Description:

    This function checks the validity of a GUID Partition table.
    
    Per EFI Spec, the following tests must be performed to determine if a GUID
    Partition Table is valid:
    
    1) Check the GUID Partition Table Signature
    2) Check the GUID Partition Table CRC
    3) Check that the MyLBA entry points to the LBA that contains the GUID
       partition table
    4) Check the CRC of the GUID Partition Entry Array        
        
Arguments:

    PartitionTableHeader - pointer to header for partition table.
    
    LBAOfPartitionTable - logical block address that the header was read from.
    
    Context - pass through value to callback function used to read from disk
    
    DiskReadFunction - callback function used to read from the disk.
    
Return Value:

    TRUE indicates that the table is valid.

--*/

{
    CHAR *PartitionEntryArray = &GptScratchBuffer[0];
    ULONG Crc32, CalculatedCrc32;
    ULONG TotalSize,CurrentSize;
    ULONGLONG CurrentLBA;
    DBG_PRINT(STR_PREFIX"Verifying GPT PT\r\n");

    //
    // 1) Check the GUID Partition Table Signature
    //
    if (memcmp(PartitionTableHeader->Signature, EFI_SIGNATURE, sizeof(EFI_SIGNATURE))) {
        DBG_PRINT(STR_PREFIX"Signature does not match, invalid partition table\r\n");
        return(FALSE);           
    }

    //
    // 2) Check the GUID Partition Table CRC
    //
    // To do this we save off the old CRC value, calculate the CRC, and compare
    // the results (remembering that we need to put the CRC back when we're 
    // done with it).
    //
    Crc32 = PartitionTableHeader->HeaderCRC;
    PartitionTableHeader->HeaderCRC = 0;
    CalculatedCrc32 = RtlComputeCrc32( 0, PartitionTableHeader, PartitionTableHeader->HeaderSize );
    PartitionTableHeader->HeaderCRC = Crc32;
    if (CalculatedCrc32 != Crc32) {
        DBG_PRINT(STR_PREFIX"Partition table CRC does not calculate, invalid partition table\r\n");                  
        return(FALSE);
    }    

    //
    // 3) Check that the MyLBA entry points to the LBA that contains the GUID Partition Table
    //
    if (LBAOfPartitionTable != PartitionTableHeader->MyLBA) {
        DBG_PRINT(STR_PREFIX"LBA of Partition table does not match LBA in partition table header, invalid partition table\r\n");
        return(FALSE);
    }

    //
    // 4) Check the CRC of the GUID Partition Entry Array
    //
    //
    // first read the GUID Partition Entry Array
    //
    CurrentLBA = PartitionTableHeader->PartitionEntryLBA;
    TotalSize = PartitionTableHeader->PartitionEntrySize * PartitionTableHeader->PartitionCount;
    CurrentSize = 0;
    CalculatedCrc32 = 0;
    while (TotalSize != 0) {
        CurrentSize = MIN(TotalSize, GPT_READ_SIZE);
        if (DiskReadFunction( 
            (ULONGLONG)CurrentLBA,
            CurrentSize,
            Context,
            PartitionEntryArray )) {
            CalculatedCrc32 = RtlComputeCrc32( 
                                           CalculatedCrc32, 
                                           PartitionEntryArray,
                                           CurrentSize);
        } else {
            DBG_PRINT(STR_PREFIX"DiskReadFunction for PartitionTableHeader failed, invalid partition table\r\n");
            return(FALSE);
            break;
        }   

        TotalSize -= CurrentSize;
        CurrentLBA += CurrentSize*SECTOR_SIZE;

    }

    if (CalculatedCrc32 == ((UNALIGNED EFI_PARTITION_TABLE *)PartitionTableHeader)->PartitionEntryArrayCRC) {            
        return(TRUE);
    } else {
        DBG_PRINT(STR_PREFIX"CRC for PartitionEntryArray does not calculate, invalid partition table\r\n");
        return(FALSE);
    }

    return(FALSE);

}

BOOLEAN
BlIsValidGUIDPartitionTable(
    IN UNALIGNED EFI_PARTITION_TABLE  *PartitionTableHeader,
    IN ULONGLONG LBAOfPartitionTable,
    IN PVOID Context,
    IN PGPT_READ_CALLBACK DiskReadFunction
    )
{
    UNALIGNED EFI_PARTITION_TABLE  *BackupPartitionTableHeader = (EFI_PARTITION_TABLE *)&GptScratchBuffer2;
    BOOLEAN RetVal = FALSE;
    if (BlIsValidGUIDPartitionTableHelper( 
                            PartitionTableHeader,
                            LBAOfPartitionTable,
                            Context,
                            DiskReadFunction)) {
        //
        // If the primary table @ LBA 1, check the AlternateLBA to see if it
        // is valid.
        //
        if (LBAOfPartitionTable == 1) {
            //
            // Read the backup partition table into memory and validate it as 
            // well.
            //
            if (DiskReadFunction( 
                            PartitionTableHeader->AlternateLBA,
                            PartitionTableHeader->HeaderSize,
                            Context,
                            BackupPartitionTableHeader)) {
                if (BlIsValidGUIDPartitionTableHelper( 
                                            (UNALIGNED EFI_PARTITION_TABLE *)BackupPartitionTableHeader,
                                            PartitionTableHeader->AlternateLBA,
                                            Context,
                                            DiskReadFunction)) {
                    RetVal = TRUE;
                    DBG_PRINT(STR_PREFIX"BlIsValidGUIDPartitionTable succeeded\r\n");
                }
            } else {
                DBG_PRINT(STR_PREFIX"DiskReadFunction for BackupPartitionTableHeader failed, invalid partition table\r\n");
            }
        } else {
            DBG_PRINT(STR_PREFIX"WARNING: LBA of PartitionTableHeader is not 1.\r\n");
            RetVal = TRUE;
        }
    }
    return(RetVal);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\blio.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blio.c

Abstract:

    This module contains the code that implements the switch function for
    I/O operations between then operating system loader, the target file
    system, and the target device.

Author:

    David N. Cutler (davec) 10-May-1991

Revision History:

--*/

#include "bootlib.h"
#include "stdio.h"

//
// Define file table.
//
BL_FILE_TABLE BlFileTable[BL_FILE_TABLE_SIZE];

#if DBG
ULONG BlFilesOpened = 0;
#endif

#ifdef CACHE_DEVINFO

//
// Device close notification routines, are registered by the file system 
// which are interested in device close events. This is primarily used for
// invalidating the internal cache, which the file system maintains
// using DeviceId as one of the keys
//
PARC_DEVICE_CLOSE_NOTIFICATION  DeviceCloseNotify[MAX_DEVICE_CLOSE_NOTIFICATION_SIZE] = {0};

//
// Device to filesystem cache table
//
DEVICE_TO_FILESYS   DeviceFSCache[BL_FILE_TABLE_SIZE];

ARC_STATUS
ArcCacheClose(
    IN ULONG DeviceId
    )
/*++

Routine Description:

    This routine invalidates the file system information
    cached for the given device ID.

Arguments:

    DeviceId : Device to close

Return Value:

    ESUCCESS is returned if the close is successful. Otherwise,
    return an unsuccessful status.

--*/
{
  ULONG Index;

  //
  // Notify all the registered file system about the device close
  //
  for (Index = 0; Index < MAX_DEVICE_CLOSE_NOTIFICATION_SIZE; Index++) {
    if (DeviceCloseNotify[Index]) {
        (DeviceCloseNotify[Index])(DeviceId);
    }
  }

  //
  // Update device to file system cache
  //

  for (Index = 0; Index < BL_FILE_TABLE_SIZE; Index++) {
    if (DeviceFSCache[Index].DeviceId == DeviceId){
      DeviceFSCache[Index].DeviceId = -1;
    }
  }    

  return ((PARC_CLOSE_ROUTINE)
          (SYSTEM_BLOCK->FirmwareVector[CloseRoutine]))(DeviceId);
}


ARC_STATUS
ArcRegisterForDeviceClose(
    PARC_DEVICE_CLOSE_NOTIFICATION FlushRoutine
    )
{
    ARC_STATUS  Status = EINVAL;
    
    if (FlushRoutine) {
        ULONG   Index;

        Status = ENOENT;

        for (Index=0; Index < MAX_DEVICE_CLOSE_NOTIFICATION_SIZE; Index++) {
            if (!DeviceCloseNotify[Index]) {
                DeviceCloseNotify[Index] = FlushRoutine;                
                Status = ESUCCESS;
                
                break;
            }                
        }
    }

    return Status;
}

ARC_STATUS
ArcDeRegisterForDeviceClose(
    PARC_DEVICE_CLOSE_NOTIFICATION FlushRoutine
    )
{
    ARC_STATUS  Status = EINVAL;
    
    if (FlushRoutine) {
        ULONG   Index;

        Status = ENOENT;

        for (Index=0; Index < MAX_DEVICE_CLOSE_NOTIFICATION_SIZE; Index++) {
            if (DeviceCloseNotify[Index] == FlushRoutine) {
                DeviceCloseNotify[Index] = NULL;
                Status = ESUCCESS;

                break;
            }                
        }
    }

    return Status;
}


#endif // CACHE_DEVINFO


ARC_STATUS
BlIoInitialize (
    VOID
    )

/*++

Routine Description:

    This routine initializes the file table used by the OS loader and
    initializes the boot loader filesystems.

Arguments:

    None.

Return Value:

    ESUCCESS is returned if the initialization is successful. Otherwise,
    return an unsuccessful status.

--*/

{

    ULONG Index;
    ARC_STATUS Status;

#ifdef CACHE_DEVINFO

    RtlZeroMemory(DeviceCloseNotify, sizeof(DeviceCloseNotify));
    
#endif

    //
    // Initialize the file table.
    //
    for (Index = 0; Index < BL_FILE_TABLE_SIZE; Index += 1) {
        BlFileTable[Index].Flags.Open = 0;
        BlFileTable[Index].StructureContext = NULL;

#ifdef CACHE_DEVINFO
        DeviceFSCache[Index].DeviceId = -1;
        DeviceFSCache[Index].Context = NULL;
        DeviceFSCache[Index].DevMethods = NULL;
#endif // for CACHE_DEVINFO       
    }

    if((Status = NetInitialize()) != ESUCCESS) {
        return Status;
    }

    if((Status = FatInitialize()) != ESUCCESS) {
        return Status;
    }

    if((Status = NtfsInitialize()) != ESUCCESS) {
        return Status;
    }

#ifndef DONT_USE_UDF
    if((Status = UDFSInitialize()) != ESUCCESS) {
        return Status;
    }
#endif

    if((Status = CdfsInitialize()) != ESUCCESS) {
        return Status;
    }

    return ESUCCESS;
}


PBOOTFS_INFO
BlGetFsInfo(
    IN ULONG DeviceId
    )

/*++

Routine Description:

    Returns filesystem information for the filesystem on the specified device

Arguments:

    FileId - Supplies the file table index of the device

Return Value:

    PBOOTFS_INFO - Pointer to the BOOTFS_INFO structure for the filesystem

    NULL - unknown filesystem

--*/

{
    FS_STRUCTURE_CONTEXT FsStructure;
    PBL_DEVICE_ENTRY_TABLE Table;

    if ((Table = IsNetFileStructure(DeviceId, &FsStructure)) != NULL) {
        return(Table->BootFsInfo);
    }

    if ((Table = IsFatFileStructure(DeviceId, &FsStructure)) != NULL) {
        return(Table->BootFsInfo);
    }

    if ((Table = IsNtfsFileStructure(DeviceId, &FsStructure)) != NULL) {
        return(Table->BootFsInfo);
    }

    if ((Table = IsCdfsFileStructure(DeviceId, &FsStructure)) != NULL) {
        return(Table->BootFsInfo);
    }

    return(NULL);
}

ARC_STATUS
BlClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    This function closes a file or a device that is open.

Arguments:

    FileId - Supplies the file table index.

Return Value:

    If the specified file is open, then a close is attempted and
    the status of the operation is returned. Otherwise, return an
    unsuccessful status.

--*/

{
    //
    // If the file is open, then attempt to close it. Otherwise return an
    // access error.
    //

    if (BlFileTable[FileId].Flags.Open == 1) {

        return (BlFileTable[FileId].DeviceEntryTable->Close)(FileId);

    } else {
        return EACCES;
    }
}

ARC_STATUS
BlMount (
    IN PCHAR MountPath,
    IN MOUNT_OPERATION Operation
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    UNREFERENCED_PARAMETER(MountPath);
    UNREFERENCED_PARAMETER(Operation);

    return ESUCCESS;
}


ARC_STATUS
_BlOpen (
    IN ULONG DeviceId,
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    This function opens a file on the specified device. The type of file
    system is automatically recognized.

Arguments:

    DeviceId - Supplies the file table index of the device.

    OpenPath - Supplies a pointer to the name of the file to be opened.

    OpenMode - Supplies the mode of the open.

    FileId - Supplies a pointer to a variable that receives the file
        table index of the open file.

Return Value:

    If a free file table entry is available and the file structure on
    the specified device is recognized, then an open is attempted and
    the status of the operation is returned. Otherwise, return an
    unsuccessful status.

--*/

{
    ULONG Index;
    FS_STRUCTURE_CONTEXT FsStructureTemp;
    PFS_STRUCTURE_CONTEXT FsStructure;
    ULONG ContextSize;
    ARC_STATUS Status;

#ifdef CACHE_DEVINFO

    ULONG   CacheIndex;

    for (CacheIndex = 0; CacheIndex < BL_FILE_TABLE_SIZE; CacheIndex++) {
      if (DeviceFSCache[CacheIndex].DeviceId == DeviceId){
        break;
      }
    }

      
#endif // for CACHE_DEVINFO 
        
    //
    // Search for a free file table entry.
    //
    for (Index = 0; Index < BL_FILE_TABLE_SIZE; Index += 1) {
      if (BlFileTable[Index].Flags.Open == 0) {     
#ifdef CACHE_DEVINFO        
        if (CacheIndex >= BL_FILE_TABLE_SIZE) {
#endif // for CACHE_DEVINFO

          //
          // Attempt to recognize the file system on the specified
          // device. If no one recognizes it then return an unsuccessful
          // status.
          //
          if ((BlFileTable[Index].DeviceEntryTable =
                                  IsNetFileStructure(DeviceId, &FsStructureTemp)) != NULL) {
              ContextSize = sizeof(NET_STRUCTURE_CONTEXT);

          } else if ((BlFileTable[Index].DeviceEntryTable =
                                  IsFatFileStructure(DeviceId, &FsStructureTemp)) != NULL) {
              ContextSize = sizeof(FAT_STRUCTURE_CONTEXT);

            } else if ((BlFileTable[Index].DeviceEntryTable =
                                    IsNtfsFileStructure(DeviceId, &FsStructureTemp)) != NULL) {
                ContextSize = sizeof(NTFS_STRUCTURE_CONTEXT);
#ifndef DONT_USE_UDF
          } else if ((BlFileTable[Index].DeviceEntryTable =
                                  IsUDFSFileStructure(DeviceId, &FsStructureTemp)) != NULL) {
              ContextSize = sizeof(UDFS_STRUCTURE_CONTEXT);
#endif                
#if defined(ELTORITO)
          //
          // This must go before the check for Cdfs; otherwise Cdfs will be detected.
          // Since BIOS calls already set up to use EDDS, reads will succeed, and checks
          // against ISO will succeed.  We check El Torito-specific fields here as well as ISO
          //
          } else if ((BlFileTable[Index].DeviceEntryTable =
                                  IsEtfsFileStructure(DeviceId, &FsStructureTemp)) != NULL) {
              ContextSize = sizeof(ETFS_STRUCTURE_CONTEXT);
#endif
          } else if ((BlFileTable[Index].DeviceEntryTable =
                                  IsCdfsFileStructure(DeviceId, &FsStructureTemp)) != NULL) {
              ContextSize = sizeof(CDFS_STRUCTURE_CONTEXT);

          } else {
              return EACCES;
          }


#ifndef CACHE_DEVINFO

          //
          // Cut down on the amount of heap we use by attempting to reuse
          // the fs structure context instead of always allocating a
          // new one. The NTFS structure context is over 4K; the FAT one
          // is almost 2K. In the setup case we're loading dozens of files.
          // Add in compression, where diamond may open each file multiple
          // times, and we waste a lot of heap.
          //
          if(BlFileTable[Index].StructureContext == NULL) {
              BlFileTable[Index].StructureContext = BlAllocateHeap(sizeof(FS_STRUCTURE_CONTEXT));
              if(BlFileTable[Index].StructureContext == NULL) {
                  return ENOMEM;
              }

              RtlZeroMemory(BlFileTable[Index].StructureContext, sizeof(FS_STRUCTURE_CONTEXT));
          }
          
          RtlCopyMemory(
              BlFileTable[Index].StructureContext,
              &FsStructureTemp,
              ContextSize
              );

#else
          //
          // save the collected info in cache for future use
          //
          for (CacheIndex = 0; CacheIndex < BL_FILE_TABLE_SIZE; CacheIndex++) {
            if (DeviceFSCache[CacheIndex].DeviceId == -1){
              PVOID Context = DeviceFSCache[CacheIndex].Context;
              
              DeviceFSCache[CacheIndex].DeviceId = DeviceId;
                        
              //
              // Cut down on the amount of heap we use by attempting to reuse
              // the fs structure context instead of always allocating a
              // new one. The NTFS structure context is over 4K; the FAT one
              // is almost 2K. In the setup case we're loading dozens of files.
              // Add in compression, where diamond may open each file multiple
              // times, and we waste a lot of heap.
              //
              if(Context == NULL) {
                Context = BlAllocateHeap(sizeof(FS_STRUCTURE_CONTEXT));

                if(Context == NULL) {
                    DeviceFSCache[CacheIndex].DeviceId = -1;
                    return ENOMEM;
                }

                RtlZeroMemory(Context, sizeof(FS_STRUCTURE_CONTEXT));
                DeviceFSCache[CacheIndex].Context = Context;
              }
              
              RtlCopyMemory(Context,
                            &FsStructureTemp, 
                            ContextSize);
              
              BlFileTable[Index].StructureContext = Context;              

              //
              // save the device table from the filetable entry
              //
              DeviceFSCache[CacheIndex].DevMethods = BlFileTable[Index].DeviceEntryTable;                
                        
              break;
            }
          }

          if (CacheIndex >= BL_FILE_TABLE_SIZE)
            return ENOSPC;

        } else {
#if 0
          {
            char Msg[128] = {0};

            BlPositionCursor(1, 5);
            sprintf(Msg,
                "Using %d cached info %p, %p for device %d, %s",
                CacheIndex,
                DeviceFSCache[CacheIndex].Context,
                DeviceFSCache[CacheIndex].DevMethods,
                DeviceFSCache[CacheIndex].DeviceId,
                OpenPath);

            BlPrint("                                                        ");
            BlPositionCursor(1, 5);
            BlPrint(Msg);
          }
#endif          
          //
          // Reuse the already cached entry
          //
          BlFileTable[Index].DeviceEntryTable = DeviceFSCache[CacheIndex].DevMethods;
          BlFileTable[Index].StructureContext = DeviceFSCache[CacheIndex].Context;
        }                 

#endif  // for ! CACHE_DEVINFO

        //
        // Someone has mounted the volume so now attempt to open the file.
        //
        *FileId = Index;
        BlFileTable[Index].DeviceId = DeviceId;
        

        Status = EBADF;
#if DBG
        //
        // Check and see if a user wants to replace this binary
        // via a transfer through the kernel debugger.  If this
        // fails just continue on with the existing file.
        //
        if( BdDebuggerEnabled ) {
    
            Status = BdPullRemoteFile( OpenPath,
                                       FILE_ATTRIBUTE_NORMAL,
                                       FILE_OVERWRITE_IF,
                                       FILE_SYNCHRONOUS_IO_NONALERT,
                                       *FileId );
            if( Status == ESUCCESS ) {
                DbgPrint( "BlLoadImageEx: Pulled %s from Kernel Debugger\r\n", OpenPath );
            }
        }
#endif


        if( Status != ESUCCESS ) {
            Status = (BlFileTable[Index].DeviceEntryTable->Open)(OpenPath,
                                                                 OpenMode,
                                                                 FileId);
        }

        return(Status);
      }
    }

    //
    // No free file table entry could be found.
    //

    return EACCES;
}

ARC_STATUS
BlOpen (
    IN ULONG DeviceId,
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Wrapper routine for BlOpen that attempts to locate the compressed
    form of a filename before trying to locate the filename itself.

    Callers need not know or care that a file x.exe actually exists
    as a compressed file x.ex_. If the file is being opened for
    read-only access and the decompressor indicates that it wants
    to try locating the compressed form of the file, we transparently
    locate that one instead of the one requested.

Arguments:

    Same as _BlOpen().

Return Value:

    Same as _BlOpen().

--*/

{
    CHAR CompressedName[256];
    ARC_STATUS Status;
   
    if((OpenMode == ArcOpenReadOnly) && DecompGenerateCompressedName(OpenPath,CompressedName)) {
        //
        // Attempt to locate the compressed form of the filename.
        //
        Status = _BlOpen(DeviceId,CompressedName,OpenMode,FileId);
        if(Status == ESUCCESS) {

            Status = DecompPrepareToReadCompressedFile(CompressedName,*FileId);

            if(Status == (ARC_STATUS)(-1)) {
                //
                // This is a special status indicating that the file is not
                // to be processed for decompression. This typically happens
                // when the decompressor opens the file to read the compressed
                // data out of it.
                //
                Status = ESUCCESS;
#if DBG                
                BlFilesOpened++;
#endif                
            }

            return(Status);
        }
    }

    Status = (_BlOpen(DeviceId,OpenPath,OpenMode,FileId));

#if DBG
    if (Status == ESUCCESS)
        BlFilesOpened++;
#endif      

    return Status;
}

ARC_STATUS
BlRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    This function reads from a file or a device that is open.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that receives the data
        read.

    Length - Supplies the number of bytes that are to be read.

    Count - Supplies a pointer to a variable that receives the number of
        bytes actually transfered.

Return Value:

    If the specified file is open for read, then a read is attempted
    and the status of the operation is returned. Otherwise, return an
    unsuccessful status.

--*/

{

    //
    // If the file is open for read, then attempt to read from it. Otherwise
    // return an access error.
    //

    if ((BlFileTable[FileId].Flags.Open == 1) &&
        (BlFileTable[FileId].Flags.Read == 1)) {
        return (BlFileTable[FileId].DeviceEntryTable->Read)(FileId,
                                                            Buffer,
                                                            Length,
                                                            Count);

    } else {
        return EACCES;
    }
}

ARC_STATUS
BlReadAtOffset(
    IN ULONG FileId,
    IN ULONG Offset,
    IN ULONG Length,
    OUT PVOID Data
    )
/*++

Routine Description:

    This routine seeks to the proper place in FileId and extracts Length bytes of data into
    Data.

Arguments:

    FileId - Supplies the file id where read operations are to be performed.

    Offset - The absolute byte offset to start reading at.

    Length - The number of bytes to read.

    Data - Buffer to hold the read results.

--*/
{
    ARC_STATUS Status;
    LARGE_INTEGER LargeOffset;
    ULONG Count;

    LargeOffset.HighPart = 0;
    LargeOffset.LowPart = Offset;
    Status = BlSeek(FileId, &LargeOffset, SeekAbsolute);

    if (Status != ESUCCESS) {
        return Status;
    }

    Status = BlRead(FileId, Data, Length, &Count);

    if ((Status == ESUCCESS) && (Count != Length)) {
        return EINVAL;
    }

    return Status;
}


ARC_STATUS
BlGetReadStatus (
    IN ULONG FileId
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    return ESUCCESS;
}

ARC_STATUS
BlSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:


Arguments:


Return Value:

    If the specified file is open, then a seek is attempted and
    the status of the operation is returned. Otherwise, return an
    unsuccessful status.

--*/

{

    //
    // If the file is open, then attempt to seek on it. Otherwise return an
    // access error.
    //

    if (BlFileTable[FileId].Flags.Open == 1) {
        return (BlFileTable[FileId].DeviceEntryTable->Seek)(FileId,
                                                            Offset,
                                                            SeekMode);

    } else {
        return EACCES;
    }
}

ARC_STATUS
BlWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    //
    // If the file is open for write, then attempt to write to it. Otherwise
    // return an access error.
    //

    if ((BlFileTable[FileId].Flags.Open == 1) &&
        (BlFileTable[FileId].Flags.Write == 1)) {
        return (BlFileTable[FileId].DeviceEntryTable->Write)(FileId,
                                                             Buffer,
                                                             Length,
                                                             Count);

    } else {
        return EACCES;
    }
}

ARC_STATUS
BlGetFileInformation (
    IN ULONG FileId,
    IN PFILE_INFORMATION FileInformation
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    //
    // If the file is open, then attempt to get file information. Otherwise
    // return an access error.
    //

    if (BlFileTable[FileId].Flags.Open == 1) {
        return (BlFileTable[FileId].DeviceEntryTable->GetFileInformation)(FileId,
                                                                          FileInformation);

    } else {
        return EACCES;
    }
}

ARC_STATUS
BlSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    //
    // If the file is open, then attempt to Set file information. Otherwise
    // return an access error.
    //

    if (BlFileTable[FileId].Flags.Open == 1) {
        return (BlFileTable[FileId].DeviceEntryTable->SetFileInformation)(FileId,
                                                                          AttributeFlags,
                                                                          AttributeMask);

    } else {
        return EACCES;
    }
}


ARC_STATUS
BlRename(
    IN ULONG FileId,
    IN PCHAR NewName
    )

/*++

Routine Description:

    Rename an open file or directory.

Arguments:

    FileId - supplies a handle to an open file or directory.  The file
        need not be open for write access.

    NewName - New name to give the file or directory (filename part only).

Return Value:

    Status indicating result of the operation.

--*/

{
    if(BlFileTable[FileId].Flags.Open == 1) {
        return(BlFileTable[FileId].DeviceEntryTable->Rename(FileId,
                                                            NewName
                                                           )
              );
    } else {
        return(EACCES);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\blload.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    blload.c

Abstract:

    This module provides common code for loading things like drivers, NLS files, registry.
    Used by both the osloader and the setupldr.

Author:

    John Vert (jvert) 8-Oct-1993

Environment:

    ARC environment

Revision History:

--*/

#include "bldr.h"
#include "stdio.h"
#include "stdlib.h"
#include "vmode.h"

#ifdef EFI
#include "bootefi.h"
#endif

//
// progress bar message ids
//
// HIBER_UI_BAR_ELEMENT    0x00002CF9L
// BLDR_UI_BAR_BACKGROUND  0x00002CFAL
//
ULONG BlProgBarFrontMsgID = 0x00002CF9L;
ULONG BlProgBarBackMsgID = 0x00002CFAL;

//
// number of files loaded (for progress bar)
//
int BlNumFilesLoaded = 0;
int BlNumProgressBarFilesLoaded = 0;

//
// maximum number of files to load (for progress bar)
//
int BlMaxFilesToLoad = 80;
int BlProgressBarFilesToLoad = 0;

#if defined(_X86_)
ULONG BlProgressBarShowTimeOut = 3;
#else
ULONG BlProgressBarShowTimeOut = 0;
#endif

//
// The progress bar width (in characters)
//
#define PROGRESS_BAR_WIDTH  80

//
// The progress bar characters
//
#define DEFAULT_FRONT_CHAR  0xDB    // block cursor
#define DEFAULT_BACK_CHAR   ' '

USHORT BlFrontChar = DEFAULT_FRONT_CHAR;
USHORT BlBackChar = DEFAULT_BACK_CHAR;

//
// defines whether to draw the progress bar or not
//
#if DBG

BOOLEAN BlOutputDots=FALSE;
//BOOLEAN BlOutputDots=TRUE;

#else

BOOLEAN BlOutputDots=TRUE;

#endif

//
// To show the progress bar or not
//
BOOLEAN BlShowProgressBar = FALSE;
ULONG   BlStartTime = 0L;

ARC_STATUS
BlLoadSystemHiveLog(
    IN  ULONG       DeviceId,
    IN  PCHAR       DeviceName,
    IN  PCHAR       DirectoryPath,
    IN  PCHAR       HiveName,
    OUT PULONG_PTR  LogData
    )

/*++

Routine Description:

    Loads the registry log file for the system hive from <BootDirectory>\config\system.LOG.

    Allocates a memory descriptor to hold the hive image, reads the hive
    image into this descriptor,

Arguments:

    DeviceId - Supplies the file id of the device the system tree is on.

    DeviceName - Supplies the name of the device the system tree is on.

    DirectoryPath - Supplies a pointer to the zero-terminated directory path
        of the root of the NT tree.

    HiveName - Supplies the name of the system hive ("SYSTEM.LOG")

    LogData - flat image of the log file

    LogLength - length of the data in LogData

Return Value:

    TRUE - system hive successfully loaded.

    FALSE - system hive could not be loaded.

--*/

{
    CHAR RegistryName[256];
    ULONG FileId;
    ARC_STATUS Status;
    FILE_INFORMATION FileInformation;
    ULONG FileSize;
    ULONG ActualBase;
    ULONG_PTR LocalPointer;
    LARGE_INTEGER SeekValue;
    ULONG Count;
    PCHAR FailReason;

    //
    // Create the full filename for the SYSTEM hive.
    //

    strcpy(&RegistryName[0], DirectoryPath);
    strcat(&RegistryName[0], HiveName);
    BlOutputLoadMessage(DeviceName, &RegistryName[0], NULL);

    Status = BlOpen(DeviceId, &RegistryName[0], ArcOpenReadOnly, &FileId);
    if (Status != ESUCCESS) {
        FailReason = "BlOpen";
        goto HiveLoadFailed;
    }

    BlUpdateBootStatus();

    //
    // Determine the length of the registry file
    //
    Status = BlGetFileInformation(FileId, &FileInformation);

    if (Status != ESUCCESS) {
        BlClose(FileId);
        FailReason = "BlGetFileInformation";
        goto HiveLoadFailed;
    }

    FileSize = FileInformation.EndingAddress.LowPart;
    if (FileSize == 0) {
        Status = EINVAL;
        BlClose(FileId);
        FailReason = "FileSize == 0";
        goto HiveLoadFailed;
    }

    //
    // Round up to a page boundary, allocate a memory descriptor, fill in the
    // registry fields in the loader parameter block, and read the registry
    // data into memory.
    //

    Status = BlAllocateDescriptor(LoaderRegistryData,
                                  0x0,
                                  (FileSize + PAGE_SIZE - 1) >> PAGE_SHIFT,
                                  &ActualBase);

    if (Status != ESUCCESS) {
        BlClose(FileId);
        FailReason = "BlAllocateDescriptor";
        goto HiveLoadFailed;
    }

    *LogData = LocalPointer = KSEG0_BASE | (ActualBase << PAGE_SHIFT);

    //
    // Read the SYSTEM hive into the allocated memory.
    //

    SeekValue.QuadPart = 0;
    Status = BlSeek(FileId, &SeekValue, SeekAbsolute);
    if (Status != ESUCCESS) {
        BlClose(FileId);
        FailReason = "BlSeek";
        BlFreeDescriptor(ActualBase);
        goto HiveLoadFailed;
    }

    Status = BlRead(FileId, (PVOID)LocalPointer, FileSize, &Count);
    BlClose(FileId);
    if (Status != ESUCCESS) {
        FailReason = "BlRead";
        BlFreeDescriptor(ActualBase);
        goto HiveLoadFailed;
    }

HiveLoadFailed:
    return Status;
}

ARC_STATUS
BlLoadSystemHive(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PCHAR HiveName
    )

/*++

Routine Description:

    Loads the registry SYSTEM hive from <BootDirectory>\config\system.

    Allocates a memory descriptor to hold the hive image, reads the hive
    image into this descriptor, and updates the registry pointers in the
    LoaderBlock.

Arguments:

    DeviceId - Supplies the file id of the device the system tree is on.

    DeviceName - Supplies the name of the device the system tree is on.

    DirectoryPath - Supplies a pointer to the zero-terminated directory path
        of the root of the NT tree.

    HiveName - Supplies the name of the system hive ("SYSTEM" or "SYSTEM.ALT")

Return Value:

    TRUE - system hive successfully loaded.

    FALSE - system hive could not be loaded.

--*/

{
    CHAR RegistryName[256];
    ULONG FileId;
    ARC_STATUS Status;
    FILE_INFORMATION FileInformation;
    ULONG FileSize;
    ULONG ActualBase;
    ULONG_PTR LocalPointer;
    LARGE_INTEGER SeekValue;
    ULONG Count;
    PCHAR FailReason;

    //
    // Create the full filename for the SYSTEM hive.
    //

    strcpy(&RegistryName[0], DirectoryPath);
    strcat(&RegistryName[0], HiveName);
    BlOutputLoadMessage(DeviceName, &RegistryName[0], NULL);

    Status = BlOpen(DeviceId, &RegistryName[0], ArcOpenReadOnly, &FileId);
    if (Status != ESUCCESS) {
        FailReason = "BlOpen";
        goto HiveLoadFailed;
    }

    BlUpdateBootStatus();

    //
    // Determine the length of the registry file
    //
    Status = BlGetFileInformation(FileId, &FileInformation);

    if (Status != ESUCCESS) {
        BlClose(FileId);
        FailReason = "BlGetFileInformation";
        goto HiveLoadFailed;
    }

    FileSize = FileInformation.EndingAddress.LowPart;
    if (FileSize == 0) {
        Status = EINVAL;
        BlClose(FileId);
        FailReason = "FileSize == 0";
        goto HiveLoadFailed;
    }

    //
    // Round up to a page boundary, allocate a memory descriptor, fill in the
    // registry fields in the loader parameter block, and read the registry
    // data into memory.
    //

    Status = BlAllocateDescriptor(LoaderRegistryData,
                                  0x0,
                                  (FileSize + PAGE_SIZE - 1) >> PAGE_SHIFT,
                                  &ActualBase);

    if (Status != ESUCCESS) {
        BlClose(FileId);
        FailReason = "BlAllocateDescriptor";
        goto HiveLoadFailed;
    }

    LocalPointer = KSEG0_BASE | (ActualBase << PAGE_SHIFT);
    BlLoaderBlock->RegistryLength = FileSize;
    BlLoaderBlock->RegistryBase = (PVOID)(LocalPointer + BlVirtualBias);

    //
    // Read the SYSTEM hive into the allocated memory.
    //

    SeekValue.QuadPart = 0;
    Status = BlSeek(FileId, &SeekValue, SeekAbsolute);
    if (Status != ESUCCESS) {
        BlClose(FileId);
        FailReason = "BlSeek";
        goto HiveLoadFailed;
    }

    Status = BlRead(FileId, (PVOID)LocalPointer, FileSize, &Count);
    BlClose(FileId);
    if (Status != ESUCCESS) {
        FailReason = "BlRead";
        goto HiveLoadFailed;
    }

HiveLoadFailed:
    return Status;
}

ARC_STATUS
BlLoadNLSData(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PUNICODE_STRING AnsiCodepage,
    IN PUNICODE_STRING OemCodepage,
    IN PUNICODE_STRING LanguageTable,
    OUT PCHAR BadFileName
    )

/*++

Routine Description:

    This routine loads all the NLS data files into one contiguous block of
    memory.

Arguments:

    DeviceId - Supplies the file id of the device the system tree is on.

    DeviceName - Supplies the name of the device the system tree is on.

    DirectoryPath - Supplies a pointer to the zero-terminated path
        of the directory containing the NLS files.

    AnsiCodePage - Supplies the filename of the ANSI codepage data file.

    OemCodePage - Supplies the filename of the OEM codepage data file.

    LanguageTable - Supplies the filename of the Unicode language case table.

    BadFileName - Returns the filename of the NLS file that was missing
        or invalid.  This will not be filled in if ESUCCESS is returned.

Return Value:

    ESUCCESS is returned if the NLS data was successfully loaded.
        Otherwise, an unsuccessful status is returned.

--*/

{
    CHAR Filename[129];
    ULONG AnsiFileId;
    ULONG OemFileId;
    ULONG LanguageFileId;
    ARC_STATUS Status;
    FILE_INFORMATION FileInformation;
    ULONG AnsiFileSize;
    ULONG OemFileSize;
    ULONG LanguageFileSize;
    ULONG TotalSize;
    ULONG ActualBase;
    ULONG_PTR LocalPointer;
    LARGE_INTEGER SeekValue;
    ULONG Count;
    BOOLEAN OemIsSameAsAnsi = FALSE;

    //
    // Under the Japanese version of NT, ANSI code page and OEM codepage
    // is same. In this case, we share the same data to save and memory.
    //

    if ( (AnsiCodepage->Length == OemCodepage->Length) &&
         (_wcsnicmp(AnsiCodepage->Buffer,
                   OemCodepage->Buffer,
                   AnsiCodepage->Length) == 0)) {

        OemIsSameAsAnsi = TRUE;
    }

    //
    // Open the ANSI data file
    //

    sprintf(Filename, "%s%wZ", DirectoryPath,AnsiCodepage);
    BlOutputLoadMessage(DeviceName, Filename, NULL);

    Status = BlOpen(DeviceId, Filename, ArcOpenReadOnly, &AnsiFileId);
    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    BlUpdateBootStatus();

    Status = BlGetFileInformation(AnsiFileId, &FileInformation);
    BlClose(AnsiFileId);
    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    AnsiFileSize = FileInformation.EndingAddress.LowPart;

    //
    // Open the OEM data file
    //

    if (OemIsSameAsAnsi) {
        OemFileSize = 0;

    } else {
        sprintf(Filename, "%s%wZ", DirectoryPath, OemCodepage);
        BlOutputLoadMessage(DeviceName, Filename, NULL);
        Status = BlOpen(DeviceId, Filename, ArcOpenReadOnly, &OemFileId);

        if (Status != ESUCCESS) {
            goto NlsLoadFailed;
        }

        BlUpdateBootStatus();

        Status = BlGetFileInformation(OemFileId, &FileInformation);
        BlClose(OemFileId);
        if (Status != ESUCCESS) {
            goto NlsLoadFailed;
        }

        OemFileSize = FileInformation.EndingAddress.LowPart;
    }

    //
    // Open the language codepage file
    //

    sprintf(Filename, "%s%wZ", DirectoryPath,LanguageTable);
    BlOutputLoadMessage(DeviceName, Filename, NULL);
    Status = BlOpen(DeviceId, Filename, ArcOpenReadOnly, &LanguageFileId);

    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    BlUpdateBootStatus();

    Status = BlGetFileInformation(LanguageFileId, &FileInformation);
    BlClose(LanguageFileId);
    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    LanguageFileSize = FileInformation.EndingAddress.LowPart;

    //
    // Calculate the total size of the descriptor needed.  We want each
    // data file to start on a page boundary, so round up each size to
    // page granularity.
    //

    TotalSize = (ULONG)(ROUND_TO_PAGES(AnsiFileSize) +
                (OemIsSameAsAnsi ? 0 : ROUND_TO_PAGES(OemFileSize)) +
                ROUND_TO_PAGES(LanguageFileSize));

    Status = BlAllocateDescriptor(LoaderNlsData,
                                  0x0,
                                  TotalSize >> PAGE_SHIFT,
                                  &ActualBase);

    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    LocalPointer = KSEG0_BASE | (ActualBase << PAGE_SHIFT);

    //
    // Read NLS data into memory.
    //
    // Open and read the ANSI file.
    //

    sprintf(Filename, "%s%wZ", DirectoryPath, AnsiCodepage);
    Status = BlOpen(DeviceId, Filename, ArcOpenReadOnly, &AnsiFileId);
    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    SeekValue.QuadPart = 0;
    Status = BlSeek(AnsiFileId, &SeekValue, SeekAbsolute);
    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    Status = BlRead(AnsiFileId,
                    (PVOID)LocalPointer,
                    AnsiFileSize,
                    &Count);

    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    BlLoaderBlock->NlsData->AnsiCodePageData = (PVOID)(LocalPointer + BlVirtualBias);
    LocalPointer += ROUND_TO_PAGES(AnsiFileSize);
    BlClose(AnsiFileId);

    //
    // If the OEM file is the same as the ANSI file, then define the OEM file as
    // the ANSI file. Otherwise, open and read the OEM file.
    //

    if(OemIsSameAsAnsi) {
        BlLoaderBlock->NlsData->OemCodePageData = BlLoaderBlock->NlsData->AnsiCodePageData;

    } else {
        sprintf(Filename, "%s%wZ", DirectoryPath, OemCodepage);
        Status = BlOpen(DeviceId, Filename, ArcOpenReadOnly, &OemFileId);
        if (Status != ESUCCESS) {
            goto NlsLoadFailed;
        }

        SeekValue.QuadPart = 0;
        Status = BlSeek(OemFileId, &SeekValue, SeekAbsolute);
        if (Status != ESUCCESS) {
            goto NlsLoadFailed;
        }

        Status = BlRead(OemFileId,
                        (PVOID)LocalPointer,
                        OemFileSize,
                        &Count);

        if (Status != ESUCCESS) {
            goto NlsLoadFailed;
        }

        BlLoaderBlock->NlsData->OemCodePageData = (PVOID)(LocalPointer + BlVirtualBias);
        LocalPointer += ROUND_TO_PAGES(OemFileSize);
        BlClose(OemFileId);
    }

    //
    // Open and read Language file.
    //

    sprintf(Filename, "%s%wZ", DirectoryPath,LanguageTable);
    Status = BlOpen(DeviceId, Filename, ArcOpenReadOnly, &LanguageFileId);
    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    SeekValue.QuadPart = 0;
    Status = BlSeek(LanguageFileId, &SeekValue, SeekAbsolute);
    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    Status = BlRead(LanguageFileId,
                    (PVOID)LocalPointer,
                    LanguageFileSize,
                    &Count);

    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    BlLoaderBlock->NlsData->UnicodeCaseTableData = (PVOID)(LocalPointer + BlVirtualBias);
    BlClose(LanguageFileId);
    return(ESUCCESS);

NlsLoadFailed:
    strcpy(BadFileName, Filename);
    return(Status);
}

ARC_STATUS
BlLoadOemHalFont(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PUNICODE_STRING OemHalFont,
    OUT PCHAR BadFileName
    )

/*++

Routine Description:

    This routine loads the OEM font file for use the HAL display string
    function.

Arguments:

    DeviceId - Supplies the file id of the device the system tree is on.

    DeviceName - Supplies the name of the device the system tree is on.

    DirectoryPath - Supplies a pointer to the directory path of the root
        of the NT tree.

    Fontfile - Supplies the filename of the OEM font file.

    BadFileName - Returns the filename of the OEM font file that was missing
        or invalid.

Return Value:

    ESUCCESS is returned if the OEM font was successfully loaded. Otherwise,
    an unsuccessful status is returned and the bad file name is filled.

--*/

{

    PVOID FileBuffer;
    ULONG Count;
    PIMAGE_DOS_HEADER DosHeader;
    ULONG FileId;
    FILE_INFORMATION FileInformation;
    CHAR Filename[129];
    ULONG FileSize;
    ARC_STATUS Status;
    POEM_FONT_FILE_HEADER FontHeader;
    PIMAGE_OS2_HEADER Os2Header;
    ULONG ScaleFactor;
    RESOURCE_TYPE_INFORMATION UNALIGNED *TableAddress;
    RESOURCE_TYPE_INFORMATION UNALIGNED *TableEnd;
    RESOURCE_NAME_INFORMATION UNALIGNED *TableName;

    //
    // Open the OEM font file.
    //

    BlLoaderBlock->OemFontFile = NULL;
    sprintf(&Filename[0], "%s%wZ", DirectoryPath, OemHalFont);
    BlOutputLoadMessage(DeviceName, &Filename[0], NULL);
    Status = BlOpen(DeviceId, &Filename[0], ArcOpenReadOnly, &FileId);
    if (Status != ESUCCESS) {
        goto OemLoadExit1;
    }

    BlUpdateBootStatus();

    //
    // Get the size of the font file and allocate a buffer from the heap
    // to hold the font file. Typically this file is about 4kb in length.
    //

    Status = BlGetFileInformation(FileId, &FileInformation);
    if (Status != ESUCCESS) {
        goto OemLoadExit;
    }

    FileSize = FileInformation.EndingAddress.LowPart;
    FileBuffer = BlAllocateHeap(FileSize + BlDcacheFillSize - 1);
    if (FileBuffer == NULL) {
        Status = ENOMEM;
        goto OemLoadExit;
    }

    //
    // Round the file buffer address up to a cache line boundary and read
    // the file into memory.
    //

    FileBuffer = (PVOID)((ULONG_PTR)FileBuffer + BlDcacheFillSize - 1);
    FileBuffer = (PVOID)((ULONG_PTR)FileBuffer & ~((ULONG_PTR)BlDcacheFillSize - 1));
    Status = BlRead(FileId,
                    FileBuffer,
                    FileSize,
                    &Count);

    if (Status != ESUCCESS) {
        goto OemLoadExit;
    }

    //
    // Attempt to recognize the file as either a .fon or .fnt file.
    //
    // Check if the file has a DOS header or a font file header. If the
    // file has a font file header, then it is a .fnt file. Otherwise,
    // it must be checked for an OS/2 executable with a font resource.
    //

    Status = EBADF;
    DosHeader = (PIMAGE_DOS_HEADER)FileBuffer;
    if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE) {

        //
        // Check if the file has a font file header.
        //

        FontHeader = (POEM_FONT_FILE_HEADER)FileBuffer;
        if ((FontHeader->Version != OEM_FONT_VERSION) ||
            (FontHeader->Type != OEM_FONT_TYPE) ||
            (FontHeader->Italic != OEM_FONT_ITALIC) ||
            (FontHeader->Underline != OEM_FONT_UNDERLINE) ||
            (FontHeader->StrikeOut != OEM_FONT_STRIKEOUT) ||
            (FontHeader->CharacterSet != OEM_FONT_CHARACTER_SET) ||
            (FontHeader->Family != OEM_FONT_FAMILY) ||
            (FontHeader->PixelWidth > 32)) {

            goto OemLoadExit;

        } else {
            BlLoaderBlock->OemFontFile = (PVOID)FontHeader;
            Status = ESUCCESS;
            goto OemLoadExit;
        }
    }

    //
    // Check if the file has an OS/2 header.
    //

    if ((FileSize < sizeof(IMAGE_DOS_HEADER)) || (FileSize < (ULONG)DosHeader->e_lfanew)) {
        goto OemLoadExit;
    }

    Os2Header = (PIMAGE_OS2_HEADER)((PUCHAR)DosHeader + DosHeader->e_lfanew);
    if (Os2Header->ne_magic != IMAGE_OS2_SIGNATURE) {
        goto OemLoadExit;
    }

    //
    // Check if the resource table exists.
    //

    if ((Os2Header->ne_restab - Os2Header->ne_rsrctab) == 0) {
        goto OemLoadExit;
    }

    //
    // Compute address of resource table and search the table for a font
    // resource.
    //

    TableAddress =
        (PRESOURCE_TYPE_INFORMATION)((PUCHAR)Os2Header + Os2Header->ne_rsrctab);

    TableEnd =
        (PRESOURCE_TYPE_INFORMATION)((PUCHAR)Os2Header + Os2Header->ne_restab);

    ScaleFactor = *((SHORT UNALIGNED *)TableAddress)++;
    while ((TableAddress < TableEnd) &&
           (TableAddress->Ident != 0) &&
           (TableAddress->Ident != FONT_RESOURCE)) {

        TableAddress =
                (PRESOURCE_TYPE_INFORMATION)((PUCHAR)(TableAddress + 1) +
                    (TableAddress->Number * sizeof(RESOURCE_NAME_INFORMATION)));
    }

    if ((TableAddress >= TableEnd) || (TableAddress->Ident != FONT_RESOURCE)) {
        goto OemLoadExit;
    }

    //
    // Compute address of resource name information and check if the resource
    // is within the file.
    //

    TableName = (PRESOURCE_NAME_INFORMATION)(TableAddress + 1);
    if (FileSize < ((TableName->Offset << ScaleFactor) + sizeof(OEM_FONT_FILE_HEADER))) {
        goto OemLoadExit;
    }

    //
    // Compute the address of the font file header and check if the header
    // contains correct information.
    //

    FontHeader = (POEM_FONT_FILE_HEADER)((PCHAR)FileBuffer +
                                            (TableName->Offset << ScaleFactor));

    if ((FontHeader->Version != OEM_FONT_VERSION) ||
        (FontHeader->Type != OEM_FONT_TYPE) ||
        (FontHeader->Italic != OEM_FONT_ITALIC) ||
        (FontHeader->Underline != OEM_FONT_UNDERLINE) ||
        (FontHeader->StrikeOut != OEM_FONT_STRIKEOUT) ||
        (FontHeader->CharacterSet != OEM_FONT_CHARACTER_SET) ||
        (FontHeader->PixelWidth > 32)) {
        goto OemLoadExit;

    } else {
        BlLoaderBlock->OemFontFile = (PVOID)FontHeader;
        Status = ESUCCESS;
        goto OemLoadExit;
    }

    //
    // Exit loading of the OEM font file.
    //

OemLoadExit:
    BlClose(FileId);
OemLoadExit1:
    strcpy(BadFileName,&Filename[0]);
    return(Status);
}


ARC_STATUS
BlLoadDeviceDriver(
    IN PPATH_SET               PathSet,
    IN PCHAR                   DriverName,
    IN PTCHAR                  DriverDescription OPTIONAL,
    IN ULONG                   DriverFlags,
    OUT PKLDR_DATA_TABLE_ENTRY *DriverDataTableEntry
    )

/*++

Routine Description:

    This routine loads the specified device driver and resolves all DLL
    references if the driver is not already loaded.

Arguments:

    PathSet - Describes all the various locations the driver could be present
        at.

    DriverName - Supplies a pointer to a zero terminated device driver
        name string.

    DriverDescription - Supplies an optional pointer to a zero terminated string
        to be displayed when loading the driver. If NULL, DriverName is used.

    DriverFlags - Supplies the driver flags that are to be set in the
        generated data table entry.

    DriverDataTableEntry - Receives a pointer to the data table entry
        created for the newly-loaded driver.

Return Value:

    ESUCCESS is returned if the specified driver is successfully loaded
    or it is already loaded. Otherwise, and unsuccessful status is
    returned.

--*/

{

    CHAR DllName[256];
    CHAR FullName[256];
    PVOID Base;
    ARC_STATUS Status;
    ULONG Index;
    PPATH_SOURCE PathSource;

    //
    // Generate the DLL name for the device driver.
    //

    strcpy(&DllName[0], DriverName);

    //
    // If the specified device driver is not already loaded, then load it.
    //

    if (BlCheckForLoadedDll(&DllName[0], DriverDataTableEntry) == FALSE) {

        //
        // Start walking our list of DevicePaths. If the list is
        // empty (bad caller!) we fail with ENOENT.
        //
        Status = ENOENT;
        for(Index=0; Index < PathSet->PathCount; Index++) {

            PathSource = &PathSet->Source[Index];

            //
            // Generate the full path name of device driver.
            //
            strcpy(&FullName[0], PathSource->DirectoryPath);
            strcat(&FullName[0], PathSet->PathOffset);
            strcat(&FullName[0], DriverName);

            //
            // Try to load it.
            //
            Status = BlLoadImage(PathSource->DeviceId,
                                 LoaderBootDriver,
                                 &FullName[0],
                                 TARGET_IMAGE,
                                 &Base);

            if (Status == ESUCCESS) {

                //
                // Print out the driver that loaded.
                //
                BlOutputLoadMessage((PCHAR) PathSource->DeviceName,
                                    &FullName[0],
                                    DriverDescription);

                break;
            }
        }

        if (Status != ESUCCESS) {
            return Status;
        }

        BlUpdateBootStatus();

        //
        // Generate a data table entry for the driver, then clear the entry
        // processed flag. The I/O initialization code calls each DLL in the
        // loaded module list that does not have its entry processed flag set.
        //
        // ISSUE - 2000/29/03 - ADRIAO: Existant namespace polution
        //     Instead of passing in DllName here, we should be passing in
        // AliasName\PathOffset\DriverName.
        //

        Status = BlAllocateDataTableEntry(&DllName[0],
                                          DriverName,
                                          Base,
                                          DriverDataTableEntry);

        if (Status != ESUCCESS) {
            return Status;
        }

        //
        // Set the flag LDRP_DRIVER_DEPENDENT_DLL so that BlScanImportDescriptorTable
        // will set the flag in the data table entries for the dlls that it creates.
        //
        (*DriverDataTableEntry)->Flags |= DriverFlags|LDRP_DRIVER_DEPENDENT_DLL;

        //
        // Scan the import table and load all the referenced DLLs.
        //
        // ISSUE - 2000/29/03 - ADRIAO: LDR memory
        //     This should probably be LoaderBootDriver. Per MikeG we are
        // leaving this alone for now.
        //
        Status = BlScanImportDescriptorTable(PathSet,
                                             *DriverDataTableEntry,
                                             LoaderHalCode);

        if (Status != ESUCCESS) {
            //
            // Remove the driver from the load order list.
            //
            RemoveEntryList(&(*DriverDataTableEntry)->InLoadOrderLinks);
            return Status;
        }
        //
        // Clear the flag here. This way we don't call DllInitialize for drivers.
        //
        (*DriverDataTableEntry)->Flags &= ~LDRP_DRIVER_DEPENDENT_DLL;

    }
    return ESUCCESS;
}

VOID
BlUpdateBootStatus(
    VOID
    )
/*++

Routine Description:

    Updates the boot status (like updating progress bar currently).
    Generally gets called after important files are loaded.

Arguments:

    None


Return Value:

    None

--*/

{
    BlNumFilesLoaded++;
    if (BlShowProgressBar)
        BlNumProgressBarFilesLoaded++;
    BlRedrawProgressBar();
}

VOID
BlRedrawProgressBar(
    VOID
    )
/*++

Routine Description:

    Redraws the progress bar (with the last percentage)

Arguments:

    None

Return Value:

    None

--*/
{
    if (!BlShowProgressBar) {
        ULONG EndTime = ArcGetRelativeTime();
        if ((BlProgressBarShowTimeOut == 0) ||
            ((EndTime - BlStartTime) > BlProgressBarShowTimeOut)) {
            BlShowProgressBar = TRUE;
            BlNumProgressBarFilesLoaded = 1;
            BlProgressBarFilesToLoad = BlMaxFilesToLoad - BlNumFilesLoaded;
        }
    }

    if (BlShowProgressBar && (BlProgressBarFilesToLoad>0)) {
            BlUpdateProgressBar((BlNumProgressBarFilesLoaded * 100) / BlProgressBarFilesToLoad);
    }
}

VOID
BlUpdateTxtProgressBar(
    ULONG fPercentage
    )
/*++

Routine Description:

    Draws the progress bar with the specified percentage value

Arguments:

    fPercentage : percentage the progress bar needs to show
    (Note : should have a value between  0 & 100 inclusive)

Return Value:

    None

--*/

{
    ULONG           lCount = 0;
    TCHAR           szMsg[PROGRESS_BAR_WIDTH * 2 + 2] = {0};
    int             iNumChars = 0;
    int             iNumBackChars = 0;
    _TUCHAR         szBarBackStr[PROGRESS_BAR_WIDTH * 2 + 2] = {0};
    _TUCHAR         szPrgBar[PROGRESS_BAR_WIDTH * 4 + 2] = {0};
    _PTUCHAR         szBarBack = 0;
    static ULONG    uRow = 0;
    static ULONG    uCol = 0;
    static ULONG    uBarWidth = PROGRESS_BAR_WIDTH;

    if (BlShowProgressBar && BlOutputDots) {
        // fix percentage value (if needed)
        if (fPercentage > 100)
            fPercentage = 100;

        // select the row where to display the progress bar
        if (uRow == 0)
            uRow = ScreenHeight - 2;

        // fix the start column
        if (uCol == 0) {
            if (PROGRESS_BAR_WIDTH >= ScreenWidth) {
                uCol = 1;
                uBarWidth = ScreenWidth;
            } else {
                uCol = (ScreenWidth - PROGRESS_BAR_WIDTH) / 2;
                uBarWidth = PROGRESS_BAR_WIDTH;
            }
        }

        iNumChars = (fPercentage * uBarWidth) / 100;
        iNumBackChars = uBarWidth - iNumChars;

        if (iNumChars) {
#ifdef EFI
            PTCHAR pMsg = szMsg;
            ULONG uNumChars = iNumChars;
            while (uNumChars--) {
                *pMsg++ = BlFrontChar;
            }
#else
            //
            // copy appropriately based on single / double byte character
            // each dbcs character takes two single char space on screen
            //
            if (BlFrontChar & 0xFF00) {
                USHORT  *pMsg = (USHORT *)szMsg;
                ULONG   uNumChars = (iNumChars + 1) / 2;

                while(uNumChars--)
                    *pMsg++ = BlFrontChar;
            } else {
                memset( szMsg, BlFrontChar, min(iNumChars, sizeof(szMsg) - 1));
            }
#endif
        }

        if (iNumBackChars && BlBackChar) {
#ifdef EFI
            PTCHAR pMsg = szBarBackStr;
            ULONG uNumChars = iNumBackChars;
            while (uNumChars--) {
                *pMsg++ = BlBackChar;
            }
#else
            //
            // copy appropriately based on single / double byte character
            // each dbcs character takes two single char space on screen
            //
            if (BlBackChar & 0xFF00) {
                USHORT  *pMsg = (USHORT *)szBarBackStr;
                ULONG   uNumChars = iNumBackChars / 2;

                while(uNumChars--)
                    *pMsg++ = BlBackChar;
            } else {
                memset(szBarBackStr, BlBackChar,
                    min(sizeof(szBarBackStr) - 1, iNumBackChars));
            }
#endif
        }

        _tcscat(szPrgBar, szMsg);
        _tcscat(szPrgBar, szBarBackStr);

#if 0
        {
            TCHAR   szDbg[512] = { 0 };

            _stprintf(szDbg, TEXT("(%x, %x)=[%d,%d],%x\n%s\n%s\n%s"),
                BlFrontChar, BlBackChar, iNumChars, iNumBackChars, fPercentage,
                szMsg, szBarBackStr, szPrgBar);

            BlPositionCursor(1,1);
            ArcWrite(BlConsoleOutDeviceId,
                    szDbg,
                    _tcslen(szDbg)*sizeof(TCHAR),
                    &lCount);
        }
#endif

        // print out the progress bar
        BlPositionCursor(uCol, uRow);
        ArcWrite(BlConsoleOutDeviceId,
                szPrgBar,
                _tcslen(szPrgBar)*sizeof(TCHAR),
                &lCount);
    }
}


VOID
BlUpdateProgressBar(
    ULONG fPercentage
    )
{
    if (DisplayLogoOnBoot) {
        BlUpdateGfxProgressBar(fPercentage);
    } else {
        BlUpdateTxtProgressBar(fPercentage);
    }        
}

VOID
BlOutputStartupMsgStr(
    PCTSTR MsgStr
    )
/*++

Routine Description:

    Clears the screen and displays the startup message at the specified
    coordinates of screen

Arguments:

    MsgStr - the message that needs to be displayed

Return Value:

    None

--*/
{
    ULONG lCount = 0;
    ULONG uX = 0, uY = 0;
    
    if (!DisplayLogoOnBoot && BlOutputDots && MsgStr) {
        BlClearScreen();
        BlSetInverseMode(FALSE);

        // center the message
        uX = ScreenHeight - 3;
        uY = (ScreenWidth / 2) - (_tcslen(MsgStr) / 2);

        if (uY > ScreenWidth)
            uY = 1;
            
        // print out the message
        BlPositionCursor(uY, uX);

        ArcWrite(BlConsoleOutDeviceId,
                 (PVOID)MsgStr,
                 _tcslen(MsgStr) * sizeof(TCHAR),
                 &lCount);

        BlRedrawProgressBar();
    }
}

VOID
BlOutputStartupMsg(
    ULONG   uMsgID
    )
/*++

Routine Description:

    Clears the screen and displays the startup message at the specified
    coordinates of screen

Arguments:

    uMsgID - inidicates the message ID that needs to be displayed

Return Value:

    None

--*/
{

    if (!DisplayLogoOnBoot && BlOutputDots) {
        //
        // Proceed only if no logo is displayed.
        //
        BlOutputStartupMsgStr(BlFindMessage(uMsgID));
    }
}

VOID
BlOutputTrailerMsgStr(
    PCTSTR MsgStr
    )
/*++

Routine Description:

    Displays a trailer message at the bottom of the screen

Arguments:

    uMsgID - inidicates the message ID that needs to be displayed


Return Value:

    None

--*/
{
    ULONG   lCount = 0;
    TCHAR   szText[256] = {0};

    if (!DisplayLogoOnBoot && BlOutputDots && MsgStr) {

        ASSERT( _tcslen(MsgStr) < 256 );

        BlPositionCursor(1, ScreenHeight);
        _tcscpy(szText, MsgStr);
        lCount = (ULONG)_tcslen(szText);

        if ((lCount > 2) && szText[lCount-2] == TEXT('\r') && szText[lCount-1] == TEXT('\n')) {
            szText[lCount-2] = TEXT('\0');
            lCount -= 2;
        }

        ArcWrite(BlConsoleOutDeviceId,
                 szText,
                 lCount*sizeof(TCHAR),
                 &lCount);
    }

}

VOID
BlOutputTrailerMsg(
    ULONG   uMsgID
    )
/*++

Routine Description:

    Displays a trailer message at the bottom of the screen

Arguments:

    uMsgID - inidicates the message ID that needs to be displayed


Return Value:

    None

--*/
{
    BlOutputTrailerMsgStr(BlFindMessage(uMsgID));
}

VOID
BlSetProgBarCharacteristics(
    IN  ULONG   FrontCharMsgID,
    IN  ULONG   BackCharMsgID
    )
/*++

Routine Description:

    Sets the characteristics for progress bar

Arguments:

    IN  ULONG   FrontCharMsgID : Progress bar foreground character
    IN  ULONG   BackCharMsgID : Progress bar background character

Return Value:

    None

--*/
{
#ifdef EFI
    BlFrontChar = GetGraphicsChar( GraphicsCharFullBlock );
    BlBackChar  = GetGraphicsChar( GraphicsCharLightShade );
#else
    
    _PTUCHAR  szBar = 0;

    BlProgBarFrontMsgID = FrontCharMsgID;
    BlProgBarBackMsgID = BackCharMsgID;

    // fetch the bar character from resource file
    szBar = BlFindMessage(BlProgBarFrontMsgID);

    if (szBar) {
        ULONG   len = _tcslen(szBar);

        if ((len == 1) ||
                ((len > 2) && (szBar[1] == TEXT('\r')) && (szBar[2] == TEXT('\n')))) {
            BlFrontChar = szBar[0];
        } else {
            BlFrontChar = *(USHORT *)szBar;
        }
    }

    // fetch the progress bar background character
    szBar = BlFindMessage(BlProgBarBackMsgID);

    if (szBar) {
        ULONG   len = _tcslen(szBar);

        if ((len == 1) ||
                ((len > 2) && (szBar[1] == TEXT('\r')) && (szBar[2] == TEXT('\n')))) {
            BlBackChar = szBar[0];
        } else {
            BlBackChar = *(USHORT *)szBar;
        }
    }

    //
    // make both the progess bar characters double byte characters
    // if one of them is double byte character
    //
    if (BlFrontChar & 0xFF00) {
        if (!(BlBackChar & 0xFF00))
            BlBackChar = BlBackChar | (BlBackChar << 8);
    } else {
        if (BlBackChar & 0xFF00)
            BlFrontChar = BlFrontChar | (BlFrontChar << 8);
    }
#endif
}

ARC_STATUS
BlLoadFileImage(
    IN  ULONG           DeviceId,
    IN  PCHAR           DeviceName,
    IN  PCHAR           Directory,
    IN  PUNICODE_STRING FileName,
    IN  TYPE_OF_MEMORY  MemoryType,
    OUT PVOID           *Image,
    OUT PULONG          ImageSize,
    OUT PCHAR           BadFileName
    )

/*++

Routine Description:

    This routine loads the specified device driver and resolves all DLL
    references if the driver is not already loaded.

Arguments:

    DeviceId - Supplies the file id of the device on which the specified
        device driver is loaded from.

    DeviceName - Supplies the name of the device the system tree is on.

    Directory - Supplies a pointer to the directory path of the root
        of the NT tree.

    FileName - Name of the file to be loaded.

    Image - Receives pointer to the buffer containing the file image in memory.

    ImageSize - Receives the size of file image in memory.

    BadFileName - Returns the filename of the OEM font file that was missing
        or invalid.

Return Value:

    ESUCCESS is returned if the specified file is successfully loaded.
    Otherwise unsuccessful status is returned.

--*/

{
    CHAR                infName[256];
    ARC_STATUS          status;
    ULONG               fileId;
    FILE_INFORMATION    fileInfo;
    ULONG               size;
    ULONG               pageCount;
    ULONG               actualBase;
    PCHAR               buffer;
    ULONG               sizeRead;

    *Image = NULL;
    *ImageSize = 0;

    //
    // Get the fully qualified name for the file being loaded.
    //

    sprintf(&infName[0], "%s%wZ", Directory, FileName);

    //
    // Display the name of file being loaded.
    //

    BlOutputLoadMessage(DeviceName, infName, NULL);

    //
    // Open the file.
    //

    status = BlOpen(DeviceId, infName, ArcOpenReadOnly, &fileId);

    if (status == ESUCCESS) {
        BlUpdateBootStatus();

        //
        // Find out size of INF file.
        //

        status = BlGetFileInformation(fileId, &fileInfo);
        if (status == ESUCCESS) {

            size = fileInfo.EndingAddress.LowPart;

            //
            // Allocate a descriptor large enough to hold the entire file.
            // On x86 this has an unfortunate tendency to slam txtsetup.sif
            // into a free block at 1MB, which means the kernel can't be
            // loaded (it's linked for 0x100000 without relocations).
            // On x86 this has an unfortunate tendency to slam txtsetup.sif
            // into a free block at 1MB, which means the kernel can't be
            // loaded (it's linked for 0x100000 without relocations).
            //
            // (tedm) we're also seeing a similar problem on alphas now
            // because txtsetup.sif has grown too large, so this code has been
            // made non-conditional.
            //


            pageCount = (ULONG)(ROUND_TO_PAGES(size) >> PAGE_SHIFT);

            status = BlAllocateDescriptor(  MemoryType, // Descriptor gets reclaimed by MM.
                                            0,
                                            pageCount,
                                            &actualBase);

            if (status == ESUCCESS) {

                buffer = (PCHAR)(KSEG0_BASE | (actualBase << PAGE_SHIFT));

                //
                // Read the file in.
                //

                status = BlRead(fileId, buffer, size, &sizeRead);
                if (status == ESUCCESS) {

                    //
                    // If the file was successfully read, return the
                    // desired parameters.
                    //

                    if (Image) {

                        *Image = buffer;
                    }

                    if (ImageSize) {

                        *ImageSize = sizeRead;
                    }
                }
                else {

                    //
                    // No need to release the memory as it will get reclaimed by MM anyway.
                    //
                }
            }
        }

        //
        // Close the file handle.
        //

        BlClose(fileId);
    }

    //
    // If there was any error, return the name of the file
    // we failed to load.
    //

    if (status != ESUCCESS)
    {
        strcpy(BadFileName, &infName[0]);
    }

    return(status);
}

VOID
BlClearScreen(
    VOID
    )

/*++

Routine Description:

    Clears the screen.

Arguments:

    None

Return Value:

    None.

--*/

{
#ifdef EFI
    BlEfiClearDisplay();
#else 
    TCHAR Buffer[16];
    ULONG Count;

    _stprintf(Buffer, ASCI_CSI_OUT TEXT("2J"));

    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             _tcslen(Buffer) *sizeof(TCHAR),
             &Count);
#endif
}


VOID
BlClearToEndOfScreen(
    VOID
    )
{
#ifdef EFI
    BlEfiClearToEndOfDisplay();
#else 
    TCHAR Buffer[16];
    ULONG Count;
    
    _stprintf(Buffer, ASCI_CSI_OUT TEXT("J"));
    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             _tcslen(Buffer)*sizeof(TCHAR),
             &Count);
#endif
}


VOID
BlClearToEndOfLine(
    VOID
    )
{
#ifdef EFI
    BlEfiClearToEndOfLine();
#else
    TCHAR Buffer[16];
    ULONG Count;
    
    if (!DisplayLogoOnBoot) {

        _stprintf(Buffer, ASCI_CSI_OUT TEXT("K"));
        ArcWrite(BlConsoleOutDeviceId,
                 Buffer,
                 _tcslen(Buffer)*sizeof(TCHAR),
                 &Count);
    }
#endif
}


VOID
BlPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    )

/*++

Routine Description:

    Sets the position of the cursor on the screen.

Arguments:

    Column - supplies new Column for the cursor position.

    Row - supplies new Row for the cursor position.

Return Value:

    None.

--*/

{
#ifdef EFI
    BlEfiPositionCursor( Column-1, Row-1 );    
#else
    TCHAR Buffer[16];
    ULONG Count;
    
    _stprintf(Buffer, ASCI_CSI_OUT TEXT("%d;%dH"), Row, Column);

    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             _tcslen(Buffer)*sizeof(TCHAR),
             &Count);
#endif

}


VOID
BlSetInverseMode(
    IN BOOLEAN InverseOn
    )

/*++

Routine Description:

    Sets inverse console output mode on or off.

Arguments:

    InverseOn - supplies whether inverse mode should be turned on (TRUE)
                or off (FALSE)

Return Value:

    None.

--*/

{
#ifdef EFI    
    BlEfiSetInverseMode( InverseOn );
#else
    TCHAR Buffer[16];
    ULONG Count;

    
    _stprintf(Buffer, ASCI_CSI_OUT TEXT("%dm"), InverseOn ? SGR_INVERSE : SGR_NORMAL);

    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             _tcslen(Buffer)*sizeof(TCHAR),
             &Count);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\bllog.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    blprint.c

Abstract:

    This module implements the OS loader debug logging routines.

Author:

    Chuck Lenzmeier (chuckl) 2-Nov-1995

Revision History:

--*/

#include "bldr.h"
#include <stdio.h>

#if DBG || BLLOGENABLED

ULONG BlLogFileId = (ULONG)-1;
ULONG BlLogActiveTargets = 0;

VOID
BlLogInitialize (
    ULONG LogfileDeviceId
    )
{
    ARC_STATUS Status;

    BlLogActiveTargets = 0;

    if (BlLoaderBlock->LoadOptions != NULL) {

        if (strstr(BlLoaderBlock->LoadOptions,"DBGDISPLAY") != NULL) {
            BlLogActiveTargets |= LOG_DISPLAY;
        }

        if (strstr(BlLoaderBlock->LoadOptions,"DBGDEBUGGER") != NULL) {
            BlLogActiveTargets |= LOG_DEBUGGER;
        }

        if (strstr(BlLoaderBlock->LoadOptions,"DBGLOG") != NULL) {
            Status = BlOpen(LogfileDeviceId, "\\LDRDBG.LOG", ArcSupersedeReadWrite, &BlLogFileId);
            if (Status == 0) {
                BlLogActiveTargets |= LOG_LOGFILE;
            }
        }
    }

#if 0
    BlLogArcDescriptors(LOG_ALL);
    BlLogMemoryDescriptors(LOG_ALL_W);
#endif

    return;
}

VOID
BlLogTerminate (
    VOID
    )
{
#if 0
    BlLogMemoryDescriptors(LOG_ALL);
#endif
    BlLog(( 
        0 ? BlLogActiveTargets | LOG_WAIT : BlLogActiveTargets, 
        "BlLog terminating" 
        ));
    
    if ((BlLogActiveTargets & LOG_LOGFILE) != 0) {
        BlClose(BlLogFileId);
    }
    BlLogActiveTargets = 0;

    return;
}

VOID
BlLogWait (
    IN ULONG Targets
    )
{
    if ((Targets & BlLogActiveTargets & LOG_DEBUGGER) != 0) {
        DbgBreakPoint( );
    } else if ((Targets & BlLogActiveTargets & LOG_DISPLAY) != 0) {
        BlLogWaitForKeystroke();
    }

    return;
}

VOID
BlLogPrint (
    ULONG Targets,
    PCHAR Format,
    ...
    )
{
    va_list arglist;
    int count;
    UCHAR buffer[79];
    ULONG activeTargets;

    activeTargets = Targets & BlLogActiveTargets;

    if (activeTargets != 0) {

        va_start(arglist, Format);

        count = _vsnprintf(buffer, sizeof(buffer), Format, arglist);
        if (count != -1) {
            RtlFillMemory(&buffer[count], sizeof(buffer)-count-2, ' ');
        }
        count = sizeof(buffer);
        buffer[count-2] = '\r';
        buffer[count-1] = '\n';

        if ((activeTargets & LOG_LOGFILE) != 0) {
            BlWrite(BlLogFileId, buffer, count, &count);
        }

        if ((activeTargets & LOG_DISPLAY) != 0) {
            ArcWrite(ARC_CONSOLE_OUTPUT, buffer, count, &count);
        }
        if ((activeTargets & LOG_DEBUGGER) != 0) {
            DbgPrint( buffer );
        }

        if ((Targets & LOG_WAIT) != 0) {
            BlLogWait( Targets );
        }
    }

    return;
}

VOID
BlLogArcDescriptors (
    ULONG Targets
    )
{
    PMEMORY_DESCRIPTOR CurrentDescriptor;
    ULONG activeTargets;

    activeTargets = Targets & BlLogActiveTargets;

    if (activeTargets != 0) {

        BlLog((activeTargets,"***** ARC Memory List *****"));

        CurrentDescriptor = NULL;
        while ((CurrentDescriptor = ArcGetMemoryDescriptor(CurrentDescriptor)) != NULL) {
            BlLog((activeTargets,
                   "Descriptor %8x:  Type %8x  Base %8x  Pages %8x",
                   CurrentDescriptor,
                   (USHORT)(CurrentDescriptor->MemoryType),
                   CurrentDescriptor->BasePage,
                   CurrentDescriptor->PageCount));
        }

        //BlLog((activeTargets,"***************************"));

        if ((Targets & LOG_WAIT) != 0) {
            BlLogWait( Targets );
        }
    }

    return;
}

VOID
BlLogMemoryDescriptors (
    ULONG Targets
    )
{
    PLIST_ENTRY CurrentLink;
    PMEMORY_ALLOCATION_DESCRIPTOR CurrentDescriptor;
    ULONG Index;
    ULONG ExpectedIndex;
    ULONG ExpectedBase;
    ULONG FoundIndex;
    PMEMORY_ALLOCATION_DESCRIPTOR FoundDescriptor;
    TYPE_OF_MEMORY LastType;
    ULONG FreeBlocks = 0;
    ULONG FreePages = 0;
    ULONG LargestFree = 0;

    ULONG activeTargets;

    activeTargets = Targets & BlLogActiveTargets;

    if (activeTargets != 0) {

        BlLog((activeTargets,"***** System Memory List *****"));

        ExpectedIndex = 0;
        ExpectedBase = 0;
        LastType = (ULONG)-1;

        do {
            Index = 0;
            FoundDescriptor = NULL;
            CurrentLink = BlLoaderBlock->MemoryDescriptorListHead.Flink;

            while (CurrentLink != &BlLoaderBlock->MemoryDescriptorListHead) {

                CurrentDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR)CurrentLink;
                if (CurrentDescriptor->BasePage == ExpectedBase) {
                    if ((FoundDescriptor != NULL) && (FoundDescriptor->BasePage == ExpectedBase)) {
                        BlLog((activeTargets,
                               "ACK! Found multiple descriptors with base %x: %x and %x",
                               ExpectedBase,
                               FoundDescriptor,
                               CurrentDescriptor));
                    } else {
                        FoundDescriptor = CurrentDescriptor;
                        FoundIndex = Index;
                    }
                } else if (CurrentDescriptor->BasePage > ExpectedBase) {
                    if ((FoundDescriptor == NULL) ||
                        (CurrentDescriptor->BasePage < FoundDescriptor->BasePage)) {
                        FoundDescriptor = CurrentDescriptor;
                        FoundIndex = Index;
                    }
                }

                CurrentLink = CurrentLink->Flink;
                Index++;
            }

            if (FoundDescriptor != NULL) {

                if (FoundDescriptor->BasePage != ExpectedBase) {
                    BlLog((activeTargets,
                           "     ACK! MISSING MEMORY! ACK!  Base %8x  Pages %8x",
                           ExpectedBase,
                           FoundDescriptor->BasePage - ExpectedBase));
                }
                BlLog((activeTargets,
                       "%c%c%2d Descriptor %8x:  Type %8x  Base %8x  Pages %8x",
                       FoundDescriptor->MemoryType == LastType ? '^' : ' ',
                       FoundIndex == ExpectedIndex ? ' ' : '*',
                       FoundIndex,
                       FoundDescriptor,
                       (USHORT)(FoundDescriptor->MemoryType),
                       FoundDescriptor->BasePage,
                       FoundDescriptor->PageCount));

                if (FoundIndex == ExpectedIndex) {
                    ExpectedIndex++;
                }
                ExpectedBase = FoundDescriptor->BasePage + FoundDescriptor->PageCount;

                LastType = FoundDescriptor->MemoryType;
                if (LastType != MemoryFree) {
                    LastType = (ULONG)-1;
                } else {
                    FreeBlocks++;
                    FreePages += FoundDescriptor->PageCount;
                    if (FoundDescriptor->PageCount > LargestFree) {
                        LargestFree = FoundDescriptor->PageCount;
                    }
                }
            }

        } while ( FoundDescriptor != NULL );

        BlLog((activeTargets,
               "Total free blocks %2d, free pages %4x, largest free %4x",
               FreeBlocks,
               FreePages,
               LargestFree));

        //BlLog((activeTargets,"******************************"));

        if ((Targets & LOG_WAIT) != 0) {
            BlLogWait( Targets );
        }
    }

    return;
}

VOID
BlLogWaitForKeystroke (
    VOID
    )
{
    UCHAR Key=0;
    ULONG Count;

    if ((BlLogActiveTargets & LOG_DISPLAY) != 0) {
        do {
            if (ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
                ArcRead(ARC_CONSOLE_INPUT,
                        &Key,
                        sizeof(Key),
                        &Count);
                break;
            }
        } while ( TRUE );
    }

    return;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\blrange.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blrange.c

Abstract:

    This module implements ranges and rangelists. These can be used
    to keep track of cached ranges of a disk for instance.

Author:

    Cenk Ergan (cenke) 11-Jan-2000

Revision History:

--*/

#include "blrange.h"

//
// Range function definitions.
//

VOID
BlRangeListInitialize (
    PBLCRANGE_LIST pRangeList,
    OPTIONAL PBLCRANGE_MERGE_ROUTINE pMergeRoutine,
    OPTIONAL PBLCRANGE_FREE_ROUTINE pFreeRoutine
    )
/*++

Routine Description:

    This routine initializes the range list whose address is passed in
    so it can be used by the other range functions.

Arguments:

    pRangeList - Address of the range list to initialize.

    pMergeRoutine - Optional routine to merge Data fields of merged
        range entries. See PBLCRANGE_MERGE_ROUTINE description.

    pFreeRoutine - Optional routine to free the memory for an entry
        that was merged into another. See PBLCRANGE_FREE_ROUTINE desc.

Return Value:

    None. [Always successful]

--*/
{
    InitializeListHead(&pRangeList->Head);
    pRangeList->NumEntries = 0;
    pRangeList->MergeRoutine = pMergeRoutine;
    pRangeList->FreeRoutine = pFreeRoutine;
}

BOOLEAN
BlRangeListAddRange (
    PBLCRANGE_LIST  pRangeList,
    PBLCRANGE_ENTRY pRangeEntry
    )
/*++

Routine Description:

    This routine adds pRangeEntry to pRangeList only if it does not
    have any overlap with other ranges in the list and its size > 0;
    If merging becomes possible it is attempted. It does not have to
    be successful.

Arguments:

    pRangeList - Address of the range list to add range to.

    pRangeEntry - Range to add to pRangeList.

Return Value:

    TRUE if addition is successful [even if merging was possible but failed]
    FALSE if not [e.g. overlap/collusion]

--*/
{
    PBLCRANGE_ENTRY pCurEntry = NULL;
    PBLCRANGE_ENTRY pLastEntry = NULL;
    LIST_ENTRY *pHead, *pNext;
    
    //
    // Handle special empty range case.
    //

    if (pRangeEntry->Range.Start == pRangeEntry->Range.End)
        return TRUE;

    //
    // Walk through the ranges in the sorted list checking for
    // overlaps and looking for the right place for us.
    //
    
    pHead = &pRangeList->Head;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pCurEntry = CONTAINING_RECORD(pNext, BLCRANGE_ENTRY, Link);
        
        //
        // Check if we are completely before this entry. 
        //

        if (pRangeEntry->Range.End <= pCurEntry->Range.Start)
        {
            //
            // Insert the new entry at its place.
            //

            InsertTailList(pNext, &pRangeEntry->Link);
            pRangeList->NumEntries++;

            //
            // Check if merging is possible.
            //
            
            if (pLastEntry && (pRangeEntry->Range.Start == pLastEntry->Range.End))
            {
                BlRangeListMergeRangeEntries(
                    pRangeList,
                    pRangeEntry,
                    pLastEntry
                    );
            }

            if (pRangeEntry->Range.End == pCurEntry->Range.Start)
            {
                BlRangeListMergeRangeEntries(
                    pRangeList,
                    pRangeEntry,
                    pCurEntry
                    );
            }

            return TRUE;
        }
        
        //
        // Check if we are not completely after this entry.
        //

        if (pRangeEntry->Range.Start < pCurEntry->Range.End)
        {
            //
            // We have an overlapping range.
            //

            return FALSE;
        }
        
        //
        // We come after this entry.
        //

        pLastEntry = pCurEntry;
        pNext = pNext->Flink;
    }  

    //
    // We come after the last entry [if there is one], i.e. before the head.
    // Insert the new entry and check if merging is possible.
    //

    InsertTailList(pHead, &pRangeEntry->Link);
    pRangeList->NumEntries++;

    if (pLastEntry && (pRangeEntry->Range.Start == pLastEntry->Range.End))
    {
        BlRangeListMergeRangeEntries(
            pRangeList,
            pRangeEntry,
            pLastEntry
            );
    }

    return TRUE;
}

BOOLEAN
BlRangeListFindOverlaps (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE pRange,
    PBLCRANGE_ENTRY *pOverlapsBuffer,
    ULONG OverlapsBufferSize,
    OUT ULONG *pNumOverlaps
    )
/*++

Routine Description:

    This routine will find ranges in pRangeList that overlap with
    pRange and put pointers to them into pOverlapsBuffer one after the
    other. If all overlapping ranges cannot be copied because
    pOverlapsBuffer is NULL or OverlapsBufferSize is 0 or not enough,
    the function will return FALSE and but still put the number of
    overlapping ranges in pNumOverlaps. You can calculate the required
    buffer size from this.

Arguments:

    pRangeList - Address of the range list to search for overlaps.

    pRange - We will look for range entries that overlap with pRange.

    pOverlapsBuffer - Pointer to buffer we can fill with pointers to
        overlapping ranges.

    OverlapsBufferSize - Size up to which we can fill pOverlapsBuffer.

    pNumOverlaps - Number of overlapping ranges will always be put
        here.

Return Value:

    TRUE if successful, FALSE if not. 

--*/
{
    PBLCRANGE_ENTRY pCurEntry;
    LIST_ENTRY *pHead, *pNext;
    ULONG NumOverlaps = 0;
    ULONG RequiredOverlapsBufferSize = 0;

    //
    // Handle special empty range case.
    //

    if (pRange->Start == pRange->End)
    {
        *pNumOverlaps = NumOverlaps;
        return (pOverlapsBuffer != NULL);
    }

    //
    // Walk through the ranges in the sorted list and copy over ones
    // that overlap into callers buffer if there is enough space.
    //

    pHead = &pRangeList->Head;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pCurEntry = CONTAINING_RECORD(pNext, BLCRANGE_ENTRY, Link);
        
        if ((pRange->End > pCurEntry->Range.Start) &&
            (pRange->Start < pCurEntry->Range.End))
        {
            //
            // This entry overlaps.
            //

            RequiredOverlapsBufferSize += sizeof(PBLCRANGE_ENTRY);
            if (pOverlapsBuffer && 
                (OverlapsBufferSize >= RequiredOverlapsBufferSize))
            {
                pOverlapsBuffer[NumOverlaps] = pCurEntry;
            }
            NumOverlaps++;
        }

        pNext = pNext->Flink;
    }

    *pNumOverlaps = NumOverlaps;
    
    return (pOverlapsBuffer && 
            (OverlapsBufferSize >= RequiredOverlapsBufferSize));
}


BOOLEAN
BlRangeListFindDistinctRanges (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE pRange,
    PBLCRANGE pDistinctRanges,
    ULONG BufferSize,
    OUT ULONG *pNumRanges
    )
/*++

Routine Description:

    This routine will look at ranges in pRangeList that overlap with
    pRange and extract the overlaps from pRange, thus keeping track of
    those ranges that are distinct. If all distinct ranges cannot be
    put into pDistinctRanges buffer because pDistinctRanges is NULL or
    BufferSize is 0 or not enough, the function will return FALSE and
    but still put the number of resulting distinct ranges in
    pNumRanges. You can calculate the required buffer size from
    this.

Arguments:

    pRangeList - Address of the range list.

    pRange - We will extract distinct ranges in pRange that do not 
        overlap with other ranges in pRangeList.

    pDistinctRanges - Pointer to buffer we can fill with distinct
        ranges.

    BufferSize - Size up to which we can fill pDistinctRanges buffer.

    pNumRanges - Number of resulting distinct ranges will always be
        put here.

Return Value:

    TRUE if successful, FALSE if not. 

--*/
{
    PBLCRANGE_ENTRY pCurEntry;
    BLCRANGE RemainingRange = *pRange;
    ULONGLONG OverlapStart;
    ULONGLONG OverlapEnd;
    LIST_ENTRY *pHead, *pNext;
    ULONG NumRanges = 0;
    ULONG RequiredBufferSize = 0;

    if (pRange->Start == pRange->End)
    {
        *pNumRanges = NumRanges;
        return (pDistinctRanges != NULL);
    }
    
    //
    // Looking at each range in the sorted list, we carve out overlap
    // and distinct zones from the start of our range.
    //

    pHead = &pRangeList->Head;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pCurEntry = CONTAINING_RECORD(pNext, BLCRANGE_ENTRY, Link);

        //
        // Is there still anything remaining from the range that we
        // have not carved out as overlap or distinct?
        //

        if (RemainingRange.Start >= RemainingRange.End)
            break;

        //
        // There are three possibilities:
        //

        //
        // 1. Is the range completely before the current range?
        //

        if (RemainingRange.End <= pCurEntry->Range.Start)
        {
            //
            // The whole range is distinct.
            //

            RequiredBufferSize += sizeof(BLCRANGE);
            if (pDistinctRanges && (RequiredBufferSize <= BufferSize))
            {
                pDistinctRanges[NumRanges].Start = RemainingRange.Start;
                pDistinctRanges[NumRanges].End = RemainingRange.End;
            }
            NumRanges++;
            
            RemainingRange.Start = RemainingRange.End;
        }
        
        //
        // 2. Are we completely beyond the current range?
        //

        if (RemainingRange.Start >= pCurEntry->Range.End)
        {
            //
            // We cannot carve out anything from the remaining range.
            // Fall through to processing the next entry.
            //
        }

        //
        // 3. Is the remaining range overlaps with the current range.
        //

        if ((RemainingRange.End > pCurEntry->Range.Start) &&
            (RemainingRange.Start < pCurEntry->Range.End))
        {
            OverlapStart = BLRGMAX(RemainingRange.Start,
                                   pCurEntry->Range.Start); 
            OverlapEnd = BLRGMIN(RemainingRange.End,
                                 pCurEntry->Range.End);
            
            if (OverlapStart > pRange->Start)
            {
                //
                // There is a distinct region before the overlap
                //
                RequiredBufferSize += sizeof(BLCRANGE);
                if (pDistinctRanges && (RequiredBufferSize <= BufferSize))
                {
                    pDistinctRanges[NumRanges].Start = RemainingRange.Start;
                    pDistinctRanges[NumRanges].End = OverlapStart;
                }
                NumRanges++;
            }

            RemainingRange.Start = OverlapEnd;
        }     

        pNext = pNext->Flink;
    }

    //
    // The remaining range (if there is any) is also distinct.
    //

    if (RemainingRange.Start < RemainingRange.End)
    {
        RequiredBufferSize += sizeof(BLCRANGE);
        if (pDistinctRanges && (RequiredBufferSize <= BufferSize))
        {
            pDistinctRanges[NumRanges].Start = RemainingRange.Start;
            pDistinctRanges[NumRanges].End = RemainingRange.End;
        }
        NumRanges++;
    }
    
    *pNumRanges = NumRanges;

    return (pDistinctRanges &&
            RequiredBufferSize <= BufferSize);
}

BOOLEAN
BlRangeListMergeRangeEntries (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry
    )
/*++

Routine Description:

    Merges SrcEntry and DestEntry range entries into DestEntry by
    calling BlRangeEntryMerge. If successful it tries to remove
    pSrcEntry from the range list it is in and free its memory by
    calling the FreeRoutine specified on the list.

Arguments:

    pRangeList - Range list pDestEntry and pSrcEntry belong to.

    pDestEntry - Range entry that we will merge into.

    pSrcEntry - Range entry that will be merged into pDestEntry,
        removed from its list and free'ed.

Return Value:

    TRUE if successful, FALSE if not. The success is mainly determined
    by calls to a MergeRoutine if specified on the list.

--*/
{

    if(BlRangeEntryMerge(pDestEntry,
                         pSrcEntry,
                         pRangeList->MergeRoutine))
    {
        //
        // Remove pSrcEntry from the list since it is merged into
        // pDestEntry now.
        // 

        pRangeList->NumEntries--;
        RemoveEntryList(&pSrcEntry->Link);

        //
        // Free the removed entry.
        //

        if (pRangeList->FreeRoutine) pRangeList->FreeRoutine(pSrcEntry);

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOLEAN
BlRangeEntryMerge (
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry,
    OPTIONAL PBLCRANGE_MERGE_ROUTINE pMergeRoutine
    )
/*++

Routine Description:

    Merges SrcEntry and DestEntry range entries into DestEntry. It
    uses pMergeRoutine if specified to merge the user's Data field of
    the range entries.

Arguments:

    pDestEntry - Range entry that we will merge into
  
    pSrcEntry - Range entry that will be merged into pDestEntry

    pMergeRoutine - Optional routine to merge Data fields of
        merged range entries. See PBLCRANGE_MERGE_ROUTINE description.

Return Value:

    TRUE if successful, FALSE if not. The success is mainly
    determined by calls to the pMergeRoutine if specified.

--*/
{
    BLCRANGE_ENTRY TempDest = *pDestEntry;
    BOOLEAN RetVal = TRUE;

    if (pMergeRoutine)
    {
        RetVal = pMergeRoutine(&TempDest, pSrcEntry);
    }
    
    if (RetVal)
    {
        TempDest.Range.Start = BLRGMIN(TempDest.Range.Start,
                                       pSrcEntry->Range.Start);
        TempDest.Range.End = BLRGMAX(TempDest.Range.End,
                                     pSrcEntry->Range.End);

        *pDestEntry = TempDest;
    }

    return RetVal;
}

VOID
BlRangeListRemoveRange (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE pRange
)
/*++

Routine Description:

    Find the ranges that overlap with pRange, remove them from the
    list and free them. It may be possible to reclaim non-overlapping
    parts of range entries by allowing the caller to specify a
    DivideRoutine in an _Ex version of this function. This function
    would be called for invalidating part of the cache, if the range
    list is being used for a disk cache.

Arguments:

    pRangeList - Range entry list we are removing range entries that
        overlap with pRange from.

    pRange - Range to remove from the range entry list.

Return Value:

    None.

--*/
{
    PBLCRANGE_ENTRY pCurEntry;
    LIST_ENTRY *pHead, *pNext;

    //
    // Handle special empty range case.
    //

    if (pRange->Start == pRange->End)
    {
        return;
    }
    
    //
    // Looking at each range in the list, remove the ones that overlap with
    // pRange even slightly.
    //

    pHead = &pRangeList->Head;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pCurEntry = CONTAINING_RECORD(pNext, BLCRANGE_ENTRY, Link);
        pNext = pNext->Flink;

        if ((pRange->End > pCurEntry->Range.Start) &&
            (pRange->Start < pCurEntry->Range.End))
        {
            pRangeList->NumEntries--;
            RemoveEntryList(&pCurEntry->Link);
            if (pRangeList->FreeRoutine) pRangeList->FreeRoutine(pCurEntry);
        }     
    }

    return;
}

VOID
BlRangeListRemoveAllRanges (
    PBLCRANGE_LIST pRangeList
    )
/*++

Routine Description:

    Remove all ranges from the list and free them. 

Arguments:

    pRangeList - Range entry list we are removing range entries that
        overlap with pRange from.

Return Value:

    None.

--*/
{
    PBLCRANGE_ENTRY pCurEntry;
    LIST_ENTRY *pHead, *pNext;
    
    pHead = &pRangeList->Head;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pCurEntry = CONTAINING_RECORD(pNext, BLCRANGE_ENTRY, Link);

        pRangeList->NumEntries--;
        RemoveEntryList(&pCurEntry->Link);      
        if (pRangeList->FreeRoutine) pRangeList->FreeRoutine(pCurEntry);

        pNext = pNext->Flink;
    }

    return;
}

#ifdef BLRANGE_SELF_TEST

//
// In order to to test blrange implementation, define
// BLRANGE_SELF_TEST and call BlRangeSelfTest from you program passing
// in a function to output debug results.
//

#include <stdlib.h>
#include <stdio.h>
#include <time.h>

//
// Keep MAX_RANDOM above 1000 or you may hit difficulties creating new
// entries.
//

#define MAX_RANDOM 10000

VOID
GetRandom_GetNewSeed(
    VOID
    )
{
    srand((unsigned)time(NULL));
}

ULONG
GetRandom(
    VOID
    )
{
    return (rand() * 10000 / RAND_MAX);
}

typedef 
int
(*PBLCRANGE_SELFTEST_FPRINTF_ROUTINE) (
    void *stream,
    const char *format,
    ...
    );

PBLCRANGE_SELFTEST_FPRINTF_ROUTINE g_fpTestPrintf = NULL;
VOID *g_pTestStream = NULL;

BOOLEAN
BlRangeSelfTest_MergeRoutine (
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry
    )
{
    g_fpTestPrintf(g_pTestStream,
                   "  Merging RangeDest %I64u-%I64u RangeSrc %I64u-%I64u : ",
                   pDestEntry->Range.Start, 
                   pDestEntry->Range.End,
                   pSrcEntry->Range.Start, 
                   pSrcEntry->Range.End);
    
    if (GetRandom() < (MAX_RANDOM / 5))
    {
        g_fpTestPrintf(g_pTestStream,"FAIL\n");
        return FALSE;
    }
    else
    {
        g_fpTestPrintf(g_pTestStream,"SUCCESS\n");
        return TRUE;
    }
}

VOID
BlRangeSelfTest_FreeRoutine (
    PBLCRANGE_ENTRY pRangeEntry
    )
{
    g_fpTestPrintf(g_pTestStream,
                   "  Freeing range %I64u-%I64u \n",
                   pRangeEntry->Range.Start, 
                   pRangeEntry->Range.End);

    free(pRangeEntry);
}

BLCRANGE
BlRangeSelfTest_RandomRange(
    VOID
    )
{
    BLCRANGE RetRange;
    ULONG Rand1;
    ULONG Rand2;
    ULONGLONG Size;
    ULONG i;

    Rand1 = GetRandom();
    Rand2 = GetRandom();

    RetRange.Start = BLRGMIN(Rand1, Rand2);
    RetRange.End = BLRGMAX(Rand1, Rand2);

    //
    // Make sure that ranges are small and there are not just a couple
    // of big ones.
    //

    for (i = 0; i < 3; i++)
    {
        if ((Size = (RetRange.End - RetRange.Start)) > MAX_RANDOM / 20)
        {
            RetRange.Start += (Size / 2);
        }
        else
        {
            break;
        }
    }

    return RetRange;
}

PBLCRANGE_ENTRY
BlRangeSelfTest_CreateNewEntry(
    VOID
    )
{
    PBLCRANGE_ENTRY pNewEntry;
   
    pNewEntry = malloc(sizeof(BLCRANGE_ENTRY));

    if (pNewEntry) 
    {
        pNewEntry->Range = BlRangeSelfTest_RandomRange();
    }

    return pNewEntry;
}

VOID
BlRangeSelfTest_FreeEntry(
    PBLCRANGE_ENTRY pEntry
    )
{
    free(pEntry);
}

typedef enum _BLRANGE_OP_TYPE
{
    BLRANGE_OP_ADD_RANGE,
    BLRANGE_OP_ADD_MERGE_RANGE,
    BLRANGE_OP_REMOVE_RANGE,
    BLRANGE_OP_FIND_OVERLAP,
    BLRANGE_OP_FIND_DISTINCT,
    BLRANGE_OP_MAX_OP_NO, // Leave this at the end of the enumeration.
} BLRANGE_OP_TYPE;

VOID
BlRangeSelfTest(
    PBLCRANGE_SELFTEST_FPRINTF_ROUTINE TestOutFPrintf,
    PVOID TestOutStream,
    ULONG NumIterations
    )
/*++

Routine Description:

    Range routines self test routine.

Arguments:

    TestOutFPrintf - Pointer to a routine like fprintf that will be used to
        print the output.

    TestOutStream - Argument to be passed to fpPrintf as its first argument.

    NumIterations - Number of random operations to perform in this self test.

Return Value:

    None.

--*/
{
    BLCRANGE_LIST RangeList;
    ULONG Rand1;
    ULONG Rand2;
    BLCRANGE Range1;
    PBLCRANGE_ENTRY pEntry1;
    PBLCRANGE_ENTRY pEntry2;
    BLRANGE_OP_TYPE OpType;
    PLIST_ENTRY pHead;
    PLIST_ENTRY pNext;
    PBLCRANGE_ENTRY *pOverlaps;
    PBLCRANGE pDistinctRanges;
    ULONG BufSize;
    ULONG NumDistincts;
    ULONG NumOverlaps;
    ULONG RandEntryNo;
    
    //
    // Simulation Parameters.
    //
    
    ULONG StartNumRanges = 10;
    
    ULONG CurIterIdx;
    ULONG CurRangeIdx;
    ULONG CurEntryIdx;

    //
    // Set global output function and stream variable so merge/free etc.
    // routines can also output.
    //

    g_fpTestPrintf = TestOutFPrintf;
    g_pTestStream = TestOutStream;

    //
    // Set semi-random starting point for pseudorandom number generation.
    //
    
    GetRandom_GetNewSeed();


    //
    // Initialize the range list.
    //

    BlRangeListInitialize(&RangeList, 
                          BlRangeSelfTest_MergeRoutine,
                          BlRangeSelfTest_FreeRoutine);
    
    //
    // Try to add StartNumRanges random entries.
    //

    for(CurRangeIdx = 0; CurRangeIdx < StartNumRanges; CurRangeIdx++)
    {
        pEntry1 = BlRangeSelfTest_CreateNewEntry();
        
        if (!pEntry1) continue;
        
        g_fpTestPrintf(g_pTestStream,
                       "AddStartRange %I64u-%I64u : ",
                       pEntry1->Range.Start,
                       pEntry1->Range.End);
                       
        if (BlRangeListAddRange(&RangeList, pEntry1))
        {
            g_fpTestPrintf(g_pTestStream, "SUCCESS\n");
        }
        else
        {
            g_fpTestPrintf(g_pTestStream, "FAILED\n");
            BlRangeSelfTest_FreeEntry(pEntry1);
        }
    }

    for(CurIterIdx = 0; CurIterIdx < NumIterations; CurIterIdx++)
    {
        //
        // Print out the current list.
        //

        g_fpTestPrintf(g_pTestStream, "List: ");
        pHead = &RangeList.Head;
        pNext = pHead->Flink;
        while (pNext != pHead)
        {
            pEntry1 = CONTAINING_RECORD(pNext, BLCRANGE_ENTRY, Link);
            
            g_fpTestPrintf(g_pTestStream, 
                           "%I64u-%I64u ", 
                           pEntry1->Range.Start,
                           pEntry1->Range.End);

            pNext = pNext->Flink;
        }
        g_fpTestPrintf(g_pTestStream, "\n");
        
    get_new_optype:
        OpType = GetRandom() % BLRANGE_OP_MAX_OP_NO;
        
        switch (OpType)
        {
        case BLRANGE_OP_ADD_RANGE:

            pEntry1 = BlRangeSelfTest_CreateNewEntry();
            g_fpTestPrintf(g_pTestStream,
                           "AddRange %I64u-%I64u : ",
                           pEntry1->Range.Start,
                           pEntry1->Range.End);
            
            if (BlRangeListAddRange(&RangeList, pEntry1))
            {
                g_fpTestPrintf(g_pTestStream, "SUCCESS\n");
            }
            else
            {
                g_fpTestPrintf(g_pTestStream, "FAILED\n");
                BlRangeSelfTest_FreeEntry(pEntry1);
            }
            break;

        case BLRANGE_OP_ADD_MERGE_RANGE:
            
            RandEntryNo = GetRandom() * RangeList.NumEntries / MAX_RANDOM;
            
            pHead = &RangeList.Head;
            pNext = pHead->Flink;

            for (CurEntryIdx = 0; CurEntryIdx < RandEntryNo; CurEntryIdx++)
            {
                pNext = pNext->Flink;
            }
            
            if (pNext == pHead) goto get_new_optype;

            pEntry1 = CONTAINING_RECORD(pNext, BLCRANGE_ENTRY, Link);
            pEntry2 = BlRangeSelfTest_CreateNewEntry();

            if (GetRandom() > (MAX_RANDOM / 2))
            {
                pEntry2->Range.Start = pEntry1->Range.End;
                pEntry2->Range.End = pEntry2->Range.Start + 
                    (GetRandom() * (MAX_RANDOM - pEntry2->Range.Start)) / MAX_RANDOM;
            }
            else
            {
                pEntry2->Range.End = pEntry1->Range.Start;
                pEntry2->Range.Start = pEntry2->Range.End - 
                    (GetRandom() * pEntry2->Range.End) / MAX_RANDOM;
            }

            g_fpTestPrintf(g_pTestStream,
                           "MergeAddRange %I64u-%I64u : ",
                           pEntry2->Range.Start,
                           pEntry2->Range.End);
            
            if (BlRangeListAddRange(&RangeList, pEntry2))
            {
                g_fpTestPrintf(g_pTestStream, "SUCCESS\n");
            }
            else
            {
                g_fpTestPrintf(g_pTestStream, "FAILED\n");
                BlRangeSelfTest_FreeEntry(pEntry2);
            }
            break;

        case BLRANGE_OP_REMOVE_RANGE:
            
            Range1 = BlRangeSelfTest_RandomRange();

            g_fpTestPrintf(g_pTestStream, 
                           "RemoveRange %I64u-%I64u\n",
                           Range1.Start,
                           Range1.End);

            BlRangeListRemoveRange(&RangeList, &Range1);

            break;

        case BLRANGE_OP_FIND_OVERLAP:

            Range1 = BlRangeSelfTest_RandomRange();

            g_fpTestPrintf(g_pTestStream, 
                           "FindOverlaps %I64u-%I64u : ",
                           Range1.Start,
                           Range1.End);

            BlRangeListFindOverlaps(&RangeList,
                                    &Range1,
                                    NULL,
                                    0,
                                    &NumOverlaps);

            g_fpTestPrintf(g_pTestStream, "%u Overlaps... ", NumOverlaps);

            BufSize = NumOverlaps * sizeof(PBLCRANGE_ENTRY);
            pOverlaps = malloc(BufSize);
                        
            if (!pOverlaps) goto get_new_optype;

            if (BlRangeListFindOverlaps(&RangeList,
                                        &Range1,
                                        pOverlaps,
                                        BufSize,
                                        &NumOverlaps) &&
                (BufSize == NumOverlaps * sizeof(PBLCRANGE_ENTRY)))
            {
                g_fpTestPrintf(g_pTestStream, "SUCCESS\n");
            }
            else
            {
                g_fpTestPrintf(g_pTestStream, "FAIL\n");
                free(pOverlaps);
                break;
            }
          
            for (CurEntryIdx = 0; CurEntryIdx < NumOverlaps; CurEntryIdx++)
            {
                g_fpTestPrintf(g_pTestStream, 
                               "  %I64u-%I64u\n",
                               pOverlaps[CurEntryIdx]->Range.Start,
                               pOverlaps[CurEntryIdx]->Range.End);
            }

            free(pOverlaps);

            break;
            
        case BLRANGE_OP_FIND_DISTINCT:

            Range1 = BlRangeSelfTest_RandomRange();

            g_fpTestPrintf(g_pTestStream, 
                           "FindDistincts %I64u-%I64u : ",
                           Range1.Start,
                           Range1.End);

            BlRangeListFindDistinctRanges(&RangeList,
                                          &Range1,
                                          NULL,
                                          0,
                                          &NumDistincts);

            g_fpTestPrintf(g_pTestStream, "%u Distincts... ", NumDistincts);

            BufSize = NumDistincts * sizeof(BLCRANGE);
            pDistinctRanges = malloc(BufSize);
                        
            if (!pDistinctRanges) goto get_new_optype;

            if (BlRangeListFindDistinctRanges(&RangeList,
                                              &Range1,
                                              pDistinctRanges,
                                              BufSize,
                                              &NumDistincts) &&
                (BufSize == NumDistincts * sizeof(BLCRANGE)))
            {
                g_fpTestPrintf(g_pTestStream, "SUCCESS\n");
            }
            else
            {
                g_fpTestPrintf(g_pTestStream, "FAIL\n");
                free(pDistinctRanges);
                break;
            }

            for (CurRangeIdx = 0; CurRangeIdx < NumDistincts; CurRangeIdx++)
            {
                g_fpTestPrintf(g_pTestStream, 
                               "  %I64u-%I64u\n",
                               pDistinctRanges[CurRangeIdx].Start,
                               pDistinctRanges[CurRangeIdx].End);
            }

            free(pDistinctRanges);

            break;
            
        default:
            g_fpTestPrintf(g_pTestStream, "ERR: INVALID OP CODE!");
            goto get_new_optype;
        }
    }

    return;
}

#endif // BLRANGE_SELF_TEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\blbindt.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blbind.c

Abstract:

    This module contains the code that implements the funtions required
    to relocate an image and bind DLL entry points.

Author:

    David N. Cutler (davec) 21-May-1991

Revision History:

    Forrest Foltz (forrestf) 10-Jun-2000

        Broke out x86 32/64 code into this module

--*/

ARC_STATUS
BlAllocateDataTableEntry (
    IN PCHAR BaseDllName,
    IN PCHAR FullDllName,
    IN PVOID Base,
    OUT PKLDR_DATA_TABLE_ENTRY *AllocatedEntry
    )

/*++

Routine Description:

    This routine allocates a data table entry for the specified image
    and inserts the entry in the loaded module list.

Arguments:

    BaseDllName - Supplies a pointer to a zero terminated base DLL name.

    FullDllName - Supplies a pointer to a zero terminated full DLL name.

    Base - Supplies a pointer to the base of the DLL image.

    AllocatedEntry - Supplies a pointer to a variable that receives a
        pointer to the allocated data table entry.

Return Value:

    ESUCCESS is returned if a data table entry is allocated. Otherwise,
    return a unsuccessful status.

--*/

{

    PWSTR Buffer;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    PIMAGE_NT_HEADERS NtHeaders;
    USHORT Length;

    //
    // Allocate a data table entry.
    //

    DataTableEntry =
            (PKLDR_DATA_TABLE_ENTRY)BlAllocateHeap(sizeof(KLDR_DATA_TABLE_ENTRY));

    if (DataTableEntry == NULL) {
        return ENOMEM;
    }

    //
    // Initialize the address of the DLL image file header and the entry
    // point address.
    //

    NtHeaders = RtlImageNtHeader(Base);
    DataTableEntry->DllBase = Base;
    DataTableEntry->SizeOfImage = NtHeaders->OptionalHeader.SizeOfImage;
    DataTableEntry->EntryPoint = (PVOID)((ULONG_PTR)Base +
                              NtHeaders->OptionalHeader.AddressOfEntryPoint);
    DataTableEntry->SectionPointer = 0;
    DataTableEntry->CheckSum = NtHeaders->OptionalHeader.CheckSum;

    //
    // Compute the length of the base DLL name, allocate a buffer to hold
    // the name, copy the name into the buffer, and initialize the base
    // DLL string descriptor.
    //

    Length = (USHORT)(strlen(BaseDllName) * sizeof(WCHAR));
    Buffer = (PWSTR)BlAllocateHeap(Length);
    if (Buffer == NULL) {
        return ENOMEM;
    }

    DataTableEntry->BaseDllName.Length = Length;
    DataTableEntry->BaseDllName.MaximumLength = Length;
    DataTableEntry->BaseDllName.Buffer = Buffer;
    while (*BaseDllName != 0) {
        *Buffer++ = *BaseDllName++;
    }

    //
    // Compute the length of the full DLL name, allocate a buffer to hold
    // the name, copy the name into the buffer, and initialize the full
    // DLL string descriptor.
    //

    Length = (USHORT)(strlen(FullDllName) * sizeof(WCHAR));
    Buffer = (PWSTR)BlAllocateHeap(Length);
    if (Buffer == NULL) {
        return ENOMEM;
    }

    DataTableEntry->FullDllName.Length = Length;
    DataTableEntry->FullDllName.MaximumLength = Length;
    DataTableEntry->FullDllName.Buffer = Buffer;
    while (*FullDllName != 0) {
        *Buffer++ = *FullDllName++;
    }

    //
    // Initialize the flags, load count, and insert the data table entry
    // in the loaded module list.
    //

    DataTableEntry->Flags = LDRP_ENTRY_PROCESSED;
    DataTableEntry->LoadCount = 1;
    InsertTailList(&BlLoaderBlock->LoadOrderListHead,
                   &DataTableEntry->InLoadOrderLinks);

    *AllocatedEntry = DataTableEntry;
    return ESUCCESS;
}


ARC_STATUS
BlpBindImportName (
    IN PVOID DllBase,
    IN PVOID ImageBase,
    IN PIMAGE_THUNK_DATA ThunkEntry,
    IN PIMAGE_EXPORT_DIRECTORY ExportDirectory,
    IN ULONG ExportSize,
    IN BOOLEAN SnapForwarder
    )

/*++

Routine Description:

    This routine binds an import table reference with an exported entry
    point and fills in the thunk data.

Arguments:

    DllBase - Supplies the base address of the DLL image that contains
        the export directory.  On x86 systems, a NULL DllBase binds the
        import table reference to the OsLoader's exported entry points.

    ImageBase - Supplies the base address of the image that contains
        the import thunk table.

    ThunkEntry - Supplies a pointer to a thunk table entry.

    ExportDirectory - Supplies a pointer to the export directory of the
        DLL from which references are to be resolved.

    SnapForwarder - determine if the snap is for a forwarder, and therefore
       Address of Data is already setup.

Return Value:

    ESUCCESS is returned if the specified thunk is bound. Otherwise, an
    return an unsuccessful status.

--*/

{

    PULONG FunctionTable;
    LONG High;
    ULONG HintIndex;
    LONG Low;
    LONG Middle;
    PULONG NameTable;
    ULONG Ordinal;
    PUSHORT OrdinalTable;
    LONG Result;
    PUCHAR Temp;

#if defined(_X86_)

    if(DllBase == NULL) {
        DllBase = (PVOID)OsLoaderBase;
    }

#endif

    //
    // If the reference is by ordinal, then compute the ordinal number.
    // Otherwise, lookup the import name in the export directory.
    //

    if (IMAGE_SNAP_BY_ORDINAL(ThunkEntry->u1.Ordinal) && !SnapForwarder) {

        //
        // Compute the ordinal.
        //

        Ordinal = (ULONG)(IMAGE_ORDINAL(ThunkEntry->u1.Ordinal) - ExportDirectory->Base);

    } else {

        if (!SnapForwarder) {
            //
            // Change AddressOfData from an RVA to a VA.
            //

            ThunkEntry->u1.AddressOfData = ((ULONG_PTR)ImageBase + ThunkEntry->u1.AddressOfData);
        }

        //
        // Lookup the import name in the export table to determine the
        // ordinal.
        //

        NameTable = (PULONG)((ULONG_PTR)DllBase +
                                          ExportDirectory->AddressOfNames);

        OrdinalTable = (PUSHORT)((ULONG_PTR)DllBase +
                                          ExportDirectory->AddressOfNameOrdinals);

        //
        // If the hint index is within the limits of the name table and the
        // import and export names match, then the ordinal number can be
        // obtained directly from the ordinal table. Otherwise, the name
        // table must be searched for the specified name.
        //

        HintIndex = ((PIMAGE_IMPORT_BY_NAME)ThunkEntry->u1.AddressOfData)->Hint;
        if ((HintIndex < ExportDirectory->NumberOfNames) &&
            (strcmp(&((PIMAGE_IMPORT_BY_NAME)ThunkEntry->u1.AddressOfData)->Name[0],
                    (PCHAR)((ULONG_PTR)DllBase + NameTable[HintIndex])) == 0)) {

            //
            // Get the ordinal number from the ordinal table.
            //

            Ordinal = OrdinalTable[HintIndex];

        } else {

            //
            // Lookup the import name in the name table using a binary search.
            //

            Low = 0;
            High = ExportDirectory->NumberOfNames - 1;
            while (High >= Low) {

                //
                // Compute the next probe index and compare the import name
                // with the export name entry.
                //

                Middle = (Low + High) >> 1;
                Result = strcmp(&((PIMAGE_IMPORT_BY_NAME)ThunkEntry->u1.AddressOfData)->Name[0],
                                (PCHAR)((ULONG_PTR)DllBase + NameTable[Middle]));

                if (Result < 0) {
                    High = Middle - 1;

                } else if (Result > 0) {
                    Low = Middle + 1;

                } else {
                    break;
                }
            }

            //
            // If the high index is less than the low index, then a matching
            // table entry was not found. Otherwise, get the ordinal number
            // from the ordinal table.
            //

            if (High < Low) {
                return EINVAL;

            } else {
                Ordinal = OrdinalTable[Middle];
            }
        }
    }

    //
    // If the ordinal number is valid, then bind the import reference and
    // return success. Otherwise, return an unsuccessful status.
    //

    if (Ordinal >= ExportDirectory->NumberOfFunctions) {
        return EINVAL;

    } else {
        FunctionTable = (PULONG)((ULONG_PTR)DllBase + ExportDirectory->AddressOfFunctions);
        ThunkEntry->u1.Function = ((ULONG_PTR)DllBase + FunctionTable[Ordinal]);

        //
        // Check for a forwarder.
        //
        if ( ((ULONG_PTR)ThunkEntry->u1.Function > (ULONG_PTR)ExportDirectory) &&
             ((ULONG_PTR)ThunkEntry->u1.Function < ((ULONG_PTR)ExportDirectory + ExportSize)) ) {
            CHAR ForwardDllName[10];
            PKLDR_DATA_TABLE_ENTRY DataTableEntry;
            ULONG TargetExportSize;
            PIMAGE_EXPORT_DIRECTORY TargetExportDirectory;

            RtlCopyMemory(ForwardDllName,
                          (PCHAR)ThunkEntry->u1.Function,
                          sizeof(ForwardDllName));
            Temp = strchr(ForwardDllName,'.');

            ASSERT(Temp != NULL);  // Malformed name, stop here and debug why.

            if (Temp != NULL) {
                *Temp = '\0';
            }

            if (!BlCheckForLoadedDll(ForwardDllName,&DataTableEntry)) {
                //
                // Should load the referenced DLL here, just return failure for now.
                //

                return(EINVAL);
            }
            TargetExportDirectory = (PIMAGE_EXPORT_DIRECTORY)
                RtlImageDirectoryEntryToData(DataTableEntry->DllBase,
                                             TRUE,
                                             IMAGE_DIRECTORY_ENTRY_EXPORT,
                                             &TargetExportSize);
            if (TargetExportDirectory) {

                IMAGE_THUNK_DATA thunkData;
                PIMAGE_IMPORT_BY_NAME addressOfData;
                UCHAR Buffer[128];
                ULONG length;
                PCHAR ImportName;
                ARC_STATUS Status;

                ImportName = strchr((PCHAR)ThunkEntry->u1.Function, '.') + 1;
                addressOfData = (PIMAGE_IMPORT_BY_NAME)Buffer;
                RtlCopyMemory(&addressOfData->Name[0], ImportName, strlen(ImportName)+1);
                addressOfData->Hint = 0;
                thunkData.u1.AddressOfData = (ULONG_PTR)addressOfData;
                Status = BlpBindImportName(DataTableEntry->DllBase,
                                           ImageBase,
                                           &thunkData,
                                           TargetExportDirectory,
                                           TargetExportSize,
                                           TRUE);
                ThunkEntry->u1 = thunkData.u1;
                return(Status);
            } else {
                return(EINVAL);
            }
        }
        return ESUCCESS;
    }
}

ARC_STATUS
BlpScanImportAddressTable(
    IN PVOID DllBase,
    IN PVOID ImageBase,
    IN PIMAGE_THUNK_DATA ThunkTable
    )

/*++

Routine Description:

    This routine scans the import address table for the specified image
    file and snaps each reference.

Arguments:

    DllBase - Supplies the base address of the specified DLL.
        If NULL, then references in the image's import table are to
        be resolved against the osloader's export table.

    ImageBase - Supplies the base address of the image.

    ThunkTable - Supplies a pointer to the import thunk table.

Return Value:

    ESUCCESS is returned in the scan is successful. Otherwise, return an
    unsuccessful status.

--*/

{

    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    ULONG ExportTableSize;
    ARC_STATUS Status;

    //
    // Locate the export table in the image specified by the DLL base
    // address.
    //

#if i386
    if (DllBase == NULL) {
        ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)OsLoaderExports;
        ExportTableSize = 0;    // this is OK as this is only used to bind forwarded exports and osloader does not have any
    } else {
        ExportDirectory =
            (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(DllBase,
                                                                 TRUE,
                                                                 IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                                 &ExportTableSize);
    }
#else
    ExportDirectory =
        (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(DllBase,
                                                             TRUE,
                                                             IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                             &ExportTableSize);
#endif
    if (ExportDirectory == NULL) {
        return EBADF;
    }

    //
    // Scan the thunk table and bind each import reference.
    //

    while (ThunkTable->u1.AddressOfData) {
        Status = BlpBindImportName(DllBase,
                                   ImageBase,
                                   ThunkTable++,
                                   ExportDirectory,
                                   ExportTableSize,
                                   FALSE);
        if (Status != ESUCCESS) {
            return Status;
        }
    }

    return ESUCCESS;
}

ARC_STATUS
BlScanImportDescriptorTable(
    IN PPATH_SET                PathSet,
    IN PKLDR_DATA_TABLE_ENTRY    ScanEntry,
    IN TYPE_OF_MEMORY           MemoryType
    )

/*++

Routine Description:

    This routine scans the import descriptor table for the specified image
    file and loads each DLL that is referenced.

Arguments:

    PathSet - Supplies a pointer to a set of paths to scan when searching
        for DLL's.

    ScanEntry - Supplies a pointer to the data table entry for the
        image whose import table is to be scanned.

    MemoryType - Supplies the type of memory to to be assigned to any DLL's
        referenced.

Return Value:

    ESUCCESS is returned in the scan is successful. Otherwise, return an
    unsuccessful status.

--*/

{

    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    CHAR FullDllName[256];
    PVOID Base;
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    ULONG ImportTableSize;
    ARC_STATUS Status;
    PSZ ImportName;
    ULONG Index;
    PPATH_SOURCE PathSource;

    //
    // Locate the import table in the image specified by the data table entry.
    //

    ImportDescriptor =
        (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(ScanEntry->DllBase,
                                                              TRUE,
                                                              IMAGE_DIRECTORY_ENTRY_IMPORT,
                                                              &ImportTableSize);

    //
    // If the image has an import directory, then scan the import table and
    // load the specified DLLs.
    //

    if (ImportDescriptor != NULL) {
        while ((ImportDescriptor->Name != 0) &&
               (ImportDescriptor->FirstThunk != 0)) {

            //
            // Change the name from an RVA to a VA.
            //

            ImportName = (PSZ)((ULONG_PTR)ScanEntry->DllBase + ImportDescriptor->Name);

            //
            // If the DLL references itself, then skip the import entry.
            //

            if (BlpCompareDllName((PCHAR)ImportName,
                                  &ScanEntry->BaseDllName) == FALSE) {

                //
                // If the DLL is not already loaded, then load the DLL and
                // scan its import table.
                //

                if (BlCheckForLoadedDll((PCHAR)ImportName,
                                        &DataTableEntry) == FALSE) {

                    //
                    // Start walking our list of DevicePaths. If the list is
                    // empty (bad caller!) we fail with ENOENT.
                    //
                    Status = ENOENT;
                    for(Index=0; Index < PathSet->PathCount; Index++) {

                        PathSource = &PathSet->Source[Index];

                        strcpy(&FullDllName[0], PathSource->DirectoryPath);
                        strcat(&FullDllName[0], PathSet->PathOffset);
                        strcat(&FullDllName[0], (PCHAR)ImportName);

                        Status = BlLoadImage(
                            PathSource->DeviceId,
                            MemoryType,
                            &FullDllName[0],
                            TARGET_IMAGE,
                            &Base
                            );

                        if (Status == ESUCCESS) {

                            BlOutputLoadMessage(
                                (PCHAR) PathSource->DeviceName,
                                &FullDllName[0],
                                NULL
                                );

                            break;
                        }
                    }

                    if (Status != ESUCCESS) {
                        return Status;
                    }

                    //
                    // ISSUE - 2000/29/03 - ADRIAO: Existant namespace polution
                    //     For the FullDllName field We should really be passing
                    // in AliasName\PathOffset\ImportName.
                    //
                    Status = BlAllocateDataTableEntry((PCHAR)ImportName,
                                                      &FullDllName[0],
                                                      Base,
                                                      &DataTableEntry);

                    if (Status != ESUCCESS) {
                        return Status;
                    }

                    DataTableEntry->Flags |= (ScanEntry->Flags & LDRP_DRIVER_DEPENDENT_DLL);

                    Status = BlScanImportDescriptorTable(PathSet,
                                                         DataTableEntry,
                                                         MemoryType);

                    if (Status != ESUCCESS) {
                        return Status;
                    }

                    //
                    // BlAllocateDataTableEntry inserts the data table entry into the load order
                    // linked list in the order the dlls were found. We want the order to be the
                    // order of dependency. For example if driver A needed Dll B which needed Dll C
                    // we want the order to be ACB and not ABC. So here we remove this DLLs entry
                    // and add it at the end. This way when IoInitializeBootDrivers calls DllInitialize
                    // it will call them in the right order.
                    //
                    if (DataTableEntry->Flags &LDRP_DRIVER_DEPENDENT_DLL) {
                        RemoveEntryList(&(DataTableEntry)->InLoadOrderLinks);
                        InsertTailList(&BlLoaderBlock->LoadOrderListHead,
                                       &DataTableEntry->InLoadOrderLinks);
                    }

                } else {
                    //
                    // Dll already exists but it might not be marked as a driver dependent DLL.
                    // For example it might be a driver. So mark it now.
                    //
                    DataTableEntry->Flags |= (ScanEntry->Flags & LDRP_DRIVER_DEPENDENT_DLL);
                }

                //
                // Scan the import address table and snap links.
                //

                Status = BlpScanImportAddressTable(DataTableEntry->DllBase,
                            ScanEntry->DllBase,
                            (PIMAGE_THUNK_DATA)((ULONG_PTR)ScanEntry->DllBase +
                                                ImportDescriptor->FirstThunk));

                if (Status != ESUCCESS) {
                    return Status;
                }
            }

            ImportDescriptor += 1;
        }
    }

    return ESUCCESS;
}

ARC_STATUS
BlScanOsloaderBoundImportTable (
    IN PKLDR_DATA_TABLE_ENTRY ScanEntry
    )

/*++

Routine Description:

    This routine scans the import descriptor table for the specified image
    file and loads each DLL that is referenced.

Arguments:

    DataTableEntry - Supplies a pointer to the data table entry for the
        image whose import table is to be scanned.

Return Value:

    ESUCCESS is returned in the scan is successful. Otherwise, return an
    unsuccessful status.

--*/

{

    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    ULONG ImportTableSize;
    ARC_STATUS Status;
    PSZ ImportName;

    //
    // Locate the import table in the image specified by the data table entry.
    //

    ImportDescriptor =
        (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(ScanEntry->DllBase,
                                                              TRUE,
                                                              IMAGE_DIRECTORY_ENTRY_IMPORT,
                                                              &ImportTableSize);

    //
    // If the image has an import directory, then scan the import table.
    //

    if (ImportDescriptor != NULL) {
        while ((ImportDescriptor->Name != 0) &&
               (ImportDescriptor->FirstThunk != 0)) {

            //
            // Change the name from an RVA to a VA.
            //

            ImportName = (PSZ)((ULONG_PTR)ScanEntry->DllBase + ImportDescriptor->Name);

            //
            // If the DLL references itself, then skip the import entry.
            //

            if (BlpCompareDllName((PCHAR)ImportName,
                                  &ScanEntry->BaseDllName) == FALSE) {

                //
                // Scan the import address table and snap links.
                //

                Status = BlpScanImportAddressTable(NULL,
                            ScanEntry->DllBase,
                            (PIMAGE_THUNK_DATA)((ULONG_PTR)ScanEntry->DllBase +
                            ImportDescriptor->FirstThunk));

                if (Status != ESUCCESS) {
                    return Status;
                }
            }

            ImportDescriptor += 1;
        }
    }

    return ESUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\blmemory.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blmemory.c

Abstract:

    This module implements the OS loader memory allocation routines.

Author:

    David N. Cutler (davec) 19-May-1991

Revision History:

--*/

#include "bldr.h"

#if defined(_X86_)
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#include <stdlib.h>
#include <ntverp.h>

#define MIN(_a,_b) (((_a) <= (_b)) ? (_a) : (_b))
#define MAX(_a,_b) (((_a) >= (_b)) ? (_a) : (_b))

#define IsTrackMem(t) ((t != LoaderFree) &&                 \
                       (t != LoaderBad)  &&                 \
                       (t != LoaderFirmwareTemporary) &&    \
                       (t != LoaderOsloaderStack) &&        \
                       (t != LoaderXIPRom) &&               \
                       (t != LoaderReserve))


//
// The first PDE page is always mapped, on PAE this is the bottom 2MB
//
#define ALWAYS_MAPPED ((2*1024*1024) >> PAGE_SHIFT)

#define IsValidTrackingRange(b,n) (((b+n) > ALWAYS_MAPPED) ? TRUE :FALSE)

ALLOCATION_POLICY BlMemoryAllocationPolicy = BlAllocateBestFit;
ALLOCATION_POLICY BlHeapAllocationPolicy = BlAllocateBestFit;

//
// Define memory allocation descriptor listhead and heap storage variables.
//

ULONG_PTR BlHeapFree;
ULONG_PTR BlHeapLimit;
PLOADER_PARAMETER_BLOCK BlLoaderBlock;
ULONG BlHighestPage;
ULONG BlLowestPage;

//
// Global Value for where to load the kernel
//
BOOLEAN BlOldKernel = FALSE;
BOOLEAN BlRestoring = FALSE;
BOOLEAN BlKernelChecked = FALSE;

//
// Define the lowest and highest usable pages
//
#if defined(_X86_)

//
// X86 is limited to the first 512MB of physical address space
// Until BlMemoryInitialize has happened, we want to limit things
// to the first 16MB as that is all that has been mapped.
//
ULONG BlUsableBase=0;
ULONG BlUsableLimit=((16*1024*1024)/PAGE_SIZE);        // 16MB

#elif defined(_IA64_)

//
// IA64 only has enough TRs to map the region between 16MB and
// 80MB. 
//
ULONG BlUsableBase  = _16MB;
ULONG BlUsableLimit = _80MB;

#else

ULONG BlUsableBase = 0;
ULONG BlUsableLimit = 0xffffffff;

#endif



TYPE_OF_MEMORY
BlpDetermineAllocationPolicy (
   TYPE_OF_MEMORY MemoryType,
   ULONG BasePage,
   ULONG PageCount,
   BOOLEAN Retry
   );

void
BlpTrackUsage (
    MEMORY_TYPE MemoryType,
    ULONG ActualBase,
    ULONG  NumberPages
    );


#if DBG
ULONG_PTR TotalHeapAbandoned = 0;
#endif



//
// WARNING: (x86 only) Use this carefully. Currently only temporary buffers
// are allocated top down. The kernel and drivers are loaded bottom up
// this has an effect on PAE. Since the PAE kernel loads at 16MB
// only temp buffers can be above 16MB. If drivers are loaded there the
// system will fail
//
VOID
BlSetAllocationPolicy (
    IN ALLOCATION_POLICY MemoryAllocationPolicy,
    IN ALLOCATION_POLICY HeapAllocationPolicy
    )
{
    BlMemoryAllocationPolicy = MemoryAllocationPolicy;
    BlHeapAllocationPolicy = HeapAllocationPolicy;

    return;
}

VOID
BlInsertDescriptor (
    IN PMEMORY_ALLOCATION_DESCRIPTOR NewDescriptor
    )

/*++

Routine Description:

    This routine inserts a memory descriptor in the memory allocation list.
    It inserts the new descriptor in sorted order, based on the starting
    page of the block.  It also merges adjacent blocks of free memory.

Arguments:

    ListHead - Supplies the address of the memory allocation list head.

    NewDescriptor - Supplies the address of the descriptor that is to be
        inserted.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListHead = &BlLoaderBlock->MemoryDescriptorListHead;
    PLIST_ENTRY PreviousEntry;
    PMEMORY_ALLOCATION_DESCRIPTOR PreviousDescriptor;
    PLIST_ENTRY NextEntry;
    PMEMORY_ALLOCATION_DESCRIPTOR NextDescriptor;

    //
    // Find the first descriptor in the list that starts above the new
    // descriptor.  The new descriptor goes in front of this descriptor.
    //

    PreviousEntry = ListHead;
    NextEntry = ListHead->Flink;
    while (NextEntry != ListHead) {
        NextDescriptor = CONTAINING_RECORD(NextEntry,
                                           MEMORY_ALLOCATION_DESCRIPTOR,
                                           ListEntry);
        if (NewDescriptor->BasePage < NextDescriptor->BasePage) {
            break;
        }
        PreviousEntry = NextEntry;
        PreviousDescriptor = NextDescriptor;
        NextEntry = NextEntry->Flink;
    }

    //
    // If the new descriptor doesn't describe free memory, just insert it
    // in the list in front of the previous entry.  Otherwise, check to see
    // if free blocks can be merged.
    //

    if (NewDescriptor->MemoryType != LoaderFree) {

        InsertHeadList(PreviousEntry, &NewDescriptor->ListEntry);

    } else {

        //
        // If the previous block also describes free memory, and it's
        // contiguous with the new block, merge them by adding the
        // page count from the new
        //

        if ((PreviousEntry != ListHead) &&
            ((PreviousDescriptor->MemoryType == LoaderFree) ||
             (PreviousDescriptor->MemoryType == LoaderReserve) ) &&
            ((PreviousDescriptor->BasePage + PreviousDescriptor->PageCount) ==
                                                                    NewDescriptor->BasePage)) {
            PreviousDescriptor->PageCount += NewDescriptor->PageCount;
            NewDescriptor = PreviousDescriptor;
        } else {
            InsertHeadList(PreviousEntry, &NewDescriptor->ListEntry);
        }
        if ((NextEntry != ListHead) &&
            ((NextDescriptor->MemoryType == LoaderFree) ||
             (NextDescriptor->MemoryType == LoaderReserve)) &&
            ((NewDescriptor->BasePage + NewDescriptor->PageCount) == NextDescriptor->BasePage)) {
            NewDescriptor->PageCount += NextDescriptor->PageCount;
            NewDescriptor->MemoryType = NextDescriptor->MemoryType;
            BlRemoveDescriptor(NextDescriptor);
        }
    }

    return;
}

ARC_STATUS
BlMemoryInitialize (
    VOID
    )

/*++

Routine Description:

    This routine allocates stack space for the OS loader, initializes
    heap storage, and initializes the memory allocation list.

Arguments:

    None.

Return Value:

    ESUCCESS is returned if the initialization is successful. Otherwise,
    ENOMEM is returned.

--*/

{

    PMEMORY_ALLOCATION_DESCRIPTOR AllocationDescriptor;
    PMEMORY_DESCRIPTOR HeapDescriptor;
    PMEMORY_DESCRIPTOR MemoryDescriptor;
    PMEMORY_DESCRIPTOR ProgramDescriptor;
    ULONG EndPage;
    ULONG HeapAndStackPages;
    ULONG StackPages;
    ULONG StackBasePage;
    ULONG i;
    CHAR versionBuffer[64];
    PCHAR major;
    PCHAR minor;


    //
    // This code doesn't work under EFI -- we can have multiple 
    // MemoryLoadedProgram descriptors under EFI.  We also cannot make the
    // same assumptions about finding a free descriptor below
    // the os loader for a stack and heap as under ARC.  Instead, we'll just
    // search for any suitable place for a heap and stack
    //
#ifndef EFI
    //
    // Find the memory descriptor that describes the allocation for the OS
    // loader itself.
    //

    ProgramDescriptor = NULL;
    while ((ProgramDescriptor = ArcGetMemoryDescriptor(ProgramDescriptor)) != NULL) {
        if (ProgramDescriptor->MemoryType == MemoryLoadedProgram) {
            break;
        }
    }

    //
    // If a loaded program memory descriptor was found, then it must be
    // for the OS loader since that is the only program that can be loaded.
    // If a loaded program memory descriptor was not found, then firmware
    // is not functioning properly and an unsuccessful status is returned.
    //

    if (ProgramDescriptor == NULL) {
        DBGTRACE( TEXT("Couldn't find ProgramDescriptor\r\n"));
        return ENOMEM;
    }

    //
    // Find the free memory descriptor that is just below the loaded
    // program in memory. There should be several megabytes of free
    // memory just preceeding the OS loader.
    //

    StackPages = BL_STACK_PAGES;
    HeapAndStackPages = BL_HEAP_PAGES + BL_STACK_PAGES;

    HeapDescriptor = NULL;
    while ((HeapDescriptor = ArcGetMemoryDescriptor(HeapDescriptor)) != NULL) {
        if (((HeapDescriptor->MemoryType == MemoryFree) ||
            (HeapDescriptor->MemoryType == MemoryFreeContiguous)) &&
            ((HeapDescriptor->BasePage + HeapDescriptor->PageCount) ==
                                                        ProgramDescriptor->BasePage)) {
            break;
        }
    }
#else
    StackPages = BL_STACK_PAGES;
    HeapAndStackPages = BL_HEAP_PAGES + BL_STACK_PAGES;
    HeapDescriptor = NULL;
#endif
    //
    // If a free memory descriptor was not found that describes the free
    // memory just below the OS loader, or the memory descriptor is not
    // large enough for the OS loader stack and heap, then try and find
    // a suitable one.
    //
    if ((HeapDescriptor == NULL) ||
        (HeapDescriptor->PageCount < (BL_HEAP_PAGES + BL_STACK_PAGES))) {

        HeapDescriptor = NULL;
        while ((HeapDescriptor = ArcGetMemoryDescriptor(HeapDescriptor)) != NULL) {
#if defined(_IA64_)
            //
            // We only have enough TR's to map the region between 16 MB
            // and 80 MB.  So we ignore anything that's not in that range
            //
            if ((HeapDescriptor->BasePage < _48MB) &&
                (HeapDescriptor->BasePage >= _16MB)) {
#endif            
                if (((HeapDescriptor->MemoryType == MemoryFree) ||
                    (HeapDescriptor->MemoryType == MemoryFreeContiguous)) &&
                    (HeapDescriptor->PageCount >= (BL_HEAP_PAGES + BL_STACK_PAGES))) {
                    break;
                }
#if defined(_IA64_)
            }
#endif
        }
    }

    //
    // A suitable descriptor could not be found, return an unsuccessful
    // status.
    //
    if (HeapDescriptor == NULL) {
        DBGTRACE( TEXT("Couldn't find HeapDescriptor\r\n"));
        return(ENOMEM);
    }

    StackBasePage = HeapDescriptor->BasePage + HeapDescriptor->PageCount - BL_STACK_PAGES;

    //
    // Compute the address of the loader heap, initialize the heap
    // allocation variables, and zero the heap memory.
    //
    EndPage = HeapDescriptor->BasePage + HeapDescriptor->PageCount;

    BlpTrackUsage (LoaderOsloaderHeap,HeapDescriptor->BasePage,HeapDescriptor->PageCount);
    BlHeapFree = KSEG0_BASE | ((EndPage - HeapAndStackPages) << PAGE_SHIFT);


    //
    // always reserve enough space in the heap for one more memory
    // descriptor, so we can go create more heap if we run out.
    //
    BlHeapLimit = (BlHeapFree + (BL_HEAP_PAGES << PAGE_SHIFT)) - sizeof(MEMORY_ALLOCATION_DESCRIPTOR);

    RtlZeroMemory((PVOID)BlHeapFree, BL_HEAP_PAGES << PAGE_SHIFT);

    //
    // Allocate and initialize the loader parameter block.
    //

    BlLoaderBlock =
        (PLOADER_PARAMETER_BLOCK)BlAllocateHeap(sizeof(LOADER_PARAMETER_BLOCK));

    if (BlLoaderBlock == NULL) {
        DBGTRACE( TEXT("Couldn't initialize loader block\r\n"));
        return ENOMEM;
    }

    BlLoaderBlock->Extension =
        (PLOADER_PARAMETER_EXTENSION)
        BlAllocateHeap(sizeof(LOADER_PARAMETER_EXTENSION));

    if (BlLoaderBlock->Extension == NULL) {
        DBGTRACE( TEXT("Couldn't initialize loader block extension\r\n"));
        return ENOMEM;
    }

    BlLoaderBlock->Extension->Size = sizeof (LOADER_PARAMETER_EXTENSION);
    major = strcpy(versionBuffer, VER_PRODUCTVERSION_STR);
    minor = strchr(major, '.');
    *minor++ = '\0';
    BlLoaderBlock->Extension->MajorVersion = atoi(major);
    BlLoaderBlock->Extension->MinorVersion = atoi(minor);
    BlLoaderBlock->Extension->InfFileImage = NULL;
    BlLoaderBlock->Extension->InfFileSize = 0;


    InitializeListHead(&BlLoaderBlock->LoadOrderListHead);
    InitializeListHead(&BlLoaderBlock->MemoryDescriptorListHead);

    //
    // Copy the memory descriptor list from firmware into the local heap and
    // deallocate the loader heap and stack from the free memory descriptor.
    //

    MemoryDescriptor = NULL;
    while ((MemoryDescriptor = ArcGetMemoryDescriptor(MemoryDescriptor)) != NULL) {
        AllocationDescriptor =
                    (PMEMORY_ALLOCATION_DESCRIPTOR)BlAllocateHeap(
                                        sizeof(MEMORY_ALLOCATION_DESCRIPTOR));

        if (AllocationDescriptor == NULL) {
            DBGTRACE( TEXT("Couldn't allocate heap for memory allocation descriptor\r\n"));
            return ENOMEM;
        }

        AllocationDescriptor->MemoryType =
                                    (TYPE_OF_MEMORY)MemoryDescriptor->MemoryType;

        if (MemoryDescriptor->MemoryType == MemoryFreeContiguous) {
            AllocationDescriptor->MemoryType = LoaderFree;

        } else if (MemoryDescriptor->MemoryType == MemorySpecialMemory) {
            AllocationDescriptor->MemoryType = LoaderSpecialMemory;
        }

        AllocationDescriptor->BasePage = MemoryDescriptor->BasePage;
        AllocationDescriptor->PageCount = MemoryDescriptor->PageCount;
        if (MemoryDescriptor == HeapDescriptor) {
            AllocationDescriptor->PageCount -= HeapAndStackPages;
        }

        //
        // [chuckl 11/19/2001, fixing a bug from 11/15/1993]
        //
        // In rare cases, the above subtraction of HeapAndStackPages from
        // PageCount can result in a PageCount of 0. MM doesn't like this,
        // so don't insert the descriptor if PageCount is 0. The side
        // effect of this is that we "lose" a descriptor, but that's just
        // a few bytes of heap lost.
        //

        if (AllocationDescriptor->PageCount != 0) {
            BlInsertDescriptor(AllocationDescriptor);
        }
    }

    //
    // Allocate a memory descriptor for the loader stack.
    //

    if (StackPages != 0) {

        AllocationDescriptor =
                (PMEMORY_ALLOCATION_DESCRIPTOR)BlAllocateHeap(
                                        sizeof(MEMORY_ALLOCATION_DESCRIPTOR));

        if (AllocationDescriptor == NULL) {
            DBGTRACE( TEXT("Couldn't allocate heap for loader stack\r\n"));
            return ENOMEM;
        }

        AllocationDescriptor->MemoryType = LoaderOsloaderStack;
        AllocationDescriptor->BasePage = StackBasePage;
        AllocationDescriptor->PageCount = BL_STACK_PAGES;
        BlInsertDescriptor(AllocationDescriptor);
    }

    //
    // Allocate a memory descriptor for the loader heap.
    //

    AllocationDescriptor =
                (PMEMORY_ALLOCATION_DESCRIPTOR)BlAllocateHeap(
                                    sizeof(MEMORY_ALLOCATION_DESCRIPTOR));

    if (AllocationDescriptor == NULL) {
        DBGTRACE( TEXT("Couldn't allocate heap for loader heap\r\n"));
        return ENOMEM;
    }

    AllocationDescriptor->MemoryType = LoaderOsloaderHeap;
    AllocationDescriptor->BasePage = EndPage - HeapAndStackPages;

    AllocationDescriptor->PageCount = BL_HEAP_PAGES;
    BlInsertDescriptor(AllocationDescriptor);

    return ESUCCESS;
}


ARC_STATUS
BlAllocateAlignedDescriptor (
    IN TYPE_OF_MEMORY MemoryType,
    IN ULONG BasePage,
    IN ULONG PageCount,
    IN ULONG Alignment,
    OUT PULONG ActualBase
    )

/*++

Routine Description:

    This routine allocates memory and generates one of more memory
    descriptors to describe the allocated region. The first attempt
    is to allocate the specified region of memory (at BasePage).
    If the memory is not free, then the smallest region of free
    memory that satisfies the request is allocated.  The Alignment
    parameter can be used to force the block to be allocated at a
    particular alignment.

Arguments:

    MemoryType - Supplies the memory type that is to be assigned to
        the generated descriptor.

    BasePage - Supplies the base page number of the desired region.
        If 0, no particular base page is required.

    PageCount - Supplies the number of pages required.

    Alignment - Supplies the required alignment, in pages.  (E.g.,
        with 4K page size, 16K alignment requires Alignment == 4.)
        If 0, no particular alignment is required.

        N.B.  If BasePage is not 0, and the specified BasePage is
        available, Alignment is ignored.  It is up to the caller
        to specify a BasePage that meets the caller's alignment
        requirement.

    ActualBase - Supplies a pointer to a variable that receives the
        page number of the allocated region.

Return Value:

    ESUCCESS is returned if an available block of free memory can be
    allocated. Otherwise, return a unsuccessful status.

--*/

{

    PMEMORY_ALLOCATION_DESCRIPTOR FreeDescriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR NextDescriptor;
    PLIST_ENTRY NextEntry;
    ARC_STATUS Status;
    ULONG AlignedBasePage, AlignedPageCount;
    ULONG FreeBasePage, FreePageCount;
    MEMORY_TYPE TypeToUse;
    ALLOCATION_POLICY OldPolicy = BlMemoryAllocationPolicy;
    BOOLEAN retryalloc=FALSE;

    //
    // Simplify the alignment checks by changing 0 to 1.
    //

    if (Alignment == 0) {
        Alignment = 1;
    }

    //
    // If the allocation is for zero pages, make it one, because allocation of zero
    // breaks the internal algorithms for merging, etc.
    //
    if (PageCount == 0) {
        PageCount = 1;
    }


    //
    // Attempt to find a free memory descriptor that encompasses the
    // specified region or a free memory descriptor that is large
    // enough to satisfy the request.
    //

retry:

    TypeToUse=BlpDetermineAllocationPolicy (MemoryType,BasePage,PageCount,retryalloc);

    //
    // If a base page was specified, find the containing descriptor and try and use
    // that directly.
    //
    if (BasePage &&
        (BasePage >= BlUsableBase) &&
        (BasePage + PageCount <= BlUsableLimit)) {

        FreeDescriptor = BlFindMemoryDescriptor(BasePage);
        if ((FreeDescriptor) &&
            (FreeDescriptor->MemoryType == TypeToUse) &&
            (FreeDescriptor->BasePage + FreeDescriptor->PageCount >= BasePage + PageCount)) {

            Status = BlGenerateDescriptor(FreeDescriptor,
                                          MemoryType,
                                          BasePage,
                                          PageCount);

            *ActualBase = BasePage;
            BlpTrackUsage (TypeToUse,*ActualBase,PageCount);
            if (BlpCheckMapping (BasePage,PageCount+1) != ESUCCESS) {
                BlMemoryAllocationPolicy=OldPolicy;
                return (ENOMEM);
            }
            BlMemoryAllocationPolicy=OldPolicy;
            return Status;
        }
    }

    FreeDescriptor = NULL;
    NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextEntry != &BlLoaderBlock->MemoryDescriptorListHead) {

        NextDescriptor = CONTAINING_RECORD(NextEntry,
                                           MEMORY_ALLOCATION_DESCRIPTOR,
                                           ListEntry);

        AlignedBasePage = (NextDescriptor->BasePage + (Alignment - 1)) & ~(Alignment - 1);
        AlignedPageCount= NextDescriptor->PageCount - (AlignedBasePage - NextDescriptor->BasePage);

        if ((NextDescriptor->MemoryType == TypeToUse) &&
            (AlignedPageCount <= NextDescriptor->PageCount) &&
            (AlignedBasePage + AlignedPageCount > BlUsableBase) &&
            (AlignedBasePage <= BlUsableLimit)) {

            //
            // Adjust bounds to account for the usable limits
            //
            if (AlignedBasePage < BlUsableBase) {
                AlignedBasePage = (BlUsableBase + (Alignment - 1)) & ~(Alignment - 1);
                AlignedPageCount= NextDescriptor->PageCount - (AlignedBasePage - NextDescriptor->BasePage);
            }
            if (AlignedBasePage + AlignedPageCount > BlUsableLimit) {
                AlignedPageCount = BlUsableLimit - AlignedBasePage;
            }

            if (PageCount <= AlignedPageCount) {

                //
                // This block will work.  If the allocation policy is
                // LowestFit, take this block (the memory list is sorted).
                // Otherwise, if this block best meets the allocation
                // policy, remember it and keep looking.
                //
                if (BlMemoryAllocationPolicy == BlAllocateLowestFit) {
                    FreeDescriptor = NextDescriptor;
                    FreeBasePage   = AlignedBasePage;
                    FreePageCount  = AlignedPageCount;
                    break;
                } else if ((FreeDescriptor == NULL) ||
                           (BlMemoryAllocationPolicy == BlAllocateHighestFit) ||
                           ((FreeDescriptor != NULL) &&
                            (AlignedPageCount < FreePageCount))) {
                    FreeDescriptor = NextDescriptor;
                    FreeBasePage   = AlignedBasePage;
                    FreePageCount  = AlignedPageCount;
                }
            }
        }

        NextEntry = NextEntry->Flink;
    }

    //
    // If a free region that satisfies the request was found, then allocate
    // the space from that descriptor. Otherwise, return an unsuccessful status.
    //
    // If allocating lowest-fit or best-fit, allocate from the start of the block,
    // rounding up to the required alignment.  If allocating highest-fit, allocate
    // from the end of the block, rounding down to the required alignment.
    //

    if (FreeDescriptor != NULL) {

#if defined(EFI)
        if (MemoryType == LoaderXIPRom) {
            FreeDescriptor->MemoryType = LoaderFirmwareTemporary;
        }
#endif

        if (BlMemoryAllocationPolicy == BlAllocateHighestFit) {
            AlignedBasePage = (FreeBasePage + FreePageCount - PageCount) & ~(Alignment - 1);
        }
        *ActualBase = AlignedBasePage;
        BlpTrackUsage (TypeToUse,*ActualBase,PageCount);
        if (BlpCheckMapping (AlignedBasePage,PageCount+1) != ESUCCESS) {
            BlMemoryAllocationPolicy=OldPolicy;
            return (ENOMEM);
        }
        BlMemoryAllocationPolicy=OldPolicy;
        return BlGenerateDescriptor(FreeDescriptor,
                                    MemoryType,
                                    AlignedBasePage,
                                    PageCount);

    } else {
        //
        // Invade the MemoryLoaderReserve pool.
        //

        if (BlOldKernel || (retryalloc == TRUE)) {
            BlMemoryAllocationPolicy=OldPolicy;
            return ENOMEM;
        } else {
            retryalloc=TRUE;
            goto retry;
        }
    }
}


ARC_STATUS
BlFreeDescriptor (
    IN ULONG BasePage
    )

/*++

Routine Description:

    This routine free the memory block starting at the specified base page.

Arguments:

    BasePage - Supplies the base page number of the region to be freed.

Return Value:

    ESUCCESS.

--*/

{

    PMEMORY_ALLOCATION_DESCRIPTOR NextDescriptor;
    PLIST_ENTRY NextEntry;

    //
    // Attempt to find a memory descriptor that starts at the
    // specified base page.
    //

    NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextEntry != &BlLoaderBlock->MemoryDescriptorListHead) {
        NextDescriptor = CONTAINING_RECORD(NextEntry,
                                           MEMORY_ALLOCATION_DESCRIPTOR,
                                           ListEntry);

        if (NextDescriptor->BasePage == BasePage) {
            if ((NextDescriptor->MemoryType != LoaderFree)) {
                NextDescriptor->MemoryType = LoaderFree;

                if ((NextDescriptor->BasePage+NextDescriptor->PageCount) == BlHighestPage) {
                    //
                    // Freeing the last descriptor. Set the highest page to 1 before us.
                    // -- this doesn't work if the guy before is free too...but....
                    //
                    BlHighestPage = NextDescriptor->BasePage +1;
                } else if (NextDescriptor->BasePage == BlLowestPage) {
                    BlLowestPage = NextDescriptor->BasePage + NextDescriptor->PageCount;
                }
                BlRemoveDescriptor(NextDescriptor);
                BlInsertDescriptor(NextDescriptor);
            }
            return ESUCCESS;
        }

        NextEntry = NextEntry->Flink;
    }

    //
    // The caller is confused and should be ignored.
    //

    return ESUCCESS;
}


PVOID
BlAllocateHeapAligned (
    IN ULONG Size
    )

/*++

Routine Description:

    This routine allocates memory from the OS loader heap.  The memory
    will be allocated on a cache line boundary.

Arguments:

    Size - Supplies the size of block required in bytes.

Return Value:

    If a free block of memory of the specified size is available, then
    the address of the block is returned. Otherwise, NULL is returned.

--*/

{
    PVOID Buffer;

    Buffer = BlAllocateHeap(Size + BlDcacheFillSize - 1);
    if (Buffer != NULL) {
        //
        // round up to a cache line boundary
        //
        Buffer = ALIGN_BUFFER(Buffer);
    }

    return(Buffer);

}

PVOID
BlAllocateHeap (
    IN ULONG Size
    )

/*++

Routine Description:

    This routine allocates memory from the OS loader heap.

Arguments:

    Size - Supplies the size of block required in bytes.

Return Value:

    If a free block of memory of the specified size is available, then
    the address of the block is returned. Otherwise, NULL is returned.

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR AllocationDescriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR FreeDescriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR NextDescriptor;
    PLIST_ENTRY NextEntry;
    ULONG NewHeapPages;
    ULONG LastAttempt;
    PVOID Block;

    //
    // Round size up to next allocation boundary and attempt to allocate
    // a block of the requested size.
    //

    Size = (Size + (BL_GRANULARITY - 1)) & (~(BL_GRANULARITY - 1));

    Block = (PVOID)BlHeapFree;
    if ((BlHeapFree + Size) <= BlHeapLimit) {
        BlHeapFree += Size;
        return Block;

    } else {

#if DBG
        TotalHeapAbandoned += (BlHeapLimit - BlHeapFree);
        BlLog((LOG_ALL_W,"ABANDONING %d bytes of heap; total abandoned %d\n",
            (BlHeapLimit - BlHeapFree), TotalHeapAbandoned));
#endif

        //
        // Our heap is full.  BlHeapLimit always reserves enough space
        // for one more MEMORY_ALLOCATION_DESCRIPTOR, so use that to
        // go try and find more free memory we can use.
        //
        AllocationDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR)BlHeapLimit;

        //
        // Attempt to find a free memory descriptor big enough to hold this
        // allocation or BL_HEAP_PAGES, whichever is bigger.
        //
        NewHeapPages = ((Size + sizeof(MEMORY_ALLOCATION_DESCRIPTOR) + (PAGE_SIZE-1)) >> PAGE_SHIFT);
        if (NewHeapPages < BL_HEAP_PAGES) {
            NewHeapPages = BL_HEAP_PAGES;
        }

        if (!BlOldKernel && BlVirtualBias) {
            BlHeapAllocationPolicy = BlAllocateHighestFit;
        }else {
            BlHeapAllocationPolicy = BlAllocateLowestFit;
        }

        do {

            FreeDescriptor = NULL;
            NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
            while (NextEntry != &BlLoaderBlock->MemoryDescriptorListHead) {
                NextDescriptor = CONTAINING_RECORD(NextEntry,
                                                   MEMORY_ALLOCATION_DESCRIPTOR,
                                                   ListEntry);

#if defined(_IA64_)
                //
                // We only have enough TR's to map the region between 16 MB
                // and 80 MB.  So we ignore anything that's not in that range
                //
                if ((NextDescriptor->BasePage < _48MB) && 
                    (NextDescriptor->BasePage >= _16MB)) {                
#endif            
                    if ((NextDescriptor->MemoryType == LoaderFree) &&
                        (NextDescriptor->PageCount >= NewHeapPages)) {
    
                        //
                        // This block will work.  If the allocation policy is
                        // LowestFit, take this block (the memory list is sorted).
                        // Otherwise, if this block best meets the allocation
                        // policy, remember it and keep looking.
                        //
    
                        if (BlHeapAllocationPolicy == BlAllocateLowestFit) {
                            FreeDescriptor = NextDescriptor;
                            break;
                        }
    
                        if ((FreeDescriptor == NULL) ||
                            (BlHeapAllocationPolicy == BlAllocateHighestFit) ||
                            ((FreeDescriptor != NULL) &&
                             (NextDescriptor->PageCount < FreeDescriptor->PageCount))) {
                            FreeDescriptor = NextDescriptor;
                        }
                    }
#if defined(_IA64_)
                }
#endif
                NextEntry = NextEntry->Flink;

            }

            //
            // If we were unable to find a block of the desired size, memory
            // must be getting tight, so try again, this time looking just
            // enough to keep us going.  (The first time through, we try to
            // allocate at least BL_HEAP_PAGES.)
            //
            if (FreeDescriptor != NULL) {
                break;
            }
            LastAttempt = NewHeapPages;
            NewHeapPages = ((Size + sizeof(MEMORY_ALLOCATION_DESCRIPTOR) + (PAGE_SIZE-1)) >> PAGE_SHIFT);
            if (NewHeapPages == LastAttempt) {
                break;
            }

        } while (TRUE);

        if (FreeDescriptor == NULL) {

            //
            // No free memory left.
            //
            return(NULL);
        }

        //
        // We've found a descriptor that's big enough.  Just carve a
        // piece off the end and use that for our heap.  If we're taking
        // all of the memory from the descriptor, remove it from the
        // memory list.  (This wastes a descriptor, but that's life.)
        //

        FreeDescriptor->PageCount -= NewHeapPages;
        if (FreeDescriptor->PageCount == 0) {
            BlRemoveDescriptor(FreeDescriptor);
        }

        //
        // Initialize our new descriptor and add it to the list.
        //
        AllocationDescriptor->MemoryType = LoaderOsloaderHeap;
        AllocationDescriptor->BasePage = FreeDescriptor->BasePage +
            FreeDescriptor->PageCount;
        AllocationDescriptor->PageCount = NewHeapPages;

        BlpTrackUsage (LoaderOsloaderHeap,AllocationDescriptor->BasePage,AllocationDescriptor->PageCount);
        BlInsertDescriptor(AllocationDescriptor);

        //
        // initialize new heap values and return pointer to newly
        // alloc'd memory.
        //
        BlHeapFree = KSEG0_BASE | (AllocationDescriptor->BasePage << PAGE_SHIFT);


        BlHeapLimit = (BlHeapFree + (NewHeapPages << PAGE_SHIFT)) - sizeof(MEMORY_ALLOCATION_DESCRIPTOR);

        RtlZeroMemory((PVOID)BlHeapFree, NewHeapPages << PAGE_SHIFT);

        Block = (PVOID)BlHeapFree;
        if ((BlHeapFree + Size) < BlHeapLimit) {
            BlHeapFree += Size;
            return Block;
        } else {
            //
            // we should never get here
            //
            return(NULL);
        }
    }
}

VOID
BlGenerateNewHeap (
    IN PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor,
    IN ULONG BasePage,
    IN ULONG PageCount
    )

/*++

Routine Description:

    This routine allocates a new heap block from the specified memory
    descriptor, avoiding the region specified by BasePage and PageCount.
    The caller must ensure that this region does not encompass the entire
    block.

    The allocated heap block may be as small as a single page.

Arguments:

    MemoryDescriptor - Supplies a pointer to a free memory descriptor
        from which the heap block is to be allocated.

    BasePage - Supplies the base page number of the excluded region.

    PageCount - Supplies the number of pages in the excluded region.

Return Value:

    None.

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR AllocationDescriptor;
    ULONG NewHeapPages;
    ULONG AvailableAtFront;
    ULONG AvailableAtBack;

    //
    // BlHeapLimit always reserves enough space for one more
    // MEMORY_ALLOCATION_DESCRIPTOR, so use that to describe the
    // new heap block.
    //
    AllocationDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR)BlHeapLimit;

    //
    // Allocate the new heap from either the front or the back of the
    // specified descriptor, whichever fits best.  We'd like to allocate
    // BL_HEAP_PAGES pages, but we'll settle for less.
    //
    AvailableAtFront = BasePage - MemoryDescriptor->BasePage;
    AvailableAtBack = (MemoryDescriptor->BasePage + MemoryDescriptor->PageCount) -
                      (BasePage + PageCount);

    if ((AvailableAtFront == 0) ||
        ((AvailableAtBack != 0) && (AvailableAtBack < AvailableAtFront))) {
        NewHeapPages = MIN(AvailableAtBack, BL_HEAP_PAGES);
        AllocationDescriptor->BasePage =
            MemoryDescriptor->BasePage + MemoryDescriptor->PageCount - NewHeapPages;
    } else {
        NewHeapPages = MIN(AvailableAtFront, BL_HEAP_PAGES);
        AllocationDescriptor->BasePage = MemoryDescriptor->BasePage;
        MemoryDescriptor->BasePage += NewHeapPages;
    }

    MemoryDescriptor->PageCount -= NewHeapPages;

    //
    // Initialize our new descriptor and add it to the list.
    //
    AllocationDescriptor->MemoryType = LoaderOsloaderHeap;
    AllocationDescriptor->PageCount = NewHeapPages;

    BlInsertDescriptor(AllocationDescriptor);

    //
    // Initialize new heap values.
    //
    BlpTrackUsage (LoaderOsloaderHeap,AllocationDescriptor->BasePage,AllocationDescriptor->PageCount);
    BlHeapFree = KSEG0_BASE | (AllocationDescriptor->BasePage << PAGE_SHIFT);

    BlHeapLimit = (BlHeapFree + (NewHeapPages << PAGE_SHIFT)) - sizeof(MEMORY_ALLOCATION_DESCRIPTOR);

    RtlZeroMemory((PVOID)BlHeapFree, NewHeapPages << PAGE_SHIFT);

    return;
}


ARC_STATUS
BlGenerateDescriptor (
    IN PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor,
    IN MEMORY_TYPE MemoryType,
    IN ULONG BasePage,
    IN ULONG PageCount
    )

/*++

Routine Description:

    This routine allocates a new memory descriptor to describe the
    specified region of memory which is assumed to lie totally within
    the specified region which is free.

Arguments:

    MemoryDescriptor - Supplies a pointer to a free memory descriptor
        from which the specified memory is to be allocated.

    MemoryType - Supplies the type that is assigned to the allocated
        memory.

    BasePage - Supplies the base page number.

    PageCount - Supplies the number of pages.

Return Value:

    ESUCCESS is returned if a descriptor(s) is successfully generated.
    Otherwise, return an unsuccessful status.

--*/

{

    PMEMORY_ALLOCATION_DESCRIPTOR NewDescriptor1;
    PMEMORY_ALLOCATION_DESCRIPTOR NewDescriptor2;
    LONG Offset;
    TYPE_OF_MEMORY OldType;
    BOOLEAN SecondDescriptorNeeded;

    //
    // If the allocation is for zero pages, make it one, because allocation of zero
    // breaks the internal algorithms for merging, etc.
    //
    if (PageCount == 0) {
        PageCount = 1;
    }

    //
    // If the specified region totally consumes the free region, then no
    // additional descriptors need to be allocated. If the specified region
    // is at the start or end of the free region, then only one descriptor
    // needs to be allocated. Otherwise, two additional descriptors need to
    // be allocated.
    //

    Offset = BasePage - MemoryDescriptor->BasePage;
    if ((Offset == 0) && (PageCount == MemoryDescriptor->PageCount)) {

        //
        // The specified region totally consumes the free region.
        //

        MemoryDescriptor->MemoryType = MemoryType;

    } else {

        //
        // Mark the entire given memory descriptor as in use.  If we are
        // out of heap, BlAllocateHeap will search for a new descriptor
        // to grow the heap and this prevents both routines from trying
        // to use the same descriptor.
        //
        OldType = MemoryDescriptor->MemoryType;
        MemoryDescriptor->MemoryType = LoaderSpecialMemory;

        //
        // A memory descriptor must be generated to describe the allocated
        // memory.
        //

        SecondDescriptorNeeded =
            (BOOLEAN)((BasePage != MemoryDescriptor->BasePage) &&
                      ((ULONG)(Offset + PageCount) != MemoryDescriptor->PageCount));

        NewDescriptor1 = BlAllocateHeap( sizeof(MEMORY_ALLOCATION_DESCRIPTOR) );

        //
        // If allocation of the first additional memory descriptor failed,
        // then generate new heap using the block from which we are
        // allocating.  This can only be done if the block is free.
        //
        // Note that BlGenerateNewHeap cannot fail, because we know there is
        // at least one more page in the block than we want to take from it.
        //
        // Note also that the allocation following BlGenerateNewHeap is
        // guaranteed to succeed.
        //

        if (NewDescriptor1 == NULL) {
            if (OldType != LoaderFree) {
                MemoryDescriptor->MemoryType = OldType;
                return ENOMEM;
            }
            BlGenerateNewHeap(MemoryDescriptor, BasePage, PageCount);
            NewDescriptor1 = BlAllocateHeap( sizeof(MEMORY_ALLOCATION_DESCRIPTOR) );

            //
            // Recompute offset, as the base page of the memory descriptor
            // has been changed by BlGenerateNewHeap
            //
            Offset = BasePage - MemoryDescriptor->BasePage;
        }

        //
        // If a second descriptor is needed, allocate it.  As above, if the
        // allocation fails, generate new heap using our block.
        //
        // Note that if BlGenerateNewHeap was called above, the first call
        // to BlAllocateHeap below will not fail.  (So we won't call
        // BlGenerateNewHeap twice.)
        //

        if (SecondDescriptorNeeded) {
            NewDescriptor2 = BlAllocateHeap( sizeof(MEMORY_ALLOCATION_DESCRIPTOR) );

            if (NewDescriptor2 == NULL) {
                if (OldType != LoaderFree) {
                    MemoryDescriptor->MemoryType = OldType;
                    return ENOMEM;
                }
                BlGenerateNewHeap(MemoryDescriptor, BasePage, PageCount);
                NewDescriptor2 = BlAllocateHeap( sizeof(MEMORY_ALLOCATION_DESCRIPTOR) );
                Offset = BasePage - MemoryDescriptor->BasePage;
            }
        }

        NewDescriptor1->MemoryType = MemoryType;
        NewDescriptor1->BasePage = BasePage;
        NewDescriptor1->PageCount = PageCount;

        if (BasePage == MemoryDescriptor->BasePage) {

            //
            // The specified region lies at the start of the free region.
            //

            MemoryDescriptor->BasePage += PageCount;
            MemoryDescriptor->PageCount -= PageCount;
            MemoryDescriptor->MemoryType = OldType;

        } else if ((ULONG)(Offset + PageCount) == MemoryDescriptor->PageCount) {

            //
            // The specified region lies at the end of the free region.
            //

            MemoryDescriptor->PageCount -= PageCount;
            MemoryDescriptor->MemoryType = OldType;

        } else {

            //
            // The specified region lies in the middle of the free region.
            //

            NewDescriptor2->MemoryType = OldType;
            NewDescriptor2->BasePage = BasePage + PageCount;
            NewDescriptor2->PageCount =
                            MemoryDescriptor->PageCount - (PageCount + Offset);

            MemoryDescriptor->PageCount = Offset;
            MemoryDescriptor->MemoryType = OldType;

            BlInsertDescriptor(NewDescriptor2);
        }

        BlInsertDescriptor(NewDescriptor1);
    }

    BlpTrackUsage (MemoryType,BasePage,PageCount);

    return ESUCCESS;
}

PMEMORY_ALLOCATION_DESCRIPTOR
BlFindMemoryDescriptor(
    IN ULONG BasePage
    )

/*++

Routine Description:

    Finds the memory allocation descriptor that contains the given page.

Arguments:

    BasePage - Supplies the page whose allocation descriptor is to be found.

Return Value:

    != NULL - Pointer to the requested memory allocation descriptor
    == NULL - indicates no memory descriptor contains the given page

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor=NULL;
    PLIST_ENTRY NextEntry;

    NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextEntry != &BlLoaderBlock->MemoryDescriptorListHead) {
        MemoryDescriptor = CONTAINING_RECORD(NextEntry,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);
        if ((MemoryDescriptor->BasePage <= BasePage) &&
            (MemoryDescriptor->BasePage + MemoryDescriptor->PageCount > BasePage)) {

            //
            // Found it.
            //
            break;
        }

        NextEntry = NextEntry->Flink;
    }

    if (NextEntry == &BlLoaderBlock->MemoryDescriptorListHead) {
        return(NULL);
    } else {
        return(MemoryDescriptor);
    }

}

#ifdef SETUP
PMEMORY_ALLOCATION_DESCRIPTOR
BlFindFreeMemoryBlock(
    IN ULONG PageCount
    )

/*++

Routine Description:

    Find a free memory block of at least a given size (using a best-fit
    algorithm) or find the largest free memory block.

Arguments:

    PageCount - supplies the size in pages of the block.  If this is 0,
        then find the largest free block.

Return Value:

    Pointer to the memory allocation descriptor for the block or NULL if
    no block could be found matching the search criteria.

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR FoundMemoryDescriptor=NULL;
    PLIST_ENTRY NextEntry;
    ULONG LargestSize = 0;
    ULONG SmallestLeftOver = (ULONG)(-1);

    NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextEntry != &BlLoaderBlock->MemoryDescriptorListHead) {
        MemoryDescriptor = CONTAINING_RECORD(NextEntry,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);

        if (MemoryDescriptor->MemoryType == LoaderFree) {

            if(PageCount) {
                //
                // Looking for a block of a specific size.
                //
                if((MemoryDescriptor->PageCount >= PageCount)
                && (MemoryDescriptor->PageCount - PageCount < SmallestLeftOver))
                {
                    SmallestLeftOver = MemoryDescriptor->PageCount - PageCount;
                    FoundMemoryDescriptor = MemoryDescriptor;
                }
            } else {

                //
                // Looking for the largest free block.
                //

                if(MemoryDescriptor->PageCount > LargestSize) {
                    LargestSize = MemoryDescriptor->PageCount;
                    FoundMemoryDescriptor = MemoryDescriptor;
                }
            }

        }
        NextEntry = NextEntry->Flink;
    }

    return(FoundMemoryDescriptor);
}

ULONG
BlDetermineTotalMemory(
    VOID
    )

/*++

Routine Description:

    Determine the total amount of memory in the machine.

Arguments:

    None.

Return Value:

    Total amount of memory in the system, in bytes.

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;
    PLIST_ENTRY NextEntry;
    ULONG PageCount;

    NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    PageCount = 0;
    while(NextEntry != &BlLoaderBlock->MemoryDescriptorListHead) {

        MemoryDescriptor = CONTAINING_RECORD(NextEntry,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);

        PageCount += MemoryDescriptor->PageCount;

#if i386
        //
        // Note: on x86 machines, we never use the 40h pages below the 16
        // meg line (bios shadow area).  But we want to account for them here,
        // so check for this case.
        //

        if(MemoryDescriptor->BasePage + MemoryDescriptor->PageCount == 0xfc0) {
            PageCount += 0x40;
        }
#endif

        NextEntry = NextEntry->Flink;
    }

    return(PageCount << PAGE_SHIFT);
}
#endif  // def SETUP


ULONG
HbPageDisposition (
    IN PFN_NUMBER   Page
    )
{
    static PLIST_ENTRY              Entry;
    PLIST_ENTRY                     Start;
    PMEMORY_ALLOCATION_DESCRIPTOR   MemDesc;
    ULONG                           Disposition;

    //
    // Check to see if page is in the range of the last descritor looked at.
    //

    if (Entry) {
        MemDesc = CONTAINING_RECORD(Entry, MEMORY_ALLOCATION_DESCRIPTOR, ListEntry);
        if (Page >= MemDesc->BasePage && Page < MemDesc->BasePage + MemDesc->PageCount) {
            goto Done;
        }
    }

    //
    // Find descriptor describing this page
    //

    if (!Entry) {
        Entry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    }

    Start = Entry;
    for (; ;) {
        if (Entry != &BlLoaderBlock->MemoryDescriptorListHead) {
            MemDesc = CONTAINING_RECORD(Entry, MEMORY_ALLOCATION_DESCRIPTOR, ListEntry);
            if (Page >= MemDesc->BasePage && Page < MemDesc->BasePage + MemDesc->PageCount) {
                goto Done;
            }
        }

        Entry = Entry->Flink;

        if (Entry == Start) {
            //
            // Descriptor for this page was not found
            //

            return HbPageInvalid;
        }
    }

Done:
    //
    // Convert memory type to the proper disposition
    //

    switch (MemDesc->MemoryType) {
        case LoaderFree:
        case LoaderReserve:
            Disposition = HbPageNotInUse;
            break;

        case LoaderBad:
            Disposition = HbPageInvalid;
            break;

        case LoaderFirmwareTemporary:
            //
            // On x86 systems memory above 16Mb is marked as firmware temporary
            // by i386\memory.c to prevent the loader from typically trying to
            // map it
            //

            Disposition = HbPageInUseByLoader;

#if i386
            if (Page > ((ULONG)0x1000000 >> PAGE_SHIFT)) {
                Disposition = HbPageNotInUse;
            }
#endif
            break;
        default:
            Disposition = HbPageInUseByLoader;
            break;
    }

    return Disposition;
}


VOID
BlpTruncateDescriptors (
    IN ULONG HighestPage
    )

/*++

Routine Description:

    This routine locates and truncates or removes any memory located in a
    page above HighestPage from the memory descriptor list in the loader
    block.

Arguments:

    HighestPage - Supplies the physical page number above which we are to
                  remove all pages.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;
    PMEMORY_ALLOCATION_DESCRIPTOR descriptor;
    ULONG lastDescriptorPage;

    listHead = &BlLoaderBlock->MemoryDescriptorListHead;
    listEntry = listHead->Flink;

    while (listEntry != listHead) {

        descriptor = CONTAINING_RECORD( listEntry,
                                        MEMORY_ALLOCATION_DESCRIPTOR,
                                        ListEntry );

        //
        // Determine the page number of the last page in this descriptor
        //

        lastDescriptorPage = descriptor->BasePage +
                             descriptor->PageCount - 1;

        if (lastDescriptorPage <= HighestPage) {

            //
            // None of the memory described by this descriptor is above
            // HighestPage.  Ignore this descriptor.
            //

        } else if (descriptor->BasePage > HighestPage) {

            //
            // All of this descriptor is above HighestPage.  Remove it.
            //

            BlRemoveDescriptor( descriptor );

        } else {

            //
            // Some but not all of the memory described by this descriptor lies
            // above HighestPage.  Truncate it.
            //

            descriptor->PageCount = HighestPage - descriptor->BasePage + 1;
        }

        listEntry = listEntry->Flink;
    }
}

TYPE_OF_MEMORY
BlpDetermineAllocationPolicy (
   TYPE_OF_MEMORY MemoryType,
   ULONG BasePage,
   ULONG PageCount,
   BOOLEAN retry
   )
{
    TYPE_OF_MEMORY TypeToUse;

    //
    // Give the restore code buffers as low as possible to avoid double buffering
    //
    if (BlRestoring == TRUE) {
        BlMemoryAllocationPolicy = BlAllocateLowestFit;
        return (LoaderFree);
    }

    if (MemoryType == LoaderXIPRom) {
#ifndef EFI
        if (PageCount <= (4*1024*1024 >> PAGE_SHIFT)) {
            TypeToUse = (retry) ? LoaderReserve:LoaderFree;
            BlMemoryAllocationPolicy = BlAllocateLowestFit;
        } else {
            TypeToUse = LoaderReserve;
            BlMemoryAllocationPolicy = BlAllocateHighestFit;
        }
#else
        TypeToUse = LoaderReserve;
        BlMemoryAllocationPolicy = BlAllocateHighestFit;
#endif
        return TypeToUse;
    }

#ifndef EFI
    if (BlVirtualBias != 0) {
        //
        // Booted /3GB
        //
        // With a 5.0 or prior kernel, allocate from the bottom
        // up (this loader will never run setup)
        //
        if (!BlOldKernel) {
            if (IsTrackMem (MemoryType)){
                // We care about this allocation.
                // Allocations from reserve are done lowest fit (growing up from 16MB)
                // Allocations from free are done highest fit (growing down from 16MB)
                TypeToUse = (retry) ? LoaderReserve : LoaderFree;
                BlMemoryAllocationPolicy = (retry) ? BlAllocateLowestFit : BlAllocateHighestFit;
            } else {
                TypeToUse = (retry) ? LoaderReserve : LoaderFree;
                BlMemoryAllocationPolicy = BlAllocateLowestFit;
            }
        } else {
            //
            // Old kernel, load the kernel at the bottom
            //
            TypeToUse = LoaderFree;
            if (IsTrackMem (MemoryType) || (MemoryType == LoaderOsloaderHeap)) {
                // We care about this allocation.
                BlMemoryAllocationPolicy = BlAllocateLowestFit;
            } else {
                BlMemoryAllocationPolicy = BlAllocateHighestFit;
            }

        }
    } else 
#endif
    {

        if (!IsTrackMem (MemoryType)) {

            // We don't care about this allocation.
            TypeToUse = (retry) ? LoaderFree:LoaderReserve;
            BlMemoryAllocationPolicy = BlAllocateHighestFit;
        } else {
            BlMemoryAllocationPolicy = BlAllocateLowestFit;
            TypeToUse = (retry) ? LoaderReserve : LoaderFree;
        }

    }

    if (BlOldKernel) {
        TypeToUse = LoaderFree;
    }

    return (TypeToUse);

}


void
BlpTrackUsage (
    MEMORY_TYPE MemoryType,
    ULONG ActualBase,
    ULONG NumberPages
    )
{



    if (BlRestoring || !(IsTrackMem (MemoryType)) || BlOldKernel ||
        !IsValidTrackingRange (ActualBase,NumberPages)) {
        //
        // Don't track
        //
        return;
    }

    if ((ActualBase+NumberPages) > BlHighestPage) {
        BlHighestPage = ActualBase+NumberPages;
    }

    if ((BlLowestPage == 0) || (BlLowestPage < ActualBase) ) {

        BlLowestPage = ActualBase;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\blstring.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    parseini.c

Abstract:

    This module implements functions to parse a .INI file

Author:

    John Vert (jvert) 7-Oct-1993

Revision History:

    John Vert (jvert) 7-Oct-1993 - largely lifted from splib\spinf.c

--*/

#include "parseini.h"
#include <string.h>
#include <ctype.h>
#include <stdlib.h>


PWCHAR
SlCopyStringAW(
    IN PCHAR String
    )
/*++

Routine Description:

    Converts an ANSI string into UNICODE and copies it into the loader heap.

Arguments:

    String - Supplies the string to be copied.

Return Value:

    PWCHAR - pointer into the loader heap where the string was copied to.

--*/
{
    PWCHAR Buffer;
    ANSI_STRING aString;
    UNICODE_STRING uString;

    if (String==NULL) {
        SlNoMemoryError();
    }

    Buffer = BlAllocateHeap(sizeof(WCHAR)*(strlen(String)+1));
    if (Buffer==NULL) {
        SlNoMemoryError();
    } else {

        RtlInitAnsiString( &aString, String );
        uString.Buffer = Buffer;
        uString.MaximumLength = sizeof(WCHAR)*(strlen(String) + 1);
        
        RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
        
        Buffer[strlen(String)] = L'\0';

    }

    return(Buffer);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\blmisc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blmisc.c

Abstract:

    This module contains miscellaneous routines for use by
    the boot loader and setupldr.

Author:

    David N. Cutler (davec) 10-May-1991

Revision History:

--*/

#include "bootlib.h"

//
// Value indicating whether a dbcs locale is active.
// If this value is non-0 we use alternate display routines, etc,
// and fetch messages in this language.
//
ULONG DbcsLangId;

PCHAR
BlGetArgumentValue (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv,
    IN PCHAR ArgumentName
    )

/*++

Routine Description:

    This routine scans the specified argument list for the named argument
    and returns the address of the argument value. Argument strings are
    specified as:

        ArgumentName=ArgumentValue

    Argument names are specified as:

        ArgumentName=

    The argument name match is case insensitive.

Arguments:

    Argc - Supplies the number of argument strings that are to be scanned.

    Argv - Supplies a pointer to a vector of pointers to null terminated
        argument strings.

    ArgumentName - Supplies a pointer to a null terminated argument name.

Return Value:

    If the specified argument name is located, then a pointer to the argument
    value is returned as the function value. Otherwise, a value of NULL is
    returned.

--*/

{

    PCHAR Name;
    PCHAR String;

    //
    // Scan the argument strings until either a match is found or all of
    // the strings have been scanned.
    //

    while (Argc > 0) {
        String = Argv[Argc - 1];
        if (String != NULL) {
            Name = ArgumentName;
            while ((*Name != 0) && (*String != 0)) {
                if (toupper(*Name) != toupper(*String)) {
                    break;
                }

                Name += 1;
                String += 1;
            }

            if ((*Name == 0) && (*String == '=')) {
                return String + 1;
            }

            Argc -= 1;
        }
    }

    return NULL;
}


PCHAR
BlSetArgumentValue (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv,
    IN PCHAR ArgumentName,
    IN PCHAR NewValue
    )

/*++

Routine Description:

    This routine scans the specified argument list for the named argument
    and returns the address of the argument value. The value associated
    with the arg is changed to the value passed in. Argument strings are

    specified as:

        ArgumentName=ArgumentValue

    Argument names are specified as:

        ArgumentName=

    The argument name match is case insensitive.

Arguments:

    Argc - Supplies the number of argument strings that are to be scanned.

    Argv - Supplies a pointer to a vector of pointers to null terminated
        argument strings.

    ArgumentName - Supplies a pointer to a null terminated argument name.

Return Value:

    If the specified argument name is located, then a pointer to the argument
    value is returned as the function value. Otherwise, a value of NULL is
    returned.

--*/

{

    PCHAR Name;
    PCHAR String;

    //
    // Scan the argument strings until either a match is found or all of
    // the strings have been scanned.
    //

    while (Argc > 0) {
        String = Argv[Argc - 1];
        if (String != NULL) {
            Name = ArgumentName;
            while ((*Name != 0) && (*String != 0)) {
                if (toupper(*Name) != toupper(*String)) {
                    break;
                }

                Name += 1;
                String += 1;
            }

            if ((*Name == 0) && (*String == '=')) {
                Name = (PCHAR)BlAllocateHeap(strlen(ArgumentName)+2+strlen(NewValue));
                if (Name) {
                    strcpy( Name, ArgumentName );
                    strcat( Name, "=" );
                    strcat( Name, NewValue );
                    return Name+strlen(ArgumentName)+1;
                }
                return String + 1;
            }

            Argc -= 1;
        }
    }

    return NULL;
}

//
// Line draw chars -- different scheme in Far East vs. SBCS
//
_TUCHAR
GetGraphicsChar(
    IN GraphicsChar WhichOne
    )
{
#ifdef EFI
    
    return(TextGetGraphicsCharacter(WhichOne));
#else

#if defined(_X86_)  && !defined(ARCI386)   

    return(TextGetGraphicsCharacter(WhichOne));
#else
    //
    // ARC machines don't support dbcs for now
    //
    static _TUCHAR ArcGraphicsChars[GraphicsCharMax] = { (UCHAR)'\311',   // right-down
                                                       (UCHAR)'\273',   // left-down
                                                       (UCHAR)'\310',   // right-up
                                                       (UCHAR)'\274',   // left-up
                                                       (UCHAR)'\272',   // vertical
                                                       (UCHAR)'\315'    // horizontal
                                                     };

    return(((unsigned)WhichOne < (unsigned)GraphicsCharMax) 
             ? ArcGraphicsChars[WhichOne] 
             : TEXT(' '));
#endif
#endif
}


LOGICAL
BdPollBreakIn(
    VOID
    );

#if defined(_X86_)
#include <bldrx86.h>
#endif

VOID
BlWaitForReboot (
    VOID
    )
{
#if defined(_X86)
    BlPrint( TEXT("Press any key to reboot\n") );
#endif

    while (TRUE) {

#if defined(_X86_)
        if ( BdPollBreakIn() ) {
            DbgBreakPoint();
        }
        if ( ArcGetReadStatus(BlConsoleInDeviceId) ) {
            BlPrint( TEXT("Rebooting...\n") );
            REBOOT_PROCESSOR();
        }
#endif

        ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\cmdcnst.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmdcnst.h

Abstract:

    This is the command string interpreter definitions

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//--------------------------------------------------------------------------
//   Definition of the set/clear mode command language.
//
//   Each command is composed of a major portion and a minor portion.
//   The major portion of a command can be found in the most significant
//   nibble of a command byte, while the minor portion is in the least
//   significant portion of a command byte.
//
//   maj  minor      Description
//   ---- -----      --------------------------------------------
//   00              End of data
//
//   10              in and out type commands as described by flags
//        flags:
//
//        xxxx
//        ||||
//        |||+-------- unused
//        ||+--------- 0/1 single/multiple values to output (in's are always 
//        |+---------- 0/1 8/16 bit operation                  single)
//        +----------- 0/1 out/in instruction
//
//       Outs
//       ----------------------------------------------
//       0           reg:W val:B
//       2           reg:W cnt:W val1:B val2:B...valN:B
//       4           reg:W val:W
//       6           reg:W cnt:W val1:W val2:W...valN:W
//
//       Ins
//       ----------------------------------------------
//       8           reg:W
//       a           reg:W cnt:W
//       c           reg:W
//       e           reg:W cnt:W
//
//   20              Special purpose outs
//       00          do indexed outs for seq, crtc, and gdc
//                   indexreg:W cnt:B startindex:B val1:B val2:B...valN:B
//       01          do indexed outs for atc
//                   index-data_reg:W cnt:B startindex:B val1:B val2:B...valN:B
//       02          do masked outs
//                   indexreg:W andmask:B xormask:B
//
//   F0              Nop
//
//---------------------------------------------------------------------------

// some useful equates - major commands

#define EOD     0x000                   // end of data
#define INOUT   0x010                   // do ins or outs
#define METAOUT 0x020                   // do special types of outs
#define NCMD    0x0f0                   // Nop command


// flags for INOUT major command

//#define UNUSED    0x01                    // reserved
#define MULTI   0x02                    // multiple or single outs
#define BW      0x04                    // byte/word size of operation
#define IO      0x08                    // out/in instruction

// minor commands for metout

#define INDXOUT 0x00                    // do indexed outs
#define ATCOUT  0x01                    // do indexed outs for atc
#define MASKOUT 0x02                    // do masked outs using and-xor masks


// composite inout type commands

#define OB      (INOUT)                 // output 8 bit value
#define OBM     (INOUT+MULTI)           // output multiple bytes
#define OW      (INOUT+BW)              // output single word value
#define OWM     (INOUT+BW+MULTI)        // output multiple words

#define IB      (INOUT+IO)              // input byte
#define IBM     (INOUT+IO+MULTI)        // input multiple bytes
#define IW      (INOUT+IO+BW)           // input word
#define IWM     (INOUT+IO+BW+MULTI)     // input multiple words
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\blres.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    blres.c

Abstract:

    Provides rudimentary resource support for the osloader and setupldr

Author:

    John Vert (jvert) 12-Nov-1993

Revision History:

--*/
#include "bootlib.h"

PUCHAR BlpResourceDirectory = NULL;
PUCHAR BlpResourceFileOffset = NULL;

//
// private function prototypes
//
PIMAGE_RESOURCE_DIRECTORY
BlpFindDirectoryEntry(
    IN PIMAGE_RESOURCE_DIRECTORY Directory,
    IN ULONG Id,
    IN PUCHAR SectionStart
    );


ARC_STATUS
BlInitResources(
    IN PCHAR StartCommand
    )

/*++

Routine Description:

    Opens the executable that was run and reads the section headers out of the
    image to determine where the resource section is located in memory.

Arguments:

    StartCommand - Supplies the command used to start the program (argv[0])

Return Value:

    ESUCCESS if successful

    ARC_STATUS if unsuccessful

--*/

{
    CHAR DeviceName[80];
    PCHAR FileName;
    PCHAR p;
    ULONG DeviceId;
    ULONG FileId;
    ARC_STATUS Status;
    UCHAR LocalBuffer[(SECTOR_SIZE * 2) + 256];
    PUCHAR LocalPointer;
    ULONG Count;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    PIMAGE_DATA_DIRECTORY ResourceDirectory;
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG NumberOfSections;
#if defined(_IA64_)
    PIMAGE_NT_HEADERS NtHeader;
#endif


    if (BlpResourceDirectory != NULL) {
        //
        // Already initialized, just return.
        //
        return(ESUCCESS);
    }
    //
    // extract device name from the startup path
    //
    p=strrchr(StartCommand,')');
    if (p==NULL) {
        return(ENODEV);
    }

    strncpy(DeviceName, StartCommand, (ULONG) (p-StartCommand+1));
    DeviceName[p-StartCommand+1]='\0';

    FileName = p+1;
#ifdef ARCI386
    FileName++;
#endif
    //
    // Open the device.
    //
    Status = ArcOpen(DeviceName, ArcOpenReadOnly, &DeviceId);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Open the file.
    //
    Status = BlOpen(DeviceId,
                    FileName,
                    ArcOpenReadOnly,
                    &FileId);
    if (Status != ESUCCESS) {
        ArcClose(DeviceId);
        return(Status);
    }

    //
    // Read the first two sectors of the image header from the file.
    //
    LocalPointer = ALIGN_BUFFER(LocalBuffer);
    Status = BlRead(FileId, LocalPointer, SECTOR_SIZE*2, &Count);
    BlClose(FileId);
    ArcClose(DeviceId);

    if (Status != ESUCCESS) {
        return(Status);
    }

#if defined(_IA64_)
    NtHeader = (PIMAGE_NT_HEADERS) ( (PCHAR) LocalPointer +
                                     ((PIMAGE_DOS_HEADER) LocalPointer)->e_lfanew);
    FileHeader = &(NtHeader->FileHeader);
    LocalPointer = (PUCHAR) FileHeader;
#else
    FileHeader = (PIMAGE_FILE_HEADER)LocalPointer;
#endif

    OptionalHeader = (PIMAGE_OPTIONAL_HEADER)(LocalPointer + sizeof(IMAGE_FILE_HEADER));
    NumberOfSections = FileHeader->NumberOfSections;
    SectionHeader = (PIMAGE_SECTION_HEADER)((PUCHAR)OptionalHeader +
                                            FileHeader->SizeOfOptionalHeader);

    //
    // Find .rsrc section
    //

    while (NumberOfSections) {
        if (_stricmp(SectionHeader->Name, ".rsrc")==0) {
            BlpResourceDirectory = (PUCHAR)((LONG_PTR)((LONG)SectionHeader->VirtualAddress));
            BlpResourceFileOffset = (PUCHAR)(ULONG_PTR)SectionHeader->PointerToRawData;
#if defined(ARCI386) || defined(_IA64_)
            // No startup.com to fix up these values for this ARC PROM.
            BlpResourceDirectory += OptionalHeader->ImageBase;
            BlpResourceFileOffset = (PUCHAR)UlongToPtr(SectionHeader->VirtualAddress);  //ResourceDirectory->VirtualAddress;
#endif
            if (FileHeader->Machine == IMAGE_FILE_MACHINE_POWERPC) {
                BlpResourceDirectory += OptionalHeader->ImageBase;
            }

            return(ESUCCESS);
        }

        ++SectionHeader;
        --NumberOfSections;
    }

    return(EBADF);
}


PTCHAR
BlFindMessage(
    IN ULONG Id
    )

/*++

Routine Description:

    Looks up a message resource in the given image.  Note that this routine
    ignores the Language ID.  It is assumed that the osloader/setupldr only
    has messages for one language.

Arguments:

    Id - Supplies the message ID to look up.

Return Value:

    PTCHAR - pointer to the message string.

    NULL - failure.

--*/

{
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY NextDirectory;
    PMESSAGE_RESOURCE_DATA  MessageData;
    PMESSAGE_RESOURCE_BLOCK MessageBlock;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    PIMAGE_RESOURCE_DATA_ENTRY DataEntry;
    ULONG NumberOfBlocks;
    ULONG Index;

    if (BlpResourceDirectory==NULL) {
        return(NULL);
    }

    ResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)BlpResourceDirectory;

    //
    // Search the directory.  We are looking for the type RT_MESSAGETABLE (11)
    //
    NextDirectory = BlpFindDirectoryEntry(ResourceDirectory,
                                          11,
                                          (PUCHAR)ResourceDirectory);
    if (NextDirectory==NULL) {
        return(NULL);
    }

    //
    // Find the next directory.  Should only be one entry here (nameid == 1)
    //
    NextDirectory = BlpFindDirectoryEntry(NextDirectory,
                                          1,
                                          (PUCHAR)ResourceDirectory);
    if (NextDirectory==NULL) {
        return(NULL);
    }

    // Find the message table.
    // If a dbcs locale is active, then we look for the appropriate
    // message table first. Otherwise we just look for the first message table.
    //
    if(DbcsLangId) {
        DataEntry = (PIMAGE_RESOURCE_DATA_ENTRY)BlpFindDirectoryEntry(
                                                    NextDirectory,
                                                    DbcsLangId,
                                                    (PUCHAR)ResourceDirectory
                                                    );
    } else {
        DataEntry = NULL;
    }

    if(!DataEntry) {
        DataEntry = (PIMAGE_RESOURCE_DATA_ENTRY)BlpFindDirectoryEntry(
                                                    NextDirectory,
                                                    (ULONG)(-1),
                                                    (PUCHAR)ResourceDirectory
                                                    );
    }

    if(!DataEntry) {
        return(NULL);
    }

    MessageData = (PMESSAGE_RESOURCE_DATA)(BlpResourceDirectory +
                                           DataEntry->OffsetToData -
                                           BlpResourceFileOffset);

    NumberOfBlocks = MessageData->NumberOfBlocks;
    MessageBlock = MessageData->Blocks;
    while (NumberOfBlocks--) {
        if ((Id >= MessageBlock->LowId) &&
            (Id <= MessageBlock->HighId)) {

            //
            // The requested ID is within this block, scan forward until
            // we find it.
            //
            MessageEntry = (PMESSAGE_RESOURCE_ENTRY)((PCHAR)MessageData + MessageBlock->OffsetToEntries);
            Index = Id - MessageBlock->LowId;
            while (Index--) {
                MessageEntry = (PMESSAGE_RESOURCE_ENTRY)((PUCHAR)MessageEntry + MessageEntry->Length);
            }
            return((PTCHAR)MessageEntry->Text);
        }

        //
        // Check the next block for this ID.
        //

        MessageBlock++;
    }

    return(NULL);

}


PIMAGE_RESOURCE_DIRECTORY
BlpFindDirectoryEntry(
    IN PIMAGE_RESOURCE_DIRECTORY Directory,
    IN ULONG Id,
    IN PUCHAR SectionStart
    )

/*++

Routine Description:

    Searches through a resource directory for the given ID.  Ignores entries
    with actual names, only searches for ID.  If the given ID is -1, the
    first entry is returned.

Arguments:

    Directory - Supplies the resource directory to search.

    Id - Supplies the ID to search for.  -1 means return the first ID found.

    SectionStart - Supplies a pointer to the start of the resource section.

Return Value:

    Pointer to the found resource directory.

    NULL for failure.

--*/

{
    ULONG i;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY FoundDirectory;

    FoundDirectory = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(Directory+1);

    //
    // Skip entries with names.
    //
    for (i=0;i<Directory->NumberOfNamedEntries;i++) {
        ++FoundDirectory;
    }

    //
    // Search for matching ID.
    //
    for (i=0;i<Directory->NumberOfIdEntries;i++) {
        if ((FoundDirectory->Name == Id) || (Id == (ULONG)-1)) {
            //
            // Found a match.
            //
            return((PIMAGE_RESOURCE_DIRECTORY)(SectionStart +
                            (FoundDirectory->OffsetToData & ~IMAGE_RESOURCE_DATA_IS_DIRECTORY)));

        }
        ++FoundDirectory;
    }

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\blsecret.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blsecret.c

Abstract:

    This module contains the code to read and write secrets from disk.

Author:

    Adam Barr (adamba) 13-June-1997

Revision History:

--*/

#include "bootlib.h"

#define SEC_FAR
typedef BOOLEAN BOOL;
typedef unsigned char BYTE, *PBYTE;
typedef unsigned long DWORD;
#define LM20_PWLEN 14
#include "crypt.h"
#include "rc4.h"

//
// Defined in the bootssp library.
//

BOOL
CalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

BOOL
CalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );

// This must be evenly divisible by sizeof(USHORT)
#define ASSUMED_SECTOR_SIZE 512

#if 0
VOID
BlpDumpSector(
    PUCHAR Sector
    )
{
    int i, j;

    PUCHAR SectorChar = (PUCHAR)Sector;

    for (i = 0; i < ASSUMED_SECTOR_SIZE; i+= 16) {

        for (j = 0; j < 16; j++) {
            DbgPrint("%2.2x ", SectorChar[i + j]);
        }
        DbgPrint("  ");
        for (j = 0; j < 16; j++) {
            if ((SectorChar[i+j] >= ' ') && (SectorChar[i+j] < '~')) {
                DbgPrint("%c", SectorChar[i+j]);
            } else {
                DbgPrint(".");
            }
        }
        DbgPrint("\n");
    }
}
#endif


#if defined(REMOTE_BOOT)
ARC_STATUS
BlOpenRawDisk(
    PULONG FileId
    )

/*++

Routine Description:

    This routine opens the raw disk for read/write.

Arguments:

    FileId - returns the FileId is successful, for use in subsequent calls.

Return Value:

    The status return from the ArcOpen.

--*/

{

    ARC_STATUS ArcStatus;

    //
    // Open the disk in raw mode. Need to check if it is the right string for Alpha.
    // On x86 this eventually turns into an int13 read of disk 0x80 which
    // is what we want and is more-or-less guaranteed to be in the format
    // we expect (e.g. 512 byte sectors).
    //

    ArcStatus = ArcOpen("multi(0)disk(0)rdisk(0)partition(0)", ArcOpenReadWrite, FileId);

    if (ArcStatus != ESUCCESS) {

        DbgPrint("BlOpenRawDisk: ArcStatus on ArcOpen: %x\n", ArcStatus);

    }

    return ArcStatus;

}


ARC_STATUS
BlCloseRawDisk(
    ULONG FileId
    )

/*++

Routine Description:

    This routine closes the raw disk.

Arguments:

    FileId - The FileId returned by BlOpenRawDisk.

Return Value:

    The status return from the ArcClose.

--*/

{

    return ArcClose(FileId);

}


ARC_STATUS
BlCheckForFreeSectors (
    ULONG FileId
    )

/*++

Routine Description:

    This routine makes sure that the MBR looks correct and that there
    is nothing installed (OnTrack or EZ-Drive -- need to detect
    NT fault-tolerance also) that would prevent us from using the third
    sector for storing the password secret.

Arguments:

    FileId - The FileId returned by BlOpenRawDisk.

Return Value:

    ESUCCESS if the disk is OK, or an error.

--*/

{

    ARC_STATUS ArcStatus;
    USHORT Sector[ASSUMED_SECTOR_SIZE/sizeof(USHORT)];
    ULONG BytesProcessed;
    PPARTITION_DESCRIPTOR FirstPartition;
    LARGE_INTEGER SeekPosition;


    //
    // Make sure we are at the beginning of the disk.
    //

    SeekPosition.QuadPart = 0;

    ArcStatus = ArcSeek(FileId, &SeekPosition, SeekAbsolute);

    if (ArcStatus != ESUCCESS) {

        DbgPrint("BlCheckForFreeSectors: ArcStatus on ArcSeek: %x\n", ArcStatus);
        return ArcStatus;

    }

    //
    // Read the MBR at the start of the disk.
    //

    ArcStatus = ArcRead(FileId, Sector, ASSUMED_SECTOR_SIZE, &BytesProcessed);

    if (ArcStatus != ESUCCESS) {

        DbgPrint("BlCheckForFreeSectors: ArcStatus on ArcRead MBR: %x\n", ArcStatus);
        return ArcStatus;

    }

#if 0
    BlpDumpSector((PUCHAR)Sector);
#endif

    //
    // Make sure the signature is OK, and that the type of partition
    // 0 is not 0x54 (OnTrack) or 0x55 (EZ-Drive).
    //

    if (Sector[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {

        DbgPrint("BlCheckForFreeSectors: Boot record signature %x not found (%x found)\n",
                BOOT_RECORD_SIGNATURE,
                Sector[BOOT_SIGNATURE_OFFSET] );
        return EINVAL;
    }

    //
    // FirstPartition is the first entry in the partition table.
    //

    FirstPartition = (PPARTITION_DESCRIPTOR)&Sector[PARTITION_TABLE_OFFSET];

    if ((FirstPartition->PartitionType == 0x54) ||
        (FirstPartition->PartitionType == 0x55)) {

        DbgPrint("BlCheckForFreeSectors: First partition has type %x, exiting\n", FirstPartition->PartitionType);
        return EINVAL;
    }

    DbgPrint("BlCheckForFreeSectors: Partition type is %d\n", FirstPartition->PartitionType);

#if 0
    //
    // Make the active entry the first one in the partition table.
    //

    if ((FirstPartition->ActiveFlag & PARTITION_ACTIVE_FLAG) != PARTITION_ACTIVE_FLAG) {

        PPARTITION_DESCRIPTOR ActivePartition;
        PARTITION_DESCRIPTOR TempPartition;
        ULONG i;

        ActivePartition = FirstPartition;

        for (i = 1; i < NUM_PARTITION_TABLE_ENTRIES; i++) {

            ++ActivePartition;
            if ((ActivePartition->ActiveFlag & PARTITION_ACTIVE_FLAG) == PARTITION_ACTIVE_FLAG) {

                DbgPrint("BlCheckForFreeSector: Moving active partition %d to the front\n", i);

                TempPartition = *FirstPartition;
                *FirstPartition = *ActivePartition;
                *ActivePartition = TempPartition;
                break;
            }
        }

        if (i == NUM_PARTITION_TABLE_ENTRIES) {

            DbgPrint("BlCheckForFreeSector: Could not find an active partition!!\n");

        } else {
        
            ArcStatus = ArcSeek(FileId, &SeekPosition, SeekAbsolute);
        
            if (ArcStatus != ESUCCESS) {
        
                DbgPrint("BlCheckForFreeSectors: ArcStatus on ArcSeek: %x\n", ArcStatus);
                return ArcStatus;
            }
        
            ArcStatus = ArcWrite(FileId, Sector, ASSUMED_SECTOR_SIZE, &BytesProcessed);
        
            if ((ArcStatus != ESUCCESS) ||
                (BytesProcessed != ASSUMED_SECTOR_SIZE)) {

                DbgPrint("BlCheckForFreeSectors: ArcStatus on ArcWrite MBR: %x (%x)\n", ArcStatus, BytesProcessed);
                return ArcStatus;
            }
        }
    }
#endif

    return ESUCCESS;

}


ARC_STATUS
BlReadSecret(
    ULONG FileId,
    PRI_SECRET Secret
    )

/*++

Routine Description:

    This routine reads the secret from the disk, if present.

Arguments:

    FileId - The FileId returned by BlOpenRawDisk.

Return Value:

    ESUCCESS if the secret is OK, an error otherwise.

--*/

{

    ARC_STATUS ArcStatus;
    ULONG BytesRead;
    LARGE_INTEGER SeekPosition;


    //
    // Seek to the third sector.
    //

    SeekPosition.QuadPart = 2 * ASSUMED_SECTOR_SIZE;

    ArcStatus = ArcSeek(FileId, &SeekPosition, SeekAbsolute);

    if (ArcStatus != ESUCCESS) {

        DbgPrint("BlReadSecret: ArcStatus on ArcSeek: %x\n", ArcStatus);
        return ArcStatus;

    }

    //
    // Read a secret-sized chunk.
    //

    ArcStatus = ArcRead(FileId, Secret, sizeof(RI_SECRET), &BytesRead);

    if ((ArcStatus != ESUCCESS) ||
        (BytesRead != sizeof(RI_SECRET))) {

        DbgPrint("BlReadSecret: ArcStatus on ArcRead secret: %x, read %d\n", ArcStatus, BytesRead);
        return ArcStatus;

    }

    if (memcmp(Secret->Signature, RI_SECRET_SIGNATURE, 4) != 0) {

        DbgPrint("BlReadSecret: No signature found\n");
        return EINVAL;
    }

    return ESUCCESS;

}



ARC_STATUS
BlWriteSecret(
    ULONG FileId,
    PRI_SECRET Secret
    )

/*++

Routine Description:

    This routine writes the secret to the disk.

Arguments:

    FileId - The FileId returned by BlOpenRawDisk.

Return Value:

    ESUCCESS if the secret is written OK, an error otherwise.

--*/

{

    ARC_STATUS ArcStatus;
    ULONG BytesWritten;
    LARGE_INTEGER SeekPosition;


    //
    // Seek to the third sector.
    //

    SeekPosition.QuadPart = 2 * ASSUMED_SECTOR_SIZE;

    ArcStatus = ArcSeek(FileId, &SeekPosition, SeekAbsolute);

    if (ArcStatus != ESUCCESS) {

        DbgPrint("BlWriteSecret: ArcStatus on ArcSeek: %x\n", ArcStatus);
        return ArcStatus;

    }

    //
    // Write a secret-sized chunk.
    //

    ArcStatus = ArcWrite(FileId, Secret, sizeof(RI_SECRET), &BytesWritten);

    if ((ArcStatus != ESUCCESS) ||
        (BytesWritten != sizeof(RI_SECRET))) {

        DbgPrint("BlWriteSecret: ArcStatus on ArcWrite secret: %x, wrote %d\n", ArcStatus, BytesWritten);
        return ArcStatus;

    }

    return ESUCCESS;

}
#endif // defined(REMOTE_BOOT)


VOID
BlInitializeSecret(
    IN PUCHAR Domain,
    IN PUCHAR User,
    IN PUCHAR LmOwfPassword1,
    IN PUCHAR NtOwfPassword1,
#if defined(REMOTE_BOOT)
    IN PUCHAR LmOwfPassword2 OPTIONAL,
    IN PUCHAR NtOwfPassword2 OPTIONAL,
#endif // defined(REMOTE_BOOT)
    IN PUCHAR Sid,
    IN OUT PRI_SECRET Secret
    )

/*++

Routine Description:

    This routine initializes the secret structures. The passwords
    are OWFed and then encrypted with the User string.

Arguments:

Return Value:

    None.

--*/

{
    int Length;
    int i;
    struct RC4_KEYSTRUCT Key;

    memset(Secret, 0, sizeof(RI_SECRET));

    memcpy(Secret->Signature, RI_SECRET_SIGNATURE, 4);
    Secret->Version = 1;

    Length = strlen(Domain);
    memcpy(Secret->Domain, Domain, Length);

    Length = strlen(User);
    memcpy(Secret->User, User, Length);

    memcpy(Secret->Sid, Sid, RI_SECRET_SID_SIZE);

    //
    // Encrypt the passwords using the user name.
    //

#if defined(BL_USE_LM_PASSWORD)
    memcpy(Secret->LmEncryptedPassword1, LmOwfPassword1, LM_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, LM_OWF_PASSWORD_SIZE, Secret->LmEncryptedPassword1);

#if defined(REMOTE_BOOT)
    if (LmOwfPassword2 != NULL) {
        memcpy(Secret->LmEncryptedPassword2, LmOwfPassword2, LM_OWF_PASSWORD_SIZE);
        rc4_key(&Key, strlen(User), User);
        rc4(&Key, LM_OWF_PASSWORD_SIZE, Secret->LmEncryptedPassword2);
    }
#endif // defined(REMOTE_BOOT)
#endif // defined(BL_USE_LM_PASSWORD)

    memcpy(Secret->NtEncryptedPassword1, NtOwfPassword1, NT_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, NT_OWF_PASSWORD_SIZE, Secret->NtEncryptedPassword1);

#if defined(REMOTE_BOOT)
    if (NtOwfPassword2 != NULL) {
        memcpy(Secret->NtEncryptedPassword2, NtOwfPassword2, NT_OWF_PASSWORD_SIZE);
        rc4_key(&Key, strlen(User), User);
        rc4(&Key, NT_OWF_PASSWORD_SIZE, Secret->NtEncryptedPassword2);
    }
#endif // defined(REMOTE_BOOT)

}



#if defined(REMOTE_BOOT_SECURITY)
VOID
BlParseSecret(
    IN OUT PUCHAR Domain,
    IN OUT PUCHAR User,
    IN OUT PUCHAR LmOwfPassword1,
    IN OUT PUCHAR NtOwfPassword1,
    IN OUT PUCHAR LmOwfPassword2,
    IN OUT PUCHAR NtOwfPassword2,
    IN OUT PUCHAR Sid,
    IN PRI_SECRET Secret
    )

/*++

Routine Description:

    This routine parses a secret structure. The passwords
    are unencrypted with the User string and returned in OWF form.

Arguments:

Return Value:

    None.

--*/

{
    struct RC4_KEYSTRUCT Key;

    memcpy(Domain, Secret->Domain, RI_SECRET_DOMAIN_SIZE);
    Domain[RI_SECRET_DOMAIN_SIZE] = '\0';

    memcpy(User, Secret->User, RI_SECRET_USER_SIZE);
    User[RI_SECRET_USER_SIZE] = '\0';

    memcpy(Sid, Secret->Sid, RI_SECRET_SID_SIZE);

    //
    // Decrypt the passwords using the user name.
    //

#if defined(BL_USE_LM_PASSWORD)
    memcpy(LmOwfPassword1, Secret->LmEncryptedPassword1, LM_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, LM_OWF_PASSWORD_SIZE, LmOwfPassword1);

    memcpy(LmOwfPassword2, Secret->LmEncryptedPassword2, LM_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, LM_OWF_PASSWORD_SIZE, LmOwfPassword2);
#else
    memset(LmOwfPassword1, 0, LM_OWF_PASSWORD_SIZE);
    memset(LmOwfPassword2, 0, LM_OWF_PASSWORD_SIZE);
#endif // defined(BL_USE_LM_PASSWORD)

    memcpy(NtOwfPassword1, Secret->NtEncryptedPassword1, NT_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, NT_OWF_PASSWORD_SIZE, NtOwfPassword1);

    memcpy(NtOwfPassword2, Secret->NtEncryptedPassword2, NT_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, NT_OWF_PASSWORD_SIZE, NtOwfPassword2);

}
#endif // defined(REMOTE_BOOT_SECURITY)



VOID
BlOwfPassword(
    IN PUCHAR Password,
    IN PUNICODE_STRING UnicodePassword,
    IN OUT PUCHAR LmOwfPassword,
    IN OUT PUCHAR NtOwfPassword
    )
{
    char TmpText[CLEAR_BLOCK_LENGTH*2] = {'\0'};
    int Length;
    int i;

    Length = strlen(Password);

    //
    // Copy the string to TmpText, converting to uppercase.
    //

    if (Length == 0 || Length > LM20_PWLEN) {
        TmpText[0] = 0;
    } else {
        for (i = 0; i <= Length; i++) {
            TmpText[i] = (char)toupper(Password[i]);
        }
    }

    CalculateLmOwfPassword((PLM_PASSWORD)TmpText, (PLM_OWF_PASSWORD)LmOwfPassword);

    CalculateNtOwfPassword(UnicodePassword, (PNT_OWF_PASSWORD)NtOwfPassword);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\bootlib.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    bootlib.h

Abstract:

    This module is the header file for the common boot library

Author:

    John Vert (jvert) 5-Oct-1993

Revision History:

--*/

#ifndef _BOOTLIB_
#define _BOOTLIB_

#include "ntos.h"
#include "bldr.h"
#include "fatboot.h"
#include "cdfsboot.h"
#include "ntfsboot.h"
#include "hpfsboot.h"
#include "etfsboot.h"
#include "netboot.h"
#include "udfsboot.h"

//
// Define partition context structure.
//

typedef struct _PARTITION_CONTEXT {
    LARGE_INTEGER PartitionLength;
    ULONG StartingSector;
    ULONG EndingSector;
    UCHAR DiskId;
    UCHAR DeviceUnit;
    UCHAR TargetId;
    UCHAR PathId;
    ULONG SectorShift;
    ULONG Size;
    struct _DEVICE_OBJECT *PortDeviceObject;
} PARTITION_CONTEXT, *PPARTITION_CONTEXT;

#ifdef EFI_PARTITION_SUPPORT

#pragma pack (1)

typedef struct _EFI_PARTITION_TABLE {
    UCHAR       Signature[8];
    ULONG       Revision;
    ULONG       HeaderSize;
    ULONG       HeaderCRC;
    ULONG       Reserved;
    unsigned __int64 MyLBA;
    unsigned __int64 AlternateLBA;
    unsigned __int64 FirstUsableLBA;
    unsigned __int64 LastUsableLBA;
    UCHAR       DiskGuid[16];
    unsigned __int64 PartitionEntryLBA;
    ULONG       PartitionCount;
    ULONG       PartitionEntrySize;
    ULONG       PartitionEntryArrayCRC;
    UCHAR       ReservedEnd[1];    // will extend till block size
} EFI_PARTITION_TABLE, *PEFI_PARTITION_TABLE;

typedef struct _EFI_PARTITION_ENTRY {
    UCHAR       Type[16];
    UCHAR       Id[16];
    unsigned __int64 StartingLBA;
    unsigned __int64 EndingLBA;
    unsigned __int64 Attributes;
    UCHAR       Name[72];        
} EFI_PARTITION_ENTRY, *PEFI_PARTITION_ENTRY;

#pragma pack ()

#define EFI_SIGNATURE   "EFI PART"

#endif // EFI_PARTITION_SUPPORT

//
// Define serial port context structure
//
typedef struct _SERIAL_CONTEXT {
    ULONG PortBase;
    ULONG PortNumber;
} SERIAL_CONTEXT, *PSERIAL_CONTEXT;


//
// Define drive context structure (for x86 BIOS)
//
typedef struct _DRIVE_CONTEXT {
    BOOLEAN IsCd;
    UCHAR Drive;    
    UCHAR Sectors;          // 1 - 63
    USHORT Cylinders;       // 1 - 1023
    USHORT Heads;           // 1 - 256
    BOOLEAN xInt13;
#if defined(_IA64_)
    ULONGLONG DeviceHandle;
#endif // IA64
} DRIVE_CONTEXT, *PDRIVE_CONTEXT;

//
// Define Floppy context structure
//
typedef struct _FLOPPY_CONTEXT {
    ULONG DriveType;
    ULONG SectorsPerTrack;
    UCHAR DiskId;
} FLOPPY_CONTEXT, *PFLOPPY_CONTEXT;

//
// Define keyboard context structure
//
typedef struct _KEYBOARD_CONTEXT {
    BOOLEAN ScanCodes;
} KEYBOARD_CONTEXT, *PKEYBOARD_CONTEXT;

//
// Define Console context
//
typedef struct _CONSOLE_CONTEXT {
    ULONG ConsoleNumber;
} CONSOLE_CONTEXT, *PCONSOLE_CONTEXT;

//
// Define EFI open handle context
//
typedef struct _EFI_ARC_OPEN_CONTEXT {
    PVOID   Handle;
    PVOID   DeviceEntryProtocol;
} EFI_ARC_OPEN_CONTEXT, *PEFI_ARC_OPEN_CONTEXT;


//
// Define file table structure.
//

typedef struct _BL_FILE_FLAGS {
    ULONG Open : 1;
    ULONG Read : 1;
    ULONG Write : 1;
    ULONG Firmware : 1;
} BL_FILE_FLAGS, *PBL_FILE_FLAGS;

#define MAXIMUM_FILE_NAME_LENGTH 32

typedef struct _BL_FILE_TABLE {
    BL_FILE_FLAGS Flags;
    ULONG DeviceId;
    LARGE_INTEGER Position;
    PVOID StructureContext;
    PBL_DEVICE_ENTRY_TABLE DeviceEntryTable;
    UCHAR FileNameLength;
    CHAR FileName[MAXIMUM_FILE_NAME_LENGTH];
    union {
        NTFS_FILE_CONTEXT NtfsFileContext;
        FAT_FILE_CONTEXT FatFileContext;
        UDFS_FILE_CONTEXT UdfsFileContext;
        CDFS_FILE_CONTEXT CdfsFileContext;
        ETFS_FILE_CONTEXT EtfsFileContext;
        NET_FILE_CONTEXT NetFileContext;
        PARTITION_CONTEXT PartitionContext;
        SERIAL_CONTEXT SerialContext;
        DRIVE_CONTEXT DriveContext;
        FLOPPY_CONTEXT FloppyContext;
        KEYBOARD_CONTEXT KeyboardContext;
        CONSOLE_CONTEXT ConsoleContext;
        EFI_ARC_OPEN_CONTEXT EfiContext;        
    } u;
} BL_FILE_TABLE, *PBL_FILE_TABLE;

extern BL_FILE_TABLE BlFileTable[BL_FILE_TABLE_SIZE];

//
// Context structure for our Decompression pseudo-filesystem
// (filter on top of other FS)
//
typedef struct _DECOMP_STRUCTURE_CONTEXT {
    //
    // File information from the original file system.
    //
    FILE_INFORMATION FileInfo;
} DECOMP_STRUCTURE_CONTEXT, *PDECOMP_STRUCTURE_CONTEXT;

//
// Define generic filesystem context area.
//
// N.B. An FS_STRUCTURE_CONTEXT structure is temporarily used when
// determining the file system for a volume.  Once the file system
// is recognized, a file system specific structure is allocated from
// the heap to retain the file system structure information.
//

typedef union {
    UDFS_STRUCTURE_CONTEXT UdfsStructure;
    CDFS_STRUCTURE_CONTEXT CdfsStructure;
    FAT_STRUCTURE_CONTEXT FatStructure;
    HPFS_STRUCTURE_CONTEXT HpfsStructure;
    NTFS_STRUCTURE_CONTEXT NtfsStructure;
#if defined(ELTORITO)
    ETFS_STRUCTURE_CONTEXT EtfsStructure;
#endif
    NET_STRUCTURE_CONTEXT NetStructure;
    DECOMP_STRUCTURE_CONTEXT DecompStructure;
} FS_STRUCTURE_CONTEXT, *PFS_STRUCTURE_CONTEXT;


//
// 
// N.B. We can speed up the boot time, by not
// querying the device for all the possible file systems
// for every open call. This saves approximately 30 secs
// on CD-ROM / DVD-ROM boot time. To disable this feature
// just undef CACHE_DEVINFO in bldr.h
//
//
#ifdef CACHE_DEVINFO 

//
// Device ID to File System information cache.
// 
// N.B. For removable media its assumed that the device will
// be closed using ArcClose(...) before using the new media.
// This close call will invalidate the cached entry as 
// ArcClose(...) will be mapped to ArcCacheClose(...) 
//
typedef struct _DEVICE_TO_FILESYS {
  ULONG                   DeviceId;
  PFS_STRUCTURE_CONTEXT   Context;
  PBL_DEVICE_ENTRY_TABLE  DevMethods;   
} DEVICE_TO_FILESYS, * PDEVICE_TO_FILESYS;

extern DEVICE_TO_FILESYS    DeviceFSCache[BL_FILE_TABLE_SIZE];

#endif // CACHE_DEVINFO


#ifdef EFI_PARTITION_SUPPORT


typedef
BOOLEAN
(*PGPT_READ_CALLBACK)(
    IN ULONGLONG StartingLBA,
    IN ULONG     BytesToRead,
    IN OUT PVOID Context,
    OUT PVOID    OutputData
    );

BOOLEAN
BlIsValidGUIDPartitionTable(
    IN UNALIGNED EFI_PARTITION_TABLE  *PartitionTableHeader,
    IN ULONGLONG LBAOfPartitionTable,
    IN PVOID  Context,
    IN PGPT_READ_CALLBACK DiskReadFunction
    );


UNALIGNED EFI_PARTITION_ENTRY *
BlLocateGPTPartition(
    IN UCHAR PartitionNumber,
    IN UCHAR MaxPartitions,
    IN PUCHAR ValidPartitionCount OPTIONAL
    );

ARC_STATUS
BlOpenGPTDiskPartition(
    IN ULONG FileId,
    IN ULONG DiskId,
    IN UCHAR PartitionNumber
    );

ARC_STATUS
BlGetGPTDiskPartitionEntry(
    IN ULONG DiskNumber,
    IN UCHAR PartitionNumber,
    OUT EFI_PARTITION_ENTRY UNALIGNED **PartitionEntry
    );

//
// EFI partition table buffer
//
extern UNALIGNED EFI_PARTITION_ENTRY EfiPartitionBuffer[128];    

#endif // EFI_PARTITION_SUPPORT    

#endif  _BOOTLIB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\cdfsboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    CdfsBoot.c

Abstract:

    This module implements the Cdfs boot file system used by the operating
    system loader.

Author:

    Brian Andrew    [BrianAn]   05-Aug-1991

Revision History:

--*/

#include "bootlib.h"
#include "cd.h"
#include "blcache.h"

BOOTFS_INFO CdfsBootFsInfo = {L"cdfs"};


//
//  Local procedure prototypes.
//

ARC_STATUS
CdfsReadDisk(
    IN ULONG DeviceId,
    IN ULONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    );

VOID
CdfsFirstComponent(
    IN OUT PSTRING String,
    OUT PSTRING FirstComponent
    );

typedef enum _COMPARISON_RESULTS {
    LessThan = -1,
    EqualTo = 0,
    GreaterThan = 1
} COMPARISON_RESULTS;

COMPARISON_RESULTS
CdfsCompareNames(
    IN PSTRING Name1,
    IN PSTRING Name2
    );

ARC_STATUS
CdfsSearchDirectory(
    IN PSTRING Name,
    OUT PBOOLEAN IsDirectory
    );

VOID
CdfsGetDirectoryInfo(
    IN PRAW_DIR_REC DirEntry,
    IN BOOLEAN IsoVol,
    OUT PULONG SectorOffset,
    OUT PULONG DiskOffset,
    OUT PULONG Length
    );

COMPARISON_RESULTS
CdfsFileMatch(
    IN PRAW_DIR_REC DirEntry,
    IN PSTRING FileName
    );


typedef union _USHORT2 {
    USHORT Ushort[2];
    ULONG  ForceAlignment;
} USHORT2, *PUSHORT2;

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//  accessing the source on a word boundary.
//

#define CopyUshort2(Dst,Src) {                               \
    ((PUSHORT2)(Dst))->Ushort[0] = ((UNALIGNED USHORT2 *)(Src))->Ushort[0]; \
    ((PUSHORT2)(Dst))->Ushort[1] = ((UNALIGNED USHORT2 *)(Src))->Ushort[1]; \
    }

//
//  The following macro upcases a single ascii character
//

#define ToUpper(C) ((((C) >= 'a') && ((C) <= 'z')) ? (C) - 'a' + 'A' : (C))

#define SetFlag(Flags,SingleFlag) { (Flags) |= (SingleFlag); }

//
//  The following macro indicate if the flag is on or off
//

#define FlagOn(Flags,SingleFlag) ((BOOLEAN)(       \
    (((Flags) & (SingleFlag)) != 0 ? TRUE : FALSE) \
    )                                              \
)


//
//  Define global data.
//
//  Context Pointer - This is a pointer to the context for the current file
//      operation that is active.
//

PCDFS_STRUCTURE_CONTEXT CdfsStructureContext;

//
//  File Descriptor - This is a pointer to the file descriptor for the current
//      file operation that is active.
//

PBL_FILE_TABLE CdfsFileTableEntry;

//
//  File entry table - This is a structure that provides entry to the Cdfs
//      file system procedures. It is exported when a Cdfs file structure
//      is recognized.
//

BL_DEVICE_ENTRY_TABLE CdfsDeviceEntryTable;


PBL_DEVICE_ENTRY_TABLE
IsCdfsFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    )

/*++

Routine Description:

    This routine determines if the partition on the specified channel
    contains a Cdfs file system volume.

Arguments:

    DeviceId - Supplies the file table index for the device on which
        read operations are to be performed.

    StructureContext - Supplies a pointer to a Hpfs file structure context.

Return Value:

    A pointer to the Cdfs entry table is returned if the partition is
    recognized as containing a Cdfs volume. Otherwise, NULL is returned.

--*/

{
    UCHAR UnalignedSector[CD_SECTOR_SIZE + 256];

    PRAW_ISO_VD RawVd;
    PRAW_DIR_REC RootDe;

    UCHAR DescType;
    UCHAR Version;

    BOOLEAN IsoVol;
    BOOLEAN HsgVol;

    STRING IsoVolId;
    STRING HsgVolId;

    STRING DiskId;

    ULONG DiskOffset;

    //
    //  Capture in our global variable the Cdfs Structure context record
    //

    CdfsStructureContext = (PCDFS_STRUCTURE_CONTEXT)StructureContext;
    RtlZeroMemory((PVOID)CdfsStructureContext, sizeof(CDFS_STRUCTURE_CONTEXT));

    //
    //  Compute the properly aligned buffer for reading in cdrom
    //  sectors.
    //

    RawVd = ALIGN_BUFFER( UnalignedSector );

    //
    //  Initialize the string Id's to match.
    //

    RtlInitString( &IsoVolId, ISO_VOL_ID );
    RtlInitString( &HsgVolId, HSG_VOL_ID );

    DiskId.Length = 5;
    DiskId.MaximumLength = 5;

    //
    //  We initially start at the first volume descriptor.
    //

    DiskOffset = FIRST_VD_SECTOR * CD_SECTOR_SIZE;

    //
    //  We loop, reading in volume descriptors until we find either
    //  a primary, terminator or a sector that cannot contain either.
    //

    while (TRUE) {

        //
        //  Initialize the Hsg boolean.
        //

        HsgVol = FALSE;

        //
        //  Read the sector at our current position.  Return NULL on an
        //  error
        //

        if (CdfsReadDisk( DeviceId,
                          DiskOffset,
                          CD_SECTOR_SIZE,
                          RawVd,
                          CACHE_NEW_DATA) != ESUCCESS) {

            return NULL;
        }

        //
        //  Compare the Id string in the volume descriptor with the Iso
        //  and Hsg values.
        //

        DiskId.Buffer = RVD_STD_ID( RawVd, TRUE );

        IsoVol = (BOOLEAN)(CdfsCompareNames( &DiskId, &IsoVolId ) == EqualTo);

        if (!IsoVol) {

            //
            //  Repeat the test with the Hsg Id string.
            //

            DiskId.Buffer = RVD_STD_ID( RawVd, FALSE );

            HsgVol = (BOOLEAN)(CdfsCompareNames( &DiskId, &HsgVolId ) == EqualTo);

            //
            //  If neither, then return NULL.
            //

            if (!HsgVol) {

                return NULL;
            }
        }

        //
        //  Get the volume descriptor type and standard version number.
        //

        DescType = RVD_DESC_TYPE( RawVd, IsoVol );
        Version = RVD_VERSION( RawVd, IsoVol );

        //
        //  Return NULL, if the version is incorrect or this is a terminal
        //  volume descriptor.
        //

        if (Version != VERSION_1
            || DescType == VD_TERMINATOR) {

            return NULL;
        }

        //
        //  If this is a primary volume descriptor, then our search is over.
        //

        if (DescType == VD_PRIMARY) {

            //
            //  Update the fields of the Cdfs context structure that apply
            //  to the volume.
            //

            CdfsStructureContext->IsIsoVol = IsoVol;
            CdfsStructureContext->LbnBlockSize = RVD_LB_SIZE( RawVd, IsoVol );
            CdfsStructureContext->LogicalBlockCount = RVD_VOL_SIZE( RawVd, IsoVol );

            //
            //  Get the information on the root directory and save it in
            //  the context structure.
            //

            RootDe = (PRAW_DIR_REC) (RVD_ROOT_DE( RawVd, IsoVol ));

            CdfsGetDirectoryInfo( RootDe,
                                  IsoVol,
                                  &CdfsStructureContext->RootDirSectorOffset,
                                  &CdfsStructureContext->RootDirDiskOffset,
                                  &CdfsStructureContext->RootDirSize );

            //
            //  Exit the loop.
            //

            break;
        }

        //
        //  Otherwise move to the next sector.
        //

        DiskOffset += CD_SECTOR_SIZE;
    }

    //
    //  Initialize the file entry table.
    //

    CdfsDeviceEntryTable.Open  = CdfsOpen;
    CdfsDeviceEntryTable.Close = CdfsClose;
    CdfsDeviceEntryTable.Read  = CdfsRead;
    CdfsDeviceEntryTable.Seek  = CdfsSeek;
    CdfsDeviceEntryTable.Write = CdfsWrite;
    CdfsDeviceEntryTable.GetFileInformation = CdfsGetFileInformation;
    CdfsDeviceEntryTable.SetFileInformation = CdfsSetFileInformation;
    CdfsDeviceEntryTable.BootFsInfo = &CdfsBootFsInfo;

    //
    //  And return the address of the table to our caller.
    //

    return &CdfsDeviceEntryTable;
}


ARC_STATUS
CdfsClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    This routine closes the file specified by the file id.

Arguments:

    FileId - Supplies the file table index.

Return Value:

    ESUCCESS if returned as the function value.

--*/

{
    //
    //  Indicate that the file isn't open any longer
    //

    BlFileTable[FileId].Flags.Open = 0;

    //
    //  And return to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
CdfsOpen (
    IN CHAR * FIRMWARE_PTR FileName,
    IN OPEN_MODE OpenMode,
    IN ULONG * FIRMWARE_PTR FileId
    )

/*++

Routine Description:

    This routine searches the root directory for a file matching FileName.
    If a match is found the dirent for the file is saved and the file is
    opened.

Arguments:

    FileName - Supplies a pointer to a zero terminated file name.

    OpenMode - Supplies the mode of the open.

    FileId - Supplies a pointer to a variable that specifies the file
        table entry that is to be filled in if the open is successful.

Return Value:

    ESUCCESS is returned if the open operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;

    ULONG DeviceId;

    STRING PathName;

    STRING Name;
    BOOLEAN IsDirectory;
    BOOLEAN SearchSucceeded;

    //
    //  Save the address of the file table entry, context area, and the device
    //  id in use.
    //

    CdfsFileTableEntry = &BlFileTable[*FileId];
    CdfsStructureContext = (PCDFS_STRUCTURE_CONTEXT)CdfsFileTableEntry->StructureContext;

    DeviceId = CdfsFileTableEntry->DeviceId;

    //
    // Construct a file name descriptor from the input file name.
    //

    RtlInitString( &PathName, FileName );

    //
    //  Set the starting directory to be the root directory.
    //

    CdfsStructureContext->DirSectorOffset = CdfsStructureContext->RootDirSectorOffset;
    CdfsStructureContext->DirDiskOffset = CdfsStructureContext->RootDirDiskOffset;
    CdfsStructureContext->DirSize = CdfsStructureContext->RootDirSize;

    //
    //  While the path name has some characters in it we'll go through our
    //  loop which extracts the first part of the path name and searches
    //  the current fnode (which must be a directory) for an the entry.
    //  If what we find is a directory then we have a new directory fnode
    //  and simply continue back to the top of the loop.
    //

    IsDirectory = TRUE;
    SearchSucceeded = TRUE;

    while (PathName.Length > 0
           && IsDirectory) {

        //
        //  Extract the first component.
        //

        CdfsFirstComponent( &PathName, &Name );

        //
        //  Copy the name into the filename buffer.
        //

        CdfsFileTableEntry->FileNameLength = (UCHAR) Name.Length;
        RtlMoveMemory( CdfsFileTableEntry->FileName,
                       Name.Buffer,
                       Name.Length );

        //
        //  Look to see if the file exists.
        //

        Status = CdfsSearchDirectory( &Name,
                                      &IsDirectory );

        if (Status == ENOENT) {

            SearchSucceeded = FALSE;
            break;
        }

        if (Status != ESUCCESS) {

            return Status;
        }

    }

    //
    //  If the path name length is not zero then we were trying to crack a path
    //  with an nonexistent (or non directory) name in it.  For example, we tried
    //  to crack a\b\c\d and b is not a directory or does not exist (then the path
    //  name will still contain c\d).
    //

    if (PathName.Length != 0) {

        return ENOTDIR;
    }

    //
    //  At this point we've cracked the name up to (an maybe including the last
    //  component).  We located the last component if the SearchSucceeded flag is
    //  true, otherwise the last component does not exist.  If we located the last
    //  component then this is like an open or a supersede, but not a create.
    //

    if (SearchSucceeded) {

        //
        //  Check if the last component is a directory
        //

        if (IsDirectory) {

            //
            //  For an existing directory the only valid open mode is OpenDirectory
            //  all other modes return an error
            //

            switch (OpenMode) {

            case ArcOpenReadOnly:
            case ArcOpenWriteOnly:
            case ArcOpenReadWrite:
            case ArcCreateWriteOnly:
            case ArcCreateReadWrite:
            case ArcSupersedeWriteOnly:
            case ArcSupersedeReadWrite:

                //
                //  If we reach here then the caller got a directory but didn't
                //  want to open a directory
                //

                return EISDIR;

            case ArcOpenDirectory:

                //
                //  If we reach here then the caller got a directory and wanted
                //  to open a directory.
                //

                CdfsFileTableEntry->u.CdfsFileContext.FileSize = CdfsStructureContext->DirSize;
                CdfsFileTableEntry->u.CdfsFileContext.DiskOffset = CdfsStructureContext->DirDiskOffset;
                CdfsFileTableEntry->u.CdfsFileContext.IsDirectory = TRUE;

                CdfsFileTableEntry->Flags.Open = 1;
                CdfsFileTableEntry->Flags.Read = 1;
                CdfsFileTableEntry->Position.LowPart = 0;
                CdfsFileTableEntry->Position.HighPart = 0;

                return ESUCCESS;

            case ArcCreateDirectory:

                //
                //  If we reach here then the caller got a directory and wanted
                //  to create a new directory
                //

                return EACCES;
            }
        }

        //
        //  If we get there then we have an existing file that is being opened.
        //  We can open existing files only read only.
        //

        switch (OpenMode) {

        case ArcOpenReadOnly:

            //
            //  If we reach here then the user got a file and wanted to open the
            //  file read only
            //

            CdfsFileTableEntry->u.CdfsFileContext.FileSize = CdfsStructureContext->DirSize;
            CdfsFileTableEntry->u.CdfsFileContext.DiskOffset = CdfsStructureContext->DirDiskOffset;
            CdfsFileTableEntry->u.CdfsFileContext.IsDirectory = FALSE;

            CdfsFileTableEntry->Flags.Open = 1;
            CdfsFileTableEntry->Flags.Read = 1;
            CdfsFileTableEntry->Position.LowPart = 0;
            CdfsFileTableEntry->Position.HighPart = 0;

            return ESUCCESS;

        case ArcOpenWriteOnly:
        case ArcOpenReadWrite:
        case ArcCreateWriteOnly:
        case ArcCreateReadWrite:
        case ArcSupersedeWriteOnly:
        case ArcSupersedeReadWrite:

            //
            //  If we reach here then we are trying to open a read only
            //  device for write.
            //

            return EROFS;

        case ArcOpenDirectory:
        case ArcCreateDirectory:

            //
            //  If we reach here then the user got a file and wanted a directory
            //

            return ENOTDIR;
        }
    }

    //
    //  If we get here the last component does not exist so we are trying to create
    //  either a new file or a directory.
    //

    switch (OpenMode) {

    case ArcOpenReadOnly:
    case ArcOpenWriteOnly:
    case ArcOpenReadWrite:
    case ArcOpenDirectory:

        //
        //  If we reach here then the user did not get a file but wanted a file
        //

        return ENOENT;

    case ArcCreateWriteOnly:
    case ArcSupersedeWriteOnly:
    case ArcCreateReadWrite:
    case ArcSupersedeReadWrite:
    case ArcCreateDirectory:

        //
        //  If we get hre the user wants to create something.
        //

        return EROFS;
    }

    //
    //  If we reach here then the path name is exhausted and we didn't
    //  reach a file so return an error to our caller
    //

    return ENOENT;
}


ARC_STATUS
CdfsRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    )

/*++

Routine Description:

    This routine reads data from the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that receives the data
        read.

    Length - Supplies the number of bytes that are to be read.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the read operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;

    ULONG DeviceId;
    ULONG DiskOffset;

    //
    //  Save the address of the file table entry, context area, and the device
    //  id in use.
    //

    CdfsFileTableEntry = &BlFileTable[FileId];
    CdfsStructureContext = (PCDFS_STRUCTURE_CONTEXT)CdfsFileTableEntry->StructureContext;

    DeviceId = CdfsFileTableEntry->DeviceId;

    //
    //  Clear the transfer count and set the initial disk offset.
    //

    *Transfer = 0;

    //
    // Check for end of file.
    //

    //
    // If the file position is currently at the end of file, then return
    // a success status with no bytes read from the file. If the file
    // plus the length of the transfer is beyond the end of file, then
    // read only the remaining part of the file. Otherwise, read the
    // requested number of bytes.
    //

    if (CdfsFileTableEntry->Position.LowPart ==
        CdfsFileTableEntry->u.CdfsFileContext.FileSize) {
        return ESUCCESS;

    } else {
        if ((CdfsFileTableEntry->Position.LowPart + Length) >=
            CdfsFileTableEntry->u.CdfsFileContext.FileSize) {
            Length = CdfsFileTableEntry->u.CdfsFileContext.FileSize -
                                                CdfsFileTableEntry->Position.LowPart;
        }
    }

    DiskOffset = CdfsFileTableEntry->Position.LowPart
                 + CdfsFileTableEntry->u.CdfsFileContext.DiskOffset;

    //
    //  Read in runs (i.e., sectors) until the byte count goes to zero
    //

    while (Length > 0) {

        ULONG CurrentRunByteCount;

        //
        //  Compute the current read byte count.
        //

        if (Length > MAX_CDROM_READ) {

            CurrentRunByteCount = MAX_CDROM_READ;

        } else {

            CurrentRunByteCount = Length;
        }

        //
        //  Read from the disk.
        //

        if ((Status = CdfsReadDisk( DeviceId,
                                    DiskOffset,
                                    CurrentRunByteCount,
                                    Buffer,
                                    DONT_CACHE_NEW_DATA)) != ESUCCESS) {

            return Status;
        }

        //
        //  Update the remaining length.
        //

        Length -= CurrentRunByteCount;

        //
        //  Update the current position and the number of bytes transfered
        //

        CdfsFileTableEntry->Position.LowPart += CurrentRunByteCount;
        DiskOffset += CurrentRunByteCount;

        *Transfer += CurrentRunByteCount;

        //
        //  Update buffer to point to the next byte location to fill in
        //

        Buffer = (PCHAR)Buffer + CurrentRunByteCount;
    }

    //
    //  If we get here then remaining sector count is zero so we can
    //  return success to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
CdfsSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    This routine seeks to the specified position for the file specified
    by the file id.

Arguments:

    FileId - Supplies the file table index.

    Offset - Supplies the offset in the file to position to.

    SeekMode - Supplies the mode of the seek operation.

Return Value:

    ESUCCESS if returned as the function value.

--*/

{
    ULONG NewPosition;

    //
    //  Compute the new position
    //

    if (SeekMode == SeekAbsolute) {

        NewPosition = Offset->LowPart;

    } else {

        NewPosition = BlFileTable[FileId].Position.LowPart + Offset->LowPart;
    }

    //
    //  If the new position is greater than the file size then return
    //  an error
    //

    if (NewPosition > BlFileTable[FileId].u.CdfsFileContext.FileSize) {

        return EINVAL;
    }

    //
    //  Otherwise set the new position and return to our caller
    //

    BlFileTable[FileId].Position.LowPart = NewPosition;

    return ESUCCESS;
}


ARC_STATUS
CdfsWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    )

/*++

Routine Description:

    This routine writes data to the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that contains the data
        written.

    Length - Supplies the number of bytes that are to be written.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the write operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    return EROFS;

    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Transfer );
}


ARC_STATUS
CdfsGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    )

/*++

Routine Description:

    This procedure returns to the user a buffer filled with file information

Arguments:

    FileId - Supplies the File id for the operation

    Buffer - Supplies the buffer to receive the file information.  Note that
        it must be large enough to hold the full file name

Return Value:

    ESUCCESS is returned for all get information requests.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    ULONG i;

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[FileId];

    //
    //  Zero out the buffer, and fill in its non-zero values
    //

    RtlZeroMemory(Buffer, sizeof(FILE_INFORMATION));

    Buffer->EndingAddress.LowPart = FileTableEntry->u.CdfsFileContext.FileSize;

    Buffer->CurrentPosition.LowPart = FileTableEntry->Position.LowPart;
    Buffer->CurrentPosition.HighPart = 0;

    SetFlag(Buffer->Attributes, ArcReadOnlyFile);

    if (FileTableEntry->u.CdfsFileContext.IsDirectory) {

        SetFlag( Buffer->Attributes, ArcDirectoryFile );
    }

    Buffer->FileNameLength = FileTableEntry->FileNameLength;

    for (i = 0; i < FileTableEntry->FileNameLength; i += 1) {

        Buffer->FileName[i] = FileTableEntry->FileName[i];
    }

    return ESUCCESS;
}


ARC_STATUS
CdfsSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )

/*++

Routine Description:

    This routine sets the file attributes of the indicated file

Arguments:

    FileId - Supplies the File Id for the operation

    AttributeFlags - Supplies the value (on or off) for each attribute being modified

    AttributeMask - Supplies a mask of the attributes being altered.  All other
        file attributes are left alone.

Return Value:

    EROFS is always returned in this case.

--*/

{
    return EROFS;

    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( AttributeFlags );
    UNREFERENCED_PARAMETER( AttributeMask );
}


ARC_STATUS
CdfsInitialize (
    VOID
    )

/*++

Routine Description:

    This routine initializes the cdfs boot filesystem.
    Currently this is a no-op.

Arguments:

    None.

Return Value:

    ESUCCESS.

--*/

{
    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
CdfsReadDisk(
    IN ULONG DeviceId,
    IN ULONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    )

/*++

Routine Description:

    This routine reads in zero or more sectors from the specified device.

Arguments:

    DeviceId - Supplies the device id to use in the arc calls.

    Lbo - Supplies the LBO to start reading from.

    ByteCount - Supplies the number of bytes to read.

    Buffer - Supplies a pointer to the buffer to read the bytes into.

Return Value:

    ESUCCESS is returned if the read operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    LARGE_INTEGER LargeLbo;
    ARC_STATUS Status;
    ULONG i;

    //
    //  Special case the zero byte read request
    //

    if (ByteCount == 0) {

        return ESUCCESS;
    }

    //
    // Issue the read through the cache.
    //

    LargeLbo.QuadPart = Lbo;
    Status = BlDiskCacheRead(DeviceId, 
                             &LargeLbo, 
                             Buffer, 
                             ByteCount, 
                             &i,
                             CacheNewData);

    if (Status != ESUCCESS) {
        return Status;
    }

    //
    //  Make sure we got back the amount requested
    //

    if (ByteCount != i) {

        return EIO;
    }

    //
    //  Everything is fine so return success to our caller
    //

    return ESUCCESS;
}


//
//  Internal support routine
//

VOID
CdfsFirstComponent(
    IN OUT PSTRING String,
    OUT PSTRING FirstComponent
    )

/*++

Routine Description:

    This routine takes an input path name and separates it into its
    first file name component and the remaining part.

Arguments:

    String - Supplies the original string being dissected.  On return
        this string will now point to the remaining part.

    FirstComponent - Returns the string representing the first file name
        in the input string.

Return Value:

    None.

--*/

{
    ULONG Index;

    //
    //  Copy over the string variable into the first component variable
    //

    *FirstComponent = *String;

    //
    //  Now if the first character in the name is a backslash then
    //  simply skip over the backslash.
    //

    if (FirstComponent->Buffer[0] == '\\') {

        FirstComponent->Buffer += 1;
        FirstComponent->Length -= 1;
    }

    //
    //  Now search the name for a backslash
    //

    for (Index = 0; Index < FirstComponent->Length; Index += 1) {

        if (FirstComponent->Buffer[Index] == '\\') {

            break;
        }
    }

    //
    //  At this point Index denotes a backslash or is equal to the length
    //  of the string.  So update string to be the remaining part.
    //  Decrement the length of the first component by the approprate
    //  amount
    //

    String->Buffer = &FirstComponent->Buffer[Index];
    String->Length = (SHORT)(FirstComponent->Length - Index);

    FirstComponent->Length = (SHORT)Index;

    //
    //  And return to our caller.
    //

    return;
}


//
//  Internal support routine
//

COMPARISON_RESULTS
CdfsCompareNames(
    IN PSTRING Name1,
    IN PSTRING Name2
    )

/*++

Routine Description:

    This routine takes two names and compare them ignoring case.  This
    routine does not do implied dot or dbcs processing.

Arguments:

    Name1 - Supplies the first name to compare

    Name2 - Supplies the second name to compare

Return Value:

    LessThan    if Name1 is lexically less than Name2
    EqualTo     if Name1 is lexically equal to Name2
    GreaterThan if Name1 is lexically greater than Name2

--*/

{
    ULONG i;
    ULONG MinimumLength;

    //
    //  Compute the smallest of the two name lengths
    //

    MinimumLength = (Name1->Length < Name2->Length ? Name1->Length : Name2->Length);

    //
    //  Now compare each character in the names.
    //

    for (i = 0; i < MinimumLength; i += 1) {

        if (ToUpper(Name1->Buffer[i]) < ToUpper(Name2->Buffer[i])) {

            return LessThan;
        }

        if (ToUpper(Name1->Buffer[i]) > ToUpper(Name2->Buffer[i])) {

            return GreaterThan;
        }
    }

    //
    //  The names compared equal up to the smallest name length so
    //  now check the name lengths
    //

    if (Name1->Length < Name2->Length) {

        return LessThan;
    }

    if (Name1->Length > Name2->Length) {

        return GreaterThan;
    }

    return EqualTo;
}


//
//  Internal support routine.
//

ARC_STATUS
CdfsSearchDirectory(
    IN PSTRING Name,
    OUT PBOOLEAN IsDirectory
    )

/*++

Routine Description:

    This routine walks through the current directory in the Cdfs
    context structure, looking for a match for 'Name'.  We will find
    the first non-multi-extent, non-interleave file.  We will ignore
    any version number for the file.  The details about the file, if
    found, are stored in the Cdfs context structure.

Arguments:

    Name - This is the name of the file to search for.

    IsDirectory - Supplies the address of a boolean where we store
                  whether this is or is not a directory.

Return Value:

    ESUCCESS is returned if the operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;

    ULONG SectorOffset;
    ULONG SectorDiskOffset;
    ULONG DirentOffset;
    ULONG RemainingBytes;

    BOOLEAN ReadSector;
    BOOLEAN SearchForMultiEnd;

    UCHAR UnalignedBuffer[CD_SECTOR_SIZE + 256];

    PUCHAR RawSector;

    PRAW_DIR_REC RawDe;

    COMPARISON_RESULTS ComparisonResult;

    //
    //  Initialize the local variables.
    //

    RawSector = ALIGN_BUFFER( UnalignedBuffer );

    SearchForMultiEnd = FALSE;

    //
    //  Remember where we are within the disk, sector and directory file.
    //

    SectorOffset = CdfsStructureContext->DirSectorOffset;
    SectorDiskOffset = CdfsStructureContext->DirDiskOffset - SectorOffset;
    DirentOffset = 0;

    ReadSector = FALSE;

    //
    //  If this is the root directory, then we can return immediately.
    //

    if (Name->Length == 1
        && *Name->Buffer == '\\') {

        *IsDirectory = TRUE;

        //
        //  The structure context is already filled in.
        //

        return ESUCCESS;
    }

    //
    //  Compute the remaining bytes in this sector.
    //

    RemainingBytes = CD_SECTOR_SIZE - SectorOffset;

    //
    //  Loop until the directory is exhausted or a matching dirent for the
    //  target name is found.
    //

    while (TRUE) {

        //
        //  If the current offset is beyond the end of the directory,
        //  raise an appropriate status.
        //

        if (DirentOffset >= CdfsStructureContext->DirSize) {

            return ENOENT;
        }

        //
        //  If the remaining bytes in this sector is less than the
        //  minimum needed for a dirent, then move to the next sector.
        //

        if (RemainingBytes < MIN_DIR_REC_SIZE) {

            SectorDiskOffset += CD_SECTOR_SIZE;
            DirentOffset += RemainingBytes;
            SectorOffset = 0;
            RemainingBytes = CD_SECTOR_SIZE;
            ReadSector = FALSE;

            continue;
        }

        //
        //  If we have not read in the sector, do so now.
        //

        if (!ReadSector) {

            Status = CdfsReadDisk( CdfsFileTableEntry->DeviceId,
                                   SectorDiskOffset,
                                   CD_SECTOR_SIZE,
                                   RawSector,
                                   CACHE_NEW_DATA);

            if (Status != ESUCCESS) {

                return Status;
            }

            ReadSector = TRUE;
        }

        //
        //  If the first byte of the next dirent is '\0', then we move to
        //  the next sector.
        //

        if (*(RawSector + SectorOffset) == '\0') {

            SectorDiskOffset += CD_SECTOR_SIZE;
            DirentOffset += RemainingBytes;
            SectorOffset = 0;
            RemainingBytes = CD_SECTOR_SIZE;
            ReadSector = FALSE;

            continue;
        }

        RawDe = (PRAW_DIR_REC) ((PUCHAR) RawSector + SectorOffset);

        //
        //  If the size of this dirent extends beyond the end of this sector
        //  we abort the search.
        //

        if ((ULONG)RawDe->DirLen > RemainingBytes) {

            return EINVAL;
        }

        //
        //  We have correctly found the next dirent.  We first check whether
        //  we are looking for the last dirent for a multi-extent.
        //

        if (SearchForMultiEnd) {

            //
            //  If this is the last of a multi-extent we change our search
            //  state.
            //

            if (!FlagOn( DE_FILE_FLAGS( CdfsStructureContext->IsIsoVol, RawDe ),
                         ISO_ATTR_MULTI )) {

                SearchForMultiEnd = TRUE;
            }

        //
        //  If this is a multi-extent dirent, we change our search state.
        //

        } else if (FlagOn( DE_FILE_FLAGS( CdfsStructureContext->IsIsoVol, RawDe ),
                           ISO_ATTR_MULTI )) {

            SearchForMultiEnd = TRUE;

        //
        //  If this is a file match, we update the Cdfs context structure
        //  and the 'IsDirectory' flag.
        //

        } else {

            ComparisonResult = CdfsFileMatch( RawDe, Name );

            if (ComparisonResult == EqualTo) {

                CdfsGetDirectoryInfo( RawDe,
                                      CdfsStructureContext->IsIsoVol,
                                      &CdfsStructureContext->DirSectorOffset,
                                      &CdfsStructureContext->DirDiskOffset,
                                      &CdfsStructureContext->DirSize );

                *IsDirectory = FlagOn( DE_FILE_FLAGS( CdfsStructureContext->IsIsoVol, RawDe ),
                                       ISO_ATTR_DIRECTORY );

                return ESUCCESS;

            //
            //  If we have passed this file in the directory, then
            //  exit with the appropriate error code.
            //

            } else if (ComparisonResult == GreaterThan) {

                return ENOENT;
            }
        }

        //
        //  Otherwise we simply compute the next sector offset, disk offset
        //  and file offset.
        //

        SectorOffset += RawDe->DirLen;
        DirentOffset += RawDe->DirLen;
        RemainingBytes -= RawDe->DirLen;
    }

    return ESUCCESS;
}


//
//  Internal support routine.
//

VOID
CdfsGetDirectoryInfo(
    IN PRAW_DIR_REC DirEntry,
    IN BOOLEAN IsoVol,
    OUT PULONG SectorOffset,
    OUT PULONG DiskOffset,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine takes a pointer to a raw directory structure on the disk
    and computes the file size, disk offset and file length for the
    directory entry.

Arguments:

    DirEntry - This points to raw data from the disk.

    IsoVol - Boolean indicating that this is an ISO volume.

    SectorOffset - This supplies the address to store the sector offset of the
                   start of the disk data.

    DiskOffset - This supplies the address to store the disk offset of the
                 start of the disk data.

    Length - This supplies the address to store the number of bytes in
             the file referred by this disk directory.

Return Value:

    None.

--*/

{
    //
    //  The disk offset is length of the Xar blocks added to the starting
    //  location for the file.
    //

    CopyUshort2( DiskOffset, DirEntry->FileLoc );
    *DiskOffset *= CdfsStructureContext->LbnBlockSize;
    *DiskOffset += (DirEntry->XarLen * CdfsStructureContext->LbnBlockSize);

    //
    //  The sector offset is the least significant bytes of the disk offset.
    //

    *SectorOffset = *DiskOffset & (CD_SECTOR_SIZE - 1);

    //
    //  The file size is pulled straight from the dirent.   We round it
    //  to a sector size to protect us from faulty disks if this is a
    //  directory.  Otherwise we use it directly from the dirent.
    //

    CopyUshort2( Length, DirEntry->DataLen );

    if (FlagOn( DE_FILE_FLAGS( IsoVol, DirEntry ), ISO_ATTR_DIRECTORY )) {

        *Length += (*SectorOffset + CD_SECTOR_SIZE - 1);
        *Length &= ~(CD_SECTOR_SIZE - 1);
        *Length -= *SectorOffset;
    }

    return;
}


//
//  Internal support routine.
//

COMPARISON_RESULTS
CdfsFileMatch(
    IN PRAW_DIR_REC DirEntry,
    IN PSTRING FileName
    )

{
    STRING DirentString;
    ULONG Count;

    PUCHAR StringPtr;

    //
    //  We never match either '\0' or '\1'.  We will return 'LessThan' in
    //  all of these cases.
    //

    if (DirEntry->FileIdLen == 1
        && (DirEntry->FileId[0] == '\0'
            || DirEntry->FileId[0] == '\1')) {

        return LessThan;
    }

    //
    //  We assume that we can use the entire file name in the dirent.
    //

    DirentString.Length = DirEntry->FileIdLen;
    DirentString.Buffer = DirEntry->FileId;

    //
    //  We walk backwards through the dirent name to check for the
    //  existance of a ';' character.  We then set the string length
    //  to this position.
    //

    StringPtr = DirentString.Buffer + DirentString.Length - 1;
    Count = DirentString.Length;

    while (Count--) {

        if (*StringPtr == ';') {

            DirentString.Length = (SHORT)Count;
            break;
        }

        StringPtr--;
    }

    //
    //  We also check for a terminating '.' character and truncate it.
    //

    StringPtr = DirentString.Buffer + DirentString.Length - 1;
    Count = DirentString.Length;

    while (Count--) {

        if (*StringPtr == '.') {

            DirentString.Length = (SHORT)Count;

        } else {

            break;
        }

        StringPtr--;
    }

    //
    //  We now have the two filenames to compare.  The result of this
    //  operation is simply the comparison of the two of them.
    //

    DirentString.MaximumLength = DirentString.Length;

    return CdfsCompareNames( &DirentString, FileName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\etfsboot.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    EtfsBoot.h

Abstract:

    This module defines globally used procedure and data structures used
    by Etfs boot.

Author:

    Steve Collins    [stevec]   25-Nov-1995

Revision History:

--*/

#ifndef _ETFSBOOT_
#define _ETFSBOOT_

//
//  The following constants are values from the disk.
//

#define ELTORITO_VD_SECTOR          (16)
#define ELTORITO_BRVD_SECTOR        (17)
#define ET_SYS_ID                  "EL TORITO SPECIFICATION"
#define BRVD_VERSION_1              (1)
#define VD_BOOTREC                  (0)

typedef struct _RAW_ET_BRVD {

    UCHAR       BrIndicator;        // boot record indicator = 0
    UCHAR       StandardId[5];      // volume structure standard id = "CD001"
    UCHAR       Version;            // descriptor version number = 1
    UCHAR       BootSysId[32];      // boot system identifier = "EL TORITO SPECIFICATION"
    UCHAR       Unused1[32];        // unused = 0
    ULONG       BootCatPtr;         // absolute pointer to first sector of boot catalog
    UCHAR       Reserved[1973];     // unused = 0

} RAW_ET_BRVD;
typedef RAW_ET_BRVD *PRAW_ET_BRVD;


//
//  The following macros are used to recover data from the different
//  volume descriptor structures.
//

#define RBRVD_BR_IND( r )   		( r->BrIndicator )
#define RBRVD_STD_ID( r )			( r->StandardId )
#define RBRVD_VERSION( r )   		( r->Version )
#define RBRVD_SYS_ID( r )			( r->BootSysId )

typedef struct _ETFS_STRUCTURE_CONTEXT {

    //
    //  The following field is the sector offset of the start of
    //  directory data.
    //

    ULONG RootDirSectorOffset;

    //
    //  The following field is the start of the sector containing the
    //  this directory.
    //

    ULONG RootDirDiskOffset;

    //
    //  The following field is the size of the directory.
    //

    ULONG RootDirSize;

    //
    //  The following field is the sector offset of the start of
    //  directory data.
    //

    ULONG DirSectorOffset;

    //
    //  The following field is the start of the sector containing the
    //  this directory.
    //

    ULONG DirDiskOffset;

    //
    //  The following field is the size of the directory.
    //

    ULONG DirSize;

    //
    //  The following field indicates the size of the disk Logical Blocks.
    //

    ULONG LbnBlockSize;

    //
    //  The following field indicates the number of logical blocks on the
    //  disk.
    //

    ULONG LogicalBlockCount;

    //
    //  The following indicates whether this is an Iso or Hsg disk.
    //

    BOOLEAN IsIsoVol;

} ETFS_STRUCTURE_CONTEXT, *PETFS_STRUCTURE_CONTEXT;

//
// Define Etfs file context structure.
//

typedef struct _ETFS_FILE_CONTEXT {

    //
    //  The following is the disk offset of the read position for the
    //  start of the file.  This may include the above number of non-file
    //  bytes.
    //

    ULONG DiskOffset;

    //
    //  The following field contains the size of the file, in bytes.
    //

    ULONG FileSize;

    //
    //  The following field indicates whether this is a directory.
    //

    BOOLEAN IsDirectory;

} ETFS_FILE_CONTEXT, *PETFS_FILE_CONTEXT;

//
// Define file I/O prototypes.
//

ARC_STATUS
EtfsClose (
    IN ULONG FileId
    );

ARC_STATUS
EtfsOpen (
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
EtfsRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
EtfsSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
EtfsWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
EtfsGetFileInformation (
    IN ULONG FileId,
    OUT PFILE_INFORMATION Buffer
    );

ARC_STATUS
EtfsSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

ARC_STATUS
EtfsInitialize(
    VOID
    );

#endif // _ETFSBOOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\fatboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    fatboot.c

Abstract:

    This module implements the FAT boot file system used by the operating
    system loader.

Author:

    Gary Kimura (garyki) 29-Aug-1989

Revision History:

--*/

#include "bootlib.h"
#include "stdio.h"
#include "blcache.h"

BOOTFS_INFO FatBootFsInfo={L"fastfat"};

//
//  Conditional debug print routine
//

#ifdef FATBOOTDBG

#define FatDebugOutput(X,Y,Z) {                                      \
    if (BlConsoleOutDeviceId) {                                      \
        CHAR _b[128];                                                \
        ULONG _c;                                                    \
        sprintf(&_b[0], X, Y, Z);                                    \
        ArcWrite(BlConsoleOutDeviceId, &_b[0], strlen(&_b[0]), &_c); \
    }                                                                \
}

#define CharOrSpace(C) ((C) < 0x20 ? 0x20: (C))

#define FatDebugOutput83(X,N,Y,Z) {                                  \
    if (BlConsoleOutDeviceId) {                                      \
        CHAR _b[128];                                                \
        CHAR _n[13];                                                 \
        ULONG _c;                                                    \
        sprintf(&_n[0], "> %c%c%c%c%c%c%c%c.%c%c%c <",               \
                        CharOrSpace(*((PCHAR)N +0)),                 \
                        CharOrSpace(*((PCHAR)N +1)),                 \
                        CharOrSpace(*((PCHAR)N +2)),                 \
                        CharOrSpace(*((PCHAR)N +3)),                 \
                        CharOrSpace(*((PCHAR)N +4)),                 \
                        CharOrSpace(*((PCHAR)N +5)),                 \
                        CharOrSpace(*((PCHAR)N +6)),                 \
                        CharOrSpace(*((PCHAR)N +7)),                 \
                        CharOrSpace(*((PCHAR)N +8)),                 \
                        CharOrSpace(*((PCHAR)N +9)),                 \
                        CharOrSpace(*((PCHAR)N +10)));               \
        sprintf(&_b[0], X, _n, Y, Z);                                \
        ArcWrite(BlConsoleOutDeviceId, &_b[0], strlen(&_b[0]), &_c); \
    }                                                                \
}

#else

#define FatDebugOutput(X,Y,Z)        {NOTHING;}
#define FatDebugOutput83(X,N,Y,Z)    {NOTHING;}
#endif // FATBOOTDBG


//
//  Low level disk I/O procedure prototypes
//

ARC_STATUS
FatDiskRead (
    IN ULONG DeviceId,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PVOID Buffer,
    IN BOOLEAN CacheNewData
    );

ARC_STATUS
FatDiskWrite (
    IN ULONG DeviceId,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PVOID Buffer
    );

//
//  VOID
//  DiskRead (
//      IN ULONG DeviceId,
//      IN LBO Lbo,
//      IN ULONG ByteCount,
//      IN PVOID Buffer,
//      IN BOOLEAN CacheNewData,
//      IN BOOLEAN IsDoubleSpace
//      );
//

#define DiskRead(A,B,C,D,E,ignored) { ARC_STATUS _s;               \
    if ((_s = FatDiskRead(A,B,C,D,E)) != ESUCCESS) { return _s; }  \
}

#define DiskWrite(A,B,C,D) { ARC_STATUS _s;                      \
    if ((_s = FatDiskWrite(A,B,C,D)) != ESUCCESS) { return _s; } \
}


//
//  Cluster/Index routines
//

typedef enum _CLUSTER_TYPE {
    FatClusterAvailable,
    FatClusterReserved,
    FatClusterBad,
    FatClusterLast,
    FatClusterNext
} CLUSTER_TYPE;

CLUSTER_TYPE
FatInterpretClusterType (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN FAT_ENTRY Entry
    );

ARC_STATUS
FatLookupFatEntry (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN ULONG FatIndex,
    OUT PULONG FatEntry,
    IN BOOLEAN IsDoubleSpace
    );

ARC_STATUS
FatSetFatEntry (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN FAT_ENTRY FatIndex,
    IN FAT_ENTRY FatEntry
    );

ARC_STATUS
FatFlushFatEntries (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId
    );

LBO
FatIndexToLbo (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN FAT_ENTRY FatIndex
    );

#define LookupFatEntry(A,B,C,D,E) { ARC_STATUS _s;                      \
    if ((_s = FatLookupFatEntry(A,B,C,D,E)) != ESUCCESS) { return _s; } \
}

#define SetFatEntry(A,B,C,D) { ARC_STATUS _s;                      \
    if ((_s = FatSetFatEntry(A,B,C,D)) != ESUCCESS) { return _s; } \
}

#define FlushFatEntries(A,B) { ARC_STATUS _s;                      \
    if ((_s = FatFlushFatEntries(A,B)) != ESUCCESS) { return _s; } \
}


//
//  Directory routines
//

ARC_STATUS
FatSearchForDirent (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN FAT_ENTRY DirectoriesStartingIndex,
    IN PFAT8DOT3 FileName,
    OUT PDIRENT Dirent,
    OUT PLBO Lbo,
    IN BOOLEAN IsDoubleSpace
    );

ARC_STATUS
FatCreateDirent (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN FAT_ENTRY DirectoriesStartingIndex,
    IN PDIRENT Dirent,
    OUT PLBO Lbo
    );

VOID
FatSetDirent (
    IN PFAT8DOT3 FileName,
    IN OUT PDIRENT Dirent,
    IN UCHAR Attributes
    );

#define SearchForDirent(A,B,C,D,E,F,G) { ARC_STATUS _s;                      \
    if ((_s = FatSearchForDirent(A,B,C,D,E,F,G)) != ESUCCESS) { return _s; } \
}

#define CreateDirent(A,B,C,D,E) { ARC_STATUS _s;                      \
    if ((_s = FatCreateDirent(A,B,C,D,E)) != ESUCCESS) { return _s; } \
}


//
//  Allocation and mcb routines
//

ARC_STATUS
FatLoadMcb (
    IN ULONG FileId,
    IN VBO StartingVbo,
    IN BOOLEAN IsDoubleSpace
    );

ARC_STATUS
FatVboToLbo (
    IN ULONG FileId,
    IN VBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG ByteCount,
    IN BOOLEAN IsDoubleSpace
    );

ARC_STATUS
FatIncreaseFileAllocation (
    IN ULONG FileId,
    IN ULONG ByteSize
    );

ARC_STATUS
FatTruncateFileAllocation (
    IN ULONG FileId,
    IN ULONG ByteSize
    );

ARC_STATUS
FatAllocateClusters (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN ULONG ClusterCount,
    IN ULONG Hint,
    OUT PULONG AllocatedEntry
    );

#define LoadMcb(A,B,C) { ARC_STATUS _s;                      \
    if ((_s = FatLoadMcb(A,B,C)) != ESUCCESS) { return _s; } \
}

#define VboToLbo(A,B,C,D) { ARC_STATUS _s;                            \
    if ((_s = FatVboToLbo(A,B,C,D,FALSE)) != ESUCCESS) { return _s; } \
}

#define IncreaseFileAllocation(A,B) { ARC_STATUS _s;                      \
    if ((_s = FatIncreaseFileAllocation(A,B)) != ESUCCESS) { return _s; } \
}

#define TruncateFileAllocation(A,B) { ARC_STATUS _s;                      \
    if ((_s = FatTruncateFileAllocation(A,B)) != ESUCCESS) { return _s; } \
}

#define AllocateClusters(A,B,C,D,E) { ARC_STATUS _s;                      \
    if ((_s = FatAllocateClusters(A,B,C,D,E)) != ESUCCESS) { return _s; } \
}


//
//  Miscellaneous routines
//

VOID
FatFirstComponent (
    IN OUT PSTRING String,
    OUT PFAT8DOT3 FirstComponent
    );

#define AreNamesEqual(X,Y) (                                                      \
    ((*(X))[0]==(*(Y))[0]) && ((*(X))[1]==(*(Y))[1]) && ((*(X))[2]==(*(Y))[2]) && \
    ((*(X))[3]==(*(Y))[3]) && ((*(X))[4]==(*(Y))[4]) && ((*(X))[5]==(*(Y))[5]) && \
    ((*(X))[6]==(*(Y))[6]) && ((*(X))[7]==(*(Y))[7]) && ((*(X))[8]==(*(Y))[8]) && \
    ((*(X))[9]==(*(Y))[9]) && ((*(X))[10]==(*(Y))[10])                            \
)

#define ToUpper(C) ((((C) >= 'a') && ((C) <= 'z')) ? (C) - 'a' + 'A' : (C))

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))
#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)(((Flags) & (SingleFlag)) != 0))
#define SetFlag(Flags,SingleFlag)       { (Flags) |= (SingleFlag); }
#define ClearFlag(Flags,SingleFlag)     { (Flags) &= ~(SingleFlag); }

#define FatFirstFatAreaLbo(B) ( (B)->ReservedSectors * (B)->BytesPerSector )

#define Minimum(X,Y) ((X) < (Y) ? (X) : (Y))
#define Maximum(X,Y) ((X) < (Y) ? (Y) : (X))

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 { UCHAR  Uchar[1]; UCHAR  ForceAlignment; } UCHAR1, *PUCHAR1;
typedef union _UCHAR2 { UCHAR  Uchar[2]; USHORT ForceAlignment; } UCHAR2, *PUCHAR2;
typedef union _UCHAR4 { UCHAR  Uchar[4]; ULONG  ForceAlignment; } UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }

//
// DirectoryEntry routines
//

VOID
FatDirToArcDir (
    IN PDIRENT FatDirent,
    OUT PDIRECTORY_ENTRY ArcDirent
    );


//
// Define global data.
//

//
// File entry table - This is a structure that provides entry to the FAT
//      file system procedures. It is exported when a FAT file structure
//      is recognized.
//

BL_DEVICE_ENTRY_TABLE FatDeviceEntryTable;


PBL_DEVICE_ENTRY_TABLE
IsFatFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    )

/*++

Routine Description:

    This routine determines if the partition on the specified channel
    contains a FAT file system volume.

Arguments:

    DeviceId - Supplies the file table index for the device on which
        read operations are to be performed.

    StructureContext - Supplies a pointer to a FAT file structure context.

Return Value:

    A pointer to the FAT entry table is returned if the partition is
    recognized as containing a FAT volume.  Otherwise, NULL is returned.

--*/

{
    PPACKED_BOOT_SECTOR BootSector;
    UCHAR Buffer[sizeof(PACKED_BOOT_SECTOR)+256];

    PFAT_STRUCTURE_CONTEXT FatStructureContext;

    FatDebugOutput("IsFatFileStructure\r\n", 0, 0);

    //
    //  Clear the file system context block for the specified channel and
    //  establish a pointer to the context structure that can be used by other
    //  routines
    //

    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)StructureContext;
    RtlZeroMemory(FatStructureContext, sizeof(FAT_STRUCTURE_CONTEXT));

    //
    //  Setup and read in the boot sector for the potential fat partition
    //

    BootSector = (PPACKED_BOOT_SECTOR)ALIGN_BUFFER( &Buffer[0] );

    if (FatDiskRead(DeviceId, 0, sizeof(PACKED_BOOT_SECTOR), BootSector, CACHE_NEW_DATA) != ESUCCESS) {

        return NULL;
    }

    //
    //  Unpack the Bios parameter block
    //

    FatUnpackBios(&FatStructureContext->Bpb, &BootSector->PackedBpb);

    //
    //  Check if it is fat
    //
    if ((BootSector->Jump[0] != 0xeb) &&
        (BootSector->Jump[0] != 0xe9)) {

        return NULL;

    } else if ((FatStructureContext->Bpb.BytesPerSector !=  128) &&
               (FatStructureContext->Bpb.BytesPerSector !=  256) &&
               (FatStructureContext->Bpb.BytesPerSector !=  512) &&
               (FatStructureContext->Bpb.BytesPerSector != 1024)) {

        return NULL;

    } else if ((FatStructureContext->Bpb.SectorsPerCluster !=  1) &&
               (FatStructureContext->Bpb.SectorsPerCluster !=  2) &&
               (FatStructureContext->Bpb.SectorsPerCluster !=  4) &&
               (FatStructureContext->Bpb.SectorsPerCluster !=  8) &&
               (FatStructureContext->Bpb.SectorsPerCluster != 16) &&
               (FatStructureContext->Bpb.SectorsPerCluster != 32) &&
               (FatStructureContext->Bpb.SectorsPerCluster != 64) &&
               (FatStructureContext->Bpb.SectorsPerCluster != 128)) {

        return NULL;

    } else if (FatStructureContext->Bpb.ReservedSectors == 0) {

        return NULL;

    } else if (((FatStructureContext->Bpb.Sectors == 0) && (FatStructureContext->Bpb.LargeSectors == 0)) ||
               ((FatStructureContext->Bpb.Sectors != 0) && (FatStructureContext->Bpb.LargeSectors != 0))) {

        return NULL;

    } else if (FatStructureContext->Bpb.Fats == 0) {

        return NULL;

    } else if ((FatStructureContext->Bpb.Media != 0xf0) &&
               (FatStructureContext->Bpb.Media != 0xf8) &&
               (FatStructureContext->Bpb.Media != 0xf9) &&
               (FatStructureContext->Bpb.Media != 0xfc) &&
               (FatStructureContext->Bpb.Media != 0xfd) &&
               (FatStructureContext->Bpb.Media != 0xfe) &&
               (FatStructureContext->Bpb.Media != 0xff)) {

        return NULL;

    } else if (FatStructureContext->Bpb.SectorsPerFat == 0) {

        if (!IsBpbFat32(&BootSector->PackedBpb)) {
            return NULL;
        }

    } else if (FatStructureContext->Bpb.RootEntries == 0) {

        return NULL;

    }

    //
    //  Initialize the file entry table and return the address of the table.
    //

    FatDeviceEntryTable.Open  = FatOpen;
    FatDeviceEntryTable.Close = FatClose;
    FatDeviceEntryTable.Read  = FatRead;
    FatDeviceEntryTable.Seek  = FatSeek;
    FatDeviceEntryTable.Write = FatWrite;
    FatDeviceEntryTable.GetFileInformation = FatGetFileInformation;
    FatDeviceEntryTable.SetFileInformation = FatSetFileInformation;
    FatDeviceEntryTable.Rename = FatRename;
    FatDeviceEntryTable.GetDirectoryEntry   = FatGetDirectoryEntry;
    FatDeviceEntryTable.BootFsInfo = &FatBootFsInfo;


    return &FatDeviceEntryTable;
}

ARC_STATUS
FatClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    This routine closes the file specified by the file id.

Arguments:

    FileId - Supplies the file table index.

Return Value:

    ESUCCESS if returned as the function value.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    ULONG DeviceId;

    FatDebugOutput("FatClose\r\n", 0, 0);

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    DeviceId = FileTableEntry->DeviceId;

    //
    //  Mark the file closed
    //

    BlFileTable[FileId].Flags.Open = 0;

    //
    //  Check if the fat is dirty and flush it out if it is.
    //

    if (FatStructureContext->CachedFatDirty) {

        FlushFatEntries( FatStructureContext, DeviceId );
    }

    //
    //  Check if the current mcb is for this file and if it is then zero it out.
    //  By setting the file id for the mcb to be the table size we guarantee that
    //  we've just set it to an invalid file id.
    //

    if (FatStructureContext->FileId == FileId) {

        FatStructureContext->FileId = BL_FILE_TABLE_SIZE;
        FatStructureContext->Mcb.InUse = 0;
    }

    return ESUCCESS;
}


ARC_STATUS
FatGetDirectoryEntry (
    IN ULONG FileId,
    IN DIRECTORY_ENTRY * FIRMWARE_PTR DirEntry,
    IN ULONG NumberDir,
    OUT ULONG * FIRMWARE_PTR CountDir
    )

/*++

Routine Description:

    This routine implements the GetDirectoryEntry operation for the
    FAT file system.

Arguments:

    FileId - Supplies the file table index.

    DirEntry - Supplies a pointer to a directory entry structure.

    NumberDir - Supplies the number of directory entries to read.

    Count - Supplies a pointer to a variable to receive the number
            of entries read.

Return Value:

    ESUCCESS is returned if the read was successful, otherwise
    an error code is returned.

--*/

{
    //
    // define local variables
    //

    ARC_STATUS Status;                 // ARC status
    ULONG Count = 0;                   // # of bytes read
    ULONG Position;                    // file position
    PFAT_FILE_CONTEXT pContext;        // FAT file context
    ULONG RunByteCount = 0;            // max sequential bytes
    ULONG RunDirCount;                 // max dir entries to read per time
    ULONG i;                           // general index
    PDIRENT FatDirEnt;                 // directory entry pointer
    UCHAR Buffer[ 16 * sizeof(DIRENT) + 32 ];
    LBO Lbo;
    BOOLEAN EofDir = FALSE;            // not end of file

    //
    // initialize local variables
    //

    pContext = &BlFileTable[ FileId ].u.FatFileContext;
    FatDirEnt = (PDIRENT)ALIGN_BUFFER( &Buffer[0] );

    //
    // if not directory entry, exit with error
    //

    if ( !FlagOn(pContext->Dirent.Attributes, FAT_DIRENT_ATTR_DIRECTORY) ) {

        return EBADF;
    }

    //
    // Initialize the output count to zero
    //

    *CountDir = 0;

    //
    // if NumberDir is zero, return ESUCCESS.
    //

    if ( !NumberDir ) {

        return ESUCCESS;
    }

    //
    // read one directory at a time.
    //

    do {

        //
        // save position
        //

        Position = BlFileTable[ FileId ].Position.LowPart;

        //
        //  Lookup the corresponding Lbo and run length for the current position
        //

        if ( !RunByteCount ) {

            if (Status = FatVboToLbo( FileId, Position, &Lbo, &RunByteCount, FALSE )) {

                if ( Status == EINVAL ) {

                    break;                      // eof has been reached

                } else {

                    return Status;              // I/O error
                }
            }
        }

        //
        // validate the # of bytes readable in sequance (exit loop if eof)
        // the block is always multiple of a directory entry size.
        //

        if ( !(RunDirCount = Minimum( RunByteCount/sizeof(DIRENT), 16)) ) {

            break;
        }

        //
        //  issue the read
        //

        if ( Status = FatDiskRead( BlFileTable[ FileId ].DeviceId,
                                   Lbo,
                                   RunDirCount * sizeof(DIRENT),
                                   (PVOID)FatDirEnt,
                                   CACHE_NEW_DATA)) {

            BlFileTable[ FileId ].Position.LowPart = Position;
            return Status;
        }

        for ( i=0; i<RunDirCount; i++ ) {

            //
            // exit from loop if logical end of directory
            //

            if ( FatDirEnt[i].FileName[0] == FAT_DIRENT_NEVER_USED ) {

                EofDir = TRUE;
                break;
            }

            //
            // update the current position and the number of bytes transfered
            //

            BlFileTable[ FileId ].Position.LowPart += sizeof(DIRENT);
            Lbo += sizeof(DIRENT);
            RunByteCount -= sizeof(DIRENT);

            //
            // skip this entry if the file or directory has been erased
            //

            if ( FatDirEnt[i].FileName[0] == FAT_DIRENT_DELETED ) {

                continue;
            }

            //
            // skip this entry if this is a valume label
            //

            if (FlagOn( FatDirEnt[i].Attributes, FAT_DIRENT_ATTR_VOLUME_ID )) {

                continue;
            }

            //
            // convert FAT directory entry in ARC directory entry
            //

            FatDirToArcDir( &FatDirEnt[i], DirEntry++ );

            //
            // update pointers
            //

            if ( ++*CountDir >= NumberDir ) {

                break;
            }
        }

    } while ( !EofDir  &&  *CountDir < NumberDir );

    //
    // all done
    //

    return *CountDir ? ESUCCESS : ENOTDIR;
}


ARC_STATUS
FatGetFileInformation (
    IN ULONG FileId,
    OUT PFILE_INFORMATION Buffer
    )

/*++

Routine Description:

    This procedure returns to the user a buffer filled with file information

Arguments:

    FileId - Supplies the File id for the operation

    Buffer - Supplies the buffer to receive the file information.  Note that
        it must be large enough to hold the full file name

Return Value:

    ESUCCESS is returned if the open operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    UCHAR Attributes;
    ULONG i;

    FatDebugOutput("FatGetFileInformation\r\n", 0, 0);

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[FileId];
    Attributes = FileTableEntry->u.FatFileContext.Dirent.Attributes;

    //
    //  Zero out the buffer, and fill in its non-zero values.
    //

    RtlZeroMemory(Buffer, sizeof(FILE_INFORMATION));

    Buffer->EndingAddress.LowPart = FileTableEntry->u.FatFileContext.Dirent.FileSize;

    Buffer->CurrentPosition.LowPart = FileTableEntry->Position.LowPart;
    Buffer->CurrentPosition.HighPart = 0;

    if (FlagOn(Attributes, FAT_DIRENT_ATTR_READ_ONLY)) { SetFlag(Buffer->Attributes, ArcReadOnlyFile) };
    if (FlagOn(Attributes, FAT_DIRENT_ATTR_HIDDEN))    { SetFlag(Buffer->Attributes, ArcHiddenFile) };
    if (FlagOn(Attributes, FAT_DIRENT_ATTR_SYSTEM))    { SetFlag(Buffer->Attributes, ArcSystemFile) };
    if (FlagOn(Attributes, FAT_DIRENT_ATTR_ARCHIVE))   { SetFlag(Buffer->Attributes, ArcArchiveFile) };
    if (FlagOn(Attributes, FAT_DIRENT_ATTR_DIRECTORY)) { SetFlag(Buffer->Attributes, ArcDirectoryFile) };

    Buffer->FileNameLength = FileTableEntry->FileNameLength;

    for (i = 0; i < FileTableEntry->FileNameLength; i += 1) {

        Buffer->FileName[i] = FileTableEntry->FileName[i];
    }

    return ESUCCESS;
}


ARC_STATUS
FatOpen (
    IN CHAR * FIRMWARE_PTR FileName,
    IN OPEN_MODE OpenMode,
    IN ULONG * FIRMWARE_PTR FileId
    )

/*++

Routine Description:

    This routine searches the device for a file matching FileName.
    If a match is found the dirent for the file is saved and the file is
    opened.

Arguments:

    FileName - Supplies a pointer to a zero terminated file name.

    OpenMode - Supplies the mode of the open.

    FileId - Supplies a pointer to a variable that specifies the file
        table entry that is to be filled in if the open is successful.

Return Value:

    ESUCCESS is returned if the open operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    ULONG DeviceId;

    FAT_ENTRY CurrentDirectoryIndex;
    BOOLEAN SearchSucceeded;
    BOOLEAN IsDirectory;
    BOOLEAN IsReadOnly;

    STRING PathName;
    FAT8DOT3 Name;

    FatDebugOutput("FatOpen: %s\r\n", FileName, 0);

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[*FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    DeviceId = FileTableEntry->DeviceId;

    //
    //  Construct a file name descriptor from the input file name
    //

    RtlInitString( &PathName, FileName );

    //
    //  While the path name has some characters in it we'll go through our loop
    //  which extracts the first part of the path name and searches the current
    //  directory for an entry.  If what we find is a directory then we have to
    //  continue looping until we're done with the path name.
    //

    FileTableEntry->u.FatFileContext.DirentLbo = 0;
    FileTableEntry->Position.LowPart = 0;
    FileTableEntry->Position.HighPart = 0;

    CurrentDirectoryIndex = 0;
    SearchSucceeded = TRUE;
    IsDirectory = TRUE;
    IsReadOnly = TRUE;

    if ((PathName.Buffer[0] == '\\') && (PathName.Length == 1)) {

        //
        // We are opening the root directory.
        //
        // N.B.: IsDirectory and SearchSucceeded are already TRUE.
        //

        PathName.Length = 0;

        FileTableEntry->FileNameLength = 1;
        FileTableEntry->FileName[0] = PathName.Buffer[0];

        //
        // Root dirent is all zeroes with a directory attribute.
        //

        RtlZeroMemory(&FileTableEntry->u.FatFileContext.Dirent, sizeof(DIRENT));

        FileTableEntry->u.FatFileContext.Dirent.Attributes = FAT_DIRENT_ATTR_DIRECTORY;

        FileTableEntry->u.FatFileContext.DirentLbo = 0;

        IsReadOnly = FALSE;

        CurrentDirectoryIndex = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;

    } else {

        //
        // We are not opening the root directory.
        //

        //
        //  If the search begins in a FAT32 root, set up the starting point
        //  for the  search.
        //

        if (IsBpbFat32(&FatStructureContext->Bpb)) {

            CurrentDirectoryIndex = FatStructureContext->Bpb.RootDirFirstCluster;
        }

        while ((PathName.Length > 0) && IsDirectory) {

            ARC_STATUS Status;

            //
            //  Extract the first component and search the directory for a match, but
            //  first copy the first part to the file name buffer in the file table entry
            //

            if (PathName.Buffer[0] == '\\') {
                PathName.Buffer +=1;
                PathName.Length -=1;
            }

            for (FileTableEntry->FileNameLength = 0;
                 (((USHORT)FileTableEntry->FileNameLength < PathName.Length) &&
                  (PathName.Buffer[FileTableEntry->FileNameLength] != '\\'));
                 FileTableEntry->FileNameLength += 1) {

                FileTableEntry->FileName[FileTableEntry->FileNameLength] =
                                             PathName.Buffer[FileTableEntry->FileNameLength];
            }

            FatFirstComponent( &PathName, &Name );

            Status = FatSearchForDirent( FatStructureContext,
                                         DeviceId,
                                         CurrentDirectoryIndex,
                                         &Name,
                                         &FileTableEntry->u.FatFileContext.Dirent,
                                         &FileTableEntry->u.FatFileContext.DirentLbo,
                                         FALSE );

            if (Status == ENOENT) {

                SearchSucceeded = FALSE;
                break;
            }

            if (Status != ESUCCESS) {

                return Status;
            }

            //
            //  We have a match now check to see if it is a directory, and also
            //  if it is readonly
            //

            IsDirectory = BooleanFlagOn( FileTableEntry->u.FatFileContext.Dirent.Attributes,
                                         FAT_DIRENT_ATTR_DIRECTORY );

            IsReadOnly = BooleanFlagOn( FileTableEntry->u.FatFileContext.Dirent.Attributes,
                                        FAT_DIRENT_ATTR_READ_ONLY );

            if (IsDirectory) {

                CurrentDirectoryIndex = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;

                if (IsBpbFat32(&FatStructureContext->Bpb)) {

                    CurrentDirectoryIndex += 0x10000 *
                         FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi;
                }
            }
        }
    }

    //
    //  If the path name length is not zero then we were trying to crack a path
    //  with an nonexistent (or non directory) name in it.  For example, we tried
    //  to crack a\b\c\d and b is not a directory or does not exist (then the path
    //  name will still contain c\d).
    //

    if (PathName.Length != 0) {

        return ENOTDIR;
    }

    //
    //  At this point we've cracked the name up to (an maybe including the last
    //  component).  We located the last component if the SearchSucceeded flag is
    //  true, otherwise the last component does not exist.  If we located the last
    //  component then this is like an open or a supersede, but not a create.
    //

    if (SearchSucceeded) {

        //
        //  Check if the last component is a directory
        //

        if (IsDirectory) {

            //
            //  For an existing directory the only valid open mode is OpenDirectory
            //  all other modes return an error
            //

            switch (OpenMode) {

            case ArcOpenReadOnly:
            case ArcOpenWriteOnly:
            case ArcOpenReadWrite:
            case ArcCreateWriteOnly:
            case ArcCreateReadWrite:
            case ArcSupersedeWriteOnly:
            case ArcSupersedeReadWrite:

                //
                //  If we reach here then the caller got a directory but didn't
                //  want to open a directory
                //

                return EISDIR;

            case ArcOpenDirectory:

                //
                //  If we reach here then the caller got a directory and wanted
                //  to open a directory.
                //

                FileTableEntry->Flags.Open = 1;
                FileTableEntry->Flags.Read = 1;

                return ESUCCESS;

            case ArcCreateDirectory:

                //
                //  If we reach here then the caller got a directory and wanted
                //  to create a new directory
                //

                return EACCES;
            }
        }

        //
        //  If we get there then we have an existing file that is being opened.
        //  We can open existing files through a lot of different open modes in
        //  some cases we need to check the read only part of file and/or truncate
        //  the file.
        //

        switch (OpenMode) {

        case ArcOpenReadOnly:

            //
            //  If we reach here then the user got a file and wanted to open the
            //  file read only
            //

            FileTableEntry->Flags.Open = 1;
            FileTableEntry->Flags.Read = 1;

            return ESUCCESS;

        case ArcOpenWriteOnly:

            //
            //  If we reach here then the user got a file and wanted to open the
            //  file write only
            //

            if (IsReadOnly) { return EROFS; }
            FileTableEntry->Flags.Open = 1;
            FileTableEntry->Flags.Write = 1;

            return ESUCCESS;

        case ArcOpenReadWrite:

            //
            //  If we reach here then the user got a file and wanted to open the
            //  file read/write
            //

            if (IsReadOnly) { return EROFS; }
            FileTableEntry->Flags.Open = 1;
            FileTableEntry->Flags.Read = 1;
            FileTableEntry->Flags.Write = 1;

            return ESUCCESS;

        case ArcCreateWriteOnly:
        case ArcCreateReadWrite:

            //
            //  If we reach here then the user got a file and wanted to create a new
            //  file
            //

            return EACCES;

        case ArcSupersedeWriteOnly:

            //
            //  If we reach here then the user got a file and wanted to supersede a
            //  file
            //

            if (IsReadOnly) { return EROFS; }
            TruncateFileAllocation( *FileId, 0 );
            FileTableEntry->Flags.Open = 1;
            FileTableEntry->Flags.Read = 1;
            FileTableEntry->Flags.Write = 1;

            return ESUCCESS;

        case ArcSupersedeReadWrite:

            //
            //  If we reach here then the user got a file and wanted to supersede a
            //  file
            //

            if (IsReadOnly) { return EROFS; }
            TruncateFileAllocation( *FileId, 0 );
            FileTableEntry->Flags.Open = 1;
            FileTableEntry->Flags.Read = 1;
            FileTableEntry->Flags.Write = 1;

            return ESUCCESS;

        case ArcOpenDirectory:
        case ArcCreateDirectory:

            //
            //  If we reach here then the user got a file and wanted a directory
            //

            return ENOTDIR;
        }
    }

    //
    //  If we get here the last component does not exist so we are trying to create
    //  either a new file or a directory.
    //

    switch (OpenMode) {

    case ArcOpenReadOnly:
    case ArcOpenWriteOnly:
    case ArcOpenReadWrite:

        //
        //  If we reach here then the user did not get a file but wanted a file
        //

        return ENOENT;

    case ArcCreateWriteOnly:
    case ArcSupersedeWriteOnly:

        //
        //  If we reach here then the user did not get a file and wanted to create
        //  or supersede a file write only
        //

        RtlZeroMemory( &FileTableEntry->u.FatFileContext.Dirent, sizeof(DIRENT));

        FatSetDirent( &Name, &FileTableEntry->u.FatFileContext.Dirent, 0 );

        CreateDirent( FatStructureContext,
                      DeviceId,
                      CurrentDirectoryIndex,
                      &FileTableEntry->u.FatFileContext.Dirent,
                      &FileTableEntry->u.FatFileContext.DirentLbo );

        FileTableEntry->Flags.Open = 1;
        FileTableEntry->Flags.Write = 1;

        return ESUCCESS;

    case ArcCreateReadWrite:
    case ArcSupersedeReadWrite:

        //
        //  If we reach here then the user did not get a file and wanted to create
        //  or supersede a file read/write
        //

        RtlZeroMemory( &FileTableEntry->u.FatFileContext.Dirent, sizeof(DIRENT));

        FatSetDirent( &Name, &FileTableEntry->u.FatFileContext.Dirent, 0 );

        CreateDirent( FatStructureContext,
                      DeviceId,
                      CurrentDirectoryIndex,
                      &FileTableEntry->u.FatFileContext.Dirent,
                      &FileTableEntry->u.FatFileContext.DirentLbo );

        FileTableEntry->Flags.Open = 1;
        FileTableEntry->Flags.Read = 1;
        FileTableEntry->Flags.Write = 1;

        return ESUCCESS;

    case ArcOpenDirectory:

        //
        //  If we reach here then the user did not get a file and wanted to open
        //  an existing directory
        //

        return ENOENT;

    case ArcCreateDirectory:

        //
        //  If we reach here then the user did not get a file and wanted to create
        //  a new directory.
        //

        RtlZeroMemory( &FileTableEntry->u.FatFileContext.Dirent, sizeof(DIRENT));

        FatSetDirent( &Name,
                      &FileTableEntry->u.FatFileContext.Dirent,
                      FAT_DIRENT_ATTR_DIRECTORY );

        CreateDirent( FatStructureContext,
                      DeviceId,
                      CurrentDirectoryIndex,
                      &FileTableEntry->u.FatFileContext.Dirent,
                      &FileTableEntry->u.FatFileContext.DirentLbo );

        IncreaseFileAllocation( *FileId, sizeof(DIRENT) * 2 );

        {
            DIRENT Buffer;
            LBO Lbo;
            ULONG Count;
            ULONG i;
            ULONG Entry;

            RtlZeroMemory((PVOID)&Buffer.FileName[0], sizeof(DIRENT) );

            for (i = 0; i < 11; i += 1) {
                Buffer.FileName[i] = ' ';
            }
            Buffer.Attributes = FAT_DIRENT_ATTR_DIRECTORY;

            VboToLbo( *FileId, 0, &Lbo, &Count );
            Buffer.FileName[0] = FAT_DIRENT_DIRECTORY_ALIAS;

            Buffer.FirstClusterOfFile =
                FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;
            Buffer.FirstClusterOfFileHi =
                FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi;

            DiskWrite( DeviceId, Lbo, sizeof(DIRENT), (PVOID)&Buffer.FileName[0] );

            VboToLbo( *FileId, sizeof(DIRENT), &Lbo, &Count );
            Buffer.FileName[1] = FAT_DIRENT_DIRECTORY_ALIAS;

            Buffer.FirstClusterOfFile = (USHORT)CurrentDirectoryIndex;
            Buffer.FirstClusterOfFileHi = (USHORT)(CurrentDirectoryIndex >> 16);

            DiskWrite( DeviceId, Lbo, sizeof(DIRENT), (PVOID)&Buffer.FileName[0] );
        }

        FileTableEntry->Flags.Open = 1;
        FileTableEntry->Flags.Read = 1;

        return ESUCCESS;
    }

    return( EINVAL );
}


ARC_STATUS
FatRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    )

/*++

Routine Description:

    This routine reads data from the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that receives the data
        read.

    Length - Supplies the number of bytes that are to be read.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the read operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    ULONG DeviceId;

    FatDebugOutput("FatRead\r\n", 0, 0);

    //
    //  Load out local variables
    //

    FileTableEntry = &BlFileTable[FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    DeviceId = FileTableEntry->DeviceId;

    //
    //  Clear the transfer count
    //

    *Transfer = 0;

    //
    //  Read in runs (i.e., bytes) until the byte count goes to zero
    //

    while (Length > 0) {

        LBO Lbo;

        ULONG CurrentRunByteCount;

        //
        //  Lookup the corresponding Lbo and run length for the current position
        //  (i.e., Vbo).
        //

        if (FatVboToLbo( FileId, FileTableEntry->Position.LowPart, &Lbo, &CurrentRunByteCount, FALSE ) != ESUCCESS) {

            return ESUCCESS;
        }

        //
        //  while there are bytes to be read in from the current run
        //  length and we haven't exhausted the request we loop reading
        //  in bytes.  The biggest request we'll handle is only 32KB
        //  contiguous bytes per physical read.  So we might need to loop
        //  through the run.
        //

        while ((Length > 0) && (CurrentRunByteCount > 0)) {

            LONG SingleReadSize;

            //
            //  Compute the size of the next physical read
            //

            SingleReadSize = Minimum(Length, 32 * 1024);
            SingleReadSize = Minimum((ULONG)SingleReadSize, CurrentRunByteCount);

            //
            //  Don't read beyond the eof
            //

            if (((ULONG)SingleReadSize + FileTableEntry->Position.LowPart) >
                FileTableEntry->u.FatFileContext.Dirent.FileSize) {

                SingleReadSize = FileTableEntry->u.FatFileContext.Dirent.FileSize -
                                 FileTableEntry->Position.LowPart;

                //
                //  If the readjusted read length is now zero then we're done.
                //

                if (SingleReadSize <= 0) {

                    return ESUCCESS;
                }

                //
                //  By also setting length here we'll make sure that this is our last
                //  read
                //

                Length = SingleReadSize;
            }

            //
            //  Issue the read
            //

            DiskRead( DeviceId, Lbo, SingleReadSize, Buffer, DONT_CACHE_NEW_DATA, FALSE );

            //
            //  Update the remaining length, Current run byte count
            //  and new Lbo offset
            //

            Length -= SingleReadSize;
            CurrentRunByteCount -= SingleReadSize;
            Lbo += SingleReadSize;

            //
            //  Update the current position and the number of bytes transfered
            //

            FileTableEntry->Position.LowPart += SingleReadSize;
            *Transfer += SingleReadSize;

            //
            //  Update buffer to point to the next byte location to fill in
            //

            Buffer = (PCHAR)Buffer + SingleReadSize;
        }
    }

    //
    //  If we get here then remaining sector count is zero so we can
    //  return success to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
FatRename(
    IN ULONG FileId,
    IN CHAR * FIRMWARE_PTR NewFileName
    )

/*++

Routine Description:

    This routine renames an open file.  It does no checking to
    see if the target filename already exists.  It is intended for use
    only when dual-booting DOS on x86 machines, where it is used to
    replace the NT MVDM CONFIG.SYS and AUTOEXEC.BAT with the native DOS
    CONFIG.SYS and AUTOEXEC.BAT files.

Arguments:

    FileId - Supplies the file id of the file to be renamed

    NewFileName - Supplies the new name for the file.

Return Value:

    ARC_STATUS

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    ULONG DeviceId;
    FAT8DOT3 FatName;
    STRING String;

    //
    //  Initialize our local variables
    //

    RtlInitString( &String, NewFileName );
    FileTableEntry = &BlFileTable[FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    DeviceId = FileTableEntry->DeviceId;

    //
    //  Modify a in-memory copy of the dirent with the new name
    //

    FatFirstComponent( &String, &FatName );

    FatSetDirent( &FatName,
                  &FileTableEntry->u.FatFileContext.Dirent,
                  FileTableEntry->u.FatFileContext.Dirent.Attributes );

    //
    //  Write the modified dirent to disk
    //

    DiskWrite( DeviceId,
               FileTableEntry->u.FatFileContext.DirentLbo,
               sizeof(DIRENT),
               &FileTableEntry->u.FatFileContext.Dirent );

    //
    //  And return to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
FatSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    This routine seeks to the specified position for the file specified
    by the file id.

Arguments:

    FileId - Supplies the file table index.

    Offset - Supplies the offset in the file to position to.

    SeekMode - Supplies the mode of the seek operation.

Return Value:

    ESUCCESS is returned if the seek operation is successful.  Otherwise,
    EINVAL is returned.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    ULONG NewPosition;

    FatDebugOutput("FatSeek\r\n", 0, 0);

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[FileId];

    //
    //  Compute the new position
    //

    if (SeekMode == SeekAbsolute) {

        NewPosition = Offset->LowPart;

    } else {

        NewPosition = FileTableEntry->Position.LowPart + Offset->LowPart;
    }

    //
    //  If the new position is greater than the file size then return
    //  an error
    //

    if (NewPosition > FileTableEntry->u.FatFileContext.Dirent.FileSize) {

        return EINVAL;
    }

    //
    //  Otherwise set the new position and return to our caller
    //

    FileTableEntry->Position.LowPart = NewPosition;

    return ESUCCESS;
}


ARC_STATUS
FatSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )

/*++

Routine Description:

    This routine sets the file attributes of the indicated file

Arguments:

    FileId - Supplies the File Id for the operation

    AttributeFlags - Supplies the value (on or off) for each attribute being modified

    AttributeMask - Supplies a mask of the attributes being altered.  All other
        file attributes are left alone.

Return Value:

    ESUCCESS is returned if the read operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    ULONG DeviceId;
    UCHAR DirentAttributes;
    UCHAR DirentMask;
    UCHAR DirentFlags;

    FatDebugOutput("FatSetFileInformation\r\n", 0, 0);

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    DeviceId = FileTableEntry->DeviceId;

    DirentAttributes = FileTableEntry->u.FatFileContext.Dirent.Attributes;

    //
    //  Check if this is the root directory
    //

    if (FileTableEntry->u.FatFileContext.DirentLbo == 0) {

        return EACCES;
    }

    //
    //  Check if the users wishes to delete the file/directory
    //

    if (FlagOn(AttributeMask, ArcDeleteFile) && FlagOn(AttributeFlags, ArcDeleteFile)) {

        //
        //  Check if the file/directory is marked read only
        //

        if (FlagOn(DirentAttributes, FAT_DIRENT_ATTR_READ_ONLY)) {

            return EACCES;
        }

        //
        //  Check if this is a directory because we need to then check if the
        //  directory is empty
        //

        if (FlagOn(DirentAttributes, FAT_DIRENT_ATTR_DIRECTORY)) {

            ULONG BytesPerCluster;
            FAT_ENTRY FatEntry;
            CLUSTER_TYPE ClusterType;

            BytesPerCluster = FatBytesPerCluster( &FatStructureContext->Bpb );

            if (IsBpbFat32(&FatStructureContext->Bpb)) {
                FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile |
                    (FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi << 16);
            } else {
                FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;
            }

            ClusterType = FatInterpretClusterType( FatStructureContext, FatEntry );

            //
            //  Now loop through each cluster, and compute the starting Lbo for each
            //  cluster that we encounter
            //

            while (ClusterType == FatClusterNext) {

                LBO ClusterLbo;
                ULONG Offset;

                ClusterLbo = FatIndexToLbo( FatStructureContext, FatEntry );

                //
                //  Now for each dirent in the cluster compute the lbo, read in the dirent
                //  and check if it is in use
                //

                for (Offset = 0; Offset < BytesPerCluster; Offset += sizeof(DIRENT)) {

                    DIRENT Dirent;

                    DiskRead( DeviceId, Offset + ClusterLbo, sizeof(DIRENT), &Dirent, CACHE_NEW_DATA, FALSE );

                    if (Dirent.FileName[0] == FAT_DIRENT_NEVER_USED) {

                        break;
                    }

                    if ((Dirent.FileName[0] != FAT_DIRENT_DIRECTORY_ALIAS) ||
                        (Dirent.FileName[0] != FAT_DIRENT_DELETED)) {

                        return EACCES;
                    }
                }

                //
                //  Now that we've exhausted the current cluster we need to read
                //  in the next cluster.  So locate the next fat entry in the chain
                //  and go back to the top of the while loop.
                //

                LookupFatEntry( FatStructureContext, DeviceId, FatEntry, &FatEntry, FALSE );

                ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);
            }
        }

        //
        //  At this point the file/directory can be deleted so mark the name
        //  as deleted and write it back out
        //

        FileTableEntry->u.FatFileContext.Dirent.FileName[0] = FAT_DIRENT_DELETED;

        DiskWrite( DeviceId,
                   FileTableEntry->u.FatFileContext.DirentLbo,
                   sizeof(DIRENT),
                   &FileTableEntry->u.FatFileContext.Dirent );

        //
        //  And then truncate any file allocation assigned to the file
        //

        TruncateFileAllocation( FileId, 0);

        return ESUCCESS;
    }

    //
    //  At this point the user does not want to delete the file so we only
    //  need to modify the attributes
    //

    DirentMask = 0;
    DirentFlags = 0;

    //
    //  Build up a mask and flag byte that correspond to the bits in the dirent
    //

    if (FlagOn(AttributeMask, ArcReadOnlyFile)) { SetFlag(DirentMask, FAT_DIRENT_ATTR_READ_ONLY); }
    if (FlagOn(AttributeMask, ArcHiddenFile))   { SetFlag(DirentMask, FAT_DIRENT_ATTR_HIDDEN); }
    if (FlagOn(AttributeMask, ArcSystemFile))   { SetFlag(DirentMask, FAT_DIRENT_ATTR_SYSTEM); }
    if (FlagOn(AttributeMask, ArcArchiveFile))  { SetFlag(DirentMask, FAT_DIRENT_ATTR_ARCHIVE); }

    if (FlagOn(AttributeFlags, ArcReadOnlyFile)) { SetFlag(DirentFlags, FAT_DIRENT_ATTR_READ_ONLY); }
    if (FlagOn(AttributeFlags, ArcHiddenFile))   { SetFlag(DirentFlags, FAT_DIRENT_ATTR_HIDDEN); }
    if (FlagOn(AttributeFlags, ArcSystemFile))   { SetFlag(DirentFlags, FAT_DIRENT_ATTR_SYSTEM); }
    if (FlagOn(AttributeFlags, ArcArchiveFile))  { SetFlag(DirentFlags, FAT_DIRENT_ATTR_ARCHIVE); }

    //
    //  The new attributes is calculated via the following formula
    //
    //      Attributes = (~Mask & OldAttributes) | (Mask & NewAttributes);
    //
    //  After we calculate the new attribute byte we write it out.
    //

    FileTableEntry->u.FatFileContext.Dirent.Attributes = (UCHAR)((~DirentMask & DirentAttributes) |
                                                                 (DirentMask & DirentFlags));

    DiskWrite( DeviceId,
               FileTableEntry->u.FatFileContext.DirentLbo,
               sizeof(DIRENT),
               &FileTableEntry->u.FatFileContext.Dirent );

    return ESUCCESS;
}


ARC_STATUS
FatWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    )

/*++

Routine Description:

    This routine writes data to the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that contains the data
        written.

    Length - Supplies the number of bytes that are to be written.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the write operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    ULONG DeviceId;
    ULONG OffsetBeyondWrite;

    FatDebugOutput("FatWrite\r\n", 0, 0);

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    DeviceId = FileTableEntry->DeviceId;

    //
    //  Reset the file size to be the maximum of what is it now and the end of
    //  our write.  We will assume that there is always enough allocation to support
    //  the file size, so we only need to increase allocation if we are increasing
    //  the file size.
    //

    OffsetBeyondWrite = FileTableEntry->Position.LowPart + Length;

    if (OffsetBeyondWrite > FileTableEntry->u.FatFileContext.Dirent.FileSize) {

        IncreaseFileAllocation( FileId, OffsetBeyondWrite );

        FileTableEntry->u.FatFileContext.Dirent.FileSize = OffsetBeyondWrite;

        DiskWrite( DeviceId,
                   FileTableEntry->u.FatFileContext.DirentLbo,
                   sizeof(DIRENT),
                   &FileTableEntry->u.FatFileContext.Dirent );
    }

    //
    //  Clear the transfer count
    //

    *Transfer = 0;

    //
    //  Write out runs (i.e., bytes) until the byte count goes to zero
    //

    while (Length > 0) {

        LBO Lbo;

        ULONG CurrentRunByteCount;

        //
        //  Lookup the corresponding Lbo and run length for the current position
        //  (i.e., Vbo).
        //

        VboToLbo( FileId, FileTableEntry->Position.LowPart, &Lbo, &CurrentRunByteCount );

        //
        //  While there are bytes to be written out to the current run
        //  length and we haven't exhausted the request we loop reading
        //  in bytes.  The biggest request we'll handle is only 32KB
        //  contiguous bytes per physical read.  So we might need to loop
        //  through the run.
        //

        while ((Length > 0) && (CurrentRunByteCount > 0)) {

            LONG SingleWriteSize;

            //
            //  Compute the size of the next physical read
            //

            SingleWriteSize = Minimum(Length, 32 * 1024);
            SingleWriteSize = Minimum((ULONG)SingleWriteSize, CurrentRunByteCount);

            //
            //  Issue the Write
            //

            DiskWrite( DeviceId, Lbo, SingleWriteSize, Buffer);

            //
            //  Update the remaining length, Current run byte count
            //  and new Lbo offset
            //

            Length -= SingleWriteSize;
            CurrentRunByteCount -= SingleWriteSize;
            Lbo += SingleWriteSize;

            //
            //  Update the current position and the number of bytes transfered
            //

            FileTableEntry->Position.LowPart += SingleWriteSize;
            *Transfer += SingleWriteSize;

            //
            //  Update buffer to point to the next byte location to fill in
            //

            Buffer = (PCHAR)Buffer + SingleWriteSize;
        }
    }

    //
    //  Check if the fat is dirty and flush it out if it is.
    //

    if (FatStructureContext->CachedFatDirty) {

        FlushFatEntries( FatStructureContext, DeviceId );
    }

    //
    //  If we get here then remaining sector count is zero so we can
    //  return success to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
FatInitialize (
    VOID
    )

/*++

Routine Description:

    This routine initializes the fat boot filesystem.
    Currently this is a no-op.

Arguments:

    None.

Return Value:

    ESUCCESS.

--*/

{
    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
FatDiskRead (
    IN ULONG DeviceId,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PVOID Buffer,
    IN BOOLEAN CacheNewData
    )

/*++

Routine Description:

    This routine reads in zero or more bytes from the specified device.

Arguments:

    DeviceId - Supplies the device id to use in the arc calls.

    Lbo - Supplies the LBO to start reading from.

    ByteCount - Supplies the number of bytes to read.

    Buffer - Supplies a pointer to the buffer to read the bytes into.

Return Value:

    ESUCCESS is returned if the read operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    LARGE_INTEGER LargeLbo;
    ARC_STATUS Status;
    ULONG i;

    //
    //  Special case the zero byte read request
    //

    if (ByteCount == 0) {

        return ESUCCESS;
    }

    //
    // Issue the read through the cache.
    //

    LargeLbo.QuadPart = Lbo;
    Status = BlDiskCacheRead(DeviceId, 
                             &LargeLbo, 
                             Buffer, 
                             ByteCount, 
                             &i,
                             CacheNewData);

    if (Status != ESUCCESS) {

        return Status;
    }

    //
    //  Make sure we got back the amount requested
    //

    if (ByteCount != i) {

        return EIO;
    }

    //
    //  Everything is fine so return success to our caller
    //

    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
FatDiskWrite (
    IN ULONG DeviceId,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This routine writes in zero or more bytes to the specified device.

Arguments:

    DeviceId - Supplies the device id to use in the arc calls.

    Lbo - Supplies the LBO to start writing from.

    ByteCount - Supplies the number of bytes to write.

    Buffer - Supplies a pointer to the buffer of bytes to write out.

Return Value:

    ESUCCESS is returned if the write operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    LARGE_INTEGER LargeLbo;
    ARC_STATUS Status;
    ULONG i;

    //
    //  Special case the zero byte write request
    //

    if (ByteCount == 0) {

        return ESUCCESS;
    }

    //
    //  Issue the write through the cache.
    //

    LargeLbo.QuadPart = Lbo;

    Status = BlDiskCacheWrite (DeviceId,
                               &LargeLbo,
                               Buffer,
                               ByteCount,
                               &i);

    if (Status != ESUCCESS) {

        return Status;
    }

    //
    //  Make sure we wrote out the amount requested
    //

    if (ByteCount != i) {

        return EIO;
    }

    //
    //  Everything is fine so return success to our caller
    //

    return ESUCCESS;
}


//
//  Internal support routine
//

CLUSTER_TYPE
FatInterpretClusterType (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN FAT_ENTRY Entry
    )

/*++

Routine Description:

    This procedure tells the caller how to interpret a fat table entry.  It will
    indicate if the fat cluster is available, reserved, bad, the last one, or another
    fat index.

Arguments:

    FatStructureContext - Supplies the volume structure for the operation

    DeviceId - Supplies the DeviceId for the volume being used.

    Entry - Supplies the fat entry to examine.

Return Value:

    The type of the input fat entry is returned

--*/

{
    //
    //  Check for 12 or 16 bit fat.
    //

    if (FatIndexBitSize(&FatStructureContext->Bpb) == 12) {

        //
        //  For 12 bit fat check for one of the cluster types, but first
        //  make sure we only looking at 12 bits of the entry
        //

        Entry &= 0x00000fff;

        if       (Entry == 0x000)                      { return FatClusterAvailable; }
        else if ((Entry >= 0xff0) && (Entry <= 0xff6)) { return FatClusterReserved; }
        else if  (Entry == 0xff7)                      { return FatClusterBad; }
        else if ((Entry >= 0xff8) && (Entry <= 0xfff)) { return FatClusterLast; }
        else                                           { return FatClusterNext; }

   } else if (FatIndexBitSize(&FatStructureContext->Bpb) == 32) {

        Entry &= 0x0fffffff;

        if       (Entry == 0x0000)                       { return FatClusterAvailable; }
        else if  (Entry == 0x0ffffff7)                   { return FatClusterBad; }
        else if ((Entry >= 0x0ffffff8))                  { return FatClusterLast; }
        else                                             { return FatClusterNext; }

   } else {

        //
        //  For 16 bit fat check for one of the cluster types, but first
        //  make sure we are only looking at 16 bits of the entry
        //

        Entry &= 0x0000ffff;

        if       (Entry == 0x0000)                       { return FatClusterAvailable; }
        else if ((Entry >= 0xfff0) && (Entry <= 0xfff6)) { return FatClusterReserved; }
        else if  (Entry == 0xfff7)                       { return FatClusterBad; }
        else if ((Entry >= 0xfff8) && (Entry <= 0xffff)) { return FatClusterLast; }
        else                                             { return FatClusterNext; }
    }
}


//
//  Internal support routine
//

ARC_STATUS
FatLookupFatEntry (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN ULONG FatIndex,
    OUT PULONG FatEntry,
    IN BOOLEAN IsDoubleSpace
    )

/*++

Routine Description:

    This routine returns the value stored within the fat table and the specified
    fat index.  It is semantically equivalent to doing

        x = Fat[FatIndex]

Arguments:

    FatStrutureContext - Supplies the volume struture being used

    DeviceId - Supplies the device being used

    FatIndex - Supplies the index being looked up.

    FatEntry - Receives the value stored at the specified fat index

    IsDoubleSpace - Indicates if the search is being done on a double space volume

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    BOOLEAN TwelveBitFat;
    VBO Vbo;

    //****if (IsDoubleSpace) { DbgPrint("FatLookupFatEntry(%0x,%0x,%0x,%0x,%0x)\n",FatStructureContext, DeviceId, FatIndex, FatEntry, IsDoubleSpace); }

    //
    //  Calculate the Vbo of the word in the fat we need and
    //  also figure out if this is a 12 or 16 bit fat
    //

    if (FatIndexBitSize( &FatStructureContext->Bpb ) == 12) {

        TwelveBitFat = TRUE;
        Vbo = (FatIndex * 3) / 2;

    } else if (FatIndexBitSize( &FatStructureContext->Bpb ) == 32) {

        TwelveBitFat = FALSE;
        Vbo = FatIndex * 4;

    } else {

        TwelveBitFat = FALSE;
        Vbo = FatIndex * 2;
    }

    //
    //  Check if the Vbo we need is already in the cached fat
    //

    if ((FatStructureContext->CachedFat == NULL) ||
        (Vbo < FatStructureContext->CachedFatVbo) ||
        ((Vbo+1) > (FatStructureContext->CachedFatVbo + FAT_CACHE_SIZE))) {

        //
        //  Set the aligned cached fat buffer in the structure context
        //

        FatStructureContext->CachedFat = ALIGN_BUFFER( &FatStructureContext->CachedFatBuffer[0] );

        //
        //  As a safety net we'll flush any dirty fats that we might have cached before
        //  we turn the window
        //

        if (!IsDoubleSpace && FatStructureContext->CachedFatDirty) {

            FlushFatEntries( FatStructureContext, DeviceId );
        }

        //
        //  Now set the new cached Vbo to be the Vbo of the cache sized section that
        //  we're trying to map.  Each time we read in the cache we only read in
        //  cache sized and cached aligned pieces of the fat.  So first compute an
        //  aligned cached fat vbo and then do the read.
        //

        FatStructureContext->CachedFatVbo = (Vbo / FAT_CACHE_SIZE) * FAT_CACHE_SIZE;

        DiskRead( DeviceId,
                  FatStructureContext->CachedFatVbo + FatFirstFatAreaLbo(&FatStructureContext->Bpb),
                  FAT_CACHE_SIZE,
                  FatStructureContext->CachedFat,
                  CACHE_NEW_DATA,
                  IsDoubleSpace );
    }

    //
    //  At this point the cached fat contains the vbo we're after so simply
    //  extract the word
    //

    if (IsBpbFat32(&FatStructureContext->Bpb)) {
        CopyUchar4( FatEntry,
                    &FatStructureContext->CachedFat[Vbo - FatStructureContext->CachedFatVbo] );
    } else {
        CopyUchar2( FatEntry,
                    &FatStructureContext->CachedFat[Vbo - FatStructureContext->CachedFatVbo] );
    }

    //
    //  Now if this is a 12 bit fat then check if the index is odd or even
    //  If it is odd then we need to shift it over 4 bits, and in all
    //  cases we need to mask out the high 4 bits.
    //

    if (TwelveBitFat) {

        if ((FatIndex % 2) == 1) { *FatEntry >>= 4; }

        *FatEntry &= 0x0fff;
    }

    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
FatSetFatEntry(
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN FAT_ENTRY FatIndex,
    IN FAT_ENTRY FatEntry
    )

/*++

Routine Description:

    This procedure sets the data within the fat table at the specified index to
    to the specified value.  It is semantically equivalent to doing

        Fat[FatIndex] = FatEntry;

Arguments:

    FatStructureContext - Supplies the structure context for the operation

    DeviceId - Supplies the device for the operation

    FatIndex - Supplies the index within the fat table to set

    FatEntry - Supplies the value to store within the fat table

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    BOOLEAN TwelveBitFat;
    VBO Vbo;

    //
    //  Calculate the Vbo of the word in the fat we are modifying and
    //  also figure out if this is a 12 or 16 bit fat
    //

    if (FatIndexBitSize( &FatStructureContext->Bpb ) == 12) {

        TwelveBitFat = TRUE;
        Vbo = (FatIndex * 3) / 2;

    } else if (FatIndexBitSize( &FatStructureContext->Bpb ) == 32) {

        TwelveBitFat = FALSE;
        Vbo = FatIndex * 4;

    } else {

        TwelveBitFat = FALSE;
        Vbo = FatIndex * 2;
    }

    //
    //  Check if the Vbo we need is already in the cached fat
    //

    if ((FatStructureContext->CachedFat == NULL) ||
        (Vbo < FatStructureContext->CachedFatVbo) ||
        ((Vbo+1) > (FatStructureContext->CachedFatVbo + FAT_CACHE_SIZE))) {

        //
        //  Set the aligned cached fat buffer in the structure context
        //

        FatStructureContext->CachedFat = ALIGN_BUFFER( &FatStructureContext->CachedFatBuffer[0] );

        //
        //  As a safety net we'll flush any dirty fats that we might have cached before
        //  we turn the window
        //

        if (FatStructureContext->CachedFatDirty) {

            FlushFatEntries( FatStructureContext, DeviceId );
        }

        //
        //  Now set the new cached Vbo to be the Vbo of the cache sized section that
        //  we're trying to map.  Each time we read in the cache we only read in
        //  cache sized and cached aligned pieces of the fat.  So first compute an
        //  aligned cached fat vbo and then do the read.
        //

        FatStructureContext->CachedFatVbo = (Vbo / FAT_CACHE_SIZE) * FAT_CACHE_SIZE;

        DiskRead( DeviceId,
                  FatStructureContext->CachedFatVbo + FatFirstFatAreaLbo(&FatStructureContext->Bpb),
                  FAT_CACHE_SIZE,
                  FatStructureContext->CachedFat,
                  CACHE_NEW_DATA,
                  FALSE );
    }

    //
    //  At this point the cached fat contains the vbo we're after.  For a 16 bit
    //  fat we simply put in the fat entry.  For the 12 bit fat we first need to extract
    //  the word containing the entry, modify the word, and then put it back.
    //

    if (TwelveBitFat) {

        FAT_ENTRY Temp;

        CopyUchar2( &Temp,
                    &FatStructureContext->CachedFat[Vbo - FatStructureContext->CachedFatVbo] );

        if ((FatIndex % 2) == 0) {

            FatEntry = (FAT_ENTRY)((Temp & 0xf000) | (FatEntry & 0x0fff));

        } else {

            FatEntry = (FAT_ENTRY)((Temp & 0x000f) | ((FatEntry << 4) & 0xfff0));
        }
    }

    if (IsBpbFat32(&FatStructureContext->Bpb)) {
        CopyUchar4( &FatStructureContext->CachedFat[Vbo - FatStructureContext->CachedFatVbo],
                    &FatEntry );

    } else {

        CopyUchar2( &FatStructureContext->CachedFat[Vbo - FatStructureContext->CachedFatVbo],
                    &FatEntry );
    }

    //
    //  Now that we're done we can set the fat dirty
    //

    FatStructureContext->CachedFatDirty = TRUE;

    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
FatFlushFatEntries (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId
    )

/*++

Routine Description:

    This routine flushes out any dirty cached fat entries to the volume.

Arguments:

    FatStructureContext - Supplies the structure context for the operation

    DeviceId - Supplies the Device for the operation

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ULONG BytesPerFat;
    ULONG AmountToWrite;
    ULONG i;

    //
    //  Compute the actual number of bytes that we need to write.  We do this
    //  because we don't want to overwrite beyond the fat.
    //

    BytesPerFat = FatBytesPerFat(&FatStructureContext->Bpb);

    if (FatStructureContext->CachedFatVbo + FAT_CACHE_SIZE <= BytesPerFat) {

        AmountToWrite = FAT_CACHE_SIZE;

    } else {

        AmountToWrite = BytesPerFat - FatStructureContext->CachedFatVbo;
    }

    //
    //  For each fat table on the volume we will calculate the lbo for the operation
    //  and then write out the cached fat
    //

    for (i = 0; i < FatStructureContext->Bpb.Fats; i += 1) {

        LBO   Lbo;

        Lbo = FatStructureContext->CachedFatVbo +
              FatFirstFatAreaLbo(&FatStructureContext->Bpb) +
              (i * BytesPerFat);

        DiskWrite( DeviceId,
                   Lbo,
                   AmountToWrite,
                   FatStructureContext->CachedFat );
    }

    //
    //  we are all done so now mark the fat clean
    //

    FatStructureContext->CachedFatDirty = FALSE;

    return ESUCCESS;
}


//
//  Internal support routine
//

LBO
FatIndexToLbo (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN FAT_ENTRY FatIndex
    )

/*++

Routine Description:

    This procedure translates a fat index into its corresponding lbo.

Arguments:

    FatStructureContext - Supplies the volume structure for the operation

    Entry - Supplies the fat entry to examine.

Return Value:

    The LBO for the input fat index is returned

--*/

{
    //
    //  The formula for translating an index into an lbo is to take the index subtract
    //  2 (because index values 0 and 1 are reserved) multiply that by the bytes per
    //  cluster and add the results to the first file area lbo.
    //

    return ((FatIndex-2) * (LBO) FatBytesPerCluster(&FatStructureContext->Bpb))
           + FatFileAreaLbo(&FatStructureContext->Bpb);
}


//
//  Internal support routine
//

ARC_STATUS
FatSearchForDirent (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN FAT_ENTRY DirectoriesStartingIndex,
    IN PFAT8DOT3 FileName,
    OUT PDIRENT Dirent,
    OUT PLBO Lbo,
    IN BOOLEAN IsDoubleSpace
    )

/*++

Routine Description:

    The procedure searches the indicated directory for a dirent that matches
    the input file name.

Arguments:

    FatStructureContext - Supplies the structure context for the operation

    DeviceId - Supplies the Device id for the operation

    DirectoriesStartingIndex - Supplies the fat index of the directory we are
        to search.  A value of zero indicates that we are searching the root directory
        of a non-FAT32 volume.  FAT32 volumes will have a non-zero index.

    FileName - Supplies the file name to look for.  The name must have already been
        biased by the 0xe5 transmogrification

    Dirent - The caller supplies the memory for a dirent and this procedure will
        fill in the dirent if one is located

    Lbo - Receives the Lbo of the dirent if one is located

    IsDoubleSpace - Indicates if the search is being done on a double space volume

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PDIRENT DirentBuffer;
    UCHAR Buffer[ 16 * sizeof(DIRENT) + 256 ];

    ULONG i;
    ULONG j;

    ULONG BytesPerCluster;
    FAT_ENTRY FatEntry;
    CLUSTER_TYPE ClusterType;

    DirentBuffer = (PDIRENT)ALIGN_BUFFER( &Buffer[0] );

    FatDebugOutput83("FatSearchForDirent: %s\r\n", FileName, 0, 0);

    //****if (IsDoubleSpace) { (*FileName)[11] = 0; DbgPrint("FatSearchForDirent(%0x,%0x,%0x,\"%11s\",%0x,%0x,%0x)\n", FatStructureContext, DeviceId, DirectoriesStartingIndex, FileName, Dirent, Lbo, IsDoubleSpace); }

    //
    //  Check if this is the root directory that is being searched
    //

    if (DirectoriesStartingIndex == FAT_CLUSTER_AVAILABLE) {

        VBO Vbo;

        ULONG RootLbo = FatRootDirectoryLbo(&FatStructureContext->Bpb);
        ULONG RootSize = FatRootDirectorySize(&FatStructureContext->Bpb);

        //
        //  For the root directory we'll zoom down the dirents until we find
        //  a match, or run out of dirents or hit the never used dirent.
        //  The outer loop reads in 512 bytes of the directory at a time into
        //  dirent buffer.
        //

        for (Vbo = 0; Vbo < RootSize; Vbo += 16 * sizeof(DIRENT)) {

            *Lbo = Vbo + RootLbo;

            DiskRead( DeviceId, *Lbo, 16 * sizeof(DIRENT), DirentBuffer, CACHE_NEW_DATA, IsDoubleSpace );

            //
            //  The inner loop cycles through the 16 dirents that we've just read in
            //

            for (i = 0; i < 16; i += 1) {

                //
                //  Check if we've found a non label match for file name, and if so
                //  then copy the buffer into the dirent and set the real lbo
                //  of the dirent and return
                //

                if (!FlagOn(DirentBuffer[i].Attributes, FAT_DIRENT_ATTR_VOLUME_ID ) &&
                    AreNamesEqual(&DirentBuffer[i].FileName, FileName)) {

                    for (j = 0; j < sizeof(DIRENT); j += 1) {

                        ((PCHAR)Dirent)[j] = ((PCHAR)DirentBuffer)[(i * sizeof(DIRENT)) + j];
                    }

                    *Lbo = Vbo + RootLbo + (i * sizeof(DIRENT));

                    return ESUCCESS;
                }

                if (DirentBuffer[i].FileName[0] == FAT_DIRENT_NEVER_USED) {

                    return ENOENT;
                }
            }
        }

        return ENOENT;
    }

    //
    //  If we get here we need to search a non-root directory.  The alrogithm
    //  for doing the search is that for each cluster we read in each dirent
    //  until we find a match, or run out of clusters, or hit the never used
    //  dirent.  First set some local variables and then get the cluster type
    //  of the first cluster
    //

    BytesPerCluster = FatBytesPerCluster( &FatStructureContext->Bpb );
    FatEntry = DirectoriesStartingIndex;
    ClusterType = FatInterpretClusterType( FatStructureContext, FatEntry );

    //
    //  Now loop through each cluster, and compute the starting Lbo for each cluster
    //  that we encounter
    //

    while (ClusterType == FatClusterNext) {

        LBO ClusterLbo;
        ULONG Offset;

        ClusterLbo = FatIndexToLbo( FatStructureContext, FatEntry );

        //
        //  Now for each dirent in the cluster compute the lbo, read in the dirent
        //  and check for a match, the outer loop reads in 512 bytes of dirents at
        //  a time.
        //

        for (Offset = 0; Offset < BytesPerCluster; Offset += 16 * sizeof(DIRENT)) {

            *Lbo = Offset + ClusterLbo;

            DiskRead( DeviceId, *Lbo, 16 * sizeof(DIRENT), DirentBuffer, CACHE_NEW_DATA, IsDoubleSpace );

            //
            //  The inner loop cycles through the 16 dirents that we've just read in
            //

            for (i = 0; i < 16; i += 1) {

                //
                //  Check if we've found a for file name, and if so
                //  then copy the buffer into the dirent and set the real lbo
                //  of the dirent and return
                //

                if (!FlagOn(DirentBuffer[i].Attributes, FAT_DIRENT_ATTR_VOLUME_ID ) &&
                    AreNamesEqual(&DirentBuffer[i].FileName, FileName)) {

                    for (j = 0; j < sizeof(DIRENT); j += 1) {

                        ((PCHAR)Dirent)[j] = ((PCHAR)DirentBuffer)[(i * sizeof(DIRENT)) + j];
                    }

                    *Lbo = Offset + ClusterLbo + (i * sizeof(DIRENT));

                    return ESUCCESS;
                }

                if (DirentBuffer[i].FileName[0] == FAT_DIRENT_NEVER_USED) {

                    return ENOENT;
                }
            }
        }

        //
        //  Now that we've exhausted the current cluster we need to read
        //  in the next cluster.  So locate the next fat entry in the chain
        //  and go back to the top of the while loop.
        //

        LookupFatEntry( FatStructureContext, DeviceId, FatEntry, &FatEntry, IsDoubleSpace );

        ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);
    }

    return ENOENT;
}


//
//  Internal support routine
//

ARC_STATUS
FatCreateDirent (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN FAT_ENTRY DirectoriesStartingIndex,
    IN PDIRENT Dirent,
    OUT PLBO Lbo
    )

/*++

Routine Description:

    This procedure allocates and write out a new dirent for a data file in the
    specified directory.  It assumes that the file name does not already exist.

Arguments:

    FatStructureContext - Supplies the structure context for the operation

    DeviceId - Supplies the device id for the operation

    DirectoriesStartingIndex - Supplies the fat index of the directory we are
        to use.  A value of zero indicates that we are using the root directory

    Dirent - Supplies a copy of the dirent to put out on the disk

    Lbo - Recieves the Lbo of where the dirent is placed

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    DIRENT TemporaryDirent;

    ULONG BytesPerCluster;
    FAT_ENTRY FatEntry;
    FAT_ENTRY PreviousEntry;

    //
    //  Check if this is the root directory that is being used
    //

    if (DirectoriesStartingIndex == FAT_CLUSTER_AVAILABLE) {

        VBO Vbo;

        ULONG RootLbo = FatRootDirectoryLbo(&FatStructureContext->Bpb);
        ULONG RootSize = FatRootDirectorySize(&FatStructureContext->Bpb);

        //
        //  For the root directory we'll zoom down the dirents until we find
        //  a the never used (or deleted) dirent, if we never find one then the
        //  directory is full.
        //

        for (Vbo = 0; Vbo < RootSize; Vbo += sizeof(DIRENT)) {

            *Lbo = Vbo + RootLbo;

            DiskRead( DeviceId, *Lbo, sizeof(DIRENT), &TemporaryDirent, CACHE_NEW_DATA, FALSE );

            if ((TemporaryDirent.FileName[0] == FAT_DIRENT_DELETED) ||
                (TemporaryDirent.FileName[0] == FAT_DIRENT_NEVER_USED)) {

                //
                //  This dirent is free so write out the dirent, and we're done.
                //

                DiskWrite( DeviceId, *Lbo, sizeof(DIRENT), Dirent );

                return ESUCCESS;
            }
        }

        return ENOSPC;
    }

    //
    //  If we get here we need to use a non-root directory.  The alrogithm
    //  for doing the work is that for each cluster we read in each dirent
    //  until we hit a never used dirent or run out of clusters.  First set
    //  some local variables and then get the cluster type of the first
    //  cluster
    //

    BytesPerCluster = FatBytesPerCluster( &FatStructureContext->Bpb );
    FatEntry = DirectoriesStartingIndex;

    //
    //  Now loop through each cluster, and compute the starting Lbo for each cluster
    //  that we encounter
    //

    while (TRUE) {

        LBO ClusterLbo;
        ULONG Offset;

        ClusterLbo = FatIndexToLbo( FatStructureContext, FatEntry );

        //
        //  Now for each dirent in the cluster compute the lbo, read in the dirent
        //  and check if it is available.
        //

        for (Offset = 0; Offset < BytesPerCluster; Offset += sizeof(DIRENT)) {

            *Lbo = Offset + ClusterLbo;

            DiskRead( DeviceId, *Lbo, sizeof(DIRENT), &TemporaryDirent, CACHE_NEW_DATA, FALSE );

            if ((TemporaryDirent.FileName[0] == FAT_DIRENT_DELETED) ||
                (TemporaryDirent.FileName[0] == FAT_DIRENT_NEVER_USED)) {

                //
                //  This dirent is free so write out the dirent, and we're done.
                //

                DiskWrite( DeviceId, *Lbo, sizeof(DIRENT), Dirent );

                return ESUCCESS;
            }
        }

        //
        //  Now that we've exhausted the current cluster we need to read
        //  in the next cluster.  So locate the next fat entry in the chain.
        //  Set previous entry to be the saved entry just in case we run off
        //  the chain and need to allocate another cluster.
        //

        PreviousEntry = FatEntry;

        LookupFatEntry( FatStructureContext, DeviceId, FatEntry, &FatEntry, FALSE );

        //
        //  If there isn't another cluster in the chain then we need to allocate a
        //  new cluster, and set previous entry to point to it.
        //

        if (FatInterpretClusterType(FatStructureContext, FatEntry) != FatClusterNext) {

            AllocateClusters( FatStructureContext, DeviceId, 1, PreviousEntry, &FatEntry );

            SetFatEntry( FatStructureContext, DeviceId, PreviousEntry, FatEntry );
        }
    }

    return ENOSPC;
}


//
//  Internal support routine
//

VOID
FatSetDirent (
    IN PFAT8DOT3 FileName,
    IN OUT PDIRENT Dirent,
    IN UCHAR Attributes
    )

/*++

Routine Description:

    This routine sets up the dirent

Arguments:

    FileName - Supplies the name to store in the dirent

    Dirent - Receives the current date and time

    Attributes - Supplies the attributes to initialize the dirent with

Return Value:

    None.

--*/

{
    PTIME_FIELDS Time;
    ULONG i;

    for (i = 0; i < sizeof(FAT8DOT3); i+= 1) {

        Dirent->FileName[i] = (*FileName)[i];
    }

    Dirent->Attributes = (UCHAR)(Attributes | FAT_DIRENT_ATTR_ARCHIVE);

    Time = ArcGetTime();

    Dirent->LastWriteTime.Time.DoubleSeconds = (USHORT)(Time->Second/2);
    Dirent->LastWriteTime.Time.Minute = Time->Minute;
    Dirent->LastWriteTime.Time.Hour = Time->Hour;

    Dirent->LastWriteTime.Date.Day = Time->Day;
    Dirent->LastWriteTime.Date.Month = Time->Month;
    Dirent->LastWriteTime.Date.Year = (USHORT)(Time->Year - 1980);

    return;
}


//
//  Internal support routine
//

ARC_STATUS
FatLoadMcb (
    IN ULONG FileId,
    IN VBO StartingVbo,
    IN BOOLEAN IsDoubleSpace
    )
/*++

Routine Description:

    This routine loads into the cached mcb table the the retrival information for
    the starting vbo.

Arguments:

    FileId - Supplies the FileId for the operation

    StartingVbo - Supplies the starting vbo to use when loading the mcb

    IsDoubleSpace - Indicates if the operation is being done on a double space volume

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    PFAT_MCB Mcb;
    ULONG DeviceId;
    ULONG BytesPerCluster;

    FAT_ENTRY FatEntry;
    CLUSTER_TYPE ClusterType;
    VBO Vbo;

    //****if (IsDoubleSpace) { DbgPrint("FatLoadMcb(%0x,%0x,%0x)\n", FileId, StartingVbo, IsDoubleSpace); }

    //
    //  Preload some of the local variables
    //

    FileTableEntry = &BlFileTable[FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    Mcb = &FatStructureContext->Mcb;
    DeviceId = FileTableEntry->DeviceId;
    BytesPerCluster = FatBytesPerCluster(&FatStructureContext->Bpb);

    if (IsDoubleSpace) { DeviceId = FileId; }

    //
    //  Set the file id in the structure context, and also set the mcb to be initially
    //  empty
    //

    FatStructureContext->FileId = FileId;
    Mcb->InUse = 0;
    Mcb->Vbo[0] = 0;

    if (!IsBpbFat32(&FatStructureContext->Bpb)) {

        //
        //  Check if this is the root directory.  If it is then we build the single
        //  run mcb entry for the root directory.
        //

        if (FileTableEntry->u.FatFileContext.DirentLbo == 0) {

            Mcb->InUse = 1;
            Mcb->Lbo[0] = FatRootDirectoryLbo(&FatStructureContext->Bpb);
            Mcb->Vbo[1] = FatRootDirectorySize(&FatStructureContext->Bpb);

            return ESUCCESS;
        }

        //
        //  For all other files/directories we need to do some work. First get the fat
        //  entry and cluster type of the fat entry stored in the dirent
        //

        FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;

    } else {

        //
        //  Check if this is the root directory.  If it is then we use
        //  the BPB values to start the run.
        //

        if (FileTableEntry->u.FatFileContext.DirentLbo == 0) {

            FatEntry = FatStructureContext->Bpb.RootDirFirstCluster;

        } else {

            //
            //  For all other files/directories we use the dirent values
            //

            if (IsBpbFat32(&FatStructureContext->Bpb)) {

                FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile |
                    (FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi << 16);
            } else {

                FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;
            }
        }

    }

    ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);

    //
    //  Scan through the fat until we reach the vbo we're after and then build the
    //  mcb for the file
    //

    for (Vbo = BytesPerCluster; Vbo < StartingVbo; Vbo += BytesPerCluster) {

        //
        //  Check if the file does not have any allocation beyond this point in which
        //  case the mcb we return is empty
        //

        if (ClusterType != FatClusterNext) {

            return ESUCCESS;
        }

        LookupFatEntry( FatStructureContext, DeviceId, FatEntry, &FatEntry, IsDoubleSpace );

        ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);
    }

    //
    //  We need to check again if the file does not have any allocation beyond this
    //  point in which case the mcb we return is empty
    //

    if (ClusterType != FatClusterNext) {

        return ESUCCESS;
    }

    //
    //  At this point FatEntry denotes another cluster, and it happens to be the
    //  cluster we want to start loading into the mcb.  So set up the first run in
    //  the mcb to be this cluster, with a size of a single cluster.
    //

    Mcb->InUse = 1;
    Mcb->Vbo[0] = Vbo - BytesPerCluster;
    Mcb->Lbo[0] = FatIndexToLbo( FatStructureContext, FatEntry );
    Mcb->Vbo[1] = Vbo;

    //
    //  Now we'll scan through the fat chain until we either exhaust the fat chain
    //  or we fill up the mcb
    //

    while (TRUE) {

        LBO Lbo;

        //
        //  Get the next fat entry and interpret its cluster type
        //

        LookupFatEntry( FatStructureContext, DeviceId, FatEntry, &FatEntry, IsDoubleSpace );

        ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);

        if (ClusterType != FatClusterNext) {

            return ESUCCESS;
        }

        //
        //  Now calculate the lbo for this cluster and determine if it
        //  is a continuation of the previous run or a start of a new run
        //

        Lbo = FatIndexToLbo(FatStructureContext, FatEntry);

        //
        //  It is a continuation if the lbo of the last run plus the current
        //  size of the run is equal to the lbo for the next cluster.  If it
        //  is a contination then we only need to add a cluster amount to the
        //  last vbo to increase the run size.  If it is a new run then
        //  we need to check if the run will fit, and if so then add in the
        //  new run.
        //

        if ((Mcb->Lbo[Mcb->InUse-1] + (Mcb->Vbo[Mcb->InUse] - Mcb->Vbo[Mcb->InUse-1])) == Lbo) {

            Mcb->Vbo[Mcb->InUse] += BytesPerCluster;

        } else {

            if ((Mcb->InUse + 1) >= FAT_MAXIMUM_MCB) {

                return ESUCCESS;
            }

            Mcb->InUse += 1;
            Mcb->Lbo[Mcb->InUse-1] = Lbo;
            Mcb->Vbo[Mcb->InUse] = Mcb->Vbo[Mcb->InUse-1] + BytesPerCluster;
        }
    }

    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
FatVboToLbo (
    IN ULONG FileId,
    IN VBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG ByteCount,
    IN BOOLEAN IsDoubleSpace
    )

/*++

Routine Description:

    This routine computes the run denoted by the input vbo to into its
    corresponding lbo and also returns the number of bytes remaining in
    the run.

Arguments:

    Vbo - Supplies the Vbo to match

    Lbo - Recieves the corresponding Lbo

    ByteCount - Receives the number of bytes remaining in the run

    IsDoubleSpace - Indicates if the operation is being done on a double space volume

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    PFAT_MCB Mcb;
    ULONG i;

    //****if (IsDoubleSpace) { DbgPrint("FatVboToLbo(%0x,%0x,%0x,%0x,%0x)\n", FileId, Vbo, Lbo, ByteCount, IsDoubleSpace); }

    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)BlFileTable[FileId].StructureContext;
    Mcb = &FatStructureContext->Mcb;

    //
    //  Check if the mcb is for the correct file id and has the range we're asking for.
    //  If it doesn't then call load mcb to load in the right range.
    //

    if ((FileId != FatStructureContext->FileId) ||
        (Vbo < Mcb->Vbo[0]) || (Vbo >= Mcb->Vbo[Mcb->InUse])) {

        LoadMcb(FileId, Vbo, IsDoubleSpace);
    }

    //
    //  Now search for the slot where the Vbo fits in the mcb.  Note that
    //  we could also do a binary search here but because the run count
    //  is probably small the extra overhead of a binary search doesn't
    //  buy us anything
    //

    for (i = 0; i < Mcb->InUse; i += 1) {

        //
        //  We found our slot if the vbo we're after is less then the
        //  next mcb's vbo
        //

        if (Vbo < Mcb->Vbo[i+1]) {

            //
            //  Compute the corresponding lbo which is the stored lbo plus
            //  the difference between the stored vbo and the vbo we're
            //  looking up.  Also compute the byte count which is the
            //  difference between the current vbo we're looking up and
            //  the vbo for the next run.
            //

            *Lbo = Mcb->Lbo[i] + (Vbo - Mcb->Vbo[i]);

            *ByteCount = Mcb->Vbo[i+1] - Vbo;

            //
            //  and return success to our caller
            //

            return ESUCCESS;
        }
    }

    //
    //  If we really reach here we have an error, most likely because the file is
    //  not large enough for the requested Vbo.
    //

    return EINVAL;
}


//
//  Internal support routine
//

ARC_STATUS
FatIncreaseFileAllocation (
    IN ULONG FileId,
    IN ULONG ByteSize
    )

/*++

Routine Description:

    This procedure increases the file allocation to be at minimum the indicated
    size.

Arguments:

    FileId - Supplies the file id being processed

    ByteSize - Supplies the minimum byte size for file allocation

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    ULONG DeviceId;
    ULONG BytesPerCluster;

    ULONG NumberOfClustersNeeded;
    FAT_ENTRY FatEntry;
    CLUSTER_TYPE ClusterType;
    FAT_ENTRY PreviousEntry;
    ULONG i;

    //
    //  Preload some of the local variables
    //

    FileTableEntry = &BlFileTable[FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    DeviceId = FileTableEntry->DeviceId;
    BytesPerCluster = FatBytesPerCluster(&FatStructureContext->Bpb);

    //
    //  Check if this is the root directory.  If it is then check if the allocation
    //  increase is already accommodated in the volume
    //

    if (FileTableEntry->u.FatFileContext.DirentLbo == 0) {

        if (FatRootDirectorySize(&FatStructureContext->Bpb) >= ByteSize) {

            return ESUCCESS;

        } else {

            return ENOSPC;
        }
    }

    //
    //  Compute the actual number of clusters needed to satisfy the request
    //  Also get the first fat entry and its cluster type from the dirent.
    //

    NumberOfClustersNeeded = (ByteSize + BytesPerCluster - 1) / BytesPerCluster;

    if (IsBpbFat32(&FatStructureContext->Bpb)) {

        FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile |
            (FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi << 16);

    } else {

        FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;
    }

    ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);

    //
    //  Previous Entry is as a hint to allocate new space and to show us where
    //  the end of the current fat chain is located
    //

    PreviousEntry = 2;

    //
    //  We loop for the number of clusters we need trying to go down the fat chain.
    //  When we exit i is either number of clusters in the file (if less then
    //  the number of clusters we need) or it is set equal to the number of clusters
    //  we need
    //

    for (i = 0; i < NumberOfClustersNeeded; i += 1) {

        if (ClusterType != FatClusterNext) { break; }

        PreviousEntry = FatEntry;

        LookupFatEntry( FatStructureContext, DeviceId, PreviousEntry, &FatEntry, FALSE );

        ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);
    }

    if (i >= NumberOfClustersNeeded) {

        return ESUCCESS;
    }

    //
    //  At this point previous entry points to the last entry and i contains the
    //  number of clusters in the file.  We now need to build up the allocation
    //

    AllocateClusters( FatStructureContext,
                      DeviceId,
                      NumberOfClustersNeeded - i,
                      PreviousEntry,
                      &FatEntry );

    //
    //  We have our additional allocation, so now figure out if we need to chain off of
    //  the dirent or it we already have a few clusters in the chain and we
    //  need to munge the fat.
    //

    if (FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile == FAT_CLUSTER_AVAILABLE) {

        FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile = (USHORT)FatEntry;
        FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi =
            (USHORT)(FatEntry >> 16);

        DiskWrite( DeviceId,
                   FileTableEntry->u.FatFileContext.DirentLbo,
                   sizeof(DIRENT),
                   &FileTableEntry->u.FatFileContext.Dirent );

    } else {

        SetFatEntry( FatStructureContext, DeviceId, PreviousEntry, FatEntry );
    }

    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
FatTruncateFileAllocation (
    IN ULONG FileId,
    IN ULONG ByteSize
    )

/*++

Routine Description:

    This procedure decreases the file allocation to be at maximum the indicated
    size.

Arguments:

    FileId - Supplies the file id being processed

    ByteSize - Supplies the maximum byte size for file allocation

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    ULONG DeviceId;
    ULONG BytesPerCluster;

    ULONG NumberOfClustersNeeded;
    FAT_ENTRY FatEntry;
    CLUSTER_TYPE ClusterType;
    FAT_ENTRY CurrentIndex;
    ULONG i;

    //
    //  Preload some of the local variables
    //

    FileTableEntry = &BlFileTable[FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    DeviceId = FileTableEntry->DeviceId;
    BytesPerCluster = FatBytesPerCluster(&FatStructureContext->Bpb);

    //
    //  Check if this is the root directory.  If it is then noop this request
    //

    if (FileTableEntry->u.FatFileContext.DirentLbo == 0) {

        return ESUCCESS;
    }

    //
    //  Compute the actual number of clusters needed to satisfy the request
    //  Also get the first fat entry and its cluster type from the dirent
    //

    NumberOfClustersNeeded = (ByteSize + BytesPerCluster - 1) / BytesPerCluster;

    if (IsBpbFat32(&FatStructureContext->Bpb)) {

        FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile |
            (FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi << 16);

    } else {

        FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;
    }

    ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);

    //
    //  The current index variable is used to indicate where we extracted the current
    //  fat entry value from.  It has a value of 0 we got the fat entry from the
    //  dirent.
    //

    CurrentIndex = FAT_CLUSTER_AVAILABLE;

    //
    //  Now loop through the fat chain for the number of clusters needed.
    //  If we run out of the chain before we run out of clusters needed then the
    //  current allocation is already smaller than necessary.
    //

    for (i = 0; i < NumberOfClustersNeeded; i += 1) {

        //
        //  If we run out of the chain before we run out of clusters needed then the
        //  current allocation is already smaller than necessary.
        //

        if (ClusterType != FatClusterNext) { return ESUCCESS; }

        //
        //  Update the current index, and read in a new fat entry and interpret its
        //  type
        //

        CurrentIndex = FatEntry;

        LookupFatEntry( FatStructureContext, DeviceId, CurrentIndex, &FatEntry, FALSE );

        ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);
    }

    //
    //  If we get here then we've found that the current allocation is equal to or
    //  larger than what we want.  It is equal if the current cluster type does not
    //  point to another cluster.  The first thing we have to do is terminate the
    //  fat chain correctly.  If the current index is zero then we zero out the
    //  dirent, otherwise we need to set the value to be last cluster.
    //

    if (CurrentIndex == FAT_CLUSTER_AVAILABLE) {

        FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;

        if (IsBpbFat32(&FatStructureContext->Bpb)) {

            FatEntry |= FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi << 16;
        }

        if (FatEntry != FAT_CLUSTER_AVAILABLE) {

            //
            //  By setting the dirent we set in a new date.
            //

            FatSetDirent( &FileTableEntry->u.FatFileContext.Dirent.FileName,
                          &FileTableEntry->u.FatFileContext.Dirent,
                          0 );

            FatEntry = FAT_CLUSTER_AVAILABLE;

            FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile = (USHORT)FatEntry;

            if (IsBpbFat32(&FatStructureContext->Bpb)) {

                FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi =
                    (USHORT)(FatEntry >> 16);
            }

            FileTableEntry->u.FatFileContext.Dirent.FileSize = 0;

            DiskWrite( DeviceId,
                       FileTableEntry->u.FatFileContext.DirentLbo,
                       sizeof(DIRENT),
                       &FileTableEntry->u.FatFileContext.Dirent );
        }

    } else {

        if (ClusterType != FatClusterLast) {

            SetFatEntry( FatStructureContext, DeviceId, CurrentIndex, FAT_CLUSTER_LAST );
        }
    }

    //
    //  Now while there are clusters left to deallocate then we need to go down the
    //  chain freeing up the clusters
    //

    while (ClusterType == FatClusterNext) {

        //
        //  Read in the value at the next fat entry and interpret its cluster type
        //

        CurrentIndex = FatEntry;

        LookupFatEntry( FatStructureContext, DeviceId, CurrentIndex, &FatEntry, FALSE );

        ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);

        //
        //  Now deallocate the cluster at the current index
        //

        SetFatEntry( FatStructureContext, DeviceId, CurrentIndex, FAT_CLUSTER_AVAILABLE );
    }

    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
FatAllocateClusters (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN ULONG ClusterCount,
    IN ULONG Hint,
    OUT PULONG AllocatedEntry
    )

/*++

Routine Description:

    This procedure allocates a new cluster, set its entry to be the last one,
    and zeros out the cluster.

Arguments:

    FatStructureContext - Supplies the structure context for the operation

    DeviceId - Supplies the device id for the operation

    ClusterCount - Supplies the number of clusters we need to allocate

    Hint - Supplies a hint to start from when looking for a free cluster

    AllocatedEntry - Receives the first fat index for the new allocated cluster chain

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ULONG TotalClustersInVolume;
    ULONG BytesPerCluster;
    UCHAR BlankBuffer[512];

    FAT_ENTRY PreviousEntry;
    ULONG CurrentClusterCount;
    ULONG j;
    LBO ClusterLbo;
    ULONG i;

    //
    //  Load some local variables
    //

    TotalClustersInVolume = FatNumberOfClusters(&FatStructureContext->Bpb);
    BytesPerCluster = FatBytesPerCluster(&FatStructureContext->Bpb);
    RtlZeroMemory((PVOID)&BlankBuffer[0], 512);

    PreviousEntry = 0;
    CurrentClusterCount = 0;

    //
    //  For each cluster on the disk we'll do the following loop
    //

    for (j = 0; j < TotalClustersInVolume; j += 1) {

        FAT_ENTRY EntryToExamine;
        FAT_ENTRY FatEntry;

        //
        //  Check if the current allocation is enough.
        //

        if (CurrentClusterCount >= ClusterCount) {

            return ESUCCESS;
        }

        //
        //  Compute an entry to examine based on the loop iteration and our hint
        //

        EntryToExamine = (FAT_ENTRY)(((j + Hint - 2) % TotalClustersInVolume) + 2);

        //
        //  Read in the prospective fat entry and check if it is available.  If it
        //  is not available then continue looping.
        //

        LookupFatEntry( FatStructureContext, DeviceId, EntryToExamine, &FatEntry, FALSE );

        if (FatInterpretClusterType(FatStructureContext, FatEntry) != FatClusterAvailable) {

            continue;
        }

        //
        //  We have a free cluster, so put it at the end of the chain.
        //

        if (PreviousEntry == 0) {

            *AllocatedEntry = EntryToExamine;

        } else {

            SetFatEntry( FatStructureContext, DeviceId, PreviousEntry, EntryToExamine );
        }

        SetFatEntry( FatStructureContext, DeviceId, EntryToExamine, FAT_CLUSTER_LAST );

        //
        //  Now we need to go through and zero out the data in the cluster that we've
        //  just allocated.  Because all clusters must be a multiple of dirents we'll
        //  do it a dirent at a time.
        //

        ClusterLbo = FatIndexToLbo( FatStructureContext, EntryToExamine );

        for (i = 0; i < BytesPerCluster; i += 512) {

            DiskWrite( DeviceId, ClusterLbo + i, 512, BlankBuffer );
        }

        //
        //  Before we go back to the top of the loop we need to update the
        //  previous entry so that it points to the end of the current chain and
        //  also i because we've just added another cluster.
        //

        PreviousEntry = EntryToExamine;
        CurrentClusterCount += 1;
    }

    return ENOSPC;
}


//
//  Internal support routine
//

VOID
FatFirstComponent (
    IN OUT PSTRING String,
    OUT PFAT8DOT3 FirstComponent
    )

/*++

Routine Description:

    Convert a string into fat 8.3 format and advance the input string
    descriptor to point to the next file name component.

Arguments:

    InputString - Supplies a pointer to the input string descriptor.

    Output8dot3 - Supplies a pointer to the converted string.

Return Value:

    None.

--*/

{
    ULONG Extension;
    ULONG Index;

    //
    //  Fill the output name with blanks.
    //

    for (Index = 0; Index < 11; Index += 1) { (*FirstComponent)[Index] = ' '; }

    //
    //  Copy the first part of the file name up to eight characters and
    //  skip to the end of the name or the input string as appropriate.
    //

    for (Index = 0; Index < String->Length; Index += 1) {

        if ((String->Buffer[Index] == '\\') || (String->Buffer[Index] == '.')) {

            break;
        }

        if (Index < 8) {

            (*FirstComponent)[Index] = (CHAR)ToUpper(String->Buffer[Index]);
        }
    }

    //
    //  Check if the end of the string was reached, an extension was specified,
    //  or a subdirectory was specified..
    //

    if (Index < String->Length) {

        if (String->Buffer[Index] == '.') {

            //
            //  Skip over the extension separator and add the extension to
            //  the file name.
            //

            Index += 1;
            Extension = 8;

            while (Index < String->Length) {

                if (String->Buffer[Index] == '\\') {

                    break;
                }

                if (Extension < 11) {

                    (*FirstComponent)[Extension] = (CHAR)ToUpper(String->Buffer[Index]);
                    Extension += 1;
                }

                Index += 1;
            }
        }
    }

    //
    //  Now we'll bias the first component by the 0xe5 factor so that all our tests
    //  to names on the disk will be ready for a straight 11 byte comparison
    //

    if ((*FirstComponent)[0] == 0xe5) {

        (*FirstComponent)[0] = FAT_DIRENT_REALLY_0E5;
    }

    //
    //  Update string descriptor.
    //

    String->Buffer += Index;
    String->Length -= (USHORT)Index;

    return;
}


//
//  Internal support routine
//

VOID
FatDirToArcDir (
    IN PDIRENT FatDirent,
    OUT PDIRECTORY_ENTRY ArcDirent
    )

/*++

Routine Description:

    This routine converts a FAT directory entry into an ARC
    directory entry.

Arguments:

    FatDirent - supplies a pointer to a FAT directory entry.

    ArcDirent - supplies a pointer to an ARC directory entry.

Return Value:

    None.

--*/

{
    ULONG i, e;

    //
    //  clear info area
    //

    RtlZeroMemory( ArcDirent, sizeof(DIRECTORY_ENTRY) );

    //
    //  check the directory flag
    //

    if (FlagOn( FatDirent->Attributes, FAT_DIRENT_ATTR_DIRECTORY )) {

        SetFlag( ArcDirent->FileAttribute, ArcDirectoryFile );
    }

    //
    //  check the read-only flag
    //

    if (FlagOn( FatDirent->Attributes, FAT_DIRENT_ATTR_READ_ONLY )) {

        SetFlag( ArcDirent->FileAttribute, ArcReadOnlyFile );
    }

    //
    //  clear name string
    //

    RtlZeroMemory( ArcDirent->FileName, 32 );

    //
    //  copy first portion of file name
    //

    for (i = 0;  (i < 8) && (FatDirent->FileName[i] != ' ');  i += 1) {

        ArcDirent->FileName[i] = FatDirent->FileName[i];
    }

    //
    //  check for an extension
    //

    if ( FatDirent->FileName[8] != ' ' ) {

        //
        //  store the dot char
        //

        ArcDirent->FileName[i++] = '.';

        //
        //  add the extension
        //

        for (e = 8;  (e < 11) && (FatDirent->FileName[e] != ' ');  e += 1) {

            ArcDirent->FileName[i++] = FatDirent->FileName[e];
        }
    }

    //
    //  set file name length before returning
    //

    ArcDirent->FileNameLength = i;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\etfsboot.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    EtfsBoot.c

Abstract:

    This module implements the El Torito CD boot file system used by the operating
    system loader.

Author:

    Steve Collins    [stevec]   25-Nov-1995

Revision History:

--*/

#if defined(ELTORITO)
#include "bootlib.h"
#include "cd.h"
#include "blcache.h"

BOOTFS_INFO EtfsBootFsInfo = {L"etfs"};


//
//  Local procedure prototypes.
//

ARC_STATUS
EtfsReadDisk(
    IN ULONG DeviceId,
    IN ULONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    );

VOID
EtfsFirstComponent(
    IN OUT PSTRING String,
    OUT PSTRING FirstComponent
    );

typedef enum _COMPARISON_RESULTS {
    LessThan = -1,
    EqualTo = 0,
    GreaterThan = 1
} COMPARISON_RESULTS;

COMPARISON_RESULTS
EtfsCompareNames(
    IN PSTRING Name1,
    IN PSTRING Name2
    );

ARC_STATUS
EtfsSearchDirectory(
    IN PSTRING Name,
    OUT PBOOLEAN IsDirectory
    );

VOID
EtfsGetDirectoryInfo(
    IN PRAW_DIR_REC DirEntry,
    IN BOOLEAN IsoVol,
    OUT PULONG SectorOffset,
    OUT PULONG DiskOffset,
    OUT PULONG Length
    );

COMPARISON_RESULTS
EtfsFileMatch(
    IN PRAW_DIR_REC DirEntry,
    IN PSTRING FileName
    );

typedef union _USHORT2 {
    USHORT Ushort[2];
    ULONG  ForceAlignment;
} USHORT2, *PUSHORT2;

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//  accessing the source on a word boundary.
//

#define CopyUshort2(Dst,Src) {                               \
    ((PUSHORT2)(Dst))->Ushort[0] = ((UNALIGNED USHORT2 *)(Src))->Ushort[0]; \
    ((PUSHORT2)(Dst))->Ushort[1] = ((UNALIGNED USHORT2 *)(Src))->Ushort[1]; \
    }

//
//  The following macro upcases a single ascii character
//

#define ToUpper(C) ((((C) >= 'a') && ((C) <= 'z')) ? (C) - 'a' + 'A' : (C))

#define SetFlag(Flags,SingleFlag) { (Flags) |= (SingleFlag); }

//
//  The following macro indicate if the flag is on or off
//

#define FlagOn(Flags,SingleFlag) ((BOOLEAN)(       \
    (((Flags) & (SingleFlag)) != 0 ? TRUE : FALSE) \
    )                                              \
)


//
//  Define global data.
//
//  Context Pointer - This is a pointer to the context for the current file
//      operation that is active.
//

PETFS_STRUCTURE_CONTEXT EtfsStructureContext;

//
//  File Descriptor - This is a pointer to the file descriptor for the current
//      file operation that is active.
//


PBL_FILE_TABLE EtfsFileTableEntry;

//
//  File entry table - This is a structure that provides entry to the Etfs
//      file system procedures. It is exported when an Etfs file structure
//      is recognized.
//

BL_DEVICE_ENTRY_TABLE EtfsDeviceEntryTable;


PBL_DEVICE_ENTRY_TABLE
IsEtfsFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    )

/*++

Routine Description:

    This routine determines if the partition on the specified channel
    contains an Etfs file system volume.

Arguments:

    DeviceId - Supplies the file table index for the device on which
        read operations are to be performed.

    StructureContext - Supplies a pointer to a Etfs file structure context.

Return Value:

    A pointer to the Etfs entry table is returned if the partition is
    recognized as containing an Etfs volume. Otherwise, NULL is returned.

--*/

{
    UCHAR UnalignedSector[CD_SECTOR_SIZE + 256];

    PRAW_ISO_VD RawVd;
    PRAW_DIR_REC RootDe;
    PRAW_ET_BRVD RawBrvd;

    UCHAR DescType;
    UCHAR Version;

    UCHAR BrInd;
    UCHAR BrVersion;

    BOOLEAN EtBootRec;
    BOOLEAN IsoVol;

    STRING IsoVolId;
    STRING EtSysId;
    STRING DiskId;

    ULONG DiskOffset;

    //
    //  Capture in our global variable the Etfs Structure context record
    //

    EtfsStructureContext = (PETFS_STRUCTURE_CONTEXT)StructureContext;
    RtlZeroMemory((PVOID)EtfsStructureContext, sizeof(ETFS_STRUCTURE_CONTEXT));

    //
    //  First check the Boot Record Volume Descriptor at sector 17
    //

    DiskOffset = ELTORITO_BRVD_SECTOR * CD_SECTOR_SIZE;

    //
    //  Compute the properly aligned buffer for reading in cdrom
    //  sectors.
    //

    RawBrvd = ALIGN_BUFFER( UnalignedSector );

    if (EtfsReadDisk( DeviceId,
                      DiskOffset,
                      CD_SECTOR_SIZE,
                      RawBrvd,
                      CACHE_NEW_DATA ) != ESUCCESS) {

        return NULL;
    }

    //
    //  Initialize the string Id to match.
    //

    RtlInitString( &IsoVolId, ISO_VOL_ID );

    DiskId.Length = 5;
    DiskId.MaximumLength = 5;

    //
    //  Compare the standard identifier string in the boot record volume descriptor with the Iso value.
    //

    DiskId.Buffer = RBRVD_STD_ID( RawBrvd );

    IsoVol = (BOOLEAN)(EtfsCompareNames( &DiskId, &IsoVolId ) == EqualTo);

    if (!IsoVol) {

        return NULL;
    }

    //
    //  Get the boot record indicator and volume descriptor version number.
    //

    BrInd = RBRVD_BR_IND( RawBrvd );
    BrVersion = RBRVD_VERSION( RawBrvd );

    //
    //  Return NULL, if the version is incorrect or this isn't a boot record
    //  volume descriptor.
    //

    if (BrVersion != BRVD_VERSION_1
        || BrInd != VD_BOOTREC) {

        return NULL;
    }

    //
    //  Initialize the string Id to match.
    //

    RtlInitString( &EtSysId, ET_SYS_ID );

    DiskId.Length = 23;
    DiskId.MaximumLength = 23;

    //
    //  Compare the boot system identifier in the boot record volume descriptor with the El Torito value.
    //

    DiskId.Buffer = RBRVD_SYS_ID( RawBrvd );

    EtBootRec = (BOOLEAN)(EtfsCompareNames( &DiskId, &EtSysId ) == EqualTo);

    if (!EtBootRec) {

        return NULL;
    }

    //
    // Now check the Primary Volume Descriptor
    // We do this second because if it's valid we want to store values from this sector
    // (we only allocate a single buffer for reading in a sector at a time)
    //

    RawVd = ALIGN_BUFFER( UnalignedSector );

    //
    //  For El Torito the Primary Volume Descriptor must be at sector 16
    //

    DiskOffset = ELTORITO_VD_SECTOR * CD_SECTOR_SIZE;

    //
    // Check if this is a valid Primary Volume Descriptor
    //

    if (EtfsReadDisk( DeviceId,
                      DiskOffset,
                      CD_SECTOR_SIZE,
                      RawVd,
                      CACHE_NEW_DATA ) != ESUCCESS) {

        return NULL;
    }

    //
    //  Initialize the string Id to match.
    //

    RtlInitString( &IsoVolId, ISO_VOL_ID );

    DiskId.Length = 5;
    DiskId.MaximumLength = 5;

    //
    //  Compare the standard identifier string in the volume descriptor with the Iso value.
    //

    DiskId.Buffer = RVD_STD_ID( RawVd, TRUE );

    IsoVol = (BOOLEAN)(EtfsCompareNames( &DiskId, &IsoVolId ) == EqualTo);

    if (!IsoVol) {

        return NULL;
    }

    //
    //  Get the volume descriptor type and volume descriptor version number.
    //

    DescType = RVD_DESC_TYPE( RawVd, IsoVol );
    Version = RVD_VERSION( RawVd, IsoVol );

    //
    //  Return NULL, if the version is incorrect or this isn't a primary
    //  volume descriptor.
    //

    if (Version != VERSION_1
        || DescType != VD_PRIMARY) {

        return NULL;
    }

    //
    //  Update the fields of the Etfs context structure that apply
    //  to the volume.
    //

    EtfsStructureContext->IsIsoVol = IsoVol;
    EtfsStructureContext->LbnBlockSize = RVD_LB_SIZE( RawVd, IsoVol );
    EtfsStructureContext->LogicalBlockCount = RVD_VOL_SIZE( RawVd, IsoVol );

    //
    //  Get the information on the root directory and save it in
    //  the context structure.
    //

    RootDe = (PRAW_DIR_REC) (RVD_ROOT_DE( RawVd, IsoVol ));

    EtfsGetDirectoryInfo( RootDe,
                          IsoVol,
                          &EtfsStructureContext->RootDirSectorOffset,
                          &EtfsStructureContext->RootDirDiskOffset,
                          &EtfsStructureContext->RootDirSize );

    //
    //  Initialize the file entry table.
    //

    EtfsDeviceEntryTable.Open  = EtfsOpen;
    EtfsDeviceEntryTable.Close = EtfsClose;
    EtfsDeviceEntryTable.Read  = EtfsRead;
    EtfsDeviceEntryTable.Seek  = EtfsSeek;
    EtfsDeviceEntryTable.Write = EtfsWrite;
    EtfsDeviceEntryTable.GetFileInformation = EtfsGetFileInformation;
    EtfsDeviceEntryTable.SetFileInformation = EtfsSetFileInformation;
    EtfsDeviceEntryTable.BootFsInfo = &EtfsBootFsInfo;

    //
    //  And return the address of the table to our caller.
    //

    return &EtfsDeviceEntryTable;
}


ARC_STATUS
EtfsClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    This routine closes the file specified by the file id.

Arguments:

    FileId - Supplies the file table index.

Return Value:

    ESUCCESS if returned as the function value.

--*/

{
    //
    //  Indicate that the file isn't open any longer
    //

    BlFileTable[FileId].Flags.Open = 0;

    //
    //  And return to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
EtfsOpen (
    IN PCHAR FileName,
    IN OPEN_MODE OpenMode,
    IN PULONG FileId
    )

/*++

Routine Description:

    This routine searches the root directory for a file matching FileName.
    If a match is found the dirent for the file is saved and the file is
    opened.

Arguments:

    FileName - Supplies a pointer to a zero terminated file name.

    OpenMode - Supplies the mode of the open.

    FileId - Supplies a pointer to a variable that specifies the file
        table entry that is to be filled in if the open is successful.

Return Value:

    ESUCCESS is returned if the open operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;

    ULONG DeviceId;

    STRING PathName;

    STRING Name;
    BOOLEAN IsDirectory;
    BOOLEAN SearchSucceeded;

    //
    //  Save the address of the file table entry, context area, and the device
    //  id in use.
    //

    EtfsFileTableEntry = &BlFileTable[*FileId];
    EtfsStructureContext = (PETFS_STRUCTURE_CONTEXT)EtfsFileTableEntry->StructureContext;

    DeviceId = EtfsFileTableEntry->DeviceId;

    //
    // Construct a file name descriptor from the input file name.
    //

    RtlInitString( &PathName, FileName );

    //
    //  Set the starting directory to be the root directory.
    //

    EtfsStructureContext->DirSectorOffset = EtfsStructureContext->RootDirSectorOffset;
    EtfsStructureContext->DirDiskOffset = EtfsStructureContext->RootDirDiskOffset;
    EtfsStructureContext->DirSize = EtfsStructureContext->RootDirSize;

    //
    //  While the path name has some characters in it we'll go through our
    //  loop which extracts the first part of the path name and searches
    //  the current fnode (which must be a directory) for an the entry.
    //  If what we find is a directory then we have a new directory fnode
    //  and simply continue back to the top of the loop.
    //

    IsDirectory = TRUE;
    SearchSucceeded = TRUE;

    while (PathName.Length > 0
           && IsDirectory) {

        //
        //  Extract the first component.
        //

        EtfsFirstComponent( &PathName, &Name );

        //
        //  Copy the name into the filename buffer.
        //

        EtfsFileTableEntry->FileNameLength = (UCHAR) Name.Length;
        RtlMoveMemory( EtfsFileTableEntry->FileName,
                       Name.Buffer,
                       Name.Length );

        //
        //  Look to see if the file exists.
        //

        Status = EtfsSearchDirectory( &Name,
                                      &IsDirectory );

        if (Status == ENOENT) {

            SearchSucceeded = FALSE;
            break;
        }

        if (Status != ESUCCESS) {

            return Status;
        }

    }

    //
    //  If the path name length is not zero then we were trying to crack a path
    //  with an nonexistent (or non directory) name in it.  For example, we tried
    //  to crack a\b\c\d and b is not a directory or does not exist (then the path
    //  name will still contain c\d).
    //

    if (PathName.Length != 0) {

        return ENOTDIR;
    }

    //
    //  At this point we've cracked the name up to (an maybe including the last
    //  component).  We located the last component if the SearchSucceeded flag is
    //  true, otherwise the last component does not exist.  If we located the last
    //  component then this is like an open or a supersede, but not a create.
    //

    if (SearchSucceeded) {

        //
        //  Check if the last component is a directory
        //

        if (IsDirectory) {

            //
            //  For an existing directory the only valid open mode is OpenDirectory
            //  all other modes return an error
            //

            switch (OpenMode) {

            case ArcOpenReadOnly:
            case ArcOpenWriteOnly:
            case ArcOpenReadWrite:
            case ArcCreateWriteOnly:
            case ArcCreateReadWrite:
            case ArcSupersedeWriteOnly:
            case ArcSupersedeReadWrite:

                //
                //  If we reach here then the caller got a directory but didn't
                //  want to open a directory
                //

                return EISDIR;

            case ArcOpenDirectory:

                //
                //  If we reach here then the caller got a directory and wanted
                //  to open a directory.
                //

                EtfsFileTableEntry->u.EtfsFileContext.FileSize = EtfsStructureContext->DirSize;
                EtfsFileTableEntry->u.EtfsFileContext.DiskOffset = EtfsStructureContext->DirDiskOffset;
                EtfsFileTableEntry->u.EtfsFileContext.IsDirectory = TRUE;

                EtfsFileTableEntry->Flags.Open = 1;
                EtfsFileTableEntry->Flags.Read = 1;
                EtfsFileTableEntry->Position.LowPart = 0;
                EtfsFileTableEntry->Position.HighPart = 0;

                return ESUCCESS;

            case ArcCreateDirectory:

                //
                //  If we reach here then the caller got a directory and wanted
                //  to create a new directory
                //

                return EACCES;
            }
        }

        //
        //  If we get there then we have an existing file that is being opened.
        //  We can open existing files only read only.
        //

        switch (OpenMode) {

        case ArcOpenReadOnly:

            //
            //  If we reach here then the user got a file and wanted to open the
            //  file read only
            //

            EtfsFileTableEntry->u.EtfsFileContext.FileSize = EtfsStructureContext->DirSize;
            EtfsFileTableEntry->u.EtfsFileContext.DiskOffset = EtfsStructureContext->DirDiskOffset;
            EtfsFileTableEntry->u.EtfsFileContext.IsDirectory = FALSE;

            EtfsFileTableEntry->Flags.Open = 1;
            EtfsFileTableEntry->Flags.Read = 1;
            EtfsFileTableEntry->Position.LowPart = 0;
            EtfsFileTableEntry->Position.HighPart = 0;

            return ESUCCESS;

        case ArcOpenWriteOnly:
        case ArcOpenReadWrite:
        case ArcCreateWriteOnly:
        case ArcCreateReadWrite:
        case ArcSupersedeWriteOnly:
        case ArcSupersedeReadWrite:

            //
            //  If we reach here then we are trying to open a read only
            //  device for write.
            //

            return EROFS;

        case ArcOpenDirectory:
        case ArcCreateDirectory:

            //
            //  If we reach here then the user got a file and wanted a directory
            //

            return ENOTDIR;
        }
    }

    //
    //  If we get here the last component does not exist so we are trying to create
    //  either a new file or a directory.
    //

    switch (OpenMode) {

    case ArcOpenReadOnly:
    case ArcOpenWriteOnly:
    case ArcOpenReadWrite:
    case ArcOpenDirectory:

        //
        //  If we reach here then the user did not get a file but wanted a file
        //

        return ENOENT;

    case ArcCreateWriteOnly:
    case ArcSupersedeWriteOnly:
    case ArcCreateReadWrite:
    case ArcSupersedeReadWrite:
    case ArcCreateDirectory:

        //
        //  If we get hre the user wants to create something.
        //

        return EROFS;
    }

    //
    //  If we reach here then the path name is exhausted and we didn't
    //  reach a file so return an error to our caller
    //

    return ENOENT;
}


ARC_STATUS
EtfsRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Transfer
    )

/*++

Routine Description:

    This routine reads data from the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that receives the data
        read.

    Length - Supplies the number of bytes that are to be read.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the read operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;

    ULONG DeviceId;
    ULONG DiskOffset;

    //
    //  Save the address of the file table entry, context area, and the device
    //  id in use.
    //

    EtfsFileTableEntry = &BlFileTable[FileId];
    EtfsStructureContext = (PETFS_STRUCTURE_CONTEXT)EtfsFileTableEntry->StructureContext;

    DeviceId = EtfsFileTableEntry->DeviceId;

    //
    //  Clear the transfer count and set the initial disk offset.
    //

    *Transfer = 0;

    //
    // Check for end of file.
    //

    //
    // If the file position is currently at the end of file, then return
    // a success status with no bytes read from the file. If the file
    // plus the length of the transfer is beyond the end of file, then
    // read only the remaining part of the file. Otherwise, read the
    // requested number of bytes.
    //

    if (EtfsFileTableEntry->Position.LowPart ==
        EtfsFileTableEntry->u.EtfsFileContext.FileSize) {
        return ESUCCESS;

    } else {
        if ((EtfsFileTableEntry->Position.LowPart + Length) >=
            EtfsFileTableEntry->u.EtfsFileContext.FileSize) {
            Length = EtfsFileTableEntry->u.EtfsFileContext.FileSize -
                                                EtfsFileTableEntry->Position.LowPart;
        }
    }

    DiskOffset = EtfsFileTableEntry->Position.LowPart
                 + EtfsFileTableEntry->u.EtfsFileContext.DiskOffset;

    //
    //  Read in runs (i.e., sectors) until the byte count goes to zero
    //

    while (Length > 0) {

        ULONG CurrentRunByteCount;

        //
        //  Compute the current read byte count.
        //

        if (Length > MAX_CDROM_READ) {

            CurrentRunByteCount = MAX_CDROM_READ;

        } else {

            CurrentRunByteCount = Length;
        }

        //
        //  Read from the disk.
        //

        if ((Status = EtfsReadDisk( DeviceId,
                                    DiskOffset,
                                    CurrentRunByteCount,
                                    Buffer,
                                    DONT_CACHE_NEW_DATA )) != ESUCCESS) {

            return Status;
        }

        //
        //  Update the remaining length.
        //

        Length -= CurrentRunByteCount;

        //
        //  Update the current position and the number of bytes transfered
        //

        EtfsFileTableEntry->Position.LowPart += CurrentRunByteCount;
        DiskOffset += CurrentRunByteCount;

        *Transfer += CurrentRunByteCount;

        //
        //  Update buffer to point to the next byte location to fill in
        //

        Buffer = (PCHAR)Buffer + CurrentRunByteCount;
    }

    //
    //  If we get here then remaining sector count is zero so we can
    //  return success to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
EtfsSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    This routine seeks to the specified position for the file specified
    by the file id.

Arguments:

    FileId - Supplies the file table index.

    Offset - Supplies the offset in the file to position to.

    SeekMode - Supplies the mode of the seek operation.

Return Value:

    ESUCCESS if returned as the function value.

--*/

{
    ULONG NewPosition;

    //
    //  Compute the new position
    //

    if (SeekMode == SeekAbsolute) {

        NewPosition = Offset->LowPart;

    } else {

        NewPosition = BlFileTable[FileId].Position.LowPart + Offset->LowPart;
    }

    //
    //  If the new position is greater than the file size then return
    //  an error
    //

    if (NewPosition > BlFileTable[FileId].u.EtfsFileContext.FileSize) {

        return EINVAL;
    }

    //
    //  Otherwise set the new position and return to our caller
    //

    BlFileTable[FileId].Position.LowPart = NewPosition;

    return ESUCCESS;
}


ARC_STATUS
EtfsWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Transfer
    )

/*++

Routine Description:

    This routine writes data to the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that contains the data
        written.

    Length - Supplies the number of bytes that are to be written.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the write operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    return EROFS;

    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Transfer );
}


ARC_STATUS
EtfsGetFileInformation (
    IN ULONG FileId,
    OUT PFILE_INFORMATION Buffer
    )

/*++

Routine Description:

    This procedure returns to the user a buffer filled with file information

Arguments:

    FileId - Supplies the File id for the operation

    Buffer - Supplies the buffer to receive the file information.  Note that
        it must be large enough to hold the full file name

Return Value:

    ESUCCESS is returned for all get information requests.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    ULONG i;

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[FileId];

    //
    //  Zero out the buffer, and fill in its non-zero values
    //

    RtlZeroMemory(Buffer, sizeof(FILE_INFORMATION));

    Buffer->EndingAddress.LowPart = FileTableEntry->u.EtfsFileContext.FileSize;

    Buffer->CurrentPosition.LowPart = FileTableEntry->Position.LowPart;
    Buffer->CurrentPosition.HighPart = 0;

    SetFlag(Buffer->Attributes, ArcReadOnlyFile);

    if (FileTableEntry->u.EtfsFileContext.IsDirectory) {

        SetFlag( Buffer->Attributes, ArcDirectoryFile );
    }

    Buffer->FileNameLength = FileTableEntry->FileNameLength;

    for (i = 0; i < FileTableEntry->FileNameLength; i += 1) {

        Buffer->FileName[i] = FileTableEntry->FileName[i];
    }

    return ESUCCESS;
}


ARC_STATUS
EtfsSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )

/*++

Routine Description:

    This routine sets the file attributes of the indicated file

Arguments:

    FileId - Supplies the File Id for the operation

    AttributeFlags - Supplies the value (on or off) for each attribute being modified

    AttributeMask - Supplies a mask of the attributes being altered.  All other
        file attributes are left alone.

Return Value:

    EROFS is always returned in this case.

--*/

{
    return EROFS;

    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( AttributeFlags );
    UNREFERENCED_PARAMETER( AttributeMask );
}


ARC_STATUS
EtfsInitialize (
    VOID
    )

/*++

Routine Description:

    This routine initializes the etfs boot filesystem.
    Currently this is a no-op.

Arguments:

    None.

Return Value:

    ESUCCESS.

--*/

{
    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
EtfsReadDisk(
    IN ULONG DeviceId,
    IN ULONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    )

/*++

Routine Description:

    This routine reads in zero or more sectors from the specified device.

Arguments:

    DeviceId - Supplies the device id to use in the arc calls.

    Lbo - Supplies the LBO (logical byte offset) to start reading from.

    ByteCount - Supplies the number of bytes to read.

    Buffer - Supplies a pointer to the buffer to read the bytes into.

    CacheNewData - Whether to cache new data read from the disk.

Return Value:

    ESUCCESS is returned if the read operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    LARGE_INTEGER LargeLbo;
    ARC_STATUS Status;
    ULONG i;

    //
    //  Special case the zero byte read request
    //

    if (ByteCount == 0) {

        return ESUCCESS;
    }

    //
    // Issue the read through the cache.
    //

    LargeLbo.QuadPart = Lbo;
    Status = BlDiskCacheRead(DeviceId, 
                             &LargeLbo, 
                             Buffer, 
                             ByteCount, 
                             &i,
                             CacheNewData);

    if (Status != ESUCCESS) {

        return Status;
    }

    //
    //  Make sure we got back the amount requested
    //

    if (ByteCount != i) {

        return EIO;
    }

    //
    //  Everything is fine so return success to our caller
    //

    return ESUCCESS;
}


//
//  Internal support routine
//

VOID
EtfsFirstComponent(
    IN OUT PSTRING String,
    OUT PSTRING FirstComponent
    )

/*++

Routine Description:

    This routine takes an input path name and separates it into its
    first file name component and the remaining part.

Arguments:

    String - Supplies the original string being dissected.  On return
        this string will now point to the remaining part.

    FirstComponent - Returns the string representing the first file name
        in the input string.

Return Value:

    None.

--*/

{
    ULONG Index;

    //
    //  Copy over the string variable into the first component variable
    //

    *FirstComponent = *String;

    //
    //  Now if the first character in the name is a backslash then
    //  simply skip over the backslash.
    //

    if (FirstComponent->Buffer[0] == '\\') {

        FirstComponent->Buffer += 1;
        FirstComponent->Length -= 1;
    }

    //
    //  Now search the name for a backslash
    //

    for (Index = 0; Index < FirstComponent->Length; Index += 1) {

        if (FirstComponent->Buffer[Index] == '\\') {

            break;
        }
    }

    //
    //  At this point Index denotes a backslash or is equal to the length
    //  of the string.  So update string to be the remaining part.
    //  Decrement the length of the first component by the approprate
    //  amount
    //

    String->Buffer = &FirstComponent->Buffer[Index];
    String->Length = (SHORT)(FirstComponent->Length - Index);

    FirstComponent->Length = (SHORT)Index;

    //
    //  And return to our caller.
    //

    return;
}


//
//  Internal support routine
//

COMPARISON_RESULTS
EtfsCompareNames(
    IN PSTRING Name1,
    IN PSTRING Name2
    )

/*++

Routine Description:

    This routine takes two names and compare them ignoring case.  This
    routine does not do implied dot or dbcs processing.

Arguments:

    Name1 - Supplies the first name to compare

    Name2 - Supplies the second name to compare

Return Value:

    LessThan    if Name1 is lexically less than Name2
    EqualTo     if Name1 is lexically equal to Name2
    GreaterThan if Name1 is lexically greater than Name2

--*/

{
    ULONG i;
    ULONG MinimumLength;

    //
    //  Compute the smallest of the two name lengths
    //

    MinimumLength = (Name1->Length < Name2->Length ? Name1->Length : Name2->Length);

    //
    //  Now compare each character in the names.
    //

    for (i = 0; i < MinimumLength; i += 1) {

        if (ToUpper(Name1->Buffer[i]) < ToUpper(Name2->Buffer[i])) {

            return LessThan;
        }

        if (ToUpper(Name1->Buffer[i]) > ToUpper(Name2->Buffer[i])) {

            return GreaterThan;
        }
    }

    //
    //  The names compared equal up to the smallest name length so
    //  now check the name lengths
    //

    if (Name1->Length < Name2->Length) {

        return LessThan;
    }

    if (Name1->Length > Name2->Length) {

        return GreaterThan;
    }

    return EqualTo;
}


//
//  Internal support routine.
//

ARC_STATUS
EtfsSearchDirectory(
    IN PSTRING Name,
    OUT PBOOLEAN IsDirectory
    )

/*++

Routine Description:

    This routine walks through the current directory in the Etfs
    context structure, looking for a match for 'Name'.  We will find
    the first non-multi-extent, non-interleave file.  We will ignore
    any version number for the file.  The details about the file, if
    found, are stored in the Etfs context structure.

Arguments:

    Name - This is the name of the file to search for.

    IsDirectory - Supplies the address of a boolean where we store
                  whether this is or is not a directory.

Return Value:

    ESUCCESS is returned if the operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;

    ULONG SectorOffset;
    ULONG SectorDiskOffset;
    ULONG DirentOffset;
    ULONG RemainingBytes;

    BOOLEAN ReadSector;
    BOOLEAN SearchForMultiEnd;

    UCHAR UnalignedBuffer[CD_SECTOR_SIZE + 256];

    PUCHAR RawSector;

    PRAW_DIR_REC RawDe;

    COMPARISON_RESULTS ComparisonResult;

    //
    //  Initialize the local variables.
    //

    RawSector = ALIGN_BUFFER( UnalignedBuffer );

    SearchForMultiEnd = FALSE;

    //
    //  Remember where we are within the disk, sector and directory file.
    //

    SectorOffset = EtfsStructureContext->DirSectorOffset;
    SectorDiskOffset = EtfsStructureContext->DirDiskOffset - SectorOffset;
    DirentOffset = 0;

    ReadSector = FALSE;

    //
    //  If this is the root directory, then we can return immediately.
    //

    if (Name->Length == 1
        && *Name->Buffer == '\\') {

        *IsDirectory = TRUE;

        //
        //  The structure context is already filled in.
        //

        return ESUCCESS;
    }

    //
    //  Compute the remaining bytes in this sector.
    //

    RemainingBytes = CD_SECTOR_SIZE - SectorOffset;

    //
    //  Loop until the directory is exhausted or a matching dirent for the
    //  target name is found.
    //

    while (TRUE) {

        //
        //  If the current offset is beyond the end of the directory,
        //  raise an appropriate status.
        //

        if (DirentOffset >= EtfsStructureContext->DirSize) {

            return ENOENT;
        }

        //
        //  If the remaining bytes in this sector is less than the
        //  minimum needed for a dirent, then move to the next sector.
        //

        if (RemainingBytes < MIN_DIR_REC_SIZE) {

            SectorDiskOffset += CD_SECTOR_SIZE;
            DirentOffset += RemainingBytes;
            SectorOffset = 0;
            RemainingBytes = CD_SECTOR_SIZE;
            ReadSector = FALSE;

            continue;
        }

        //
        //  If we have not read in the sector, do so now.
        //

        if (!ReadSector) {

            Status = EtfsReadDisk( EtfsFileTableEntry->DeviceId,
                                   SectorDiskOffset,
                                   CD_SECTOR_SIZE,
                                   RawSector,
                                   CACHE_NEW_DATA );

            if (Status != ESUCCESS) {

                return Status;
            }

            ReadSector = TRUE;
        }

        //
        //  If the first byte of the next dirent is '\0', then we move to
        //  the next sector.
        //

        if (*(RawSector + SectorOffset) == '\0') {

            SectorDiskOffset += CD_SECTOR_SIZE;
            DirentOffset += RemainingBytes;
            SectorOffset = 0;
            RemainingBytes = CD_SECTOR_SIZE;
            ReadSector = FALSE;

            continue;
        }

        RawDe = (PRAW_DIR_REC) ((PUCHAR) RawSector + SectorOffset);

        //
        //  If the size of this dirent extends beyond the end of this sector
        //  we abort the search.
        //

        if ((ULONG)RawDe->DirLen > RemainingBytes) {

            return EINVAL;
        }

        //
        //  We have correctly found the next dirent.  We first check whether
        //  we are looking for the last dirent for a multi-extent.
        //

        if (SearchForMultiEnd) {

            //
            //  If this is the last of a multi-extent we change our search
            //  state.
            //

            if (!FlagOn( DE_FILE_FLAGS( EtfsStructureContext->IsIsoVol, RawDe ),
                         ISO_ATTR_MULTI )) {

                SearchForMultiEnd = TRUE;
            }

        //
        //  If this is a multi-extent dirent, we change our search state.
        //

        } else if (FlagOn( DE_FILE_FLAGS( EtfsStructureContext->IsIsoVol, RawDe ),
                           ISO_ATTR_MULTI )) {

            SearchForMultiEnd = TRUE;

        //
        //  If this is a file match, we update the Etfs context structure
        //  and the 'IsDirectory' flag.
        //

        } else {

            ComparisonResult = EtfsFileMatch( RawDe, Name );

            if (ComparisonResult == EqualTo) {

                EtfsGetDirectoryInfo( RawDe,
                                      EtfsStructureContext->IsIsoVol,
                                      &EtfsStructureContext->DirSectorOffset,
                                      &EtfsStructureContext->DirDiskOffset,
                                      &EtfsStructureContext->DirSize );

                *IsDirectory = FlagOn( DE_FILE_FLAGS( EtfsStructureContext->IsIsoVol, RawDe ),
                                       ISO_ATTR_DIRECTORY );

                return ESUCCESS;

            //
            //  If we have passed this file in the directory, then
            //  exit with the appropriate error code.
            //

            } else if (ComparisonResult == GreaterThan) {

                return ENOENT;
            }
        }

        //
        //  Otherwise we simply compute the next sector offset, disk offset
        //  and file offset.
        //

        SectorOffset += RawDe->DirLen;
        DirentOffset += RawDe->DirLen;
        RemainingBytes -= RawDe->DirLen;
    }

    return ESUCCESS;
}


//
//  Internal support routine.
//

VOID
EtfsGetDirectoryInfo(
    IN PRAW_DIR_REC DirEntry,
    IN BOOLEAN IsoVol,
    OUT PULONG SectorOffset,
    OUT PULONG DiskOffset,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine takes a pointer to a raw directory structure on the disk
    and computes the file size, disk offset and file length for the
    directory entry.

Arguments:

    DirEntry - This points to raw data from the disk.

    IsoVol - Boolean indicating that this is an ISO volume.

    SectorOffset - This supplies the address to store the sector offset of the
                   start of the disk data.

    DiskOffset - This supplies the address to store the disk offset of the
                 start of the disk data.

    Length - This supplies the address to store the number of bytes in
             the file referred by this disk directory.

Return Value:

    None.

--*/

{
    //
    //  The disk offset is length of the Xar blocks added to the starting
    //  location for the file.
    //

    CopyUshort2( DiskOffset, DirEntry->FileLoc );
    *DiskOffset *= EtfsStructureContext->LbnBlockSize;
    *DiskOffset += (DirEntry->XarLen * EtfsStructureContext->LbnBlockSize);

    //
    //  The sector offset is the least significant bytes of the disk offset.
    //

    *SectorOffset = *DiskOffset & (CD_SECTOR_SIZE - 1);

    //
    //  The file size is pulled straight from the dirent.   We round it
    //  to a sector size to protect us from faulty disks if this is a
    //  directory.  Otherwise we use it directly from the dirent.
    //

    CopyUshort2( Length, DirEntry->DataLen );

    if (FlagOn( DE_FILE_FLAGS( IsoVol, DirEntry ), ISO_ATTR_DIRECTORY )) {

        *Length += (*SectorOffset + CD_SECTOR_SIZE - 1);
        *Length &= ~(CD_SECTOR_SIZE - 1);
        *Length -= *SectorOffset;
    }

    return;
}


//
//  Internal support routine.
//

COMPARISON_RESULTS
EtfsFileMatch(
    IN PRAW_DIR_REC DirEntry,
    IN PSTRING FileName
    )

{
    STRING DirentString;
    ULONG Count;

    PUCHAR StringPtr;

    //
    //  We never match either '\0' or '\1'.  We will return 'LessThan' in
    //  all of these cases.
    //

    if (DirEntry->FileIdLen == 1
        && (DirEntry->FileId[0] == '\0'
            || DirEntry->FileId[0] == '\1')) {

        return LessThan;
    }

    //
    //  We assume that we can use the entire file name in the dirent.
    //

    DirentString.Length = DirEntry->FileIdLen;
    DirentString.Buffer = DirEntry->FileId;

    //
    //  We walk backwards through the dirent name to check for the
    //  existance of a ';' character.  We then set the string length
    //  to this position.
    //

    StringPtr = DirentString.Buffer + DirentString.Length - 1;
    Count = DirentString.Length;

    while (Count--) {

        if (*StringPtr == ';') {

            DirentString.Length = (SHORT)Count;
            break;
        }

        StringPtr--;
    }

    //
    //  We also check for a terminating '.' character and truncate it.
    //

    StringPtr = DirentString.Buffer + DirentString.Length - 1;
    Count = DirentString.Length;

    while (Count--) {

        if (*StringPtr == '.') {

            DirentString.Length = (SHORT)Count;

        } else {

            break;
        }

        StringPtr--;
    }

    //
    //  We now have the two filenames to compare.  The result of this
    //  operation is simply the comparison of the two of them.
    //

    DirentString.MaximumLength = DirentString.Length;

    return EtfsCompareNames( &DirentString, FileName );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\haldtect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    haldtect.c

Abstract:

    Provides HAL detection for ARC-compliant machines.

Author:

    John Vert (jvert) 21-Oct-1993

Revision History:

--*/

#if defined(_ALPHA_) || defined(_AXP64_) || defined(_MIPS_) || defined(_PPC_)

#include "haldtect.h"
#include <stdlib.h>

PVOID InfFile;
PVOID WinntSifHandle;


PCHAR
SlDetectHal(
    VOID
    )

/*++

Routine Description:

    Determines the canonical short machine name for the HAL to be loaded for
    this machine.

    It does this by enumerating the [Map.Computer] section of the INF file and
    comparing the strings there with the computer description in the ARC tree.

    [Map.Computer]
        msjazz_up   = *Jazz
        desksta1_up = "DESKTECH-ARCStation I"
        pica61_up   = "PICA-61"
        duo_mp      = *Duo

    [Map.Computer]
        DECjensen = "DEC-20Jensen"
        DECjensen = "DEC-10Jensen"

Arguments:

    None.

Return Value:

    PCHAR - pointer to canonical shortname for the machine.
    NULL - the type of machine could not be determined.

--*/

{
    PCONFIGURATION_COMPONENT_DATA Node;
    PCHAR MachineName;

    //
    // Find the system description node
    //
    Node = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                    SystemClass,
                                    ArcSystem,
                                    NULL);
    if (Node==NULL) {
        SlError(0);
        return(NULL);
    }

    MachineName = Node->ComponentEntry.Identifier;
    MachineName = (MachineName ? SlSearchSection("Map.Computer", MachineName) : NULL);
    return(MachineName);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\debug.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    blio.c

Abstract:

    This module contains the stub code for the debug print API's.

Author:

    David N. Cutler (davec) 2-Feby-2000

Revision History:

--*/

#include "bootlib.h"
#include "stdarg.h"

#if !defined(ENABLE_LOADER_DEBUG)

#if !defined (_IA64_) || !defined (FORCE_CD_BOOT)


ULONG
DbgPrint(
    IN PCHAR Format,
    ...
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    Format     - printf style format string
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{

    return 0;
}
#endif

ULONG
DbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    PCHAR Format,
    ...
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    ComponentId - Supplies the Id of the calling component.
//    Level      - Supplies the output filter level.
//    Format     - printf style format string
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{
    return 0;
}

ULONG
vDbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCHAR Format,
    va_list arglist
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    ComponentId - Supplies the Id of the calling component.
//    Level      - Supplies the output filter level or mask.
//    Arguments   - Supplies a pointer to a variable argument list.
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{

    return 0;
}

ULONG
vDbgPrintExWithPrefix(
    IN PCH Prefix,
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCHAR Format,
    va_list arglist
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    Prefix - Supplies a pointer to a message prefix.
//    ComponentId - Supplies the Id of the calling component.
//    Level      - Supplies the output filter level or mask.
//    Arguments   - Supplies a pointer to a variable argument list.
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{

    return 0;
}

VOID
DbgLoadImageSymbols(
    IN PSTRING FileName,
    IN PVOID ImageBase,
    IN ULONG_PTR ProcessId
    )

//++
//
// Routine Description:
//
//    Tells the debugger about newly loaded symbols.
//
// Arguments:
//
// Return Value:
//
//--

{

    return;
}

VOID
DbgUnLoadImageSymbols (
    IN PSTRING FileName,
    IN PVOID ImageBase,
    IN ULONG_PTR ProcessId
    )

//++
//
// Routine Description:
//
//    Tells the debugger about newly unloaded symbols.
//
// Arguments:
//
// Return Value:
//
//--

{
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\hdlsterm.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hdlsterm.c

Abstract:

    This modules implements stuff that is specific for headless terminal support.

Author:

    Sean Selitrennikoff (v-seans) 1-13-00

Revision History:

--*/

#include "bldr.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#include "ntverp.h"
#include "bldrx86.h"

#define TERMINAL_LINE_LENGTH 70
BOOLEAN FirstEntry = TRUE;
UCHAR TerminalLine[TERMINAL_LINE_LENGTH];
ULONG LinePosition = 0;

#define TERMINAL_PROMPT "!SAC>"

BOOLEAN
BlpDoCommand(
    IN PUCHAR InputLine
    );

BOOLEAN
BlTerminalHandleLoaderFailure(
    VOID
    )

/*++

Routine Description:

    Gives a mini-SAC to the user, return TRUE when the user wants a reboot.

Arguments:

    None.

Return Value:

    TRUE - When the user wants a reboot, else FALSE.

--*/

{
    ULONG Count;
    BOOLEAN Reboot;
    ULONG Key;

    if (!BlIsTerminalConnected()) {
        return TRUE;
    }

    //
    // Position the cursor to the bottom of the screen and write the prompt
    //
    if (FirstEntry) {
        FirstEntry = FALSE;
        BlPositionCursor(1, ScreenHeight);
        ArcWrite(BlConsoleOutDeviceId, "\r\n", sizeof("\r\n"), &Count);
        ArcWrite(BlConsoleOutDeviceId, TERMINAL_PROMPT, sizeof(TERMINAL_PROMPT), &Count);
    }

    //
    // Check for input.
    // 
    if (ArcGetReadStatus(BlConsoleInDeviceId) == ESUCCESS) {
        
        Key = BlGetKey();

        if (Key == ESCAPE_KEY) {

            //
            // Clear this line
            //

            ArcWrite(BlConsoleOutDeviceId, "\\", sizeof("\\"), &Count);
            BlPositionCursor(1, ScreenHeight);
            ArcWrite(BlConsoleOutDeviceId, "\r\n", sizeof("\r\n"), &Count);
            ArcWrite(BlConsoleOutDeviceId, TERMINAL_PROMPT, sizeof(TERMINAL_PROMPT), &Count);
            return FALSE;
        }

        if (Key == BKSP_KEY) {

            if (LinePosition != 0) {
                BlPositionCursor(LinePosition + sizeof(TERMINAL_PROMPT) - 1, ScreenHeight);
                ArcWrite(BlConsoleOutDeviceId, " ", sizeof(" "), &Count);
                BlPositionCursor(LinePosition + sizeof(TERMINAL_PROMPT) - 1, ScreenHeight);
                LinePosition--;
                TerminalLine[LinePosition] = '\0';
            }

            return FALSE;
        }

        if (Key == TAB_KEY) {

            ArcWrite(BlConsoleOutDeviceId, "\007", sizeof("\007"), &Count);
            return FALSE;
        }

        if (Key == ENTER_KEY) {

            TerminalLine[LinePosition] = '\0';

            ArcWrite(BlConsoleOutDeviceId, "\r\n", sizeof("\r\n"), &Count);
            
            if (LinePosition != 0) {
                Reboot = BlpDoCommand(TerminalLine);
            } else {
                Reboot = FALSE;
            }

            if (!Reboot) {
                BlPositionCursor(1, ScreenHeight);
                ArcWrite(BlConsoleOutDeviceId, "\r\n", sizeof("\r\n"), &Count);
                ArcWrite(BlConsoleOutDeviceId, TERMINAL_PROMPT, sizeof(TERMINAL_PROMPT), &Count);
                LinePosition = 0;
            }

            return Reboot;
        }

        //
        // Ignore all other non-ASCII keys
        //
        if (Key != (ULONG)(Key & 0x7F)) {
            return FALSE;
        }

        //
        // All other keys get recorded.
        //
        TerminalLine[LinePosition] = (UCHAR)Key;

        if (LinePosition < TERMINAL_LINE_LENGTH - 1) {
            LinePosition++;
        } else {
            BlPositionCursor(LinePosition + sizeof(TERMINAL_PROMPT) - 1, ScreenHeight);
        }

        //
        // Echo back to the console the character.
        //
        ArcWrite(BlConsoleOutDeviceId, &((UCHAR)Key), sizeof(UCHAR), &Count);

    }

    return FALSE;
}

BOOLEAN
BlpDoCommand(
    IN PUCHAR InputLine
    )

/*++

Routine Description:

    Process an input line.

Arguments:

    InputLine - The command from the user.

Return Value:

    TRUE - When the user wants a reboot, else FALSE.

--*/

{
    ULONG Count;

    if ((_stricmp(InputLine, "?") == 0) ||
        (_stricmp(InputLine, "help") == 0)) {
        ArcWrite(BlConsoleOutDeviceId, 
                 "?        Display this message.\r\n",
                 sizeof("?        Display this message.\r\n"),
                 &Count
                );

        ArcWrite(BlConsoleOutDeviceId, 
                 "restart   Restart the system immediately.\r\n",
                 sizeof("restart   Restart the system immediately.\r\n"),
                 &Count
                );

        return FALSE;
    }

    if (_stricmp(InputLine, "restart") == 0) {
        return TRUE;
    }

    ArcWrite(BlConsoleOutDeviceId,
             "Invalid Command, use '?' for help.\r\n",
             sizeof("Invalid Command, use '?' for help.\r\n"),
             &Count
            );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\netboot.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    netboot.c

Abstract:

    This module implements the net boot file system used by the operating
    system loader.

Author:

    Chuck Lenzmeier (chuckl) 09-Jan-1997

Revision History:

--*/

#include "bootlib.h"
#include "stdio.h"

#ifdef UINT16
#undef UINT16
#endif

#ifdef INT16
#undef INT16
#endif

#include <dhcp.h>
#include <netfs.h>
#include <pxe_cmn.h>

#include <pxe_api.h>

#include <udp_api.h>
#include <tftp_api.h>
#if defined(_IA64_)
#include "bootia64.h"
#else
#include "bootx86.h"
#endif

#ifndef BOOL
typedef int BOOL;
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE  1
#endif

#ifndef BYTE
typedef unsigned char BYTE;
#endif

#ifndef LPBYTE
typedef BYTE *LPBYTE;
#endif

#define MAX_PATH          260


//
// Define global data.
//

BOOLEAN BlBootingFromNet = FALSE;

BOOLEAN NetBootInitialized = FALSE;

PARC_OPEN_ROUTINE NetRealArcOpenRoutine;
PARC_CLOSE_ROUTINE NetRealArcCloseRoutine;

BL_DEVICE_ENTRY_TABLE NetDeviceEntryTable;

BOOTFS_INFO NetBootFsInfo={L"net"};

#if defined(REMOTE_BOOT_SECURITY)
ULONG TftpSecurityHandle = 0;
#endif // defined(REMOTE_BOOT_SECURITY)

BOOLEAN NetBootTftpUsedPassword2;

//
// We cache the last file opened, in case we get a request to open it again.
// We don't save a copy of the data, just a pointer to the data read by that
// open. So if the original open is closed before the next open for the
// same file comes in, we won't get a cache hit. But this system works for
// reading compressed files, which is the situation we care about. In that
// case a file is opened once and then re-opened twice more before the
// original open is closed.
//

ULONG CachedFileDeviceId = 0;
UCHAR CachedFilePath[MAX_PATH];
ULONG CachedFileSize = 0;
PUCHAR CachedFileData = NULL;

extern ARC_STATUS
GetParametersFromRom (
    VOID
    );


PBL_DEVICE_ENTRY_TABLE
IsNetFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    )

/*++

Routine Description:

    This routine determines if the partition on the specified channel
    contains a net file system volume.

Arguments:

    DeviceId - Supplies the file table index for the device on which
        read operations are to be performed.

    StructureContext - Supplies a pointer to a net file structure context.

Return Value:

    A pointer to the net entry table is returned if the partition is
    recognized as containing a net volume.  Otherwise, NULL is returned.

--*/

{
    PNET_STRUCTURE_CONTEXT NetStructureContext;

    DPRINT( TRACE, ("IsNetFileStructure\n") );

    if ( !BlBootingFromNet || (DeviceId != NET_DEVICE_ID) ) {
        return NULL;
    }

    //
    //  Clear the file system context block for the specified channel and
    //  establish a pointer to the context structure that can be used by other
    //  routines
    //

    NetStructureContext = (PNET_STRUCTURE_CONTEXT)StructureContext;
    RtlZeroMemory(NetStructureContext, sizeof(NET_STRUCTURE_CONTEXT));

    //
    //  Return the address of the table.
    //

    return &NetDeviceEntryTable;

} // IsNetFileStructure


ARC_STATUS
NetInitialize (
    VOID
    )

/*++

Routine Description:

    This routine initializes the net boot filesystem.

Arguments:

    None.

Return Value:

    ESUCCESS.

--*/

{
    NTSTATUS status;

    DPRINT( TRACE, ("NetInitialize\n") );
    //DbgBreakPoint( );

    
    if( NetBootInitialized ) {
        return ESUCCESS;
    }

    
    //
    // Initialize the file entry table.  Note that we need to do
    // this even if we aren't booting from the net because we may
    // use the 'Net' I/O functions to lay on top of any files that
    // we download through the debugger port.  So for that case,
    // we need access to all these functions here (see bd\file.c)
    //
    NetDeviceEntryTable.Close = NetClose;
    NetDeviceEntryTable.Mount = NetMount;
    NetDeviceEntryTable.Open  = NetOpen;
    NetDeviceEntryTable.Read  = NetRead;
    NetDeviceEntryTable.GetReadStatus = NetGetReadStatus;
    NetDeviceEntryTable.Seek  = NetSeek;
    NetDeviceEntryTable.Write = NetWrite;
    NetDeviceEntryTable.GetFileInformation = NetGetFileInformation;
    NetDeviceEntryTable.SetFileInformation = NetSetFileInformation;
    NetDeviceEntryTable.Rename = NetRename;
    NetDeviceEntryTable.GetDirectoryEntry   = NetGetDirectoryEntry;
    NetDeviceEntryTable.BootFsInfo = &NetBootFsInfo;

    if( !BlBootingFromNet ) {
        return ESUCCESS;
    }

    NetBootInitialized = TRUE;

    DPRINT( LOUD, ("NetInitialize: booting from net\n") );
    //DPRINT( LOUD, ("  NetInitialize at %08x\n", NetInitialize) );
    //DPRINT( LOUD, ("  NetOpen       at %08x\n", NetOpen) );
    //DbgBreakPoint( );


    //
    // Hook the ArcOpen and ArcClose routines.
    //

    NetRealArcOpenRoutine = SYSTEM_BLOCK->FirmwareVector[OpenRoutine];
    SYSTEM_BLOCK->FirmwareVector[OpenRoutine] = NetArcOpen;

    NetRealArcCloseRoutine = SYSTEM_BLOCK->FirmwareVector[CloseRoutine];
    SYSTEM_BLOCK->FirmwareVector[CloseRoutine] = NetArcClose;

    //
    // Get boot parameters from the boot ROM.
    //

    status = GetParametersFromRom( );

    if ( status != ESUCCESS ) {
        return status;
    }

    return ESUCCESS;
}


VOID
NetTerminate (
    VOID
    )

/*++

Routine Description:

    This routine shuts down the net boot filesystem.

Arguments:

    None.

Return Value:

    ESUCCESS.

--*/

{

#if defined(_X86_)

#if defined(REMOTE_BOOT_SECURITY)
    if ( TftpSecurityHandle != 0 ) {
        TftpLogoff(NetServerIpAddress, TftpSecurityHandle);
        TftpSecurityHandle = 0;
    }
#endif // defined(REMOTE_BOOT_SECURITY)


    //
    //  let's not set the receive status if the card isn't active.
    //
    RomSetReceiveStatus( 0 );
#endif // defined(_X86_)


#ifdef EFI
    extern VOID EfiNetTerminate();
    EfiNetTerminate();
#endif

    return;

} // NetTerminate


ARC_STATUS
NetArcClose (
    IN ULONG FileId
    )
{
    DPRINT( TRACE, ("NetArcClose\n") );

    if ( FileId != NET_DEVICE_ID ) {
        return NetRealArcCloseRoutine( FileId );
    }

    return ESUCCESS;

} // NetArcClose


ARC_STATUS
NetArcOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    )
{
    DPRINT( TRACE, ("NetArcOpen\n") );

    if ( _strnicmp(OpenPath, "net(", 4) != 0 ) {
        return NetRealArcOpenRoutine( OpenPath, OpenMode, FileId );
    }

    *FileId = NET_DEVICE_ID;

    return ESUCCESS;

} // NetArcOpen


ARC_STATUS
NetClose (
    IN ULONG FileId
    )
{
    PBL_FILE_TABLE fileTableEntry;
    DPRINT( TRACE, ("NetClose FileId = %d\n", FileId) );

    fileTableEntry = &BlFileTable[FileId];

    {
        DPRINT( REAL_LOUD, ("NetClose: id %d, freeing memory at 0x%08x, %d bytes\n",
            FileId,
            fileTableEntry->u.NetFileContext.InMemoryCopy,
            fileTableEntry->u.NetFileContext.FileSize) );
        BlFreeDescriptor( (ULONG)((ULONG_PTR)fileTableEntry->u.NetFileContext.InMemoryCopy >> PAGE_SHIFT ));

        //
        // If the data read for this specific open was what was cached,
        // then mark the cache empty.
        //
        if (fileTableEntry->u.NetFileContext.InMemoryCopy == CachedFileData) {
            CachedFileData = NULL;
            CachedFilePath[0] = '\0';
        }
    }

    fileTableEntry->Flags.Open = 0;

    return EROFS;

} // NetClose


ARC_STATUS
NetMount (
    IN CHAR * FIRMWARE_PTR MountPath,
    IN MOUNT_OPERATION Operation
    )
{
    DPRINT( TRACE, ("NetMount\n") );

    return EROFS;

} // NetMount


ARC_STATUS
NetOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    )
{
    NTSTATUS ntStatus;
    ARC_STATUS arcStatus; // holds temp values, not the function return value
    PBL_FILE_TABLE fileTableEntry;
    TFTP_REQUEST request;
    ULONG oldBase;
    ULONG oldLimit;
    PCHAR p;
#if defined(REMOTE_BOOT_SECURITY)
    static BOOLEAN NetBootTryTftpSecurity = FALSE;
#endif // defined(REMOTE_BOOT_SECURITY)

    DPRINT( TRACE, ("NetOpen FileId = %d\n", *FileId) );

    DPRINT( LOUD, ("NetOpen: opening %s, id %d, mode %d\n", OpenPath, *FileId, OpenMode) );
    fileTableEntry = &BlFileTable[*FileId];

    if ( OpenMode != ArcOpenReadOnly ) {
        DPRINT( LOUD, ("NetOpen: invalid OpenMode\n") );
        return EROFS;
    }

    fileTableEntry->Flags.Open = 1; // Prevent GetCSCFileNameFromUNCPath using our entry

#if defined(REMOTE_BOOT_SECURITY)
    //
    // Login if we don't have a valid handle, using the on-disk secret.
    //

    if ((TftpSecurityHandle == 0) &&
        NetBootTryTftpSecurity) {

        ULONG FileId;
        RI_SECRET Secret;
        UCHAR Domain[RI_SECRET_DOMAIN_SIZE + 1];
        UCHAR User[RI_SECRET_USER_SIZE + 1];
        struct {
            UCHAR Owf[LM_OWF_PASSWORD_SIZE+NT_OWF_PASSWORD_SIZE];
        } Passwords[2];
        UCHAR Sid[RI_SECRET_SID_SIZE];

        arcStatus = BlOpenRawDisk(&FileId);

        if (arcStatus == ESUCCESS) {

            arcStatus = BlReadSecret(FileId, &Secret);
            if (arcStatus == ESUCCESS) {
                BlParseSecret(
                    Domain,
                    User,
                    Passwords[0].Owf,
                    Passwords[0].Owf + LM_OWF_PASSWORD_SIZE,
                    Passwords[1].Owf,
                    Passwords[1].Owf + LM_OWF_PASSWORD_SIZE,
                    Sid,
                    &Secret);
                DPRINT(LOUD, ("Logging on to <%s><%s>\n", Domain, User));

                //
                // Try logging on with the first password, if that fails
                // then try the second.
                //

                ntStatus = TftpLogin(
                             Domain,
                             User,
                             Passwords[0].Owf,
                             NetServerIpAddress,
                             &TftpSecurityHandle);
                if (!NT_SUCCESS(ntStatus)) {
                    DPRINT(LOUD, ("TftpLogin using password 2\n"));
                    ntStatus = TftpLogin(
                                 Domain,
                                 User,
                                 Passwords[1].Owf,
                                 NetServerIpAddress,
                                 &TftpSecurityHandle);
                    if (NT_SUCCESS(ntStatus)) {
                        NetBootTftpUsedPassword2 = TRUE;
                    }
                }

            } else {

                ntStatus = STATUS_OBJECT_PATH_NOT_FOUND;
            }

            arcStatus = BlCloseRawDisk(FileId);

            //
            // We are inside the if() for successfully opening the raw
            // disk, so we are not diskless. On these machines we must
            // fail the open at this point.
            //

            if (!NT_SUCCESS(ntStatus)) {
                DPRINT( ERROR, ("TftpLogin failed %lx\n", ntStatus) );
                return EACCES;
            }

        } else {

            NetBootTryTftpSecurity = FALSE;  // so we don't try to open it again
        }

    }
#endif // defined(REMOTE_BOOT_SECURITY)

    DPRINT( LOUD, ("NetOpen: opening %s\n", OpenPath) );

    oldBase = BlUsableBase;
    oldLimit = BlUsableLimit;
    BlUsableBase = BL_DRIVER_RANGE_LOW;
    BlUsableLimit = BL_DRIVER_RANGE_HIGH;

    //
    // If this request matches the cached file, then just copy that data.
    //

    if ((fileTableEntry->DeviceId == CachedFileDeviceId) &&
        (strcmp(OpenPath, CachedFilePath) == 0) &&
        (CachedFileData != NULL)) {

        ULONG basePage;

        arcStatus = BlAllocateAlignedDescriptor(
                        LoaderFirmwareTemporary,
                        0,
                        (CachedFileSize + PAGE_SIZE - 1) >> PAGE_SHIFT,
                        0,
                        &basePage
                        );

        BlUsableBase = oldBase;
        BlUsableLimit = oldLimit;

        if ( arcStatus != ESUCCESS ) {
            fileTableEntry->Flags.Open = 0; // Free entry we didn't use

            return EROFS;
        }

        DPRINT( REAL_LOUD, ("NetOpen: Using cache for file %s\n", CachedFilePath) );

        fileTableEntry->u.NetFileContext.InMemoryCopy = (PUCHAR)ULongToPtr( (basePage << PAGE_SHIFT) );
        memcpy(fileTableEntry->u.NetFileContext.InMemoryCopy, CachedFileData, CachedFileSize);
        fileTableEntry->u.NetFileContext.FileSize = CachedFileSize;

    } else {

        request.RemoteFileName = OpenPath;
        request.ServerIpAddress = NetServerIpAddress;
        request.MemoryAddress = NULL;
        request.MaximumLength = 0;
        request.BytesTransferred = 0xbadf00d;
        request.Operation = TFTP_RRQ;
        request.MemoryType = LoaderFirmwareTemporary;
#if defined(REMOTE_BOOT_SECURITY)
        request.SecurityHandle = TftpSecurityHandle;
#endif // defined(REMOTE_BOOT_SECURITY)
        request.ShowProgress = FALSE;

        ntStatus = TftpGetPut( &request );
        DPRINT( REAL_LOUD, ("NetOpen: TftpGetPut(get) status: %x, bytes: %x\n", ntStatus, request.BytesTransferred) );

        BlUsableBase = oldBase;
        BlUsableLimit = oldLimit;

        if ( !NT_SUCCESS(ntStatus) ) {
            if ( request.MemoryAddress != NULL ) {
                DPRINT( REAL_LOUD, ("NetOpen: freeing memory at 0x%08x, %d bytes\n",
                        request.MemoryAddress, request.MaximumLength) );
                BlFreeDescriptor( (ULONG)((ULONG_PTR)request.MemoryAddress >> PAGE_SHIFT ));
            }
            fileTableEntry->Flags.Open = 0; // Free entry we didn't use

            if ( ntStatus == STATUS_INSUFFICIENT_RESOURCES ) {
                return ENOMEM;
            }
            return EROFS;
        }

        fileTableEntry->u.NetFileContext.FileSize = request.BytesTransferred;
        fileTableEntry->u.NetFileContext.InMemoryCopy = request.MemoryAddress;

        //
        // We always cache the last file that was actually read from
        // the network.
        //

        strcpy(CachedFilePath, OpenPath);
        CachedFileDeviceId = fileTableEntry->DeviceId;
        CachedFileSize = request.BytesTransferred;
        CachedFileData = request.MemoryAddress;

    }

    fileTableEntry->Position.QuadPart = 0;

    fileTableEntry->Flags.Read = 1;

    return ESUCCESS;

} // NetOpen


ARC_STATUS
NetRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    )
{
    PBL_FILE_TABLE fileTableEntry;
    PNET_FILE_CONTEXT context;
    PUCHAR source;

    fileTableEntry = &BlFileTable[FileId];
    context = &fileTableEntry->u.NetFileContext;

    {
        source = context->InMemoryCopy + fileTableEntry->Position.LowPart;
        if ( (fileTableEntry->Position.LowPart + Length) > context->FileSize ) {
            Length = context->FileSize - fileTableEntry->Position.LowPart;
        }

        RtlCopyMemory( Buffer, source, Length );
        *Count = Length;

        fileTableEntry->Position.LowPart += Length;
    }

    DPRINT( REAL_LOUD, ("NetRead: id %d, length %d, count %d, new pos %x\n",
                    FileId, Length, *Count, fileTableEntry->Position.LowPart) );

    return ESUCCESS;

} // NetRead


ARC_STATUS
NetGetReadStatus (
    IN ULONG FileId
    )
{
    DPRINT( TRACE, ("NetGetReadStatus\n") );

    return ESUCCESS;

} // NetGetReadStatus


ARC_STATUS
NetSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    )
{
    PBL_FILE_TABLE fileTableEntry;
    LARGE_INTEGER newPosition;

    //DPRINT( TRACE, ("NetSeek\n") );

    fileTableEntry = &BlFileTable[FileId];

    {
        if ( SeekMode == SeekAbsolute ) {
            newPosition = *Offset;
        } else if ( SeekMode == SeekRelative ) {
            newPosition.QuadPart =
                fileTableEntry->Position.QuadPart + Offset->QuadPart;
        } else {
            return EROFS;
        }

        DPRINT( REAL_LOUD, ("NetSeek: id %d, mode %d, offset %x, new pos %x\n",
                        FileId, SeekMode, Offset->LowPart, newPosition.LowPart) );

        if ( newPosition.QuadPart > fileTableEntry->u.NetFileContext.FileSize ) {
            return EROFS;
        }

        fileTableEntry->Position = newPosition;
    }

    return ESUCCESS;

} // NetSeek


ARC_STATUS
NetWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    )
{
    DPRINT( TRACE, ("NetWrite\n") );

    return EROFS;

} // NetWrite


ARC_STATUS
NetGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    )
{
    PBL_FILE_TABLE fileTableEntry;
    //DPRINT( TRACE, ("NetGetFileInformation\n") );

    fileTableEntry = &BlFileTable[FileId];

    {
        Buffer->EndingAddress.QuadPart = fileTableEntry->u.NetFileContext.FileSize;
        Buffer->CurrentPosition.QuadPart = fileTableEntry->Position.QuadPart;
        DPRINT( REAL_LOUD, ("NetGetFileInformation returning size %x, position %x\n",
                Buffer->EndingAddress.LowPart, Buffer->CurrentPosition.LowPart) );

        return ESUCCESS;
    }

} // NetGetFileInformation


ARC_STATUS
NetSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )
{
    DPRINT( TRACE, ("NetSetFileInformation\n") );

    return EROFS;

} // NetSetFileInformation


ARC_STATUS
NetRename (
    IN ULONG FileId,
    IN CHAR * FIRMWARE_PTR NewFileName
    )
{
    DPRINT( TRACE, ("NetRename\n") );

    return EROFS;

} // NetRename


ARC_STATUS
NetGetDirectoryEntry (
    IN ULONG FileId,
    IN DIRECTORY_ENTRY * FIRMWARE_PTR DirEntry,
    IN ULONG NumberDir,
    OUT ULONG * FIRMWARE_PTR CountDir
    )
{
    DPRINT( TRACE, ("NetGetDirectoryEntry\n") );

    return EROFS;

} // NetGetDirectoryEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\peldrt.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    peldrt.c

Abstract:

    This module implements the code to load a PE format image into memory
    and relocate it if necessary.

Author:

    David N. Cutler (davec) 10-May-1991

Environment:

    Kernel mode only.

Revision History:

    Forrest Foltz (forrestf) 10-Jun-2000

        Broke out x86 32/64 code into this module

--*/

extern BOOLEAN BlBootingFromNet;

ARC_STATUS
BlLoadImageEx(
    IN ULONG DeviceId,
    IN TYPE_OF_MEMORY MemoryType,
    IN PCHAR LoadFile,
    IN USHORT ImageType,
    IN OPTIONAL ULONG PreferredAlignment,
    IN OPTIONAL ULONG PreferredBasePage,
    OUT PVOID *ImageBase
    )

/*++

Routine Description:

    This routine attempts to load the specified file from the specified
    device.

Arguments:

    DeviceId - Supplies the file table index of the device to load the
        specified image file from.

    MemoryType - Supplies the type of memory to to be assigned to the
        allocated memory descriptor.

    BootFile - Supplies a pointer to string descriptor for the name of
        the file to load.

    ImageType - Supplies the type of image that is expected.

    PreferredAlignment - If present, supplies the preferred image alignment.

    PreferredBasePage - If present, supplies the preferred base page which will
        override the image base address

    ImageBase - Supplies a pointer to a variable that receives the
        address of the image base.

Return Value:

    ESUCCESS is returned if the specified image file is loaded
    successfully. Otherwise, an unsuccessful status is returned
    that describes the reason for failure.

--*/

{

    ULONG ActualBase;
    ULONG BasePage;
    ULONG Count;
    ULONG FileId;
    ULONG_PTR NewImageBase;
    ULONG Index;
    UCHAR LocalBuffer[(SECTOR_SIZE * 2) + 256];
    PUCHAR LocalPointer;
    ULONG NumberOfSections;
    ULONG PageCount;
    USHORT MachineType;
    ARC_STATUS Status;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_SECTION_HEADER SectionHeader;
    LARGE_INTEGER SeekPosition;
    ULONG RelocSize;
    PIMAGE_BASE_RELOCATION RelocDirectory;
    ULONG RelocPage;
    ULONG RelocPageCount;
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;
    FILE_INFORMATION FileInfo;
    PUSHORT AdjustSum;
    USHORT PartialSum;
    ULONG CheckSum;
    ULONG VirtualSize;
    ULONG SizeOfRawData;
    BOOLEAN bCloseFile = FALSE;
    BOOLEAN bFreeCache = FALSE;
    IMAGE_PREFETCH_CACHE ImgCache = {0};

    if (PreferredAlignment == 0) {
        PreferredAlignment = 1;
    }
    //
    // Align the buffer on a Dcache fill boundary.
    //

    LocalPointer = ALIGN_BUFFER(LocalBuffer);

    //
    // Attempt to open the image file.
    //

    Status = BlOpen(DeviceId, LoadFile, ArcOpenReadOnly, &FileId);
    if (Status != ESUCCESS) {
        goto cleanup;
    }
    bCloseFile = TRUE;

    //
    // Try to prefetch the whole file into a prefetch buffer. The file
    // must have been opened read-only and must not be modified until
    // the cache is freed by the BlImageFreeCache call. The file position
    // of FileId is reset to the beginning of the file.
    //

    if ((BlBootingFromNet) || (BlImageInitCache(&ImgCache, FileId) != ESUCCESS) ) {
        //
        // Make sure file position is at the beginning of the file.
        // BlImageInitCache leaves file position undefined under failure.
        //

        SeekPosition.QuadPart = 0;
        Status = BlSeek(FileId, &SeekPosition, SeekAbsolute);
        if (Status != ESUCCESS) {
            goto cleanup;
        }
    } else {
        //
        // We got a cache. Make a note to free it.
        //

        bFreeCache = TRUE;
    }

    //
    // Read the first two sectors of the image header from the file.
    //

    Status = BlImageRead(&ImgCache, FileId, LocalPointer, SECTOR_SIZE * 2, &Count);
    if (Status != ESUCCESS) {
        goto cleanup;
    }

    //
    // If the image file is not the specified type, is not executable, or is
    // not a NT image, then return bad image type status.
    //

    NtHeaders = RtlImageNtHeader(LocalPointer);
    if (NtHeaders == NULL) {
        Status = EBADF;
        goto cleanup;
    }

    MachineType = NtHeaders->FileHeader.Machine;
    if ((MachineType != ImageType) ||
        ((NtHeaders->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0)) {
        Status = EBADF;
        goto cleanup;
    }

    //
    // Compute the starting page and the number of pages that are consumed
    // by the entire image, and then allocate a memory descriptor for the
    // allocated region.
    //

    NumberOfSections = NtHeaders->FileHeader.NumberOfSections;
    SectionHeader = IMAGE_FIRST_SECTION( NtHeaders );

    //
    // If a preferred alignment was specified or the image is not located in KSEG0,
    // then don't bother trying to put it at its specified image base.
    //
    if (PreferredBasePage != 0) {
        BasePage = PreferredBasePage;
    } else if ((PreferredAlignment != 1) ||
               ((NtHeaders->OptionalHeader.ImageBase & KSEG0_BASE) == 0)) {
        BasePage = 0;
    } else {
        BasePage = (ULONG)((NtHeaders->OptionalHeader.ImageBase & 0x1fffffff) >> PAGE_SHIFT);
    }
    if (strcmp((PCHAR)&SectionHeader[NumberOfSections - 1].Name, ".debug") == 0) {
        NumberOfSections -= 1;
        PageCount = (NtHeaders->OptionalHeader.SizeOfImage -
            SectionHeader[NumberOfSections].SizeOfRawData + PAGE_SIZE - 1) >> PAGE_SHIFT;

    } else {
        PageCount =
         (NtHeaders->OptionalHeader.SizeOfImage + PAGE_SIZE - 1) >> PAGE_SHIFT;
    }

    //
    // If we fail to allocate memory descriptor here, we will try again
    // below after freeing the cache if we have one.
    //

    Status = BlAllocateAlignedDescriptor(MemoryType,
                                         BasePage,
                                         PageCount,
                                         PreferredAlignment,
                                         &ActualBase);

    if (Status != ESUCCESS) {

        //
        // Free the memory we have allocated for caching the image and
        // try again.
        //

        if (bFreeCache) {
            BlImageFreeCache(&ImgCache, FileId);
            bFreeCache = FALSE;

            Status = BlAllocateDescriptor(MemoryType,
                                          BasePage,
                                          PageCount,
                                          &ActualBase);
        }

        //
        // Check to see if we were able to allocate memory after freeing
        // cache if we had one.
        //

        if (Status != ESUCCESS) {
            Status = ENOMEM;
            goto cleanup;
        }
    }

    //
    // Compute the address of the file header.
    //

    NewImageBase = KSEG0_BASE | (ActualBase << PAGE_SHIFT);

    //
    // Read the entire image header from the file.
    //

    SeekPosition.QuadPart = 0;
    Status = BlImageSeek(&ImgCache, FileId, &SeekPosition, SeekAbsolute);
    if (Status != ESUCCESS) {
        goto cleanup;
    }

    Status = BlImageRead(&ImgCache,
                         FileId,
                         (PVOID)NewImageBase,
                         NtHeaders->OptionalHeader.SizeOfHeaders,
                         &Count);

    if (Status != ESUCCESS) {
        goto cleanup;
        BlClose(FileId);
        return Status;
    }

    NtHeaders = RtlImageNtHeader((PVOID)NewImageBase);

    //
    // Compute the address of the section headers, set the image base address.
    //

    SectionHeader = IMAGE_FIRST_SECTION(NtHeaders);

    //
    // Compute the check sum on the image.
    //

    PartialSum = ChkSum(0,
                        (PVOID)NewImageBase,
                        NtHeaders->OptionalHeader.SizeOfHeaders / sizeof(USHORT));

    //
    // Scan through the sections and either read them into memory or clear
    // the memory as appropriate.
    //

    for (Index = 0; Index < NumberOfSections; Index += 1) {
        VirtualSize = SectionHeader->Misc.VirtualSize;
        SizeOfRawData = SectionHeader->SizeOfRawData;
        VirtualSize = (VirtualSize + 1) & ~1;
        SizeOfRawData = (SizeOfRawData + 1) & ~1;
        if (VirtualSize == 0) {
            VirtualSize = SizeOfRawData;
        }

        //
        // Compute the size of the raw data.
        //
        // N.B. The size ofthe raw data can be non-zero even when the pointer
        //      to the raw data is zero. The size of the raw data can also be
        //      larger than the virtual size.
        //

        if (SectionHeader->PointerToRawData == 0) {
            SizeOfRawData = 0;

        } else if (SizeOfRawData > VirtualSize) {
            SizeOfRawData = VirtualSize;
        }

        //
        // If the size of the raw data is not zero, then load the raw data
        // into memory.
        //

        if (SizeOfRawData != 0) {
            SeekPosition.LowPart = SectionHeader->PointerToRawData;
            Status = BlImageSeek(&ImgCache,
                                 FileId,
                                 &SeekPosition,
                                 SeekAbsolute);

            if (Status != ESUCCESS) {
                break;
            }

            Status = BlImageRead(&ImgCache,
                                 FileId,
                                 (PVOID)(SectionHeader->VirtualAddress + NewImageBase),
                                 SizeOfRawData,
                                 &Count);

            if (Status != ESUCCESS) {
                break;
            }

            //
            // Remember how far we have read.
            //

            RelocSize = SectionHeader->PointerToRawData + SizeOfRawData;

            //
            // Compute the check sum on the section.
            //

            PartialSum = ChkSum(PartialSum,
                                (PVOID)(SectionHeader->VirtualAddress + NewImageBase),
                                SizeOfRawData / sizeof(USHORT));
        }

        //
        // If the size of the raw data is less than the virtual size, then zero
        // the remaining memory.
        //

        if (SizeOfRawData < VirtualSize) {
            RtlZeroMemory((PVOID)(KSEG0_BASE | SectionHeader->VirtualAddress + NewImageBase + SizeOfRawData),
                          VirtualSize - SizeOfRawData);

        }

        SectionHeader += 1;
    }

    //
    // Only do the check sum if the image loaded properly and is stripped.
    //

    if ((Status == ESUCCESS) &&
        (NtHeaders->FileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED)) {

        //
        // Get the length of the file for check sum validation.
        //

        Status = BlGetFileInformation(FileId, &FileInfo);
        if (Status != ESUCCESS) {

            //
            // Set the length to current end of file.
            //

            Count = RelocSize;
            FileInfo.EndingAddress.LowPart = RelocSize;

        } else {
            Count = FileInfo.EndingAddress.LowPart;
        }

        Count -= RelocSize;
        while (Count != 0) {
            ULONG Length;

            //
            // Read in the rest of the image and check sum it.
            //

            Length = Count < SECTOR_SIZE * 2 ? Count : SECTOR_SIZE * 2;
            if (BlImageRead(&ImgCache, FileId, LocalBuffer, Length, &Length) != ESUCCESS) {
                break;
            }

            if (Length == 0) {
                break;

            }

            PartialSum = ChkSum(PartialSum, (PUSHORT) LocalBuffer, Length / 2);
            Count -= Length;
        }


        AdjustSum = (PUSHORT)(&NtHeaders->OptionalHeader.CheckSum);
        PartialSum -= (PartialSum < AdjustSum[0]);
        PartialSum -= AdjustSum[0];
        PartialSum -= (PartialSum < AdjustSum[1]);
        PartialSum -= AdjustSum[1];
        CheckSum = (ULONG)PartialSum + FileInfo.EndingAddress.LowPart;

        if (CheckSum != NtHeaders->OptionalHeader.CheckSum) {
            Status = EBADF;
        }
    }

    //
    // If the specified image was successfully loaded, then perform image
    // relocation if necessary.
    //

    if (Status == ESUCCESS) {

        //
        // If a virtual bias is specified, then attempt to relocate the
        // image to its biased address. If the image cannot be relocated,
        // then turn off the virtual bias, and attempt to relocate the
        // image again as its allocated base. Otherwise, just attempt to
        // relocate the image to its allocated base.
        //
        // N.B. The loaded image is double mapped at the biased address.
        //
        // N.B. It is assumed that the only possibly nonrelocatable image
        //      is the kernel image which is the first image that is loaded.
        //      Therefore, if a biased address is specified and the kernel
        //      cannot be relocated, then the biased loading of the kernel
        //      image is turned off.
        //

        if (BlVirtualBias != 0) {
            Status = LdrRelocateImage((PVOID)(NewImageBase + BlVirtualBias),
                                                  "OS Loader",
                                                  ESUCCESS,
                                                  0xffff0000 + EBADF,
                                                  EBADF);

            if (Status == (0xffff0000 + EBADF)) {
               BlVirtualBias = 0;
               if (NewImageBase != NtHeaders->OptionalHeader.ImageBase) {
                   Status = (ARC_STATUS)LdrRelocateImage((PVOID)NewImageBase,
                                                         "OS Loader",
                                                         ESUCCESS,
                                                         EBADF,
                                                         EBADF);
               } else {
                  Status = ESUCCESS;
               }

            }

        } else {
            if (NewImageBase != NtHeaders->OptionalHeader.ImageBase) {
                Status = (ARC_STATUS)LdrRelocateImage((PVOID)NewImageBase,
                                                      "OS Loader",
                                                      ESUCCESS,
                                                      EBADF,
                                                      EBADF);
            }
        }

        *ImageBase = (PVOID)(NewImageBase + BlVirtualBias);

        if(BdDebuggerEnabled) {
            DbgPrint("BD: %s base address %p\n", LoadFile, *ImageBase);
            {
                STRING string;

                RtlInitString(&string, LoadFile);
                DbgLoadImageSymbols(&string, *ImageBase, (ULONG_PTR)-1);
            }
        }
    }

#if 0

    //
    // Mark the pages from the relocation information to the end of the
    // image as MemoryFree and adjust the size of the image so table
    // based structured exception handling will work properly.
    //
    // Relocation sections are no longer deleted here because memory
    // management will be relocating them again in Phase 0.
    //

    RelocDirectory = (PIMAGE_BASE_RELOCATION)
        RtlImageDirectoryEntryToData((PVOID)NewImageBase,
                                     TRUE,
                                     IMAGE_DIRECTORY_ENTRY_BASERELOC,
                                     &RelocSize );

    if (RelocDirectory != NULL) {
        RelocPage = (ULONG)(((ULONG_PTR)RelocDirectory + PAGE_SIZE - 1) >> PAGE_SHIFT);
        RelocPage &= ~(KSEG0_BASE >> PAGE_SHIFT);
        MemoryDescriptor = BlFindMemoryDescriptor(RelocPage);
        if ((MemoryDescriptor != NULL) && (RelocPage < (ActualBase + PageCount))) {
            RelocPageCount = MemoryDescriptor->PageCount +
                             MemoryDescriptor->BasePage  -
                             RelocPage;

            NtHeaders->OptionalHeader.SizeOfImage =
                                        (RelocPage - ActualBase) << PAGE_SHIFT;

            BlGenerateDescriptor(MemoryDescriptor,
                                 MemoryFree,
                                 RelocPage,
                                 RelocPageCount );
        }
    }

#endif

#if defined(_GAMBIT_)
    {
        SSC_IMAGE_INFO ImageInfo;

        ImageInfo.LoadBase = *ImageBase;
        ImageInfo.ImageSize = NtHeaders->OptionalHeader.SizeOfImage;
        ImageInfo.ImageType = NtHeaders->FileHeader.Machine;
        ImageInfo.ProcessID.QuadPart = 0;
        ImageInfo.LoadCount = 1;

        if (memcmp(LoadFile, "\\ntdetect.exe", 13) != 0) {
            SscLoadImage64( LoadFile,
                            &ImageInfo );
        }
    }
#endif // _GAMBIT_

cleanup:

    if (bFreeCache) {
        BlImageFreeCache(&ImgCache, FileId);
    }

    if (bCloseFile) {
        BlClose(FileId);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\peldr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    peldr.c

Abstract:

    This module implements the code to load a PE format image into memory
    and relocate it if necessary.

Author:

    David N. Cutler (davec) 10-May-1991

Environment:

    Kernel mode only.

Revision History:

--*/

#include "bldr.h"
#include "string.h"
#include "ntimage.h"

#if defined(_GAMBIT_)
#include "ssc.h"
#endif // defined(_GAMBIT_)

//
// Define image prefetch cache structure used in BlLoadImage. Images
// are read as a whole into an allocated buffer and read requests in
// BlLoadImage are satisfied by copying from this buffer if the
// prefetch is successful. I chose to read the whole file in at once
// to simplify code but it limits [although not in practice] the size of
// files that can be prefetched this way, as opposed to prefetching chunks
// of the file at a time.
//

typedef struct _IMAGE_PREFETCH_CACHE {
    ULONG FileId;               // FileId that has been prefetched.
    LARGE_INTEGER Position;     // Current position in the file.
    ULONG ValidDataLength;      // Length of data that was prefetched.
    PUCHAR Data;                // Pointer to cached data.
} IMAGE_PREFETCH_CACHE, *PIMAGE_PREFETCH_CACHE;

//
// The next two defines are used in allocating memory for the image
// cache to direct the allocator into using memory above 1MB and to make
// the allocated memory 64KB aligned. They are in terms of number of pages.
//

#define BL_IMAGE_ABOVE_1MB        (0x200000 >> PAGE_SHIFT)
#define BL_IMAGE_64KB_ALIGNED     (0x10000 >> PAGE_SHIFT)

//
// Define forward referenced prototypes.
//

USHORT
ChkSum(
    ULONG PartialSum,
    PUSHORT Source,
    ULONG Length
    );

ARC_STATUS
BlImageInitCache(
    IN PIMAGE_PREFETCH_CACHE pCache,
    ULONG FileId
    );

ARC_STATUS
BlImageRead(
    IN PIMAGE_PREFETCH_CACHE pCache,
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG pCount
    );

ARC_STATUS
BlImageSeek(
    IN PIMAGE_PREFETCH_CACHE pCache,
    IN ULONG FileId,
    IN PLARGE_INTEGER pOffset,
    IN SEEK_MODE SeekMode
    );

VOID
BlImageFreeCache(
    IN PIMAGE_PREFETCH_CACHE pCache,
    ULONG FileId
    );

#include "peldrt.c"

ARC_STATUS
BlImageInitCache(
    IN PIMAGE_PREFETCH_CACHE pCache,
    ULONG FileId
    )

/*++

Routine Description:

    Attempt to allocate memory and prefetch a file. Setup pCache
    structure so it can be passed to BlImageRead/Seek to either copy
    from the cache if prefetch was successful or read from the disk as
    normal. The file must be opened read only and should not be closed
    or modified before calling BlImageFreeCache. The file position of
    FileId is reset to the beginning of the file on success, and is
    undefined on failure. pCache is always setup so it can be used in
    BlImage* I/O functions. If the file could not be prefetched, the
    cache's ValidDataLength will be set to 0 and the I/O functions
    will simply call the Bl* I/O functions [e.g. BlImageRead calls
    BlRead]. Note that the whole file is prefetched at once and this
    puts a limit on the size of files that can be prefetched via this
    cache since boot loader memory is limited. This limit is not hit
    in practice though.

Arguments:

    pCache - Cache structure to setup.

    FileId - File to prefetch.

Return Value:

    ESUCCESS if everything was successful .
    Appropriate ARC_STATUS if there was a problem.

--*/

{
    ARC_STATUS Status = ESUCCESS;
    FILE_INFORMATION FileInfo;
    ULONG FileSize;
    ULONG ActualBase;
    ULONG_PTR NewImageBase;
    PVOID CacheBufBase = NULL;
    ULONG ReadCount;
    LARGE_INTEGER SeekPosition;
    ALLOCATION_POLICY OldPolicy;

    //
    // Initialize fields of the cache structure.
    //

    pCache->Data = 0;
    pCache->ValidDataLength = 0;
    pCache->Position.QuadPart = 0;
    pCache->FileId = FileId;

    //
    // Get file size.
    //

    Status = BlGetFileInformation(FileId, &FileInfo);

    if (Status != ESUCCESS) {
        goto cleanup;
    }

    //
    // Check if file is too big. File size is at
    // FileInfo.EndingAddress.
    //

    if (FileInfo.EndingAddress.HighPart != 0) {
        Status = E2BIG;
        goto cleanup;
    }

    FileSize = FileInfo.EndingAddress.LowPart;

    //
    // Allocate memory for the cache. In order to avoid fragmenting memory
    // terribly, temporarily change the allocation policy to HighestFit. This
    // causes the drivers to get loaded from the bottom up, while the cache
    // is always at the top of free memory.
    //

    Status = BlAllocateAlignedDescriptor(LoaderFirmwareTemporary,
                                         0,
                                         (FileSize >> PAGE_SHIFT) + 1,
                                         BL_IMAGE_64KB_ALIGNED,
                                         &ActualBase);

    if (Status != ESUCCESS) {
        Status = ENOMEM;
        goto cleanup;
    }

    CacheBufBase = (PVOID) (KSEG0_BASE | (ActualBase << PAGE_SHIFT));

    //
    // Read the file into the prefetch buffer.
    //

    SeekPosition.QuadPart = 0;
    Status = BlSeek(FileId, &SeekPosition, SeekAbsolute);
    if (Status != ESUCCESS) {
        goto cleanup;
    }

    Status = BlRead(FileId, CacheBufBase, FileSize, &ReadCount);
    if (Status != ESUCCESS) {
        goto cleanup;
    }

    if (ReadCount != FileSize) {
        Status = EIO;
        goto cleanup;
    }

    //
    // Reset file position back to beginning.
    //

    SeekPosition.QuadPart = 0;
    Status = BlSeek(FileId, &SeekPosition, SeekAbsolute);
    if (Status != ESUCCESS) {
        goto cleanup;
    }

    //
    // The file was successfully prefetched.
    //

    pCache->Data = CacheBufBase;
    CacheBufBase = NULL;
    pCache->ValidDataLength = FileSize;

 cleanup:
    if (CacheBufBase != NULL) {
        BlFreeDescriptor(ActualBase);
    }

    return Status;
}

ARC_STATUS
BlImageRead(
    IN PIMAGE_PREFETCH_CACHE pCache,
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG pCount
    )

/*++

Routine Description:

    A wrapper for BlRead. Checks to see if the request can be
    satisfied from pCache first. If not calls BlRead.

Arguments:

    pCache - Prefetch Cache for FileId

    FileId, Buffer, Length, Count - BlRead parameters

Return Value:

    Status that would be returned by BlRead.

--*/

{
    ARC_STATUS Status;
    LONG AdjustedLength;

    //
    // If the cache buffer does not exist or the cached size is 0,
    // hand over the call to BlRead.
    //

    if (!pCache->Data || !pCache->ValidDataLength) {
        return BlRead(FileId, Buffer, Length, pCount);
    }

    //
    // Clear read bytes count.
    //

    *pCount = 0;

    //
    // Determine how many bytes we can copy from our current position till
    // EOF, if there is not Length bytes.
    //

    AdjustedLength = (LONG)pCache->ValidDataLength - (LONG)pCache->Position.LowPart;
    if (AdjustedLength < 0) {
        AdjustedLength = 0;
    }
    AdjustedLength = ((ULONG)AdjustedLength < Length) ? AdjustedLength : Length;

    //
    // Copy AdjustedLength bytes into target buffer and advance the file position.
    //

    RtlCopyMemory(Buffer, pCache->Data + pCache->Position.LowPart, AdjustedLength);
    pCache->Position.LowPart += AdjustedLength;

    //
    // Update number of bytes read.
    //

    *pCount = AdjustedLength;

    return ESUCCESS;
}

ARC_STATUS
BlImageSeek(
    IN PIMAGE_PREFETCH_CACHE pCache,
    IN ULONG FileId,
    IN PLARGE_INTEGER pOffset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    A wrapper for BlSeek. Calls BlSeek and if successful, updates the
    position in the cache structure as well. We call BlSeek to update
    the file position as well because at any time the cache may be
    freed or invalidated and we have to be able to continue calling on
    Bl* I/O functions transparently.

Arguments:

    pCache - Prefetch Cache for FileId.

    FileId, Offset, SeekMode - BlSeek parameters.

Return Value:

    Status that would be returned by BlSeek.

--*/

{
    ARC_STATUS Status;

    //
    // Do not allow setting position to too big. We do not open such
    // files anyway and the boot loader file systems and other places
    // in the boot loader I/O system do not handle it.
    //

    if (pOffset->HighPart != 0) {
        return E2BIG;
    }

    //
    // Try to update file position.
    //

    Status = BlSeek(FileId, pOffset, SeekMode);

    if (Status != ESUCCESS) {
        return Status;
    }

    //
    // Update the position in cached buffer. We don't perform
    // checks since BlSeek accepted the new offset.
    //

    pCache->Position.QuadPart = pOffset->QuadPart;

    return Status;
}

VOID
BlImageFreeCache(
    IN PIMAGE_PREFETCH_CACHE pCache,
    ULONG FileId
    )

/*++

Routine Description:

    Free the memory allocated for the prefetch cache for FileId in
    pCache. Sets ValidDataLength to 0 to stop caching.

Arguments:

    pCache - Cache structure to setup

    FileId - File that was opened read-only to be cached.

Return Value:

    None.

--*/

{
    ULONG DescBase;

    //
    // NOTE: ValidDataLength may be zero, but we still allocate at least
    // a page and we have to free that.
    //

    if (pCache->Data) {
        DescBase = (ULONG)((ULONG_PTR)pCache->Data & (~KSEG0_BASE));
        BlFreeDescriptor(DescBase >> PAGE_SHIFT);
        pCache->Data = NULL;
    }

    pCache->ValidDataLength = 0;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\parseini.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    parseini.c

Abstract:

    This module implements functions to parse a .INI file

Author:

    John Vert (jvert) 7-Oct-1993

Revision History:

    John Vert (jvert) 7-Oct-1993 - largely lifted from splib\spinf.c

--*/

#include "parseini.h"
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

#define SpFree(x)

// what follows was alpar.h

//
//   EXPORTED BY THE PARSER AND USED BY BOTH THE PARSER AND
//   THE INF HANDLING COMPONENTS
//

// typedefs exported
//

typedef struct _value {
    struct _value *pNext;
    PCHAR  pName;
#ifdef UNICODE
    PWCHAR  pNameW;
#endif
    } VALUE, *PVALUE;

#define NUMBER_OF_INTERNAL_VALUES 10

typedef struct _line {
    struct _line *pNext;
    PCHAR   pName;
    PCHAR   InternalValues[NUMBER_OF_INTERNAL_VALUES];
#ifdef  UNICODE
    PWCHAR  pNameW;
    PWCHAR  InternalValuesW[NUMBER_OF_INTERNAL_VALUES];
#endif
    PVALUE  pFirstExternalValue;
    } LINE, *PLINE;

typedef struct _section {
    struct _section *pNext;
    PCHAR    pName;
#ifdef UNICODE
    PWCHAR   pNameW;
#endif
    PLINE    pLine;
    } SECTION, *PSECTION;

typedef struct _inf {
    PSECTION pSection;
    } INF, *PINF;

//
// Routines exported
//

PVOID
ParseInfBuffer(
    PCHAR INFFile,
    PCHAR Buffer,
    ULONG Size,
    PULONG ErrorLine
    );

//
// DEFINES USED FOR THE PARSER INTERNALLY
//
//
// typedefs used
//

typedef enum _tokentype {
    TOK_EOF,
    TOK_EOL,
    TOK_LBRACE,
    TOK_RBRACE,
    TOK_STRING,
    TOK_EQUAL,
    TOK_COMMA,
    TOK_ERRPARSE,
    TOK_ERRNOMEM
    } TOKENTYPE, *PTOKENTTYPE;


typedef struct _token {
    TOKENTYPE Type;
    PCHAR     pValue;
    } TOKEN, *PTOKEN;


//
// Routine defines
//

ARC_STATUS
SpAppendSection(
    IN PCHAR pSectionName
#ifdef UNICODE 
    , IN PWCHAR pSectionNameW
#endif
    );

ARC_STATUS
SpAppendLine(
    IN PCHAR pLineKey
#ifdef UNICODE 
    , IN PWCHAR pLineKeyW
#endif
    );

ARC_STATUS
SpAppendValue(
    IN PCHAR pValueString
#ifdef UNICODE 
    , IN PWCHAR pValueStringW
#endif
    );

TOKEN
SpGetToken(
    IN OUT PCHAR *Stream,
    IN PCHAR     MaxStream
    );

// Global added to provide INF filename for friendly error messages.
PCHAR pchINFName = NULL;

// what follows was alinf.c

//
// Internal Routine Declarations for freeing inf structure members
//

VOID
FreeSectionList (
   IN PSECTION pSection
   );

VOID
FreeLineList (
   IN PLINE pLine
   );

VOID
FreeValueList (
   IN PVALUE pValue
   );


//
// Internal Routine declarations for searching in the INF structures
//


PCHAR
SearchValueInLine(
   IN PLINE pLine,
   IN ULONG ValueIndex
   );

PLINE
SearchLineInSectionByKey(
   IN  PSECTION pSection,
   IN  PCHAR    Key,
   OUT PULONG   pOrdinal    OPTIONAL
   );

PLINE
SearchLineInSectionByIndex(
   IN PSECTION pSection,
   IN ULONG    LineIndex
   );

PSECTION
SearchSectionByName(
   IN PINF  pINF,
   IN PCHAR SectionName
   );

PCHAR
ProcessForStringSubs(
    IN PINF  pInf,
    IN PCHAR String
    );

#ifdef UNICODE
PWCHAR
SearchValueInLineW(
   IN PLINE pLine,
   IN ULONG ValueIndex
   );

PWCHAR
ProcessForStringSubsW(
    IN PINF  pInf,
    IN PWCHAR String
    );
#endif


//
// ROUTINE DEFINITIONS
//


PCHAR
SlGetIniValue(
    IN PVOID InfHandle,
    IN PCHAR SectionName,
    IN PCHAR KeyName,
    IN PCHAR Default
    )

/*++

Routine Description:

    Searches an INF handle for a given section/key value.

Arguments:

    InfHandle - Supplies a handle returned by SlInitIniFile.

    SectionName - Supplies the name of the section to search

    KeyName - Supplies the name of the key whose value should be returned.

    Default - Supplies the default setting, returned if the specified key
            is not found.

Return Value:

    Pointer to the value of the key, if the key is found

    Default, if the key is not found.

--*/

{
    PCHAR Value;

    Value = SlGetSectionKeyIndex(InfHandle,
                                 SectionName,
                                 KeyName,
                                 0);
    if (Value==NULL) {
        Value = Default;
    }

    return(Value);

}

#ifdef UNICODE

PWCHAR
SlGetIniValueW(
    IN PVOID InfHandle,
    IN PCHAR SectionName,
    IN PCHAR KeyName,
    IN PWCHAR Default
    )

/*++

Routine Description:

    Searches an INF handle for a given section/key value.

Arguments:

    InfHandle - Supplies a handle returned by SlInitIniFile.

    SectionName - Supplies the name of the section to search

    KeyName - Supplies the name of the key whose value should be returned.

    Default - Supplies the default setting, returned if the specified key
            is not found.

Return Value:

    Pointer to the value of the key, if the key is found

    Default, if the key is not found.

--*/

{
    PWCHAR Value;

    Value = SlGetSectionKeyIndexW(InfHandle,
                                  SectionName,
                                  KeyName,
                                  0);
    if (Value==NULL) {
        Value = Default;
    }

    return(Value);

}
#endif

//
// returns a handle to use for further inf parsing
//

ARC_STATUS
SlInitIniFile(
   IN  PCHAR   DevicePath,
   IN  ULONG   DeviceId,
   IN  PCHAR   INFFile,
   OUT PVOID  *pINFHandle,
   OUT PVOID  *pINFBuffer OPTIONAL,
   OUT PULONG  INFBufferSize OPTIONAL,
   OUT PULONG  ErrorLine
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    ARC_STATUS Status;
    ULONG      DeviceID,FileID;
    PCHAR      Buffer;
    ULONG      Size, SizeRead;
    FILE_INFORMATION FileInfo;
    ULONG       PageCount;
    ULONG       ActualBase;

    *ErrorLine = (ULONG)(-1);

    //
    // If required, open the device
    //

    if(DevicePath) {
        Status = ArcOpen(DevicePath,ArcOpenReadOnly,&DeviceID);
        if (Status != ESUCCESS) {
            return( Status );
        }
    } else {
        DeviceID = DeviceId;
    }

    //
    // Open the file
    //

    Status = BlOpen(DeviceID,INFFile,ArcOpenReadOnly,&FileID);
    if (Status != ESUCCESS) {
        // We report better error messages elsewhere
        // SlMessageBox(SL_FILE_LOAD_FAILED,INFFile,Status);
        pchINFName = NULL;
        goto xx0;
    } else {
        pchINFName = INFFile;
    }

    //
    // find out size of INF file
    //

    Status = BlGetFileInformation(FileID, &FileInfo);
    if (Status != ESUCCESS) {
        BlClose(FileID);
        goto xx0;
    }
    Size = FileInfo.EndingAddress.LowPart;

    //
    // Allocate a descriptor large enough to hold the entire file.
    // On x86 this has an unfortunate tendency to slam txtsetup.sif
    // into a free block at 1MB, which means the kernel can't be
    // loaded (it's linked for 0x100000 without relocations).
    // On x86 this has an unfortunate tendency to slam txtsetup.sif
    // into a free block at 1MB, which means the kernel can't be
    // loaded (it's linked for 0x100000 without relocations).
    //
    // (tedm) we're also seeing a similar problem on alphas now
    // because txtsetup.sif has grown too large, so this code has been
    // made non-conditional.
    //
    {

        PageCount = (ULONG)(ROUND_TO_PAGES(Size) >> PAGE_SHIFT);

        Status = BlAllocateDescriptor(LoaderOsloaderHeap,
                                      0,
                                      PageCount,
                                      &ActualBase);

    }

    if (Status != ESUCCESS) {
        BlClose(FileID);
        goto xx0;
    }

    Buffer = (PCHAR)(KSEG0_BASE | (ActualBase << PAGE_SHIFT));

    //
    // read the file in
    //

    Status = BlRead(FileID, Buffer, Size, &SizeRead);
    if (Status != ESUCCESS) {
        BlClose(FileID);
        goto xx0;
    }

    if ( pINFBuffer != NULL ) {
        *pINFBuffer = Buffer;
        *INFBufferSize = SizeRead;
    }

    //
    // parse the file
    //
    if((*pINFHandle = ParseInfBuffer(INFFile, Buffer, SizeRead, ErrorLine)) == (PVOID)NULL) {
        Status = EBADF;
    } else {
        Status = ESUCCESS;
    }

    //
    // Clean up and return
    //
    BlClose(FileID);

    xx0:

    if(DevicePath) {
        ArcClose(DeviceID);
    }

    return( Status );

}

//
// frees an INF Buffer
//
ARC_STATUS
SpFreeINFBuffer (
   IN PVOID INFHandle
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PINF       pINF;

   //
   // Valid INF Handle?
   //

   if (INFHandle == (PVOID)NULL) {
       return ESUCCESS;
   }

   //
   // cast the buffer into an INF structure
   //

   pINF = (PINF)INFHandle;

   FreeSectionList(pINF->pSection);

   //
   // free the inf structure too
   //

   SpFree(pINF);

   return( ESUCCESS );
}


VOID
FreeSectionList (
   IN PSECTION pSection
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PSECTION Next;

    while(pSection) {
        Next = pSection->pNext;
        FreeLineList(pSection->pLine);
        if(pSection->pName) {
            SpFree(pSection->pName);
        }
#ifdef UNICODE
        if(pSection->pNameW) {
            SpFree(pSection->pNameW);
        }
#endif
        SpFree(pSection);
        pSection = Next;
    }
}


VOID
FreeLineList (
   IN PLINE pLine
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PLINE Next;

    while(pLine) {
        Next = pLine->pNext;
        FreeValueList(pLine->pFirstExternalValue);
        if(pLine->pName) {
            SpFree(pLine->pName);
        }
#ifdef UNICODE
        if(pLine->pNameW) {
            SpFree(pLine->pNameW);
        }
#endif
        SpFree(pLine);
        pLine = Next;
    }
}

VOID
FreeValueList (
   IN PVALUE pValue
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PVALUE Next;

    while(pValue) {
        Next = pValue->pNext;
        if(pValue->pName) {
            SpFree(pValue->pName);
        }
#ifdef UNICODE
        if(pValue->pNameW) {
            SpFree(pValue->pNameW);
        }
#endif
        SpFree(pValue);
        pValue = Next;
    }
}


//
// searches for the existance of a particular section
//
BOOLEAN
SpSearchINFSection (
   IN PVOID INFHandle,
   IN PCHAR SectionName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;

   //
   // if search for section fails return false
   //

   if ((pSection = SearchSectionByName(
                       (PINF)INFHandle,
                       SectionName
                       )) == (PSECTION)NULL) {
       return( FALSE );
   }

   //
   // else return true
   //
   return( TRUE );

}




//
// given section name, line number and index return the value.
//
PCHAR
SlGetSectionLineIndex (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN ULONG LineIndex,
   IN ULONG ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PCHAR    pName;

   if((pSection = SearchSectionByName(
                      (PINF)INFHandle,
                      SectionName
                      ))
                      == (PSECTION)NULL)
       return((PCHAR)NULL);

   if((pLine = SearchLineInSectionByIndex(
                      pSection,
                      LineIndex
                      ))
                      == (PLINE)NULL)
       return((PCHAR)NULL);

   if((pName = SearchValueInLine(
                      pLine,
                      ValueIndex
                      ))
                      == (PCHAR)NULL)
       return((PCHAR)NULL);

   return(ProcessForStringSubs(INFHandle,pName));

}


#ifdef UNICODE
//
// given section name, line number and index return the value.
//
PWCHAR
SlGetSectionLineIndexW (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN ULONG LineIndex,
   IN ULONG ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PWCHAR    pName;

   if((pSection = SearchSectionByName(
                      (PINF)INFHandle,
                      SectionName
                      ))
                      == (PSECTION)NULL)
       return((PWCHAR)NULL);

   if((pLine = SearchLineInSectionByIndex(
                      pSection,
                      LineIndex
                      ))
                      == (PLINE)NULL)
       return((PWCHAR)NULL);

   if((pName = SearchValueInLineW(
                      pLine,
                      ValueIndex
                      ))
                      == (PWCHAR)NULL)
       return((PWCHAR)NULL);

   return(ProcessForStringSubsW(INFHandle,pName));

}
#endif


BOOLEAN
SpGetSectionKeyExists (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN PCHAR Key
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;

   if((pSection = SearchSectionByName(
                      (PINF)INFHandle,
                      SectionName
                      ))
              == (PSECTION)NULL) {
       return( FALSE );
   }

   if (SearchLineInSectionByKey(pSection, Key, NULL) == (PLINE)NULL) {
       return( FALSE );
   }

   return( TRUE );
}


PCHAR
SlGetKeyName(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    )
{
    PSECTION pSection;
    PLINE    pLine;

    pSection = SearchSectionByName((PINF)INFHandle,SectionName);
    if(pSection == NULL) {
        return(NULL);
    }

    pLine = SearchLineInSectionByIndex(pSection,LineIndex);
    if(pLine == NULL) {
        return(NULL);
    }

    return(pLine->pName);
}

#ifdef UNICODE
PWCHAR
SlGetKeyNameW(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    )
{
    PSECTION pSection;
    PLINE    pLine;

    pSection = SearchSectionByName((PINF)INFHandle,SectionName);
    if(pSection == NULL) {
        return(NULL);
    }

    pLine = SearchLineInSectionByIndex(pSection,LineIndex);
    if(pLine == NULL) {
        return(NULL);
    }

    return(pLine->pNameW);
}
#endif


//
// given section name and key, return (0-based) ordinal for this entry
// (returns -1 on error)
//
ULONG
SlGetSectionKeyOrdinal(
    IN  PVOID INFHandle,
    IN  PCHAR SectionName,
    IN  PCHAR Key
    )
{
    PSECTION pSection;
    PLINE    pLine;
    ULONG    Ordinal;


    pSection = SearchSectionByName(
                      (PINF)INFHandle,
                      SectionName
                      );

    pLine = SearchLineInSectionByKey(
                pSection,
                Key,
                &Ordinal
                );

    if(pLine == (PLINE)NULL) {
        return (ULONG)-1;
    } else {
        return Ordinal;
    }
}


//
// given section name, key and index return the value
//
PCHAR
SlGetSectionKeyIndex (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN PCHAR Key,
   IN ULONG ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PCHAR    pName;

   if((pSection = SearchSectionByName(
                      (PINF)INFHandle,
                      SectionName
                      ))
                      == (PSECTION)NULL)
       return((PCHAR)NULL);

   if((pLine = SearchLineInSectionByKey(
                      pSection,
                      Key,
                      NULL
                      ))
                      == (PLINE)NULL)
       return((PCHAR)NULL);

   if((pName = SearchValueInLine(
                      pLine,
                      ValueIndex
                      ))
                      == (PCHAR)NULL)
       return((PCHAR)NULL);

   return(ProcessForStringSubs(INFHandle,pName));
}

#ifdef UNICODE
//
// given section name, key and index return the value
//
PWCHAR
SlGetSectionKeyIndexW (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN PCHAR Key,
   IN ULONG ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PWCHAR    pName;

   if((pSection = SearchSectionByName(
                      (PINF)INFHandle,
                      SectionName
                      ))
                      == (PSECTION)NULL)
       return((PWCHAR)NULL);

   if((pLine = SearchLineInSectionByKey(
                      pSection,
                      Key,
                      NULL
                      ))
                      == (PLINE)NULL)
       return((PWCHAR)NULL);

   if((pName = SearchValueInLineW(
                      pLine,
                      ValueIndex
                      ))
                      == (PWCHAR)NULL)
       return((PWCHAR)NULL);

   return(ProcessForStringSubsW(INFHandle,pName));
}
#endif


ULONG
SlCountLinesInSection(
    IN PVOID INFHandle,
    IN PCHAR SectionName
    )
{
    PSECTION pSection;
    PLINE    pLine;
    ULONG    Count;

    if((pSection = SearchSectionByName((PINF)INFHandle,SectionName)) == NULL) {
        return((ULONG)(-1));
    }

    for(pLine = pSection->pLine, Count = 0;
        pLine;
        pLine = pLine->pNext, Count++
       );

    return(Count);
}


PCHAR
SearchValueInLine(
   IN PLINE pLine,
   IN ULONG ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PVALUE pValue;
   ULONG  i;

   if (pLine == (PLINE)NULL)
       return ((PCHAR)NULL);

   if (ValueIndex < NUMBER_OF_INTERNAL_VALUES) {
       return pLine->InternalValues[ValueIndex];
   }

   pValue = pLine->pFirstExternalValue;
   for (i = NUMBER_OF_INTERNAL_VALUES;
        i < ValueIndex && ((pValue = pValue->pNext) != (PVALUE)NULL);
        i++)
      ;

   return (PCHAR)((pValue != NULL) ? pValue->pName : NULL);

}

#ifdef UNICODE
PWCHAR
SearchValueInLineW(
   IN PLINE pLine,
   IN ULONG ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PVALUE pValue;
   ULONG  i;

   if (pLine == (PLINE)NULL)
       return ((PWCHAR)NULL);

   if (ValueIndex < NUMBER_OF_INTERNAL_VALUES) {
       return pLine->InternalValuesW[ValueIndex];
   }

   pValue = pLine->pFirstExternalValue;
   for (i = NUMBER_OF_INTERNAL_VALUES;
        i < ValueIndex && ((pValue = pValue->pNext) != (PVALUE)NULL);
        i++)
      ;

   return (PWCHAR)((pValue != NULL) ? pValue->pNameW : NULL);

}
#endif


PLINE
SearchLineInSectionByKey(
   IN  PSECTION pSection,
   IN  PCHAR    Key,
   OUT PULONG   pOrdinal    OPTIONAL
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PLINE pLine;
   ULONG LineOrdinal;

   if (pSection == (PSECTION)NULL || Key == (PCHAR)NULL) {
       return ((PLINE)NULL);
   }

   pLine = pSection->pLine;
   LineOrdinal = 0;
   while ((pLine != (PLINE)NULL) && (pLine->pName == NULL || _stricmp(pLine->pName, Key))) {
       pLine = pLine->pNext;
       LineOrdinal++;
   }

   if(pLine && pOrdinal) {
       *pOrdinal = LineOrdinal;
   }

   return pLine;

}


PLINE
SearchLineInSectionByIndex(
   IN PSECTION pSection,
   IN ULONG    LineIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PLINE pLine;
   ULONG  i;

   //
   // Validate the parameters passed in
   //

   if (pSection == (PSECTION)NULL) {
       return ((PLINE)NULL);
   }

   //
   // find the start of the line list in the section passed in
   //

   pLine = pSection->pLine;

   //
   // traverse down the current line list to the LineIndex th line
   //

   for (i = 0; i < LineIndex && ((pLine = pLine->pNext) != (PLINE)NULL); i++) {
      ;
   }

   //
   // return the Line found
   //

   return pLine;

}


PSECTION
SearchSectionByName(
   IN PINF  pINF,
   IN PCHAR SectionName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;

   //
   // validate the parameters passed in
   //

   if (pINF == (PINF)NULL || SectionName == (PCHAR)NULL) {
       return ((PSECTION)NULL);
   }

   //
   // find the section list
   //
   pSection = pINF->pSection;

   //
   // traverse down the section list searching each section for the section
   // name mentioned
   //

   while ((pSection != (PSECTION)NULL) && _stricmp(pSection->pName, SectionName)) {
       pSection = pSection->pNext;
   }

   //
   // return the section at which we stopped (either NULL or the section
   // which was found
   //

   return pSection;

}


PCHAR
ProcessForStringSubs(
    IN PINF  pInf,
    IN PCHAR String
    )
{
    unsigned Len;
    PCHAR ReturnString;
    PSECTION pSection;
    PLINE pLine;

    //
    // Assume no substitution necessary.
    //
    ReturnString = String;

    //
    // If it starts and ends with % then look it up in the
    // strings section. Note the initial check before doing a
    // strlen, to preserve performance in the 99% case where
    // there is no substitution.
    //
    if((String[0] == '%') && ((Len = strlen(String)) > 2) && (String[Len-1] == '%')) {

        for(pSection = pInf->pSection; pSection; pSection=pSection->pNext) {
            if(pSection->pName && !_stricmp(pSection->pName,"Strings")) {
                break;
            }
        }

        if(pSection) {

            for(pLine = pSection->pLine; pLine; pLine=pLine->pNext) {
                if(pLine->pName
                && !_strnicmp(pLine->pName,String+1,Len-2)
                && (pLine->pName[Len-2] == 0))
                {
                    break;
                }
            }

            if(pLine && pLine->InternalValues[0]) {
                ReturnString = pLine->InternalValues[0];
            }
        }
    }

    return(ReturnString);
}

#ifdef UNICODE
PWCHAR
ProcessForStringSubsW(
    IN PINF  pInf,
    IN PWCHAR String
    )
{
    unsigned Len;
    PWCHAR ReturnString;
    PSECTION pSection;
    PLINE pLine;

    //
    // Assume no substitution necessary.
    //
    ReturnString = String;

    //
    // If it starts and ends with % then look it up in the
    // strings section. Note the initial check before doing a
    // strlen, to preserve performance in the 99% case where
    // there is no substitution.
    //
    if((String[0] == L'%') && ((Len = wcslen(String)) > 2) && (String[Len-1] == L'%')) {

        for(pSection = pInf->pSection; pSection; pSection=pSection->pNext) {
            if(pSection->pName && !_stricmp(pSection->pName,"Strings")) {
                break;
            }
        }

        if(pSection) {

            for(pLine = pSection->pLine; pLine; pLine=pLine->pNext) {
                if(pLine->pName
                && !_tcsnicmp(pLine->pNameW,String+1,Len-2)
                && (pLine->pName[Len-2] == 0))
                {
                    break;
                }
            }

            if(pLine && pLine->InternalValuesW[0]) {
                ReturnString = pLine->InternalValuesW[0];
            }
        }
    }

    return(ReturnString);
}
#endif



// what follows was alparse.c


//
//  Globals used to make building the lists easier
//

PINF     pINF;
PSECTION pSectionRecord;
PLINE    pLineRecord;
PVALUE   pValueRecord;
PCHAR *  pInternalValue;
PCHAR *  pLastInternalValue;

#ifdef UNICODE
PWCHAR *  pInternalValueW;
PWCHAR *  pLastInternalValueW;
#endif


//
// Globals used by the token parser
//

// string terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below

CHAR  StringTerminators[] = "[]=,\t \"\n\f\v\r";
PCHAR QStringTerminators = StringTerminators+6;
PCHAR EmptyValue;

#define STRING_HEAP_SIZE 1024

ULONG_PTR StringHeapFree = 0;
ULONG_PTR StringHeapLimit = 0;

#if 0 && DBG

#define HEAP_SIZE(_size) (((_size) + BL_GRANULARITY - 1) & ~(BL_GRANULARITY - 1))
#define MAX(_a,_b) (((_a) > (_b)) ? (_a) : (_b))
#define MIN(_a,_b) (((_a) < (_b)) ? (_a) : (_b))

ULONG nStrings = 0;
ULONG maxString = 0;
ULONG bytesStrings = 0;
ULONG wasteStrings = 0;
ULONG stringsWithNLength[12] = {0};

VOID
GetStatistics (
    PINF pINF
    )
{
    ULONG nSections = 0;
    ULONG nLines = 0;
    ULONG nValues = 0;
    ULONG maxLinesPerSection = 0;
    ULONG maxValuesPerLine = 0;
    ULONG maxValuesPerSection = 0;
    ULONG bytesSections = 0;
    ULONG bytesLines = 0;
    ULONG bytesValues = 0;

    ULONG sectionsWithNLines[12] = {0};
    ULONG linesWithNValues[12] = {0};
    ULONG sectionsWithNValues[12] = {0};

    ULONG linesThisSection;
    ULONG valuesThisLine;
    ULONG valuesThisSection;

    PSECTION section;
    PLINE line;
    PVALUE value;

    ULONG i;

    section = pINF->pSection;
    while ( section != NULL ) {
        nSections++;
        bytesSections += HEAP_SIZE(sizeof(SECTION));
        linesThisSection = 0;
        valuesThisSection = 0;
        line = section->pLine;
        while ( line != NULL ) {
            linesThisSection++;
            bytesLines += HEAP_SIZE(sizeof(LINE));
            valuesThisLine = 0;
            for ( i = 0; i < NUMBER_OF_INTERNAL_VALUES; i++ ) {
                if ( line->InternalValues[i] != NULL ) {
                    valuesThisLine++;
                }
            }
            value = line->pFirstExternalValue;
            while ( value != NULL ) {
                valuesThisLine++;
                bytesValues += HEAP_SIZE(sizeof(VALUE));
                value = value->pNext;
            }
            nValues += valuesThisLine;
            valuesThisSection += valuesThisLine;
            maxValuesPerLine = MAX(maxValuesPerLine, valuesThisLine);
            linesWithNValues[MIN(valuesThisLine,11)]++;
            line = line->pNext;
        }
        nLines += linesThisSection;
        maxLinesPerSection = MAX(maxLinesPerSection, linesThisSection);
        sectionsWithNLines[MIN(linesThisSection,11)]++;
        maxValuesPerSection = MAX(maxValuesPerSection, valuesThisSection);
        sectionsWithNValues[MIN(valuesThisSection,11)]++;
        section = section->pNext;
    }

    DbgPrint( "Number of sections = %d\n", nSections );
    DbgPrint( "Bytes in sections  = %d\n", bytesSections );
    DbgPrint( "\n" );
    DbgPrint( "Number of lines    = %d\n", nLines );
    DbgPrint( "Bytes in lines     = %d\n", bytesLines );
    DbgPrint( "\n" );
    DbgPrint( "Number of values    = %d\n", nValues );
    DbgPrint( "Bytes in values     = %d\n", bytesValues );
    DbgPrint( "\n" );
    DbgPrint( "Max lines/section   = %d\n", maxLinesPerSection );
    DbgPrint( "Max values/line     = %d\n", maxValuesPerLine );
    DbgPrint( "Max values/section  = %d\n", maxValuesPerSection );
    DbgPrint( "\n" );
    DbgPrint( "Number of strings          = %d\n", nStrings );
    DbgPrint( "Bytes in strings           = %d\n", bytesStrings );
    DbgPrint( "Wasted bytes in strings    = %d\n", wasteStrings + (StringHeapLimit - StringHeapFree) );
    DbgPrint( "Longest string             = %d\n", maxString );
    DbgPrint( "\n" );
    DbgPrint( "Sections with N lines  =" );
    for ( i = 0; i < 12; i++ ) {
        DbgPrint( " %5d", sectionsWithNLines[i] );
    }
    DbgPrint( "\n" );
    DbgPrint( "Sections with N values =" );
    for ( i = 0; i < 12; i++ ) {
        DbgPrint( " %5d", sectionsWithNValues[i] );
    }
    DbgPrint( "\n" );
    DbgPrint( "Lines with N values    =" );
    for ( i = 0; i < 12; i++ ) {
        DbgPrint( " %5d", linesWithNValues[i] );
    }
    DbgPrint( "\n" );
    DbgPrint( "String with length N   =" );
    for ( i = 0; i < 12; i++ ) {
        DbgPrint( " %5d", stringsWithNLength[i] );
    }
    DbgPrint( "\n" );

    DbgBreakPoint();
}

#endif // DBG

//
// Main parser routine
//

PVOID
ParseInfBuffer(
    PCHAR INFFile,
    PCHAR Buffer,
    ULONG Size,
    PULONG ErrorLine
    )

/*++

Routine Description:

   Given a character buffer containing the INF file, this routine parses
   the INF into an internal form with Section records, Line records and
   Value records.

Arguments:

   Buffer - contains to ptr to a buffer containing the INF file

   Size - contains the size of the buffer.

   ErrorLine - if a parse error occurs, this variable receives the line
        number of the line containing the error.


Return Value:

   PVOID - INF handle ptr to be used in subsequent INF calls.

--*/

{
    PCHAR      Stream, MaxStream, pchSectionName = NULL, pchValue = NULL;
    ULONG      State, InfLine;
    TOKEN      Token;
    BOOLEAN       Done;
    BOOLEAN       Error;
    ARC_STATUS ErrorCode;

    //
    // Initialise the globals
    //
    pINF            = (PINF)NULL;
    pSectionRecord  = (PSECTION)NULL;
    pLineRecord     = (PLINE)NULL;
    pValueRecord    = (PVALUE)NULL;
    pInternalValue  = NULL;
    pLastInternalValue = NULL;
#ifdef UNICODE
    pInternalValueW  = NULL;
    pLastInternalValueW = NULL;
#endif

    //
    // Need EmptyValue to point at a nul character
    //
    EmptyValue = StringTerminators + strlen(StringTerminators);

    //
    // Get INF record
    //
    if ((pINF = (PINF)BlAllocateHeap(sizeof(INF))) == NULL) {
        SlNoMemoryError();
        return NULL;
    }
    pINF->pSection = NULL;

    //
    // Set initial state
    //
    State     = 1;
    InfLine   = 1;
    Stream    = Buffer;
    MaxStream = Buffer + Size;
    Done      = FALSE;
    Error     = FALSE;

    //
    // Enter token processing loop
    //

    while (!Done)       {

       Token = SpGetToken(&Stream, MaxStream);

       switch (State) {
       //
       // STATE1: Start of file, this state remains till first
       //         section is found
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_LBRACE
       case 1:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;

       //
       // STATE 2: Section LBRACE has been received, expecting STRING
       //
       // Valid Tokens: TOK_STRING
       //
       case 2:
           switch (Token.Type) {
              case TOK_STRING:
                  State = 3;
                  pchSectionName = Token.pValue;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;

           }
           break;

       //
       // STATE 3: Section Name received, expecting RBRACE
       //
       // Valid Tokens: TOK_RBRACE
       //
       case 3:
           switch (Token.Type) {
              case TOK_RBRACE:
                State = 4;
                break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;
       //
       // STATE 4: Section Definition Complete, expecting EOL
       //
       // Valid Tokens: TOK_EOL, TOK_EOF
       //
       case 4:
           switch (Token.Type) {
              case TOK_EOL:
                  if ((ErrorCode = SpAppendSection(
                                        pchSectionName
#ifdef UNICODE
                                        ,SlCopyStringAW(pchSectionName)
#endif
                                        )) != ESUCCESS) {

                    Error = Done = TRUE;
                  } else {
                    pchSectionName = NULL;
                    State = 5;
                  }
                  break;

              case TOK_EOF:
                  if ((ErrorCode = SpAppendSection(
                                        pchSectionName
#ifdef UNICODE
                                        ,SlCopyStringAW(pchSectionName)
#endif                                        
                                        )) != ESUCCESS)
                    Error = Done = TRUE;
                  else {
                    pchSectionName = NULL;
                    Done = TRUE;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;

       //
       // STATE 5: Expecting Section Lines
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_STRING, TOK_LBRACE
       //
       case 5:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_STRING:
                  pchValue = Token.pValue;
                  State = 6;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;

       //
       // STATE 6: String returned, not sure whether it is key or value
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA, TOK_EQUAL
       //
       case 6:
           switch (Token.Type) {
              case TOK_EOL:
                  if ( (ErrorCode = SpAppendLine(
                                            NULL
#ifdef UNICODE
                                            ,NULL
#endif
                                            )) != ESUCCESS ||
                       (ErrorCode = SpAppendValue(
                                            pchValue
#ifdef UNICODE
                                            ,SlCopyStringAW(pchValue)
#endif
                                            )) !=ESUCCESS )
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 5;
                  }
                  break;

              case TOK_EOF:
                  if ( (ErrorCode = SpAppendLine(
                                            NULL
#ifdef UNICODE
                                            ,NULL
#endif
                                            )) != ESUCCESS ||
                       (ErrorCode = SpAppendValue(
                                            pchValue
#ifdef UNICODE
                                            ,SlCopyStringAW(pchValue)
#endif
                                            )) !=ESUCCESS )
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      Done = TRUE;
                  }
                  break;

              case TOK_COMMA:
                  if ( (ErrorCode = SpAppendLine(
                                            NULL
#ifdef UNICODE
                                            ,NULL
#endif
                                            )) != ESUCCESS ||
                       (ErrorCode = SpAppendValue(
                                            pchValue
#ifdef UNICODE
                                            ,SlCopyStringAW(pchValue)
#endif
                                            )) !=ESUCCESS )
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 7;
                  }
                  break;

              case TOK_EQUAL:
                  if ( (ErrorCode = SpAppendLine(
                                            pchValue
#ifdef UNICODE
                                            ,SlCopyStringAW(pchValue)
#endif
                                            )) !=ESUCCESS)
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 8;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;

       //
       // STATE 7: Comma received, Expecting another string
       //
       // Valid Tokens: TOK_STRING TOK_COMMA
       //   A comma means we have an empty value.
       //
       case 7:
           switch (Token.Type) {
              case TOK_COMMA:
                  Token.pValue = EmptyValue;
                  if ((ErrorCode = SpAppendValue(
                                        Token.pValue
#ifdef UNICODE
                                        ,SlCopyStringAW(Token.pValue)
#endif
                                        )) != ESUCCESS) {
                      Error = Done = TRUE;
                  }
                  //
                  // State stays at 7 because we are expecting a string
                  //
                  break;

              case TOK_STRING:
                  if ((ErrorCode = SpAppendValue(
                                            Token.pValue
#ifdef UNICODE
                                            ,SlCopyStringAW(Token.pValue)
#endif
                                            )) != ESUCCESS)
                      Error = Done = TRUE;
                  else
                     State = 9;

                  break;

              case TOK_EOL:
              case TOK_EOF:
                  Token.pValue = EmptyValue;
                  if ((ErrorCode = SpAppendValue(
                                            Token.pValue
#ifdef UNICODE
                                            ,SlCopyStringAW(Token.pValue)
#endif
                                            )) != ESUCCESS)
                      Error = Done = TRUE;
                  else
                     State = 9;

                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;
       //
       // STATE 8: Equal received, Expecting another string
       //          If none, assume there is a single empty string on the RHS
       //
       // Valid Tokens: TOK_STRING, TOK_EOL, TOK_EOF
       //
       case 8:
           switch (Token.Type) {
              case TOK_EOF:
                  Token.pValue = EmptyValue;
                  if((ErrorCode = SpAppendValue(
                                            Token.pValue
#ifdef UNICODE
                                            ,SlCopyStringAW(Token.pValue)
#endif
                                            )) != ESUCCESS) {
                      Error = TRUE;
                  }
                  Done = TRUE;
                  break;

              case TOK_EOL:
                  Token.pValue = EmptyValue;
                  if((ErrorCode = SpAppendValue(
                                            Token.pValue
#ifdef UNICODE
                                            ,SlCopyStringAW(Token.pValue)
#endif
                                            )) != ESUCCESS) {
                      Error = TRUE;
                      Done = TRUE;
                  } else {
                      State = 5;
                  }
                  break;

              case TOK_STRING:
                  if ((ErrorCode = SpAppendValue(
                                            Token.pValue
#ifdef UNICODE
                                            ,SlCopyStringAW(Token.pValue)
#endif
                                            )) != ESUCCESS)
                      Error = Done = TRUE;
                  else
                      State = 9;

                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;
       //
       // STATE 9: String received after equal, value string
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 9:
           switch (Token.Type) {
              case TOK_EOL:
                  State = 5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;
       //
       // STATE 10: Value string definitely received
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 10:
           switch (Token.Type) {
              case TOK_EOL:
                  State =5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;

       default:
           Error = Done = TRUE;
           ErrorCode = EINVAL;
           break;

       } // end switch(State)


       if (Error) {

           switch (ErrorCode) {
               case EINVAL:
                  *ErrorLine = InfLine;
                  break;
               case ENOMEM:
	         SlBadInfLineError(InfLine, INFFile);
                  break;
               default:
                  break;
           }

           ErrorCode = SpFreeINFBuffer((PVOID)pINF);
           if (pchSectionName != (PCHAR)NULL) {
               SpFree(pchSectionName);
           }

           if (pchValue != (PCHAR)NULL) {
               SpFree(pchValue);
           }

           pINF = (PINF)NULL;
       }
       else {

          //
          // Keep track of line numbers so that we can display Errors
          //

          if (Token.Type == TOK_EOL)
              InfLine++;
       }

    } // End while

#if 0 && DBG
    GetStatistics(pINF);
#endif

    return((PVOID)pINF);
}



ARC_STATUS
SpAppendSection(
    IN PCHAR pSectionName
#ifdef UNICODE 
    , IN PWCHAR pSectionNameW
#endif
    )

/*++

Routine Description:

    This appends a new section to the section list in the current INF.
    All further lines and values pertain to this new section, so it resets
    the line list and value lists too.

Arguments:

    pSectionName - Name of the new section. ( [SectionName] )

Return Value:

    ESUCCESS - if successful.
    ENOMEM   - if memory allocation failed.
    EINVAL   - if invalid parameters passed in or the INF buffer not
               initialised

--*/

{
    PSECTION pNewSection;

    //
    // Check to see if INF initialised and the parameter passed in is valid
    //

    if (pINF == (PINF)NULL || pSectionName == (PCHAR)NULL) {
        if(pchINFName) {
            SlFriendlyError(
                EINVAL,
                pchINFName,
                __LINE__,
                __FILE__
                );
        } else {
            SlError(EINVAL);
        }
        return EINVAL;
    }

    //
    // See if we already have a section by this name. If so we want
    // to merge sections.
    //
    for(pNewSection=pINF->pSection; pNewSection; pNewSection=pNewSection->pNext) {
        if(pNewSection->pName && !_stricmp(pNewSection->pName,pSectionName)) {
            break;
        }
    }
    if(pNewSection) {
        //
        // Set pLineRecord to point to the list line currently in the section.
        //
        for(pLineRecord = pNewSection->pLine;
            pLineRecord && pLineRecord->pNext;
            pLineRecord = pLineRecord->pNext)
            ;

    } else {
        //
        // Allocate memory for the new section
        //

        if ((pNewSection = (PSECTION)BlAllocateHeap(sizeof(SECTION))) == (PSECTION)NULL) {
            SlNoMemoryError();
            return ENOMEM;
        }

        //
        // initialise the new section
        //
        pNewSection->pNext = NULL;
        pNewSection->pLine = NULL;
        pNewSection->pName = pSectionName;
#ifdef UNICODE
        pNewSection->pNameW = pSectionNameW;
#endif

        //
        // link it in
        //
        pNewSection->pNext = pINF->pSection;
        pINF->pSection = pNewSection;

        //
        // reset the current line record
        //
        pLineRecord = NULL;
    }

    pSectionRecord = pNewSection;
    pValueRecord = NULL;
    pInternalValue = NULL;
    pLastInternalValue = NULL;
#ifdef UNICODE
    pInternalValueW = NULL;
    pLastInternalValueW = NULL;
#endif

    return ESUCCESS;
}


ARC_STATUS
SpAppendLine(
    IN PCHAR pLineKey
#ifdef UNICODE 
    , IN PWCHAR pLineKeyW
#endif
    )

/*++

Routine Description:

    This appends a new line to the line list in the current section.
    All further values pertain to this new line, so it resets
    the value list too.

Arguments:

    pLineKey - Key to be used for the current line, this could be NULL.

Return Value:

    ESUCCESS - if successful.
    ENOMEM   - if memory allocation failed.
    EINVAL   - if invalid parameters passed in or current section not
               initialised


--*/


{
    PLINE pNewLine;
    ULONG i;

    //
    // Check to see if current section initialised
    //

    if (pSectionRecord == (PSECTION)NULL) {
        if(pchINFName) {
            SlFriendlyError(
                EINVAL,
                pchINFName,
                __LINE__,
                __FILE__
                );
        } else {
            SlError(EINVAL);
        }
        return EINVAL;
    }

    //
    // Allocate memory for the new Line
    //

    if ((pNewLine = (PLINE)BlAllocateHeap(sizeof(LINE))) == (PLINE)NULL) {
        SlNoMemoryError();
        return ENOMEM;
    }

    //
    // Link it in
    //
    pNewLine->pNext  = (PLINE)NULL;
    for ( i = 0; i < NUMBER_OF_INTERNAL_VALUES; i++ ) {
        pNewLine->InternalValues[i] = NULL;
#ifdef UNICODE
        pNewLine->InternalValuesW[i] = NULL;
#endif
    }
    pNewLine->pFirstExternalValue = (PVALUE)NULL;
    pNewLine->pName  = pLineKey;
#ifdef UNICODE    
    pNewLine->pNameW = pLineKeyW;
#endif

    if (pLineRecord == (PLINE)NULL) {
        pSectionRecord->pLine = pNewLine;
    }
    else {
        pLineRecord->pNext = pNewLine;
    }

    pLineRecord  = pNewLine;

    //
    // Reset the current value record
    //

    pValueRecord = (PVALUE)NULL;
    pInternalValue = &pNewLine->InternalValues[0];
    pLastInternalValue = &pNewLine->InternalValues[NUMBER_OF_INTERNAL_VALUES];

#ifdef UNICODE
    pInternalValueW = &pNewLine->InternalValuesW[0];
    pLastInternalValueW = &pNewLine->InternalValuesW[NUMBER_OF_INTERNAL_VALUES];
#endif

    return ESUCCESS;
}



ARC_STATUS
SpAppendValue(
    IN PCHAR pValueString
#ifdef UNICODE 
    , IN PWCHAR pValueStringW
#endif
    )

/*++

Routine Description:

    This appends a new value to the value list in the current line.

Arguments:

    pValueString - The value string to be added.

Return Value:

    ESUCCESS - if successful.
    ENOMEM   - if memory allocation failed.
    EINVAL   - if invalid parameters passed in or current line not
               initialised.

--*/

{
    PVALUE pNewValue;

    //
    // Check to see if current line record has been initialised and
    // the parameter passed in is valid
    //

    if (pLineRecord == (PLINE)NULL || pValueString == (PCHAR)NULL) {
        if(pchINFName) {
            SlFriendlyError(
                EINVAL,
                pchINFName,
                __LINE__,
                __FILE__
                );
        } else {
            SlError(EINVAL);
        }
        return EINVAL;
    }

    if (pInternalValue != NULL) {

        *pInternalValue++ = pValueString;
        if (pInternalValue >= pLastInternalValue) {
            pInternalValue = NULL;
        }

#ifdef UNICODE
        *pInternalValueW++ = pValueStringW;
        if (pInternalValueW >= pLastInternalValueW) {
            pInternalValueW = NULL;
        }
#endif


        return ESUCCESS;
    }

    //
    // Allocate memory for the new value record
    //

    if ((pNewValue = (PVALUE)BlAllocateHeap(sizeof(VALUE))) == (PVALUE)NULL) {
        SlNoMemoryError();
        return ENOMEM;
    }

    //
    // Link it in.
    //

    pNewValue->pNext  = (PVALUE)NULL;
    pNewValue->pName  = pValueString;
#ifdef UNICODE
    pNewValue->pNameW = pValueStringW;    
#endif

    if (pValueRecord == (PVALUE)NULL)
        pLineRecord->pFirstExternalValue = pNewValue;
    else
        pValueRecord->pNext = pNewValue;

    pValueRecord = pNewValue;
    return ESUCCESS;
}

PVOID
SpAllocateStringHeap (
    IN ULONG Size
    )

/*++

Routine Description:

    This routine allocates memory from the OS loader heap.

Arguments:

    Size - Supplies the size of block required in bytes.

Return Value:

    If a free block of memory of the specified size is available, then
    the address of the block is returned. Otherwise, NULL is returned.

--*/

{
    PVOID HeapBlock;
    ULONG_PTR Block;

    if (Size >= STRING_HEAP_SIZE) {
        return BlAllocateHeap(Size);
    }

    if ((StringHeapFree + Size) >= StringHeapLimit) {

#if 0 && DBG
        wasteStrings += (StringHeapLimit - StringHeapFree);
#endif

        HeapBlock = BlAllocateHeap( STRING_HEAP_SIZE );
        if ( HeapBlock == NULL ) {
            return NULL;
        }

        StringHeapFree = (ULONG_PTR)HeapBlock;
        StringHeapLimit = StringHeapFree + STRING_HEAP_SIZE;
    }

    Block = StringHeapFree;
    StringHeapFree += Size;

#if 0 && DBG
    nStrings++;
    bytesStrings += Size;
    stringsWithNLength[MIN(Size,11)]++;
    maxString = MAX(maxString, Size);
#endif
    return (PVOID)Block;
}

TOKEN
SpGetToken(
    IN OUT PCHAR *Stream,
    IN PCHAR      MaxStream
    )

/*++

Routine Description:

    This function returns the Next token from the configuration stream.

Arguments:

    Stream - Supplies the address of the configuration stream.  Returns
        the address of where to start looking for tokens within the
        stream.

    MaxStream - Supplies the address of the last character in the stream.


Return Value:

    TOKEN - Returns the next token

--*/

{

    PCHAR pch, pchStart, pchNew;
    ULONG  Length;
    TOKEN Token;

    //
    //  Skip whitespace (except for eol)
    //

    pch = *Stream;
    while (pch < MaxStream && *pch != '\n' && isspace(*pch))
        pch++;


    //
    // Check for comments and remove them
    //

    if (pch < MaxStream &&
        ((*pch == '#') ||
         (*pch == ';') ||
         (*pch == '/' && pch+1 < MaxStream && *(pch+1) =='/')))
        while (pch < MaxStream && *pch != '\n')
            pch++;

    //
    // Check to see if EOF has been reached, set the token to the right
    // value
    //

    if ((pch >= MaxStream) || (*pch == 26)) {
        *Stream = pch;
        Token.Type  = TOK_EOF;
        Token.pValue = NULL;
        return Token;
    }


    switch (*pch) {

    case '[' :
        pch++;
        Token.Type  = TOK_LBRACE;
        Token.pValue = NULL;
        break;

    case ']' :
        pch++;
        Token.Type  = TOK_RBRACE;
        Token.pValue = NULL;
        break;

    case '=' :
        pch++;
        Token.Type  = TOK_EQUAL;
        Token.pValue = NULL;
        break;

    case ',' :
        pch++;
        Token.Type  = TOK_COMMA;
        Token.pValue = NULL;
        break;

    case '\n' :
        pch++;
        Token.Type  = TOK_EOL;
        Token.pValue = NULL;
        break;

    case '\"':
        pch++;
        //
        // determine quoted string
        //
        pchStart = pch;
        while (pch < MaxStream && (strchr(QStringTerminators,*pch) == NULL)) {
            pch++;
        }

        if (pch >=MaxStream || *pch != '\"') {
            Token.Type   = TOK_ERRPARSE;
            Token.pValue = NULL;
        } else {
            //
            // We require a quoted string to end with a double-quote.
            // (If the string ended with anything else, the if() above
            // would not have let us into the else clause.) The quote
            // character is irrelevent, however, and can be overwritten.
            // So we'll save some heap and use the string in-place.
            // No need to make a copy.
            //
            // Note that this alters the image of txtsetup.sif we pass
            // to setupdd.sys. Thus the inf parser in setupdd.sys must
            // be able to treat a nul character as if it were a terminating
            // double quote.
            //
            *pch++ = 0;
            Token.Type = TOK_STRING;
            Token.pValue = pchStart;
        }
        break;

    default:
        //
        // determine regular string
        //
        pchStart = pch;
        while (pch < MaxStream && (strchr(StringTerminators,*pch) == NULL)) {
            pch++;
        }

        if (pch == pchStart) {
            pch++;
            Token.Type  = TOK_ERRPARSE;
            Token.pValue = NULL;
        }
        else {
            Length = (ULONG)(pch - pchStart);
            if ((pchNew = SpAllocateStringHeap(Length + 1)) == NULL) {
                Token.Type = TOK_ERRNOMEM;
                Token.pValue = NULL;
            }
            else {
                strncpy(pchNew, pchStart, Length);
                pchNew[Length] = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
            }
        }
        break;
    }

    *Stream = pch;
    return (Token);
}

PCHAR
SlSearchSection(
    IN PCHAR SectionName,
    IN PCHAR TargetName
    )

/*++

Routine Description:

    Searches a section in the INF file to match a name from the ARC identifier
    with the canonical shortname.

    If a string starts with *, then use strstr to find it in the node's id
    string, else use stricmp.

    [Map.Computer]
        msjazz_up   = *Jazz
        desksta1_up = "DESKTECH-ARCStation I"
        pica61_up   = "PICA-61"
        duo_mp      = *Duo

    [Map.Computer]
        DECjensen = "DEC-20Jensen"
        DECjensen = "DEC-10Jensen"

Arguments:

    SectionName - Supplies the name of the section ("Map.Computer")

    TargetName - Supplies the ARC string to be matched ("DEC-20Jensen")

Return Value:

    NULL - No match was found.

    PCHAR - Pointer to the canonical shortname of the device.

--*/

{
    ULONG i;
    PCHAR SearchName;

    //
    // Enumerate the entries in the section.  If the 0 value
    // begins with a *, then see if the system name contains the string that
    // follows.  Otherwise, do a case-insensitive compare on the name.
    //
    for (i=0;;i++) {
        SearchName = SlGetSectionLineIndex(InfFile,
                                           SectionName,
                                           i,
                                           0);
        if (SearchName==NULL) {
            //
            // we have enumerated the entire section without finding a match,
            // return failure.
            //
            return(NULL);
        }

        if (SearchName[0]=='*') {
            if (strstr(TargetName,SearchName+1) != 0) {
                //
                // we have a match
                //
                break;
            }
        } else {
            if (_stricmp(TargetName, SearchName) == 0) {
                //
                // we have a match
                //
                break;
            }
        }
    }

    //
    // i is the index into the section of the short machine name
    //
    return(SlGetKeyName(InfFile,
                        SectionName,
                        i));


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\netboot2.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    net.c

Abstract:

    This module implements the net boot file system used by the operating
    system loader.

    It only contains those functions which are firmware/BIOS dependent.

Author:

    Chuck Lenzmeier (chuckl) 09-Jan-1997

Revision History:

--*/

#include "bootlib.h"
#include "stdio.h"

#ifdef UINT16
#undef UINT16
#endif

#ifdef INT16
#undef INT16
#endif

#include <dhcp.h>
#include <netfs.h>
#include <pxe_cmn.h>

#include <pxe_api.h>

#include <udp_api.h>
#include <tftp_api.h>
#include "bootx86.h"

#ifndef BOOL
typedef int BOOL;
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE  1
#endif

#ifndef BYTE
typedef unsigned char BYTE;
#endif

#ifndef LPBYTE
typedef BYTE *LPBYTE;
#endif

#define MAX_PATH          260


//
// Define global data.
//

CHAR NetBootPath[129];

ULONG NetLocalIpAddress;
ULONG NetLocalSubnetMask;
ULONG NetServerIpAddress;
ULONG NetGatewayIpAddress;
UCHAR NetLocalHardwareAddress[16];

UCHAR NetBootIniContents[1020 + 1]; // 4 * 255 = 1020 + 1
UCHAR NetBootIniPath[256 + 1];

USHORT NetMaxTranUnit = 0; // MTU
USHORT NetHwAddrLen = 0; // actual length of hardware address
USHORT NetHwType = 0; // Type of protocol at the hardware level from rfc1010

UCHAR MyGuid[16];
ULONG MyGuidLength = sizeof(MyGuid);
BOOLEAN MyGuidValid = FALSE;


ARC_STATUS
FindDhcpOption(
    IN BOOTPLAYER * Packet,
    IN UCHAR Option,
    IN ULONG MaximumLength,
    OUT PUCHAR OptionData,
    OUT PULONG Length OPTIONAL,
    IN ULONG Instance OPTIONAL
    )
{
    PUCHAR curOption;
    ULONG copyLength;
    ULONG i = 0;

    if (MaximumLength == 0) {
        return EINVAL;
    }

    RtlZeroMemory(OptionData, MaximumLength);

    //
    // Parse the DHCP options looking for a specific one.
    //

    curOption = &Packet->vendor.d[4];   // skip the magic cookie
    while ((curOption - (PUCHAR)Packet) < sizeof(BOOTPLAYER)) {

        if (*curOption == Option) {

            //
            // Found it, copy and leave.
            //

            if ( i == Instance ) {

                if (curOption[1] > MaximumLength) {
                    copyLength = MaximumLength;
                } else {
                    copyLength = curOption[1];
                }

                RtlCopyMemory(OptionData,
                              curOption+2,
                              copyLength);

                if (ARGUMENT_PRESENT(Length)) {
                    *Length = copyLength;
                }

                return ESUCCESS;
            }

            i++;
        }

        if (*curOption == 0xff) {
            break;
        }

        curOption = curOption + 2 + curOption[1];

    }

    return EINVAL;

}


ARC_STATUS
GetParametersFromRom (
    VOID
    )
{
    SHORT status;
    t_PXENV_GET_BINL_INFO gbi;
    t_PXENV_UNDI_GET_INFORMATION info;
    BOOTPLAYER packet;
    ULONG pathLength;
    ULONG temp;
    ULONG i;

    NetLocalIpAddress = 0;
    NetGatewayIpAddress = 0;
    NetServerIpAddress = 0;
    NetLocalSubnetMask = 0;
    *NetBootPath = 0;

    RtlZeroMemory( NetBootIniContents, sizeof(NetBootIniContents) ) ;
    RtlZeroMemory( NetBootIniPath, sizeof(NetBootIniPath) ) ;

    //
    // Get client IP address, server IP address, default gateway IP address,
    // and subnet mask from the DHCP ACK packet.
    //

    gbi.packet_type = PXENV_PACKET_TYPE_DHCP_ACK;
    gbi.buffer_size = sizeof(packet);
    gbi.buffer_offset = (USHORT)((ULONG_PTR)&packet & 0x0f);
    gbi.buffer_segment = (USHORT)(((ULONG_PTR)&packet >> 4) & 0xffff);

    status = NETPC_ROM_SERVICES( PXENV_GET_BINL_INFO, &gbi );
    if ( status != PXENV_EXIT_SUCCESS ) {
        DPRINT( ERROR, ("PXENV_GET_BINL_INFO(1) failed with %x\n", status) );
    } else {
        NetLocalIpAddress = *(ULONG *)packet.yip;
        NetServerIpAddress = *(ULONG *)packet.sip;
        if (FindDhcpOption(&packet, DHCP_ROUTER, sizeof(temp), (PUCHAR)&temp, NULL, 0) == ESUCCESS) {
            NetGatewayIpAddress = temp;
        } else {
            NetGatewayIpAddress = *(ULONG *)packet.gip;
        }
        memcpy(NetLocalHardwareAddress, packet.caddr, 16);
        if (FindDhcpOption(&packet, DHCP_SUBNET, sizeof(temp), (PUCHAR)&temp, NULL, 0) == ESUCCESS) {
            NetLocalSubnetMask = temp;
        }
    }

    //
    // Values for client IP address, server IP address, default gateway IP address,
    // and subnet mask that are present in the BINL REPLY packet override those
    // in the DHCP ACK packet.
    //

    gbi.packet_type = PXENV_PACKET_TYPE_BINL_REPLY;
    gbi.buffer_size = sizeof(packet);
    gbi.buffer_offset = (USHORT)((ULONG_PTR)&packet & 0x0f);
    gbi.buffer_segment = (USHORT)(((ULONG_PTR)&packet >> 4) & 0xffff);

    status = NETPC_ROM_SERVICES( PXENV_GET_BINL_INFO, &gbi );
    if ( status != PXENV_EXIT_SUCCESS ) {
        DPRINT( ERROR, ("PXENV_GET_BINL_INFO(2) failed with %x\n", status) );
        return ENODEV;
    }

    if ( *(ULONG *)packet.yip != 0 ) {
        NetLocalIpAddress = *(ULONG *)packet.yip;
    }
    if ( *(ULONG *)packet.sip != 0 ) {
        NetServerIpAddress = *(ULONG *)packet.sip;
    }

    if (FindDhcpOption(&packet, DHCP_ROUTER, sizeof(temp), (PUCHAR)&temp, NULL, 0) == ESUCCESS) {
        NetGatewayIpAddress = temp;
    } else if ( *(ULONG *)packet.gip != 0 ) {
        NetGatewayIpAddress = *(ULONG *)packet.gip;
    }
    if (FindDhcpOption(&packet, DHCP_SUBNET, sizeof(temp), (PUCHAR)&temp, NULL, 0) == ESUCCESS) {
        NetLocalSubnetMask = temp;
    }

    DPRINT( ERROR, ("Client: %x, Subnet mask: %x; Server: %x; Gateway: %x\n",
            NetLocalIpAddress, NetLocalSubnetMask, NetServerIpAddress, NetGatewayIpAddress) );

    //
    // Find the length of the path of the boot filename (the part right
    // before the actual name).
    //

    pathLength = strlen(packet.bootfile);
    while (pathLength > 0) {
        --pathLength;
        if (packet.bootfile[pathLength] == '\\') {
            ++pathLength;  // advance it past the '\'
            packet.bootfile[pathLength] = 0; // terminate the path
            break;
        }
    }

    if ( pathLength ) {
        strcpy( NetBootPath, packet.bootfile );
    }

    //
    // The BINL server could optionally specify two private DHCP option tags
    // that are used for processing boot.ini.
    //
    // DHCP_LOADER_BOOT_INI would contain the entire contents of boot.ini
    // and is limited to 1024 bytes. Note that each DHCP option tags is 
    // to 255 bytes. Boot.ini contents can be broken into multiple instances
    // of the same tag. We support up to 4 instances = 1020 bytes.
    //
    for (i = 0; i < 4; i++) {

        if (FindDhcpOption( &packet, 
                            DHCP_LOADER_BOOT_INI, 
                            255, 
                            &NetBootIniContents[i * 255], 
                            NULL,
                            i) != ESUCCESS ) {
            break;
        }                        
    }
    
    //
    // DHCP_LOADER_BOOT_INI_PATH contains a path to a boot.ini file and is 
    // ignored if DHCP_LOADER_BOOT_INI has been specified.
    //
    FindDhcpOption(&packet, DHCP_LOADER_BOOT_INI_PATH, sizeof(NetBootIniPath), NetBootIniPath, NULL, 0);

    //
    // Get UNDI information
    //

    RtlZeroMemory(&info, sizeof(info));
    status = NETPC_ROM_SERVICES( PXENV_UNDI_GET_INFORMATION, &info );
    if ((status != PXENV_EXIT_SUCCESS) || (info.Status != PXENV_EXIT_SUCCESS)) {
        DPRINT( ERROR, ("PXENV_UNDI_GET_INFORMATION failed with %x, status = %x\n", status, info.Status) );
        return ENODEV;
    }

    NetMaxTranUnit = info.MaxTranUnit;
    NetHwAddrLen = info.HwAddrLen;
    NetHwType = info.HwType;
    memcpy( NetLocalHardwareAddress, info.PermNodeAddress, ADDR_LEN );

    return ESUCCESS;
}


VOID
GetGuid(
    OUT PUCHAR *Guid,
    OUT PULONG GuidLength
    )

/*++

Routine Description:

    This routine returns the Guid of this machine.

Arguments:

    Guid - Place to store pointer to the guid.

    GuidLength - Place to store the length in bytes of the guid.

Return Value:

    None.

--*/

{
    t_PXENV_GET_BINL_INFO gbi;
    BOOTPLAYER packet;
    SHORT romStatus;
    ARC_STATUS Status;
    UCHAR TmpBuffer[sizeof(MyGuid) + 1];

    if (!MyGuidValid) {

        gbi.packet_type = PXENV_PACKET_TYPE_BINL_REPLY;
        gbi.buffer_size = sizeof(packet);
        gbi.buffer_offset = (USHORT)((ULONG_PTR)&packet & 0x0f);
        gbi.buffer_segment = (USHORT)(((ULONG_PTR)&packet >> 4) & 0xffff);

        romStatus = NETPC_ROM_SERVICES( PXENV_GET_BINL_INFO, &gbi );
        if ( romStatus == PXENV_EXIT_SUCCESS ) {
            Status = FindDhcpOption(&packet,
                                    DHCP_CLIENT_GUID,
                                    sizeof(TmpBuffer),
                                    TmpBuffer,
                                    &MyGuidLength,
                                    0);
            if (Status == ESUCCESS) {

                if (MyGuidLength > sizeof(MyGuid)) {
                    memcpy(MyGuid, TmpBuffer + MyGuidLength - sizeof(MyGuid), sizeof(MyGuid));
                    MyGuidLength = sizeof(MyGuid);
                } else {
                    memcpy(MyGuid, TmpBuffer, MyGuidLength);
                }

                *Guid = MyGuid;
                *GuidLength = MyGuidLength;
                MyGuidValid = TRUE;
                return;
            }
        }

        //
        // Use the NIC hardware address as a GUID
        //
        memset(MyGuid, 0x0, sizeof(MyGuid));
        memcpy(MyGuid + sizeof(MyGuid) - sizeof(NetLocalHardwareAddress),
               NetLocalHardwareAddress,
               sizeof(NetLocalHardwareAddress)
              );
        MyGuidLength = sizeof(MyGuid);
        MyGuidValid = TRUE;
    }

    *Guid = MyGuid;
    *GuidLength = MyGuidLength;
}


ULONG
CalculateChecksum(
    IN PLONG Block,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine calculates a simple two's-complement checksum of a block of
    memory. If the returned value is stored in the block (in a word that was
    zero during the calculation), then new checksum of the block will be zero.

Arguments:

    Block - Address of a block of data. Must be 4-byte aligned.

    Length - Length of the block. Must be a multiple of 4.

Return Value:

    ULONG - Two's complement additive checksum of the input block.

--*/

{
    LONG checksum = 0;

    ASSERT( ((ULONG_PTR)Block & 3) == 0 );
    ASSERT( (Length & 3) == 0 );

    for ( ; Length != 0; Length -= 4 ) {
        checksum += *Block;
        Block++;
    }

    return -checksum;
}


NTSTATUS
NetSoftReboot(
    IN PUCHAR NextBootFile,
    IN ULONGLONG Param,
    IN PUCHAR RebootFile OPTIONAL,
    IN PUCHAR SifFile OPTIONAL,
    IN PUCHAR User OPTIONAL,
    IN PUCHAR Domain OPTIONAL,
    IN PUCHAR Password OPTIONAL,
    IN PUCHAR AdministratorPassword OPTIONAL
    )

/*++

Routine Description:

    This routine does a soft reboot by inserting a fake BINL packet into the ROM and
    then inserting the filename of the start of a TFTP command.

Arguments:

    NextBootFile - Fully qualified path name of the file to download.

    Param - Reboot parameter to set.

    RebootFile - String identifying the file to reboot to when after the current reboot is done.

    SifFile - Optional SIF file to pass to the next loader.

    User/Domain/Password/AdministratorPassword - Optional credentials to pass to the next loader.

Return Value:

    Should not return if successful.

--*/

{

    SHORT romStatus;
    NTSTATUS status = STATUS_SUCCESS;
    union {
        t_PXENV_UDP_CLOSE UdpClose;
        t_PXENV_TFTP_READ_FILE TftpReadFile;
    } command;
    t_PXENV_GET_BINL_INFO gbi;
    BOOTPLAYER * packet;
    PTFTP_RESTART_BLOCK restartBlock;
    PTFTP_RESTART_BLOCK_V1 restartBlockV1;

    DPRINT( TRACE, ("NetSoftReboot ( )\n") );

    ASSERT(NextBootFile != NULL);

    //
    // Store the reboot parameters in memory.
    //
    restartBlock = (PTFTP_RESTART_BLOCK)(0x7C00 + 0x8000 - sizeof(TFTP_RESTART_BLOCK));
    RtlZeroMemory(restartBlock, sizeof(TFTP_RESTART_BLOCK));
    
    BlSetHeadlessRestartBlock(restartBlock);

    if (AdministratorPassword) {
        RtlMoveMemory(restartBlock->AdministratorPassword,AdministratorPassword, OSC_ADMIN_PASSWORD_LEN);        
    }

    restartBlockV1 = (PTFTP_RESTART_BLOCK_V1)(0x7C00 + 0x8000 - sizeof(TFTP_RESTART_BLOCK_V1));

    restartBlockV1->RebootParameter = Param;

    if (RebootFile != NULL) {
        strcpy(restartBlockV1->RebootFile, RebootFile);
    }

    if (SifFile != NULL) {
        strcpy(restartBlockV1->SifFile, SifFile);
    }

    if (User != NULL) {
        strcpy(restartBlockV1->User, User);
    }
    if (Domain != NULL) {
        strcpy(restartBlockV1->Domain, Domain);
    }
    if (Password != NULL) {
        strcpy(restartBlockV1->Password, Password);
    }

    //
    // Set the tag in the restart block and calculate and store the checksum.
    //
    restartBlockV1->Tag = 'rtsR';
    restartBlockV1->Checksum = CalculateChecksum((PLONG)(0x7C00 + 0x8000 - 128), 128);

    //
    // For all versions of RIS after NT5.0 we have a new datastructure which is
    // more adaptable for the future.  For this section we have a different checksum,
    // do that now.
    //
    restartBlock->TftpRestartBlockVersion = TFTP_RESTART_BLOCK_VERSION;
    restartBlock->NewCheckSumLength = FIELD_OFFSET(TFTP_RESTART_BLOCK, RestartBlockV1);
    restartBlock->NewCheckSum = CalculateChecksum((PLONG)restartBlock,
                                                  restartBlock->NewCheckSumLength);

    //
    // Modify the BINL reply that the ROM has stored so that
    // the file name looks like the one we are rebooting to
    // (this is so we can retrieve the path correctly after
    // reboot, so we know where to look for bootloader).
    //

    gbi.packet_type = PXENV_PACKET_TYPE_BINL_REPLY;
    gbi.buffer_size = 0;
    gbi.buffer_offset = 0;
    gbi.buffer_segment = 0;

    romStatus = NETPC_ROM_SERVICES( PXENV_GET_BINL_INFO, &gbi );
    if ( romStatus != PXENV_EXIT_SUCCESS ) {
        DPRINT( ERROR, ("PXENV_GET_BINL_INFO(1) failed with %x\n", romStatus) );
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Now convert the segment/offset to a pointer and modify the
    // filename.
    //

    packet = (BOOTPLAYER *)UIntToPtr( ((gbi.buffer_segment << 4) + gbi.buffer_offset) );

    RtlZeroMemory(packet->bootfile, sizeof(packet->bootfile));
    strcpy(packet->bootfile, NextBootFile);

    //
    // First tell the ROM to shut down its UDP layer.
    //

    RtlZeroMemory( &command, sizeof(command) );

    command.UdpClose.Status = 0;
    status = NETPC_ROM_SERVICES( PXENV_UDP_CLOSE, &command );
    if ( status != 0 ) {
        DPRINT( ERROR, ("NetSoftReboot: error %d from UDP_CLOSE\n", status) );
    }

    //
    // Now tell the ROM to reboot and do a TFTP read of the specified
    // file from the specifed server.
    //

    RtlZeroMemory( &command, sizeof(command) );

    command.TftpReadFile.BufferOffset = 0x7c00;  // standard boot image location
    // 32K (max size allowed) less area for passing parameters
    command.TftpReadFile.BufferSize = 0x8000 - sizeof(TFTP_RESTART_BLOCK);

    *(ULONG *)command.TftpReadFile.ServerIPAddress = NetServerIpAddress;

    //
    // Determine whether we need to send via the gateway.
    //

    if ( (NetServerIpAddress & NetLocalSubnetMask) == (NetLocalIpAddress & NetLocalSubnetMask) ) {
        *(UINT32 *)command.TftpReadFile.GatewayIPAddress = 0;
    } else {
        *(UINT32 *)command.TftpReadFile.GatewayIPAddress = NetGatewayIpAddress;
    }

    strcpy(command.TftpReadFile.FileName, NextBootFile);

    //
    // This should not return if it succeeds!
    //

    romStatus = NETPC_ROM_SERVICES( PXENV_RESTART_TFTP, &command );

    if ( (romStatus != 0) || (command.TftpReadFile.Status != 0) ) {

        DPRINT( ERROR, ("NetSoftReboot: Could not reboot to <%s>, %d/%d\n",
                NextBootFile, romStatus, command.TftpReadFile.Status) );
        status = STATUS_UNSUCCESSFUL;

    }

    return status;

}

VOID
NetGetRebootParameters(
    OUT PULONGLONG Param OPTIONAL,
    OUT PUCHAR RebootFile OPTIONAL,
    OUT PUCHAR SifFile OPTIONAL,
    OUT PUCHAR User OPTIONAL,
    OUT PUCHAR Domain OPTIONAL,
    OUT PUCHAR Password OPTIONAL,
    OUT PUCHAR AdministratorPassword OPTIONAL,
    BOOLEAN ClearRestartBlock
    )

/*++

Routine Description:

    This routine reads the reboot parameters from the TFTP_RESTART_BLOCK
    that ends at physical address 0x7c00 + 0x8000
    and returns them. (then clearing the address)

    0x7c00 is the base address for startrom.com
    0x8000 is the largest startrom.com allowed.
    then we reserve some space at the end for parameters.

Arguments:

    Param - Space for returning the value.

    RebootFile - Optional space for storing the file to reboot to when done here. (size >= char[128])

    SifFile - Optional space for storing a SIF file passed from whoever
        initiated the soft reboot.

    User/Domain/Password/AdministratorPassword - Optional space to store credentials passed across
        the soft reboot.

    ClearRestartBlock - If set to TRUE, it wipes out the memory here - should be done exactly once, at the
        last call to this function.

Return Value:

    None.

--*/

{
    PTFTP_RESTART_BLOCK restartBlock;
    PTFTP_RESTART_BLOCK_V1 restartBlockV1;
    TFTP_RESTART_BLOCK nullRestartBlock;
    BOOLEAN restartBlockValid;

    restartBlock = (PTFTP_RESTART_BLOCK)(0x7C00 + 0x8000 - sizeof(TFTP_RESTART_BLOCK));
    restartBlockV1 = (PTFTP_RESTART_BLOCK_V1)(0x7C00 + 0x8000 - sizeof(TFTP_RESTART_BLOCK_V1));

    //
    // See if the block is valid. If it's not, we create a temporary empty
    // one so the copy logic below doesn't have to keep checking.
    //

    if ((restartBlockV1->Tag == 'rtsR') &&
        (CalculateChecksum((PLONG)(0x7C00 + 0x8000 - 128), 128) == 0)) {
        restartBlockValid = TRUE;
    } else {
        restartBlockValid = FALSE;
        RtlZeroMemory( &nullRestartBlock, sizeof(TFTP_RESTART_BLOCK) );
        restartBlock = &nullRestartBlock;
    }


    //
    // Copy out the parameters that were in the original TFTP_RESTART_BLOCK structure.
    // These shipped in Win2K.
    //
    if (Param != NULL) {
        *Param = restartBlockV1->RebootParameter;
    }

    if (RebootFile != NULL) {
        memcpy(RebootFile, restartBlockV1->RebootFile, sizeof(restartBlockV1->RebootFile));
    }

    if (SifFile != NULL) {
        memcpy(SifFile, restartBlockV1->SifFile, sizeof(restartBlockV1->SifFile));
    }

    if (User != NULL) {
        strcpy(User, restartBlockV1->User);
    }
    if (Domain != NULL) {
        strcpy(Domain, restartBlockV1->Domain);
    }
    if (Password != NULL) {
        strcpy(Password, restartBlockV1->Password);
    }

    //
    // Now do a new check for all versions past Win2K
    //
    if (restartBlockValid) {

        ULONG RestartBlockChecksumPointer = 0;

        //
        // Figure out how much of the restart block needs to be checksumed.
        //
        RestartBlockChecksumPointer = (ULONG)restartBlockV1;
        RestartBlockChecksumPointer -= (restartBlock->NewCheckSumLength);
        RestartBlockChecksumPointer -= (sizeof(restartBlock->NewCheckSumLength));

        if ((restartBlock->NewCheckSumLength == 0) ||
            (CalculateChecksum((PLONG)(RestartBlockChecksumPointer), restartBlock->NewCheckSumLength) != 0)) {

            //
            // A pre-Win2K OsChooser has given us this block.  Clear out all fields
            // that are post-Win2K and continue.
            //
            RtlZeroMemory(restartBlock, FIELD_OFFSET(TFTP_RESTART_BLOCK, RestartBlockV1));

        }

    }

    //
    // Now extract the parameters from the block.
    //
    if (restartBlock->TftpRestartBlockVersion == TFTP_RESTART_BLOCK_VERSION) {
        BlGetHeadlessRestartBlock(restartBlock, restartBlockValid);

        if (AdministratorPassword) {
            RtlMoveMemory(AdministratorPassword,restartBlock->AdministratorPassword, OSC_ADMIN_PASSWORD_LEN);
        }
    }    

    if (restartBlockValid && ClearRestartBlock) {
        RtlZeroMemory(restartBlock, sizeof(TFTP_RESTART_BLOCK));
    }

    return;
}


ARC_STATUS
NetFillNetworkLoaderBlock (
    PNETWORK_LOADER_BLOCK NetworkLoaderBlock
    )
{
    SHORT status;
    t_PXENV_GET_BINL_INFO gbi;
    BOOTPLAYER packet;


    //
    // Get client IP address, server IP address, default gateway IP address,
    // and subnet mask from the DHCP ACK packet.
    //
    
    gbi.packet_type = PXENV_PACKET_TYPE_DHCP_ACK;
    gbi.buffer_size = sizeof(packet);
    gbi.buffer_offset = (USHORT)((ULONG_PTR)&packet & 0x0f);
    gbi.buffer_segment = (USHORT)(((ULONG_PTR)&packet >> 4) & 0xffff);

    status = NETPC_ROM_SERVICES( PXENV_GET_BINL_INFO, &gbi );
    if ( status != PXENV_EXIT_SUCCESS ) {
        DbgPrint("PXENV_GET_BINL_INFO(DHCPACK) failed with %x\n", status);
        return ENODEV;
    }

    NetworkLoaderBlock->DHCPServerACK = BlAllocateHeap(gbi.buffer_size);
    if (NetworkLoaderBlock->DHCPServerACK == NULL) {
        return ENOMEM;
    }

    memcpy( NetworkLoaderBlock->DHCPServerACK, &packet, gbi.buffer_size );
    NetworkLoaderBlock->DHCPServerACKLength = gbi.buffer_size;

    gbi.packet_type = PXENV_PACKET_TYPE_BINL_REPLY;
    gbi.buffer_size = sizeof(packet);
    gbi.buffer_offset = (USHORT)((ULONG_PTR)&packet & 0x0f);
    gbi.buffer_segment = (USHORT)(((ULONG_PTR)&packet >> 4) & 0xffff);

    status = NETPC_ROM_SERVICES( PXENV_GET_BINL_INFO, &gbi );
    if ( status != PXENV_EXIT_SUCCESS ) {
        DbgPrint("PXENV_GET_BINL_INFO(BINLREPLY) failed with %x\n", status);
    } else {

        NetworkLoaderBlock->BootServerReplyPacket = BlAllocateHeap(gbi.buffer_size);
        if (NetworkLoaderBlock->BootServerReplyPacket == NULL) {
            return ENOMEM;
        }

        memcpy( NetworkLoaderBlock->BootServerReplyPacket, &packet, gbi.buffer_size );
        NetworkLoaderBlock->BootServerReplyPacketLength = gbi.buffer_size;
    }

    return ESUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\nlsboot.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    nlsboot.c

Abstract:

    This module contains NLS routines for use by the OS Loader.  Before
    the NLS tables are loaded, they convert between ANSI and Unicode by
    zero-extending.

Author:

    John Vert (jvert) 11-Nov-1992

Revision History:

    John Vert (jvert) 11-Nov-1992
        created - mostly copied from old RTL routines

--*/
#include "bldr.h"

//
// Hack-o-rama string routines to use before tables are loaded
//

#define upcase(C) (WCHAR )(((C) >= 'a' && (C) <= 'z' ? (C) - ('a' - 'A') : (C)))


NTSTATUS
RtlAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

{
    ULONG UnicodeLength;
    ULONG Index;
    NTSTATUS st;

    UnicodeLength = (SourceString->Length << 1) + sizeof(UNICODE_NULL);

    if ( UnicodeLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength - sizeof(UNICODE_NULL));
    if ( AllocateDestinationString ) {
        return STATUS_NO_MEMORY;
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    Index = 0;
    while(Index < SourceString->Length ) {
        DestinationString->Buffer[Index] = (WCHAR)SourceString->Buffer[Index];
        Index++;
        }
    DestinationString->Buffer[Index] = UNICODE_NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
RtlUnicodeStringToAnsiString(
    OUT PANSI_STRING DestinationString,
    IN  PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

{
    ULONG AnsiLength;
    ULONG Index;
    NTSTATUS st;

    AnsiLength = SourceString->Length + 1;

    if ( AnsiLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(AnsiLength*2);
    if ( AllocateDestinationString ) {
        return STATUS_NO_MEMORY;
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    Index = 0;
    while(Index < SourceString->Length ) {
        DestinationString->Buffer[Index] = (CHAR)SourceString->Buffer[Index];
        Index++;
        }
    DestinationString->Buffer[Index] = TEXT('\0');

    return STATUS_SUCCESS;
}


LONG
RtlCompareUnicodeString(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlCompareUnicodeString function compares two counted strings.  The
    return value indicates if the strings are equal or String1 is less than
    String2 or String1 is greater than String2.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2


--*/

{

    UNALIGNED WCHAR *s1, *s2;
    USHORT n1, n2;
    WCHAR c1, c2;
    LONG cDiff;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = (USHORT )(String1->Length / sizeof(WCHAR));
    n2 = (USHORT )(String2->Length / sizeof(WCHAR));
    while (n1 && n2) {
        c1 = *s1++;
        c2 = *s2++;

        if (CaseInSensitive) {
            //
            // Note that this needs to reference the translation table !
            //
            c1 = upcase(c1);
            c2 = upcase(c2);
        }

        if ((cDiff = ((LONG)c1 - (LONG)c2)) != 0) {
            return( cDiff );
            }

        n1--;
        n2--;
        }

    return( n1 - n2 );
}

BOOLEAN
RtlEqualUnicodeString(
    IN const UNICODE_STRING *String1,
    IN const UNICODE_STRING *String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualUnicodeString function compares two counted unicode strings for
    equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{
    UNALIGNED WCHAR *s1, *s2;
    USHORT n1, n2;
    WCHAR c1, c2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = (USHORT )(String1->Length / sizeof(WCHAR));
    n2 = (USHORT )(String2->Length / sizeof(WCHAR));

    if ( n1 != n2 ) {
        return FALSE;
        }

    if (CaseInSensitive) {

        while ( n1 ) {

            if ( *s1++ != *s2++ ) {
                c1 = upcase(*(s1-1));
                c2 = upcase(*(s2-1));
                if (c1 != c2) {
                    return( FALSE );
                    }
                }
            n1--;
            }
        }
    else {

        while ( n1 ) {

            if (*s1++ != *s2++) {
                return( FALSE );
                }

            n1--;
            }
        }

    return TRUE;
}


VOID
RtlInitString(
    OUT PSTRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    DestinationString->Length = 0;
    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        while (*SourceString++) {
            DestinationString->Length++;
            }

        DestinationString->MaximumLength = (SHORT)(DestinationString->Length+1);
        }
    else {
        DestinationString->MaximumLength = 0;
        }
}


VOID
RtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    USHORT Length = 0;
    DestinationString->Length = 0;
    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        while (*SourceString++) {
            Length += sizeof(*SourceString);
            }

        DestinationString->Length = Length;

        DestinationString->MaximumLength = Length+(USHORT)sizeof(UNICODE_NULL);
        }
    else {
        DestinationString->MaximumLength = 0;
        }
}


VOID
RtlInitAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitAnsiString function initializes an NT counted
    ANSI string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated ANSI string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    USHORT Length = 0;
    DestinationString->Length = 0;
    DestinationString->Buffer = (PSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        while (*SourceString++) {
            Length += sizeof(*SourceString);
            }

        DestinationString->Length = Length;

        DestinationString->MaximumLength = Length+1;
        }
    else {
        DestinationString->MaximumLength = 0;
        }
}



NTSTATUS
RtlAppendUnicodeStringToString (
    IN OUT PUNICODE_STRING Destination,
    IN PCUNICODE_STRING Source
    )

/*++

Routine Description:

    This routine will concatinate two PSTRINGs together.  It will copy
    bytes from the source up to the MaximumLength of the destination.

Arguments:

    IN PSTRING Destination, - Supplies the destination string
    IN PSTRING Source - Supplies the source for the string copy

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n = Source->Length;
    UNALIGNED WCHAR *dst;

    if (n) {
        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        dst = &Destination->Buffer[ (Destination->Length / sizeof( WCHAR )) ];
        RtlMoveMemory( dst, Source->Buffer, n );

        Destination->Length += n;

        if (Destination->Length < Destination->MaximumLength) {
            dst[ n / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlAppendUnicodeToString (
    IN PUNICODE_STRING Destination,
    IN PCWSTR Source OPTIONAL
    )

/*++

Routine Description:

    This routine appends the supplied UNICODE string to an existing
    PUNICODE_STRING.

    It will copy bytes from the Source PSZ to the destination PSTRING up to
    the destinations PUNICODE_STRING->MaximumLength field.

Arguments:

    IN PUNICODE_STRING Destination, - Supplies a pointer to the destination
                            string
    IN PWSTR Source - Supplies the string to append to the destination

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n;
    UNALIGNED WCHAR *dst;

    if (ARGUMENT_PRESENT( Source )) {
        UNICODE_STRING UniSource;

        RtlInitUnicodeString(&UniSource, Source);

        n = UniSource.Length;

        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        dst = &Destination->Buffer[ (Destination->Length / sizeof( WCHAR )) ];
        RtlMoveMemory( dst, Source, n );

        Destination->Length += n;

        if (Destination->Length < Destination->MaximumLength) {
            dst[ n / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }

    return( STATUS_SUCCESS );
}

WCHAR
RtlUpcaseUnicodeChar(
    IN WCHAR SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified unicode character to its
    equivalent upcased unicode chararacter.  The purpose for this routine
    is to allow for character by character upcase translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies the unicode character to be upcased.

Return Value:

    Returns the upcased unicode equivalent of the specified input character.

--*/

{

    return (upcase(SourceCharacter));
}

WCHAR
RtlAnsiCharToUnicodeChar(
    IN OUT PUCHAR *SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified ansi character to unicode and
    returns the unicode value.  The purpose for this routine is to allow
    for character by character ansi to unicode translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies a pointer to an ansi character pointer.
        Through two levels of indirection, this supplies an ansi
        character that is to be translated to unicode.  After
        translation, the ansi character pointer is modified to point to
        the next character to be converted.  This is done to allow for
        dbcs ansi characters.

Return Value:

    Returns the unicode equivalent of the specified ansi character.

--*/

{
    WCHAR UnicodeCharacter;
    ULONG cbCharSize;
    NTSTATUS st;


    UnicodeCharacter = (WCHAR)**SourceCharacter;
    (*SourceCharacter)++;
    return(UnicodeCharacter);
}

NTSTATUS
RtlUpcaseUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions upper cases the specified unicode source string and
    converts it into an ansi string. The translation is done with respect
    to the ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        upper case of the unicode source string.  If the translation can
        not be done, an error is returned.

    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
        written to MultiByteString.  If this causes MultiByteString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

--*/

{
    ULONG TmpCount;
    ULONG LoopCount;
    ULONG CharsInUnicodeString;
    UCHAR SbChar;
    WCHAR UnicodeChar;
    ULONG i;

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
                 CharsInUnicodeString : MaxBytesInMultiByteString;

    if (ARGUMENT_PRESENT(BytesInMultiByteString))
        *BytesInMultiByteString = LoopCount;


    for (i=0;i<LoopCount;i++) {

        MultiByteString[i] = (UCHAR)RtlUpcaseUnicodeChar((UCHAR)(UnicodeString[i]));
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RtlMultiByteToUnicodeN(
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCSTR MultiByteString,
    IN ULONG BytesInMultiByteString)

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    ANSI Code Page (ACP) installed at boot time.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    UnicodeString - Returns a unicode string that is equivalent to
        the ansi source string.

    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
        written to UnicodeString.  If this causes UnicodeString to be a
        truncated equivalent of MultiByteString, no error condition results.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    MultiByteString - Supplies the ansi source string that is to be
        converted to unicode.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

Return Value:

    SUCCESS - The conversion was successful.


--*/

{
    ULONG LoopCount;
    PUSHORT TranslateTable;
    ULONG MaxCharsInUnicodeString;
    ULONG i;

    MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
                 MaxCharsInUnicodeString : BytesInMultiByteString;

    if (ARGUMENT_PRESENT(BytesInUnicodeString))
        *BytesInUnicodeString = LoopCount * sizeof(WCHAR);

    for (i=0;i<LoopCount;i++) {
        UnicodeString[i] = (WCHAR)((UCHAR)(MultiByteString[i]));
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
RtlUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.

    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
        written to MultiByteString.  If this causes MultiByteString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

--*/

{
    ULONG TmpCount;
    ULONG LoopCount;
    ULONG CharsInUnicodeString;
    UCHAR SbChar;
    WCHAR UnicodeChar;
    ULONG i;

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
                 CharsInUnicodeString : MaxBytesInMultiByteString;

    if (ARGUMENT_PRESENT(BytesInMultiByteString))
        *BytesInMultiByteString = LoopCount;


    for (i=0;i<LoopCount;i++) {
        MultiByteString[i] = (CHAR)(UnicodeString[i]);
    }

    return STATUS_SUCCESS;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\ntfsboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsBoot.c

Abstract:

    This module implements the Ntfs boot file system used by the operating system
    loader.

Author:

    Gary Kimura     [GaryKi]    10-April-1992

Revision History:

--*/

//
//  Stuff to get around the fact that we include both Fat, Hpfs, and Ntfs include
//  environments
//

#define _FAT_
#define _HPFS_
#define _CVF_

#define VBO ULONG
#define LBO ULONG
#define BIOS_PARAMETER_BLOCK ULONG
#define CVF_LAYOUT ULONG
#define CVF_HEADER ULONG
#define COMPONENT_LOCATION ULONG
#define PCVF_FAT_EXTENSIONS PCHAR

typedef struct DIRENT {
    char      Garbage[32];
} DIRENT;                                       //  sizeof = 32


#include "bootlib.h"
#include "stdio.h"
#include "blcache.h"

#include "bootstatus.h"

BOOTFS_INFO NtfsBootFsInfo={L"ntfs"};

#undef VBO
#undef LBO
#undef BIOS_PARAMETER_BLOCK
#undef DIRENT

#include "ntfs.h"

int Line = 0;

VOID NtfsPrint( IN PCHAR FormatString, ... )
{   va_list arglist; CHAR text[78+1]; ULONG Count,Length;

    va_start(arglist,FormatString);
    Length = _vsnprintf(text,sizeof(text),FormatString,arglist);
    text[78] = 0;
    ArcWrite(ARC_CONSOLE_OUTPUT,text,Length,&Count);
    va_end(arglist);
}

VOID NtfsGetChar(VOID) { UCHAR c; ULONG count; ArcRead(ARC_CONSOLE_INPUT,&c,1,&count); }

#define ReadConsole(c) {                                             \
    UCHAR Key=0; ULONG Count;                                        \
    while (Key != c) {                                               \
        if (ArcGetReadStatus(BlConsoleInDeviceId) == ESUCCESS) {     \
            ArcRead(BlConsoleInDeviceId, &Key, sizeof(Key), &Count); \
        }                                                            \
    }                                                                \
}

#define Pause   ReadConsole( ' ' )

#if FALSE
#define PausedPrint(x) {                                            \
    NtfsPrint x;                                                    \
    Line++;                                                         \
    if (Line >= 20) {                                               \
        NtfsPrint( ">" );                                           \
        Pause;                                                      \
        Line = 0;                                                   \
    }                                                               \
}
#else
#define PausedPrint(x)
#endif

#define ToUpper(C) ((((C) >= 'a') && ((C) <= 'z')) ? (C) - 'a' + 'A' : (C))

#define DereferenceFileRecord(idx) {                                \
    NtfsFileRecordBufferPinned[idx] -= 1;                           \
    if (NtfsFileRecordBufferPinned[idx] & 0xFF00) {                 \
        PausedPrint(( "NtfsFileRecordBufferPinned[%x]=%x\r\n",      \
                      idx, NtfsFileRecordBufferPinned[idx]));       \
    }                                                               \
}


//
//  Low level disk read routines
//

//
//  VOID
//  ReadDisk (
//      IN ULONG DeviceId,
//      IN LONGLONG Lbo,
//      IN ULONG ByteCount,
//      IN OUT PVOID Buffer,
//      IN BOOLEAN CacheNewData
//      );
//

ARC_STATUS
NtfsReadDisk (
    IN ULONG DeviceId,
    IN LONGLONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    );

#define ReadDisk(A,B,C,D,E) { ARC_STATUS _s;                     \
    if ((_s = NtfsReadDisk(A,B,C,D,E)) != ESUCCESS) {return _s;} \
}

//
//  Low level disk write routines
//
//
//  VOID
//  WriteDisk (
//      IN ULONG DeviceId,
//      IN LONGLONG Lbo,
//      IN ULONG ByteCount,
//      IN OUT PVOID Buffer
//      );
//

ARC_STATUS
NtfsWriteDisk (
    IN ULONG DeviceId,
    IN LONGLONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer
    );

#define WriteDisk(A,B,C,D) { ARC_STATUS _s;                     \
    if ((_s = NtfsWriteDisk(A,B,C,D)) != ESUCCESS) {return _s;} \
}

//
//  Attribute lookup and read routines
//
//
//  VOID
//  LookupAttribute (
//      IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN LONGLONG FileRecord,
//      IN ATTRIBUTE_TYPE_CODE TypeCode,
//      OUT PBOOLEAN FoundAttribute,
//      OUT PNTFS_ATTRIBUTE_CONTEXT AttributeContext
//      );
//
//  VOID
//  ReadAttribute (
//      IN PNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN PNTFS_ATTRIBUTE_CONTEXT AttributeContext,
//      IN VBO Vbo,
//      IN ULONG Length,
//      IN PVOID Buffer
//      );
//
//  VOID
//  ReadAndDecodeFileRecord (
//      IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN LONGLONG FileRecord,
//      OUT PULONG Index
//      );
//
//  VOID
//  DecodeUsa (
//      IN PVOID UsaBuffer,
//      IN ULONG Length
//      );
//

ARC_STATUS
NtfsLookupAttribute(
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN LONGLONG FileRecord,
    IN ATTRIBUTE_TYPE_CODE TypeCode,
    OUT PBOOLEAN FoundAttribute,
    OUT PNTFS_ATTRIBUTE_CONTEXT AttributeContext
    );

ARC_STATUS
NtfsReadResidentAttribute (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN ULONG Length,
    IN PVOID Buffer
    );

ARC_STATUS
NtfsReadNonresidentAttribute (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN ULONG Length,
    IN PVOID Buffer
    );

ARC_STATUS
NtfsWriteNonresidentAttribute (
    IN PNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN ULONG Length,
    IN PVOID Buffer
    );

ARC_STATUS
NtfsReadAndDecodeFileRecord (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN LONGLONG FileRecord,
    OUT PULONG Index
    );

ARC_STATUS
NtfsDecodeUsa (
    IN PVOID UsaBuffer,
    IN ULONG Length
    );

#define LookupAttribute(A,B,C,D,E) { ARC_STATUS _s;                     \
    if ((_s = NtfsLookupAttribute(A,B,C,D,E)) != ESUCCESS) {return _s;} \
}

#define ReadAttribute(A,B,C,D,E) { ARC_STATUS _s;                                    \
    if ((B)->IsAttributeResident) {                                                  \
        if ((_s = NtfsReadResidentAttribute(A,B,C,D,E)) != ESUCCESS) {return _s;}    \
    } else {                                                                         \
        if ((_s = NtfsReadNonresidentAttribute(A,B,C,D,E)) != ESUCCESS) {return _s;} \
    }                                                                                \
}

#define ReadAndDecodeFileRecord(A,B,C) { ARC_STATUS _s;                       \
    if ((_s = NtfsReadAndDecodeFileRecord(A,B,C)) != ESUCCESS) { return _s; } \
}

#define DecodeUsa(A,B) { ARC_STATUS _s;                     \
    if ((_s = NtfsDecodeUsa(A,B)) != ESUCCESS) {return _s;} \
}


//
//  Directory and index lookup routines
//
//
//  VOID
//  SearchForFileName (
//      IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN CSTRING FileName,
//      IN OUT PLONGLONG FileRecord,
//      OUT PBOOLEAN FoundFileName,
//      OUT PBOOLEAN IsDirectory
//      );
//
//  VOID
//  IsRecordAllocated (
//      IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN PCNTFS_ATTRIBUTE_CONTEXT AllocationBitmap,
//      IN ULONG BitOffset,
//      OUT PBOOLEAN IsAllocated
//      );
//

ARC_STATUS
NtfsSearchForFileName (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN OUT PLONGLONG FileRecord,
    OUT PBOOLEAN FoundFileName,
    OUT PBOOLEAN IsDirectory
    );

ARC_STATUS
NtfsIsRecordAllocated (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AllocationBitmap,
    IN ULONG BitOffset,
    OUT PBOOLEAN IsAllocated
    );

ARC_STATUS
NtfsLinearDirectoryScan(
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN OUT PLONGLONG FileRecord,
    OUT PBOOLEAN Found,
    OUT PBOOLEAN IsDirectory
    );

ARC_STATUS
NtfsInexactSortedDirectoryScan(
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN OUT PLONGLONG FileRecord,
    OUT PBOOLEAN Found,
    OUT PBOOLEAN IsDirectory
    );

#define SearchForFileName(A,B,C,D,E)                            \
{                                                               \
    ARC_STATUS _s;                                              \
    if ((_s = NtfsSearchForFileName(A,B,C,D,E)) != ESUCCESS) {  \
        return _s;                                              \
    }                                                           \
}

#define IsRecordAllocated(A,B,C,D)                              \
{                                                               \
    ARC_STATUS _s;                                              \
    if ((_s = NtfsIsRecordAllocated(A,B,C,D)) != ESUCCESS) {    \
        return _s;                                              \
    }                                                           \
}

#define LinearDirectoryScan(A,B,C,D,E)                          \
{                                                               \
    ARC_STATUS _s;                                              \
    if ((_s = NtfsLinearDirectoryScan(A,B,C,D,E)) != ESUCCESS) {\
        return _s;                                              \
    }                                                           \
}

#define InexactSortedDirectoryScan(A,B,C,D,E)                   \
{                                                               \
    ARC_STATUS _s;                                              \
    if ((_s = NtfsInexactSortedDirectoryScan(A,B,C,D,E)) != ESUCCESS) {\
        return _s;                                              \
    }                                                           \
}





//
//  Mcb support routines
//
//
//  VOID
//  LoadMcb (
//      IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
//      IN VBO Vbo,
//      IN PNTFS_MCB Mcb
//      );
//
//  VOID
//  VboToLbo (
//      IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
//      IN VBO Vbo,
//      OUT PLBO Lbo,
//      OUT PULONG ByteCount
//      );
//
//  VOID
//  DecodeRetrievalInformation (
//      IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN PNTFS_MCB Mcb,
//      IN VCN Vcn,
//      IN PATTRIBUTE_RECORD_HEADER AttributeHeader
//      );
//

ARC_STATUS
NtfsLoadMcb (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN PNTFS_MCB Mcb
    );

ARC_STATUS
NtfsVboToLbo (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG ByteCount
    );

ARC_STATUS
NtfsDecodeRetrievalInformation (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PNTFS_MCB Mcb,
    IN VCN Vcn,
    IN PATTRIBUTE_RECORD_HEADER AttributeHeader
    );

#define LoadMcb(A,B,C,D) { ARC_STATUS _s;                     \
    if ((_s = NtfsLoadMcb(A,B,C,D)) != ESUCCESS) {return _s;} \
}

#define VboToLbo(A,B,C,D,E) { ARC_STATUS _s;                     \
    if ((_s = NtfsVboToLbo(A,B,C,D,E)) != ESUCCESS) {return _s;} \
}

#define DecodeRetrievalInformation(A,B,C,D) { ARC_STATUS _s;                     \
    if ((_s = NtfsDecodeRetrievalInformation(A,B,C,D)) != ESUCCESS) {return _s;} \
}


//
//  Miscellaneous routines
//


VOID
NtfsFirstComponent (
    IN OUT PCSTRING String,
    OUT PCSTRING FirstComponent
    );

int
NtfsCompareName (
    IN CSTRING AnsiString,
    IN UNICODE_STRING UnicodeString
    );

VOID
NtfsInvalidateCacheEntries(
    IN ULONG DeviceId
    );
//
//  VOID
//  FileReferenceToLargeInteger (
//      IN PFILE_REFERENCE FileReference,
//      OUT PLONGLONG LargeInteger
//      );
//
//  VOID
//  InitializeAttributeContext (
//      IN PNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN PVOID FileRecordBuffer,
//      IN PVOID AttributeHeader,
//      IN LONGLONG FileRecord,
//      OUT PNTFS_ATTRIBUTE_CONTEXT AttributeContext
//      );
//

#define FileReferenceToLargeInteger(FR,LI) {     \
    *(LI) = *(PLONGLONG)&(FR);              \
    ((PFILE_REFERENCE)(LI))->SequenceNumber = 0; \
}

//
//**** note that the code to get the compression engine will need to change
//**** once the NTFS format changes
//

#define InitializeAttributeContext(SC,FRB,AH,FR,AC) {                        \
    (AC)->TypeCode = (AH)->TypeCode;                                         \
    (AC)->FileRecord = (FR);                                                 \
    (AC)->FileRecordOffset = (USHORT)PtrOffset((FRB),(AH));                  \
    if ((AC)->IsAttributeResident = ((AH)->FormCode == RESIDENT_FORM)) {     \
        (AC)->DataSize = /*xxFromUlong*/((AH)->Form.Resident.ValueLength);   \
    } else {                                                                 \
        (AC)->DataSize = (AH)->Form.Nonresident.FileSize;                    \
    }                                                                        \
    (AC)->CompressionFormat = COMPRESSION_FORMAT_NONE;                       \
    if ((AH)->Flags & ATTRIBUTE_FLAG_COMPRESSION_MASK) {                     \
        ULONG _i;                                                            \
        (AC)->CompressionFormat = COMPRESSION_FORMAT_LZNT1;                  \
        (AC)->CompressionUnit = (SC)->BytesPerCluster;                       \
        for (_i = 0; _i < (AH)->Form.Nonresident.CompressionUnit; _i += 1) { \
            (AC)->CompressionUnit *= 2;                                      \
        }                                                                    \
    }                                                                        \
}

#define FlagOn(Flags,SingleFlag) ((BOOLEAN)(((Flags) & (SingleFlag)) != 0))
#define SetFlag(Flags,SingleFlag) { (Flags) |= (SingleFlag); }
#define ClearFlag(Flags,SingleFlag) { (Flags) &= ~(SingleFlag); }

#define Add2Ptr(POINTER,INCREMENT) ((PVOID)((PUCHAR)(POINTER) + (INCREMENT)))
#define PtrOffset(BASE,OFFSET) ((ULONG)((ULONG_PTR)(OFFSET) - (ULONG_PTR)(BASE)))

#define Minimum(X,Y) ((X) < (Y) ? (X) : (Y))

#define IsCharZero(C)    (((C) & 0x000000ff) == 0x00000000)
#define IsCharLtrZero(C) (((C) & 0x00000080) == 0x00000080)

//
//  The following types and macros are used to help unpack the packed and misaligned
//   fields found in the Bios parameter block
//

typedef union _UCHAR1 { UCHAR  Uchar[1]; UCHAR  ForceAlignment; } UCHAR1, *PUCHAR1;
typedef union _UCHAR2 { UCHAR  Uchar[2]; USHORT ForceAlignment; } UCHAR2, *PUCHAR2;
typedef union _UCHAR4 { UCHAR  Uchar[4]; ULONG  ForceAlignment; } UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }


//
//  Define global data.
//

ULONG LastMcb = 0;
BOOLEAN FirstTime = TRUE;

//
//  File entry table - This is a structure that provides entry to the NTFS
//      file system procedures. It is exported when a NTFS file structure
//      is recognized.
//

BL_DEVICE_ENTRY_TABLE NtfsDeviceEntryTable;

//
//  These are the static buffers that we use when read file records and index
//  allocation buffers.  To save ourselves some extra reads we will identify the
//  current file record by its Vbo within the mft.
//

#define BUFFER_COUNT (64)

USHORT NtfsFileRecordBufferPinned[BUFFER_COUNT];
VBO NtfsFileRecordBufferVbo[BUFFER_COUNT];
PFILE_RECORD_SEGMENT_HEADER NtfsFileRecordBuffer[BUFFER_COUNT];

PINDEX_ALLOCATION_BUFFER NtfsIndexAllocationBuffer;

//
//  The following field are used to identify and store the cached
//  compressed buffer and its uncompressed equivalent.  The first
//  two fields identifies the attribute stream, and the third field
//  identifies the Vbo within the attribute stream that we have
//  cached.  The compressed and uncompressed buffer contains
//  the data.
//

LONGLONG NtfsCompressedFileRecord;
USHORT        NtfsCompressedOffset;
ULONG         NtfsCompressedVbo;

PUCHAR NtfsCompressedBuffer;
PUCHAR NtfsUncompressedBuffer;

UCHAR NtfsBuffer0[MAXIMUM_FILE_RECORD_SIZE+256];
UCHAR NtfsBuffer1[MAXIMUM_FILE_RECORD_SIZE+256];
UCHAR NtfsBuffer2[MAXIMUM_INDEX_ALLOCATION_SIZE+256];
UCHAR NtfsBuffer3[MAXIMUM_COMPRESSION_UNIT_SIZE+256];
UCHAR NtfsBuffer4[MAXIMUM_COMPRESSION_UNIT_SIZE+256];

//
//  The following is a simple prefix cache to speed up directory traversal
//

typedef struct {

    //
    //  DeviceId used to for I/O.  Serves as unique volume identifier
    //

    ULONG DeviceId;

    //
    //  Parent file record of entry
    //

    LONGLONG ParentFileRecord;

    //
    //  Name length and text of entry.  This is already uppercased!
    //

    ULONG NameLength;
    UCHAR RelativeName[32];

    //
    //  File record of name relative to parent
    //

    LONGLONG ChildFileRecord;
} NTFS_CACHE_ENTRY;

#define MAX_CACHE_ENTRIES   8
NTFS_CACHE_ENTRY NtfsLinkCache[MAX_CACHE_ENTRIES];
ULONG NtfsLinkCacheCount = 0;


PBL_DEVICE_ENTRY_TABLE
IsNtfsFileStructure (
    IN ULONG DeviceId,
    IN PVOID OpaqueStructureContext
    )

/*++

Routine Description:

    This routine determines if the partition on the specified channel contains an
    Ntfs file system volume.

Arguments:

    DeviceId - Supplies the file table index for the device on which read operations
        are to be performed.

    StructureContext - Supplies a pointer to a Ntfs file structure context.

Return Value:

    A pointer to the Ntfs entry table is returned if the partition is recognized as
    containing a Ntfs volume. Otherwise, NULL is returned.

--*/

{
    PNTFS_STRUCTURE_CONTEXT StructureContext = (PNTFS_STRUCTURE_CONTEXT)OpaqueStructureContext;

    PPACKED_BOOT_SECTOR BootSector;
    BIOS_PARAMETER_BLOCK Bpb;

    ULONG ClusterSize;
    ULONG FileRecordSize;

    PATTRIBUTE_RECORD_HEADER AttributeHeader;

    ULONG i;

    //
    //  Clear the file system context block for the specified channel and initialize
    //  the global buffer pointers that we use for buffering I/O
    //

    RtlZeroMemory(StructureContext, sizeof(NTFS_STRUCTURE_CONTEXT));

    //
    //  Zero out the pinned buffer array because we start with nothing pinned
    //  Also negate the vbo array to not let us get spooked with stale data
    //

    RtlZeroMemory( NtfsFileRecordBufferPinned, sizeof(NtfsFileRecordBufferPinned));
    for (i = 0; i < BUFFER_COUNT; i += 1) { NtfsFileRecordBufferVbo[i] = -1; }

    NtfsCompressedFileRecord = 0;
    NtfsCompressedOffset     = 0;
    NtfsCompressedVbo        = 0;

    //
    //  Set up a local pointer that we will use to read in the boot sector and check
    //  for an Ntfs partition.  We will temporarily use the global file record buffer
    //

    BootSector = (PPACKED_BOOT_SECTOR)NtfsFileRecordBuffer[0];

    //
    //  Now read in the boot sector and return null if we can't do the read
    //

    if (NtfsReadDisk(DeviceId, 0, sizeof(PACKED_BOOT_SECTOR), BootSector, CACHE_NEW_DATA) != ESUCCESS) {

        return NULL;
    }

    //
    //  Unpack the Bios parameter block
    //

    NtfsUnpackBios( &Bpb, &BootSector->PackedBpb );

    //
    //  Check if it is NTFS, by first checking the signature, then must be zero
    //  fields, then the media type, and then sanity check the non zero fields.
    //

    if (RtlCompareMemory( &BootSector->Oem[0], "NTFS    ", 8) != 8) {

        return NULL;
    }

    if ((Bpb.ReservedSectors != 0) ||
        (Bpb.Fats            != 0) ||
        (Bpb.RootEntries     != 0) ||
        (Bpb.Sectors         != 0) ||
        (Bpb.SectorsPerFat   != 0) ||
        (Bpb.LargeSectors    != 0)) {

        return NULL;
    }

    if ((Bpb.Media != 0xf0) &&
        (Bpb.Media != 0xf8) &&
        (Bpb.Media != 0xf9) &&
        (Bpb.Media != 0xfc) &&
        (Bpb.Media != 0xfd) &&
        (Bpb.Media != 0xfe) &&
        (Bpb.Media != 0xff)) {

        return NULL;
    }

    if ((Bpb.BytesPerSector !=  128) &&
        (Bpb.BytesPerSector !=  256) &&
        (Bpb.BytesPerSector !=  512) &&
        (Bpb.BytesPerSector != 1024) &&
        (Bpb.BytesPerSector != 2048)) {

        return NULL;
    }

    if ((Bpb.SectorsPerCluster !=  1) &&
        (Bpb.SectorsPerCluster !=  2) &&
        (Bpb.SectorsPerCluster !=  4) &&
        (Bpb.SectorsPerCluster !=  8) &&
        (Bpb.SectorsPerCluster != 16) &&
        (Bpb.SectorsPerCluster != 32) &&
        (Bpb.SectorsPerCluster != 64) &&
        (Bpb.SectorsPerCluster != 128)) {

        return NULL;
    }

    if ((BootSector->NumberSectors == 0) ||
        (BootSector->MftStartLcn == 0) ||
        (BootSector->Mft2StartLcn == 0) ||
        (BootSector->ClustersPerFileRecordSegment == 0) ||
        (BootSector->DefaultClustersPerIndexAllocationBuffer == 0)) {

        return NULL;
    }

    if ((BootSector->ClustersPerFileRecordSegment < 0) &&
        ((BootSector->ClustersPerFileRecordSegment > -9) ||
         (BootSector->ClustersPerFileRecordSegment < -31))) {

        return NULL;
    }

    //
    //  So far the boot sector has checked out to be an NTFS partition so now compute
    //  some of the volume constants.
    //

    StructureContext->DeviceId           = DeviceId;

    StructureContext->BytesPerCluster    =
    ClusterSize                          = Bpb.SectorsPerCluster * Bpb.BytesPerSector;

    //
    //  If the number of clusters per file record is less than zero then the file record
    //  size computed by using the negative of this number as a shift value.
    //

    if (BootSector->ClustersPerFileRecordSegment > 0) {

        StructureContext->BytesPerFileRecord =
        FileRecordSize                       = BootSector->ClustersPerFileRecordSegment * ClusterSize;

    } else {

        StructureContext->BytesPerFileRecord =
        FileRecordSize                       = 1 << (-1 * BootSector->ClustersPerFileRecordSegment);
    }

    //
    //  Read in the base file record for the mft
    //

    if (NtfsReadDisk( DeviceId,
                      /*xxXMul*/(BootSector->MftStartLcn * ClusterSize),
                      FileRecordSize,
                      NtfsFileRecordBuffer[0],
                      CACHE_NEW_DATA) != ESUCCESS) {

        return NULL;
    }

    //
    //  Decode Usa for the file record
    //

    if (NtfsDecodeUsa(NtfsFileRecordBuffer[0], FileRecordSize) != ESUCCESS) {

        return NULL;
    }

    //
    //  Make sure the file record is in use
    //

    if (!FlagOn(NtfsFileRecordBuffer[0]->Flags, FILE_RECORD_SEGMENT_IN_USE)) {

        return NULL;
    }

    //
    //  Search for the unnamed $data attribute header, if we reach $end then it is
    //  an error
    //

    for (AttributeHeader = NtfsFirstAttribute( NtfsFileRecordBuffer[0] );
         (AttributeHeader->TypeCode != $DATA) || (AttributeHeader->NameLength != 0);
         AttributeHeader = NtfsGetNextRecord( AttributeHeader )) {

        if (AttributeHeader->TypeCode == $END) {

            return NULL;
        }
    }

    //
    //  Make sure the $data attribute for the mft is non resident
    //

    if (AttributeHeader->FormCode != NONRESIDENT_FORM) {

        return NULL;
    }

    //
    //  Now set the mft structure context up for later use
    //

    InitializeAttributeContext( StructureContext,
                                NtfsFileRecordBuffer[0],
                                AttributeHeader,
                                0,
                                &StructureContext->MftAttributeContext );

    //
    //  Now decipher the part of the Mcb that is stored in the file record
    //

    if (NtfsDecodeRetrievalInformation( StructureContext,
                                        &StructureContext->MftBaseMcb,
                                        0,
                                        AttributeHeader ) != ESUCCESS) {

        return NULL;
    }

    //
    //  We have finished initializing the structure context so now Initialize the
    //  file entry table and return the address of the table.
    //

    NtfsDeviceEntryTable.Open               = NtfsOpen;
    NtfsDeviceEntryTable.Close              = NtfsClose;
    NtfsDeviceEntryTable.Read               = NtfsRead;
    NtfsDeviceEntryTable.Seek               = NtfsSeek;
    NtfsDeviceEntryTable.Write              = NtfsWrite;
    NtfsDeviceEntryTable.GetFileInformation = NtfsGetFileInformation;
    NtfsDeviceEntryTable.SetFileInformation = NtfsSetFileInformation;
    NtfsDeviceEntryTable.BootFsInfo = &NtfsBootFsInfo;

    return &NtfsDeviceEntryTable;
}


ARC_STATUS
NtfsClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    This routine closes the file specified by the file id.

Arguments:

    FileId - Supplies the file table index.

Return Value:

    ESUCCESS if returned as the function value.

--*/

{
    //
    //  Indicate that the file isn't open any longer
    //
    BlFileTable[FileId].Flags.Open = 0;

    //
    //  And return to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
NtfsGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    )

/*++

Routine Description:

    This procedure returns to the user a buffer filled with file information

Arguments:

    FileId - Supplies the File id for the operation

    Buffer - Supplies the buffer to receive the file information.  Note that
        it must be large enough to hold the full file name

Return Value:

    ESUCCESS is returned if the open operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PNTFS_STRUCTURE_CONTEXT StructureContext;
    PNTFS_FILE_CONTEXT FileContext;

    NTFS_ATTRIBUTE_CONTEXT AttributeContext;
    BOOLEAN Found;

    STANDARD_INFORMATION StandardInformation;

    ULONG i;

    //
    //  Setup some local references
    //

    FileTableEntry   = &BlFileTable[FileId];
    StructureContext = (PNTFS_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    FileContext      = &FileTableEntry->u.NtfsFileContext;

    //
    //  Zero out the output buffer and fill in its non-zero values
    //

    RtlZeroMemory(Buffer, sizeof(FILE_INFORMATION));

    Buffer->EndingAddress.QuadPart   = FileContext->DataSize;
    Buffer->CurrentPosition = FileTableEntry->Position;

    //
    //  Locate and read in the standard information for the file.  This will get us
    //  the attributes for the file.
    //

    LookupAttribute( StructureContext,
                     FileContext->FileRecord,
                     $STANDARD_INFORMATION,
                     &Found,
                     &AttributeContext );

    if (!Found) { return EBADF; }

    ReadAttribute( StructureContext,
                   &AttributeContext,
                   0,
                   sizeof(STANDARD_INFORMATION),
                   &StandardInformation );

    //
    //  Now check for set bits in the standard information structure and set the
    //  appropriate bits in the output buffer
    //

    if (FlagOn(StandardInformation.FileAttributes, FAT_DIRENT_ATTR_READ_ONLY))   {

        SetFlag(Buffer->Attributes, ArcReadOnlyFile);
    }

    if (FlagOn(StandardInformation.FileAttributes, FAT_DIRENT_ATTR_HIDDEN))      {

        SetFlag(Buffer->Attributes, ArcHiddenFile);
    }

    if (FlagOn(StandardInformation.FileAttributes, FAT_DIRENT_ATTR_SYSTEM))      {

        SetFlag(Buffer->Attributes, ArcSystemFile);
    }

    if (FlagOn(StandardInformation.FileAttributes, FAT_DIRENT_ATTR_ARCHIVE))     {

        SetFlag(Buffer->Attributes, ArcArchiveFile);
    }

    if (FlagOn(StandardInformation.FileAttributes, DUP_FILE_NAME_INDEX_PRESENT)) {

        SetFlag(Buffer->Attributes, ArcDirectoryFile);
    }

    //
    //  Get the file name from the file table entry
    //

    Buffer->FileNameLength = FileTableEntry->FileNameLength;

    for (i = 0; i < FileTableEntry->FileNameLength; i += 1) {

        Buffer->FileName[i] = FileTableEntry->FileName[i];
    }

    //
    //  And return to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
NtfsOpen (
    IN CHAR * FIRMWARE_PTR RWFileName,
    IN OPEN_MODE OpenMode,
    IN ULONG * FIRMWARE_PTR FileId
    )

/*++

Routine Description:

    This routine searches the root directory for a file matching FileName.
    If a match is found the dirent for the file is saved and the file is
    opened.

Arguments:

    FileName - Supplies a pointer to a zero terminated file name.

    OpenMode - Supplies the mode of the open.

    FileId - Supplies a pointer to a variable that specifies the file
        table entry that is to be filled in if the open is successful.

Return Value:

    ESUCCESS is returned if the open operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    const CHAR * FIRMWARE_PTR FileName = (const CHAR * FIRMWARE_PTR)RWFileName;
    PBL_FILE_TABLE FileTableEntry;
    PNTFS_STRUCTURE_CONTEXT StructureContext;
    PNTFS_FILE_CONTEXT FileContext;

    CSTRING PathName;
    CSTRING Name;

    LONGLONG FileRecord;
    BOOLEAN IsDirectory;
    BOOLEAN Found;

    PausedPrint(( "NtfsOpen(\"%s\")\r\n", FileName ));

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[*FileId];
    StructureContext = (PNTFS_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    FileContext = &FileTableEntry->u.NtfsFileContext;

    //
    //  Zero out the file context and position information in the file table entry
    //

    FileTableEntry->Position.QuadPart = 0;

    RtlZeroMemory(FileContext, sizeof(NTFS_FILE_CONTEXT));

    //
    //  Construct a file name descriptor from the input file name
    //

    RtlInitString( (PSTRING)&PathName, FileName );

    //
    //  Open the root directory as our starting point,  The root directory file
    //  reference number is 5.
    //

    FileRecord = 5;
    IsDirectory = TRUE;

    //
    //  While the path name has some characters left in it and current attribute
    //  context is a directory we will continue our search
    //

    while ((PathName.Length > 0) && IsDirectory) {

        //
        //  Extract the first component and search the directory for a match, but
        //  first copy the first part to the file name buffer in the file table entry
        //

        if (PathName.Buffer[0] == '\\') {

            PathName.Buffer +=1;
            PathName.Length -=1;
        }

        for (FileTableEntry->FileNameLength = 0;
             (((USHORT)FileTableEntry->FileNameLength < PathName.Length) &&
              (PathName.Buffer[FileTableEntry->FileNameLength] != '\\'));
             FileTableEntry->FileNameLength += 1) {

            FileTableEntry->FileName[FileTableEntry->FileNameLength] =
                                      PathName.Buffer[FileTableEntry->FileNameLength];
        }

        NtfsFirstComponent( &PathName, &Name );

        //
        //  Search for the name in the current directory
        //

        SearchForFileName( StructureContext,
                           Name,
                           &FileRecord,
                           &Found,
                           &IsDirectory );

        //
        //  If we didn't find it then we should get out right now
        //

        if (!Found) { return ENOENT; }
    }

    //
    //  At this point we have exhausted our pathname or we did not get a directory
    //  Check if we didn't get a directory and we still have a name to crack
    //

    if (PathName.Length > 0) {

        return ENOTDIR;
    }

    //
    //  Now FileRecord is the one we wanted to open.  Check the various open modes
    //  against what we have located
    //

    if (IsDirectory) {

        switch (OpenMode) {

        case ArcOpenDirectory:

            //
            //  To open the directory we will lookup the index root as our file
            //  context and then increment the appropriate counters.
            //

            LookupAttribute( StructureContext,
                             FileRecord,
                             $INDEX_ROOT,
                             &Found,
                             FileContext );

            if (!Found) { return EBADF; }

            FileTableEntry->Flags.Open = 1;
            FileTableEntry->Flags.Read = 1;

            return ESUCCESS;

        case ArcCreateDirectory:

            return EROFS;

        default:

            return EISDIR;
        }

    }

    switch (OpenMode) {

    case ArcOpenReadWrite:
        //
        // The only file allowed to be opened with write access is the hiberfil
        //
        if (!strstr(FileName, "\\hiberfil.sys") && 
            !strstr(FileName, BSD_FILE_NAME)) {
            return EROFS;
        }

        //
        //  To open the file we will lookup the $data as our file context and then
        //  increment the appropriate counters.
        //

        LookupAttribute( StructureContext,
                         FileRecord,
                         $DATA,
                         &Found,
                         FileContext );

        if (!Found) { return EBADF; }

        FileTableEntry->Flags.Open = 1;
        FileTableEntry->Flags.Read = 1;
        FileTableEntry->Flags.Write = 1;
        return ESUCCESS;

    case ArcOpenReadOnly:

        //
        //  To open the file we will lookup the $data as our file context and then
        //  increment the appropriate counters.
        //

        LookupAttribute( StructureContext,
                         FileRecord,
                         $DATA,
                         &Found,
                         FileContext );

        if (!Found) { return EBADF; }

        FileTableEntry->Flags.Open = 1;
        FileTableEntry->Flags.Read = 1;

        return ESUCCESS;

    case ArcOpenDirectory:

        return ENOTDIR;

    default:

        return EROFS;
    }
}


ARC_STATUS
NtfsRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    )

/*++

Routine Description:

    This routine reads data from the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that receives the data
        read.

    Length - Supplies the number of bytes that are to be read.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the read operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PNTFS_STRUCTURE_CONTEXT StructureContext;
    PNTFS_FILE_CONTEXT FileContext;

    LONGLONG AmountLeft;

    //
    //  Setup some local references
    //

    FileTableEntry = &BlFileTable[FileId];
    StructureContext = (PNTFS_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    FileContext = &FileTableEntry->u.NtfsFileContext;

    //
    //  Compute the amount left in the file and then from that we compute the amount
    //  for the transfer
    //

    AmountLeft = /*xxSub*/( FileContext->DataSize - FileTableEntry->Position.QuadPart);

    if (/*xxLeq*/(/*xxFromUlong*/(Length) <= AmountLeft)) {

        *Transfer = Length;

    } else {

        *Transfer = ((ULONG)AmountLeft);
    }

    //
    //  Now issue the read attribute
    //

    ReadAttribute( StructureContext,
                   FileContext,
                   FileTableEntry->Position.QuadPart,
                   *Transfer,
                   Buffer );

    //
    //  Update the current position, and return to our caller
    //

    FileTableEntry->Position.QuadPart = /*xxAdd*/(FileTableEntry->Position.QuadPart + /*xxFromUlong*/(*Transfer));

    return ESUCCESS;
}


ARC_STATUS
NtfsSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    This routine seeks to the specified position for the file specified
    by the file id.

Arguments:

    FileId - Supplies the file table index.

    Offset - Supplies the offset in the file to position to.

    SeekMode - Supplies the mode of the seek operation.

Return Value:

    ESUCCESS if returned as the function value.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    LONGLONG NewPosition;

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[FileId];

    //
    //  Compute the new position
    //

    if (SeekMode == SeekAbsolute) {

        NewPosition = Offset->QuadPart;

    } else {

        NewPosition = /*xxAdd*/(FileTableEntry->Position.QuadPart + Offset->QuadPart);
    }

    //
    //  If the new position is greater than the file size then return an error
    //

    if (/*xxGtr*/(NewPosition > FileTableEntry->u.NtfsFileContext.DataSize)) {

        return EINVAL;
    }

    //
    //  Otherwise set the new position and return to our caller
    //

    FileTableEntry->Position.QuadPart = NewPosition;

    return ESUCCESS;
}


ARC_STATUS
NtfsSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )

/*++

Routine Description:

    This routine sets the file attributes of the indicated file

Arguments:

    FileId - Supplies the File Id for the operation

    AttributeFlags - Supplies the value (on or off) for each attribute being modified

    AttributeMask - Supplies a mask of the attributes being altered.  All other
        file attributes are left alone.

Return Value:

    ESUCCESS is returned if the read operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    return EROFS;
}


ARC_STATUS
NtfsWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    )

/*++

Routine Description:

    This routine writes data to the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that contains the data
        written.

    Length - Supplies the number of bytes that are to be written.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the write operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PNTFS_STRUCTURE_CONTEXT StructureContext;
    PNTFS_FILE_CONTEXT FileContext;
    LONGLONG AmountLeft;
    ULONG Status;

    //
    //  Setup some local references
    //

    FileTableEntry = &BlFileTable[FileId];
    StructureContext = (PNTFS_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    FileContext = &FileTableEntry->u.NtfsFileContext;

    //
    //  Compute the amount left in the file and then from that we compute the amount
    //  for the transfer
    //

    AmountLeft = /*xxSub*/( FileContext->DataSize - FileTableEntry->Position.QuadPart);

    if (Length <= AmountLeft) {

        *Transfer = Length;

    } else {

        *Transfer = ((ULONG)AmountLeft);
    }

    //
    //  Now issue the write attribute
    //

    if (FileContext->IsAttributeResident) {
        return EROFS;
    }

    Status = NtfsWriteNonresidentAttribute(
                StructureContext,
                FileContext,
                FileTableEntry->Position.QuadPart,
                *Transfer,
                Buffer
                );

    if (Status != ESUCCESS) {
        return Status;
    }

    //
    //  Update the current position, and return to our caller
    //

    FileTableEntry->Position.QuadPart += *Transfer;
    return ESUCCESS;
}


ARC_STATUS
NtfsInitialize (
    VOID
    )

/*++

Routine Description:

    This routine initializes the ntfs boot filesystem.
    Currently this is a no-op.

Arguments:

    None.

Return Value:

    ESUCCESS.

--*/

{
    //
    //  The first time we will zero out the file record buffer and allocate
    //  a few buffers for read in data.
    //
    ARC_STATUS Status = ESUCCESS;
    ULONG Index = 0;
    
    RtlZeroMemory(NtfsLinkCache, sizeof(NtfsLinkCache));

    for (Index=0; Index < MAX_CACHE_ENTRIES; Index++) {
        NtfsLinkCache[Index].DeviceId = -1;
    }
    
    RtlZeroMemory( NtfsFileRecordBuffer, sizeof(NtfsFileRecordBuffer));

    NtfsFileRecordBuffer[0]   = ALIGN_BUFFER(NtfsBuffer0);
    NtfsFileRecordBuffer[1]   = ALIGN_BUFFER(NtfsBuffer1);
    NtfsIndexAllocationBuffer = ALIGN_BUFFER(NtfsBuffer2);
    NtfsCompressedBuffer      = ALIGN_BUFFER(NtfsBuffer3);
    NtfsUncompressedBuffer    = ALIGN_BUFFER(NtfsBuffer4);

#ifdef CACHE_DEVINFO

    Status = ArcRegisterForDeviceClose(NtfsInvalidateCacheEntries);

#endif // for CACHE_DEV_INFO

    return Status;    
}


//
//  Local support routine
//

ARC_STATUS
NtfsReadDisk (
    IN ULONG DeviceId,
    IN LONGLONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    )

/*++

Routine Description:

    This routine reads in zero or more bytes from the specified device.

Arguments:

    DeviceId - Supplies the device id to use in the arc calls.

    Lbo - Supplies the LBO to start reading from.

    ByteCount - Supplies the number of bytes to read.

    Buffer - Supplies a pointer to the buffer to read the bytes into.

    CacheNewData - Whether to cache new data read from the disk.

Return Value:

    ESUCCESS is returned if the read operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;
    ULONG i;

    //
    //  Special case the zero byte read request
    //

    if (ByteCount == 0) {

        return ESUCCESS;
    }

    //
    //  Issue the read through the cache.
    //

    Status = BlDiskCacheRead(DeviceId, 
                             (PLARGE_INTEGER)&Lbo, 
                             Buffer, 
                             ByteCount, 
                             &i,
                             CacheNewData); 

    if (Status != ESUCCESS) {

        return Status;
    }

    //
    //  Make sure we got back the amount requested
    //

    if (ByteCount != i) {

        return EIO;
    }

    //
    //  Everything is fine so return success to our caller
    //

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsWriteDisk (
    IN ULONG DeviceId,
    IN LONGLONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer
    )

/*++

Routine Description:

    This routine Writes in zero or more bytes from the specified device.

Arguments:

    DeviceId - Supplies the device id to use in the arc calls.

    Lbo - Supplies the LBO to start Writeing from.

    ByteCount - Supplies the number of bytes to Write.

    Buffer - Supplies a pointer to the buffer to Write the bytes into.

Return Value:

    ESUCCESS is returned if the Write operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    LARGE_INTEGER EndLbo;
    ARC_STATUS Status;
    ULONG i;

    //
    //  Special case the zero byte Write request
    //

    if (ByteCount == 0) {

        return ESUCCESS;
    }


    //
    //  Issue the write through the cache.
    //

    Status = BlDiskCacheWrite (DeviceId,
                               (PLARGE_INTEGER) &Lbo,
                               Buffer,
                               ByteCount,
                               &i);

    if (Status != ESUCCESS) {
        
        return Status;
    }

    //
    //  Make sure we got back the amount requested
    //

    if (ByteCount != i) {

        return EIO;
    }

    //
    //  Everything is fine so return success to our caller
    //

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsLookupAttribute (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN LONGLONG FileRecord,
    IN ATTRIBUTE_TYPE_CODE TypeCode,
    OUT PBOOLEAN FoundAttribute,
    OUT PNTFS_ATTRIBUTE_CONTEXT AttributeContext
    )

/*++

Routine Description:

    This routine search the input file record for the indicated
    attribute record.  It will search through multiple related
    file records to find the attribute.  If the type code is for $data
    then the attribute we look for must be unnamed otherwise we will
    ignore the names of the attributes and return the first attriubute
    of the indicated type.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    FileRecord - Supplies the file record to start searching from.  This need
        not be the base file record.

    TypeCode - Supplies the attribute type that we are looking for

    FoundAttribute - Receives an indicating if the attribute was located

    AttributeContext - Receives the attribute context for the found attribute

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PATTRIBUTE_RECORD_HEADER AttributeHeader;

    NTFS_ATTRIBUTE_CONTEXT AttributeContext1;
    PNTFS_ATTRIBUTE_CONTEXT AttributeList;

    LONGLONG li;
    ATTRIBUTE_LIST_ENTRY AttributeListEntry;

    ULONG BufferIndex;

    //
    //  Unless other noted we will assume we haven't found the attribute
    //

    *FoundAttribute = FALSE;

    //
    //  Read in the file record and if necessary move ourselves up to the base file
    //  record
    //

    ReadAndDecodeFileRecord( StructureContext,
                             FileRecord,
                             &BufferIndex );

    if (/*!xxEqlZero*/(*((PLONGLONG)&(NtfsFileRecordBuffer[BufferIndex]->BaseFileRecordSegment)) != 0)) {

        //
        //  This isn't the base file record so now extract the base file record
        //  number and read it in
        //

        FileReferenceToLargeInteger( NtfsFileRecordBuffer[BufferIndex]->BaseFileRecordSegment,
                                     &FileRecord );

        DereferenceFileRecord( BufferIndex );

        ReadAndDecodeFileRecord( StructureContext,
                                 FileRecord,
                                 &BufferIndex );
    }

    //
    //  Now we have read in the base file record so search for the target attribute
    //  type code and also remember if we find the attribute list attribute
    //

    AttributeList = NULL;

    for (AttributeHeader = NtfsFirstAttribute( NtfsFileRecordBuffer[BufferIndex] );
         AttributeHeader->TypeCode != $END;
         AttributeHeader = NtfsGetNextRecord( AttributeHeader )) {

        //
        //  We have located the attribute in question if the type code match and if
        //  it is either not the data attribute or if it is the data attribute then
        //  it is also unnamed
        //

        if ((AttributeHeader->TypeCode == TypeCode)

                    &&

            ((TypeCode != $DATA) ||
             ((TypeCode == $DATA) && (AttributeHeader->NameLength == 0)))

                    &&

            ((AttributeHeader->FormCode != NONRESIDENT_FORM) ||
             (AttributeHeader->Form.Nonresident.LowestVcn == 0))) {

            //
            //  Indicate that we have found the attribute and setup the output
            //  attribute context and then return to our caller
            //

            *FoundAttribute = TRUE;

            InitializeAttributeContext( StructureContext,
                                        NtfsFileRecordBuffer[BufferIndex],
                                        AttributeHeader,
                                        FileRecord,
                                        AttributeContext );

            DereferenceFileRecord( BufferIndex );

            return ESUCCESS;
        }

        //
        //  Check if this is the attribute list attribute and if so then setup a
        //  local attribute context to use just in case we don't find the attribute
        //  we're after in the base file record
        //

        if (AttributeHeader->TypeCode == $ATTRIBUTE_LIST) {

            InitializeAttributeContext( StructureContext,
                                        NtfsFileRecordBuffer[BufferIndex],
                                        AttributeHeader,
                                        FileRecord,
                                        AttributeList = &AttributeContext1 );
        }
    }

    //
    //  If we reach this point then the attribute has not been found in the base file
    //  record so check if we have located an attribute list.  If not then the search
    //  has not been successful
    //

    if (AttributeList == NULL) {

        DereferenceFileRecord( BufferIndex );

        return ESUCCESS;
    }

    //
    //  Now that we've located the attribute list we need to continue our search.  So
    //  what this outer loop does is search down the attribute list looking for a
    //  match.
    //

    for (li = 0;
         /*xxLtr*/(li < AttributeList->DataSize);
         li = /*xxAdd*/(li + /*xxFromUlong*/(AttributeListEntry.RecordLength))) {

        //
        //  Read in the attribute list entry.  We don't need to read in the name,
        //  just the first part of the list entry.
        //

        ReadAttribute( StructureContext,
                       AttributeList,
                       li,
                       sizeof(ATTRIBUTE_LIST_ENTRY),
                       &AttributeListEntry );

        //
        //  Now check if the attribute matches, and it is the first of multiple
        //  segments, and either it is not $data or if it is $data then it is unnamed
        //

        if ((AttributeListEntry.AttributeTypeCode == TypeCode)

                    &&

            /*xxEqlZero*/(AttributeListEntry.LowestVcn == 0)

                    &&

            ((TypeCode != $DATA) ||
             ((TypeCode == $DATA) && (AttributeListEntry.AttributeNameLength == 0)))) {

            //
            //  We found a match so now compute the file record containing the
            //  attribute we're after and read in the file record
            //

            FileReferenceToLargeInteger( AttributeListEntry.SegmentReference,
                                         &FileRecord );

            DereferenceFileRecord( BufferIndex );

            ReadAndDecodeFileRecord( StructureContext,
                                     FileRecord,
                                     &BufferIndex );

            //
            //  Now search down the file record for our matching attribute, and it
            //  better be there otherwise the attribute list is wrong.
            //

            for (AttributeHeader = NtfsFirstAttribute( NtfsFileRecordBuffer[BufferIndex] );
                 AttributeHeader->TypeCode != $END;
                 AttributeHeader = NtfsGetNextRecord( AttributeHeader )) {

                //
                //  We have located the attribute in question if the type code match
                //  and if it is either not the data attribute or if it is the data
                //  attribute then it is also unnamed
                //

                if ((AttributeHeader->TypeCode == TypeCode)

                            &&

                    ((TypeCode != $DATA) ||
                     ((TypeCode == $DATA) && (AttributeHeader->NameLength == 0)))) {

                    //
                    //  Indicate that we have found the attribute and setup the
                    //  output attribute context and return to our caller
                    //

                    *FoundAttribute = TRUE;

                    InitializeAttributeContext( StructureContext,
                                                NtfsFileRecordBuffer[BufferIndex],
                                                AttributeHeader,
                                                FileRecord,
                                                AttributeContext );

                    DereferenceFileRecord( BufferIndex );

                    return ESUCCESS;
                }
            }

            DereferenceFileRecord( BufferIndex );

            return EBADF;
        }
    }

    //
    //  If we reach this point we've exhausted the attribute list without finding the
    //  attribute
    //

    DereferenceFileRecord( BufferIndex );

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsReadResidentAttribute (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN ULONG Length,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This routine reads in the value of a resident attribute.  The attribute
    must be resident.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    AttributeContext - Supplies the attribute being read.

    Vbo - Supplies the offset within the value to return

    Length - Supplies the number of bytes to return

    Buffer - Supplies a pointer to the output buffer for storing the data

Return Value:

    ESUCCESS is returned if the read operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PATTRIBUTE_RECORD_HEADER AttributeHeader;

    ULONG BufferIndex;

    //
    //  Read in the file record containing the resident attribute
    //

    ReadAndDecodeFileRecord( StructureContext,
                             AttributeContext->FileRecord,
                             &BufferIndex );

    //
    //  Get a pointer to the attribute header
    //

    AttributeHeader = Add2Ptr( NtfsFileRecordBuffer[BufferIndex],
                               AttributeContext->FileRecordOffset );

    //
    //  Copy the amount of data the user asked for starting with the proper offset
    //

    RtlMoveMemory( Buffer,
                   Add2Ptr(NtfsGetValue(AttributeHeader), ((ULONG)Vbo)),
                   Length );

    //
    //  And return to our caller
    //

    DereferenceFileRecord( BufferIndex );

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsReadNonresidentAttribute (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN ULONG Length,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This routine reads in the value of a Nonresident attribute.  The attribute
    must be Nonresident.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    AttributeContext - Supplies the attribute being read.

    Vbo - Supplies the offset within the value to return

    Length - Supplies the number of bytes to return

    Buffer - Supplies a pointer to the output buffer for storing the data

Return Value:

    ESUCCESS is returned if the read operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    BOOLEAN bCacheNewData;

    //
    //  We want to cache new data read from the disk to satisfy this
    //  request only if we are reading the MFT, or $INDEX_ROOT,
    //  $BITMAP or $INDEX_ALLOCATION attributes for directory look
    //  up. $INDEX_ROOT is supposed to be resident in the file record
    //  but we want cache a read we make for it otherwise.
    //
    
    if ((AttributeContext == &StructureContext->MftAttributeContext) ||
        (AttributeContext->TypeCode == $INDEX_ROOT) ||
        (AttributeContext->TypeCode == $INDEX_ALLOCATION) ||
        (AttributeContext->TypeCode == $BITMAP)) {

        bCacheNewData = CACHE_NEW_DATA;

    } else {

        bCacheNewData = DONT_CACHE_NEW_DATA;

    }
    

    //
    //  Check if we are reading a compressed attribute
    //

    if (AttributeContext->CompressionFormat != 0) {

        //
        //  While there is still some more to copy into the
        //  caller's buffer, we will load the cached compressed buffers
        //  and then copy out the data
        //

        while (Length > 0) {

            ULONG ByteCount;

            //
            //  Load up the cached compressed buffers with the
            //  the proper data.  First check if the buffer is
            //  already (i.e., the file record and offset match and
            //  the vbo we're after is within the buffers range)
            //

            if (/*xxNeq*/(NtfsCompressedFileRecord != AttributeContext->FileRecord) ||
                (NtfsCompressedOffset != AttributeContext->FileRecordOffset)  ||
                (((ULONG)Vbo) < NtfsCompressedVbo)                             ||
                (((ULONG)Vbo) >= (NtfsCompressedVbo + AttributeContext->CompressionUnit))) {

                ULONG i;
                LBO Lbo;

                //
                //  Load up the cached identification information
                //

                NtfsCompressedFileRecord = AttributeContext->FileRecord;
                NtfsCompressedOffset = AttributeContext->FileRecordOffset;

                NtfsCompressedVbo = ((ULONG)Vbo) & ~(AttributeContext->CompressionUnit - 1);

                //
                //  Now load up the compressed buffer with data.  We keep on
                //  loading until we're done loading or the Lbo we get back is
                //  zero.
                //

                for (i = 0; i < AttributeContext->CompressionUnit; i += ByteCount) {

                    VboToLbo( StructureContext,
                              AttributeContext,
                              /*xxFromUlong*/(NtfsCompressedVbo + i),
                              &Lbo,
                              &ByteCount );

                    if (/*xxEqlZero*/(Lbo == 0)) { break; }

                    //
                    //  Trim the byte count down to a compression unit and we'll catch the
                    //  excess the next time through the loop
                    //

                    if ((i + ByteCount) > AttributeContext->CompressionUnit) {

                        ByteCount = AttributeContext->CompressionUnit - i;
                    }

                    ReadDisk( StructureContext->DeviceId, Lbo, ByteCount, &NtfsCompressedBuffer[i], bCacheNewData );
                }

                //
                //  If the index for the preceding loop is zero then we know
                //  that there isn't any data on disk for the compression unit
                //  and in-fact the compression unit is all zeros
                //

                if (i == 0) {

                    RtlZeroMemory( NtfsUncompressedBuffer, AttributeContext->CompressionUnit );

                //
                //  Otherwise the unit we just read in cannot be compressed
                //  because it completely fills up the compression unit
                //

                } else if (i >= AttributeContext->CompressionUnit) {

                    RtlMoveMemory( NtfsUncompressedBuffer,
                                   NtfsCompressedBuffer,
                                   AttributeContext->CompressionUnit );

                //
                //  If the index for the preceding loop is less then the
                //  compression unit size then we know that the data we
                //  read in is less than the compression unit and we hit
                //  a zero lbo.  So the unit must be compressed.
                //

                } else {

                    NTSTATUS Status;

                    Status = RtlDecompressBuffer( AttributeContext->CompressionFormat,
                                                  NtfsUncompressedBuffer,
                                                  AttributeContext->CompressionUnit,
                                                  NtfsCompressedBuffer,
                                                  i,
                                                  &ByteCount );

                    if (!NT_SUCCESS(Status)) {

                        return EINVAL;
                    }

                    //
                    //  Check if the decompressed buffer doesn't fill up the
                    //  compression unit and if so then zero out the remainder
                    //  of the uncompressed buffer
                    //

                    if (ByteCount < AttributeContext->CompressionUnit) {

                        RtlZeroMemory( &NtfsUncompressedBuffer[ByteCount],
                                       AttributeContext->CompressionUnit - ByteCount );
                    }
                }
            }

            //
            //  Now copy off the data from the compressed buffer to the
            //  user buffer and continue the loop until the length is zero.
            //  The amount of data we need to copy is the smaller of the
            //  length the user wants back or the number of bytes left in
            //  the uncompressed buffer from the requested vbo to the end
            //  of the buffer.
            //

            ByteCount = Minimum( Length,
                                 NtfsCompressedVbo + AttributeContext->CompressionUnit - ((ULONG)Vbo) );

            RtlMoveMemory( Buffer,
                           &NtfsUncompressedBuffer[ ((ULONG)Vbo) - NtfsCompressedVbo ],
                           ByteCount );

            //
            //  Update the length to be what the user now needs read in,
            //  also update the Vbo and Buffer to be the next locations
            //  to be read in.
            //

            Length -= ByteCount;
            Vbo = /*xxAdd*/( Vbo + /*xxFromUlong*/(ByteCount));
            Buffer = (PCHAR)Buffer + ByteCount;
        }

        return ESUCCESS;
    }

    //
    //  Read in runs of data until the byte count goes to zero
    //

    while (Length > 0) {

        LBO Lbo;
        ULONG CurrentRunByteCount;

        //
        //  Lookup the corresponding Lbo and run length for the current position
        //  (i.e., vbo)
        //

        VboToLbo( StructureContext,
                  AttributeContext,
                  Vbo,
                  &Lbo,
                  &CurrentRunByteCount );

        //
        //  While there are bytes to be read in from the current run length and we
        //  haven't exhausted the request we loop reading in bytes.  The biggest
        //  request we'll handle is only 32KB contiguous bytes per physical read.
        //  So we might need to loop through the run
        //

        while ((Length > 0) && (CurrentRunByteCount > 0)) {

            LONG SingleReadSize;

            //
            //  Compute the size of the next physical read
            //

            SingleReadSize = Minimum(Length, 32*1024);
            SingleReadSize = Minimum((ULONG)SingleReadSize, CurrentRunByteCount);

            //
            //  Don't read beyond the data size
            //

            if (/*xxGtr*/(/*xxAdd*/(Vbo + /*xxFromUlong*/(SingleReadSize)) > AttributeContext->DataSize )) {

                SingleReadSize = ((ULONG)(/*xxSub*/(AttributeContext->DataSize - Vbo)));

                //
                //  If the readjusted read length is now zero then we're done
                //

                if (SingleReadSize <= 0) {

                    return ESUCCESS;
                }

                //
                //  By also setting length we'll make sure that this is our last read
                //

                Length = SingleReadSize;
            }

            //
            //  Issue the read
            //

            ReadDisk( StructureContext->DeviceId, Lbo, SingleReadSize, Buffer, bCacheNewData );

            //
            //  Update the remaining length, current run byte count, and new lbo
            //  offset
            //

            Length -= SingleReadSize;
            CurrentRunByteCount -= SingleReadSize;
            Lbo = /*xxAdd*/(Lbo + /*xxFromUlong*/(SingleReadSize));
            Vbo = /*xxAdd*/(Vbo + /*xxFromUlong*/(SingleReadSize));

            //
            //  Update the buffer to point to the next byte location to fill in
            //

            Buffer = (PCHAR)Buffer + SingleReadSize;
        }
    }

    //
    //  If we get here then the remaining byte count is zero so we can return success
    //  to our caller
    //

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsWriteNonresidentAttribute (
    IN PNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN ULONG Length,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This routine write in the value of a Nonresident attribute.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    AttributeContext - Supplies the attribute being written

    Vbo - Supplies the offset within the value to return

    Length - Supplies the number of bytes to return

    Buffer - Supplies a pointer to the output buffer for storing the data

Return Value:

    ESUCCESS is returned if the write operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    //
    //  Check if we are writing a compressed attribute
    //

    if (AttributeContext->CompressionFormat != 0) {

        return EROFS;

    }

    //
    //  Write in runs of data until the byte count goes to zero
    //

    while (Length > 0) {

        LBO Lbo;
        ULONG CurrentRunByteCount;

        //
        //  Lookup the corresponding Lbo and run length for the current position
        //  (i.e., vbo)
        //

        VboToLbo( StructureContext,
                  AttributeContext,
                  Vbo,
                  &Lbo,
                  &CurrentRunByteCount );

        //
        //  While there are bytes to be written in from the current run length and we
        //  haven't exhausted the request we loop writing in bytes.  The biggest
        //  request we'll handle is only 32KB contiguous bytes per physical write.
        //  So we might need to loop through the run
        //

        while ((Length > 0) && (CurrentRunByteCount > 0)) {

            LONG SingleWriteSize;

            //
            //  Compute the size of the next physical written
            //

            SingleWriteSize = Minimum(Length, 32*1024);
            SingleWriteSize = Minimum((ULONG)SingleWriteSize, CurrentRunByteCount);

            //
            //  Don't write beyond the data size
            //

            if (/*xxGtr*/(/*xxAdd*/(Vbo + /*xxFromUlong*/(SingleWriteSize)) > AttributeContext->DataSize )) {

                SingleWriteSize = ((ULONG)(/*xxSub*/(AttributeContext->DataSize - Vbo)));

                //
                //  If the adjusted write length is now zero then we're done
                //

                if (SingleWriteSize <= 0) {

                    return ESUCCESS;
                }

                //
                //  By also setting length we'll make sure that this is our last write
                //

                Length = SingleWriteSize;
            }

            //
            //  Issue the write
            //

            WriteDisk( StructureContext->DeviceId, Lbo, SingleWriteSize, Buffer );

            //
            //  Update the remaining length, current run byte count, and new lbo
            //  offset
            //

            Length -= SingleWriteSize;
            CurrentRunByteCount -= SingleWriteSize;
            Lbo = /*xxAdd*/(Lbo + /*xxFromUlong*/(SingleWriteSize));
            Vbo = /*xxAdd*/(Vbo + /*xxFromUlong*/(SingleWriteSize));

            //
            //  Update the buffer to point to the next byte location to fill in
            //

            Buffer = (PCHAR)Buffer + SingleWriteSize;
        }
    }

    //
    //  If we get here then the remaining byte count is zero so we can return success
    //  to our caller
    //

    return ESUCCESS;
}



//
//  Local support routine
//


ARC_STATUS
NtfsReadAndDecodeFileRecord (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN LONGLONG FileRecord,
    OUT PULONG Index
    )

/*++

Routine Description:

    This routine reads in the specified file record into the indicated
    ntfs file record buffer index provided that the buffer is not pinned.
    It will also look at the current buffers and see if any will already
    satisfy the request or assign an unused buffer if necessary and
    fix Index to point to the right buffer

Arguments:

    StructureContext - Supplies the volume structure for this operation

    FileRecord - Supplies the file record number being read

    Index - Receives the index of where we put the buffer.  After this
        call the buffer is pinned and will need to be unpinned if it is
        to be reused.

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;

    //
    //  For each buffer that is not null check if we have a hit on the
    //  file record and if so then increment the pin count and return
    //  that index
    //

    for (*Index = 0; (*Index < BUFFER_COUNT) && (NtfsFileRecordBuffer[*Index] != NULL); *Index += 1) {

        if (NtfsFileRecordBufferVbo[*Index] == FileRecord) {

            NtfsFileRecordBufferPinned[*Index] += 1;
            return ESUCCESS;
        }
    }

    //
    //  Check for the first unpinned buffer and make sure we haven't exhausted the
    //  array
    //

    for (*Index = 0; (*Index < BUFFER_COUNT) && (NtfsFileRecordBufferPinned[*Index] != 0); *Index += 1) {

        NOTHING;
    }

    if (*Index == BUFFER_COUNT) { return E2BIG; }

    //
    //  We have an unpinned buffer that we want to use, check if we need to
    //  allocate a buffer to actually hold the data
    //

    PausedPrint(( "Reusing index %x for %I64x\r\n", *Index, FileRecord ));

    if (NtfsFileRecordBuffer[*Index] == NULL) {

        NtfsFileRecordBuffer[*Index] = BlAllocateHeapAligned(MAXIMUM_FILE_RECORD_SIZE);
    }

    //
    //  Pin the buffer and then read in the data
    //

    NtfsFileRecordBufferPinned[*Index] += 1;

    if ((Status = NtfsReadNonresidentAttribute( StructureContext,
                                                &StructureContext->MftAttributeContext,
                                                FileRecord * StructureContext->BytesPerFileRecord,
                                                StructureContext->BytesPerFileRecord,
                                                NtfsFileRecordBuffer[*Index] )) != ESUCCESS) {

        return Status;
    }

    //
    //  Decode the usa
    //

    if ((Status = NtfsDecodeUsa( NtfsFileRecordBuffer[*Index],
                                 StructureContext->BytesPerFileRecord )) != ESUCCESS) {

        return Status;
    }

    //
    //  And set the file record so that we know where it came from
    //

    NtfsFileRecordBufferVbo[*Index] = FileRecord;

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsDecodeUsa (
    IN PVOID UsaBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine takes as input file record or index buffer and applies the
    usa transformation to get it back into a state that we can use it.

Arguments:

    UsaBuffer - Supplies the buffer used in this operation

    Length - Supplies the length of the buffer in bytes

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PMULTI_SECTOR_HEADER MultiSectorHeader;

    PUSHORT UsaOffset;
    ULONG UsaSize;

    ULONG i;
    PUSHORT ProtectedUshort;

    //
    //  Setup our local variables
    //

    MultiSectorHeader = (PMULTI_SECTOR_HEADER)UsaBuffer;

    UsaOffset = Add2Ptr(UsaBuffer, MultiSectorHeader->UpdateSequenceArrayOffset);
    UsaSize = MultiSectorHeader->UpdateSequenceArraySize;

    //
    //  For every entry in the usa we need to compute the address of the protected
    //  ushort and then check that the protected ushort is equal to the current
    //  sequence number (i.e., the number at UsaOffset[0]) and then replace the
    //  protected ushort number with the saved ushort in the usa.
    //

    for (i = 1; i < UsaSize; i += 1) {

        ProtectedUshort = Add2Ptr( UsaBuffer,
                                   (SEQUENCE_NUMBER_STRIDE * i) - sizeof(USHORT));

        if (*ProtectedUshort != UsaOffset[0]) {

//            NtfsPrint( "USA Failure\r\n" );

            return EBADF;
        }

        *ProtectedUshort = UsaOffset[i];
    }

    //
    //  And return to our caller
    //

    return ESUCCESS;
}


//
//  Local support routine
//

BOOLEAN
NtfsIsNameCached (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN OUT PLONGLONG FileRecord,
    OUT PBOOLEAN Found,
    OUT PBOOLEAN IsDirectory
    )

/*++

Routine Description:

    This routine consults the cache for the given link.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    FileName - name of entry to look up

    FileRecord - IN file record of parent directory, OUT file record of child

    Found - whether we found this in the cache or not

Return Value:

    TRUE if the name was found in the cache.

--*/

{
    ULONG i, j;

    *Found = FALSE;

#ifdef CACHE_DEVINFO    

//    NtfsPrint( "Cache probe on %04x %I64x '%.*s'\r\n",
//               StructureContext->DeviceId,
//               *FileRecord,
//               FileName.Length,
//               FileName.Buffer );

    for (i = 0; i < MAX_CACHE_ENTRIES; i++) {
//        NtfsPrint( "Cache comparing to %04x %I64x '%.*s'\r\n",
//                   NtfsLinkCache[i].DeviceId,
//                   NtfsLinkCache[i].ParentFileRecord,
//                   NtfsLinkCache[i].NameLength,
//                   NtfsLinkCache[i].RelativeName );

        if (NtfsLinkCache[i].DeviceId == StructureContext->DeviceId &&
            NtfsLinkCache[i].ParentFileRecord == *FileRecord &&
            NtfsLinkCache[i].NameLength == FileName.Length) {

//            NtfsPrint( "Comparing names\r\n" );

            for (j = 0; j < FileName.Length; j++ ) {
                if (NtfsLinkCache[i].RelativeName[j] != ToUpper( (USHORT) FileName.Buffer[j] )) {
                    break;
                }
            }

            if (j == FileName.Length) {

                //
                //  Match
                //

//                NtfsPrint( "Cache hit\r\n" );

                *Found = TRUE;
                *FileRecord = NtfsLinkCache[i].ChildFileRecord;
                *IsDirectory = TRUE;

                break;
            }
        }
    }

#endif  // CACHE_DEVINFO    

    return *Found;
}



//
//  Local support routine
//

#ifdef CACHE_DEVINFO

VOID
NtfsInvalidateCacheEntries(
    IN ULONG DeviceId
    )
{
    ULONG i, Count = 0;


#if 0
    BlPrint("NtfsInvalidateCacheEntries() called for %d(%d)\r\n", 
            DeviceId,
            NtfsLinkCacheCount);
            
    while (!BlGetKey());    
#endif    
        
    for (i = 0; i < MAX_CACHE_ENTRIES; i++) {
        if (NtfsLinkCache[i].DeviceId == DeviceId) {
            NtfsLinkCache[i].DeviceId = -1;
            Count++;
        }
    }

    if (NtfsLinkCacheCount >= Count) {
        NtfsLinkCacheCount -= Count;
    } else {
        NtfsLinkCacheCount = 0;
    }        


#if 0
    BlPrint("NtfsInvalidateCacheEntries() called for %d(%d)\r\n", 
            DeviceId,
            NtfsLinkCacheCount);
            
    while (!BlGetKey());            
#endif    
}

#endif // CACHE_DEV_INFO

VOID
NtfsAddNameToCache (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN LONGLONG ParentFileRecord,
    IN LONGLONG FileRecord
    )

/*++

Routine Description:

    This routine adds a name and link to the name cache

Arguments:

    StructureContext - Supplies the volume structure for this operation

    FileName - Supplies the file name being cached (in ansi).

    ParentFileRecord - the file record of the parent

    FileRecord - file record associated with the name


Return Value:

    None.

--*/

{
#ifdef CACHE_DEVINFO

    if (NtfsLinkCacheCount < MAX_CACHE_ENTRIES) {
        ULONG i;
        ULONG Index;

        for (Index = 0; Index < MAX_CACHE_ENTRIES; Index++) {
            if (NtfsLinkCache[Index].DeviceId == -1) {
                break;
            }                
        }

        if (Index < MAX_CACHE_ENTRIES) {
            NtfsLinkCache[Index].DeviceId = StructureContext->DeviceId;
            NtfsLinkCache[Index].ParentFileRecord = ParentFileRecord;
            NtfsLinkCache[Index].NameLength = FileName.Length;
            
            for (i = 0; i < FileName.Length; i++) {
                NtfsLinkCache[Index].RelativeName[i] = ToUpper( FileName.Buffer[i] );
            }

            NtfsLinkCache[Index].ChildFileRecord = FileRecord;
            NtfsLinkCacheCount++;

            PausedPrint( ("Caching %04x %I64x %.*s %I64X\r\n",
                          StructureContext->DeviceId,
                          ParentFileRecord,
                          FileName.Length,
                          FileName.Buffer,
                          FileRecord ));
        }                                                
    } else {
//        NtfsPrint( "Cache is full at %I64x %.*s %I64X\r\n",
//                   ParentFileRecord,
//                   FileName.Length,
//                   FileName.Buffer,
//                   FileRecord );
//        Pause;

    }
    
#endif    
}


//
//  Local support routine
//

ARC_STATUS
NtfsSearchForFileName (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN OUT PLONGLONG FileRecord,
    OUT PBOOLEAN Found,
    OUT PBOOLEAN IsDirectory
    )

/*++

Routine Description:

    This routine searches a given index root and allocation for the specified
    file name.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    FileName - Supplies the file name being searched for (in ansi).

    FileRecord - Receives the file record for the entry if one was located.

    Found - Receives a value to indicate if we found the specified
        file name in the directory

    IsDirectory - Receives a value to indicate if the found index is itself
        a directory

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    LONGLONG ParentFileRecord;

    //
    //  Test to see if the file name is cached
    //

    if (NtfsIsNameCached( StructureContext, FileName, FileRecord, Found, IsDirectory )) {
        return ESUCCESS;
    }

    ParentFileRecord = *FileRecord;

    InexactSortedDirectoryScan( StructureContext, FileName, FileRecord, Found, IsDirectory );

    if (!*Found) {
        LinearDirectoryScan( StructureContext, FileName, FileRecord, Found, IsDirectory );
    }

    //
    //  If we have a directory entry, then add it to the cache
    //

    if (*Found && *IsDirectory) {
        NtfsAddNameToCache( StructureContext, FileName, ParentFileRecord, *FileRecord );
    }

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsInexactSortedDirectoryScan (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN OUT PLONGLONG FileRecord,
    OUT PBOOLEAN Found,
    OUT PBOOLEAN IsDirectory
    )

/*++

Routine Description:

    This routine searches a given index root and allocation for the specified
    file name by performing simple uppercasing and using that to wander through
    the directory tree.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    FileName - Supplies the file name being searched for (in ansi).

    FileRecord - Receives the file record for the entry if one was located.

    Found - Receives a value to indicate if we found the specified
        file name in the directory

    IsDirectory - Receives a value to indicate if the found index is itself
        a directory

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PATTRIBUTE_RECORD_HEADER IndexAttributeHeader;
    PINDEX_ROOT IndexRootValue;
    PINDEX_HEADER IndexHeader;

    NTFS_ATTRIBUTE_CONTEXT AttributeContext1;
    NTFS_ATTRIBUTE_CONTEXT AttributeContext2;
    NTFS_ATTRIBUTE_CONTEXT AttributeContext3;

    PNTFS_ATTRIBUTE_CONTEXT IndexRoot;
    PNTFS_ATTRIBUTE_CONTEXT IndexAllocation;
    PNTFS_ATTRIBUTE_CONTEXT AllocationBitmap;

    ULONG NextIndexBuffer;
    ULONG BytesPerIndexBuffer;

    ULONG BufferIndex;

    //
    //  The current file record must be a directory so now lookup the index root,
    //  allocation and bitmap for the directory and then we can do our search.
    //

//    NtfsPrint( "InexactSortedDirectoryScan %04x %I64x for '%.*s'\r\n",
//               StructureContext->DeviceId,
//               *FileRecord, FileName.Length, FileName.Buffer );
//    Pause;

    IndexRoot = &AttributeContext1;

    LookupAttribute( StructureContext,
                     *FileRecord,
                     $INDEX_ROOT,
                     Found,
                     IndexRoot);

    if (!*Found) { return EBADF; }

    IndexAllocation = &AttributeContext2;

    LookupAttribute( StructureContext,
                     *FileRecord,
                     $INDEX_ALLOCATION,
                     Found,
                     IndexAllocation);

    if (!*Found) { IndexAllocation = NULL; }

    AllocationBitmap = &AttributeContext3;

    LookupAttribute( StructureContext,
                     *FileRecord,
                     $BITMAP,
                     Found,
                     AllocationBitmap);

    if (!*Found) { AllocationBitmap = NULL; }

    //
    //  unless otherwise set we will assume that our search has failed
    //

    *Found = FALSE;

    //
    //  First read in and search the index root for the file name.  We know the index
    //  root is resident so we'll save some buffering and just read in file record
    //  with the index root directly
    //

    ReadAndDecodeFileRecord( StructureContext,
                             IndexRoot->FileRecord,
                             &BufferIndex );

    IndexAttributeHeader = Add2Ptr( NtfsFileRecordBuffer[BufferIndex],
                                    IndexRoot->FileRecordOffset );

    IndexRootValue = NtfsGetValue( IndexAttributeHeader );

    IndexHeader = &IndexRootValue->IndexHeader;

    //
    //  We also setup ourselves so that if the current index does not contain a match
    //  we will read in the next index and continue our search
    //

    BytesPerIndexBuffer = IndexRootValue->BytesPerIndexBuffer;

    //
    //  Now we'll just continue looping intil we either find a match or exhaust all
    //  of the index buffer
    //

    NextIndexBuffer = -1;
    while (TRUE) {

        PINDEX_ENTRY IndexEntry;
        BOOLEAN IsAllocated;
        VBO Vbo;

//        NtfsPrint( "Searching IndexBuffer %x\r\n", NextIndexBuffer );

        //
        //  Search the current index buffer (from index header looking for a match
        //

        for (IndexEntry = Add2Ptr(IndexHeader, IndexHeader->FirstIndexEntry);
             !FlagOn(IndexEntry->Flags, INDEX_ENTRY_END);
             IndexEntry = Add2Ptr(IndexEntry, IndexEntry->Length)) {

            PFILE_NAME FileNameEntry;
            UNICODE_STRING UnicodeFileName;
            int Result;

            //
            //  Get the FileName for this index entry
            //

            FileNameEntry = Add2Ptr(IndexEntry, sizeof(INDEX_ENTRY));

            UnicodeFileName.Length = FileNameEntry->FileNameLength * 2;
            UnicodeFileName.Buffer = &FileNameEntry->FileName[0];

            //
            //  Check if this the name we're after if it is then say we found it and
            //  setup the output variables
            //

            Result = NtfsCompareName( FileName, UnicodeFileName );
            if (Result == 0) {

                LONGLONG ParentFileRecord = *FileRecord;

                FileReferenceToLargeInteger( IndexEntry->FileReference,
                                             FileRecord );

                *Found = TRUE;
                *IsDirectory = FlagOn( FileNameEntry->Info.FileAttributes,
                                       DUP_FILE_NAME_INDEX_PRESENT);

//                NtfsPrint( "Found Entry %I64x\r\n", *FileRecord );

                DereferenceFileRecord( BufferIndex );

                return ESUCCESS;
            } else if (Result < 0) {
//                NtfsPrint( "Found > entry '%.*ws'\r\n", UnicodeFileName.Length, UnicodeFileName.Buffer );
                break;
            }
        }

        //
        //  At this point, we've either hit the end of the index or we have
        //  found the first entry larger than the name we're looking for.  In either case
        //  we may have a downpointer to examine.  If not, then there is no entry here.
        //

        //
        //  If no down pointer then release the file record buffer and quit
        //

        if (!FlagOn( IndexEntry->Flags, INDEX_ENTRY_NODE )) {
            DereferenceFileRecord( BufferIndex );

//            NtfsPrint( "No down pointer\r\n" );

            return ESUCCESS;
        }

        //
        //  At this point we've searched one index header and need to read in another
        //  one to check.  But first make sure there are additional index buffers
        //

        if (!ARGUMENT_PRESENT(IndexAllocation) ||
            !ARGUMENT_PRESENT(AllocationBitmap)) {

//            NtfsPrint( "No index allocation\r\n" );

            DereferenceFileRecord( BufferIndex );

            return ESUCCESS;
        }

        NextIndexBuffer = (ULONG)NtfsIndexEntryBlock( IndexEntry ) ;
        Vbo = NextIndexBuffer * StructureContext->BytesPerCluster;

        //
        //  Make sure the buffer offset is within the stream
        //

        if (Vbo >= IndexAllocation->DataSize) {

//            NtfsPrint( "Beyond end of stream %I64x %x\r\n", IndexAllocation->DataSize, NextIndexBuffer );

            DereferenceFileRecord( BufferIndex );

            return ESUCCESS;

        }

        //
        //  At this point we've computed the next index allocation buffer to read in
        //  so read it in, decode it, and go back to the top of our loop
        //

        ReadAttribute( StructureContext,
                       IndexAllocation,
                       Vbo,
                       BytesPerIndexBuffer,
                       NtfsIndexAllocationBuffer );

        DecodeUsa( NtfsIndexAllocationBuffer, BytesPerIndexBuffer );

        IndexHeader = &NtfsIndexAllocationBuffer->IndexHeader;
    }
}


//
//  Local support routine
//

ARC_STATUS
NtfsLinearDirectoryScan (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN OUT PLONGLONG FileRecord,
    OUT PBOOLEAN Found,
    OUT PBOOLEAN IsDirectory
    )

/*++

Routine Description:

    This routine searches a given index root and allocation for the specified
    file name by looking linearly through every entry.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    FileName - Supplies the file name being searched for (in ansi).

    FileRecord - Receives the file record for the entry if one was located.

    Found - Receives a value to indicate if we found the specified
        file name in the directory

    IsDirectory - Receives a value to indicate if the found index is itself
        a directory

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PATTRIBUTE_RECORD_HEADER IndexAttributeHeader;
    PINDEX_ROOT IndexRootValue;
    PINDEX_HEADER IndexHeader;

    NTFS_ATTRIBUTE_CONTEXT AttributeContext1;
    NTFS_ATTRIBUTE_CONTEXT AttributeContext2;
    NTFS_ATTRIBUTE_CONTEXT AttributeContext3;

    PNTFS_ATTRIBUTE_CONTEXT IndexRoot;
    PNTFS_ATTRIBUTE_CONTEXT IndexAllocation;
    PNTFS_ATTRIBUTE_CONTEXT AllocationBitmap;

    ULONG NextIndexBuffer;
    ULONG BytesPerIndexBuffer;

    ULONG BufferIndex;

    //
    //  The current file record must be a directory so now lookup the index root,
    //  allocation and bitmap for the directory and then we can do our search.
    //

//    NtfsPrint( "LinearSearching %04x %I64x for %.*s\r\n",
//               StructureContext->DeviceId,
//               *FileRecord, FileName.Length, FileName.Buffer );
//    Pause;

    IndexRoot = &AttributeContext1;

    LookupAttribute( StructureContext,
                     *FileRecord,
                     $INDEX_ROOT,
                     Found,
                     IndexRoot);

    if (!*Found) { return EBADF; }

    IndexAllocation = &AttributeContext2;

    LookupAttribute( StructureContext,
                     *FileRecord,
                     $INDEX_ALLOCATION,
                     Found,
                     IndexAllocation);

    if (!*Found) { IndexAllocation = NULL; }

    AllocationBitmap = &AttributeContext3;

    LookupAttribute( StructureContext,
                     *FileRecord,
                     $BITMAP,
                     Found,
                     AllocationBitmap);

    if (!*Found) { AllocationBitmap = NULL; }

    //
    //  unless otherwise set we will assume that our search has failed
    //

    *Found = FALSE;

    //
    //  First read in and search the index root for the file name.  We know the index
    //  root is resident so we'll save some buffering and just read in file record
    //  with the index root directly
    //

    ReadAndDecodeFileRecord( StructureContext,
                             IndexRoot->FileRecord,
                             &BufferIndex );

    IndexAttributeHeader = Add2Ptr( NtfsFileRecordBuffer[BufferIndex],
                                    IndexRoot->FileRecordOffset );

    IndexRootValue = NtfsGetValue( IndexAttributeHeader );

    IndexHeader = &IndexRootValue->IndexHeader;

    //
    //  We also setup ourselves so that if the current index does not contain a match
    //  we will read in the next index and continue our search
    //

    NextIndexBuffer = 0;

    BytesPerIndexBuffer = IndexRootValue->BytesPerIndexBuffer;

    //
    //  Now we'll just continue looping intil we either find a match or exhaust all
    //  of the index buffer
    //

    while (TRUE) {

        PINDEX_ENTRY IndexEntry;
        BOOLEAN IsAllocated;
        VBO Vbo;

        //
        //  Search the current index buffer (from index header looking for a match
        //

        for (IndexEntry = Add2Ptr(IndexHeader, IndexHeader->FirstIndexEntry);
             !FlagOn(IndexEntry->Flags, INDEX_ENTRY_END);
             IndexEntry = Add2Ptr(IndexEntry, IndexEntry->Length)) {

            PFILE_NAME FileNameEntry;
            UNICODE_STRING UnicodeFileName;

            //
            //  Get the FileName for this index entry
            //

            FileNameEntry = Add2Ptr(IndexEntry, sizeof(INDEX_ENTRY));

            UnicodeFileName.Length = FileNameEntry->FileNameLength * 2;
            UnicodeFileName.Buffer = &FileNameEntry->FileName[0];

            //
            //  Check if this the name we're after if it is then say we found it and
            //  setup the output variables
            //

            if (NtfsCompareName( FileName, UnicodeFileName ) == 0) {

                LONGLONG ParentFileRecord = *FileRecord;

                FileReferenceToLargeInteger( IndexEntry->FileReference,
                                             FileRecord );

                *Found = TRUE;
                *IsDirectory = FlagOn( FileNameEntry->Info.FileAttributes,
                                       DUP_FILE_NAME_INDEX_PRESENT);

                DereferenceFileRecord( BufferIndex );

                return ESUCCESS;
            }
        }

        //
        //  At this point we've searched one index header and need to read in another
        //  one to check.  But first make sure there are additional index buffers
        //

        if (!ARGUMENT_PRESENT(IndexAllocation) ||
            !ARGUMENT_PRESENT(AllocationBitmap)) {

            DereferenceFileRecord( BufferIndex );

            return ESUCCESS;
        }

        //
        //  Now the following loop reads in the valid index buffer.  The variable
        //  next index buffer denotes the buffer we want to read in.  The idea is to
        //  first check that the buffer is part of the index allocation otherwise
        //  we've exhausted the list without finding a match.  Once we know the
        //  allocation exists then we check if the record is really allocated if it
        //  is not allocated we try the next buffer and so on.
        //

        IsAllocated = FALSE;

        while (!IsAllocated) {

            //
            //  Compute the starting vbo of the next index buffer and check if it is
            //  still within the data size.
            //

            Vbo = (BytesPerIndexBuffer * NextIndexBuffer);

            if (Vbo >= IndexAllocation->DataSize) {

                DereferenceFileRecord( BufferIndex );

                return ESUCCESS;

            }

            //
            //  Now check if the index buffer is in use
            //

            IsRecordAllocated( StructureContext,
                               AllocationBitmap,
                               NextIndexBuffer,
                               &IsAllocated );

            NextIndexBuffer += 1;
        }

        //
        //  At this point we've computed the next index allocation buffer to read in
        //  so read it in, decode it, and go back to the top of our loop
        //

        ReadAttribute( StructureContext,
                       IndexAllocation,
                       Vbo,
                       BytesPerIndexBuffer,
                       NtfsIndexAllocationBuffer );

        DecodeUsa( NtfsIndexAllocationBuffer, BytesPerIndexBuffer );

        IndexHeader = &NtfsIndexAllocationBuffer->IndexHeader;
    }
}


//
//  Local support routine
//

ARC_STATUS
NtfsIsRecordAllocated (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AllocationBitmap,
    IN ULONG BitOffset,
    OUT PBOOLEAN IsAllocated
    )

/*++

Routine Description:

    This routine indicates to the caller if the specified index allocation record
    is in use (i.e., its bit is 1).

Arguments:

    StructureContext - Supplies the volume structure for this operation

    AllocationBitmap - Supplies the attribute context for the index allocation bitmap

    BitOffset - Supplies the offset (zero based) being checked

    IsAllocated - Recieves an value indicating if the record is allocated or not

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ULONG ByteIndex;
    ULONG BitIndex;
    UCHAR LocalByte;

    //
    //  This routine is rather dumb in that it only reads in the byte that contains
    //  the bit we're interested in and doesn't keep any state information between
    //  calls.  We first break down the bit offset into the byte and bit within
    //  the byte that we need to check
    //

    ByteIndex = BitOffset / 8;
    BitIndex = BitOffset % 8;

    //
    //  Read in a single byte containing the bit we need to check
    //

    ReadAttribute( StructureContext,
                   AllocationBitmap,
                   /*xxFromUlong*/(ByteIndex),
                   1,
                   &LocalByte );

    //
    //  Shift over the local byte so that the bit we want is in the low order bit and
    //  then mask it out to see if the bit is set
    //

    if (FlagOn(LocalByte >> BitIndex, 0x01)) {

        *IsAllocated = TRUE;

    } else {

        *IsAllocated = FALSE;
    }

    //
    //  And return to our caller
    //

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsLoadMcb (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN PNTFS_MCB Mcb
    )

/*++

Routine Description:

    This routine loads into one of the cached mcbs the retrival information for the
    starting vbo.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    AttributeContext - Supplies the Nonresident attribute being queried

    Vbo - Supplies the starting Vbo to use when loading the mcb

    Mcb - Supplies the mcb that we should be loading

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PATTRIBUTE_RECORD_HEADER AttributeHeader;

    ULONG BytesPerCluster;

    VBO LowestVbo;
    VBO HighestVbo;

    LONGLONG FileRecord;

    NTFS_ATTRIBUTE_CONTEXT AttributeContext1;
    PNTFS_ATTRIBUTE_CONTEXT AttributeList;

    LONGLONG li;
    LONGLONG Previousli;
    ATTRIBUTE_LIST_ENTRY AttributeListEntry;

    ATTRIBUTE_TYPE_CODE TypeCode;

    ULONG BufferIndex;
    ULONG SavedBufferIndex;

    //
    //  Load our local variables
    //

    BytesPerCluster = StructureContext->BytesPerCluster;

    //
    //  Setup a pointer to the cached mcb, indicate the attribute context that is will
    //  now own the cached mcb, and zero out the mcb
    //

    Mcb->InUse = 0;

    //
    //  Read in the file record that contains the non-resident attribute and get a
    //  pointer to the attribute header
    //

    ReadAndDecodeFileRecord( StructureContext,
                             AttributeContext->FileRecord,
                             &BufferIndex );

    AttributeHeader = Add2Ptr( NtfsFileRecordBuffer[BufferIndex],
                               AttributeContext->FileRecordOffset );

    //
    //  Compute the lowest and highest vbo that is described by this attribute header
    //

    LowestVbo  = AttributeHeader->Form.Nonresident.LowestVcn * BytesPerCluster;

    HighestVbo = ((AttributeHeader->Form.Nonresident.HighestVcn + 1) * BytesPerCluster) - 1;

    //
    //  Now check if the vbo we are after is within the range of this attribute header
    //  and if so then decode the retrieval information and return to our caller
    //

    if ((LowestVbo <= Vbo) && (Vbo <= HighestVbo)) {

        DecodeRetrievalInformation( StructureContext, Mcb, Vbo, AttributeHeader );

        DereferenceFileRecord( BufferIndex );

        return ESUCCESS;
    }

    //
    //  At this point the attribute header does not contain the range we need so read
    //  in the base file record and we'll search the attribute list for a attribute
    //  header that we need.  We need to make sure that we don't already have the base FRS.
    //  If we do, then we just continue using it.
    //

    if (/*!xxEqlZero*/(*((PLONGLONG)&(NtfsFileRecordBuffer[BufferIndex]->BaseFileRecordSegment)) != 0)) {

        FileReferenceToLargeInteger( NtfsFileRecordBuffer[BufferIndex]->BaseFileRecordSegment,
                                     &FileRecord );

        DereferenceFileRecord( BufferIndex );

        ReadAndDecodeFileRecord( StructureContext,
                                 FileRecord,
                                 &BufferIndex );

    } else {

        FileRecord = NtfsFileRecordBufferVbo[BufferIndex];
    }

    //
    //  Now we have read in the base file record so search for the attribute list
    //  attribute
    //

    AttributeList = NULL;

    for (AttributeHeader = NtfsFirstAttribute( NtfsFileRecordBuffer[BufferIndex] );
         AttributeHeader->TypeCode != $END;
         AttributeHeader = NtfsGetNextRecord( AttributeHeader )) {

        //
        //  Check if this is the attribute list attribute and if so then setup a local
        //  attribute context
        //

        if (AttributeHeader->TypeCode == $ATTRIBUTE_LIST) {

            InitializeAttributeContext( StructureContext,
                                        NtfsFileRecordBuffer[BufferIndex],
                                        AttributeHeader,
                                        FileRecord,
                                        AttributeList = &AttributeContext1 );
        }
    }

    //
    //  We have better located an attribute list otherwise we're in trouble
    //

    if (AttributeList == NULL) {

        DereferenceFileRecord( BufferIndex );

        return EINVAL;
    }

    //
    //  Setup a local for the type code
    //

    TypeCode = AttributeContext->TypeCode;

    //
    //  Now that we've located the attribute list we need to continue our search.  So
    //  what this outer loop does is search down the attribute list looking for a
    //  match.
    //

    NtfsFileRecordBufferPinned[SavedBufferIndex = BufferIndex] += 1;

    for (Previousli = li = 0;
         /*xxLtr*/(li < AttributeList->DataSize);
         li = /*xxAdd*/(li + /*xxFromUlong*/(AttributeListEntry.RecordLength))) {

        //
        //  Read in the attribute list entry.  We don't need to read in the name,
        //  just the first part of the list entry.
        //

        ReadAttribute( StructureContext,
                       AttributeList,
                       li,
                       sizeof(ATTRIBUTE_LIST_ENTRY),
                       &AttributeListEntry );

        //
        //  Now check if the attribute matches, and either it is not $data or if it
        //  is $data then it is unnamed
        //

        if ((AttributeListEntry.AttributeTypeCode == TypeCode)

                    &&

            ((TypeCode != $DATA) ||
             ((TypeCode == $DATA) && (AttributeListEntry.AttributeNameLength == 0)))) {

            //
            //  If the lowest vcn is is greater than the vbo we've after then
            //  we are done and can use previous li otherwise set previous li accordingly.

            if (Vbo < AttributeListEntry.LowestVcn * BytesPerCluster) {

                break;
            }

            Previousli = li;
        }
    }

    //
    //  Now we should have found the offset for the attribute list entry
    //  so read it in and verify that it is correct
    //

    ReadAttribute( StructureContext,
                   AttributeList,
                   Previousli,
                   sizeof(ATTRIBUTE_LIST_ENTRY),
                   &AttributeListEntry );

    if ((AttributeListEntry.AttributeTypeCode == TypeCode)

                &&

        ((TypeCode != $DATA) ||
         ((TypeCode == $DATA) && (AttributeListEntry.AttributeNameLength == 0)))) {

        //
        //  We found a match so now compute the file record containing this
        //  attribute and read in the file record
        //

        FileReferenceToLargeInteger( AttributeListEntry.SegmentReference, &FileRecord );

        DereferenceFileRecord( BufferIndex );

        ReadAndDecodeFileRecord( StructureContext,
                                 FileRecord,
                                 &BufferIndex );

        //
        //  Now search down the file record for our matching attribute, and it
        //  better be there otherwise the attribute list is wrong.
        //

        for (AttributeHeader = NtfsFirstAttribute( NtfsFileRecordBuffer[BufferIndex] );
             AttributeHeader->TypeCode != $END;
             AttributeHeader = NtfsGetNextRecord( AttributeHeader )) {

            //
            //  As a quick check make sure that this attribute is non resident
            //

            if (AttributeHeader->FormCode == NONRESIDENT_FORM) {

                //
                //  Compute the range of this attribute header
                //

                LowestVbo  = AttributeHeader->Form.Nonresident.LowestVcn * BytesPerCluster;

                HighestVbo = ((AttributeHeader->Form.Nonresident.HighestVcn + 1) * BytesPerCluster) - 1;

                //
                //  We have located the attribute in question if the type code
                //  match, it is within the proper range, and if it is either not
                //  the data attribute or if it is the data attribute then it is
                //  also unnamed
                //

                if ((AttributeHeader->TypeCode == TypeCode)

                            &&

                    (LowestVbo <= Vbo) && (Vbo <= HighestVbo)

                            &&

                    ((TypeCode != $DATA) ||
                     ((TypeCode == $DATA) && (AttributeHeader->NameLength == 0)))) {

                    //
                    //  We've located the attribute so now it is time to decode
                    //  the retrieval information and return to our caller
                    //

                    DecodeRetrievalInformation( StructureContext,
                                                Mcb,
                                                Vbo,
                                                AttributeHeader );

                    DereferenceFileRecord( BufferIndex );
                    DereferenceFileRecord( SavedBufferIndex );

                    return ESUCCESS;
                }
            }
        }
    }


    DereferenceFileRecord( BufferIndex );
    DereferenceFileRecord( SavedBufferIndex );

    return EINVAL;
}


//
//  Local support routine
//


ARC_STATUS
NtfsVboToLbo (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG ByteCount
    )

/*++

Routine Description:

    This routine computes the run denoted by the input vbo to into its
    corresponding lbo and also returns the number of bytes remaining in
    the run.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    AttributeContext - Supplies the Nonresident attribute being queried

    Vbo - Supplies the Vbo to match

    Lbo - Recieves the corresponding Lbo

    ByteCount - Receives the number of bytes remaining in the run

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PNTFS_MCB Mcb;
    ULONG i;

    //
    //  Check if we are doing the mft or some other attribute
    //

    Mcb = NULL;

    if (AttributeContext == &StructureContext->MftAttributeContext) {

        //
        //  For the mft we start with the base mcb but if the vbo is not in the mcb
        //  then we immediately switch over to the cached mcb
        //

        Mcb = (PNTFS_MCB)&StructureContext->MftBaseMcb;

        if (/*xxLtr*/(Vbo < Mcb->Vbo[0]) || /*xxGeq*/(Vbo >= Mcb->Vbo[Mcb->InUse])) {

            Mcb = NULL;
        }
    }

    //
    //  If the Mcb is still null then we are to use the cached mcb, first find
    //  if one of the cached ones contains the range we're after
    //

    if (Mcb == NULL) {

        for (i = 0; i < 16; i += 1) {

            //
            //  check if we have a hit, on the same attribute and range
            //

            Mcb = (PNTFS_MCB)&StructureContext->CachedMcb[i];

            if ((/*xxEql*/(AttributeContext->FileRecord == StructureContext->CachedMcbFileRecord[i]) &&
                (AttributeContext->FileRecordOffset == StructureContext->CachedMcbFileRecordOffset[i]) &&
                /*xxLeq*/(Mcb->Vbo[0] <= Vbo) && /*xxLtr*/(Vbo < Mcb->Vbo[Mcb->InUse]))) {

                break;
            }

            Mcb = NULL;
        }

        //
        //  If we didn't get a hit then we need to load a new mcb we'll
        //  alternate through our two cached mcbs
        //

        if (Mcb == NULL) {


            Mcb = (PNTFS_MCB)&StructureContext->CachedMcb[LastMcb % 16];
            ((PNTFS_STRUCTURE_CONTEXT)StructureContext)->CachedMcbFileRecord[LastMcb % 16]
                = AttributeContext->FileRecord;
            ((PNTFS_STRUCTURE_CONTEXT)StructureContext)->CachedMcbFileRecordOffset[LastMcb % 16]
                = AttributeContext->FileRecordOffset;

            LastMcb += 1;

            LoadMcb( StructureContext, AttributeContext, Vbo, Mcb );
        }
    }

    //
    //  At this point the mcb contains the vbo asked for.  So now search for the vbo.
    //  Note that we could also do binary search here but because the run count is
    //  probably small the extra overhead of a binary search doesn't buy us anything
    //

    for (i = 0; i < Mcb->InUse; i += 1) {


        //
        //  We found our slot if the vbo we're after is less than the next mcb's vbo
        //

        if (/*xxLtr*/(Vbo < Mcb->Vbo[i+1])) {

            //
            //  Compute the corresponding lbo which is the stored lbo plus the
            //  difference between the stored vbo and the vbo we're looking up.
            //  Also compute the byte count which is the difference between the
            //  current vbo we're looking up and the vbo for the next run
            //

            if (/*xxNeqZero*/(Mcb->Lbo[i] != 0)) {

                *Lbo = /*xxAdd*/(Mcb->Lbo[i] + /*xxSub*/(Vbo - Mcb->Vbo[i]));

            } else {

                *Lbo = 0;
            }

            *ByteCount = ((ULONG)/*xxSub*/(Mcb->Vbo[i+1] - Vbo));

            //
            //  And return to our caller
            //

            return ESUCCESS;
        }
    }

    //
    //  If we really reach here we have an error.  Most likely the file is not large
    //  enough for the requested vbo
    //

    return EINVAL;
}


//
//  Local support routine
//

ARC_STATUS
NtfsDecodeRetrievalInformation (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PNTFS_MCB Mcb,
    IN VBO Vbo,
    IN PATTRIBUTE_RECORD_HEADER AttributeHeader
    )

/*++

Routine Description:

    This routine does the decode of the retrival information stored in a Nonresident
    attribute header into the specified output mcb starting with the specified
    Lbo.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    Mcb - Supplies the Mcb used in this operation

    Vbo - Supplies the starting vbo that must be stored in the mcb

    AttributeHeader - Supplies the non resident attribute header that
        we are to use in this operation

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ULONG BytesPerCluster;

    VBO NextVbo;
    LBO CurrentLbo;
    VBO CurrentVbo;

    LONGLONG Change;
    PCHAR ch;
    ULONG VboBytes;
    ULONG LboBytes;

    //
    //  Initialize our locals
    //

    BytesPerCluster = StructureContext->BytesPerCluster;

    //
    //  Setup the next vbo and current lbo and ch for the following loop that decodes
    //  the retrieval information
    //

    NextVbo = /*xxXMul*/(AttributeHeader->Form.Nonresident.LowestVcn * BytesPerCluster);

    CurrentLbo = 0;

    ch = Add2Ptr( AttributeHeader,
                  AttributeHeader->Form.Nonresident.MappingPairsOffset );

    Mcb->InUse = 0;

    //
    //  Loop to process mapping pairs
    //

    while (!IsCharZero(*ch)) {

        //
        //  Set current Vbo from initial value or last pass through loop
        //

        CurrentVbo = NextVbo;

        //
        //  Extract the counts from the two nibbles of this byte
        //

        VboBytes = *ch & 0x0f;
        LboBytes = *ch++ >> 4;

        //
        //  Extract the Vbo change and update next vbo
        //

        Change = 0;

        if (IsCharLtrZero(*(ch + VboBytes - 1))) {

            return EINVAL;
        }

        RtlMoveMemory( &Change, ch, VboBytes );

        ch += VboBytes;

        NextVbo = /*xxAdd*/(NextVbo + /*xXMul*/(Change * BytesPerCluster));

        //
        //  If we have reached the maximum for this mcb then it is time
        //  to return and not decipher any more retrieval information
        //

        if (Mcb->InUse >= MAXIMUM_NUMBER_OF_MCB_ENTRIES - 1) {

            break;
        }

        //
        //  Now check if there is an lbo change.  If there isn't
        //  then we only need to update the vbo, because this
        //  is sparse/compressed file.
        //

        if (LboBytes != 0) {

            //
            //  Extract the Lbo change and update current lbo
            //

            Change = 0;

            if (IsCharLtrZero(*(ch + LboBytes - 1))) {

                Change = /*xxSub*/( Change - 1 );
            }

            RtlMoveMemory( &Change, ch, LboBytes );

            ch += LboBytes;

            CurrentLbo = /*xxAdd*/( CurrentLbo + /*xxXMul*/(Change * BytesPerCluster));
        }

        //
        //  Now check if the Next Vbo is greater than the Vbo we after
        //

        if (/*xxGeq*/(NextVbo >= Vbo)) {

            //
            //  Load this entry into the mcb and advance our in use counter
            //

            Mcb->Vbo[Mcb->InUse]     = CurrentVbo;
            Mcb->Lbo[Mcb->InUse]     = (LboBytes != 0 ? CurrentLbo : 0);
            Mcb->Vbo[Mcb->InUse + 1] = NextVbo;

            Mcb->InUse += 1;
        }
    }

    return ESUCCESS;
}


//
//  Local support routine
//

VOID
NtfsFirstComponent (
    IN OUT PCSTRING String,
    OUT PCSTRING FirstComponent
    )

/*++

Routine Description:

    This routine takes an input path name and separates it into its first
    file name component and the remaining part.

Arguments:

    String - Supplies the original string being dissected (in ansi).  On return
        this string will now point to the remaining part.

    FirstComponent - Recieves the string representing the first file name in
        the input string.

Return Value:

    None.

--*/

{
    ULONG Index;

    //
    //  Copy over the string variable into the first component variable
    //

    *FirstComponent = *String;

    //
    //  Now if the first character in the name is a backslash then
    //  simply skip over the backslash.
    //

    if (FirstComponent->Buffer[0] == '\\') {

        FirstComponent->Buffer += 1;
        FirstComponent->Length -= 1;
    }

    //
    //  Now search the name for a backslash
    //

    for (Index = 0; Index < FirstComponent->Length; Index += 1) {

        if (FirstComponent->Buffer[Index] == '\\') {

            break;
        }
    }

    //
    //  At this point Index denotes a backslash or is equal to the length of the
    //  string.  So update string to be the remaining part.  Decrement the length of
    //  the first component by the approprate amount
    //

    String->Buffer = &FirstComponent->Buffer[Index];
    String->Length = (SHORT)(FirstComponent->Length - Index);

    FirstComponent->Length = (SHORT)Index;

    //
    //  And return to our caller.
    //

    return;
}


//
//  Local support routine
//

int
NtfsCompareName (
    IN CSTRING AnsiString,
    IN UNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine compares two names (one ansi and one unicode) for equality.

Arguments:

    AnsiString - Supplies the ansi string to compare

    UnicodeString - Supplies the unicode string to compare

Return Value:

    < 0 if AnsiString is approximately < than UnicodeString
    = 0 if AnsiString is approximately == UnicodeString
    > 0 otherwise

--*/

{
    ULONG i;
    ULONG Length;

    //
    //  Determine length for compare
    //

    if (AnsiString.Length * sizeof( WCHAR ) < UnicodeString.Length) {
        Length = AnsiString.Length;
    } else {
        Length = UnicodeString.Length / sizeof( WCHAR );
    }

    i = 0;
    while (i < Length) {

        //
        //  If the current char is a mismatch, return the difference
        //

        if (ToUpper( (USHORT)AnsiString.Buffer[i] ) != ToUpper( UnicodeString.Buffer[i] )) {
            return ToUpper( (USHORT)AnsiString.Buffer[i] ) - ToUpper( UnicodeString.Buffer[i] );
        }

        i++;
    }

    //
    //  We've compared equal up to the length of the shortest string.  Return
    //  based on length comparison now.
    //

    return AnsiString.Length - UnicodeString.Length / sizeof( WCHAR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\ramdisk.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ramdisk.c

Abstract:

    Provides the ARC emulation routines for I/O to a RAM disk device.

Author:

    Chuck Lenzmeier (chuckl) 29-Apr-2001

Revision History:

    Bassam Tabbara (bassamt) 06-Aug-2001 Added Ramdisk Building Support

--*/


#include "bootlib.h"
#include "arccodes.h"
#include "stdlib.h"
#include "string.h"
#if defined(_X86_)
#include "bootx86.h"
#endif
#if defined(_IA64_)
#include "bootia64.h"
#endif
#include "ramdisk.h"
#include "netfs.h"
#if defined(POST_XPSP)
#include "bmbuild.h"
#endif
#include "ntexapi.h"
#include "haldtect.h"
#include "pci.h"
#include "pbios.h"
#include "bldr.h"

#include <sdistructs.h>

//
// Debug helpers
//
#define ERR     0
#define INFO    1
#define VERBOSE 2
#define PAINFUL 3

#define DBGPRINT(lvl, _fmt_) if (RamdiskDebug && lvl <= RamdiskDebugLevel) DbgPrint _fmt_
#define DBGLVL(x) (RamdiskDebug && RamdiskDebugLevel == x)

BOOLEAN RamdiskDebug = TRUE;
BOOLEAN RamdiskDebugLevel = INFO;
BOOLEAN RamdiskBreak = FALSE;

//
// Macros
//
#define BL_INVALID_FILE_ID (ULONG)-1

#define TEST_BIT(value, b) (((value) & (b)) == (b))

#define PCI_ITERATOR_IS_VALID(i)        (i & 0x8000)
#define PCI_ITERATOR_TO_BUS(i)          (UCHAR)(((i) >> 8) & 0x7f)
#define PCI_ITERATOR_TO_DEVICE(i)       (UCHAR)(((i) >> 3) & 0x1f)
#define PCI_ITERATOR_TO_FUNCTION(i)     (UCHAR)(((i) >> 0) & 0x7)

#define PCI_TO_ITERATOR(b,d,f)          ((USHORT)(0x8000 | ((b)<<8) | ((d)<<3) | (f)))

//
// PCI Device struct as persisted in registry by ntdetect.com
//

#include <pshpack1.h>
typedef struct _PCIDEVICE {
    USHORT BusDevFunc;
    PCI_COMMON_CONFIG Config;
} PCIDEVICE, *PPCIDEVICE;
#include <poppack.h>

//
// Externs
//

extern PVOID InfFile;
extern BOOLEAN GraphicsMode;
extern BOOLEAN BlShowProgressBar;
extern BOOLEAN BlOutputDots;
extern BOOLEAN DisplayLogoOnBoot;

//
// Global Ramdisk options. 
// NOTE: All Ip addresses and ports are in network byte order.
//

BOOLEAN RamdiskBuild = FALSE;

//
// Used if downloading a ramdisk directly. RamdiskBuild = FALSE
//

PCHAR  RamdiskPath = NULL;
ULONG  RamdiskTFTPAddr = 0;             // network byte order
ULONG  RamdiskMTFTPAddr = 0;            // network byte order
USHORT RamdiskMTFTPCPort = 0;           // network byte order
USHORT RamdiskMTFTPSPort = 0;           // network byte order
USHORT RamdiskMTFTPTimeout = 5;
USHORT RamdiskMTFTPDelay = 5;
LONGLONG RamdiskMTFTPFileSize = 0;
LONGLONG RamdiskMTFTPChunkSize = 0;


//
// Used if Building a ramdisk. RamdiskBuild = TRUE
//
#define RAMDISK_MAX_SERVERS     10

#define RAMDISK_DISCOVERY_MULTICAST 0x00000001
#define RAMDISK_DISCOVERY_BROADCAST 0x00000002
#define RAMDISK_DISCOVERY_UNICAST   0x00000004
#define RAMDISK_DISCOVERY_RESTRICT  0x00000008

GUID   RamdiskGuid = {0,0,0,0};
ULONG  RamdiskDiscovery = 0; 
ULONG  RamdiskMCastAddr = 0;        // network byte order
ULONG  RamdiskServerCount = 0;
ULONG  RamdiskServers[RAMDISK_MAX_SERVERS];     // network byte order
USHORT RamdiskTimeout = 15;
USHORT RamdiskRetry = 5;

//
// Globals
//

BOOLEAN RamdiskActive = FALSE;
ULONG RamdiskBasePage = 0;
LONGLONG RamdiskFileSize = 0;
ULONG RamdiskFileSizeInPages = 0;
ULONG RamdiskImageOffset = 0;
LONGLONG RamdiskImageLength = 0;
ULONG_PTR SdiAddress = 0;

ULONG RamdiskMaxPacketSize = 0;
ULONG RamdiskXID = 0;


BL_DEVICE_ENTRY_TABLE RamdiskEntryTable =
    {
        (PARC_CLOSE_ROUTINE)RamdiskClose,
        (PARC_MOUNT_ROUTINE)RamdiskMount,
        (PARC_OPEN_ROUTINE)RamdiskOpen,
        (PARC_READ_ROUTINE)RamdiskRead,
        (PARC_READ_STATUS_ROUTINE)RamdiskReadStatus,
        (PARC_SEEK_ROUTINE)RamdiskSeek,
        (PARC_WRITE_ROUTINE)RamdiskWrite,
        (PARC_GET_FILE_INFO_ROUTINE)RamdiskGetFileInfo,
        (PARC_SET_FILE_INFO_ROUTINE)RamdiskSetFileInfo,
        (PRENAME_ROUTINE)RamdiskRename,
        (PARC_GET_DIRECTORY_ENTRY_ROUTINE)RamdiskGetDirectoryEntry,
        (PBOOTFS_INFO)NULL
    };

//
// forward decls
//

PVOID
MapRamdisk (
    IN LONGLONG Offset,
    OUT PLONGLONG AvailableLength
    );

ARC_STATUS 
RamdiskParseOptions (
    IN PCHAR LoadOptions
    );

ARC_STATUS
RamdiskInitializeFromPath(
    );

ARC_STATUS
RamdiskBuildAndInitialize(
    );

VOID
RamdiskFatalError(
    IN ULONG Message1,
    IN ULONG Message2
    );



ARC_STATUS
RamdiskInitialize(
    IN PCHAR LoadOptions,
    IN BOOLEAN SdiBoot
    )
/*++

Routine Description:

    This function will initiate the boot from a RAMDISK. Depending
    on the options passed in the the boot will either happen from 
    a static RAMDISK (using the /RDPATH option) or from a dynamic
    RAMDISK (using the /RDBUILD option).

Arguments:

    LoadOptions - boot.ini parameters

    SdiBoot - indicates whether this is an SDI boot. If it is, LoadOptions
        is ignored. The global variable SdiAddress gives the pointer to
        the SDI image.

Return Value:

    none

--*/
{
    ARC_STATUS status;
    BOOLEAN OldOutputDots = FALSE;
    BOOLEAN OldShowProgressBar = FALSE;
    ULONG oldBase;
    ULONG oldLimit;

    //
    // Debug Break on entry
    //

    if (RamdiskBreak) {
        DbgBreakPoint();
    }

    //
    // If the ramdisk has already been initialized, just return. We know the
    // ramdisk has been initialized if SdiBoot is FALSE (implying that this is
    // NOT the call from BlStartup(), but the call from BlOsLoader()) and
    // RamdiskBasePage is not NULL (implying that we were previously called
    // from BlStartup() to initialize the SDI boot.
    //

    if ( !SdiBoot && (RamdiskBasePage != 0) ) {

        //
        // Now that ntdetect has been run, we can free up the pages that
        // we allocated earlier (see below).
        //

        BlFreeDescriptor( 0x10 );

        return ESUCCESS;
    }

    //
    // If this is an SDI boot, then we must have a pointer to the SDI image.
    //

    if ( SdiBoot && (SdiAddress == 0) ) {

        RamdiskFatalError( RAMDISK_GENERAL_FAILURE, 
                           RAMDISK_INVALID_OPTIONS );
        return EINVAL;
    }

    //
    // If this is not an SDI boot, parse all ramdisk options (if any).
    //

    if ( !SdiBoot ) {
        status = RamdiskParseOptions ( LoadOptions );
        if (status != ESUCCESS) {
            RamdiskFatalError( RAMDISK_GENERAL_FAILURE, 
                               RAMDISK_INVALID_OPTIONS );
            return status;                           
        }
    }

#if defined(_IA64_)
    // Ramdisk boot path not supported on IA64 as of yet
    if ( RamdiskBuild ) {
        return ESUCCESS;
    }
#endif

    //
    // Show the progress bar in text mode
    //
    if ( RamdiskBuild || RamdiskPath ) {

        // If booting from a ramdisk, graphics mode is off permanently
        DisplayLogoOnBoot = FALSE;
        GraphicsMode = FALSE;

        OldShowProgressBar = BlShowProgressBar;
        BlShowProgressBar = TRUE;

        OldOutputDots = BlOutputDots;
        BlOutputDots = TRUE;
    }

#if defined(POST_XPSP)
#if defined(i386)

    if ( RamdiskBuild ) {

        //
        // We will need to build the ramdisk first
        //

        ASSERT( RamdiskPath == NULL );

        status = RamdiskBuildAndInitialize();
        if (status != ESUCCESS) {
            RamdiskFatalError( RAMDISK_GENERAL_FAILURE, 
                               RAMDISK_BUILD_FAILURE );
            return status;
        }
    }

#endif
#endif

    if ( RamdiskPath ) {

        //
        // Initialize the Ramdisk from the RamdiskPath
        //

        status = RamdiskInitializeFromPath();
        if (status != ESUCCESS) {
            RamdiskFatalError( RAMDISK_GENERAL_FAILURE, 
                               RAMDISK_BOOT_FAILURE );
            return status;
        }

    } else if ( SdiBoot ) {

        //
        // This is an SDI boot. Find the ramdisk image within the SDI image
        // and allocate the pages in which the ramdisk image resides.
        //

        ULONG basePage;
        ULONG pageCount;
        PSDI_HEADER sdiHeader;
        ULONG i;
        ULONG_PTR ramdiskAddress;

        //
        // Temporarily allocate the pages that will be occupied by ntdetect
        // while it runs. BlDetectHardware() just assumes that these pages
        // are free for loading ntdetect. But we're going to allocate and map
        // the ramdisk image, which will result in the allocation of many
        // page table pages, some of which might end up in the place where
        // ntdetect will be loaded. So we allocate the ntdetect range here,
        // then free it later (see above).
        //

        basePage = 0x10;
        pageCount = 0x10;

        status = BlAllocateAlignedDescriptor(
                    LoaderFirmwareTemporary,
                    basePage,
                    pageCount,
                    0,
                    &basePage
                    );

        //
        // Allocate the page that contains the SDI header. This will cause
        // it to be mapped, which will allow us to read the header to find
        // the ramdisk image.
        //

        oldBase = BlUsableBase;
        oldLimit = BlUsableLimit;
        BlUsableBase = BL_XIPROM_RANGE_LOW;
        BlUsableLimit = BL_XIPROM_RANGE_HIGH;
    
        basePage = (ULONG)(SdiAddress >> PAGE_SHIFT);
        pageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES( SdiAddress, sizeof(SDI_HEADER) );

        status = BlAllocateAlignedDescriptor(
                    LoaderFirmwareTemporary,
                    basePage,
                    pageCount,
                    0,
                    &basePage
                    );

        BlUsableBase = oldBase;
        BlUsableLimit = oldLimit;

        //
        // Find the ramdisk image by looking through the TOC in the SDI header.
        //

        sdiHeader = (PSDI_HEADER)SdiAddress;

        for ( i = 0; i < SDI_TOCMAXENTRIES; i++ ) {
            if ( sdiHeader->ToC[i].dwType == SDI_BLOBTYPE_PART ) {
                break;
            }
        }

        if ( i >= SDI_TOCMAXENTRIES ) {
            RamdiskFatalError( RAMDISK_GENERAL_FAILURE, 
                               RAMDISK_BOOT_FAILURE );
            return ENOENT;
        }

        //
        // Calculate the starting address and page of the ramdisk image, the
        // length of the ramdisk image, and the offset within the starting page
        // to the image. The offset should be 0, because everything in the SDI
        // image should be page-aligned.
        //

        ramdiskAddress = (ULONG_PTR)(SdiAddress + sdiHeader->ToC[i].llOffset.QuadPart);
        RamdiskBasePage = (ULONG)(ramdiskAddress >> PAGE_SHIFT);

        RamdiskImageOffset = (ULONG)(ramdiskAddress - ((ULONG_PTR)RamdiskBasePage << PAGE_SHIFT));
        RamdiskImageLength = sdiHeader->ToC[i].llSize.QuadPart;

        RamdiskFileSizeInPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                                    ramdiskAddress,
                                    RamdiskImageLength
                                    );
        RamdiskFileSize = (LONGLONG)RamdiskFileSizeInPages << PAGE_SHIFT;

        //
        // Release the page(s) occupied by the SDI header.
        //

        BlFreeDescriptor( basePage );

        //
        // Tell the memory allocator about the pages occupied by the ramdisk
        // by allocating those pages.
        //

        oldBase = BlUsableBase;
        oldLimit = BlUsableLimit;
        BlUsableBase = BL_XIPROM_RANGE_LOW;
        BlUsableLimit = BL_XIPROM_RANGE_HIGH;
    
        basePage = RamdiskBasePage;
        pageCount = RamdiskFileSizeInPages;

        status = BlAllocateAlignedDescriptor(
                    LoaderXIPRom,
                    basePage,
                    pageCount,
                    0,
                    &basePage
                    );
    
        BlUsableBase = oldBase;
        BlUsableLimit = oldLimit;

        ASSERT( status == ESUCCESS );
        ASSERT( basePage == RamdiskBasePage );

        DBGPRINT(VERBOSE, ("Ramdisk is active\n") );
        RamdiskActive = TRUE;
    }

    //
    // Restore old progress bar settings
    //
    if ( RamdiskBuild || RamdiskPath ) {
        BlShowProgressBar = OldShowProgressBar;
        BlOutputDots = OldOutputDots;
        BlClearScreen();
    }

    return ESUCCESS;
}

ARC_STATUS
RamdiskReadImage(
    PCHAR RamdiskPath
    )
/*++

Routine Description:

    This function will load a ramdisk image from the network
    or another ARC boot device.

Arguments:

    RamdiskPath - name of the file to load

Return Value:

    status    

--*/
{
    ARC_STATUS status;
    ULONG RamdiskDeviceId;
    ULONG RamdiskFileId = BL_INVALID_FILE_ID;
    PCHAR p;
    FILE_INFORMATION fileInformation;
    LARGE_INTEGER offset;
    LONGLONG remainingLength;
    ULONG oldBase;
    ULONG oldLimit;
    BOOLEAN retry = TRUE;
    ULONG lastProgressPercent = 0; 
    BOOLEAN ForceDisplayFirstTime = TRUE; // force display initially
    ULONG currentProgressPercent;
    PUCHAR ip;
    PTCHAR FormatString = NULL;
    TCHAR Buffer[256];
    
    //
    // Show text progress bar
    //
    BlOutputStartupMsg(RAMDISK_DOWNLOAD);
    BlUpdateProgressBar(0);

    DBGPRINT(VERBOSE, ("RamdiskReadImage(%s)\n", RamdiskPath));

    //
    // Open the device that the RAM disk image is on.
    //

    p = strchr(RamdiskPath, '\\');
    if (p == NULL) {
        DBGPRINT(ERR, ("no \\ found in path\n"));
        return EINVAL;
    }

    *p = 0;

try_again:

    status = ArcOpen(RamdiskPath, ArcOpenReadWrite, &RamdiskDeviceId);
    if (status != ESUCCESS) {
        DBGPRINT(ERR, ("ArcOpen(%s) failed: %d\n", RamdiskPath, status));
        if ( retry ) {
            retry = FALSE;
            _strlwr(RamdiskPath);
            goto try_again;
        }
        *p = '\\';
        return status;
    }

    *p++ = '\\';

    //
    // If the RAM disk image is on the network, use TftpGetPut to read it.
    // Otherwise, use normal I/O.
    //

    oldBase = BlUsableBase;
    oldLimit = BlUsableLimit;
    BlUsableBase = BL_XIPROM_RANGE_LOW;
    BlUsableLimit = BL_XIPROM_RANGE_HIGH;

#ifdef EFI // multicast ramdisk download only supported on non-EFI machines for now

    if ( RamdiskDeviceId == NET_DEVICE_ID && RamdiskMTFTPAddr != 0 )
    {
        return EBADF;
    }

#endif

    if ( RamdiskDeviceId == NET_DEVICE_ID && RamdiskMTFTPAddr == 0) {

        //
        // Network device using UNICAST download. We will use the TFTP
        // client implementation in TFTPLIB for the download.
        //
        TFTP_REQUEST request;
        NTSTATUS ntStatus;

        request.RemoteFileName = (PUCHAR)p;
        request.ServerIpAddress = RamdiskTFTPAddr;
        request.MemoryAddress = NULL;
        request.MaximumLength = 0;
        request.BytesTransferred = 0xbadf00d;
        request.Operation = TFTP_RRQ;
        request.MemoryType = LoaderXIPRom;
#if defined(REMOTE_BOOT_SECURITY)
        request.SecurityHandle = TftpSecurityHandle;
#endif // defined(REMOTE_BOOT_SECURITY)
        request.ShowProgress = TRUE;
        
        //
        // Print progress message
        //
        ip = (PUCHAR) &RamdiskTFTPAddr;
        FormatString = BlFindMessage( RAMDISK_DOWNLOAD_NETWORK );
        if ( FormatString != NULL ) {
            _stprintf(Buffer, FormatString, ip[0], ip[1], ip[2], ip[3] );
            BlOutputTrailerMsgStr( Buffer );
        }

        //
        // Download the image using TFTP
        //
        DBGPRINT(VERBOSE, ("calling TftpGetPut(%s,0x%x)\n", p, NetServerIpAddress));
        ntStatus = TftpGetPut( &request );
        DBGPRINT(VERBOSE, ("status from TftpGetPut 0x%x\n", ntStatus));

        BlUsableBase = oldBase;
        BlUsableLimit = oldLimit;

        if ( !NT_SUCCESS(ntStatus) ) {

            if ( request.MemoryAddress != NULL ) {
                BlFreeDescriptor( (ULONG)((ULONG_PTR)request.MemoryAddress >> PAGE_SHIFT ));
            }

            ArcClose( RamdiskDeviceId );

            if ( ntStatus == STATUS_INSUFFICIENT_RESOURCES ) {
                return ENOMEM;
            }
            return EROFS;
        }

        RamdiskBasePage = (ULONG)((ULONG_PTR)request.MemoryAddress >> PAGE_SHIFT);

        RamdiskFileSize = request.MaximumLength;
        RamdiskFileSizeInPages = (ULONG)BYTES_TO_PAGES(RamdiskFileSize);
        if ( (RamdiskImageLength == 0) ||
             (RamdiskImageLength > (RamdiskFileSize - RamdiskImageOffset)) ) {
            RamdiskImageLength = RamdiskFileSize - RamdiskImageOffset;
        }

#ifndef EFI // multicast ramdisk download only supported on non-EFI machines for now

    } else if ( RamdiskDeviceId == NET_DEVICE_ID && RamdiskMTFTPAddr != 0) {

        LONGLONG FileOffset = 0;
        LONGLONG physicalAddressOfOffset;
        ULONG DownloadSize;
        USHORT ClientPort;
        USHORT ServerPort;
        ULONG iSession = 0;
        
        //
        // Network device and using multicast download. For multicast
        // downloads we will use the MTFTP implementation in the ROM.
        // A single MTFTP transfer is limited to 16-bit block counts.
        // This translates to ~32MB for 512 block sizes and ~90MB for
        // 1468 block sizes. In order to support larger files, we will 
        // use multiple MTFTP sessions to bring the file down in chunks.
        // The MTFTP server will need to understand the chunking semantics. 
        //

        //
        // Print progress message
        //
        ip = (PUCHAR) &RamdiskMTFTPAddr;
        FormatString = BlFindMessage( RAMDISK_DOWNLOAD_NETWORK_MCAST );
        if ( FormatString != NULL ) {
            _stprintf(Buffer, FormatString, ip[0], ip[1], ip[2], ip[3], SWAP_WORD( RamdiskMTFTPSPort ) );
            BlOutputTrailerMsgStr( Buffer );
        }

        //
        // Allocate the memory for the entire RAMDisk
        //
        RamdiskFileSize = RamdiskMTFTPFileSize;
        RamdiskFileSizeInPages = (ULONG)BYTES_TO_PAGES(RamdiskFileSize);
        if ( (RamdiskImageLength == 0) ||
             (RamdiskImageLength > (RamdiskFileSize - RamdiskImageOffset)) ) {
            RamdiskImageLength = RamdiskFileSize - RamdiskImageOffset;
        }

        DBGPRINT(INFO, ("Downloading Ramdisk using MTFTP. File Size=0x%I64x Chunk Size=0x%I64x\n", RamdiskFileSize, RamdiskMTFTPChunkSize ));

        status = BlAllocateAlignedDescriptor(
                    LoaderXIPRom,
                    0,
                    RamdiskFileSizeInPages,
                    0,
                    &RamdiskBasePage
                    );

        BlUsableBase = oldBase;
        BlUsableLimit = oldLimit;

        if (status != ESUCCESS) {
            DBGPRINT(ERR, ("BlAllocateAlignedDescriptor(%d pages) failed: %d\n", RamdiskFileSizeInPages, status));
            return status;
        }
    
        DBGPRINT(VERBOSE, ("Allocated %d pages at page %x for RAM disk\n", RamdiskFileSizeInPages, RamdiskBasePage ));

        //
        // Download the ramdisk file using MTFTP
        //

        if ( RamdiskMTFTPChunkSize == 0 ) {
            RamdiskMTFTPChunkSize = RamdiskMTFTPFileSize;
        }

        // starting client and server port (in Intel byte order to 
        // allow increment operators to work )
        ClientPort = SWAP_WORD( RamdiskMTFTPCPort );
        ServerPort = SWAP_WORD( RamdiskMTFTPSPort );

        while ( FileOffset < RamdiskFileSize ) {

            //
            // Call the ROM implementation to download a single chunk
            //
            physicalAddressOfOffset = ((LONGLONG)RamdiskBasePage << PAGE_SHIFT) + FileOffset;

            ip = (PUCHAR)&RamdiskMTFTPAddr;
            DBGPRINT(INFO, ("MTFTP Session %d: %s from %u.%u.%u.%u sport=%d cport=%d offset=0x%I64x\n", 
                            iSession, p, 
                            ip[0], ip[1], ip[2], ip[3], ClientPort, ServerPort,
                            physicalAddressOfOffset ));

            //
            // the high 32 bits are going to be lost when calling RomMtftpReadFile.
            // find out now, if this is happening
            //
            ASSERT( (physicalAddressOfOffset >> 32) == 0 );
            status = RomMtftpReadFile ( (PUCHAR)p,
                                        (PVOID)(ULONG)physicalAddressOfOffset,
                                        (ULONG)RamdiskMTFTPChunkSize,
                                        RamdiskTFTPAddr,
                                        RamdiskMTFTPAddr,
                                        SWAP_WORD( ClientPort ),
                                        SWAP_WORD( ServerPort ),
                                        RamdiskMTFTPTimeout,
                                        RamdiskMTFTPDelay,
                                        &DownloadSize );
            if ( status != ESUCCESS ) {
                DBGPRINT(ERR, ("RomMtftpReadFile failed %d\n", status ));
                BlFreeDescriptor( RamdiskBasePage );
                return status;
            }

#if 1 || INTEL_MTFTP_SERVER_TEST
            p[strlen(p) - 1]++;
            RamdiskMTFTPAddr += 0x01000000;
#else
            ClientPort++;            
            ServerPort++;            
#endif
            FileOffset += DownloadSize;
            iSession++;

            // update progress bar
            currentProgressPercent = (ULONG)(((LONGLONG)FileOffset * 100) / RamdiskFileSize);
            if ( ForceDisplayFirstTime || (currentProgressPercent != lastProgressPercent) ) {
                BlUpdateProgressBar( currentProgressPercent );
                ForceDisplayFirstTime = FALSE;
            }
            lastProgressPercent = currentProgressPercent;

        }

        DBGPRINT(INFO, ("MTFTP Download complete. 0x%I64x bytes transferred using %d sessions\n", RamdiskFileSize, iSession));

#endif

    } else {
    
        //
        // Open the RAM disk image.
        //
    
        status = BlOpen( RamdiskDeviceId, p, ArcOpenReadOnly, &RamdiskFileId );
        if (status != ESUCCESS) {
            DBGPRINT(ERR, ("BlOpen(%s) failed: %d\n", p, status));
            ArcClose( RamdiskDeviceId );
            return status;
        }
    
        //
        // Get the size of the RAM disk image.
        //
    
        status = BlGetFileInformation( RamdiskFileId, &fileInformation );
        if (status != ESUCCESS) {
            DBGPRINT(ERR, ("BlGetFileInformation(%s) failed: %d\n", p, status));
            BlClose( RamdiskFileId );
            ArcClose( RamdiskDeviceId );
            return status;
        }
    
        RamdiskFileSize = fileInformation.EndingAddress.QuadPart;
        RamdiskFileSizeInPages = (ULONG)BYTES_TO_PAGES(RamdiskFileSize);
        if ( (RamdiskImageLength == 0) ||
             (RamdiskImageLength > (RamdiskFileSize - RamdiskImageOffset)) ) {
            RamdiskImageLength = RamdiskFileSize - RamdiskImageOffset;
        }
    
        //
        // Allocate pages to hold the RAM disk image.
        //
    
        status = BlAllocateAlignedDescriptor(
                    LoaderXIPRom,
                    0,
                    RamdiskFileSizeInPages,
                    0,
                    &RamdiskBasePage
                    );

        BlUsableBase = oldBase;
        BlUsableLimit = oldLimit;

        if (status != ESUCCESS) {
            DBGPRINT(ERR, ("BlAllocateAlignedDescriptor(%d pages) failed: %d\n", RamdiskFileSizeInPages, status));
            BlClose( RamdiskFileId );
            ArcClose( RamdiskDeviceId );
            return status;
        }
    
        DBGPRINT(VERBOSE, ("Allocated %d pages at page %x for RAM disk\n", RamdiskFileSizeInPages, RamdiskBasePage ));
    
        //
        // Read the RAM disk image into memory.
        //

#define MAX_DISK_READ (1024 * 1024)

        offset.QuadPart = 0;
        remainingLength = RamdiskFileSize;

        while ( offset.QuadPart < RamdiskFileSize ) {
    
            LONGLONG availableLength;
            ULONG readLength;
            PVOID va;
            ULONG count;
    
            va = MapRamdisk( offset.QuadPart, &availableLength );
    
            if ( remainingLength > availableLength ) {
                readLength = (ULONG)availableLength;
            } else {
                readLength = (ULONG)remainingLength;
            }
            if ( readLength > MAX_DISK_READ ) {
                readLength = MAX_DISK_READ;
            }
    
            status = BlSeek( RamdiskFileId, &offset, SeekAbsolute );
            if ( status != ESUCCESS ) {
                DBGPRINT(ERR, ("Unable to seek RAM disk image: %d\n", status));
                BlClose( RamdiskFileId );
                ArcClose( RamdiskDeviceId );
                return status;
            }
    
            status = BlRead( RamdiskFileId, va, readLength, &count );
            if ( (status != ESUCCESS) || (count != readLength) ) {
                DBGPRINT(ERR, ( "Unable to read RAM disk image: status %d count %x (wanted %x)\n", status, count, readLength) );
                BlClose( RamdiskFileId );
                ArcClose( RamdiskDeviceId );
                return status;
            }

            offset.QuadPart += readLength;
            remainingLength -= readLength;

            // update progress bar
            currentProgressPercent = (ULONG)(((LONGLONG)offset.QuadPart * 100) / RamdiskFileSize);
            if ( ForceDisplayFirstTime || (currentProgressPercent != lastProgressPercent) ) {
                BlUpdateProgressBar( currentProgressPercent );
                ForceDisplayFirstTime = FALSE;
            }
            lastProgressPercent = currentProgressPercent;
        }
        DBGPRINT(VERBOSE, ( "Done reading ramdisk\n" ) );
    
        BlClose( RamdiskFileId );
        RamdiskFileId = BL_INVALID_FILE_ID;
    }

    ArcClose( RamdiskDeviceId );

    return status;

} // RamdiskReadImage

ARC_STATUS
RamdiskInitializeFromPath(
    )
/*++

Routine Description:

    This function will load a ramdisk image from the network
    or another ARC boot device.

Arguments:

    none

Return Value:

    status    

--*/
{
    ARC_STATUS status;

    ASSERT( RamdiskPath );

    DBGPRINT(VERBOSE, ("RamdiskInitializeFromPath(%s)\n", RamdiskPath));

    status = RamdiskReadImage( RamdiskPath );

    if ( status == ESUCCESS ) {
    
        DBGPRINT(VERBOSE, ("Ramdisk is active\n") );
        RamdiskActive = TRUE;
    }

    return status;

} // RamdiskInitializeFromPath


ARC_STATUS
RamdiskClose(
    IN ULONG FileId
    )

/*++

Routine Description:

    Closes the specified device

Arguments:

    FileId - Supplies file id of the device to be closed

Return Value:

    ESUCCESS - Device closed successfully

    !ESUCCESS - Device was not closed.

--*/

{
    if (BlFileTable[FileId].Flags.Open == 0) {
#if DBG
        BlPrint(TEXT("ERROR - Unopened fileid %lx closed\r\n"),FileId);
#endif
    }
    BlFileTable[FileId].Flags.Open = 0;

    return(ESUCCESS);
}


ARC_STATUS
RamdiskOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Opens a RAM disk for raw sector access.

Arguments:

    OpenPath - Supplies a pointer to the name of the RAM disk.

    OpenMode - Supplies the mode of the open

    FileId - Supplies a pointer to a variable that specifies the file
             table entry that is filled in if the open is successful.

Return Value:

    ESUCCESS is returned if the open operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ULONG Key;
    PDRIVE_CONTEXT Context;

    UNREFERENCED_PARAMETER( OpenMode );

    //BlPrint(TEXT("RamdiskOpen entered\r\n"));

    if ( !RamdiskActive ) {
        //BlPrint(TEXT("RamdiskOpen: not active\r\n"));
        return EBADF;
    }

    if(FwGetPathMnemonicKey(OpenPath,"ramdisk",&Key)) {
        DBGPRINT(VERBOSE, ("RamdiskOpen: not a ramdisk path\n"));
        return EBADF;
    }

    if ( Key != 0 ) {
        DBGPRINT(ERR, ("RamdiskOpen: not ramdisk 0\n"));
        return EBADF;
    }

    //
    // Find an available FileId descriptor to open the device with
    //
    *FileId=2;

    while (BlFileTable[*FileId].Flags.Open != 0) {
        *FileId += 1;
        if(*FileId == BL_FILE_TABLE_SIZE) {
            DBGPRINT(ERR, ("RamdiskOpen: no file table entry available\n"));
            return(ENOENT);
        }
    }

    //
    // We found an entry we can use, so mark it as open.
    //
    BlFileTable[*FileId].Flags.Open = 1;
    BlFileTable[*FileId].DeviceEntryTable = &RamdiskEntryTable;


    Context = &(BlFileTable[*FileId].u.DriveContext);
    Context->Drive = (UCHAR)Key;
    Context->xInt13 = TRUE;

    DBGPRINT(VERBOSE, ("RamdiskOpen: exit success\n"));

    return(ESUCCESS);
}


ARC_STATUS
RamdiskSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    Changes the current offset of the file specified by FileId

Arguments:

    FileId - specifies the file on which the current offset is to
             be changed.

    Offset - New offset into file.

    SeekMode - Either SeekAbsolute or SeekRelative
               SeekEndRelative is not supported

Return Value:

    ESUCCESS - Operation completed succesfully

    EBADF - Operation did not complete successfully.

--*/

{
    switch (SeekMode) {
        case SeekAbsolute:
            BlFileTable[FileId].Position = *Offset;
            break;
        case SeekRelative:
            BlFileTable[FileId].Position.QuadPart += Offset->QuadPart;
            break;
        default:
#if DBG
            BlPrint(TEXT("SeekMode %lx not supported\r\n"),SeekMode);
#endif
            return(EACCES);

    }
    return(ESUCCESS);

}

ARC_STATUS
RamdiskWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Writes sectors directly to an open RAM disk.

Arguments:

    FileId - Supplies the file to write to

    Buffer - Supplies buffer with data to write

    Length - Supplies number of bytes to write

    Count - Returns actual bytes written

Return Value:

    ESUCCESS - write completed successfully

    !ESUCCESS - write failed

--*/

{
    PUCHAR buffer;
    LONGLONG offset;
    ULONG remainingLength;
    LONGLONG availableLength;
    ULONG bytesWritten;
    ULONG bytesThisPage;
    PVOID va;

    DBGPRINT(ERR, ("RamdiskWrite entered\n"));
    //DbgBreakPoint();

    buffer = Buffer;
    offset = BlFileTable[FileId].Position.QuadPart;

    remainingLength = Length;
    if ( offset >= RamdiskImageLength ) {
        return EINVAL;
    }
    if ( remainingLength > (RamdiskImageLength - offset) ) {
        remainingLength = (ULONG)(RamdiskImageLength - offset);
    }

    bytesWritten = 0;

    while ( remainingLength != 0 ) {

        va = MapRamdisk( RamdiskImageOffset + offset, &availableLength );

        bytesThisPage = remainingLength;
        if ( remainingLength > availableLength ) {
            bytesThisPage = (ULONG)availableLength;
        }

        memcpy( va, buffer, bytesThisPage );

        offset += bytesThisPage;
        buffer += bytesThisPage;
        remainingLength -= bytesThisPage;
        bytesWritten += bytesThisPage;
    }

    BlFileTable[FileId].Position.QuadPart += bytesWritten;
    *Count = bytesWritten;

    return ESUCCESS;
}


ARC_STATUS
RamdiskRead(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Reads sectors directly from an open RAM disk.

Arguments:

    FileId - Supplies the file to read from

    Buffer - Supplies buffer to read into

    Length - Supplies number of bytes to read

    Count - Returns actual bytes read

Return Value:

    ESUCCESS - read completed successfully

    !ESUCCESS - read failed

--*/

{
    PUCHAR buffer;
    LONGLONG offset;
    ULONG remainingLength;
    LONGLONG availableLength;
    ULONG bytesRead;
    ULONG bytesThisPage;
    PVOID va;

    buffer = Buffer;
    offset = BlFileTable[FileId].Position.QuadPart;
    DBGPRINT(VERBOSE, ( "RamdiskRead: offset %x, length %x, buffer %p\n", (ULONG)offset, Length, buffer ));

    remainingLength = Length;
    if ( offset >= RamdiskImageLength ) {
        DBGPRINT(ERR, ( "RamdiskRead: read beyond EOF\n" ) );
        return EINVAL;
    }
    if ( remainingLength > (RamdiskImageLength - offset) ) {
        remainingLength = (ULONG)(RamdiskImageLength - offset);
    }

    bytesRead = 0;

    while ( remainingLength != 0 ) {

        va = MapRamdisk( RamdiskImageOffset + offset, &availableLength );
        DBGPRINT(VERBOSE, ( "Mapped offset %x, va %p, availableLength %x\n", (ULONG)offset, va, availableLength ) );

        bytesThisPage = remainingLength;
        if ( remainingLength > availableLength ) {
            bytesThisPage = (ULONG)availableLength;
        }

        memcpy( buffer, va, bytesThisPage );

        offset += bytesThisPage;
        buffer += bytesThisPage;
        remainingLength -= bytesThisPage;
        bytesRead += bytesThisPage;
    }

    BlFileTable[FileId].Position.QuadPart += bytesRead;
    *Count = bytesRead;

    return ESUCCESS;
}


ARC_STATUS
RamdiskGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION Finfo
    )
/*++

Routine Description:

    Returns file information about a RAMDISK file.

Arguments:

    FileId - id of the file

    Finfo - file information structure to be filled in

Return Value:

    ESUCCESS - write completed successfully

    !ESUCCESS - write failed

--*/
{
    RtlZeroMemory(Finfo, sizeof(FILE_INFORMATION));

    Finfo->EndingAddress.QuadPart = RamdiskImageLength;
    Finfo->CurrentPosition.QuadPart = BlFileTable[FileId].Position.QuadPart;
    Finfo->Type = DiskPeripheral;

    return ESUCCESS;
}

ARC_STATUS
RamdiskMount(
    IN CHAR * FIRMWARE_PTR MountPath,
    IN MOUNT_OPERATION Operation
    )
{
    UNREFERENCED_PARAMETER( MountPath );
    UNREFERENCED_PARAMETER( Operation );

    DBGPRINT(VERBOSE, ( "RamdiskMount called\n" ));
    return EINVAL;
}

ARC_STATUS
RamdiskReadStatus(
    IN ULONG FileId
    )
{
    UNREFERENCED_PARAMETER( FileId );

    DBGPRINT(VERBOSE, (  "RamdiskReadStatus called\n" ) );
    return EINVAL;
}

ARC_STATUS
RamdiskSetFileInfo (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )
{
    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( AttributeFlags );
    UNREFERENCED_PARAMETER( AttributeMask );

    DBGPRINT(VERBOSE, (  "RamdiskSetFileInfo called\n" ));
    return EINVAL;
}

ARC_STATUS
RamdiskRename (
    IN ULONG FileId,
    IN CHAR * FIRMWARE_PTR NewName
    )
{
    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( NewName );

    DBGPRINT(VERBOSE, (  "RamdiskRename called\n" ));
    return EINVAL;
}

ARC_STATUS
RamdiskGetDirectoryEntry (
    IN ULONG FileId,
    OUT PDIRECTORY_ENTRY Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    )
{
    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Count );

    DBGPRINT(VERBOSE, (  "RamdiskGetDirectoryEntry called\n" ));
    return EINVAL;
}

PVOID
MapRamdisk (
    LONGLONG Offset,
    PLONGLONG AvailableLength
    )
{
    LONGLONG physicalAddressOfOffset;

    physicalAddressOfOffset = ((LONGLONG)RamdiskBasePage << PAGE_SHIFT) + Offset;
    *AvailableLength = RamdiskFileSize - Offset;

#if defined(_X86_)
    //
    // the high 32 bits of physicalAddressOfOffset are 
    // going to be lost when returning the address as a pvoid.
    // find out if this is happening now.
    //
    ASSERT( (physicalAddressOfOffset >> 32) == 0 );
    return (PVOID)(ULONG)physicalAddressOfOffset;
#else
    return (PVOID)physicalAddressOfOffset;
#endif
}


PCHAR
RamdiskGetOptionValue(
    IN PCHAR LoadOptions,
    IN PCHAR OptionName
)
/*++

Routine Description:

    Parse the load options string returning a value of one of the
    options.

    Format supported: /OPTIONNAME=VALUE

    Note there is no space before or after the '='.
    Value is terminated with a '\r','\n',' ','/', or '\t'

Arguments:

    LoadOptions - Loader options from boot.ini. Must be all caps.

    OptionName - Name of the option to find.

Return Value:

    Pointer to a value string that has been allocated with
    BlAllocateHeap or NULL if the option has not found.

--*/
{
    PCHAR retValue = NULL;
    PCHAR value;
    PCHAR p;
    ULONG n;

    ASSERT( LoadOptions );
    ASSERT( OptionName );

    if ( (p = strstr( LoadOptions, OptionName )) != 0 ) {

        value = strchr( p , '=' );
        if (value) {

            value++;

            for (p = value;  *p;  p++) {
                if (*p == ' ') break;
                if (*p == '/') break;
                if (*p == '\n') break;
                if (*p == '\r') break;
                if (*p == '\t') break;
            }

            n = (ULONG)(p - value);
            retValue = (PCHAR)BlAllocateHeap( n+1 );
            if ( retValue ) {
                strncpy( retValue, value, n );
            }
        }
    }

    return retValue;
}


ULONG
RamdiskParseIPAddr(
    IN PCHAR psz
)
/*++

Routine Description:

    parses an ip address from a string
    
    Arguments:  [psz]     - Ip address string

    Returns:    ipaddress (in network byte order) or 0.

--*/
{
    ULONG nAddr = 0;
    ULONG nDigit = 0;
    ULONG cDigits = 0;


    for (; (psz!= NULL && *psz != 0); psz++) {
        if (*psz >= '0' && *psz <= '9') {
            nDigit = nDigit * 10 + *psz - '0';
            if ( nDigit > 255 ) {
                return 0;
            }
        }
        else if (*psz == '.') {
            nAddr = (nAddr << 8) | nDigit;
            nDigit = 0;
            cDigits++;
        } else {
            break;
        }
    }

    if (cDigits != 3) { 
        return 0;
    }

    nAddr = (nAddr << 8) | nDigit;
    return SWAP_DWORD( nAddr );
}


BOOLEAN
RamdiskHexStringToDword(
    IN PCHAR psz, 
    OUT PULONG RetValue,
    IN USHORT cDigits, 
    IN CHAR chDelim
)
/*++

Routine Description:

    scan psz for a number of hex digits (at most 8); update psz
    return value in Value; check for chDelim;

    Arguments:  [psz]    - the hex string to convert
                [Value]   - the returned value
                [cDigits] - count of digits

    Returns:    TRUE for success

--*/
{
    USHORT Count;
    ULONG Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, psz++)
    {
        if (*psz >= '0' && *psz <= '9') {
            Value = (Value << 4) + *psz - '0';
        } else if (*psz >= 'A' && *psz <= 'F') {
            Value = (Value << 4) + *psz - 'A' + 10;
        } else if (*psz >= 'a' && *psz <= 'f') {
            Value = (Value << 4) + *psz - 'a' + 10;
        } else {
            return(FALSE);
        }
    }

    *RetValue = Value;

    if (chDelim != 0) {
        return *psz++ == chDelim;
    } else {
        return TRUE;
    }
}


BOOLEAN
RamdiskUUIDFromString(
    IN PCHAR psz, 
    OUT LPGUID pguid
)
/**

Routine Description:

    Parse UUID such as 00000000-0000-0000-0000-000000000000

Arguments:  
    [psz]  - Supplies the UUID string to convert
    [pguid] - Returns the GUID.

Returns:    TRUE if successful

**/
{
    ULONG dw;

    if (!RamdiskHexStringToDword(psz, &pguid->Data1, sizeof(ULONG)*2, '-')) {
        return FALSE;
    }            
    psz += sizeof(ULONG)*2 + 1;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(USHORT)*2, '-')) {
        return FALSE;
    }            
    psz += sizeof(USHORT)*2 + 1;

    pguid->Data2 = (USHORT)dw;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(USHORT)*2, '-')) {
        return FALSE;
    }            
    psz += sizeof(USHORT)*2 + 1;

    pguid->Data3 = (USHORT)dw;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, 0)) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2;

    pguid->Data4[0] = (UCHAR)dw;
    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, '-')) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2+1;

    pguid->Data4[1] = (UCHAR)dw;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, 0)) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2;

    pguid->Data4[2] = (UCHAR)dw;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, 0)) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2;

    pguid->Data4[3] = (UCHAR)dw;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, 0)) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2;

    pguid->Data4[4] = (UCHAR)dw;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, 0)) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2;

    pguid->Data4[5] = (UCHAR)dw;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, 0)) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2;

    pguid->Data4[6] = (UCHAR)dw;
    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, 0)) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2;

    pguid->Data4[7] = (UCHAR)dw;

    return TRUE;
}


BOOLEAN
RamdiskGUIDFromString(
    IN PCHAR psz, 
    OUT LPGUID pguid
)
/**

Routine Description:

    Parse GUID such as {00000000-0000-0000-0000-000000000000}

Arguments:  
    [psz]   - Supplies the UUID string to convert
    [pguid] - Returns the GUID.

Returns:    TRUE if successful

**/
{

    if (*psz == '{' ) {
        psz++;
    }
    
    if (RamdiskUUIDFromString(psz, pguid) != TRUE) {
        return FALSE;
    }
    
    psz += 36;

    if (*psz == '}' ) {
        psz++;
    }
    
    if (*psz != '\0') {
       return FALSE;
    }

    return TRUE;
}


ARC_STATUS 
RamdiskParseOptions (
    IN PCHAR LoadOptions
)
/*++

Routine Description:

    Parses all the Ramdisk params from the boot.ini option string.

Arguments:

    LoadOptions - Loader options from boot.ini. Must be all caps.

    /RDPATH     - Indicates that the boot ramdisk should be downloaded
                  from the specified path. This option takes
                  precedence over RDBUILD.

                  Example: /RDPATH=net(0)\boot\ramdisk.dat

    /RDMTFTPADDR  - Specifies the Multicast Address where the ramdisk
                    image should be downloaded from. If not specified
                    a unicast download from the PXE boot server will
                    be performed.

    /RDMTFTPCPORT - Specifies the Multicast Client port to use.

    /RDMTFTPSPORT - Specifies the Multicast Server port to use.

    /RDMTFTPDELAY - Specifies the delay before starting a new MTFTP session.

    /RDMTFTPTIMEOUT - Specifies the timeout before restarting a MTFTP session.

    /RDIMAGEOFFSET - Specifies the offset into the downloaded file at which the
                     actual disk image begins. If not specified, 0 is used.

    /RDIMAGELENGTH - Specifies the length of the actual disk image. If not
                     specified, the size of the downloaded file minus the offset
                     to the image (RDIMAGEOFFSET) is used.

    /RDFILESIZE   - Specifies the size of the file to be downloaded.

    /RDCHUNKSIZE  - Specifies the size of each file chunck when more than
                    one MTFTP session is required to download a large file. If the
                    file is to be downloaded with one chunk this option is omitted
                    or is set to zero.

                    This is used to workaround a size limitation in the MTFTP 
                    protcol. MTFTP currently has 16-bit block counts, therefore 
                    when using 512 byte blocks we are limited to ~32MB files.

                    Example 1: assume we want to download a 85MB file 
                    using 512 byte TFTP block sizes.

                    /RDMTFTPADDR=224.1.1.1 /RDMTFTPCPORT=100 /RDMTFTPSPORT=200 
                    /RDCHUNKSIZE=31457280 /RDFILESIZE=89128960

                    1st MTFTP session on CPort=100, SPort=200 Size=31457280 (30MB)
                    2nd MTFTP session on CPort=101, SPort=201 Size=31457280 (30MB)
                    3rd MTFTP session on CPort=102, SPort=202 Size=26214400 (25MB)

                    Example 2: assume we want to download a 300MB file 
                    using 1468 byte TFTP block sizes.

                    /RDMTFTPADDR=224.1.1.2 /RDMTFTPCPORT=100 /RDMTFTPSPORT=200 
                    /RDCHUNKSIZE=94371840 /RDFILESIZE=314572800

                    1st MTFTP session on CPort=100, SPort=200 Size=94371840 (90MB)
                    2nd MTFTP session on CPort=101, SPort=201 Size=94371840 (90MB)
                    3rd MTFTP session on CPort=102, SPort=202 Size=94371840 (90MB)
                    4th MTFTP session on CPort=103, SPort=203 Size=31457280 (30MB)
                  

    /RDBUILD    - Indicates that the boot ramdisk should be built
                  from the build server. This is ignored if the RDBUILD
                  option is set.

                  Example: /RDBUILD

    /RDGUID     - Specifies the GUID of the configuration to be built
                  by the build server.

                  Example: /RDGUID={54C7D140-09EF-11D1-B25A-F5FE627ED95E}

    /RDDISCOVERY - Describes how we should discover the build server.
                   Possible values include:

                   M - A packet will be sent on the multicast
                       address specified by /RDMCASTADDR. The
                       first server to respond will be used. If
                       /RDMCASTADDR is not specified multicast
                       discovery is ignored.
                   
                   B - A packet will be broadcasted. First server
                       to respond will be used. This is the default.

                   U - A packet will be unicast to all the servers
                       specified in the /RMSERVERS. Or if /RMSERVERS
                       is not specified to the PXE Boot server.

                   R - Will only use servers that are included in 
                       the /RMSERVERS. This option is used to filter 
                       servers when specified in conjunction with broadcast
                       and Multicast discovery. It can also be used with 
                       unicast discovery to specify a list of servers
                       to use.

                   If more than one discovery option is specified then 
                   exactly one method will be selected according in the 
                   following order:

                        1) Multicast - M
                        2) Broadcast - B (Default)
                        3) Unicast  U

                   Examples:

                       /RDDISCOVERY=U   
                            This will send a unicast packet to the same 
                            server as the PXE Boot server.

                       /RDDISCOVERY=M /RDMCASTADDR=204.1.1.1 
                            This will send a multicast packet to the 
                            address sepcified.

                       /RDDISCOVERY=MBU /RDMCASTADDR=204.1.1.1 
                            This will use multicast discovery to the address
                            specified. If no boot server responds within the
                            timeout period. Note that Broadcast and Unicast
                            discovery are ignored.

                       /RDDISCOVERY=BR /RDSERVERS={10.0.0.3, 10.0.0.4}
                            This will send a broadcast packet but will only
                            accept responses from 10.0.0.3 or 10.0.0.4 .

                       /RDDISCOVERY=UR /RDSERVERS={10.0.0.3, 10.0.0.4}
                            A discovery packet will be sent to the two servers
                            specified and one of them will be selected.

    /RDMCASTADDR    Specifies the Multicast address to use for Build Server
                    multicast discovery.

    /RDSERVERS      Specifies a list of Build Servers to accpet responses 
                    from. A maximum of 10 servers are supported.

                    Example: /RDSERVERS={10.0.0.3, 10.0.0.4}

    /RDTIMEOUT      Specifies the timeout period to wait for a response in 
                    seconds. Default is 10 secs.

                    Example: /RDTIMEOUT=10                    

    /RDRETRY        Specifies the number of times to retry finding a build
                    server. Default is 5 times.

                    Example: /RDRETRY=5


Return Value:

    ESUCCESS - read completed successfully

    !ESUCCESS - read failed

--*/
{
    PCHAR value;
    PCHAR p;
    USHORT i;


    if ( LoadOptions == NULL ) {
        return ESUCCESS;
    }

    //
    // Get RDPATH and its associated options
    //
    RamdiskPath = RamdiskGetOptionValue( LoadOptions, "RDPATH" );

    if (RamdiskPath) {
    
        value = RamdiskGetOptionValue( LoadOptions, "RDIMAGEOFFSET" );
        if (value) RamdiskImageOffset = atoi( value );
        value = RamdiskGetOptionValue( LoadOptions, "RDIMAGELENGTH" );
        if (value) RamdiskImageLength = _atoi64( value );

        //
        // By Default the PXE Boot Server is the TFTP address
        //
        RamdiskTFTPAddr = NetServerIpAddress;

        //
        // Get the MTFTP Address used to download the image.
        // if not specified, the image will be downloaded
        // from the same place as ntldr (i.e. the PXE
        // boot server).
        //
        value = RamdiskGetOptionValue( LoadOptions, "RDMTFTPADDR" );
        if ( value ) {
            RamdiskMTFTPAddr = RamdiskParseIPAddr( value );
 
            value = RamdiskGetOptionValue( LoadOptions, "RDMTFTPCPORT" );
            if ( value ) RamdiskMTFTPCPort = SWAP_WORD( (USHORT)atoi( value ) );
            value = RamdiskGetOptionValue( LoadOptions, "RDMTFTPSPORT" );
            if (value) RamdiskMTFTPSPort = SWAP_WORD( (USHORT)atoi( value ) );
            value = RamdiskGetOptionValue( LoadOptions, "RDMTFTPDELAY" );
            if (value) RamdiskMTFTPDelay = (USHORT)atoi( value );
            value = RamdiskGetOptionValue( LoadOptions, "RDMTFTPTIMEOUT" );
            if (value) RamdiskMTFTPTimeout = (USHORT)atoi( value );
            value = RamdiskGetOptionValue( LoadOptions, "RDFILESIZE" );
            if (value) RamdiskMTFTPFileSize = _atoi64( value );
            value = RamdiskGetOptionValue( LoadOptions, "RDCHUNKSIZE" );
            if (value) RamdiskMTFTPChunkSize = _atoi64( value );

            // Validate options
            if ( RamdiskMTFTPAddr == 0 ||
                 RamdiskMTFTPCPort == 0 ||
                 RamdiskMTFTPSPort == 0 || 
                 RamdiskMTFTPDelay == 0 || 
                 RamdiskMTFTPTimeout == 0 ||
                 RamdiskMTFTPFileSize == 0 ||
                 RamdiskMTFTPChunkSize > RamdiskMTFTPFileSize ) {
                return EINVAL;
            }
            
        }

        if (DBGLVL(INFO)) {
            DbgPrint( "RAMDISK options:\n");
            DbgPrint( "RDPATH = %s\n", RamdiskPath);
            p = (PCHAR) &RamdiskMTFTPAddr;
            DbgPrint( "RDMTFTPADDR = %u.%u.%u.%u\n", p[0], p[1], p[2], p[3]);
            DbgPrint( "RDMTFTPCPORT = %d\n", SWAP_WORD( RamdiskMTFTPCPort ));
            DbgPrint( "RDMTFTPSPORT = %d\n", SWAP_WORD( RamdiskMTFTPSPort ));
            DbgPrint( "RDMTFTPDELAY = %d\n", RamdiskMTFTPDelay);
            DbgPrint( "RDMTFTPTIMEOUT = %d\n", RamdiskMTFTPTimeout);
            DbgPrint( "RDFILESIZE = 0x%0I64x bytes\n", RamdiskMTFTPFileSize );
            DbgPrint( "RDCHUNKSIZE = 0x%0I64x bytes\n", RamdiskMTFTPChunkSize );
            DbgPrint( "RDIMAGEOFFSET = 0x%x bytes\n", RamdiskImageOffset );
            DbgPrint( "RDIMAGELENGTH = 0x%0I64x bytes\n", RamdiskImageLength );
        }
        
        // we are done if RDPATH was specified.
        return ESUCCESS;
    }

#if defined(POST_XPSP)
    //
    // Check if RDBUILD exists
    //
    if ( strstr( LoadOptions, "RDBUILD" ) ) {

        RamdiskBuild = TRUE;

        value = RamdiskGetOptionValue( LoadOptions, "RDGUID" );
        if ( value == NULL ||
             RamdiskGUIDFromString( value, &RamdiskGuid ) == FALSE ) {
             return EINVAL;
        }

        value = RamdiskGetOptionValue( LoadOptions, "RDMCASTADDR" );
        if ( value ) RamdiskMCastAddr = RamdiskParseIPAddr( value );

        value = RamdiskGetOptionValue( LoadOptions, "RDSERVERS" );
        if ( value && *value == '{' ) {
            PCHAR e = strchr( value, '}' );

            p = value;

            if ( e && (ULONG)(e - p) > 7 ) { // at least seven characters for X.X.X.X
            
                while ( p && p < e && RamdiskServerCount < RAMDISK_MAX_SERVERS) {
                    RamdiskServers[RamdiskServerCount] = RamdiskParseIPAddr( p + 1 );
                    RamdiskServerCount++;
                    p = strchr( p + 1, ',' );
                }
            }
        }

        value = RamdiskGetOptionValue( LoadOptions, "RDDISCOVERY" );
        if ( value ) {
            // NOTE : order of these checks is important since
            //        they override each other.
            if ( strchr( value, 'U' ) ) {
                RamdiskDiscovery = RAMDISK_DISCOVERY_UNICAST;
            }
            if ( strchr( value, 'B' ) ) {
                RamdiskDiscovery = RAMDISK_DISCOVERY_BROADCAST;
            }
            if ( strchr( value, 'M' ) && RamdiskMCastAddr != 0 ) {
                RamdiskDiscovery = RAMDISK_DISCOVERY_MULTICAST;
            }
            if ( strchr( value, 'R' ) && RamdiskServerCount > 0 ) {
                RamdiskDiscovery |= RAMDISK_DISCOVERY_RESTRICT;
            }
        } else {
            // default is broadcast discovery
            RamdiskDiscovery = RAMDISK_DISCOVERY_BROADCAST;
        }

        value = RamdiskGetOptionValue( LoadOptions, "RDTIMEOUT" );
        if (value) RamdiskTimeout = (USHORT)atoi( value );
        value = RamdiskGetOptionValue( LoadOptions, "RDRETRY" );
        if (value) RamdiskRetry = (USHORT)atoi( value );

        //
        // Normalize options
        //
        if ( !TEST_BIT( RamdiskDiscovery, RAMDISK_DISCOVERY_RESTRICT) &&
             RamdiskServerCount > 0 ) {
             RamdiskServerCount = 0;   
        }

        if ( RamdiskDiscovery == RAMDISK_DISCOVERY_UNICAST ) {
             RamdiskServerCount = 1;
             RamdiskServers[0] = NetServerIpAddress;
        }

        //
        // Print out debug information
        //
        if (DBGLVL(INFO)) {
            DbgPrint("RDBUILD options:\n");
            DbgPrint("RDGUID = {%x-%x-%x-%x%x%x%x%x%x%x%x}\n",
                   RamdiskGuid.Data1, RamdiskGuid.Data2,
                   RamdiskGuid.Data3,
                   RamdiskGuid.Data4[0], RamdiskGuid.Data4[1],
                   RamdiskGuid.Data4[2], RamdiskGuid.Data4[3],
                   RamdiskGuid.Data4[4], RamdiskGuid.Data4[5],
                   RamdiskGuid.Data4[6], RamdiskGuid.Data4[7]);
            DbgPrint("RDDISCOVERY = %d\n", RamdiskDiscovery);
            p = (PCHAR) &RamdiskMCastAddr;
            DbgPrint("RDMCASTADDR = %u.%u.%u.%u\n", p[0], p[1], p[2], p[3]);
            DbgPrint("RDSERVERS = %d\n", RamdiskServerCount);
            for (i = 0; i < RamdiskServerCount; i++) {
                p = (PCHAR) &RamdiskServers[i];
                DbgPrint("RDSERVER[%d] = %u.%u.%u.%u\n", i, p[0], p[1], p[2], p[3]);
            }
            DbgPrint("RDTIMEOUT = %d\n", RamdiskTimeout);
            DbgPrint("RDRETRY = %d\n", RamdiskRetry);
        }
    }
#endif

    return ESUCCESS;
}


#if defined(POST_XPSP)
#if defined(i386) // RDBUILD is only supported on x86 machines for now

VOID
RamdiskDeviceInfoToString(
    PDEVICE_INFO pDevice,
    PCHAR DeviceString
    )
/*++

Routine Description:

    This routine generates a string representation of the Device info for 
    debugging purposes.

Arguments:

    pDefive - Pointer to the device info structure

    DeviceString - a pointer to a buffer that will hold the final string. The buffer
                   must be at least 128 * sizeof(CHAR) bytes.

Return Value:

    NONE.

--*/
{
    const CHAR HexToCharTable[17] = "0123456789ABCDEF";

    if (pDevice->DeviceType == BMBUILD_DEVICE_TYPE_PCI) {
        sprintf (   DeviceString, 
                    "%d.%d.%d PCI\\VEN_%04X&DEV_%04X&SUBSYS_%04X%04X&REV_%02X&CC_%02X%02X%02X", 
                    PCI_ITERATOR_TO_BUS( pDevice->info.pci.BusDevFunc ),
                    PCI_ITERATOR_TO_DEVICE( pDevice->info.pci.BusDevFunc ),
                    PCI_ITERATOR_TO_FUNCTION( pDevice->info.pci.BusDevFunc ),
                    pDevice->info.pci.VendorID,
                    pDevice->info.pci.DeviceID,
                    pDevice->info.pci.SubDeviceID,
                    pDevice->info.pci.SubVendorID,
                    pDevice->info.pci.RevisionID,
                    pDevice->info.pci.BaseClass,
                    pDevice->info.pci.SubClass,
                    pDevice->info.pci.ProgIntf );
    } else if (pDevice->DeviceType == BMBUILD_DEVICE_TYPE_PCI_BRIDGE ) {
        sprintf (   DeviceString, 
                    "%d.%d.%d PCI\\VEN_%04X&DEV_%04X&REV_%02X&CC_%02X%02X%02X Bridge %d->%d Sub = %d", 
                    PCI_ITERATOR_TO_BUS( pDevice->info.pci_bridge.BusDevFunc ),
                    PCI_ITERATOR_TO_DEVICE( pDevice->info.pci_bridge.BusDevFunc ),
                    PCI_ITERATOR_TO_FUNCTION( pDevice->info.pci_bridge.BusDevFunc ),
                    pDevice->info.pci_bridge.VendorID,
                    pDevice->info.pci_bridge.DeviceID,
                    pDevice->info.pci_bridge.RevisionID,
                    pDevice->info.pci_bridge.BaseClass,
                    pDevice->info.pci_bridge.SubClass,
                    pDevice->info.pci_bridge.ProgIntf,
                    pDevice->info.pci_bridge.PrimaryBus,
                    pDevice->info.pci_bridge.SecondaryBus,
                    pDevice->info.pci_bridge.SubordinateBus );
    
    } else if (pDevice->DeviceType == BMBUILD_DEVICE_TYPE_PNP) {
        CHAR ProductIDStr[8];
        PUCHAR id = (PUCHAR)&pDevice->info.pnp.EISADevID;

        ProductIDStr[0] = (id[0] >> 2) + 0x40;
        ProductIDStr[1] = (((id[0] & 0x03) << 3) | (id[1] >> 5)) + 0x40;
        ProductIDStr[2] = (id[1] & 0x1f) + 0x40;
        ProductIDStr[3] = HexToCharTable[id[2] >> 4];
        ProductIDStr[4] = HexToCharTable[id[2] & 0x0F];
        ProductIDStr[5] = HexToCharTable[id[3] >> 4];
        ProductIDStr[6] = HexToCharTable[id[3] & 0x0F];
        ProductIDStr[7] = 0x00;

        sprintf(    DeviceString,
                    "%s CC_%02X%02X%02X",
                    ProductIDStr,
                    pDevice->info.pnp.BaseClass,
                    pDevice->info.pnp.SubClass,
                    pDevice->info.pnp.ProgIntf );
    }
}


ARC_STATUS
RamdiskBuildRequest(
    IN PBMBUILD_REQUEST_PACKET pRequest
    )
/*++

Routine Description:

    This routine will form the build request packet.

Arguments:

    pRequest - a pointer to a buffer that will hold the request

Return Value:

    ESUCCESS - read completed successfully

    !ESUCCESS - read failed

--*/
{
    ARC_STATUS status;
    PDEVICE_INFO pDevice;
    t_PXENV_UNDI_GET_NIC_TYPE PxeNicType;
    PCONFIGURATION_COMPONENT_DATA Node = NULL;
    PCONFIGURATION_COMPONENT_DATA CurrentNode = NULL;
    PCONFIGURATION_COMPONENT_DATA ResumeNode = NULL;
    PPCIDEVICE pPCIDevice;
    PPNP_BIOS_INSTALLATION_CHECK pPNPBios;
    PPNP_BIOS_DEVICE_NODE pDevNode;
    PCM_PARTIAL_RESOURCE_LIST pPartialList;
    PUCHAR pCurr;
    USHORT cDevices;
    USHORT i;    
    ULONG lengthRemaining;
    ULONG x;
    PCHAR HalName = NULL;
    BOOLEAN fNICFound = FALSE;


    pRequest->Version = BMBUILD_PACKET_VERSION;
    pRequest->OpCode = BMBUILD_OPCODE_REQUEST;
    pRequest->Length = BMBUILD_REQUEST_FIXED_PACKET_LENGTH;
    
    //
    // Get the SMBIOS UUID (or PXE MAC address)
    //
    GetGuid( (PUCHAR*)&pRequest->MachineGuid, &x );
    ASSERT( x == sizeof( pRequest->MachineGuid ) );

    memcpy( &pRequest->ProductGuid, &RamdiskGuid, sizeof( GUID ) );
#ifdef _IA64_
    pRequest->Architecture = PROCESSOR_ARCHITECTURE_IA64;
#else
    pRequest->Architecture = PROCESSOR_ARCHITECTURE_INTEL;
#endif

    //
    // Detect the appropriate HAL using TextMode Setup methods.
    //

#ifdef DOWNLOAD_TXTSETUP_SIF
    status = SlInitIniFile(  "net(0)",
                             0,
                             "boot\\txtsetup.sif",
                             &InfFile,
                             NULL,
                             NULL,
                             &x);
#endif

    HalName = SlDetectHal();
    ASSERT( HalName != NULL );

    strcpy( (PCHAR) pRequest->Data, HalName );
    pRequest->HalDataOffset = BMBUILD_FIELD_OFFSET(BMBUILD_REQUEST_PACKET, Data);

    pRequest->Flags = 0;
    pRequest->DeviceCount = 0;
    pRequest->DeviceOffset = RESET_SIZE_AT_USHORT_MAX((ULONG)pRequest->HalDataOffset + strlen( HalName ) + 1);
    pDevice = (PDEVICE_INFO)( (PUCHAR)pRequest + pRequest->DeviceOffset );

    //
    // Get the PXE NIC information
    //
    RtlZeroMemory( &PxeNicType, sizeof( PxeNicType ) );
    status = RomGetNicType( &PxeNicType );
    if ( ( status != PXENV_EXIT_SUCCESS ) || ( PxeNicType.Status != PXENV_EXIT_SUCCESS ) ) {
        DBGPRINT( ERR, ( "RAMDISK ERROR: Couldn't get the NIC type from PXE. Failed with %x, status = %x\n", status, PxeNicType.Status ) );
        return ENODEV;
    }

    //
    // Fill in PCI Device information
    //

    Node = KeFindConfigurationEntry(FwConfigurationTree,
                                    PeripheralClass,
                                    RealModePCIEnumeration,
                                    NULL);
    ASSERT( Node != NULL );
    ASSERT( Node->ComponentEntry.ConfigurationDataLength > 0 );
    ASSERT( Node->ConfigurationData != NULL );

    pPCIDevice = (PPCIDEVICE)( (PUCHAR)Node->ConfigurationData + sizeof( CM_PARTIAL_RESOURCE_LIST ) );
    cDevices = (USHORT)( Node->ComponentEntry.ConfigurationDataLength - sizeof ( CM_PARTIAL_RESOURCE_LIST ) ) / sizeof ( PCIDEVICE );

    if (cDevices > BMBUILD_MAX_DEVICES( RamdiskMaxPacketSize ) ) {
        DBGPRINT(ERR, ("RAMDISK ERROR: Too many PCI devices to fit in a request\n"));
        return EINVAL;
    }

    for (i = 0; i < cDevices; i++ ) {

        //
        // check if this is a bridge or a normal device
        //
        if ( (pPCIDevice->Config.HeaderType & (~PCI_MULTIFUNCTION) ) == PCI_BRIDGE_TYPE) {
            //
            // Bridge.
            //
            pDevice[i].DeviceType = BMBUILD_DEVICE_TYPE_PCI_BRIDGE;

            pDevice[i].info.pci_bridge.BusDevFunc = pPCIDevice->BusDevFunc;
            pDevice[i].info.pci_bridge.VendorID = pPCIDevice->Config.VendorID;
            pDevice[i].info.pci_bridge.DeviceID = pPCIDevice->Config.DeviceID;
            pDevice[i].info.pci_bridge.BaseClass = pPCIDevice->Config.BaseClass;
            pDevice[i].info.pci_bridge.SubClass = pPCIDevice->Config.SubClass;
            pDevice[i].info.pci_bridge.ProgIntf = 0;
            pDevice[i].info.pci_bridge.RevisionID = pPCIDevice->Config.RevisionID;
            pDevice[i].info.pci_bridge.PrimaryBus = pPCIDevice->Config.u.type1.PrimaryBus;
            pDevice[i].info.pci_bridge.SecondaryBus = pPCIDevice->Config.u.type1.SecondaryBus;
            pDevice[i].info.pci_bridge.SubordinateBus = pPCIDevice->Config.u.type1.SubordinateBus;

        } else {
            //
            // Non-bridge PCI device
            //
            pDevice[i].DeviceType = BMBUILD_DEVICE_TYPE_PCI;

            pDevice[i].info.pci.BusDevFunc = pPCIDevice->BusDevFunc;
            pDevice[i].info.pci.VendorID = pPCIDevice->Config.VendorID;
            pDevice[i].info.pci.DeviceID = pPCIDevice->Config.DeviceID;
            pDevice[i].info.pci.BaseClass = pPCIDevice->Config.BaseClass;
            pDevice[i].info.pci.SubClass = pPCIDevice->Config.SubClass;
            pDevice[i].info.pci.ProgIntf = 0;
            pDevice[i].info.pci.RevisionID = pPCIDevice->Config.RevisionID;
            pDevice[i].info.pci.SubVendorID = pPCIDevice->Config.u.type0.SubVendorID;
            pDevice[i].info.pci.SubDeviceID = pPCIDevice->Config.u.type0.SubSystemID;

            //
            // Check if this device is the PXE boot device
            //
            if ( PxeNicType.NicType == 2 &&
                 PxeNicType.pci_pnp_info.pci.BusDevFunc == ( pPCIDevice->BusDevFunc & 0x7FFF ) ) {

                 pRequest->PrimaryNicIndex = i;
                 fNICFound = TRUE;
            }
        }
                
        pPCIDevice++;
    }

    pRequest->DeviceCount = pRequest->DeviceCount + cDevices;
    pDevice += cDevices;

    //
    // Fill in PNP Device information (if there)
    //

    Node = NULL;
    
    while ((CurrentNode = KeFindConfigurationNextEntry(
                            FwConfigurationTree, 
                            AdapterClass, 
                            MultiFunctionAdapter,
                            NULL, 
                            &ResumeNode)) != 0) {
        if (!(strcmp(CurrentNode->ComponentEntry.Identifier,"PNP BIOS"))) {
            Node = CurrentNode;
            break;
        }
        ResumeNode = CurrentNode;
    }

    if ( Node != NULL ) {
        //
        // Set the PnP BIOS devices if found
        //
        ASSERT( Node->ComponentEntry.ConfigurationDataLength > 0 );
        ASSERT( Node->ConfigurationData != NULL );

        pPartialList = (PCM_PARTIAL_RESOURCE_LIST)Node->ConfigurationData;
        pPNPBios = (PPNP_BIOS_INSTALLATION_CHECK)( (PUCHAR)Node->ConfigurationData + sizeof( CM_PARTIAL_RESOURCE_LIST ) );

        pCurr = (PUCHAR)pPNPBios + pPNPBios->Length;
        lengthRemaining = pPartialList->PartialDescriptors[0].u.DeviceSpecificData.DataSize - pPNPBios->Length;

        for (cDevices = 0; lengthRemaining > sizeof(PNP_BIOS_DEVICE_NODE); cDevices++) {

            if ((pRequest->DeviceCount + cDevices + 1) > BMBUILD_MAX_DEVICES( RamdiskMaxPacketSize ) ) {
                DBGPRINT(ERR, ("RAMDISK ERROR: Too many PNP devices to fit in a request\n"));
                return EINVAL;
            }

            pDevNode = (PPNP_BIOS_DEVICE_NODE)pCurr;

            if (pDevNode->Size > lengthRemaining) {

                DBGPRINT(   ERR,
                            ( "PNP Node # %d, invalid size (%d), length remaining (%d)\n",
                              pDevNode->Node,
                              pDevNode->Size,
                              lengthRemaining ) );
                ASSERT( FALSE );
                // REVIEW: [bassamt] Should I fail here?
                break;
            }

            pDevice->DeviceType = BMBUILD_DEVICE_TYPE_PNP;
            pDevice->info.pnp.EISADevID = pDevNode->ProductId;
            pDevice->info.pnp.BaseClass = pDevNode->DeviceType[0];
            pDevice->info.pnp.SubClass = pDevNode->DeviceType[1];
            pDevice->info.pnp.ProgIntf = pDevNode->DeviceType[2];
            pDevice->info.pnp.CardSelNum = pDevNode->Node;

            if ( PxeNicType.NicType == 3 &&
                 PxeNicType.pci_pnp_info.pnp.EISA_Dev_ID == pDevNode->ProductId &&
                 PxeNicType.pci_pnp_info.pnp.CardSelNum == pDevNode->Node) {

                 pRequest->PrimaryNicIndex = pRequest->DeviceCount + cDevices;
                 fNICFound = TRUE;
            }

            pCurr += pDevNode->Size;
            lengthRemaining -= pDevNode->Size;
            pDevice++;
        }

        pRequest->DeviceCount = pRequest->DeviceCount + cDevices;
    }

    //
    // We better have found the primary NIC or the packet is invalid
    //
    if (!fNICFound) {
        DBGPRINT(ERR, ("RAMDISK ERROR: Could not find the primary NIC\n"));
        return ENODEV;
    }
        
    //
    // Set the packet length
    //
    pRequest->Length += pRequest->DeviceCount * sizeof( DEVICE_INFO );

    ASSERT ( pRequest->Length <= RamdiskMaxPacketSize );

    //
    // Debug prints
    //
    if (DBGLVL(INFO)) {
        DbgPrint("RAMDISK Build Request\n");
        DbgPrint("Architecture = %d\n", pRequest->Architecture);
        DbgPrint("MachineGuid = {%x-%x-%x-%x%x%x%x%x%x%x%x}\n",
               pRequest->MachineGuid.Data1, pRequest->MachineGuid.Data2,
               pRequest->MachineGuid.Data3,
               pRequest->MachineGuid.Data4[0], pRequest->MachineGuid.Data4[1],
               pRequest->MachineGuid.Data4[2], pRequest->MachineGuid.Data4[3],
               pRequest->MachineGuid.Data4[4], pRequest->MachineGuid.Data4[5],
               pRequest->MachineGuid.Data4[6], pRequest->MachineGuid.Data4[7]);
        DbgPrint("ProductGuid = {%x-%x-%x-%x%x%x%x%x%x%x%x}\n",
               pRequest->ProductGuid.Data1, pRequest->ProductGuid.Data2,
               pRequest->ProductGuid.Data3,
               pRequest->ProductGuid.Data4[0], pRequest->ProductGuid.Data4[1],
               pRequest->ProductGuid.Data4[2], pRequest->ProductGuid.Data4[3],
               pRequest->ProductGuid.Data4[4], pRequest->ProductGuid.Data4[5],
               pRequest->ProductGuid.Data4[6], pRequest->ProductGuid.Data4[7]);
        DbgPrint("HALName = %s\n", HalName);
        DbgPrint("Flags = 0x%x\n", pRequest->Flags);
        DbgPrint("DeviceCount = %d\n", pRequest->DeviceCount);
        pDevice = (PDEVICE_INFO)( (PUCHAR)pRequest + pRequest->DeviceOffset );

        for (i = 0; i < pRequest->DeviceCount; i++ ) {
            CHAR DeviceString[128];
            RamdiskDeviceInfoToString( pDevice, DeviceString );
            DbgPrint( "[%d] %s %s\n", i, DeviceString, (i == pRequest->PrimaryNicIndex? "PRIMARY NIC" : "") );
            pDevice++;
        }
    }
    
    return ESUCCESS;
}


ARC_STATUS
RamdiskSendDiscoverPacketAndWait(
    IN PBMBUILD_DISCOVER_PACKET pDiscover,
    IN ULONG DestinationAddress,
    IN ULONG Timeout,
    IN BOOLEAN fExcludeServers,
    IN ULONG DiscoveryStartTime,
    IN ULONG TotalExpectedWaitTime,
    OUT PULONG pBuildServerChosen
    )
/*++

Routine Description:

    This routine will send a discovery packet on the network in 
    accordance with the RamdiskDiscovery paramters. It will then
    select wait for a timeout period for replies and select the best
    response.

Arguments:

    pDiscover - Discover packet to send out

    DestinationAddress - destination address of the discovery packet

    Timeout - timeout interval

    fExcludeServers - if TRUE the response are filtered through the server list

    DiscoveryStartTime - time when discovery was started 
    
    TotalExpectedWaitTime - total time we expect to be in discovery. for updating the progress bar

    pBuildServerChosen - pointer to storage that will hold the chosen server

Return Value:

    ESUCCESS - successfully selected a boot server

    !ESUCCESS - no build server chosen

--*/
{
    ULONG WaitStartTime;
    BMBUILD_ACCEPT_PACKET Accept;
    PUCHAR p = (PUCHAR) &DestinationAddress;
    ULONG lastProgressPercent = 0;
    BOOLEAN ForceDisplayFirstTime = TRUE;
    ULONG currentProgressPercent;
    USHORT BestBuildTime = 0xFFFF;
    USHORT iServer;
    ULONG Length;
    ULONG RemoteHost = 0;
    USHORT RemotePort = 0;

    //
    // No server chosen initially
    //
    *pBuildServerChosen = 0;

    //
    // Send the discovery packet to the destination address
    //
    if ( RomSendUdpPacket( (PVOID)pDiscover, 
                            sizeof( BMBUILD_DISCOVER_PACKET ), 
                            DestinationAddress, 
                            BMBUILD_SERVER_PORT ) != sizeof( BMBUILD_DISCOVER_PACKET ) ) {
        
        DBGPRINT(ERR, ("FAILED to send discovery packet to %u.%u.%u.%u:%u\n", p[0], p[1], p[2], p[3], SWAP_WORD( BMBUILD_SERVER_PORT )));

        //
        // update progress bar. this happens here since a timed out packet
        // might take some time.
        //
        currentProgressPercent = ((SysGetRelativeTime() - DiscoveryStartTime ) * 100) / TotalExpectedWaitTime;
        if ( ForceDisplayFirstTime || (currentProgressPercent != lastProgressPercent) ) {
            BlUpdateProgressBar( currentProgressPercent );
            ForceDisplayFirstTime = FALSE;
        }
        lastProgressPercent = currentProgressPercent;


        return EINVAL;
    }

    DBGPRINT(INFO, ("Sent discovery packet to %u.%u.%u.%u:%u\n", p[0], p[1], p[2], p[3], SWAP_WORD( BMBUILD_SERVER_PORT )));

    //
    // Wait for the responses. We will wait for the timeout period and
    // select the best ACCEPT we get within this timeout. The best accept
    // is the one with the lowest build time.
    //

    WaitStartTime = SysGetRelativeTime();

    while ( (SysGetRelativeTime() - WaitStartTime) < Timeout ) {

        Length = RomReceiveUdpPacket( (PVOID)&Accept, sizeof(Accept), 0, &RemoteHost, &RemotePort);
        if ( Length == sizeof( BMBUILD_ACCEPT_PACKET ) &&
            RemotePort == BMBUILD_SERVER_PORT &&
            Accept.Version == BMBUILD_PACKET_VERSION && 
            Accept.OpCode == BMBUILD_OPCODE_ACCEPT && 
            Accept.Length == sizeof( BMBUILD_ACCEPT_PACKET ) - BMBUILD_COMMON_PACKET_LENGTH &&
            Accept.XID == pDiscover->XID ) {

            ULONG AcceptedBuildServer = RemoteHost;

            ASSERT( RemoteHost != 0 );
            ASSERT( RemoteHost != 0xFFFFFFFF );

            p = (PUCHAR) &RemoteHost;
            DBGPRINT(INFO, ("Received ACCEPT packet XID = %d from %u.%u.%u.%u:%u\n", Accept.XID, p[0], p[1], p[2], p[3], SWAP_WORD( BMBUILD_SERVER_PORT )));

            //
            // Exclude servers if we were asked to
            //
            if ( fExcludeServers ) {
               for (iServer = 0; iServer < RamdiskServerCount; iServer++) {
                   if (RemoteHost == RamdiskServers[iServer]) {
                       p = (PUCHAR) &RemoteHost;
                       DBGPRINT(INFO, ("Ignoring ACCEPT packet from %u.%u.%u.%u:%u\n", p[0], p[1], p[2], p[3], SWAP_WORD( BMBUILD_SERVER_PORT )));
                       AcceptedBuildServer = 0;
                       break;
                    }
                }
            }
             
            //
            // We have a valid packet from a build server. Check 
            // if it is the best one. "Best" is determined by 
            // the first server to respond with the lowest
            // builtime.
            //
            if ( AcceptedBuildServer != 0 &&
                 Accept.BuildTime < BestBuildTime) {

                p = (PUCHAR) &AcceptedBuildServer;
                DBGPRINT(INFO, ("We picked server at %u.%u.%u.%u:%u for this build\n", p[0], p[1], p[2], p[3], SWAP_WORD( BMBUILD_SERVER_PORT )));

                *pBuildServerChosen = AcceptedBuildServer;

                return ESUCCESS;
            }
        }

        //
        // update progress bar
        //
        currentProgressPercent = ((SysGetRelativeTime() - DiscoveryStartTime ) * 100) / TotalExpectedWaitTime;
        if ( ForceDisplayFirstTime || (currentProgressPercent != lastProgressPercent) ) {
            BlUpdateProgressBar( currentProgressPercent );
            ForceDisplayFirstTime = FALSE;
        }
        lastProgressPercent = currentProgressPercent;
    }

    return ENOENT;
}


ARC_STATUS
RamdiskDiscoverBuildServer(
    OUT PULONG BuildServerIpAddress
    )
/*++

Routine Description:

    This routine will send a discovery packet on the network in 
    accordance with the RamdiskDiscovery paramters. It will then
    select a acceptance from one of the build servers that respond
    and return its IP Address.

Arguments:

    BuildServerIpAddress - returned Build server IP address

Return Value:

    ESUCCESS - successfully selected a boot server

    !ESUCCESS - no build server responded

--*/
{
#define DISCOVER_RETRIES 4  // 4 retries
#define DISCOVER_TIMEOUT 4  // starting at 4 then 8, 16, and 32
#define DISCOVER_TOTAL_TIMEOUT_TIME (4+8+16+32)  // total time that we could be waiting for responses
#define DISCOVER_SEND_TIMEOUT 3                    // Time it takes to send a packet to an invalid address

    BMBUILD_DISCOVER_PACKET Discover;
    BOOLEAN fExcludeServers = FALSE;
    ULONG iRetry;
    ULONG cRetries = DISCOVER_RETRIES;
    ULONG Timeout = DISCOVER_TIMEOUT;
    ULONG x;
    ULONG DestinationAddress = 0xFFFFFFFF;
    ULONG DiscoveryStartTime = SysGetRelativeTime();
    ULONG TotalExpectedWaitTime;
    USHORT iServer;


    ASSERT( BuildServerIpAddress );
    
    *BuildServerIpAddress = 0;

    //
    // Short-circuit discovery if we are unicasting to one server
    //
    if ( RamdiskDiscovery == RAMDISK_DISCOVERY_UNICAST &&
         RamdiskServerCount == 1 ) {
        ASSERT( RamdiskServers[0] != 0 );
        ASSERT( RamdiskServers[0] != 0xFFFFFFFF );
        *BuildServerIpAddress = RamdiskServers[0];
        return ESUCCESS;
    }

    //
    // Fill in Discover packet
    //

    Discover.Version = BMBUILD_PACKET_VERSION;
    Discover.OpCode = BMBUILD_OPCODE_DISCOVER;
    Discover.Length = sizeof( BMBUILD_DISCOVER_PACKET ) - BMBUILD_COMMON_PACKET_LENGTH;
    GetGuid( (PUCHAR*)&Discover.MachineGuid, &x );
    ASSERT( x == sizeof( Discover.MachineGuid ) );
    memcpy( &Discover.ProductGuid, &RamdiskGuid, sizeof( GUID ) );

    //
    // Start the discovery. Note that this will be repeated a number
    // of times to account for network congestion and load on the servers.
    //

    BlOutputStartupMsg(RAMDISK_BUILD_DISCOVER);
    BlUpdateProgressBar(0);

    //
    // If we are doing multicast or broadcast discovery
    //
    if ( TEST_BIT( RamdiskDiscovery, RAMDISK_DISCOVERY_BROADCAST ) ||
         TEST_BIT( RamdiskDiscovery, RAMDISK_DISCOVERY_MULTICAST ) ) {

        TotalExpectedWaitTime = DISCOVER_TOTAL_TIMEOUT_TIME;

        for (iRetry = 0; iRetry < cRetries; iRetry++) {

            // Each Discover / Accpet gets its own transaction ID.
            Discover.XID = ++RamdiskXID;

            DBGPRINT(INFO, ("Sending Discovery packet XID = %d. Retry %d out of %d. Timeout = %d\n", Discover.XID, iRetry, cRetries, Timeout));

            if ( TEST_BIT( RamdiskDiscovery, RAMDISK_DISCOVERY_MULTICAST) ) {
                DestinationAddress = RamdiskMCastAddr;
            } else if ( TEST_BIT( RamdiskDiscovery, RAMDISK_DISCOVERY_BROADCAST ) ) {
                DestinationAddress = 0xFFFFFFFF;
            }

            if ( TEST_BIT( RamdiskDiscovery, RAMDISK_DISCOVERY_RESTRICT ) ) {
                ASSERT( RamdiskServerCount > 0 );
                fExcludeServers = TRUE;
            }
            
            if ( RamdiskSendDiscoverPacketAndWait( &Discover,
                                                   DestinationAddress,
                                                   Timeout,
                                                   fExcludeServers,
                                                   DiscoveryStartTime,
                                                   TotalExpectedWaitTime,
                                                   BuildServerIpAddress ) == ESUCCESS ) {
                // we found a server. we are done.
                BlUpdateProgressBar( 100 );
                return ESUCCESS;
            }

            // double the timeout
            Timeout = Timeout * 2;
            
        }

    } else {
        //
        // We are doing Unicast discovery to a fixed list of server addresses
        // in the order that they appear in the list. first to respond within
        // the timeout period wins
        //
            
        TotalExpectedWaitTime = RamdiskServerCount * ( RamdiskTimeout + DISCOVER_SEND_TIMEOUT ); 

        for (iServer = 0; iServer < RamdiskServerCount; iServer++) {

            // Each Discover / Accpet gets its own transaction ID.
            Discover.XID = ++RamdiskXID;

            if (RamdiskSendDiscoverPacketAndWait( &Discover,
                                                  RamdiskServers[iServer],
                                                  RamdiskTimeout,
                                                  FALSE,
                                                  DiscoveryStartTime,
                                                  TotalExpectedWaitTime,
                                                  BuildServerIpAddress ) == ESUCCESS ) {
                // we found a server. we are done.
                BlUpdateProgressBar( 100 );
                return ESUCCESS;
            }
        }
    }

    BlUpdateProgressBar( 100 );
    
    return EINVAL;
}


VOID
RamdiskWait(
    ULONG WaitTime
    )
{
    ULONG startTime = SysGetRelativeTime();
    while ( (SysGetRelativeTime() - startTime) < WaitTime ) {
    }
}


VOID
RamdiskPrintBuildProgress(
    ULONG uMsgId,
    ULONG BuildServerIpAddress
    )
{    
    PUCHAR p;
    PTCHAR FormatString = NULL;
    TCHAR Buffer[256];

    //
    // print progress message
    //
    p = (PUCHAR) &BuildServerIpAddress;
    FormatString = BlFindMessage( uMsgId );
    if ( FormatString != NULL ) {
        _stprintf(Buffer, FormatString, p[0], p[1], p[2], p[3] );
        BlOutputTrailerMsgStr( Buffer );
    }
}

ARC_STATUS
RamdiskBuildAndInitialize(
    )
/*++

Routine Description:

    This routine will communicate with a build server to build 
    a ramdisk and obtain a RDPATH.

Arguments:


Return Value:

    ESUCCESS - read completed successfully

    !ESUCCESS - read failed

--*/
{
    ARC_STATUS status;
    PBMBUILD_REQUEST_PACKET pRequest = NULL;
    PBMBUILD_RESPONSE_PACKET pResponse = NULL;
    USHORT iRetry = 0;
    ULONG Length;
    ULONG RemoteHost = 0;
    USHORT RemotePort = 0;
    PUCHAR p;
    BOOLEAN fSuccess = FALSE;
    ULONG BuildServerIpAddress = 0;
    

    //
    // Set the max packet size. This is calculate from the 
    // MTU size of the network (1500 for Ethernet) minus
    // the IP and UDP headers ( which account to 28 bytes ).
    //
    RamdiskMaxPacketSize = NetMaxTranUnit - 28;

    ASSERT( RamdiskMaxPacketSize > 0 );

    pRequest = BlAllocateHeap( RamdiskMaxPacketSize );
    if ( pRequest == NULL ) {
        DBGPRINT(ERR, ("Failed to allocate request packet of size %d.\n", RamdiskMaxPacketSize));
        return ENOMEM;
    }

    pResponse = BlAllocateHeap( RamdiskMaxPacketSize );
    if ( pRequest == NULL ) {
        DBGPRINT(ERR, ("Failed to allocate request packet of size %d.\n", RamdiskMaxPacketSize));
        return ENOMEM;
    }

    memset(pRequest, 0, RamdiskMaxPacketSize);
    memset(pResponse, 0, RamdiskMaxPacketSize);

    //
    // All packets sent from client will go from the client port
    //
    RomSetReceiveStatus( BMBUILD_CLIENT_PORT );


    //
    // Discover build server
    //
    status = RamdiskDiscoverBuildServer( &BuildServerIpAddress );
    if (status != ESUCCESS ) {
        goto Error;
    }

    //
    // Build request packet
    //
    status = RamdiskBuildRequest( pRequest );
    if ( status != ESUCCESS ) {
        goto Error;
    }

    //
    // Start communication with boot server. Display the text progress 
    // bar when booting of a ramdisk
    //
    BlOutputStartupMsg(RAMDISK_BUILD_REQUEST);
    BlUpdateProgressBar(0);
    RamdiskPrintBuildProgress( RAMDISK_BUILD_PROGRESS, BuildServerIpAddress );
   
    DBGPRINT(INFO, ("Requesting appropriate image for this computer...\n"));
   
    while ( iRetry < RamdiskRetry ) {

        BlUpdateProgressBar( (iRetry * 100) / RamdiskRetry );

        Length = pRequest->Length + BMBUILD_COMMON_PACKET_LENGTH;

        // allocate a new transaction ID for this session
        pRequest->XID = ++RamdiskXID;

        p = (PUCHAR) &NetServerIpAddress;
        DBGPRINT(INFO, ( "Sending request packet (%d bytes) XID = %d to %u.%u.%u.%u:%u.\n", 
            Length, pRequest->XID, p[0], p[1], p[2], p[3], SWAP_WORD( BMBUILD_SERVER_PORT ) ) );

        if ( RomSendUdpPacket( (PVOID)pRequest, Length, BuildServerIpAddress, BMBUILD_SERVER_PORT ) != Length ) {
            RamdiskWait( RamdiskTimeout );
            iRetry++;
            RamdiskPrintBuildProgress( RAMDISK_BUILD_PROGRESS_ERROR, BuildServerIpAddress );
            continue;
        }

        DBGPRINT(INFO, ( "Waiting for response (Timeout = %d secs).\n", RamdiskTimeout ) );

        Length = RomReceiveUdpPacket( (PVOID)pResponse, RamdiskMaxPacketSize, RamdiskTimeout, &RemoteHost, &RemotePort);
        if ( Length == 0 ) {
            DBGPRINT(INFO, ( "Receive timed out.\n") );
            iRetry++;
            RamdiskPrintBuildProgress( RAMDISK_BUILD_PROGRESS_TIMEOUT, BuildServerIpAddress );
            continue;
        }

        if ( Length < BMBUILD_RESPONSE_FIXED_PACKET_LENGTH - BMBUILD_COMMON_PACKET_LENGTH ||
             RemoteHost != BuildServerIpAddress ||
             RemotePort != BMBUILD_SERVER_PORT ||
             pResponse->OpCode != BMBUILD_OPCODE_RESPONSE ||
             pResponse->Version != BMBUILD_PACKET_VERSION || 
             pResponse->XID != pRequest->XID ) {

            p = (PUCHAR) &RemoteHost;
            DBGPRINT(INFO, ("Received invalid packet OpCode = %d Length = %d Version = %d XID = %d from %u.%u.%u.%u:%u\n",
                pResponse->OpCode, 
                pResponse->Length, pResponse->Version, pResponse->XID,
                p[0], p[1], p[2], p[3], SWAP_WORD( RemotePort ) ) );

            RamdiskWait( RamdiskTimeout );
            iRetry++;
            RamdiskPrintBuildProgress( RAMDISK_BUILD_PROGRESS_ERROR, BuildServerIpAddress );
            continue;
        }

        p = (PUCHAR) &RemoteHost;
        DBGPRINT(INFO, ("Received VALID packet OpCode = %d Length = %d Version = %d XID = %d from %u.%u.%u.%u:%u\n",
            pResponse->OpCode, 
            pResponse->Length, pResponse->Version, pResponse->XID,
            p[0], p[1], p[2], p[3], SWAP_WORD( RemotePort )) );

        if ( BMBUILD_IS_E( pResponse->Error ) ) {
            DBGPRINT(INFO, ("Request Failed. Error = %x\n", pResponse->Error) );
            RamdiskWait( RamdiskTimeout );
            iRetry++;
            RamdiskPrintBuildProgress( RAMDISK_BUILD_PROGRESS_PENDING, BuildServerIpAddress );
            continue;
        }

        if ( pResponse->Error == BMBUILD_S_REQUEST_PENDING ) {
            DBGPRINT(INFO, ("Request is pending. Instructed to wait for %d secs.\n", pResponse->WaitTime ) );
            RamdiskWait( pResponse->WaitTime );
            RamdiskPrintBuildProgress( RAMDISK_BUILD_PROGRESS_ERROR, BuildServerIpAddress );
            continue;
        }

        ASSERT( BMBUILD_S ( pResponse->Error ) );

        fSuccess = TRUE;
        break;
    }


    if (fSuccess) {

        ASSERT ( RamdiskPath == NULL );

        RamdiskPrintBuildProgress( RAMDISK_BUILD_PROGRESS, BuildServerIpAddress );
        BlUpdateProgressBar( 100 );

        //
        // Set the MTFTP options
        //
        RamdiskTFTPAddr = pResponse->TFTPAddr.Address;
        RamdiskMTFTPAddr = pResponse->MTFTPAddr.Address;
        RamdiskMTFTPCPort = pResponse->MTFTPCPort;
        RamdiskMTFTPSPort = pResponse->MTFTPSPort;
        RamdiskMTFTPTimeout = pResponse->MTFTPTimeout;
        RamdiskMTFTPDelay = pResponse->MTFTPDelay;
        RamdiskMTFTPFileSize = pResponse->MTFTPFileSize;
        RamdiskMTFTPChunkSize = pResponse->MTFTPChunkSize;

        //
        // Set the image offset and length
        //
        RamdiskImageOffset = pResponse->ImageFileOffset;
        RamdiskImageLength = pResponse->ImageFileLength;

        p = (PUCHAR)((ULONG_PTR)pResponse + pResponse->ImagePathOffset);

        RamdiskPath = BlAllocateHeap( strlen((PCHAR)p ) + sizeof ( "net(0)\\" ) );
        if ( RamdiskPath == NULL ) {
            DBGPRINT(ERR, ("Failed to allocate memory for RamdiskPath size %d.\n", strlen((PCHAR)p ) + sizeof ( "net(0)\\" )));
            return ENOMEM;
        }

        strcpy( RamdiskPath, "net(0)\\" );
        strcat( RamdiskPath, (PCHAR)p );

        if (DBGLVL(INFO)) {
            DbgPrint( "RDPATH = %s\n", RamdiskPath);
            p = (PUCHAR) &RamdiskTFTPAddr;
            DbgPrint( "RDTFTPADDR = %u.%u.%u.%u\n", p[0], p[1], p[2], p[3]);
            p = (PUCHAR) &RamdiskMTFTPAddr;
            DbgPrint( "RDMTFTPADDR = %u.%u.%u.%u\n", p[0], p[1], p[2], p[3]);
            DbgPrint( "RDMTFTPCPORT = %d\n", SWAP_WORD( RamdiskMTFTPCPort ));
            DbgPrint( "RDMTFTPSPORT = %d\n", SWAP_WORD( RamdiskMTFTPSPort ));
            DbgPrint( "RDMTFTPDELAY = %d\n", RamdiskMTFTPDelay);
            DbgPrint( "RDMTFTPTIMEOUT = %d\n", RamdiskMTFTPTimeout);
            DbgPrint( "RDFILESIZE = 0x%0I64x bytes\n", RamdiskMTFTPFileSize );
            DbgPrint( "RDCHUNKSIZE = 0x%0I64x bytes\n", RamdiskMTFTPChunkSize );
            DbgPrint( "RDIMAGEOFFSET = 0x%x bytes\n", RamdiskImageOffset );
            DbgPrint( "RDIMAGELENGTH = 0x%0I64x bytes\n", RamdiskImageLength );
        }
    
    } else {

        DBGPRINT(ERR, ("RamdiskBuildAndInitialize: Failed.\n"));
        return EINVAL;
    }        

    return ESUCCESS;

Error:
    return status;
}

#endif
#endif // defined(POST_XPSP)

VOID
RamdiskFatalError(
    IN ULONG Message1,
    IN ULONG Message2
    )
/*++

Routine Description:

    This function looks up a message to display at a error condition.

Arguments:

    Message - message that describes the class of problem.

Return Value:

    none

--*/
{

    PTCHAR Text;
    TCHAR Buffer[40];
    ULONG Count;


    BlClearScreen();

    Text = BlFindMessage(Message1);
    if (Text == NULL) {
        _stprintf(Buffer,TEXT("%08lx\r\n"),Message1);
        Text = Buffer;
    }

    ArcWrite(BlConsoleOutDeviceId,
             Text,
             (ULONG)_tcslen(Text)*sizeof(TCHAR),
             &Count);

    Text = BlFindMessage(Message2);
    if (Text == NULL) {
        _stprintf(Buffer,TEXT("%08lx\r\n"),Message2);
        Text = Buffer;
    }

    ArcWrite(BlConsoleOutDeviceId,
             Text,
             (ULONG)_tcslen(Text)*sizeof(TCHAR),
             &Count);

#if defined(ENABLE_LOADER_DEBUG) || DBG
#if (defined(_X86_) || defined(_ALPHA_) || defined(_IA64_)) && !defined(ARCI386) // everything but ARCI386
    if(BdDebuggerEnabled) {
        DbgBreakPoint();
    }
#endif
#endif

    return;
}

#if defined(_X86_)

VOID
RamdiskSdiBoot(
    IN PCHAR SdiFile
    )
{
    ARC_STATUS status;
    PSDI_HEADER sdiHeader;
    PUCHAR startromAddress;
    ULONG startromLength;
    BOOLEAN OldShowProgressBar;
    LONGLONG availableLength;

    //
    // Read the SDI image into memory.
    //

    RamdiskTFTPAddr = NetServerIpAddress;
    RamdiskImageOffset = 0;
    RamdiskImageLength = 0;

    OldShowProgressBar = BlShowProgressBar;
    BlShowProgressBar = TRUE;

    status = RamdiskReadImage( SdiFile );
    if ( status != ESUCCESS ) {
        RamdiskFatalError( RAMDISK_GENERAL_FAILURE, 
                           RAMDISK_BOOT_FAILURE );
        return;
    }

    BlShowProgressBar = OldShowProgressBar;

    //
    // Copy startrom.com from the SDI image to 0x7c00.
    //

    sdiHeader = MapRamdisk( 0, &availableLength );

    ASSERT( availableLength >= sizeof(SDI_HEADER) );
    ASSERT( availableLength >=
            (sdiHeader->liBootCodeOffset.QuadPart + sdiHeader->liBootCodeSize.QuadPart) );

    ASSERT( sdiHeader->liBootCodeOffset.HighPart == 0 );
    ASSERT( sdiHeader->liBootCodeSize.HighPart == 0 );

    startromAddress = (PUCHAR)sdiHeader + sdiHeader->liBootCodeOffset.LowPart;
    startromLength = sdiHeader->liBootCodeSize.LowPart;

    RtlMoveMemory( (PVOID)0x7c00, startromAddress, startromLength );

    //
    // Shut down PXE.
    //

    if ( BlBootingFromNet ) {
        NetTerminate();
    }

    //
    // Inform boot debugger that the boot phase is complete.
    //

#if defined(ENABLE_LOADER_DEBUG) || DBG
#if (defined(_X86_) || defined(_ALPHA_)) && !defined(ARCI386)

    {
        if (BdDebuggerEnabled == TRUE) {
            DbgUnLoadImageSymbols(NULL, (PVOID)-1, 0);
        }
    }

#endif
#endif

    REBOOT( (ULONG)sdiHeader | 3 );

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\scsiboot.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    scsiboot.c

Abstract:

    This is the NT SCSI port driver.

Author:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is linked into the kernel.

Revision History:

--*/

#if !defined(DECSTATION)

#include "stdarg.h"
#include "stdio.h"
#if defined(_MIPS_)
#include "..\fw\mips\fwp.h"
#elif defined(_ALPHA_)
#include "bldr.h"
#elif defined(_PPC_)
#include "..\fw\ppc\fwp.h"
#elif defined(_IA64_)
#include "bootia64.h"
#else
#include "bootx86.h"
#endif
#include "scsi.h"
#include "scsiboot.h"
#include "pci.h"

#if DBG
ULONG ScsiDebug = 0;
#endif

ULONG ScsiPortCount;
PDEVICE_OBJECT ScsiPortDeviceObject[MAXIMUM_NUMBER_OF_SCSIPORT_OBJECTS];
PINQUIRYDATA InquiryDataBuffer;
FULL_SCSI_REQUEST_BLOCK PrimarySrb;
FULL_SCSI_REQUEST_BLOCK RequestSenseSrb;
FULL_SCSI_REQUEST_BLOCK AbortSrb;


extern PDRIVER_UNLOAD AEDriverUnloadRoutine;

//
// Function declarations
//

ARC_STATUS
ScsiPortDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ScsiPortExecute(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ScsiPortStartIo (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
ScsiPortInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
ScsiPortCompletionDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
ScsiPortTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

IO_ALLOCATION_ACTION
ScsiPortAllocationRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

ARC_STATUS
IssueInquiry(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PLUNINFO LunInfo
    );

VOID
IssueRequestSense(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    );

VOID
ScsiPortInternalCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

PSCSI_BUS_SCAN_DATA
ScsiBusScan(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN UCHAR ScsiBus,
    IN UCHAR InitiatorBusId
    );

PLOGICAL_UNIT_EXTENSION
CreateLogicalUnitExtension(
    IN PDEVICE_EXTENSION DeviceExtension
    );

BOOLEAN
SpStartIoSynchronized (
    PVOID ServiceContext
    );

VOID
IssueAbortRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP FailingIrp
    );

VOID
SpCheckResetDelay(
    IN PDEVICE_EXTENSION deviceExtension
    );

IO_ALLOCATION_ACTION
SpBuildScatterGather(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

BOOLEAN
SpGetInterruptState(
    IN PVOID ServiceContext
    );

VOID
SpTimerDpc(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

PLOGICAL_UNIT_EXTENSION
GetLogicalUnitExtension(
    PDEVICE_EXTENSION DeviceExtension,
    UCHAR TargetId
    );

NTSTATUS
SpInitializeConfiguration(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PHW_INITIALIZATION_DATA HwInitData,
    OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN BOOLEAN InitialCall
    );

NTSTATUS
SpGetCommonBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    ULONG NonCachedExtensionSize
    );

BOOLEAN
GetPciConfiguration(
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PPORT_CONFIGURATION_INFORMATION ConfigInformation,
    ULONG NumberOfAccessRanges,
    PVOID RegistryPath,
    BOOLEAN IsMultiFunction,
    PULONG BusNumber,
    PULONG SlotNumber,
    PULONG FunctionNumber
    );

BOOLEAN
FindPciDevice(
    PHW_INITIALIZATION_DATA HwInitializationData,
    PULONG BusNumber,
    PULONG SlotNumber,
    PULONG FunctionNumber,
    PBOOLEAN IsMultiFunction
    );

#ifdef i386
ULONG
HalpGetCmosData(
    IN ULONG    SourceLocation,
    IN ULONG    SourceAddress,
    IN PVOID    ReturnBuffer,
    IN ULONG    ByteCount
    );
#endif

VOID
ScsiPortInitializeMdlPages (
    IN OUT PMDL Mdl
    );

SCSI_ADAPTER_CONTROL_STATUS
SpCallAdapterControl(
    IN PDEVICE_EXTENSION Adapter,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    );

VOID
SpGetSupportedAdapterControlFunctions(
    PDEVICE_EXTENSION Adapter
    );

VOID
SpUnload(
    IN PDRIVER_OBJECT DriverObject
    );

//
// Routines start
//

BOOLEAN
GetNextPciBus(
    PULONG BusNumber
    )

/*++

Routine Description:

    Advance ConfigInformation to the next PCI bus if one exists in the
    system.  Advances the bus number and calls HalGetBusDataByOffset to
    see if the bus number is valid.

    Note: *BusNumber has already been scanned in its entirety, we
    simply advance to the start of the next bus.   No need to keep
    track of where we might be on this  bus.

Arguments:

    BusNumber   Pointer to a ULONG containing the last BusNumber tested.
                Will be updated to the next bus number if another PCI
                bus exists.

Return Value:

    TRUE    If ConfigInformation has been advanced,
    FALSE   If there are not more PCI busses in the system.

--*/

{
    ULONG  pciBus;
    USHORT pciData;
    ULONG  length;

    pciBus = *BusNumber;

    DebugPrint((3,"GetNextPciBus: try to advance from bus %d\n", pciBus));

    if (++pciBus < 256) {
        length = HalGetBusDataByOffset(
                     PCIConfiguration,
                     pciBus,
                     0,                 // slot number
                     &pciData,
                     0,
                     sizeof(pciData));

        if (length == sizeof(pciData)) {

            //
            // HalGetBusDataByOffset returns zero when out of
            // busses.   If not out of busses it should always
            // succeed a length = 2 read at offset 0 even if
            // just to return PCI_INVALID_VENDORID.
            //

            *BusNumber = pciBus;
            return TRUE;
        }
    }
    DebugPrint((3,"GetNextPciBus: test bus %d returned %d\n", pciBus, length));
    return FALSE;
}

ULONG
ScsiPortInitialize(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN struct _HW_INITIALIZATION_DATA *HwInitializationData,
    IN PVOID HwContext
    )

/*++

Routine Description:

    This routine initializes the port driver.

Arguments:

    Argument1 - Pointer to driver object created by system
    HwInitializationData - Miniport initialization structure
    HwContext - Value passed to miniport driver's config routine

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    PDRIVER_OBJECT driverObject = Argument1;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject;
    BOOLEAN checkAdapterControl = FALSE;
    PORT_CONFIGURATION_INFORMATION configInfo;
    KEVENT allocateAdapterEvent;
    ULONG ExtensionAllocationSize;
    ULONG j;
    UCHAR scsiBus;
    PULONG scsiPortNumber;
    ULONG numberOfPageBreaks;
    PIO_SCSI_CAPABILITIES capabilities;
    BOOLEAN callAgain;
    UCHAR ldrString[] = {'n', 't', 'l', 'd','r','=', '1', ';', 0 };
    DEVICE_DESCRIPTION deviceDescription;
    ARC_CODES status;
    BOOLEAN isPci = FALSE;
    BOOLEAN isMultiFunction = FALSE;
    ULONG busNumber = 0;
    ULONG slotNumber = 0;
    ULONG functionNumber = 0;
    BOOLEAN foundOne = FALSE;

    UNREFERENCED_PARAMETER(Argument2);

    AEDriverUnloadRoutine = SpUnload;

    if (HwInitializationData->HwInitializationDataSize > sizeof(HW_INITIALIZATION_DATA)) {

        DebugPrint((0,"ScsiPortInitialize: Miniport driver wrong version\n"));
        return EBADF;
    }

    if (HwInitializationData->HwInitializationDataSize >= 
        (FIELD_OFFSET(HW_INITIALIZATION_DATA, HwAdapterControl) + 
         sizeof(PVOID))) {

        DebugPrint((2, "ScsiPortInitialize: Miniport may have adapter "
                       "control routine\n"));
        checkAdapterControl = TRUE;
    }

    //
    // Check that each required entry is not NULL.
    //

    if ((!HwInitializationData->HwInitialize) ||
        (!HwInitializationData->HwFindAdapter) ||
        (!HwInitializationData->HwResetBus)) {

        DebugPrint((0,
            "ScsiPortInitialize: Miniport driver missing required entry\n"));

        return EBADF;
    }

CallAgain:

    //
    // Get the configuration information
    //

    scsiPortNumber = &ScsiPortCount;

    //
    // Determine if there is room for the next port device object.
    //

    if (*scsiPortNumber >= MAXIMUM_NUMBER_OF_SCSIPORT_OBJECTS) {
        return foundOne ? ESUCCESS : EIO;
    }

    //
    // If this is a PCI card then do a quick scan to see if we can find 
    // the device.
    //

    if (HwInitializationData->AdapterInterfaceType == PCIBus &&
        HwInitializationData->VendorIdLength > 0 &&
        HwInitializationData->DeviceIdLength > 0 &&
        HwInitializationData->DeviceId &&
        HwInitializationData->VendorId) {

        if (!FindPciDevice(HwInitializationData,
                           &busNumber,
                           &slotNumber,
                           &functionNumber,
                           &isMultiFunction)) {

            DebugPrint((1,
                       "ScsiPortInitialize: FindPciDevice failed\n"));
            return foundOne ? ESUCCESS : EIO;
        }

        isPci = TRUE;
    }

    //
    // Determine size of extensions.
    //

    ExtensionAllocationSize = DEVICE_EXTENSION_SIZE +
        HwInitializationData->DeviceExtensionSize + sizeof(DEVICE_OBJECT);

    deviceObject = ExAllocatePool(NonPagedPool, ExtensionAllocationSize);

    if (deviceObject == NULL) {
        return ENOMEM;
    }

    RtlZeroMemory(deviceObject, ExtensionAllocationSize);

    //
    // Set up device extension pointers
    //

    deviceExtension = deviceObject->DeviceExtension = (PVOID) (deviceObject + 1);
    deviceExtension->DeviceObject = deviceObject;

    //
    // Save the dependent driver routines in the device extension.
    //

    deviceExtension->HwInitialize = HwInitializationData->HwInitialize;
    deviceExtension->HwStartIo = HwInitializationData->HwStartIo;
    deviceExtension->HwInterrupt = HwInitializationData->HwInterrupt;
    deviceExtension->HwReset = HwInitializationData->HwResetBus;
    deviceExtension->HwDmaStarted = HwInitializationData->HwDmaStarted;
    deviceExtension->HwLogicalUnitExtensionSize =
        HwInitializationData->SpecificLuExtensionSize;

    if(checkAdapterControl) {
        deviceExtension->HwAdapterControl = HwInitializationData->HwAdapterControl;
    }

    deviceExtension->HwDeviceExtension =
        (PVOID)(deviceExtension + 1);

    //
    // Set indicater as to whether adapter needs kernel mapped buffers.
    //

    deviceExtension->MapBuffers = HwInitializationData->MapBuffers;

    //
    // Mark this object as supporting direct I/O so that I/O system
    // will supply mdls in irps.
    //

    deviceObject->Flags |= DO_DIRECT_IO;

    //
    // Check if miniport driver requires any noncached memory.
    // SRB extensions will come from zoned memory. A page is
    // allocated as it is the smallest unit of noncached memory
    // allocation.
    //

    deviceExtension->SrbExtensionSize = HwInitializationData->SrbExtensionSize;

    //
    // Get the miniport configuration information.
    //

    capabilities = &deviceExtension->Capabilities;

    capabilities->Length = sizeof(IO_SCSI_CAPABILITIES);

    callAgain = FALSE;

    //
    // This call can't really fail - if it does something is seriously wrong and
    // should fail on the first try.
    //

    if (!NT_SUCCESS(SpInitializeConfiguration(
                        deviceExtension,
                        HwInitializationData,
                        &configInfo,
                        TRUE
                        ))) {

        DebugPrint((2, "ScsiPortInitialize: No config info found\n"));
        return(ENODEV);
    }

    configInfo.NumberOfAccessRanges = HwInitializationData->NumberOfAccessRanges;

    configInfo.AccessRanges = ExAllocatePool(NonPagedPool,
                                             sizeof(ACCESS_RANGE) *
                                             HwInitializationData->NumberOfAccessRanges);

    if (configInfo.AccessRanges == NULL) {

        //
        // We're out of memory - it's probably not worth continuing on to 
        // try and find more adapters.
        //

        return (foundOne ? ESUCCESS : EIO);
    }

    RtlZeroMemory(configInfo.AccessRanges,
        HwInitializationData->NumberOfAccessRanges * sizeof(ACCESS_RANGE));

    //
    // Initialize configuration information with slot information if PCI bus.
    //

    if (isPci) {

        if (!GetPciConfiguration(driverObject,
                                 deviceObject,
                                 &configInfo,
                                 HwInitializationData->NumberOfAccessRanges,
                                 Argument2,
                                 isMultiFunction,
                                 &busNumber,
                                 &slotNumber,
                                 &functionNumber)) {

            DebugPrint((1,
                       "ScsiPortInitialize: GetPciConfiguration failed\n"));
            return foundOne ? ESUCCESS : EIO;
        }

        //
        // Call miniport driver's find adapter routine to search for adapters.
        //

        if (HwInitializationData->HwFindAdapter(
                 deviceExtension->HwDeviceExtension,    // DeviceExtension
                 HwContext,                             // HwContext
                 NULL,                                  // BusInformation
                 (PCHAR)&ldrString,                     // ArgumentString
                 &configInfo,                           // ConfigurationInformation
                 &callAgain                             // Again
                 ) != SP_RETURN_FOUND) {

            return foundOne ? ESUCCESS : EIO;
        }
    } else {

        //
        // Not PCI, or PCI but the miniport is fundamentally broken
        // and wants to do its own search.
        //

        //
        // Starting at the current config, examine each bus
        // until we run out of busses.
        //

        configInfo.SystemIoBusNumber = busNumber;

        if (HwInitializationData->HwFindAdapter(
                 deviceExtension->HwDeviceExtension,    // DeviceExtension
                 HwContext,                             // HwContext
                 NULL,                                  // BusInformation
                 (PCHAR)&ldrString,                     // ArgumentString
                 &configInfo,                           // ConfigurationInformation
                 &callAgain                             // Again
                 ) != SP_RETURN_FOUND) {

            //
            // No device found on this bus, try next bus.
            //

            if ((HwInitializationData->AdapterInterfaceType != PCIBus) ||
                !GetNextPciBus(&busNumber)) {

                return foundOne ? ESUCCESS : EIO;
            }

            goto CallAgain;
        }
    }

    DebugPrint((1,"ScsiPortInitialize: SCSI adapter IRQ is %d\n",
        configInfo.BusInterruptLevel));

    DebugPrint((1,"ScsiPortInitialize: SCSI adapter ID is %d\n",
        configInfo.InitiatorBusId[0]));

    deviceExtension->NumberOfBuses = configInfo.NumberOfBuses;

    //
    // Free the pointer to the bus data at map register base.  This was
    // allocated by ScsiPortGetBusData.
    //

    if (deviceExtension->MapRegisterBase != NULL) {
        ExFreePool(deviceExtension->MapRegisterBase);
    }

    //
    // Get the adapter object for this card.
    //

    if ( deviceExtension->DmaAdapterObject == NULL &&
        (configInfo.Master || configInfo.DmaChannel != 0xFFFFFFFF) ) {

        deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
        deviceDescription.DmaChannel = configInfo.DmaChannel;
        deviceDescription.InterfaceType = configInfo.AdapterInterfaceType;
        deviceDescription.BusNumber = configInfo.SystemIoBusNumber;
        deviceDescription.DmaWidth = configInfo.DmaWidth;
        deviceDescription.DmaSpeed = configInfo.DmaSpeed;
        deviceDescription.DmaPort = configInfo.DmaPort;
        deviceDescription.MaximumLength = configInfo.MaximumTransferLength;
        deviceDescription.ScatterGather = configInfo.ScatterGather;
        deviceDescription.Master = configInfo.Master;
        deviceDescription.AutoInitialize = FALSE;
        deviceDescription.DemandMode = FALSE;

        if (configInfo.MaximumTransferLength > 0x11000) {

            deviceDescription.MaximumLength = 0x11000;

        } else {

            deviceDescription.MaximumLength = configInfo.MaximumTransferLength;

        }

        deviceExtension->DmaAdapterObject = HalGetAdapter(
            &deviceDescription,
            &numberOfPageBreaks
            );

        //
        // Set maximum number of page breaks.
        //

        if (numberOfPageBreaks > configInfo.NumberOfPhysicalBreaks) {
            capabilities->MaximumPhysicalPages = configInfo.NumberOfPhysicalBreaks;
        } else {
            capabilities->MaximumPhysicalPages = numberOfPageBreaks;
        }

    }

    //
    // Allocate memory for the non cached extension if it has not already been
    // allocated.  If we can't get any abort the search for adapters but 
    // succeed if we've managed to initialize at least one.
    //

    if (deviceExtension->SrbExtensionSize != 0 &&
        deviceExtension->SrbExtensionZonePool == NULL) {

        status = SpGetCommonBuffer(deviceExtension, 0);

        if (status != ESUCCESS) {

            return (foundOne ? ESUCCESS : status);
        }
    }

    capabilities->Length = sizeof(IO_SCSI_CAPABILITIES);
    capabilities->MaximumTransferLength = configInfo.MaximumTransferLength;
    DebugPrint((1,
               "Maximum physical page breaks = %d. Maximum transfer length = %x\n",
               capabilities->MaximumPhysicalPages,
               capabilities->MaximumTransferLength));

    if (HwInitializationData->ReceiveEvent) {
        capabilities->SupportedAsynchronousEvents |=
            SRBEV_SCSI_ASYNC_NOTIFICATION;
    }

    capabilities->TaggedQueuing = HwInitializationData->TaggedQueuing;
    capabilities->AdapterScansDown = configInfo.AdapterScansDown;
    capabilities->AlignmentMask = configInfo.AlignmentMask;

    //
    // Make sure maximum nuber of pages is set to a reasonable value.
    // This occurs for mini-ports with no Dma adapter.
    //

    if (capabilities->MaximumPhysicalPages == 0) {

        capabilities->MaximumPhysicalPages =
                (ULONG)ROUND_TO_PAGES(capabilities->MaximumTransferLength) + 1;

        //
        // Honor any limit requested by the mini-port.
        //

        if (configInfo.NumberOfPhysicalBreaks < capabilities->MaximumPhysicalPages) {

            capabilities->MaximumPhysicalPages =
                configInfo.NumberOfPhysicalBreaks;
        }
    }

    //
    // Get maximum target IDs.
    //

    if (configInfo.MaximumNumberOfTargets > SCSI_MAXIMUM_TARGETS_PER_BUS) {
        deviceExtension->MaximumTargetIds = SCSI_MAXIMUM_TARGETS_PER_BUS;
    } else {
        deviceExtension->MaximumTargetIds =
            configInfo.MaximumNumberOfTargets;
    }

    if (deviceExtension->DmaAdapterObject != NULL &&
        !HwInitializationData->NeedPhysicalAddresses) {

        //
        // Allocate the adapter object.  For the port driver the adapter object
        // and map registers are permentently allocated and used  shared between
        // all logical units.  The adapter is allocated by initializing an event,
        // calling IoAllocateAdapterChannel and waiting on the event.  When the
        // adapter and map registers are available, ScsiPortAllocationRoutine is
        // called which set the event.  In reality, all this takes zero time since
        // the stuff is available immediately.
        //
        // Allocate the AdapterObject.  The number of registers is equal to the
        // maximum transfer length supported by the adapter + 1.  This insures
        // that there will always be a sufficient number of registers.
        //
        /* TODO: Fix this for the case when there is no maximum transfer length. */

        IoAllocateAdapterChannel(
            deviceExtension->DmaAdapterObject,
            deviceObject,
            capabilities->MaximumPhysicalPages,
            ScsiPortAllocationRoutine,
            &allocateAdapterEvent
            );

        //
        // Wait for adapter object.
        //

        ASSERT(deviceExtension->MapRegisterBase);

        deviceExtension->MasterWithAdapter = FALSE;

    } else if (deviceExtension->DmaAdapterObject != NULL) {

        //
        // This SCSI adapter is a master with an adapter so a scatter/gather
        // list needs to be allocated for each transfer.
        //

        deviceExtension->MasterWithAdapter = TRUE;

    } else {

        deviceExtension->MasterWithAdapter = FALSE;

    } // end if (deviceExtension->DmaAdapterObject != NULL)

    //
    // Call the hardware dependent driver to do its initialization.  If it fails
    // then continue the search for adapters.
    //

    if (!KeSynchronizeExecution(
            deviceExtension->InterruptObject,
            deviceExtension->HwInitialize,
            deviceExtension->HwDeviceExtension
            )) {

        DebugPrint((1,"ScsiPortInitialize: initialization failed\n"));

        if(callAgain) {
            goto CallAgain;
        } else {
            return foundOne ? ESUCCESS : ENODEV;
        }
    }

    //
    // Find out if the miniport supports AdapterControl routines to shutdown.
    //

    SpGetSupportedAdapterControlFunctions(deviceExtension);

    //
    // Allocate properly aligned INQUIRY buffer.  If we can't get one we're 
    // out of memory so searching for more adapters is pointless.
    //

    InquiryDataBuffer = ExAllocatePool(NonPagedPool, INQUIRYDATABUFFERSIZE);

    if (InquiryDataBuffer == NULL) {
        return foundOne ? ESUCCESS : ENOMEM;
    }

    //
    // Reset the scsi bus.
    //

    if (!deviceExtension->HwReset(
        deviceExtension->HwDeviceExtension,
        0)){

        DebugPrint((1,"Reset SCSI bus failed\n"));
    }

    //
    // Call the interupt handler for a few microseconds to clear any reset
    // interrupts.
    //

    for (j = 0; j < 1000 * 100; j++) {

        FwStallExecution(10);
        if (deviceExtension->HwInterrupt != NULL) {
            deviceExtension->HwInterrupt(deviceExtension->HwDeviceExtension);
        }
    }

    deviceExtension->PortTimeoutCounter = PD_TIMER_RESET_HOLD_TIME;
    SpCheckResetDelay( deviceExtension );

    //
    // Find devices on each SCSI bus.
    //

    //
    // Allocate buffer for SCSI bus scan information.
    //

    deviceExtension->ScsiInfo = ExAllocatePool(NonPagedPool,
                   deviceExtension->NumberOfBuses * sizeof(PSCSI_BUS_SCAN_DATA) +
                    4);

    if (deviceExtension->ScsiInfo) {

        deviceExtension->ScsiInfo->NumberOfBuses = deviceExtension->NumberOfBuses;

        //
        // Find devices on each SCSI bus.
        //

        for (scsiBus = 0; scsiBus < deviceExtension->NumberOfBuses; scsiBus++) {
            deviceExtension->ScsiInfo->BusScanData[scsiBus] =
                ScsiBusScan(deviceExtension,
                            scsiBus,
                            configInfo.InitiatorBusId[scsiBus]);
        }
    }

    //
    // Save the device object for use by the driver.
    //

    ScsiPortDeviceObject[*scsiPortNumber] = deviceObject;

    //
    // Bump SCSI host bus adapters count.
    //

    (*scsiPortNumber)++;

    foundOne = TRUE;

    //
    // If the adapter wants to be called again with the same configuration data
    // then start over from the beginning again.
    //

    if (callAgain) {
        goto CallAgain;
    }

    return ESUCCESS;

} // end ScsiPortInitialize()

IO_ALLOCATION_ACTION
ScsiPortAllocationRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is called by IoAllocateAdapterChannel when sufficent resources
    are available to the driver.  This routine saves the MapRegisterBase in the
    device object and set the event pointed to by the context parameter.

Arguments:

    DeviceObject - Pointer to the device object to which the adapter is being
        allocated.

    Irp - Unused.

    MapRegisterBase - Supplied by the Io subsystem for use in IoMapTransfer.

    Context - Supplies a pointer to an event which is set to indicate the
        AdapterObject has been allocated.

Return Value:

    KeepObject - Indicates the adapter and mapregisters should remain allocated
        after return.

--*/

{
    ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->MapRegisterBase =
        MapRegisterBase;

    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(Context);

    return(KeepObject);
}

IO_ALLOCATION_ACTION
SpBuildScatterGather(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is called by the I/O system when an adapter object and map
    registers have been allocated.  This routine then builds a scatter/gather
    list for use by the mini-port driver.  Next it sets the timeout and
    the current Irp for the logical unit.  Finally it calls the mini-port
    StartIo routine.  Once that routines complete, this routine will return
    requesting that the adapter be freed and but the registers remain allocated.
    The registers will be freed the request completes.

Arguments:

    DeviceObject - Supplies a pointer to the port driver device object.

    Irp - Supplies a pointer to the current Irp.

    MapRegisterBase - Supplies a context pointer to be used with calls the
        adapter object routines.

    Context - Supplies a pointer to the logical unit structure.

Return Value:

    Returns DeallocateObjectKeepRegisters so that the adapter object can be
        used by other logical units.

--*/

{
    BOOLEAN writeToDevice;
    PIO_STACK_LOCATION irpstack = IoGetCurrentIrpStackLocation(Irp);
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK srb;
    PSRB_SCATTER_GATHER scatterList;
    ULONG totalLength;

    logicalUnit = Context;
    srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;
    scatterList = logicalUnit->ScatterGather;
    totalLength = 0;

    //
    // Save the MapRegisterBase for later use to deallocate the map registers.
    //

    logicalUnit->MapRegisterBase = MapRegisterBase;

    //
    // Build the scatter/gather list by looping throught the transfer calling
    // I/O map transfer.
    //

    writeToDevice = srb->SrbFlags & SRB_FLAGS_DATA_OUT ? TRUE : FALSE;

    while (totalLength < srb->DataTransferLength) {

        //
        // Request that the rest of the transfer be mapped.
        //

        scatterList->Length = srb->DataTransferLength - totalLength;

        //
        // Since we are a master call I/O map transfer with a NULL adapter.
        //

        scatterList->PhysicalAddress = IoMapTransfer(
            NULL,
            Irp->MdlAddress,
            MapRegisterBase,
            (PCCHAR) srb->DataBuffer + totalLength,
            &scatterList->Length,
            writeToDevice
            ).LowPart;

        totalLength += scatterList->Length;
        scatterList++;
    }

    //
    // Set request timeout value from Srb SCSI extension in Irp.
    //

    logicalUnit->RequestTimeoutCounter = srb->TimeOutValue;

    //
    // Set current request for this logical unit.
    //

    logicalUnit->CurrentRequest = Irp;

    /* TODO: Check the return value. */
    KeSynchronizeExecution(
        ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->InterruptObject,
        SpStartIoSynchronized,
        DeviceObject
        );

    return(DeallocateObjectKeepRegisters);

}

VOID
ScsiPortExecute(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine calls the start I/O routine an waits for the request to
    complete.  During the wait for complete the interrupt routine is called,
    also the timer routines are called at the appropriate times.  After the
    request completes a check is made to determine if an request sense needs
    to be issued.

Arguments:

    DeviceObject - Supplies pointer to Adapter device object.

    Irp - Supplies a pointer to an IRP.

Return Value:

    Nothing.

--*/

{
    ULONG milliSecondTime;
    ULONG secondTime;
    ULONG completionDelay;
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpstack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;
    PVOID logicalUnit;

    deviceExtension = DeviceObject->DeviceExtension;
    logicalUnit = GetLogicalUnitExtension(deviceExtension, srb->TargetId);

    if (logicalUnit == NULL) {
       Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
       srb->SrbStatus = SRB_STATUS_NO_DEVICE;
       return;
    }

    //
    // Make sure the adapter is ready to accept requests.
    //

    SpCheckResetDelay( deviceExtension );

    //
    // Mark IRP as pending.
    //

    Irp->PendingReturned = TRUE;

    //
    // Start the request.
    //

    ScsiPortStartIo( DeviceObject, Irp);

    //
    // The completion delay controls how long interrupts are serviced after
    // a request has been completed.  This allows interrupts which occur after
    // a completion to be serviced.
    //

    completionDelay = COMPLETION_DELAY;

    //
    // Wait for the IRP to complete.
    //

    while (Irp->PendingReturned && completionDelay) {

        //
        // Wait 1 second then call the scsi port timer routine.
        //

        for (secondTime = 0; secondTime < 1000/ 250; secondTime++) {

            for (milliSecondTime = 0; milliSecondTime < (250 * 1000 / PD_INTERLOOP_STALL); milliSecondTime++) {

                ScsiPortInterrupt(NULL, DeviceObject);

                if (!Irp->PendingReturned) {
                    if (completionDelay-- == 0) {
                        goto done;
                    }
                }

                if (deviceExtension->Flags & PD_ENABLE_CALL_REQUEST) {

                    //
                    // Call the mini-port requested routine.
                    //

                    deviceExtension->Flags &= ~PD_ENABLE_CALL_REQUEST;
                    deviceExtension->HwRequestInterrupt(deviceExtension->HwDeviceExtension);

                    if (deviceExtension->Flags & PD_DISABLE_CALL_REQUEST) {

                        deviceExtension->Flags &= ~(PD_DISABLE_INTERRUPTS | PD_DISABLE_CALL_REQUEST);
                        deviceExtension->HwRequestInterrupt(deviceExtension->HwDeviceExtension);

                    }
                }


                if (deviceExtension->Flags & PD_CALL_DMA_STARTED) {

                    deviceExtension->Flags &= ~PD_CALL_DMA_STARTED;

                    //
                    // Notify the mini-port driver that the DMA has been
                    // started.
                    //

                    if (deviceExtension->HwDmaStarted) {
                        KeSynchronizeExecution(
                            &deviceExtension->InterruptObject,
                            (PKSYNCHRONIZE_ROUTINE) deviceExtension->HwDmaStarted,
                            deviceExtension->HwDeviceExtension
                            );
                    }

                }

                FwStallExecution(PD_INTERLOOP_STALL);

                //
                // Check the miniport timer.
                //

                if (deviceExtension->TimerValue != 0) {

                    deviceExtension->TimerValue--;

                    if (deviceExtension->TimerValue == 0) {

                        //
                        // The timer timed out so called requested timer routine.
                        //

                        deviceExtension->HwTimerRequest(deviceExtension->HwDeviceExtension);
                    }
                }
            }
        }

        ScsiPortTickHandler(DeviceObject, NULL);
    }

done:

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        PIO_STACK_LOCATION irpstack = IoGetCurrentIrpStackLocation(Irp);
        PSCSI_REQUEST_BLOCK Srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;

        //
        // Determine if a REQUEST SENSE command needs to be done.
        // Check that a CHECK_CONDITION was received, an autosense has not
        // been done already, and that autosense has been requested.
        //

        if (srb->ScsiStatus == SCSISTAT_CHECK_CONDITION &&
            !(srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID)  &&
            srb->SenseInfoBuffer) {

            //
            // Call IssueRequestSense and it will complete the request after
            // the REQUEST SENSE completes.
            //

            IssueRequestSense(deviceExtension, Srb);
        }
    }
}

VOID
ScsiPortStartIo (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - Supplies pointer to Adapter device object.
    Irp - Supplies a pointer to an IRP.

Return Value:

    Nothing.

--*/

{
    PIO_STACK_LOCATION irpstack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK Srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PFULL_SCSI_REQUEST_BLOCK FullSrb;
    NTSTATUS status;

    DebugPrint((3,"ScsiPortStartIo: Enter routine\n"));

    FullSrb = CONTAINING_RECORD(Srb, FULL_SCSI_REQUEST_BLOCK, Srb);

    if (deviceExtension->SrbExtensionZonePool && 
        (Srb->SrbExtension == NULL || 
         (deviceExtension->SrbExtensionSize > FullSrb->SrbExtensionSize))) {

        //
        // Allocate SRB extension from zone.
        //

        Srb->SrbExtension = deviceExtension->SrbExtensionPointer;

        (PCCHAR) deviceExtension->SrbExtensionPointer +=
            deviceExtension->SrbExtensionSize;

        FullSrb->SrbExtensionSize = deviceExtension->SrbExtensionSize;

        if ((ULONG_PTR) deviceExtension->SrbExtensionPointer >
            (ULONG_PTR) deviceExtension->NonCachedExtension) {
            DebugPrint((0, "NtLdr: ScsiPortStartIo: Srb extension overflow.  Too many srb extension allocated.\n"));
            DbgBreakPoint();
        }

        DebugPrint((3,"ExInterlockedAllocateFromZone: %lx\n",
            Srb->SrbExtension));

        DebugPrint((3,"Srb %lx\n",Srb));
    }

    //
    // Get logical unit extension.
    //

    logicalUnit = GetLogicalUnitExtension(deviceExtension, Srb->TargetId);

    //
    // Flush the data buffer if necessary.
    //

    if (Srb->SrbFlags & (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)) {

        if (Srb->DataTransferLength > deviceExtension->Capabilities.MaximumTransferLength) {

            DebugPrint((1, "Scsiboot: ScsiPortStartIo Length Exceeds limit %x, %x\n",
                Srb->DataTransferLength,
                deviceExtension->Capabilities.MaximumTransferLength));
        }

        KeFlushIoBuffers(
            Irp->MdlAddress,
            (BOOLEAN) (Srb->SrbFlags & SRB_FLAGS_DATA_IN ? TRUE : FALSE),
            TRUE
            );

        //
        // Determine if this adapter needs map registers
        //

        if (deviceExtension->MasterWithAdapter) {

            //
            // Calculate the number of map registers needed for this transfer.
            //

            logicalUnit->NumberOfMapRegisters = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                    Srb->DataBuffer,
                    Srb->DataTransferLength
                    );

            //
            // Allocate the adapter channel with sufficient map registers
            // for the transfer.
            //

            status = IoAllocateAdapterChannel(
                deviceExtension->DmaAdapterObject,  // AdapterObject
                DeviceObject,                       // DeviceObject.
                logicalUnit->NumberOfMapRegisters,  // NumberOfMapRegisters
                SpBuildScatterGather,               // ExecutionRoutine
                logicalUnit                         // Context
                );

            if (!NT_SUCCESS(status)) {

                ;
            }

            //
            // The execution routine called by IoAllocateChannel will do the
            // rest of the work so just return.
            //

            return;
        }
    }

    //
    // Set request timeout value from Srb SCSI extension in Irp.
    //

    logicalUnit->RequestTimeoutCounter = Srb->TimeOutValue;

    //
    // Set current request for this logical unit.
    //

    logicalUnit->CurrentRequest = Irp;

    /* TODO: Check the return value. */
    KeSynchronizeExecution(
        deviceExtension->InterruptObject,
        SpStartIoSynchronized,
        DeviceObject
        );

    return;

} // end ScsiPortStartIO()


BOOLEAN
SpStartIoSynchronized (
    PVOID ServiceContext
    )

/*++

Routine Description:

    This routine calls the dependent driver start io routine.

Arguments:

    ServiceContext - Supplies the pointer to the device object.

Return Value:

    Returns the value returned by the dependent start I/O routine.


--*/

{
    PDEVICE_OBJECT DeviceObject = ServiceContext;
    PDEVICE_EXTENSION deviceExtension =  DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpstack;
    PSCSI_REQUEST_BLOCK Srb;

    DebugPrint((3, "ScsiPortStartIoSynchronized: Enter routine\n"));

    irpstack = IoGetCurrentIrpStackLocation(DeviceObject->CurrentIrp);
    Srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;

    DebugPrint((3, "SpPortStartIoSynchronized: SRB %lx\n",
        Srb));

    DebugPrint((3, "SpPortStartIoSynchronized: IRP %lx\n",
        DeviceObject->CurrentIrp));

    //
    // Disable all synchronous transfers.
    //

    Srb->SrbFlags |=
        (SRB_FLAGS_DISABLE_SYNCH_TRANSFER | SRB_FLAGS_DISABLE_DISCONNECT | SRB_FLAGS_DISABLE_AUTOSENSE);

    return deviceExtension->HwStartIo(
        deviceExtension->HwDeviceExtension,
        Srb
        );

} // end SpStartIoSynchronized()


BOOLEAN
ScsiPortInterrupt(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:


Arguments:

    Interrupt

    Device Object

Return Value:

    Returns TRUE if interrupt expected.

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(Interrupt);

    if (deviceExtension->Flags & PD_DISABLE_INTERRUPTS) {
        return FALSE;
    }

    if (deviceExtension->HwInterrupt != NULL) {

        if (deviceExtension->HwInterrupt(deviceExtension->HwDeviceExtension)) {

            return TRUE;

        } else {

            return FALSE;
        }
    }

    return(FALSE);

} // end ScsiPortInterrupt()


VOID
ScsiPortCompletionDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

    Dpc
    DeviceObject
    Irp - not used
    Context - not used

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpstack;
    PSCSI_REQUEST_BLOCK Srb;
    PLOGICAL_UNIT_EXTENSION luExtension;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(Context);

    DebugPrint((3, "ScsiPortCompletionDpc Entered\n"));

    //
    // Acquire the spinlock to protect the flags structure and the saved
    // interrupt context.
    //

    KeAcquireSpinLock(&deviceExtension->SpinLock, &currentIrql);

    //
    // Check for a flush DMA adapter object request.
    //

    if (deviceExtension->InterruptFlags & PD_FLUSH_ADAPTER_BUFFERS) {

        //
        // Call IoFlushAdapterBuffers using the parameters saved from the last
        // IoMapTransfer call.
        //

        IoFlushAdapterBuffers(
            deviceExtension->DmaAdapterObject,
            ((PIRP)deviceExtension->FlushAdapterParameters.Srb->OriginalRequest)
                ->MdlAddress,
            deviceExtension->MapRegisterBase,
            deviceExtension->FlushAdapterParameters.LogicalAddress,
            deviceExtension->FlushAdapterParameters.Length,
            (BOOLEAN)(deviceExtension->FlushAdapterParameters.Srb->SrbFlags
                & SRB_FLAGS_DATA_OUT ? TRUE : FALSE)
            );

        deviceExtension->InterruptFlags &= ~PD_FLUSH_ADAPTER_BUFFERS;
    }

    //
    // Check for an IoMapTransfer DMA request.
    //

    if (deviceExtension->InterruptFlags & PD_MAP_TRANSFER) {

        //
        // Call IoMapTransfer using the parameters saved from the
        // interrupt level.
        //

        IoMapTransfer(
            deviceExtension->DmaAdapterObject,
            ((PIRP)deviceExtension->MapTransferParameters.Srb->OriginalRequest)
                ->MdlAddress,
            deviceExtension->MapRegisterBase,
            deviceExtension->MapTransferParameters.LogicalAddress,
            &deviceExtension->MapTransferParameters.Length,
            (BOOLEAN)(deviceExtension->MapTransferParameters.Srb->SrbFlags
                & SRB_FLAGS_DATA_OUT ? TRUE : FALSE)
            );

        //
        // Save the paramters for IoFlushAdapterBuffers.
        //

        deviceExtension->FlushAdapterParameters =
            deviceExtension->MapTransferParameters;

        deviceExtension->InterruptFlags &= ~PD_MAP_TRANSFER;
        deviceExtension->Flags |= PD_CALL_DMA_STARTED;

    }

    //
    // Process any completed requests.
    //

    while (deviceExtension->CompletedRequests != NULL) {

        Irp = deviceExtension->CompletedRequests;
        irpstack = IoGetCurrentIrpStackLocation(Irp);
        Srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;
        luExtension =
                GetLogicalUnitExtension(deviceExtension, Srb->TargetId);

        DebugPrint((3, "ScsiPortCompletionDpc: SRB %lx\n", Srb));
        DebugPrint((3, "ScsiPortCompletionDpc: IRP %lx\n", Irp));

        //
        // Remove the request from the linked-list.
        //

        deviceExtension->CompletedRequests =
            irpstack->Parameters.Others.Argument3;

        //
        // Check for very unlikely return of NULL.
        //
        if (luExtension == NULL) {

            ASSERT(luExtension != NULL); // Debug why this happened.  It should not.

            //
            // But in retail, if some reason it did, complete the IRP and continue.
            //
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            Irp->IoStatus.Information = Srb->DataTransferLength;

            //
            // Free SrbExtension if allocated.
            //
            if (Srb->SrbExtension == (deviceExtension->SrbExtensionPointer -
                                      deviceExtension->SrbExtensionSize) ) {

                Srb->SrbExtension = NULL;

                (PCCHAR) deviceExtension->SrbExtensionPointer -=
                                        deviceExtension->SrbExtensionSize;
            }

            IoCompleteRequest(Irp, 2);
            continue;
        }

        //
        // Reset request timeout counter.
        //

        luExtension->RequestTimeoutCounter = -1;

        //
        // Flush the adapter buffers if necessary.
        //

        if (luExtension->MapRegisterBase) {

            //
            // Since we are a master call I/O flush adapter buffers with a NULL
            // adapter.
            //

            IoFlushAdapterBuffers(
                NULL,
                Irp->MdlAddress,
                luExtension->MapRegisterBase,
                Srb->DataBuffer,
                Srb->DataTransferLength,
                (BOOLEAN) (Srb->SrbFlags & SRB_FLAGS_DATA_OUT ? TRUE : FALSE)
                );

            //
            // Free the map registers.
            //

            IoFreeMapRegisters(
                deviceExtension->DmaAdapterObject,
                luExtension->MapRegisterBase,
                luExtension->NumberOfMapRegisters
                );

            //
            // Clear the MapRegisterBase.
            //

            luExtension->MapRegisterBase = NULL;

        }

        //
        // Set IRP status. Class drivers will reset IRP status based
        // on request sense if error.
        //

        if (SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_SUCCESS) {
            Irp->IoStatus.Status = STATUS_SUCCESS;
        } else {
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        }

        //
        // Move bytes transfered to IRP.
        //

        Irp->IoStatus.Information = Srb->DataTransferLength;

        //
        // If success then start next packet.
        // Not starting packet effectively
        // freezes the queue.
        //

        if (SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_SUCCESS) {

            DebugPrint((
                2,
                "ScsiPortCompletionDpc: Iocompletion IRP %lx\n",
                Irp));

            //
            // Free SrbExtension if allocated.
            //

            if (Srb->SrbExtension == (deviceExtension->SrbExtensionPointer -
                                      deviceExtension->SrbExtensionSize) ) {

                Srb->SrbExtension = NULL;

                (PCCHAR) deviceExtension->SrbExtensionPointer -=
                                            deviceExtension->SrbExtensionSize;
            }

            IoCompleteRequest(Irp, 2);

        } else {

            if ( Srb->ScsiStatus == SCSISTAT_BUSY &&
                (luExtension->RetryCount++ < 20)) {
                //
                // If busy status is returned, then indicate that the logical
                // unit is busy.  The timeout code will restart the request
                // when it fires. Reset the status to pending.
                //
                Srb->SrbStatus = SRB_STATUS_PENDING;
                luExtension->CurrentRequest = Irp;
                luExtension->Flags |= PD_LOGICAL_UNIT_IS_BUSY;

                //
                // Restore the data transfer length.
                //

                if (Irp->MdlAddress != NULL) {
                    Srb->DataTransferLength = Irp->MdlAddress->ByteCount;
                }

                DebugPrint((1, "ScsiPortCompletionDpc: Busy returned.  Length = %lx\n", Srb->DataTransferLength));

            } else {


                DebugPrint((
                    3,
                    "ScsiPortCompletionDpc: Iocompletion IRP %lx\n",
                    Irp));

                //
                // Free SrbExtension if allocated.
                //

                if (Srb->SrbExtension == (deviceExtension->SrbExtensionPointer -
                                          deviceExtension->SrbExtensionSize) ) {

                    Srb->SrbExtension = NULL;

                    (PCCHAR) deviceExtension->SrbExtensionPointer -=
                                            deviceExtension->SrbExtensionSize;
                }

                IoCompleteRequest(Irp, 2);
            }
        }
    }

    //
    // Release the spinlock.
    //

    KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);

    return;

} // end ScsiPortCompletionDpc()


ARC_STATUS
IssueInquiry(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PLUNINFO LunInfo
    )

/*++

Routine Description:

    Build IRP, SRB and CDB for SCSI INQUIRY command.

Arguments:

    DeviceExtension - address of adapter's device object extension.
    LunInfo - address of buffer for INQUIRY information.

Return Value:

    ARC_STATUS

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpstack;
    PCDB cdb;
    PSCSI_REQUEST_BLOCK srb;
    ARC_STATUS status;
    ULONG retryCount = 0;

    DebugPrint((3,"IssueInquiry: Enter routine\n"));

    if (InquiryDataBuffer == NULL) {
        return ENOMEM;
    }

inquiryRetry:

    //
    // Build IRP for this request.
    //

    irp = InitializeIrp(
                &PrimarySrb,
                IRP_MJ_SCSI,
                DeviceExtension->DeviceObject,
                (PVOID)InquiryDataBuffer,
                INQUIRYDATABUFFERSIZE
                );

    irpstack = IoGetNextIrpStackLocation(irp);

    //
    // Set major and minor codes.
    //

    irpstack->MajorFunction = IRP_MJ_SCSI;

    //
    // Fill in SRB fields.
    //

    irpstack->Parameters.Others.Argument1 = &PrimarySrb;
    srb = &PrimarySrb.Srb;

    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId = LunInfo->PathId;
    srb->TargetId = LunInfo->TargetId;
    srb->Lun = LunInfo->Lun;

    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER | SRB_FLAGS_DISABLE_DISCONNECT;

    srb->SrbStatus = srb->ScsiStatus = 0;

    srb->OriginalRequest = irp;

    srb->NextSrb = 0;

    //
    // Set timeout to 5 seconds.
    //

    srb->TimeOutValue = 5;

    srb->CdbLength = 6;

    srb->SenseInfoBufferLength = 0;
    srb->SenseInfoBuffer = 0;

    srb->DataBuffer = MmGetMdlVirtualAddress(irp->MdlAddress);
    srb->DataTransferLength = INQUIRYDATABUFFERSIZE;

    cdb = (PCDB)srb->Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set CDB LUN.
    //

    cdb->CDB6INQUIRY.LogicalUnitNumber = LunInfo->Lun;
    cdb->CDB6INQUIRY.Reserved1 = 0;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = INQUIRYDATABUFFERSIZE;

    //
    // Zero reserve field and
    // Set EVPD Page Code to zero.
    // Set Control field to zero.
    // (See SCSI-II Specification.)
    //

    cdb->CDB6INQUIRY.PageCode = 0;
    cdb->CDB6INQUIRY.IReserved = 0;
    cdb->CDB6INQUIRY.Control = 0;

    //
    // Call port driver to handle this request.
    //

    (VOID)IoCallDriver(DeviceExtension->DeviceObject, irp);


    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        DebugPrint((2,"IssueInquiry: Inquiry failed SRB status %x\n",
            srb->SrbStatus));

        //
        // NOTE: if INQUIRY fails with a data underrun,
        //      indicate success and let the class drivers
        //      determine whether the inquiry information
        //      is useful.
        //

        if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

            //
            // Copy INQUIRY buffer to LUNINFO.
            //

            DebugPrint((1,"IssueInquiry: Data underrun at TID %d\n",
                LunInfo->TargetId));

            RtlMoveMemory(LunInfo->InquiryData,
                      InquiryDataBuffer,
                      INQUIRYDATABUFFERSIZE);

            status = STATUS_SUCCESS;

        } else if ((SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SELECTION_TIMEOUT) && (retryCount++ < 2)) {

            //
            // If the selection did not time out then retry the request.
            //

            DebugPrint((2,"IssueInquiry: Retry %d\n", retryCount));
            goto inquiryRetry;

        } else {

            status = EIO;

        }

    } else {

        //
        // Copy INQUIRY buffer to LUNINFO.
        //

        RtlMoveMemory(LunInfo->InquiryData,
                      InquiryDataBuffer,
                      INQUIRYDATABUFFERSIZE);

        status = STATUS_SUCCESS;
    }

    return status;

} // end IssueInquiry()


PSCSI_BUS_SCAN_DATA
ScsiBusScan(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN UCHAR ScsiBus,
    IN UCHAR InitiatorBusId
    )

/*++

Routine Description:

Arguments:

    DeviceExtension
    ScsiBus

Return Value:

    SCSI configuration information


--*/
{
    PSCSI_BUS_SCAN_DATA busScanData;
    PLUNINFO lunInfo;
    UCHAR target;
    UCHAR device = 0;
    PLOGICAL_UNIT_EXTENSION nextLogicalUnitExtension;

    DebugPrint((3,"ScsiBusScan: Enter routine\n"));

    busScanData = ExAllocatePool(NonPagedPool,
                                 sizeof(SCSI_BUS_SCAN_DATA));

    if (busScanData == NULL) {

        //
        // Insufficient system resources to complete bus scan.
        //

        return NULL;
    }

    RtlZeroMemory(busScanData,sizeof(SCSI_BUS_SCAN_DATA));

    busScanData->Length = sizeof(SCSI_CONFIGURATION_INFO);

    //
    // Create first LUNINFO.
    //

    lunInfo = ExAllocatePool(NonPagedPool, sizeof(LUNINFO));

    if (lunInfo == NULL) {

        //
        // Insufficient system resources to complete bus scan.
        //

        return NULL;
    }

    RtlZeroMemory(lunInfo, sizeof(LUNINFO));

    //
    // Create first logical unit extension.
    //

    nextLogicalUnitExtension = CreateLogicalUnitExtension(DeviceExtension);

    if (nextLogicalUnitExtension == NULL) {
        return(NULL);
    }

    //
    // Link logical unit extension on list.
    //

    nextLogicalUnitExtension->NextLogicalUnit = DeviceExtension->LogicalUnitList;

    DeviceExtension->LogicalUnitList = nextLogicalUnitExtension;

    //
    // Issue inquiry command to each target id to find devices.
    //
    // NOTE: Does not handle multiple logical units per target id.
    //

    for (target = DeviceExtension->MaximumTargetIds; target > 0; target--) {

        if (InitiatorBusId == target-1) {
            continue;
        }

        //
        // Record address.
        //

        nextLogicalUnitExtension->PathId = lunInfo->PathId = ScsiBus;

        nextLogicalUnitExtension->TargetId = lunInfo->TargetId = target-1;

        nextLogicalUnitExtension->Lun = lunInfo->Lun = 0;

         //
         // Rezero hardware logigal unit extension if it's being recycled.
         //

         if (DeviceExtension->HwLogicalUnitExtensionSize) {

             if (nextLogicalUnitExtension->SpecificLuExtension) {

                 RtlZeroMemory(nextLogicalUnitExtension->SpecificLuExtension,
                             DeviceExtension->HwLogicalUnitExtensionSize);
             }

        }

        //
        // Issue inquiry command.
        //

        DebugPrint((2,"ScsiBusScan: Try TargetId %d LUN 0\n", target-1));

        if (IssueInquiry(DeviceExtension, lunInfo) == ESUCCESS) {

            PINQUIRYDATA inquiryData = (PINQUIRYDATA)lunInfo->InquiryData;

            //
            // Make sure we can use the device.
            //

            if (inquiryData->DeviceTypeQualifier & 0x04) {

              //
              // This device is not supported; continue looking for
              // other devices.
              //

              continue;
            }

            DebugPrint((1,
                       "ScsiBusScan: Found Device %d at TID %d LUN %d\n",
                       device,
                       lunInfo->TargetId,
                       lunInfo->Lun));

            //
            // Link LUN information on list.
            //

            lunInfo->NextLunInfo = busScanData->LunInfoList;
            busScanData->LunInfoList = lunInfo;

            //
            // This buffer is used. Get another.
            //

            lunInfo = ExAllocatePool(NonPagedPool, sizeof(LUNINFO));

            if (lunInfo == NULL) {

                //
                // Insufficient system resources to complete bus scan.
                //

                return busScanData;
            }

            RtlZeroMemory(lunInfo, sizeof(LUNINFO));

            //
            // Current logical unit extension claimed.
            // Create next logical unit.
            //

            nextLogicalUnitExtension =
                CreateLogicalUnitExtension(DeviceExtension);

            if (nextLogicalUnitExtension == NULL) {
                return busScanData;
            }

            //
            // Link logical unit extension on list.
            //

            nextLogicalUnitExtension->NextLogicalUnit =
                DeviceExtension->LogicalUnitList;

            DeviceExtension->LogicalUnitList = nextLogicalUnitExtension;

            device++;
        }

    } // end for (target ...

    //
    // Remove unused logicalunit extension from list.
    //

    DeviceExtension->LogicalUnitList =
        DeviceExtension->LogicalUnitList->NextLogicalUnit;

    ExFreePool(nextLogicalUnitExtension);
    ExFreePool(lunInfo);

    busScanData->NumberOfLogicalUnits = device;
    DebugPrint((1,
               "ScsiBusScan: Found %d devices on SCSI bus %d\n",
               device,
               ScsiBus));

    return busScanData;

} // end ScsiBusScan()


PLOGICAL_UNIT_EXTENSION
CreateLogicalUnitExtension(
    IN PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    Create logical unit extension.

Arguments:

    DeviceExtension
    PathId

Return Value:

    Logical unit extension


--*/
{
    PLOGICAL_UNIT_EXTENSION logicalUnitExtension;

            //
            // Create logical unit extension and link in chain.
            //

            logicalUnitExtension =
                ExAllocatePool(NonPagedPool, sizeof(LOGICAL_UNIT_EXTENSION));

            if (logicalUnitExtension == NULL) {
                return(NULL);
            }

            //
            // Zero logical unit extension.
            //

            RtlZeroMemory(logicalUnitExtension, sizeof(LOGICAL_UNIT_EXTENSION));

            //
            // Allocate miniport driver logical unit extension if necessary.
            //

            if (DeviceExtension->HwLogicalUnitExtensionSize) {

                logicalUnitExtension->SpecificLuExtension =
                    ExAllocatePool(NonPagedPool,
                    DeviceExtension->HwLogicalUnitExtensionSize);

                if (logicalUnitExtension->SpecificLuExtension == NULL) {
                    return(NULL);
                }

                //
                // Zero hardware logical unit extension.
                //

                RtlZeroMemory(logicalUnitExtension->SpecificLuExtension,
                    DeviceExtension->HwLogicalUnitExtensionSize);
            }

            //
            // Set timer counters in LogicalUnits to -1 to indicate no
            // outstanding requests.
            //

            logicalUnitExtension->RequestTimeoutCounter = -1;

            //
            // Clear the current request field.
            //

            logicalUnitExtension->CurrentRequest = NULL;

            return logicalUnitExtension;

} // end CreateLogicalUnitExtension()


//
// Routines providing service to hardware dependent driver.
//

SCSI_PHYSICAL_ADDRESS
ScsiPortGetPhysicalAddress(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID VirtualAddress,
    OUT ULONG *Length
)

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PDEVICE_EXTENSION deviceExtension =
        ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;
    PSRB_SCATTER_GATHER scatterList;
    PIRP irp;
    PMDL mdl;
    ULONG byteOffset;
    ULONG whichPage;
    PULONG pages;
    ULONG_PTR address;

    if (Srb == NULL) {

        //
        // The virtual address is required to be within the non-cached extension
        // and we can't allocate 4GB of non-cached extension in the loader so 
        // truncate the offset to a ULONG.
        //

        byteOffset = (ULONG) ((PUCHAR) deviceExtension->NonCachedExtension - 
                              (PUCHAR) VirtualAddress);

        if (deviceExtension->SrbExtensionZonePool) {

            address = (PUCHAR) VirtualAddress - 
                      (PUCHAR) deviceExtension->SrbExtensionZonePool +
                      deviceExtension->PhysicalZoneBase;

        } else {

            address = MmGetPhysicalAddress(VirtualAddress).LowPart;
        }

        //
        // Return the requested length.
        //

        *Length = deviceExtension->NonCachedExtensionSize - byteOffset;

    } else if (deviceExtension->MasterWithAdapter) {

        //
        // A scatter/gather list has already been allocated use it to determine
        // the physical address and length.  Get the scatter/gather list.
        //

        scatterList = GetLogicalUnitExtension(deviceExtension, Srb->TargetId)
            ->ScatterGather;

        //
        // Calculate byte offset into the data buffer.
        //

        byteOffset = (ULONG)((PCHAR) VirtualAddress - (PCHAR) Srb->DataBuffer);

        //
        // Find the appropirate entry in the scatter/gatter list.
        //

        while (byteOffset >= scatterList->Length) {

            byteOffset -= scatterList->Length;
            scatterList++;
        }

        //
        // Calculate the physical address and length to be returned.
        //

        *Length = scatterList->Length - byteOffset;
        return(ScsiPortConvertUlongToPhysicalAddress(scatterList->PhysicalAddress + byteOffset));

    } else {

        //
        // Get IRP from SRB.
        //

        irp = Srb->OriginalRequest;

        //
        // Get MDL from IRP.
        //

        mdl = irp->MdlAddress;

        //
        // Calculate byte offset from
        // beginning of first physical page.
        //

        byteOffset = (ULONG)((PCHAR)VirtualAddress - (PCHAR)mdl->StartVa);

        //
        // Calculate which physical page.
        //

        whichPage = byteOffset >> PAGE_SHIFT;

        //
        // Calculate beginning of physical page array.
        //

        pages = (PULONG)(mdl + 1);

        //
        // Calculate physical address.
        //

        address = (pages[whichPage] << PAGE_SHIFT) +
            BYTE_OFFSET(VirtualAddress);

        //
        // Assume the buffer is contiguous.  Just return the requested length.
        //
    }

    return ScsiPortConvertUlongToPhysicalAddress(address);

} // end ScsiPortGetPhysicalAddress()


PVOID
ScsiPortGetVirtualAddress(
    IN PVOID HwDeviceExtension,
    IN SCSI_PHYSICAL_ADDRESS PhysicalAddress
    )

/*++

Routine Description:

    This routine is returns a virtual address associated with a
    physical address, if the physical address was obtained by a
    call to ScsiPortGetPhysicalAddress.

Arguments:

    PhysicalAddress

Return Value:

    Virtual address if physical page hashed.
    NULL if physical page not found in hash.

--*/

{
    PDEVICE_EXTENSION deviceExtension =
        ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;
    PVOID address;



    address = ScsiPortConvertPhysicalAddressToUlong(PhysicalAddress)
        - deviceExtension->PhysicalZoneBase +
        (PUCHAR)deviceExtension->SrbExtensionZonePool;

    return address;

} // end ScsiPortGetVirtualAddress()


PVOID
ScsiPortGetLogicalUnit(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )

/*++

Routine Description:

    Walk port driver's logical unit extension list searching
    for entry.

Arguments:

    HwDeviceExtension - The port driver's device extension follows
        the miniport's device extension and contains a pointer to
        the logical device extension list.

    PathId, TargetId and Lun - identify which logical unit on the
        SCSI buses.

Return Value:

    If entry found return miniport driver's logical unit extension.
    Else, return NULL.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;

    //
    // Get pointer to port driver device extension.
    //

    deviceExtension = (PDEVICE_EXTENSION)HwDeviceExtension -1;

    //
    // Get pointer to logical unit list.
    //

    logicalUnit = deviceExtension->LogicalUnitList;

    //
    // Walk list looking at target id for requested logical unit extension.
    //

    while (logicalUnit != NULL) {

        if ((logicalUnit->TargetId == TargetId) &&
            (logicalUnit->PathId == PathId) &&
            (logicalUnit->Lun == Lun)) {

            //
            // Logical unit extension found.
            // Return specific logical unit extension.
            //

            return logicalUnit->SpecificLuExtension;
        }

        //
        // Get next logical unit.
        //

        logicalUnit = logicalUnit->NextLogicalUnit;
    }

    //
    // Requested logical unit extension not found.
    //

    return NULL;

} // end ScsiPortGetLogicalUnit()

VOID
ScsiPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PDEVICE_EXTENSION deviceExtension =
        (PDEVICE_EXTENSION) HwDeviceExtension - 1;
    PIO_STACK_LOCATION irpstack;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK srb;
    va_list(ap);

    va_start(ap, HwDeviceExtension);

    switch (NotificationType) {

        case NextLuRequest:
        case NextRequest:

            //
            // Start next packet on adapter's queue.
            //

            deviceExtension->InterruptFlags |= PD_READY_FOR_NEXT_REQUEST;
            break;

        case RequestComplete:

            srb = va_arg(ap, PSCSI_REQUEST_BLOCK);

            if (srb->SrbStatus == SRB_STATUS_ERROR) {
            }

            //
            // Link the completed request into a forward-linked list of IRPs.
            //

            irpstack = IoGetCurrentIrpStackLocation(
                ((PIRP) srb->OriginalRequest)
                );

            irpstack->Parameters.Others.Argument3 =
                deviceExtension->CompletedRequests;

            deviceExtension->CompletedRequests = srb->OriginalRequest;

            //
            // Set logical unit current request to NULL
            // to prevent race condition.
            //

            logicalUnit = GetLogicalUnitExtension(deviceExtension, srb->TargetId);

            if (logicalUnit != NULL) {
                logicalUnit->CurrentRequest = NULL;
            } else {
                ASSERT(logicalUnit != NULL); // Logic error, must debug this.
            }

            break;

        case ResetDetected:

                 deviceExtension->PortTimeoutCounter = PD_TIMER_RESET_HOLD_TIME;
            break;

        case CallDisableInterrupts:

            ASSERT(deviceExtension->Flags & PD_DISABLE_INTERRUPTS);

            //
            // The mini-port wants us to call the specified routine
            // with interrupts disabled.  This is done after the current
            // HwRequestInterrutp routine completes. Indicate the call is
            // needed and save the routine to be called.
            //

            deviceExtension->Flags |= PD_DISABLE_CALL_REQUEST;

            deviceExtension->HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);

            break;

        case CallEnableInterrupts:

            ASSERT(!(deviceExtension->Flags & PD_DISABLE_INTERRUPTS));

            //
            // The mini-port wants us to call the specified routine
            // with interrupts enabled this is done from the DPC.
            // Disable calls to the interrupt routine, indicate the call is
            // needed and save the routine to be called.
            //

            deviceExtension->Flags |= PD_DISABLE_INTERRUPTS | PD_ENABLE_CALL_REQUEST;

            deviceExtension->HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);

            break;

        case RequestTimerCall:

            deviceExtension->HwTimerRequest = va_arg(ap, PHW_INTERRUPT);
            deviceExtension->TimerValue = va_arg(ap, ULONG);

            if (deviceExtension->TimerValue) {

                //
                // Round up the timer value to the stall time.
                //

                deviceExtension->TimerValue = (deviceExtension->TimerValue
                  + PD_INTERLOOP_STALL - 1)/ PD_INTERLOOP_STALL;
            }

            break;
    }

    va_end(ap);

    //
    // Check to see if the last DPC has been processed yet.  If so
    // queue another DPC.
    //

    ScsiPortCompletionDpc(
        NULL,                           // Dpc
        deviceExtension->DeviceObject,  // DeviceObject
        NULL,                           // Irp
        NULL                            // Context
        );

} // end ScsiPortNotification()


VOID
ScsiPortFlushDma(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine checks to see if the perivious IoMapTransfer has been done
    started.  If it has not, then the PD_MAP_TRANSER flag is cleared, and the
    routine returns; otherwise, this routine schedules a DPC which will call
    IoFlushAdapter buffers.

Arguments:

    HwDeviceExtension - Supplies a the hardware device extension for the
        host bus adapter which will be doing the data transfer.


Return Value:

    None.

--*/

{

    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;

    if (deviceExtension->InterruptFlags & PD_MAP_TRANSFER) {

        //
        // The transfer has not been started so just clear the map transfer
        // flag and return.
        //

        deviceExtension->InterruptFlags &= ~PD_MAP_TRANSFER;
        return;
    }

    deviceExtension->InterruptFlags |= PD_FLUSH_ADAPTER_BUFFERS;

    //
    // Check to see if the last DPC has been processed yet.  If so
    // queue another DPC.
    //

    ScsiPortCompletionDpc(
        NULL,                           // Dpc
        deviceExtension->DeviceObject,  // DeviceObject
        NULL,                           // Irp
        NULL                            // Context
        );

    return;

}

VOID
ScsiPortIoMapTransfer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID LogicalAddress,
    IN ULONG Length
    )
/*++

Routine Description:

    Saves the parameters for the call to IoMapTransfer and schedules the DPC
    if necessary.

Arguments:

    HwDeviceExtension - Supplies a the hardware device extension for the
        host bus adapter which will be doing the data transfer.

    Srb - Supplies the particular request that data transfer is for.

    LogicalAddress - Supplies the logical address where the transfer should
        begin.

    Length - Supplies the maximum length in bytes of the transfer.

Return Value:

   None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;

    //
    // Make sure this host bus adapter has an Dma adapter object.
    //

    if (deviceExtension->DmaAdapterObject == NULL) {
        //
        // No DMA adapter, no work.
        //
        return;
    }

    deviceExtension->MapTransferParameters.Srb = Srb;
    deviceExtension->MapTransferParameters.LogicalAddress = LogicalAddress;
    deviceExtension->MapTransferParameters.Length = Length;

    deviceExtension->InterruptFlags |= PD_MAP_TRANSFER;

    //
    // Check to see if the last DPC has been processed yet.  If so
    // queue another DPC.
    //

    ScsiPortCompletionDpc(
        NULL,                           // Dpc
        deviceExtension->DeviceObject,  // DeviceObject
        NULL,                           // Irp
        NULL                            // Context
        );

} // end ScsiPortIoMapTransfer()


VOID
IssueRequestSense(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    )

/*++

Routine Description:

    This routine creates a REQUEST SENSE request and uses IoCallDriver to
    renter the driver.  The completion routine cleans up the data structures
    and processes the logical unit queue according to the flags.

    A pointer to failing SRB is stored at the end of the request sense
    Srb, so that the completion routine can find it.

Arguments:

    DeviceExension - Supplies a pointer to the device extension for this
        SCSI port.

    FailingSrb - Supplies a pointer to the request that the request sense
        is being done for.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpstack;
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    PCDB cdb;
    PVOID *Pointer;

    //
    // Allocate Srb from non-paged pool
    // plus room for a pointer to the failing IRP.
    // Since this routine is in an error-handling
    // path and a shortterm allocation
    // NonPagedMustSucceed is requested.
    //

    Srb = &RequestSenseSrb.Srb;

    //
    // Allocate an IRP to issue the REQUEST SENSE request.
    //

    Irp = InitializeIrp(
        &RequestSenseSrb,
        IRP_MJ_READ,
        deviceExtension->DeviceObject,
        FailingSrb->SenseInfoBuffer,
        FailingSrb->SenseInfoBufferLength
        );

    irpstack = IoGetNextIrpStackLocation(Irp);

    irpstack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save the Failing SRB after the request sense Srb.
    //

    Pointer = (PVOID *) (Srb+1);
    *Pointer = FailingSrb;

    //
    // Build the REQUEST SENSE CDB.
    //

    Srb->CdbLength = 6;
    cdb = (PCDB)Srb->Cdb;

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
    cdb->CDB6INQUIRY.LogicalUnitNumber = 0;
    cdb->CDB6INQUIRY.Reserved1 = 0;
    cdb->CDB6INQUIRY.PageCode = 0;
    cdb->CDB6INQUIRY.IReserved = 0;
    cdb->CDB6INQUIRY.AllocationLength =
        (UCHAR)FailingSrb->SenseInfoBufferLength;
    cdb->CDB6INQUIRY.Control = 0;

    //
    // Save SRB address in next stack for port driver.
    //

    irpstack->Parameters.Others.Argument1 = (PVOID)Srb;

    //
    // Set up IRP Address.
    //

    Srb->OriginalRequest = Irp;

    Srb->NextSrb = 0;

    //
    // Set up SCSI bus address.
    //

    Srb->TargetId = FailingSrb->TargetId;
    Srb->Lun = FailingSrb->Lun;
    Srb->PathId = FailingSrb->PathId;
    Srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    //
    // Set timeout value to 2 seconds.
    //

    Srb->TimeOutValue = 2;

    //
    // Disable auto request sense.
    //

    Srb->SenseInfoBufferLength = 0;

    //
    // Sense buffer is in stack.
    //

    Srb->SenseInfoBuffer = NULL;

    //
    // Set read and bypass frozen queue bits in flags.
    //

    //
    // Set a speical flags to indicate the logical unit queue should be by
    // passed and that no queue processing should be done when the request
    // completes.
    //

    Srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_BYPASS_FROZEN_QUEUE |
        SRB_FLAGS_DISABLE_SYNCH_TRANSFER | SRB_FLAGS_DISABLE_DISCONNECT;

    Srb->DataBuffer = FailingSrb->SenseInfoBuffer;

    //
    // Set the transfer length.
    //

    Srb->DataTransferLength = FailingSrb->SenseInfoBufferLength;

    //
    // Zero out status.
    //

    Srb->ScsiStatus = Srb->SrbStatus = 0;

    (VOID)IoCallDriver(deviceExtension->DeviceObject, Irp);

    ScsiPortInternalCompletion(deviceExtension->DeviceObject, Irp, Srb);

    return;

} // end IssueRequestSense()


VOID
ScsiPortInternalCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )

/*++

Routine Description:

Arguments:

    Device object
    IRP
    Context - pointer to SRB

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb = Context;
    PIO_STACK_LOCATION irpstack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK failingSrb;
    PIRP failingIrp;

    UNREFERENCED_PARAMETER(DeviceObject);

    //
    // Request sense completed. If successful or data over/underrun
    // get the failing SRB and indicate that the sense information
    // is valid. The class driver will check for underrun and determine
    // if there is enough sense information to be useful.
    //

    if ((SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS) ||
        (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN)) {

        //
        // Get a pointer to failing Irp and Srb.
        //

        failingSrb = *((PVOID *) (srb+1));
        failingIrp = failingSrb->OriginalRequest;

        //
        // Report sense buffer is valid.
        //

        failingSrb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;

        //
        // Copy bytes transferred to failing SRB
        // request sense length field to communicate
        // to the class drivers the number of valid
        // sense bytes.
        //

        failingSrb->SenseInfoBufferLength = (UCHAR) srb->DataTransferLength;

    }

} // ScsiPortInternalCompletion()


VOID
ScsiPortTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension =
        (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;

    UNREFERENCED_PARAMETER(Context);

    logicalUnit = deviceExtension->LogicalUnitList;

    //
    // NOTE: The use of Current request needs to be synchronized with the
    // clearing of current request.
    //

    while (logicalUnit != NULL) {

        //
        // Check for busy requests.
        //

        if (logicalUnit->Flags & PD_LOGICAL_UNIT_IS_BUSY) {

            DebugPrint((1,"ScsiPortTickHandler: Retrying busy status request\n"));

            //
            // Clear the busy flag and retry the request.
            //

            logicalUnit->Flags &= ~PD_LOGICAL_UNIT_IS_BUSY;

            ScsiPortStartIo(DeviceObject, logicalUnit->CurrentRequest);

        } else if (logicalUnit->RequestTimeoutCounter == 0) {

            //
            // Request timed out.
            //

            DebugPrint((1, "ScsiPortTickHandler: Request timed out\n"));

            //
            // Reset request timeout counter to unused state.
            //

            logicalUnit->RequestTimeoutCounter = -1;

            //
            // Build and send request to abort command.
            //

            IssueAbortRequest(deviceExtension, logicalUnit->CurrentRequest);
        } else if (logicalUnit->RequestTimeoutCounter != -1) {

            DebugPrint((1, "ScsiPortTickHandler: Timeout value %lx\n",logicalUnit->RequestTimeoutCounter));
            logicalUnit->RequestTimeoutCounter--;
        }

        logicalUnit = logicalUnit->NextLogicalUnit;
    }

    return;

} // end ScsiPortTickHandler()


VOID
IssueAbortRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP FailingIrp
    )

/*++

Routine Description:

    A request timed out and to clear the request at the HBA
    an ABORT request is issued. But first, if the request
    that timed out was an ABORT command, then reset the
    adapter instead.

Arguments:

    DeviceExension - Supplies a pointer to the device extension for this
        SCSI port.

    FailingIrp - Supplies a pointer to the request that is to be aborted.

Return Value:

    None.

--*/

{

    ULONG j;

    //
    // A request to abort failed.
    // Need to reset the adapter.
    //

    DebugPrint((1,"IssueAbort: Request timed out, resetting the bus.\n"));


    if (!DeviceExtension->HwReset(
        DeviceExtension->HwDeviceExtension,
        0)){

        DebugPrint((1,"Reset SCSI bus failed\n"));
    }

    //
    // Call the interupt handler for a few microseconds to clear any reset
    // interrupts.
    //

    for (j = 0; j < 1000 * 100; j++) {

        FwStallExecution(10);
        if (DeviceExtension->HwInterrupt != NULL) {
            DeviceExtension->HwInterrupt(DeviceExtension->HwDeviceExtension);
        }

    }

    DeviceExtension->PortTimeoutCounter = PD_TIMER_RESET_HOLD_TIME;
    SpCheckResetDelay( DeviceExtension );

    return;


} // end IssueAbortRequest()


VOID
SpCheckResetDelay(
    IN PDEVICE_EXTENSION deviceExtension
    )

/*++

Routine Description:

    If there is a pending reset delay, this routine stalls the execution
    for the specified number of seconds.  During the delay the timer
    routines are called at the appropriate times.

Arguments:

    DeviceExension - Supplies a pointer to the device extension for this
        SCSI port.

Return Value:

    Nothing.

--*/

{
    ULONG milliSecondTime;

    //
    // Check if the adapter is ready to accept requests.
    //

    while (deviceExtension->PortTimeoutCounter) {

        deviceExtension->PortTimeoutCounter--;

        //
        // One second delay.
        //

        for ( milliSecondTime = 0;
              milliSecondTime < ((1000*1000)/PD_INTERLOOP_STALL);
              milliSecondTime++ ) {

            FwStallExecution(PD_INTERLOOP_STALL);

            //
            // Check the miniport timer.
            //

            if (deviceExtension->TimerValue != 0) {

                deviceExtension->TimerValue--;

                if (deviceExtension->TimerValue == 0) {

                    //
                    // The timer timed out so called requested timer routine.
                    //

                    deviceExtension->HwTimerRequest(deviceExtension->HwDeviceExtension);
                }
            }
        }
    }

    return;
}

BOOLEAN
SpGetInterruptState(
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This routine saves the InterruptFlags, MapTransferParameters and
    CompletedRequests fields and clears the InterruptFlags.

Arguments:

    ServiceContext - Supplies a pointer to the device extension for this
        SCSI port.

Return Value:

    Always returns TRUE.

Notes:

    Called via KeSynchronizeExecution.

--*/
{
    PDEVICE_EXTENSION deviceExtension = ServiceContext;

    //
    // Move the interrupt state to save area.
    //

    deviceExtension->InterruptFlags = deviceExtension->InterruptFlags;
    deviceExtension->CompletedRequests = deviceExtension->CompletedRequests;
    deviceExtension->MapTransferParameters = deviceExtension->MapTransferParameters;

    //
    // Clear the interrupt state.
    //

    deviceExtension->InterruptFlags = 0;
    deviceExtension->CompletedRequests = NULL;

    return(TRUE);
}

VOID
ScsiDebugPause(
    VOID
    )
{
#if DBG
#define SCSIDEBUG_PAUSE 0x100
#define SCSIDEBUG_PAUSE_LIMIT 20

    static ULONG ScsiDebugPauseCount;

    if (++ScsiDebugPauseCount > SCSIDEBUG_PAUSE_LIMIT) {
        ScsiDebugPauseCount = 0;
        if (ScsiDebug & SCSIDEBUG_PAUSE) {
            DebugPrint((1, "Hit any key.\n"));
            while(!GET_KEY()); // DEBUG Only!
        }
    }
#endif
}

VOID
ScsiPortLogError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied text
    to it, and requests that it be written to the error log file.

Arguments:

    DeviceExtenson - Supplies the HBA mini-port driver's adapter data storage.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    ErrorCode - Supplies an error code indicating the type of error.

    UniqueId - Supplies a unique identifier for the error.

Return Value:

    None.

--*/

{
    PCHAR errorCodeString;

    switch (ErrorCode) {
    case SP_BUS_PARITY_ERROR:
        errorCodeString = "SCSI bus partity error";
        break;

    case SP_UNEXPECTED_DISCONNECT:
        errorCodeString = "Unexpected disconnect";
        break;

    case SP_INVALID_RESELECTION:
        errorCodeString = "Invalid reselection";
        break;

    case SP_BUS_TIME_OUT:
        errorCodeString = "SCSI bus time out";
        break;

    case SP_PROTOCOL_ERROR:
        errorCodeString = "SCSI protocol error";
        break;

    case SP_INTERNAL_ADAPTER_ERROR:
        errorCodeString = "Internal adapter error";
        break;

    default:
        errorCodeString = "Unknown error code";
        break;

    }

    DebugPrint((1,"\n\nLogErrorEntry: Logging SCSI error packet. ErrorCode = %s.\n",
        errorCodeString));
    DebugPrint((1,
        "PathId = %2x, TargetId = %2x, Lun = %2x, UniqueId = %x.\n\n",
        PathId,
        TargetId,
        Lun,
        UniqueId));

#if DBG
    ScsiDebugPause();
#endif

    return;

} // end ScsiPortLogError()


VOID
ScsiPortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    )

/*++

Routine Description:

    Complete all active requests for the specified logical unit.

Arguments:

    DeviceExtenson - Supplies the HBA mini-port driver's adapter data storage.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    SrbStatus - Status to be returned in each completed SRB.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension =
        ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;
    PSCSI_REQUEST_BLOCK Srb;
    PSCSI_REQUEST_BLOCK failingSrb;
    PLOGICAL_UNIT_EXTENSION luExtension;
    PIRP nextIrp;
    PIO_STACK_LOCATION irpstack;

    UNREFERENCED_PARAMETER(PathId);
    UNREFERENCED_PARAMETER(Lun);

    if (TargetId == (UCHAR)(-1)) {

        //
        // Complete requests for all units on this bus.
        //

        luExtension = deviceExtension->LogicalUnitList;

        while (luExtension != NULL) {

            //
            // Complete requests until queue is empty.
            //

            if ((nextIrp = luExtension->CurrentRequest) != NULL &&
                !(luExtension->Flags & PD_LOGICAL_UNIT_IS_BUSY)) {

                //
                // Get SRB address from current IRP stack.
                //

                irpstack = IoGetCurrentIrpStackLocation(nextIrp);

                Srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;

                //
                // Just in case this is an abort request,
                // get pointer to failingSrb.
                //

                failingSrb = Srb->NextSrb;

                //
                // Update SRB status.
                //

                Srb->SrbStatus = SrbStatus;

                //
                // Indicate no bytes transferred.
                //

                Srb->DataTransferLength = 0;

                //
                // Set IRP status.
                //

                nextIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

                //
                // Move bytes transferred to IRP.
                //

                nextIrp->IoStatus.Information = Srb->DataTransferLength;

                //
                // Call notification routine.
                //

                ScsiPortNotification(RequestComplete,
                            (PVOID)HwDeviceExtension,
                            Srb);

                if (failingSrb) {

                    //
                    // This was an abort request. The failing
                    // SRB must also be completed.
                    //

                    failingSrb->SrbStatus = SrbStatus;
                    failingSrb->DataTransferLength = 0;

                    //
                    // Get IRP from SRB.
                    //

                    nextIrp = failingSrb->OriginalRequest;

                    //
                    // Set IRP status.
                    //

                    nextIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

                    //
                    // Move bytes transferred to IRP.
                    //

                    nextIrp->IoStatus.Information =
                        failingSrb->DataTransferLength;

                    //
                    // Call notification routine.
                    //

                    ScsiPortNotification(RequestComplete,
                            (PVOID)HwDeviceExtension,
                            failingSrb);
                }

            } // end if

            luExtension = luExtension->NextLogicalUnit;

        } // end while

    } else {

        //
        // Complete all requests for this logical unit.
        //

        luExtension =
                GetLogicalUnitExtension(deviceExtension, TargetId);

        ASSERT(luExtension != NULL);

        //
        // Complete requests until queue is empty.
        //

        if ((luExtension != NULL) && ((nextIrp = luExtension->CurrentRequest) != NULL)) {

            //
            // Get SRB address from current IRP stack.
            //

            irpstack = IoGetCurrentIrpStackLocation(nextIrp);

            Srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;

            //
            // Update SRB status.
            //

            Srb->SrbStatus = SrbStatus;

            //
            // Indicate no bytes transferred.
            //

            Srb->DataTransferLength = 0;

            //
            // Set IRP status.
            //

            nextIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

            //
            // Move bytes transferred to IRP.
            //

            nextIrp->IoStatus.Information = Srb->DataTransferLength;

            //
            // Call notification routine.
            //

            ScsiPortNotification(RequestComplete,
                            (PVOID)HwDeviceExtension,
                            Srb);

        } // end if

    } // end if ... else

    return;


} // end ScsiPortCompleteRequest()


VOID
ScsiPortMoveMemory(
    IN PVOID WriteBuffer,
    IN PVOID ReadBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    Copy from one buffer into another.

Arguments:

    ReadBuffer - source
    WriteBuffer - destination
    Length - number of bytes to copy

Return Value:

    None.

--*/

{
    RtlMoveMemory(WriteBuffer, ReadBuffer, Length);

} // end ScsiPortMoveMemory()


VOID
ScsiPortStallExecution(
    ULONG Delay
    )
/*++

Routine Description:

    Wait number of microseconds in tight processor loop.

Arguments:

    Delay - number of microseconds to wait.

Return Value:

    None.

--*/

{
    FwStallExecution(Delay);

} // end ScsiPortStallExecution()


PLOGICAL_UNIT_EXTENSION
GetLogicalUnitExtension(
    PDEVICE_EXTENSION deviceExtension,
    UCHAR TargetId
    )

/*++

Routine Description:

    Walk logical unit extension list looking for
    extension with matching target id.

Arguments:

    deviceExtension
    TargetId

Return Value:

    Requested logical unit extension if found,
    else NULL.

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit = deviceExtension->LogicalUnitList;

    while (logicalUnit != NULL) {

        if (logicalUnit->TargetId == TargetId) {

            return logicalUnit;
        }

        logicalUnit = logicalUnit->NextLogicalUnit;
    }

    //
    // Logical unit extension not found.
    //

    return (PLOGICAL_UNIT_EXTENSION)NULL;

} // end GetLogicalUnitExtension()

#if DBG


VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all SCSI drivers

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    va_start( ap, DebugMessage );

    if (DebugPrintLevel <= (ScsiDebug & (SCSIDEBUG_PAUSE-1))) {

        char buffer[256];

        _vsnprintf(buffer, sizeof(buffer), DebugMessage, ap);
#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
        FwPrint(buffer);
        FwPrint("\r");
#else
        BlPrint(buffer);
        BlPrint("\r");
#endif
        DbgPrint(buffer);
    }

    va_end(ap);
}

#else

//
// ScsiDebugPrint stub
//

VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
}

#endif


UCHAR
ScsiPortReadPortUchar(
    IN PUCHAR Port
    )

/*++

Routine Description:

    Read from the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

#ifdef MIPS

    return(READ_REGISTER_UCHAR(Port));

#else

    return(READ_PORT_UCHAR(Port));

#endif
}

USHORT
ScsiPortReadPortUshort(
    IN PUSHORT Port
    )

/*++

Routine Description:

    Read from the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

#ifdef MIPS

    return(READ_REGISTER_USHORT(Port));

#else

    return(READ_PORT_USHORT(Port));

#endif
}

ULONG
ScsiPortReadPortUlong(
    IN PULONG Port
    )

/*++

Routine Description:

    Read from the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

#ifdef MIPS

    return(READ_REGISTER_ULONG(Port));

#else

    return(READ_PORT_ULONG(Port));

#endif
}

UCHAR
ScsiPortReadRegisterUchar(
    IN PUCHAR Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_UCHAR(Register));

}

USHORT
ScsiPortReadRegisterUshort(
    IN PUSHORT Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_USHORT(Register));

}

ULONG
ScsiPortReadRegisterUlong(
    IN PULONG Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_ULONG(Register));

}

VOID
ScsiPortReadRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
ScsiPortReadRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
ScsiPortReadRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

VOID
ScsiPortWritePortUchar(
    IN PUCHAR Port,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

#ifdef MIPS

    WRITE_REGISTER_UCHAR(Port, Value);

#else

    WRITE_PORT_UCHAR(Port, Value);

#endif
}

VOID
ScsiPortWritePortUshort(
    IN PUSHORT Port,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

#ifdef MIPS

    WRITE_REGISTER_USHORT(Port, Value);

#else

    WRITE_PORT_USHORT(Port, Value);

#endif
}

VOID
ScsiPortWritePortUlong(
    IN PULONG Port,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

#ifdef MIPS

    WRITE_REGISTER_ULONG(Port, Value);

#else

    WRITE_PORT_ULONG(Port, Value);

#endif
}

VOID
ScsiPortWriteRegisterUchar(
    IN PUCHAR Register,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_UCHAR(Register, Value);

}

VOID
ScsiPortWriteRegisterUshort(
    IN PUSHORT Register,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_USHORT(Register, Value);

}

VOID
ScsiPortWriteRegisterUlong(
    IN PULONG Register,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_ULONG(Register, Value);

}

VOID
ScsiPortWriteRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
ScsiPortWriteRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
ScsiPortWriteRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

SCSI_PHYSICAL_ADDRESS
ScsiPortConvertUlongToPhysicalAddress(
    ULONG_PTR UlongAddress
    )

{
    SCSI_PHYSICAL_ADDRESS physicalAddress;

    physicalAddress.QuadPart = UlongAddress;
    return(physicalAddress);
}

#undef ScsiPortConvertPhysicalAddressToUlong

ULONG
ScsiPortConvertPhysicalAddressToUlong(
    SCSI_PHYSICAL_ADDRESS Address
    )
{

    return(Address.LowPart);
}



PIRP
InitializeIrp(
   PFULL_SCSI_REQUEST_BLOCK FullSrb,
   CCHAR MajorFunction,
   PVOID DeviceObject,
   PVOID Buffer,
   ULONG Length
   )
/*++

Routine Description:

    This funcition builds an IRP for use by the SCSI port driver and builds a
    MDL list.

Arguments:

    FullSrb - Supplies a pointer to the full srb structure which contains the
        Irp and Mdl.

    MajorFunction - Supplies the major function code to initialize the Irp
        entry.

    DeviceObject - Supplies the device Object pointer to initialize the Irp
        with.

    Buffer - Supplies the virual address of the buffer for which the
        Mdl should be built.

    Length - Supplies the size of buffer for which the Mdl should be built.

Return Value:

    Returns a pointer to the initialized IRP.

--*/

{
    PIRP irp;
    PMDL mdl;

    irp = &FullSrb->Irp;
    mdl = &FullSrb->Mdl;

    irp->Tail.Overlay.CurrentStackLocation = &FullSrb->IrpStack[IRP_STACK_SIZE];

    if (Buffer != NULL && Length != 0) {

        //
        // Build the memory descriptor list.
        //

        irp->MdlAddress = mdl;
        mdl->Next = NULL;
        mdl->Size = (CSHORT)(sizeof(MDL) +
                  ADDRESS_AND_SIZE_TO_SPAN_PAGES(Buffer, Length) * sizeof(ULONG));
        mdl->StartVa = (PVOID)PAGE_ALIGN(Buffer);
        mdl->ByteCount = Length;
        mdl->ByteOffset = BYTE_OFFSET(Buffer);
        mdl->MappedSystemVa = Buffer;
        mdl->MdlFlags = MDL_MAPPED_TO_SYSTEM_VA;
        ScsiPortInitializeMdlPages (mdl);

    } else {
        irp->MdlAddress = NULL;
    }

    return(irp);
}

PVOID
ScsiPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    SCSI_PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    BOOLEAN InMemorySpace
    )

/*++

Routine Description:

    This routine maps an IO address to system address space.
    Use ScsiPortFreeDeviceBase to unmap address.

Arguments:

    HwDeviceExtension - used to find port device extension.
    BusType - what type of bus - eisa, mca, isa
    SystemIoBusNumber - which IO bus (for machines with multiple buses).
    IoAddress - base device address to be mapped.
    NumberOfBytes - number of bytes for which address is valid.

Return Value:

    Mapped address

--*/

{
    PHYSICAL_ADDRESS cardAddress;
    ULONG addressSpace = InMemorySpace;
    PVOID mappedAddress;

    if (!HalTranslateBusAddress(
            BusType,                // AdapterInterfaceType
            SystemIoBusNumber,      // SystemIoBusNumber
            IoAddress,              // Bus Address
            &addressSpace,          // AddressSpace
            &cardAddress            // Translated address
            )) {
        return NULL;
    }

    //
    // Map the device base address into the virtual address space
    // if the address is in memory space.
    //

    if (!addressSpace) {

        mappedAddress = MmMapIoSpace(cardAddress,
                                 NumberOfBytes,
                                 FALSE);


    } else {

        mappedAddress = (PVOID)((ULONG_PTR)cardAddress.LowPart);
    }

    return mappedAddress;

} // end ScsiPortGetDeviceBase()

VOID
ScsiPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )

/*++

Routine Description:

    This routine unmaps an IO address that has been previously mapped
    to system address space using ScsiPortGetDeviceBase().

Arguments:

    HwDeviceExtension - used to find port device extension.
    MappedAddress - address to unmap.
    NumberOfBytes - number of bytes mapped.
    InIoSpace - addresses in IO space don't get mapped.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER(HwDeviceExtension);
    UNREFERENCED_PARAMETER(MappedAddress);

    return;

} // end ScsiPortFreeDeviceBase()

ARC_STATUS
GetAdapterCapabilities(
    IN PDEVICE_OBJECT PortDeviceObject,
    OUT PIO_SCSI_CAPABILITIES *PortCapabilities
    )

/*++

Routine Description:

Arguments:

Return Value:

    Status is returned.

--*/

{
    *PortCapabilities = &((PDEVICE_EXTENSION)PortDeviceObject->DeviceExtension)
        ->Capabilities;

    return(ESUCCESS);
} // end GetAdapterCapabilities()


ARC_STATUS
GetInquiryData(
    IN PDEVICE_OBJECT PortDeviceObject,
    OUT PSCSI_CONFIGURATION_INFO *ConfigInfo
    )

/*++

Routine Description:

    This routine sends a request to a port driver to return
    configuration information.

Arguments:

    The address of the configuration information is returned in
    the formal parameter ConfigInfo.

Return Value:

    Status is returned.

--*/
{
    *ConfigInfo = ((PDEVICE_EXTENSION)PortDeviceObject->DeviceExtension)
        ->ScsiInfo;
    return(ESUCCESS);
} // end GetInquiryData()

NTSTATUS
SpInitializeConfiguration(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PHW_INITIALIZATION_DATA HwInitData,
    OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN BOOLEAN InitialCall
    )
/*++

Routine Description:

    This routine initializes the port configuration information structure.
    Any necessary information is extracted from the registery.

Arguments:

    DeviceExtension - Supplies the device extension.

    HwInitializationData - Supplies the initial miniport data.

    ConfigInfo - Supplies the configuration information to be
        initialized.

    InitialCall - Indicates that this is first call to this function.
        If InitialCall is FALSE, then the perivous configuration information
        is used to determine the new information.

Return Value:

    Returns a status indicating the success or fail of the initializaiton.

--*/

{
#ifdef i386
    extern ULONG MachineType;
#endif

    ULONG j;

    //
    // If this is the initial call then zero the information and set
    // the structure to the uninitialized values.
    //

    if (InitialCall) {

        RtlZeroMemory(ConfigInfo, sizeof(PORT_CONFIGURATION_INFORMATION));

        ConfigInfo->Length = sizeof(PORT_CONFIGURATION_INFORMATION);
        ConfigInfo->AdapterInterfaceType = HwInitData->AdapterInterfaceType;
        ConfigInfo->InterruptMode = Latched;
        ConfigInfo->MaximumTransferLength = 0xffffffff;
//        ConfigInfo->NumberOfPhysicalBreaks = 0x17;
        ConfigInfo->NumberOfPhysicalBreaks = 0xffffffff;
        ConfigInfo->DmaChannel = 0xffffffff;
        ConfigInfo->NumberOfAccessRanges = HwInitData->NumberOfAccessRanges;
        ConfigInfo->MaximumNumberOfTargets = 8;

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
        {
            PCONFIGURATION_COMPONENT Component;
            PCM_SCSI_DEVICE_DATA ScsiDeviceData;
            UCHAR Buffer[sizeof(CM_PARTIAL_RESOURCE_LIST) +
                         (sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * 5) +
                         sizeof(CM_SCSI_DEVICE_DATA)];
            PCM_PARTIAL_RESOURCE_LIST Descriptor = (PCM_PARTIAL_RESOURCE_LIST)&Buffer;
            ULONG Count;
            ULONG ScsiHostId;

            if (((Component = ArcGetComponent("scsi(0)")) != NULL) &&
                (Component->Class == AdapterClass) && (Component->Type == ScsiAdapter) &&
                (ArcGetConfigurationData((PVOID)Descriptor, Component) == ESUCCESS) &&
                ((Count = Descriptor->Count) < 6)) {

                ScsiDeviceData = (PCM_SCSI_DEVICE_DATA)&Descriptor->PartialDescriptors[Count];

                if (ScsiDeviceData->HostIdentifier > 7) {
                    ScsiHostId = 7;
                } else {
                    ScsiHostId = ScsiDeviceData->HostIdentifier;
                }
            } else {
                ScsiHostId = 7;
            }

            for (j = 0; j < 8; j++) {
                ConfigInfo->InitiatorBusId[j] = ScsiHostId;
            }
        }

#else

        for (j = 0; j < 8; j++) {
            ConfigInfo->InitiatorBusId[j] = ~0;
        }

#endif

#if defined(i386)
        switch (HwInitData->AdapterInterfaceType) {
            case Isa:
                if ((MachineType & 0xff) == MACHINE_TYPE_ISA) {
                    return(STATUS_SUCCESS);
                }
            case Eisa:
                if ((MachineType & 0xff) == MACHINE_TYPE_EISA) {
                    return(STATUS_SUCCESS);
                } else {
                    return(STATUS_DEVICE_DOES_NOT_EXIST);
                }
            case MicroChannel:
                if ((MachineType & 0xff) == MACHINE_TYPE_MCA) {
                    return(STATUS_SUCCESS);
                } else {
                    return(STATUS_DEVICE_DOES_NOT_EXIST);
                }
            case PCIBus:
                return(STATUS_SUCCESS);
            default:
                return(STATUS_DEVICE_DOES_NOT_EXIST);
        }
#elif defined(_MIPS_)
      if (HwInitData->AdapterInterfaceType != Internal) {
                return(STATUS_DEVICE_DOES_NOT_EXIST);
      }
#elif defined(_ALPHA_)
      if ( (HwInitData->AdapterInterfaceType != Internal) &&
           (HwInitData->AdapterInterfaceType != Eisa) &&
           (HwInitData->AdapterInterfaceType != PCIBus) &&
           (HwInitData->AdapterInterfaceType != Isa) ) {
          return(STATUS_DEVICE_DOES_NOT_EXIST);
      }
#elif defined(_PPC_)
      if ( (HwInitData->AdapterInterfaceType != Internal) &&
           (HwInitData->AdapterInterfaceType != Eisa) &&
           (HwInitData->AdapterInterfaceType != Isa) ) {
          return(STATUS_DEVICE_DOES_NOT_EXIST);
      }
#endif

        return(STATUS_SUCCESS);

    } else {

        return(STATUS_DEVICE_DOES_NOT_EXIST);
    }
}


NTSTATUS
SpGetCommonBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    ULONG NonCachedExtensionSize
    )
/*++

Routine Description:

    This routine determines the required size of the common buffer.  Allocates
    the common buffer and finally sets up the srb extension zone.  This routine
    expects that the adapter object has already been allocated.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension.

    NonCachedExtensionSize - Supplies the size of the noncached device
        extension for the mini-port driver.

Return Value:

    Returns the status of the allocate operation.

--*/

{
    PHYSICAL_ADDRESS pAddress;
    PVOID buffer;
    ULONG length;
    ULONG blockSize;

    //
    // Calculate the block size for the zone elements based on the Srb
    // Extension.
    //

    blockSize = DeviceExtension->SrbExtensionSize;

    //
    // Last three bits of blocksize must be zero.
    // Round blocksize up.
    //

    blockSize = (blockSize + 7) &  ~7;

    //
    // Same for the noncached extension size.
    //

    NonCachedExtensionSize += 7;
    NonCachedExtensionSize &= ~7;

    length = NonCachedExtensionSize + blockSize * MINIMUM_SRB_EXTENSIONS;

    //
    // Round the length up to a page size, since HalGetCommonBuffer allocates
    // in pages anyway.
    //

    length = (ULONG)ROUND_TO_PAGES(length);

    //
    // Allocate one page for noncached deviceextension
    // and srbextension zoned pool.
    //

    if (DeviceExtension->DmaAdapterObject == NULL) {

        //
        // Since there is no adapter just allocate from non-paged pool.
        //

        if (buffer = MmAllocateNonCachedMemory(length)) {
            DeviceExtension->PhysicalZoneBase = MmGetPhysicalAddress(buffer).LowPart;
        }

    } else {
#ifdef AXP_FIRMWARE
        buffer = HalAllocateCommonBuffer(DeviceExtension->DmaAdapterObject,
                                         length,
                                         &pAddress,
                                         FALSE );
        DeviceExtension->PhysicalZoneBase = pAddress.LowPart;
#else
        if (buffer = MmAllocateNonCachedMemory(length)) {
            DeviceExtension->PhysicalZoneBase = MmGetPhysicalAddress(buffer).LowPart;
        }
#endif
    }

    if (buffer == NULL) {
        return ENOMEM;
    }

    //
    // Truncate Physical address to 32 bits.
    //
    // Determine length and starting address of zone.
    // If noncached device extension required then
    // subtract size from page leaving rest for zone.
    //

    length -= NonCachedExtensionSize;

    DeviceExtension->NonCachedExtension = (PUCHAR)buffer + length;
    DeviceExtension->NonCachedExtensionSize = NonCachedExtensionSize;

    if (DeviceExtension->SrbExtensionSize) {

        //
        // Get block size.
        //

        blockSize = DeviceExtension->SrbExtensionSize;

        //
        // Record starting virtual address of zone.
        //

        DeviceExtension->SrbExtensionZonePool = buffer;
        DeviceExtension->SrbExtensionPointer = buffer;
        DeviceExtension->SrbExtensionSize = blockSize;


    } else {
        DeviceExtension->SrbExtensionZonePool = NULL;
    }

    return(ESUCCESS);
}

PVOID
ScsiPortGetUncachedExtension(
    IN PVOID HwDeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN ULONG NumberOfBytes
    )
/*++

Routine Description:

    This function allocates a common buffer to be used as the uncached device
    extension for the mini-port driver.  This function will also allocate any
    required SRB extensions.  The DmaAdapter is allocated if it has not been
    allocated previously.

Arguments:

    DeviceExtension - Supplies a pointer to the mini-ports device extension.

    ConfigInfo - Supplies a pointer to the partially initialized configuraiton
        information.  This is used to get an DMA adapter object.

    NumberOfBytes - Supplies the size of the extension which needs to be
        allocated

Return Value:

    A pointer to the uncached device extension or NULL if the extension could
    not be allocated or was previously allocated.

--*/

{
    DEVICE_DESCRIPTION deviceDescription;
    PDEVICE_EXTENSION deviceExtension =
        ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;
    NTSTATUS status;
    ULONG numberOfPageBreaks;

    //
    // Make sure that an common buffer  has not already been allocated.
    //

    if (deviceExtension->SrbExtensionZonePool != NULL) {
        return(NULL);
    }

    if ( deviceExtension->DmaAdapterObject == NULL ) {

        RtlZeroMemory( &deviceDescription, sizeof(DEVICE_DESCRIPTION) );

        deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
        deviceDescription.DmaChannel = ConfigInfo->DmaChannel;
        deviceDescription.InterfaceType = ConfigInfo->AdapterInterfaceType;
        deviceDescription.BusNumber = ConfigInfo->SystemIoBusNumber;
        deviceDescription.DmaWidth = ConfigInfo->DmaWidth;
        deviceDescription.DmaSpeed = ConfigInfo->DmaSpeed;
        deviceDescription.DmaPort = ConfigInfo->DmaPort;
        deviceDescription.Dma32BitAddresses = ConfigInfo->Dma32BitAddresses;
        deviceDescription.MaximumLength = ConfigInfo->MaximumTransferLength;
        deviceDescription.ScatterGather = ConfigInfo->ScatterGather;
        deviceDescription.Master = ConfigInfo->Master;
        deviceDescription.AutoInitialize = FALSE;
        deviceDescription.DemandMode = FALSE;

        if (ConfigInfo->MaximumTransferLength > 0x11000) {

            deviceDescription.MaximumLength = 0x11000;

        } else {

            deviceDescription.MaximumLength = ConfigInfo->MaximumTransferLength;

        }

        deviceExtension->DmaAdapterObject = HalGetAdapter(
            &deviceDescription,
            &numberOfPageBreaks
            );

        //
        // Set maximum number of page breaks.
        //

        if (numberOfPageBreaks > ConfigInfo->NumberOfPhysicalBreaks) {
            deviceExtension->Capabilities.MaximumPhysicalPages =
                                        ConfigInfo->NumberOfPhysicalBreaks;
        } else {
            deviceExtension->Capabilities.MaximumPhysicalPages =
                                        numberOfPageBreaks;
        }

    }

    //
    // Allocate the common buffer.
    //

    status = SpGetCommonBuffer( deviceExtension, NumberOfBytes);

    if (status != ESUCCESS) {
        return(NULL);
    }

    return(deviceExtension->NonCachedExtension);
}

ULONG
ScsiPortGetBusData(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the bus data for an adapter slot or CMOS address.

Arguments:

    BusDataType - Supplies the type of bus.

    BusNumber - Indicates which bus.

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/

{
    ULONG DataLength = 0;

    PDEVICE_EXTENSION deviceExtension =
        (PDEVICE_EXTENSION) DeviceExtension - 1;

    //
    // If the length is non-zero, the the requested data.
    //

    if (Length != 0) {

        ULONG ret;

        ret = HalGetBusData( BusDataType,
                             SystemIoBusNumber,
                             SlotNumber,
                             Buffer,
                             Length
                             );
        return ret;
    }

    //
    // Free any previously allocated data.
    //

    if (deviceExtension->MapRegisterBase != NULL) {
        ExFreePool(deviceExtension->MapRegisterBase);
    }

    if (BusDataType == EisaConfiguration) {

#if 0
        //
        // Deteremine the length to allocate based on the number of functions
        // for the slot.
        //

        Length = HalGetBusData( BusDataType,
                               SystemIoBusNumber,
                               SlotNumber,
                               &slotInformation,
                               sizeof(CM_EISA_SLOT_INFORMATION));


        if (Length < sizeof(CM_EISA_SLOT_INFORMATION)) {

            //
            // The data is messed up since this should never occur
            //

            DebugPrint((1, "ScsiPortGetBusData: Slot information not returned. Length = %d\n", Length));
            return(0);
        }

        //
        // Calculate the required length based on the number of functions.
        //

        Length = sizeof(CM_EISA_SLOT_INFORMATION) +
            (sizeof(CM_EISA_FUNCTION_INFORMATION) * slotInformation.NumberFunctions);

#else

        //
        // Since the loader does not really support freeing data and the EISA
        // configuration data can be very large.  Hal get bus data has be changed
        // to accept a length of zero for EIAS configuration data.
        //

        DataLength = HalGetBusData( BusDataType,
                                    SystemIoBusNumber,
                                    SlotNumber,
                                    Buffer,
                                    Length
                                    );

        DebugPrint((1, "ScsiPortGetBusData: Returning data. Length = %d\n", DataLength));
        return(DataLength);
#endif

    } else {

        Length = PAGE_SIZE;
    }

    deviceExtension->MapRegisterBase = ExAllocatePool(NonPagedPool, Length);

    if (deviceExtension->MapRegisterBase == NULL) {
        DebugPrint((1, "ScsiPortGetBusData: Memory allocation failed. Length = %d\n", Length));
        return(0);
    }

    //
    // Return the pointer to the mini-port driver.
    //

    *((PVOID *)Buffer) = deviceExtension->MapRegisterBase;

    DataLength = HalGetBusData( BusDataType,
                                SystemIoBusNumber,
                                SlotNumber,
                                deviceExtension->MapRegisterBase,
                                Length
                                );

    return(DataLength);
}

PSCSI_REQUEST_BLOCK
ScsiPortGetSrb(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LONG QueueTag
    )

/*++

Routine Description:

    This routine retrieves an active SRB for a particuliar logical unit.

Arguments:

    HwDeviceExtension
    PathId, TargetId, Lun - identify logical unit on SCSI bus.
    QueueTag - -1 indicates request is not tagged.

Return Value:

    SRB, if one exists. Otherwise, NULL.

--*/

{
    PDEVICE_EXTENSION deviceExtension =
        ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;
    PLOGICAL_UNIT_EXTENSION luExtension;
    PIRP irp;
    PIO_STACK_LOCATION irpstack;


    luExtension = GetLogicalUnitExtension(deviceExtension, TargetId);


    if (luExtension == NULL) {
        return(NULL);
    }

    irp = luExtension->CurrentRequest;
    irpstack = IoGetCurrentIrpStackLocation(irp);
    return ((PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1);

} // end ScsiPortGetSrb()

BOOLEAN
ScsiPortValidateRange(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN SCSI_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    )

/*++

Routine Description:

    This routine should take an IO range and make sure that it is not already
    in use by another adapter. This allows miniport drivers to probe IO where
    an adapter could be, without worrying about messing up another card.

Arguments:

    HwDeviceExtension - Used to find scsi managers internal structures
    BusType - EISA, PCI, PC/MCIA, MCA, ISA, what?
    SystemIoBusNumber - Which system bus?
    IoAddress - Start of range
    NumberOfBytes - Length of range
    InIoSpace - Is range in IO space?

Return Value:

    TRUE if range not claimed by another driver.

--*/

{
    PDEVICE_EXTENSION deviceExtension =
        ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;

        //
        // This is not implemented in NT.
        //

        return TRUE;
}

VOID
ScsiPortReadPortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_UCHAR(Port, Buffer, Count);

}

VOID
ScsiPortReadPortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_USHORT(Port, Buffer, Count);

}

VOID
ScsiPortReadPortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_ULONG(Port, Buffer, Count);

}

VOID
ScsiPortWritePortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_UCHAR(Port, Buffer, Count);

}

VOID
ScsiPortWritePortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_USHORT(Port, Buffer, Count);

}

VOID
ScsiPortWritePortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_ULONG(Port, Buffer, Count);

}

VOID
ScsiPortQuerySystemTime(
    OUT PLARGE_INTEGER Port
    )

/*++

Routine Description:

    Return a dummy system time to caller.  This routine is present only to
    satisfy scsi miniport drivers that require the export.

Arguments:

    CurrentTime - Supplies a pointer to a data buffer into which
                  to copy the system time.

Return Value:

    None

--*/

{

    Port->QuadPart = 0;

}


BOOLEAN
GetPciConfiguration(
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PPORT_CONFIGURATION_INFORMATION ConfigInformation,
    ULONG NumberOfAccessRanges,
    PVOID RegistryPath,
    BOOLEAN IsMultiFunction,
    PULONG BusNumber,
    PULONG SlotNumber,
    PULONG FunctionNumber
    )

/*++

Routine Description:

    Uses the Bus/Slot/Function numbers provided and gets slot information for 
    the device and register with hal for the resources.

Arguments:

    DriverObject - Miniport driver object.
    DeviceObject - Represents this adapter.
    ConfigInformation - Template for configuration information passed to a
                        miniport driver via the FindAdapter routine.
    NumberOfAccessRanges - from the HwInitializationData provided by the 
                           miniport
    RegistryPath - Service key path.
    IsMultiFunctionDevice - as returned by FindPciDevice.
    BusNumber - PCI Bus number provided by FindPciDevice.
    SlotNumber - Slot number provided by FindPciDevice.
    FunctionNumber - FunctionNumber provided by FindPciDevice.

Return Value:

    TRUE if card found. BusNumber and Slotnumber will return values that
    should be used to continue the search for additional cards, when a card
    is found.

--*/

{
    PCI_SLOT_NUMBER     slotData;
    PPCI_COMMON_CONFIG  pciData;
    PCI_COMMON_CONFIG   pciBuffer;
    ULONG               pciBus = *BusNumber;
    ULONG               slotNumber = *SlotNumber;
    ULONG               functionNumber = *FunctionNumber;
    ULONG               i;
    ULONG               length;
    ULONG               rangeNumber = 0;
    PACCESS_RANGE       accessRange;
    BOOLEAN             moreSlots = TRUE;
    ULONG               status;
    PCM_RESOURCE_LIST   resourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resourceDescriptor;
    UNICODE_STRING      unicodeString;
    UCHAR               vendorString[5];
    UCHAR               deviceString[5];

    pciData = &pciBuffer;

    //
    //
    // typedef struct _PCI_SLOT_NUMBER {
    //     union {
    //         struct {
    //             ULONG   DeviceNumber:5;
    //             ULONG   FunctionNumber:3;
    //             ULONG   Reserved:24;
    //         } bits;
    //         ULONG   AsULONG;
    //     } u;
    // } PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;
    //

    slotData.u.AsULONG = 0;

    //
    // Search each PCI bus.
    //

    //
    // Look at each device.
    //

    slotData.u.bits.DeviceNumber = slotNumber;
    slotData.u.bits.FunctionNumber = functionNumber;

    //
    // Look at each function.
    //

    length = HalGetBusDataByOffset(
                PCIConfiguration,
                pciBus,
                slotData.u.AsULONG,
                pciData,
                0,
                FIELD_OFFSET(PCI_COMMON_CONFIG, DeviceSpecific));

    ASSERT(length != 0);
    ASSERT(pciData->VendorID != PCI_INVALID_VENDORID);

    //
    // Translate hex ids to strings.
    //

    sprintf(vendorString, "%04x", pciData->VendorID);
    sprintf(deviceString, "%04x", pciData->DeviceID);

    DebugPrint((1,
               "GetPciConfiguration: Bus %x Slot %x Function %x Vendor %s Product %s %s\n",
               pciBus,
               slotNumber,
               functionNumber,
               vendorString,
               deviceString,
               (IsMultiFunction ? "MF" : "")));

    //
    // This is the miniport drivers slot. Allocate the
    // resources.
    //

    RtlInitUnicodeString(&unicodeString, L"ScsiAdapter");

    status = HalAssignSlotResources(RegistryPath,
                                    &unicodeString,
                                    DriverObject,
                                    DeviceObject,
                                    PCIBus,
                                    pciBus,
                                    slotData.u.AsULONG,
                                    &resourceList);

    if(!NT_SUCCESS(status)) {
        DebugPrint((0, "GetPciConfiguration: HalAssignSlotResources failed with %x\n", status));
        return FALSE;
    }

    //
    // Walk resource list to update configuration information.
    //

    for (i = 0;
         i < resourceList->List->PartialResourceList.Count;
         i++) {

       //
       // Get resource descriptor.
       //

       resourceDescriptor =
           &resourceList->List->PartialResourceList.PartialDescriptors[i];

       //
       // Check for interrupt descriptor.
       //

       if (resourceDescriptor->Type == CmResourceTypeInterrupt) {
           ConfigInformation->BusInterruptLevel =
               resourceDescriptor->u.Interrupt.Level;
           ConfigInformation->BusInterruptVector =
               resourceDescriptor->u.Interrupt.Vector;

           //
           // Check interrupt mode.
           //

           if ((resourceDescriptor->Flags ==
               CM_RESOURCE_INTERRUPT_LATCHED)) {
               ConfigInformation->InterruptMode = Latched;
           } else if (resourceDescriptor->Flags ==
                      CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {
               ConfigInformation->InterruptMode = LevelSensitive;
           }
       }

       //
       // Check for port descriptor.
       //

       if (resourceDescriptor->Type == CmResourceTypePort) {

          //
          // Verify range count does not exceed what the
          // miniport indicated.
          //

          if (NumberOfAccessRanges > rangeNumber) {

              //
              // Get next access range.
              //

              accessRange =
                  &((*(ConfigInformation->AccessRanges))[rangeNumber]);

              accessRange->RangeStart =
                  resourceDescriptor->u.Port.Start;
              accessRange->RangeLength =
                  resourceDescriptor->u.Port.Length;

              accessRange->RangeInMemory = FALSE;
              rangeNumber++;
          }
       }

       //
       // Check for memory descriptor.
       //

       if (resourceDescriptor->Type == CmResourceTypeMemory) {

          //
          // Verify range count does not exceed what the
          // miniport indicated.
          //

          if (NumberOfAccessRanges > rangeNumber) {

              //
              // Get next access range.
              //

              accessRange =
                  &((*(ConfigInformation->AccessRanges))[rangeNumber]);

              accessRange->RangeStart =
                  resourceDescriptor->u.Memory.Start;
              accessRange->RangeLength =
                  resourceDescriptor->u.Memory.Length;

              accessRange->RangeInMemory = TRUE;
              rangeNumber++;
          }
       }

       //
       // Check for DMA descriptor.
       //

       if (resourceDescriptor->Type == CmResourceTypeDma) {
          ConfigInformation->DmaChannel =
              resourceDescriptor->u.Dma.Channel;
          ConfigInformation->DmaPort =
              resourceDescriptor->u.Dma.Port;
       }

    } // next resource descriptor

    ExFreePool(resourceList);

    //
    // Update bus and slot numbers.
    //

    *BusNumber = pciBus;
    *SlotNumber = slotNumber;

    if(IsMultiFunction) {
        //
        // Save away the next function number to check.
        //

        *FunctionNumber = functionNumber + 1;
    } else {
        //
        // this isn't multifunction so make sure we loop around 
        // to the next one.
        //

        *FunctionNumber = PCI_MAX_FUNCTION;
    }

    ConfigInformation->SystemIoBusNumber = pciBus;
    ConfigInformation->SlotNumber = slotData.u.AsULONG;

    return TRUE;

} // GetPciConfiguration()


ULONG
ScsiPortSetBusDataByOffset(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns writes bus data to a specific offset within a slot.

Arguments:

    DeviceExtension - State information for a particular adapter.

    BusDataType - Supplies the type of bus.

    SystemIoBusNumber - Indicates which system IO bus.

    SlotNumber - Indicates which slot.

    Buffer - Supplies the data to write.

    Offset - Byte offset to begin the write.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Number of bytes written.

--*/

{
    return(HalSetBusDataByOffset(BusDataType,
                                 SystemIoBusNumber,
                                 SlotNumber,
                                 Buffer,
                                 Offset,
                                 Length));

} // end ScsiPortSetBusDataByOffset()


BOOLEAN
FindPciDevice(
    PHW_INITIALIZATION_DATA HwInitializationData,
    PULONG BusNumber,
    PULONG SlotNumber,
    PULONG FunctionNumber,
    PBOOLEAN IsMultiFunction
    )

/*++

Routine Description:

    Walk PCI slot information looking for Vendor and Product ID matches.

Arguments:

    HwInitializationData - Miniport description.
    BusNumber - Starting PCI bus for this search.
    SlotNumber - Starting slot number for this search.
    FunctionNumber - Starting function number for this search.

Return Value:

    TRUE if card found.

    Bus, Slot and Function number will contain the address of the adapter 
    found once this routine completes.  These values should be provided to 
    GetPciConfiguration.

--*/

{
    PCI_SLOT_NUMBER     slotData;
    PPCI_COMMON_CONFIG  pciData;
    PCI_COMMON_CONFIG   pciBuffer;
    ULONG               pciBus;
    ULONG               slotNumber;
    ULONG               functionNumber;
    ULONG               i;
    ULONG               length;
    BOOLEAN             moreSlots = TRUE;
    ULONG               status;
    UCHAR               vendorString[5];
    UCHAR               deviceString[5];

    pciData = &pciBuffer;

    //
    //
    // typedef struct _PCI_SLOT_NUMBER {
    //     union {
    //         struct {
    //             ULONG   DeviceNumber:5;
    //             ULONG   FunctionNumber:3;
    //             ULONG   Reserved:24;
    //         } bits;
    //         ULONG   AsULONG;
    //     } u;
    // } PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;
    //

    slotData.u.AsULONG = 0;

    //
    // Search each PCI bus.
    //

    for (pciBus = *BusNumber; moreSlots && pciBus < 256; pciBus++) {

        //
        // Look at each device.
        //

        for (slotNumber = *SlotNumber;
             moreSlots  &&  slotNumber < PCI_MAX_DEVICES;
             slotNumber++) {

            slotData.u.bits.DeviceNumber = slotNumber;
            *IsMultiFunction = FALSE;

            //
            // Look at each function.
            //

            for (functionNumber = *FunctionNumber;
                moreSlots  &&  functionNumber < PCI_MAX_FUNCTION;
                functionNumber++) {

                slotData.u.bits.FunctionNumber = functionNumber;

                length = HalGetBusDataByOffset(
                            PCIConfiguration,
                            pciBus,
                            slotData.u.AsULONG,
                            pciData,
                            0,
                            FIELD_OFFSET(PCI_COMMON_CONFIG, DeviceSpecific));

                if (length == 0) {

                    //
                    // Out of PCI buses, all done.
                    //

                    moreSlots = FALSE;
                    break;
                }

                if (pciData->VendorID == PCI_INVALID_VENDORID) {
                    if(*IsMultiFunction) {
                        //
                        // Of course function numbers may be sparse - keep 
                        // checking anyway.
                        //
                        continue;
                    } else {
                        //
                        // But since this isn't a multifunction card there's
                        // nothing else to check in this slot.  Or if the 
                        // function is zero then it's not MF.
                        //
                        break;
                    }
                }

                if((slotData.u.bits.FunctionNumber == 0) &&
                   PCI_MULTIFUNCTION_DEVICE(pciData)) {
                    *IsMultiFunction = TRUE;
                }
                    
                //
                // Translate hex ids to strings.
                //

                sprintf(vendorString, "%04x", pciData->VendorID);
                sprintf(deviceString, "%04x", pciData->DeviceID);

                DebugPrint((1,
                           "FindPciDevice: Bus %x Slot %x Function %x Vendor %s Product %s %s\n",
                           pciBus,
                           slotNumber,
                           functionNumber,
                           vendorString,
                           deviceString,
                           (*IsMultiFunction ? "MF" : "")));

                //
                // Compare strings.
                //

                if (_strnicmp(vendorString,
                            HwInitializationData->VendorId,
                            HwInitializationData->VendorIdLength) ||
                    _strnicmp(deviceString,
                            HwInitializationData->DeviceId,
                            HwInitializationData->DeviceIdLength)) {

                    //
                    // Not our PCI device. Try next device/function
                    //

                    if(*IsMultiFunction) {
                        // check next function.
                        continue;
                    } else {
                        // check next slot.
                        break;
                    }
                }

                *BusNumber = pciBus;
                *SlotNumber = slotNumber;
                *FunctionNumber = functionNumber;

                return TRUE;

            }   // next PCI function

            *FunctionNumber = 0;

        }   // next PCI slot

        *SlotNumber = 0;

    }   // next PCI bus

    return FALSE;

} // GetPciConfiguration()



VOID
SpGetSupportedAdapterControlFunctions(
    PDEVICE_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine will query the miniport to determine which adapter control 
    types are supported for the specified adapter.  The 
    SupportedAdapterControlBitmap in the adapter extension will be updated with
    the data returned by the miniport.  These flags are used to determine 
    what functionality (for power management and such) the miniport will support
    
Arguments:    

    Adapter - the adapter to query
    
Return Value:

    none
    
--*/        

{
    UCHAR buffer[sizeof(SCSI_SUPPORTED_CONTROL_TYPE_LIST) + 
                 (sizeof(BOOLEAN) * (ScsiAdapterControlMax + 1))];

    PSCSI_SUPPORTED_CONTROL_TYPE_LIST typeList = 
        (PSCSI_SUPPORTED_CONTROL_TYPE_LIST) &buffer;

    SCSI_ADAPTER_CONTROL_STATUS status;

    if(Adapter->HwAdapterControl == NULL) {

        //
        // Adapter control is not supported by the miniport or the miniport 
        // isn't pnp (in which case it's not supported by scsiport) - the 
        // supported array has already been cleared so we can just quit now.
        //
        return;
    }

    RtlZeroMemory(typeList, (sizeof(SCSI_SUPPORTED_CONTROL_TYPE_LIST) + 
                             sizeof(BOOLEAN) * (ScsiAdapterControlMax + 1)));

    typeList->MaxControlType = ScsiAdapterControlMax;

#if DBG
    typeList->SupportedTypeList[ScsiAdapterControlMax] = 0x63;
#endif

    status = SpCallAdapterControl(Adapter,
                                  ScsiQuerySupportedControlTypes,
                                  typeList);

    if(status == ScsiAdapterControlSuccess) {
        ULONG i;

        Adapter->HasShutdown = typeList->SupportedTypeList[ScsiStopAdapter];
        Adapter->HasSetBoot = typeList->SupportedTypeList[ScsiSetBootConfig];
    }
    return;
}

SCSI_ADAPTER_CONTROL_STATUS 
SpCallAdapterControl(
    IN PDEVICE_EXTENSION Adapter,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )
{
    DebugPrint((2, "SpCallAdapterControl: Calling adapter control %x for adapter %#08lx with param %#08lx\n", ControlType, Adapter, Parameters));
    return Adapter->HwAdapterControl(
                Adapter->HwDeviceExtension,
                ControlType,
                Parameters);
}


VOID
SpUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    ULONG i;

    for(i = 0; i < MAXIMUM_NUMBER_OF_SCSIPORT_OBJECTS; i++) {
        PDEVICE_OBJECT deviceObject;

        deviceObject = ScsiPortDeviceObject[i];
        
        if(deviceObject != NULL) {

            PDEVICE_EXTENSION deviceExtension;

            deviceExtension = deviceObject->DeviceExtension;

            if(deviceExtension->HasShutdown) {
                SpCallAdapterControl(deviceExtension, ScsiStopAdapter, NULL);

                if(deviceExtension->HasSetBoot) {
                    SpCallAdapterControl(deviceExtension,
                                         ScsiSetBootConfig,
                                         NULL);
                }
            }
        }
        
        //
        // Now that we've shut this one down we can't use it anymore.
        // Since the memory will be reclaimed by the OS we can just throw it 
        // away.
        //

        ScsiPortDeviceObject[i] = NULL;
    }
    return;
}
#endif /* DECSTATION */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\scsidisk.c ===
#if defined(JAZZ) || defined(i386) || defined(_ALPHA_) || defined(_IA64_)
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    scsidisk.c

Abstract:

    This module implements the hard disk boot driver for the Jazz system.

Author:

    Jeff Havens (jhavens) 8-12-1991

Environment:

    Kernel mode

Revision History:

    Vijay Jayaseelan (vijayj) 2-April-2000

        -   Add GPT support

--*/


#ifdef MIPS
#include "..\fw\mips\fwp.h"
#undef KeGetDcacheFillSize
#define KeGetDcacheFillSize() BlDcacheFillSize
#elif defined(_ALPHA_)
#include "..\fw\alpha\fwp.h"
#undef KeGetDcacheFillSize
#define KeGetDcacheFillSize() BlDcacheFillSize
#elif defined(_IA64_)
#include "bootia64.h"
#else
#include "bootx86.h"
#undef KeGetDcacheFillSize
#define KeGetDcacheFillSize() 4
#endif
#include "ntdddisk.h"
#include "scsi.h"
#include "scsiboot.h"
#include "stdio.h"
#include "string.h"

#if defined(SETUP) && i386
#include "spscsi.h"
#endif



//
// SCSI driver constants.
//

#define MAXIMUM_NUMBER_SECTORS 128      // maximum number of transfer sector
#define MAXIMUM_NUMBER_RETRIES 8        // maximum number of read/write retries
#define MAXIMUM_SECTOR_SIZE 2048        // define the maximum supported sector size
#define MODE_DATA_SIZE 192
#define HITACHI_MODE_DATA_SIZE 12

CHAR ScsiTempBuffer[MAXIMUM_SECTOR_SIZE + 128];

//
// Define device driver prototypes.
//

NTSTATUS
ScsiDiskBootPartitionOpen(
    IN ULONG   FileId,
    IN UCHAR   DeviceUnit,
    IN UCHAR   PartitionNumber
    );

NTSTATUS
ScsiGPTDiskBootPartitionOpen(
    IN ULONG   FileId,
    IN UCHAR   DeviceUnit,
    IN UCHAR   PartitionNumber
    );
    

ARC_STATUS
ScsiDiskClose (
    IN ULONG FileId
    );

ARC_STATUS
ScsiDiskMount (
    IN PCHAR MountPath,
    IN MOUNT_OPERATION Operation
    );

ARC_STATUS
ScsiDiskOpen (
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
ScsiDiskRead (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
ScsiDiskGetReadStatus (
    IN ULONG FileId
    );

ARC_STATUS
ScsiDiskSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
ScsiDiskWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
ScsiDiskGetFileInformation (
    IN ULONG FileId,
    OUT PFILE_INFORMATION Finfo
    );

NTSTATUS
ScsiDiskBootIO (
    IN PMDL MdlAddress,
    IN ULONG LogicalBlock,
    IN PPARTITION_CONTEXT PartitionContext,
    IN BOOLEAN Operation
    );

VOID
ScsiDiskBootSetup (
    VOID
    );

VOID
ScsiPortExecute(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ScsiDiskStartUnit(
    IN PPARTITION_CONTEXT PartitionContext
    );

VOID
ScsiDiskFilterBad(
    IN PPARTITION_CONTEXT PartitionContext
    );

ULONG
ClassModeSense(
    IN PPARTITION_CONTEXT Context,
    IN PCHAR ModeSenseBuffer,
    IN ULONG Length,
    IN UCHAR PageMode
    );

PVOID
ClassFindModePage(
    IN PCHAR ModeSenseBuffer,
    IN ULONG Length,
    IN UCHAR PageMode
    );
BOOLEAN
IsFloppyDevice(
    PPARTITION_CONTEXT Context
    );

BOOLEAN
CheckFileId(
    ULONG FileId
    );

VOID
ScsiPortInitializeMdlPages (
    IN OUT PMDL Mdl
    );


//
// Define static data.
//

BL_DEVICE_ENTRY_TABLE ScsiDiskEntryTable = {
    ScsiDiskClose,
    ScsiDiskMount,
    ScsiDiskOpen,
    ScsiDiskRead,
    ScsiDiskGetReadStatus,
    ScsiDiskSeek,
    ScsiDiskWrite,
    ScsiDiskGetFileInformation,
    (PARC_SET_FILE_INFO_ROUTINE)NULL
    };


//
// Global poiter for buffers.
//

PREAD_CAPACITY_DATA ReadCapacityBuffer;
PUCHAR SenseInfoBuffer;

#define SECTORS_IN_LOGICAL_VOLUME   0x20


ARC_STATUS
ScsiDiskGetFileInformation (
    IN ULONG FileId,
    OUT PFILE_INFORMATION Finfo
    )

/*++

Routine Description:

    This routine returns information on the scsi partition.

Arguments:

    FileId - Supplies the file table index.

    Finfo - Supplies a pointer to where the File Informatino is stored.

Return Value:

    ESUCCESS is returned.

--*/

{

    PPARTITION_CONTEXT Context;

    RtlZeroMemory(Finfo, sizeof(FILE_INFORMATION));

    Context = &BlFileTable[FileId].u.PartitionContext;

    Finfo->StartingAddress.QuadPart = Context->StartingSector;
    Finfo->StartingAddress.QuadPart <<= Context->SectorShift;

    Finfo->EndingAddress.QuadPart = Finfo->StartingAddress.QuadPart + Context->PartitionLength.QuadPart;

    Finfo->Type = DiskPeripheral;

    return ESUCCESS;
}


ARC_STATUS
ScsiDiskClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    This function closes the file table entry specified by the file id.

Arguments:

    FileId - Supplies the file table index.

Return Value:

    ESUCCESS is returned.

--*/

{

    BlFileTable[FileId].Flags.Open = 0;
    return ESUCCESS;
}

ARC_STATUS
ScsiDiskMount (
    IN PCHAR MountPath,
    IN MOUNT_OPERATION Operation
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    return ESUCCESS;
}


#ifdef EFI_PARTITION_SUPPORT

#define STR_PREFIX      
#define DBG_PRINT(x)    

/*
#if defined(_IA64_)

#define STR_PREFIX      L
#define DBG_PRINT(x)    DbgOut(x);

#else

#define STR_PREFIX      

#define DBG_PRINT(x)    \
{\
    BlPrint(x); \
    while (!BlGetKey()); \
}    

#endif  // _IA64_
*/

#endif

ARC_STATUS
ScsiDiskOpen (
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    This routine fills in the file table entry.  In particular the Scsi address
    of the device is determined from the name.  The block size of device is
    queried from the target controller, and the partition information is read
    from the device.

Arguments:

    OpenPath - Supplies the name of the device being opened.

    OpenMode - Unused.

    FileId - Supplies the index to the file table entry to be initialized.

Return Value:

    Retruns the arc status of the operation.

--*/

{
    ULONG Partition;
    ULONG Id;
    BOOLEAN IsCdRom;
    BOOLEAN IsFloppy;
    PPARTITION_CONTEXT Context;

    Context = &BlFileTable[*FileId].u.PartitionContext;

    //
    // Determine the scsi port device object.
    //
    if (FwGetPathMnemonicKey(OpenPath, "signature", &Id)) {
        if (FwGetPathMnemonicKey(OpenPath, "scsi", &Id)) {
            return ENODEV;
        }
    } else {
        PCHAR  DiskStart = strstr(OpenPath, ")disk");

        if (DiskStart) {
            DiskStart++;
            strcpy(OpenPath, "scsi(0)");
            strcat(OpenPath, DiskStart);
        }            
            
        Id = 0; // only the first SCSI card is supported        
    }        

    if (ScsiPortDeviceObject[Id] == NULL) {
        return ENODEV;
    }

    Context->PortDeviceObject = ScsiPortDeviceObject[Id];

    //
    // Get the logical unit, path Id and target id from the name.
    // NOTE: FwGetPathMnemonicKey returns 0 for success.
    //

    if (FwGetPathMnemonicKey(OpenPath, "rdisk", &Id)) {
        if (FwGetPathMnemonicKey(OpenPath, "fdisk", &Id)) {
            return ENODEV;
        } else {
            IsFloppy = TRUE;
        }
    } else {
        IsFloppy = FALSE;
    }

    //
    // Booting is only allowed on LUN 0 since the scsibus
    // scan in the loader only searches for LUN 0.
    //

    if (Id != 0) {
        return ENODEV;
    }

    Context->DiskId = (UCHAR)Id;

    if (!FwGetPathMnemonicKey(OpenPath, "cdrom", &Id)) {
        IsCdRom = TRUE;
    } else if (!FwGetPathMnemonicKey(OpenPath, "disk", &Id)) {
        IsCdRom = FALSE;
    } else {
        return ENODEV;
    }

    SCSI_DECODE_BUS_TARGET( Id, Context->PathId, Context->TargetId );

    //
    // Initialize any bad devices.
    //

    ScsiDiskFilterBad(Context);

    //
    // Read the capacity of the disk to determine the block size.
    //

    if (ReadDriveCapacity(Context)) {
        return ENODEV;
    }

    //
    // This is all that needs to be done for floppies and harddisks.
    //

    if (IsCdRom || IsFloppy) {
        return(ESUCCESS);
    }

    if (FwGetPathMnemonicKey(OpenPath,
                             "partition",
                             &Partition
                             )) {
        return ENODEV;
    }

    if (Partition != 0) {
        //
        // First try to open the MBR partition
        //
        DBG_PRINT(STR_PREFIX"Trying to open SCSI MBR partition\r\n");
        
        if (ScsiDiskBootPartitionOpen(*FileId,0,(UCHAR)Partition) != STATUS_SUCCESS) {

#ifdef EFI_PARTITION_SUPPORT
            //
            // Since we failed with MBR open now try GPT partition
            //
            DBG_PRINT(STR_PREFIX"Trying to open SCSI GPT partition\r\n");
            
            if (ScsiGPTDiskBootPartitionOpen(*FileId,0,(UCHAR)(Partition -1)) != STATUS_SUCCESS) {
                return ENODEV;
            }
#else

            return ENODEV;
            
#endif // EFI_PARTITION_SUPPORT            
        }
    }

    DBG_PRINT(STR_PREFIX"Opened the SCSI partition successfully\r\n");
    
    //
    // Initialize partition table
    //
    return ESUCCESS;
}

ARC_STATUS
ScsiDiskRead (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    This function reads data from the hard disk starting at the position
    specified in the file table.


Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a poiner to the buffer that receives the data
        read.

    Length - Supplies the number of bytes to be read.

    Count - Supplies a pointer to a variable that receives the number of
        bytes actually read.

Return Value:

    The read operation is performed and the read completion status is
    returned.

--*/


{

    ARC_STATUS ArcStatus;
    ULONG Index;
    ULONG Limit;
    PMDL MdlAddress;
    UCHAR MdlBuffer[sizeof(MDL) + ((64 / 4) + 1) * sizeof(ULONG)];
    NTSTATUS NtStatus;
    ULONG NumberOfPages;
    ULONG Offset;
    LARGE_INTEGER Position;
    LARGE_INTEGER LogicalBlock;
    PCHAR TempPointer;
    PIO_SCSI_CAPABILITIES PortCapabilities;
    ULONG adapterLimit;
    ULONG alignmentMask;
    ULONG SectorSize;
    ULONG TransferCount;
    ULONG BytesToTransfer;

    //
    // If the requested size of the transfer is zero return ESUCCESS
    //
    if (Length==0) {
        return ESUCCESS;
    }

    if (!CheckFileId(FileId)) {
        return(ENODEV);
    }

    //
    // Compute a Dcache aligned pointer into the temporary buffer.
    //

    TempPointer =  (PVOID)((ULONG_PTR)(ScsiTempBuffer +
        KeGetDcacheFillSize() - 1) & ~((LONG)KeGetDcacheFillSize() - 1));


    //
    // Calculate the actual sector size.
    //

    SectorSize = 1 << BlFileTable[FileId].u.PartitionContext.SectorShift;

    ArcStatus = GetAdapterCapabilities(
        BlFileTable[FileId].u.PartitionContext.PortDeviceObject,
        &PortCapabilities
        );

    if (ArcStatus != ESUCCESS) {

        adapterLimit = 0x10000;
        alignmentMask = KeGetDcacheFillSize();

    } else {

        if (PortCapabilities->MaximumTransferLength < 0x1000 ||
            PortCapabilities->MaximumTransferLength > 0x10000) {

            adapterLimit = 0x10000;

        } else {

            adapterLimit = PortCapabilities->MaximumTransferLength;

        }

        alignmentMask = PortCapabilities->AlignmentMask;
    }

    //
    // If the current position is not at a sector boundary or if the data
    // buffer is not properly aligned, then read the first sector separately
    // and copy the data.
    //

    Offset = BlFileTable[FileId].Position.LowPart & (SectorSize - 1);
    *Count = 0;
    while (Offset != 0 || (ULONG_PTR) Buffer & alignmentMask) {

        Position = BlFileTable[FileId].Position;
        BlFileTable[FileId].Position.QuadPart = Position.QuadPart - Offset;

        ArcStatus = ScsiDiskRead(FileId, TempPointer, SectorSize, &TransferCount);
        if (ArcStatus != ESUCCESS) {
            BlFileTable[FileId].Position = Position;
            return ArcStatus;
        }

        //
        // Copy the data to the specified buffer.
        //

        if ((SectorSize - Offset) > Length) {
            Limit = Offset + Length;

        } else {
            Limit = SectorSize;
        }

        for (Index = Offset; Index < Limit; Index += 1) {
            ((PCHAR)Buffer)[Index - Offset] = TempPointer[Index];
        }

        //
        // Update transfer parameters.
        //

        *Count += Limit - Offset;
        Length -= Limit - Offset;
        Buffer = (PVOID)((PCHAR)Buffer + Limit - Offset);
        BlFileTable[FileId].Position.QuadPart = Position.QuadPart + (Limit - Offset);

        Offset = BlFileTable[FileId].Position.LowPart & (SectorSize - 1);

        if (Length == 0) {
            break;
        }

    }

    //
    // The position is aligned on a sector boundary. Read as many sectors
    // as possible in a contiguous run in 64Kb chunks.
    //

    BytesToTransfer = Length & (~(SectorSize - 1));
    while (BytesToTransfer != 0) {

        //
        // The scsi controller doesn't support transfers bigger than 64Kb.
        // Transfer the maximum number of bytes possible.
        //

        Limit = (BytesToTransfer > adapterLimit ? adapterLimit : BytesToTransfer);

        //
        // Build the memory descriptor list.
        //


        MdlAddress = (PMDL)&MdlBuffer[0];
        MdlAddress->Next = NULL;
        MdlAddress->Size = (CSHORT)(sizeof(MDL) +
                  ADDRESS_AND_SIZE_TO_SPAN_PAGES(Buffer, Limit) * sizeof(ULONG));
        MdlAddress->MdlFlags = 0;
        MdlAddress->StartVa = (PVOID)PAGE_ALIGN(Buffer);
        MdlAddress->ByteCount = Limit;
        MdlAddress->ByteOffset = BYTE_OFFSET(Buffer);
        ScsiPortInitializeMdlPages (MdlAddress);

        //
        // Flush I/O buffers and read from the boot device.
        //

        KeFlushIoBuffers(MdlAddress, TRUE, TRUE);
        LogicalBlock.QuadPart = BlFileTable[FileId].Position.QuadPart >>
                                    BlFileTable[FileId].u.PartitionContext.SectorShift;
        LogicalBlock.LowPart += BlFileTable[FileId].u.PartitionContext.StartingSector;
        NtStatus = ScsiDiskBootIO(MdlAddress,
            LogicalBlock.LowPart,
            &BlFileTable[FileId].u.PartitionContext,
            TRUE);

        if (NtStatus != ESUCCESS) {
            return EIO;
        }

        *Count += Limit;
        Length -= Limit;
        Buffer = (PVOID)((PCHAR)Buffer + Limit);
        BytesToTransfer -= Limit;
        BlFileTable[FileId].Position.QuadPart = BlFileTable[FileId].Position.QuadPart + Limit;
    }

    //
    // If there is any residual data to read, then read the last sector
    // separately and copy the data.
    //

    if (Length != 0) {
        Position = BlFileTable[FileId].Position;
        ArcStatus = ScsiDiskRead(FileId, TempPointer, SectorSize, &TransferCount);
        if (ArcStatus != ESUCCESS) {
            BlFileTable[FileId].Position = Position;
            return ArcStatus;
        }

        //
        // Copy the data to the specified buffer.
        //
        RtlCopyMemory(Buffer,TempPointer,Length);

        //
        // Update transfer parameters.
        //

        *Count += Length;
        BlFileTable[FileId].Position.QuadPart = Position.QuadPart + Length;
    }

    return ESUCCESS;

}

ARC_STATUS
ScsiDiskGetReadStatus (
    IN ULONG FileId
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    return ESUCCESS;
}

ARC_STATUS
ScsiDiskSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    This function sets the device position to the specified offset for
    the specified file id.

Arguments:

    FileId - Supplies the file table index.

    Offset - Supplies to new device position.

    SeekMode - Supplies the mode for the position.

Return Value:

    ESUCCESS is returned.

--*/

{

    //
    // Set the current device position as specifed by the seek mode.
    //

    if (SeekMode == SeekAbsolute) {
        BlFileTable[FileId].Position = *Offset;

    } else if (SeekMode == SeekRelative) {
        BlFileTable[FileId].Position.QuadPart = BlFileTable[FileId].Position.QuadPart + Offset->QuadPart;
    }

    return ESUCCESS;
}

ARC_STATUS
ScsiDiskWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    This function writes data to the hard disk starting at the position
    specified in the file table.


Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a poiner to the buffer that contains the write data.

    Length - Supplies the number of bytes to be written.

    Count - Supplies a pointer to a variable that receives the number of
        bytes actually written.

Return Value:

    The write operation is performed and the write completion status is
    returned.

--*/

{

    ARC_STATUS ArcStatus;
    ULONG Index;
    ULONG Limit;
    PMDL MdlAddress;
    UCHAR MdlBuffer[sizeof(MDL) + ((64 / 4) + 1) * sizeof(ULONG)];
    NTSTATUS NtStatus;
    ULONG Offset;
    LARGE_INTEGER Position;
    LARGE_INTEGER WritePosition;
    LARGE_INTEGER LogicalBlock;
    CHAR TempBuffer[MAXIMUM_SECTOR_SIZE + 128];
    PIO_SCSI_CAPABILITIES PortCapabilities;
    ULONG adapterLimit;
    PCHAR TempPointer;
    ULONG SectorSize;
    ULONG TransferCount;
    ULONG BytesToTransfer;
    ULONG alignmentMask;
    //
    // If the requested size of the transfer is zero return ESUCCESS
    //

    if (Length==0) {
        return ESUCCESS;
    }

    if (!CheckFileId(FileId)) {
        return(ENODEV);
    }

    //
    // Compute a Dcache aligned pointer into the temporary buffer.
    //

    TempPointer =  (PVOID)((ULONG_PTR)(TempBuffer +
                        KeGetDcacheFillSize() - 1) & ~((LONG)KeGetDcacheFillSize() - 1));


    //
    // Calculate the actual sector size.
    //

    SectorSize = 1 << BlFileTable[FileId].u.PartitionContext.SectorShift;

    ArcStatus = GetAdapterCapabilities(
        BlFileTable[FileId].u.PartitionContext.PortDeviceObject,
        &PortCapabilities
        );

    if (ArcStatus != ESUCCESS) {

        adapterLimit = 0x10000;
        alignmentMask = KeGetDcacheFillSize();

    } else {

        if (PortCapabilities->MaximumTransferLength < 0x1000 ||
            PortCapabilities->MaximumTransferLength > 0x10000) {

            adapterLimit = 0x10000;

        } else {

            adapterLimit = PortCapabilities->MaximumTransferLength;

        }

        alignmentMask = PortCapabilities->AlignmentMask;
    }

    //
    // If the current position is not at a sector boundary or if the data
    // buffer is not properly aligned, then read the first sector separately
    // and copy the data.
    //

    Offset = BlFileTable[FileId].Position.LowPart & (SectorSize - 1);
    *Count = 0;
    while (Offset != 0 || (ULONG_PTR) Buffer & alignmentMask) {

        Position = BlFileTable[FileId].Position;
        BlFileTable[FileId].Position.QuadPart = Position.QuadPart - Offset;
        WritePosition = BlFileTable[FileId].Position;
        ArcStatus = ScsiDiskRead(FileId, TempPointer, SectorSize, &TransferCount);
        if (ArcStatus != ESUCCESS) {
            BlFileTable[FileId].Position = Position;
            return ArcStatus;
        }
        //
        // Reset the position as it was before the read.
        //

        BlFileTable[FileId].Position = WritePosition;

        //
        // If the length of write is less than the number of bytes from
        // the offset to the end of the sector, then copy only the number
        // of bytes required to fulfil the request. Otherwise copy to the end
        // of the sector and, read the remaining data.
        //

        if ((SectorSize - Offset) > Length) {
            Limit = Offset + Length;

        } else {
            Limit = SectorSize;
        }

        //
        // Merge the data from the specified buffer.
        //
        for (Index = Offset; Index < Limit; Index += 1) {
            TempPointer[Index] = ((PCHAR)Buffer)[Index-Offset];
        }

        //
        // Write the modified sector.
        //
        ArcStatus = ScsiDiskWrite(FileId, TempPointer, SectorSize, &TransferCount);

        if (ArcStatus != ESUCCESS) {
            return ArcStatus;
        }

        //
        // Update transfer parameters.
        //

        *Count += Limit - Offset;
        Length -= Limit - Offset;
        Buffer = (PVOID)((PCHAR)Buffer + Limit - Offset);
        BlFileTable[FileId].Position.QuadPart = Position.QuadPart + (Limit - Offset);

        Offset = BlFileTable[FileId].Position.LowPart & (SectorSize - 1);

        if (Length == 0) {
            break;
        }
    }


    //
    // The position is aligned on a sector boundary. Write as many sectors
    // as possible in a contiguous run.
    //

    BytesToTransfer = Length & (~(SectorSize - 1));
    while (BytesToTransfer != 0) {

        //
        // The scsi controller doesn't support transfers bigger than 64Kb.
        // Transfer the maximum number of bytes possible.
        //
        Limit = (BytesToTransfer > adapterLimit ? adapterLimit : BytesToTransfer);

        //
        // Build the memory descriptor list.
        //

        MdlAddress = (PMDL)&MdlBuffer[0];
        MdlAddress->Next = NULL;
        MdlAddress->Size = (CSHORT)(sizeof(MDL) +
                  ADDRESS_AND_SIZE_TO_SPAN_PAGES(Buffer, Limit) * sizeof(ULONG));
        MdlAddress->MdlFlags = 0;
        MdlAddress->StartVa = (PVOID)PAGE_ALIGN(Buffer);
        MdlAddress->ByteCount = Limit;
        MdlAddress->ByteOffset = BYTE_OFFSET(Buffer);
        ScsiPortInitializeMdlPages (MdlAddress);

        //
        // Flush I/O buffers and write to the boot device.
        //

        KeFlushIoBuffers(MdlAddress, FALSE, TRUE);
        LogicalBlock.QuadPart = BlFileTable[FileId].Position.QuadPart >>
                                    BlFileTable[FileId].u.PartitionContext.SectorShift;
        LogicalBlock.LowPart += BlFileTable[FileId].u.PartitionContext.StartingSector;
        NtStatus = ScsiDiskBootIO(MdlAddress,
            LogicalBlock.LowPart,
            &BlFileTable[FileId].u.PartitionContext,
            FALSE);

        if (NtStatus != ESUCCESS) {
            return EIO;
        }

        *Count += Limit;
        Length -= Limit;
        Buffer = (PVOID)((PCHAR)Buffer + Limit);
        BytesToTransfer -= Limit;
        BlFileTable[FileId].Position.QuadPart = BlFileTable[FileId].Position.QuadPart + Limit;
    }

    //
    // If there is any residual data to write, then read the last sector
    // separately merge the write data and write it.
    //

    if (Length != 0) {
        Position = BlFileTable[FileId].Position;
        ArcStatus = ScsiDiskRead(FileId, TempPointer, SectorSize, &TransferCount);

        //
        // Reset the position as it was before the read.
        //

        BlFileTable[FileId].Position = Position;

        if (ArcStatus != ESUCCESS) {
            return ArcStatus;
        }
        //
        // Merge the data with the read sector from the buffer.
        //

        for (Index = 0; Index < Length; Index += 1) {
            TempPointer[Index] = ((PCHAR)Buffer)[Index];
        }

        //
        // Write the merged sector
        //

        ArcStatus = ScsiDiskWrite(FileId, TempPointer, SectorSize, &TransferCount);

        //
        // Reset the postion.
        //

        BlFileTable[FileId].Position = Position;

        //
        // Update transfer parameters.
        //

        *Count += Length;

        //
        // Position is aligned to a sector boundary and Length is less than
        // a sector, therefore the addition will never overflow.
        //

        BlFileTable[FileId].Position.LowPart += Length;
    }

    return ESUCCESS;

}

#ifdef EFI_PARTITION_SUPPORT

BOOLEAN
ScsiGPTDiskReadCallback(
    ULONGLONG StartingLBA,
    ULONG    BytesToRead,
    PVOID     pContext,
    UNALIGNED PVOID OutputBuffer
    )
{
    PMDL MdlAddress;    
    PUSHORT DataPointer;
    ULONG DummyMdl[(sizeof(MDL) + 16) / sizeof(ULONG)];
    NTSTATUS Status;
    ULONG PartitionOffset;
    PPARTITION_CONTEXT Context;
    
    DBG_PRINT(STR_PREFIX"Trying to read SCSI GPT partition\r\n");

    Context = (PPARTITION_CONTEXT)pContext;
    
    DataPointer = OutputBuffer;

    //
    // Initialize a memory descriptor list to read the master boot record
    // from the specified hard disk drive.
    //
    MdlAddress = (PMDL)&DummyMdl[0];
    MdlAddress->StartVa = (PVOID)(((ULONG_PTR)DataPointer) & (~(PAGE_SIZE - 1)));
    MdlAddress->ByteCount = BytesToRead;
    MdlAddress->ByteOffset = (ULONG)((ULONG_PTR)DataPointer & (PAGE_SIZE - 1));

    ScsiPortInitializeMdlPages(MdlAddress);

    //
    // cast this to a ULONG because that's all we support in this stack.
    //
    PartitionOffset = (ULONG)StartingLBA;

    DBG_PRINT(STR_PREFIX"Reading SCSI GPT block\r\n");
    
    Status = ScsiDiskBootIO(MdlAddress, PartitionOffset, Context, TRUE);

    return(NT_SUCCESS(Status) != FALSE);

}


#define DATA_BUFF_SIZE  ((MAXIMUM_SECTOR_SIZE * 2 / sizeof(USHORT)) + 128)
                            
NTSTATUS
ScsiGPTDiskBootPartitionOpen(
    IN ULONG   FileId,
    IN UCHAR   DeviceUnit,
    IN UCHAR   PartitionNumber
    )
{
    PMDL MdlAddress;
    UNALIGNED USHORT DataBuffer[DATA_BUFF_SIZE];
    PUSHORT DataPointer;
    ULONG DummyMdl[(sizeof(MDL) + 16) / sizeof(ULONG)];
    PPARTITION_CONTEXT Context;
    NTSTATUS Status;
    ULONG PartitionOffset;
    ULONG SectorSize;
    UCHAR ValidPartitions;
    UCHAR PartitionCount;
    UCHAR PartitionsPerSector = 0;
    UCHAR   NullGuid[16] = {0};

    DBG_PRINT(STR_PREFIX"Trying to open SCSI GPT partition\r\n");

    Context = &BlFileTable[FileId].u.PartitionContext;

    if (PartitionNumber > 128)
        return EINVAL;

    //
    // Calculate the actual sector size
    //

    SectorSize = 1 << Context->SectorShift;

    RtlZeroMemory(DataBuffer, sizeof(DataBuffer));

    //
    // Make the sector size the minimum of 512 or the sector size.
    //
    if (SectorSize < 512) {
        SectorSize = 512;
    }

    //
    // Align the buffer on a Dcache line size.
    //
    DataPointer =  (PVOID) ((ULONG_PTR) ((PCHAR) DataBuffer +
        KeGetDcacheFillSize() - 1) & ~((LONG)KeGetDcacheFillSize() - 1));

    //
    // Initialize a memory descriptor list to read the master boot record
    // from the specified hard disk drive.
    //
    MdlAddress = (PMDL)&DummyMdl[0];
    MdlAddress->StartVa = (PVOID)(((ULONG_PTR)DataPointer) & (~(PAGE_SIZE - 1)));
    MdlAddress->ByteCount = SectorSize;
    MdlAddress->ByteOffset = (ULONG)((ULONG_PTR)DataPointer & (PAGE_SIZE - 1));

    ScsiPortInitializeMdlPages(MdlAddress);

    PartitionOffset = 1;

    DBG_PRINT(STR_PREFIX"Reading SCSI GPT block 1\r\n");
    
    Status = ScsiDiskBootIO(MdlAddress, PartitionOffset, Context, TRUE);
    
    if (NT_SUCCESS(Status) != FALSE) {        
        UNALIGNED EFI_PARTITION_TABLE  *EfiHdr;
        ULONGLONG StartLBA;

        EfiHdr = (UNALIGNED EFI_PARTITION_TABLE *)DataPointer;
                                                              
        if (!BlIsValidGUIDPartitionTable(
                                    EfiHdr,
                                    1,
                                    Context,
                                    ScsiGPTDiskReadCallback)) {
            Status = STATUS_UNSUCCESSFUL;

            return Status;
        }                

        //
        // Read the partition entries
        //
        StartLBA = EfiHdr->PartitionEntryLBA;
        PartitionOffset = (ULONG)StartLBA;
        ValidPartitions = 0;
        PartitionCount = 0;
        PartitionsPerSector = (UCHAR)(SectorSize / sizeof(EFI_PARTITION_ENTRY));

        while ((PartitionCount < 128)) {                 
#if 0
            BlPrint("Reading %d at %d block offset of blk size %d %d \r\n", 
                MdlAddress->ByteCount, PartitionOffset, SectorSize,
                PartitionsPerSector);
#endif                

            RtlZeroMemory(DataPointer, SectorSize);                

            DBG_PRINT(STR_PREFIX"Reading GPT partition entries\r\n");
            
            Status = ScsiDiskBootIO(MdlAddress, PartitionOffset, Context, TRUE);

            if (NT_SUCCESS(Status)) {
                UNALIGNED EFI_PARTITION_ENTRY *PartEntry = NULL;

                RtlZeroMemory(EfiPartitionBuffer, SectorSize);                
                
                //
                // Move the read content to EfiPartitionBuffer
                //
                RtlCopyMemory(EfiPartitionBuffer, DataPointer, SectorSize);

                DBG_PRINT(STR_PREFIX"Locating the requested GPT partition\r\n");
                
                //
                // Locate the GPT partition requested
                //
                PartEntry = (UNALIGNED EFI_PARTITION_ENTRY *)
                                BlLocateGPTPartition(PartitionNumber, 
                                        PartitionsPerSector, 
                                        &ValidPartitions);                            

                if (PartEntry) {                
                    PPARTITION_CONTEXT PartContext = &(BlFileTable[FileId].u.PartitionContext);
                    ULONG   SectorCount = (ULONG)(PartEntry->EndingLBA - PartEntry->StartingLBA);

                    DBG_PRINT(STR_PREFIX"Initializing GPT Partition Entry Context\r\n");

                    //
                    // Fill the partition context structure
                    //
                    PartContext->PartitionLength.QuadPart = SectorCount * SECTOR_SIZE;
                    PartContext->StartingSector = (ULONG)(PartEntry->StartingLBA);
                    PartContext->EndingSector = (ULONG)(PartEntry->EndingLBA);


#if 0
                    BlPrint("Start:%d,End:%d\r\n", PartContext->StartingSector,
                            PartContext->EndingSector);
                    while (!BlGetKey());                            
#endif                    

                    BlFileTable[FileId].Position.QuadPart = 0;

                    Status = ESUCCESS;
                    
                    break;
                } else {
                    //
                    // Get hold of the next set of
                    // partition entries in the next block
                    //
                    PartitionCount += PartitionsPerSector;
                    PartitionOffset++;
                }                    
            } else {
                break;  // I/O Error
            }
        }
    }

    DBG_PRINT(STR_PREFIX"Returning from ScsiGPTDiskBootPartitionOpen(...)\r\n");

    return Status;
}

#endif  // for EFI_PARTITION_SUPPORT


NTSTATUS
ScsiDiskBootPartitionOpen(
    IN ULONG   FileId,
    IN UCHAR   DeviceUnit,
    IN UCHAR   PartitionNumber
    )

/*++

Routine Description:

    This is the initialization routine for the hard disk boot driver
    for the given partition. It sets the partition info in the
    FileTable at the specified index and initializes the Device entry
    table to point to the table of ScsiDisk routines.

    It reads the partition information until the requested partition
    is found or no more partitions are defined.

Arguments:

    FileId - Supplies the file id for the file table entry.

    DeviceUnit - Supplies the device number in the scis bus.

    PartitionNumber - Supplies the partition number must be bigger than zero.
                      To get the size of the disk call ReadDriveCapacity.


Return Value:

    If a valid FAT file system structure is found on the hard disk, then
    STATUS_SUCCESS is returned. Otherwise, STATUS_UNSUCCESSFUL is returned.

--*/

{

    PMDL MdlAddress;
    USHORT DataBuffer[MAXIMUM_SECTOR_SIZE / sizeof(USHORT) + 128];
    PUSHORT DataPointer;
    ULONG DummyMdl[(sizeof(MDL) + 16) / sizeof(ULONG)];
    PPARTITION_DESCRIPTOR Partition;
    PPARTITION_CONTEXT Context;
    ULONG PartitionLength;
    ULONG StartingSector;
    ULONG VolumeOffset;
    NTSTATUS Status;
    BOOLEAN PrimaryPartitionTable;
    ULONG PartitionOffset=0;
    ULONG PartitionIndex,PartitionCount=0;
    ULONG SectorSize;

    BlFileTable[FileId].Position.LowPart = 0;
    BlFileTable[FileId].Position.HighPart = 0;

    VolumeOffset=0;
    PrimaryPartitionTable=TRUE;

    Context = &BlFileTable[FileId].u.PartitionContext;

    //
    // Calculate the actual sector size
    //

    SectorSize = 1 << Context->SectorShift;

    RtlZeroMemory(DataBuffer, sizeof(DataBuffer));

    //
    // Make the sector size the minimum of 512 or the sector size.
    //

    if (SectorSize < 512) {
        SectorSize = 512;
    }

    //
    // Align the buffer on a Dcache line size.
    //

    DataPointer =  (PVOID) ((ULONG_PTR) ((PCHAR) DataBuffer +
        KeGetDcacheFillSize() - 1) & ~((LONG)KeGetDcacheFillSize() - 1));

    //
    // Initialize a memory descriptor list to read the master boot record
    // from the specified hard disk drive.
    //

    MdlAddress = (PMDL)&DummyMdl[0];
    MdlAddress->StartVa = (PVOID)(((ULONG_PTR)DataPointer) & (~(PAGE_SIZE - 1)));
    MdlAddress->ByteCount = SectorSize;
    MdlAddress->ByteOffset = (ULONG)((ULONG_PTR)DataPointer & (PAGE_SIZE - 1));
    ScsiPortInitializeMdlPages (MdlAddress);
    do {
        Status = ScsiDiskBootIO(MdlAddress,PartitionOffset,Context,TRUE);
        if (NT_SUCCESS(Status) != FALSE) {

            //
            // If sector zero is not a master boot record, then return failure
            // status. Otherwise return success.
            //

            if (*(DataPointer + BOOT_SIGNATURE_OFFSET) != BOOT_RECORD_SIGNATURE) {
                // This DbgPrint has been commented out.  On IA64 and AXP64,
                // it crashes unless booted with a boot debugger.
                //DbgPrint("Boot record signature not found\n");
                return STATUS_UNSUCCESSFUL;
            }

            //
            // Read the partition information until the four entries are
            // checked or until we found the requested one.
            //
            Partition = (PPARTITION_DESCRIPTOR)(DataPointer+PARTITION_TABLE_OFFSET);
            for (PartitionIndex=0;
                PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
                PartitionIndex++,Partition++) {
                //
                // Count first the partitions in the MBR. The units
                // inside the extended partition are counted later.
                //
                if (!IsContainerPartition(Partition->PartitionType) &&
                    (Partition->PartitionType != STALE_GPT_PARTITION_ENTRY) &&
                    (Partition->PartitionType != PARTITION_ENTRY_UNUSED)) {
                    PartitionCount++;   // another partition found.
                }

                //
                // Check if the requested partition has already been found.
                // set the partition info in the file table and return.
                //
                if (PartitionCount == (ULONG)PartitionNumber) {
                    StartingSector = (ULONG)(Partition->StartingSectorLsb0) |
                                     (ULONG)(Partition->StartingSectorLsb1 << 8) |
                                     (ULONG)(Partition->StartingSectorMsb0 << 16) |
                                     (ULONG)(Partition->StartingSectorMsb1 << 24);
                    PartitionLength = (ULONG)(Partition->PartitionLengthLsb0) |
                                      (ULONG)(Partition->PartitionLengthLsb1 << 8) |
                                      (ULONG)(Partition->PartitionLengthMsb0 << 16) |
                                      (ULONG)(Partition->PartitionLengthMsb1 << 24);

                    Context->PartitionLength.QuadPart = PartitionLength;
                    Context->PartitionLength.QuadPart <<= Context->SectorShift;
                    Context->StartingSector = PartitionOffset + StartingSector;
                    Context->EndingSector = Context->StartingSector + PartitionLength;
                    return Status;
                }
            }

            //
            //  If requested partition was not yet found.
            //  Look for an extended partition.
            //
            Partition = (PPARTITION_DESCRIPTOR)(DataPointer + PARTITION_TABLE_OFFSET);
            PartitionOffset = 0;
            for (PartitionIndex=0;
                PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
                PartitionIndex++,Partition++) {
                if (IsContainerPartition(Partition->PartitionType)) {
                    StartingSector = (ULONG)(Partition->StartingSectorLsb0) |
                                     (ULONG)(Partition->StartingSectorLsb1 << 8) |
                                     (ULONG)(Partition->StartingSectorMsb0 << 16) |
                                     (ULONG)(Partition->StartingSectorMsb1 << 24);
                    PartitionOffset = VolumeOffset+StartingSector;
                    if (PrimaryPartitionTable) {
                        VolumeOffset = StartingSector;
                    }
                    break;      // only one partition can be extended.
                }
            }
        }
        PrimaryPartitionTable=FALSE;
    } while (PartitionOffset != 0);
    return STATUS_UNSUCCESSFUL;
}

VOID
ScsiPortInitializeMdlPages (
    IN OUT PMDL Mdl
    )
/*++

Routine Description:

    This routine fills in the physical pages numbers for the virtual
    addresses specified in the passed in Mdl.

Arguments:

    Mdl     - On input contains the StartVa, ByteCount and  ByteOffset
              of the Mdl.

Return Value:

    Mdl     - The physical page array referenced by the mdl is completed

--*/

{
    PULONG PageFrame;
    PUCHAR PageVa;
    ULONG Index;
    ULONG NumberOfPages;

    PageFrame = (PULONG)(Mdl + 1);
    PageVa = (PUCHAR) Mdl->StartVa;
    NumberOfPages = (Mdl->ByteCount + Mdl->ByteOffset + PAGE_SIZE - 1) >> PAGE_SHIFT;
    for (Index = 0; Index < NumberOfPages; Index += 1) {
        PageFrame[Index] = (ULONG)(MmGetPhysicalAddress(PageVa).QuadPart >> PAGE_SHIFT);
        PageVa += PAGE_SIZE;
    }
}

BOOLEAN
ScsiGetDevicePath(
    IN ULONG ScsiNumber,
    IN PCONFIGURATION_COMPONENT TargetComponent,
    IN PCONFIGURATION_COMPONENT LunComponent,
    OUT PCHAR DevicePath
    )
/*++

Routine Description:

    This routine constructs the device path for the device identified
    by the supplied parameters.

Arguments:

    ScsiNumber      - Identifies the scis bus on which the device resides.

    TargetComponent - Points to a CONFIGURATION_COMPONENT structure that
                      describes the target.

    LunComponent    - Points to a CONFIGURATION_COMPONENT structure that
                      describes the lun.

    DevicePath      - Points to the output buffer into which the device path
                      is copied.

Return Value:

    TRUE if a valid device path is copied into the output buffer.

    FALSE if the supplied parameters do not represent a valid device. If
    the return value is FALSE, nothing copied into the output buffer.

--*/
{
    if (TargetComponent->Type == DiskController) {

        //
        // This is either a hard disk or a floppy floppy disk. Construct
        // the appropriate device path depending on which.
        //

        if (LunComponent->Type == FloppyDiskPeripheral) {
            sprintf(DevicePath, "scsi(%d)disk(%d)fdisk(%d)",
                    ScsiNumber,
                    TargetComponent->Key,
                    LunComponent->Key);
        } else if (LunComponent->Type == DiskPeripheral) {
            sprintf(DevicePath, "scsi(%d)disk(%d)rdisk(%d)",
                    ScsiNumber,
                    TargetComponent->Key,
                    LunComponent->Key);
        } else {
            ASSERT(FALSE);
            return FALSE;
        }

    } else if (TargetComponent->Type == CdromController) {

        //
        // This is a cdrom device. Construct an appropriate device path.
        //

        sprintf(DevicePath, "scsi(%d)cdrom(%d)fdisk(%d)",
                ScsiNumber,
                TargetComponent->Key,
                LunComponent->Key);
    } else {

        //
        // Unexpected device path.
        //

        ASSERT(FALSE);
        return FALSE;
    }

    return TRUE;
}

PCONFIGURATION_COMPONENT
ScsiGetNextConfiguredLunComponent(
    IN PCONFIGURATION_COMPONENT LunComponent
    )
/*++

Routine Description:

    Given a lun that exists on one of the system's SCSI buses, this 
    routine returns the next sequential lun identified on the same
    target.

Arguments:

    LunComponent - Pointer to a CONFIGURATION_COMPONENT structure that
                   describes an existing lun.

Return Value:

    If one or more luns were identified on the same target as supplied 
    lun, this function returns a pointer to a CONFIGURATION_COMPONTENT       
    structure that describes the next sequential lun on the same target.

--*/
{
    PCONFIGURATION_COMPONENT nextLunComponent;

    nextLunComponent = FwGetPeer(LunComponent);
    if (nextLunComponent != NULL) {
        if (nextLunComponent->Type != FloppyDiskPeripheral &&
            nextLunComponent->Type != DiskPeripheral) {
            nextLunComponent = NULL;
        }
    }
    return nextLunComponent;
}

PCONFIGURATION_COMPONENT
ScsiGetFirstConfiguredLunComponent(
    IN PCONFIGURATION_COMPONENT TargetComponent
    )
/*++

Routine Description:

    Given a target that exists on one of the system's SCSI buses, this
    routine returns the first LUN identified on that target.

Arguments:

    TargetComponent - Pointer to a CONFIGURATION_COMPONENT structure that
                      describes an existing SCSI target.

Return Value:

    If any lun was identified on given target, this function returns a pointer
    to a CONFIGURATION_COMPONENT structure that describes the lun.  If no
    LUNs were found on the target, NULL is returned.

--*/
{
    PCONFIGURATION_COMPONENT lunComponent;

    lunComponent = FwGetChild(TargetComponent);
    if (lunComponent != NULL) {
        if (lunComponent->Type != FloppyDiskPeripheral &&
            lunComponent->Type != DiskPeripheral) {
            lunComponent = NULL;
        }
    }
    return lunComponent;
}

PCONFIGURATION_COMPONENT
ScsiGetNextConfiguredTargetComponent(
    IN PCONFIGURATION_COMPONENT TargetComponent
    )
/*++

Routine Description:

    Given a target that exists on one of the system's SCSI buses, this
    routine returns the next numerically sequestial target found on the 
    same bus.  

Arguments:

    TargetComponent - Pointer to a CONFIGURATION_COMPONENT structure
                      that describes a SCSI target.    

Return Value:

    If one or more targets were identified on the same SCSI bus as the 
    supplied target, a pointer to a CONFIGURATION_COMPONENT structure
    that describes the next sequential target is returned.  If there
    are no targets following the one supplied, NULL is returned.

--*/
{
    PCONFIGURATION_COMPONENT nextTarget;

    nextTarget = FwGetPeer(TargetComponent);
    if (nextTarget != NULL) {
        if (nextTarget->Type != DiskController && 
            nextTarget->Type != CdromController) {
            nextTarget = NULL;
        }
    }
    return nextTarget;
}

PCONFIGURATION_COMPONENT
ScsiGetFirstConfiguredTargetComponent(
    ULONG ScsiNumber 
    )
/*++

Routine Description:

    This routine returns the first configured target on the specified SCSI bus.

Arguments:

    ScsiNumber - Identifies the SCSI bus for which the first target is requested.

Return Value:

    If any target was detected on the specified bus, a pointer to a
    CONFIGURATION_COMPONENT structure describing the target is returned.  If no 
    targets were detected on the speicified bus, the funtion returns NULL.

--*/
{
    PCONFIGURATION_COMPONENT scsiComponent;
    PCONFIGURATION_COMPONENT controllerComponent;
    CHAR componentPath[10];

    //
    // Get the requested scsi adapter component.  If no match, return NULL.
    //

    sprintf(componentPath, "scsi(%1d)", ScsiNumber);
    scsiComponent = FwGetComponent(componentPath);
    if (scsiComponent == NULL) {
        return NULL;
    }

    //
    // If returned the component is not a SCSI adapter, return NULL.
    //
  
    if (scsiComponent->Type != ScsiAdapter) {
        return NULL;
    }

    //
    // Get the first configured target on the adapter.
    //

    controllerComponent = FwGetChild(scsiComponent);
        
    if ((controllerComponent != NULL) &&
         ((controllerComponent->Type == DiskController) ||
         (controllerComponent->Type == CdromController))) {
        return controllerComponent;
    } else {
        //
        // We got back an unexpected controller type.
        //

        ASSERT(FALSE);
    }
    
    return NULL;
}

//
// This callback messes a lot of things up.  There is no clean definition
// for it anywhere, so it has to be defined in all modules that reference it.
//

#ifndef SCSI_INFO_CALLBACK_DEFINED

typedef
VOID
(*PSCSI_INFO_CALLBACK_ROUTINE) (
    IN ULONG AdapterNumber,
    IN ULONG ScsiId,
    IN ULONG Lun,
    IN BOOLEAN Cdrom
    );
#endif

VOID
HardDiskInitialize(
    IN OUT PDRIVER_LOOKUP_ENTRY LookupTable,
    IN ULONG Entries,
    IN PSCSI_INFO_CALLBACK_ROUTINE DeviceFound
    )

/*++

Routine Description:

    This routine initializes the scsi controller and the
    device entry table for the scsi driver.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG lookupTableIndex = 0;
    ULONG scsiNumber;
    ULONG busNumber;
    PCHAR Identifier;
    PLUNINFO lunInfo;
    PSCSI_CONFIGURATION_INFO configInfo;
    PSCSI_BUS_SCAN_DATA busScanData;
    PDEVICE_EXTENSION scsiPort;
    PINQUIRYDATA inquiryData;
    PCONFIGURATION_COMPONENT RootComponent;
    PCONFIGURATION_COMPONENT ScsiComponent;
    PCONFIGURATION_COMPONENT ControllerComponent;
    PCONFIGURATION_COMPONENT PeripheralComponent;
    PCONFIGURATION_COMPONENT NextComponent;
    CHAR ComponentPath[10];
    CONFIGURATION_COMPONENT ControllerEntry;
    CONFIGURATION_COMPONENT AdapterEntry;
    CONFIGURATION_COMPONENT PeripheralEntry;
    PARTITION_CONTEXT Context;
    BOOLEAN IsFloppy;

    RtlZeroMemory(&Context, sizeof(PARTITION_CONTEXT));

    //
    // Initialize the common buffers.
    //

    ReadCapacityBuffer = ExAllocatePool( NonPagedPool, sizeof(READ_CAPACITY_DATA));

    SenseInfoBuffer = ExAllocatePool( NonPagedPool, SENSE_BUFFER_SIZE);

    if (ReadCapacityBuffer == NULL || SenseInfoBuffer == NULL) {
        return;
    }

    //
    // Scan the scsi ports looking for disk devices.
    //

    for (scsiNumber = 0; ScsiPortDeviceObject[scsiNumber]; scsiNumber++) {

        scsiPort = ScsiPortDeviceObject[scsiNumber]->DeviceExtension;
        configInfo = scsiPort->ScsiInfo;
        Context.PortDeviceObject = ScsiPortDeviceObject[scsiNumber];

        //
        // Search the configuration database for scsi disk and cdrom devices and
        // delete them.
        //

        sprintf(ComponentPath,"scsi(%1d)", scsiNumber);
        ScsiComponent = FwGetComponent(ComponentPath);

        if (ScsiComponent != NULL) {
            if (ScsiComponent->Type == ScsiAdapter) {
                ControllerComponent = FwGetChild(ScsiComponent);

                while (ControllerComponent != NULL) {
                    NextComponent = FwGetPeer(ControllerComponent);

                    if ((ControllerComponent->Type == DiskController) ||
                        (ControllerComponent->Type == CdromController)) {

                        PeripheralComponent = FwGetChild(ControllerComponent);
                        if (FwDeleteComponent(PeripheralComponent) == ESUCCESS) {
                            FwDeleteComponent(ControllerComponent);
                        }
                    }
                    ControllerComponent = NextComponent;
                }
            } else {
                RootComponent = FwGetChild(NULL);
                AdapterEntry.Class = AdapterClass;
                AdapterEntry.Type = ScsiAdapter;
                AdapterEntry.Flags.ReadOnly = 0;
                AdapterEntry.Flags.Removable = 0;
                AdapterEntry.Flags.ConsoleIn = 0;
                AdapterEntry.Flags.ConsoleOut = 0;
                AdapterEntry.Flags.Output = 1;
                AdapterEntry.Flags.Input = 1;
                AdapterEntry.Version = 0;
                AdapterEntry.Revision = 0;
                AdapterEntry.Key = scsiNumber;
                AdapterEntry.AffinityMask = 0xffffffff;
                AdapterEntry.ConfigurationDataLength = 0;
                AdapterEntry.IdentifierLength = 0;
                AdapterEntry.Identifier = 0;
                ScsiComponent = FwAddChild(RootComponent, &AdapterEntry, NULL);
            }
        }

        for (busNumber=0; busNumber < (ULONG)configInfo->NumberOfBuses; busNumber++) {

            busScanData = configInfo->BusScanData[busNumber];

            //
            // Set LunInfo to beginning of list.
            //

            lunInfo = busScanData->LunInfoList;

            while (lunInfo != NULL) {

                inquiryData = (PVOID)lunInfo->InquiryData;

                ScsiDebugPrint(3,"FindScsiDevices: Inquiry data at %lx\n",
                    inquiryData);

                if ((inquiryData->DeviceType == DIRECT_ACCESS_DEVICE
                    || inquiryData->DeviceType == OPTICAL_DEVICE) &&
                    !lunInfo->DeviceClaimed) {

                    ScsiDebugPrint(1,
                                   "FindScsiDevices: Vendor string is %.24s\n",
                                   inquiryData->VendorId);

                    IsFloppy = FALSE;

                    //
                    // Create a dummy paritition context so that I/O can be
                    // done on the device.  SendSrbSynchronous only uses the
                    // port device object pointer and the scsi address of the
                    // logical unit.
                    //

                    Context.PathId = lunInfo->PathId;
                    Context.TargetId = lunInfo->TargetId;
                    Context.DiskId = lunInfo->Lun;

                    //
                    // Create name for disk object.
                    //

                    LookupTable->DevicePath =
                        ExAllocatePool(NonPagedPool,
                                       sizeof("scsi(%d)disk(%d)rdisk(%d)"));

                    if (LookupTable->DevicePath == NULL) {
                        return;
                    }

                    //
                    // If this is a removable.  Check to see if the device is
                    // a floppy.
                    //

                    if (inquiryData->RemovableMedia  &&
                        inquiryData->DeviceType == DIRECT_ACCESS_DEVICE &&
                        IsFloppyDevice(&Context) ) {

                        sprintf(LookupTable->DevicePath,
                            "scsi(%d)disk(%d)fdisk(%d)",
                            scsiNumber,
                            SCSI_COMBINE_BUS_TARGET( lunInfo->PathId, lunInfo->TargetId ),
                            lunInfo->Lun
                            );

                        IsFloppy = TRUE;
                    } else {

                        sprintf(LookupTable->DevicePath,
                            "scsi(%d)disk(%d)rdisk(%d)",
                            scsiNumber,
                            SCSI_COMBINE_BUS_TARGET( lunInfo->PathId, lunInfo->TargetId ),
                            lunInfo->Lun
                            );

                        if (DeviceFound) {
                            DeviceFound( scsiNumber,
                            SCSI_COMBINE_BUS_TARGET( lunInfo->PathId, lunInfo->TargetId ),
                                 lunInfo->Lun,
                                 FALSE
                               );
                        }
                    }

                    LookupTable->DispatchTable = &ScsiDiskEntryTable;

                    //
                    // If the disk controller entry does not exist, add it to
                    // the configuration database.
                    //

                    ControllerComponent = FwGetComponent(LookupTable->DevicePath);

                    if (ControllerComponent != NULL) {
                        if (ControllerComponent->Type != DiskController) {

                            ControllerEntry.Class = ControllerClass;
                            ControllerEntry.Type = DiskController;
                            ControllerEntry.Flags.Failed = 0;
                            ControllerEntry.Flags.ReadOnly = 0;
                            ControllerEntry.Flags.Removable = 0;
                            ControllerEntry.Flags.ConsoleIn = 0;
                            ControllerEntry.Flags.ConsoleOut = 0;
                            ControllerEntry.Flags.Output = 1;
                            ControllerEntry.Flags.Input = 1;
                            ControllerEntry.Version = 0;
                            ControllerEntry.Revision = 0;
                            ControllerEntry.Key = SCSI_COMBINE_BUS_TARGET( lunInfo->PathId, lunInfo->TargetId );
                            ControllerEntry.AffinityMask = 0xffffffff;
                            ControllerEntry.ConfigurationDataLength = 0;

                            Identifier =
                                ExAllocatePool(NonPagedPool,
                                               strlen(inquiryData->VendorId)
                                               );

                            if (Identifier == NULL) {
                                return;
                            }

                            sprintf(Identifier,
                                    "%s",
                                    inquiryData->VendorId
                                    );

                            ControllerEntry.IdentifierLength = strlen(Identifier);
                            ControllerEntry.Identifier = Identifier;

                            ControllerComponent = FwAddChild(ScsiComponent, &ControllerEntry, NULL);
                        }
                    }

                    //
                    // Add disk peripheral entry to the configuration database.
                    //

                    PeripheralEntry.Class = PeripheralClass;
                    PeripheralEntry.Type = IsFloppy ? FloppyDiskPeripheral : DiskPeripheral;
                    PeripheralEntry.Flags.Failed = 0;
                    PeripheralEntry.Flags.ReadOnly = 0;
                    PeripheralEntry.Flags.Removable = IsFloppy;
                    PeripheralEntry.Flags.ConsoleIn = 0;
                    PeripheralEntry.Flags.ConsoleOut = 0;
                    PeripheralEntry.Flags.Output = 1;
                    PeripheralEntry.Flags.Input = 1;
                    PeripheralEntry.Version = 0;
                    PeripheralEntry.Revision = 0;
                    PeripheralEntry.Key = lunInfo->Lun;
                    PeripheralEntry.AffinityMask = 0xffffffff;
                    PeripheralEntry.ConfigurationDataLength = 0;
                    PeripheralEntry.IdentifierLength = 0;
                    PeripheralEntry.Identifier = NULL;

                    FwAddChild(ControllerComponent, &PeripheralEntry, NULL);

                    //
                    // Increment to the next entry.
                    //

                    LookupTable++;
                    lookupTableIndex++;
                    if (lookupTableIndex >= Entries) {

                        //
                        // There is no more space in the caller provided buffer
                        // for disk information.  Return.
                        //
                        return;
                    }

                    //
                    // Claim disk device by marking configuration
                    // record owned.
                    //

                    lunInfo->DeviceClaimed = TRUE;

                }

                if ((inquiryData->DeviceType == READ_ONLY_DIRECT_ACCESS_DEVICE) &&
                    (!lunInfo->DeviceClaimed)) {

                    ScsiDebugPrint(1,"FindScsiDevices: Vendor string is %s\n", inquiryData->VendorId);

                    //
                    // Create name for cdrom object.
                    //

                    LookupTable->DevicePath =
                        ExAllocatePool( NonPagedPool, sizeof("scsi(%d)cdrom(%d)fdisk(%d)"));

                    if (LookupTable->DevicePath == NULL) {
                        return;
                    }

                    sprintf(LookupTable->DevicePath,
                        "scsi(%d)cdrom(%d)fdisk(%d)",
                        scsiNumber,
                        SCSI_COMBINE_BUS_TARGET( lunInfo->PathId, lunInfo->TargetId ),
                        lunInfo->Lun
                        );

                    LookupTable->DispatchTable = &ScsiDiskEntryTable;

                    if (DeviceFound) {
                        DeviceFound( scsiNumber,
                                 SCSI_COMBINE_BUS_TARGET( lunInfo->PathId, lunInfo->TargetId ),
                                 lunInfo->Lun,
                                 TRUE
                               );
                    }

                    //
                    // If the cdrom controller entry does not exist, add it to
                    // the configuration database.
                    //

                    ControllerComponent = FwGetComponent(LookupTable->DevicePath);

                    if (ControllerComponent != NULL) {
                        if (ControllerComponent->Type != CdromController) {

                            ControllerEntry.Class = ControllerClass;
                            ControllerEntry.Type = CdromController;
                            ControllerEntry.Flags.Failed = 0;
                            ControllerEntry.Flags.ReadOnly = 1;
                            ControllerEntry.Flags.Removable = 1;
                            ControllerEntry.Flags.ConsoleIn = 0;
                            ControllerEntry.Flags.ConsoleOut = 0;
                            ControllerEntry.Flags.Output = 0;
                            ControllerEntry.Flags.Input = 1;
                            ControllerEntry.Version = 0;
                            ControllerEntry.Revision = 0;
                            ControllerEntry.Key = SCSI_COMBINE_BUS_TARGET( lunInfo->PathId, lunInfo->TargetId );
                            ControllerEntry.AffinityMask = 0xffffffff;
                            ControllerEntry.ConfigurationDataLength = 0;

                            Identifier =
                                ExAllocatePool( NonPagedPool,
                                                strlen(inquiryData->VendorId)
                                                );

                            if (Identifier == NULL) {
                                return;
                            }

                            sprintf(Identifier,
                                    inquiryData->VendorId
                                    );

                            ControllerEntry.IdentifierLength = strlen(Identifier);
                            ControllerEntry.Identifier = Identifier;

                            ControllerComponent = FwAddChild(ScsiComponent, &ControllerEntry, NULL);
                        }
                    }

                    //
                    // Add disk peripheral entry to the configuration database.
                    //

                    PeripheralEntry.Class = PeripheralClass;
                    PeripheralEntry.Type = FloppyDiskPeripheral;
                    PeripheralEntry.Flags.Failed = 0;
                    PeripheralEntry.Flags.ReadOnly = 1;
                    PeripheralEntry.Flags.Removable = 1;
                    PeripheralEntry.Flags.ConsoleIn = 0;
                    PeripheralEntry.Flags.ConsoleOut = 0;
                    PeripheralEntry.Flags.Output = 0;
                    PeripheralEntry.Flags.Input = 1;
                    PeripheralEntry.Version = 0;
                    PeripheralEntry.Revision = 0;
                    PeripheralEntry.Key = lunInfo->Lun;
                    PeripheralEntry.AffinityMask = 0xffffffff;
                    PeripheralEntry.ConfigurationDataLength = 0;
                    PeripheralEntry.IdentifierLength = 0;
                    PeripheralEntry.Identifier = NULL;

                    FwAddChild(ControllerComponent, &PeripheralEntry, NULL);

                    //
                    // Increment to the next entry.
                    //

                    LookupTable++;
                    lookupTableIndex++;
                    if (lookupTableIndex >= Entries) {

                        //
                        // There is no more space in the caller provided buffer
                        // for disk information.  Return.
                        //
                        return;
                    }


                    //
                    // Claim disk device by marking configuration
                    // record owned.
                    //

                    lunInfo->DeviceClaimed = TRUE;

                }

                //
                // Get next LunInfo.
                //

                lunInfo = lunInfo->NextLunInfo;
            }
        }
    }

//    ScsiDebugPrint(1,"FindScsiDevices: Hit any key\n");
//    PAUSE;

}

NTSTATUS
ScsiDiskBootIO (
    IN PMDL MdlAddress,
    IN ULONG LogicalBlock,
    IN PPARTITION_CONTEXT PartitionContext,
    IN BOOLEAN Operation
    )

/*++

Routine Description:

    This routine is the read/write routine for the hard disk boot driver.

Arguments:

    MdlAddress - Supplies a pointer to an MDL for the IO operation.

    LogicalBlock - Supplies the starting block number.

    DeviceUnit  - Supplies the SCSI Id number.

    Operation - Specifies the IO operation to perform
                TRUE  =  SCSI_READ
                FALSE =  SCSI_WRITE.

Return Value:

    The final status of the read operation (STATUS_UNSUCCESSFUL or
    STATUS_SUCCESS).

--*/

{
    ARC_STATUS Status;
    PIRP Irp;
    PIO_STACK_LOCATION NextIrpStack;
    PSCSI_REQUEST_BLOCK Srb;
    ULONG RetryCount = MAXIMUM_RETRIES;

    //
    // Check that the request is within the limits of the partition.
    //
    if (PartitionContext->StartingSector > LogicalBlock) {
        return STATUS_UNSUCCESSFUL;
    }
    if (PartitionContext->EndingSector <
        LogicalBlock + (MdlAddress->ByteCount >> PartitionContext->SectorShift)) {
        return STATUS_UNSUCCESSFUL;
    }

Retry:

    //
    // Build the I/O Request.
    //

    Irp = BuildRequest(PartitionContext, MdlAddress, LogicalBlock, Operation);

    NextIrpStack = IoGetNextIrpStackLocation(Irp);
    Srb = NextIrpStack->Parameters.Others.Argument1;

    //
    // Call the port driver.
    //

    IoCallDriver(PartitionContext->PortDeviceObject, Irp);

    //
    // Check the status.
    //

    if (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        //
        // Determine the cause of the error.
        //

        if (InterpretSenseInfo(Srb, &Status, PartitionContext) && RetryCount--) {

            goto Retry;
        }

        if (Status == EAGAIN) {
            Status = EIO;
        }

        DebugPrint((1, "SCSI: Read request failed.  Arc Status: %d, Srb Status: %x\n",
            Status,
            Srb->SrbStatus
            ));

    } else {

        Status = ESUCCESS;

    }

    return(Status);
}

ARC_STATUS
ReadDriveCapacity(
    IN PPARTITION_CONTEXT PartitionContext
    )

/*++

Routine Description:

    This routine sends a read capacity to a target id and returns
    when it is complete.

Arguments:

Return Value:

    Status is returned.

--*/
{
    PCDB Cdb;
    PSCSI_REQUEST_BLOCK Srb = &PrimarySrb.Srb;
    ULONG LastSector;
    ULONG retries = 1;
    ARC_STATUS status;
    ULONG BytesPerSector;

    ScsiDebugPrint(3,"SCSI ReadCapacity: Enter routine\n");


    //
    // Build the read capacity CDB.
    //

    Srb->CdbLength = 10;
    Cdb = (PCDB)Srb->Cdb;

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(Cdb, MAXIMUM_CDB_SIZE);

    Cdb->CDB10.OperationCode = SCSIOP_READ_CAPACITY;

Retry:

    status = SendSrbSynchronous(PartitionContext,
                  Srb,
                  ReadCapacityBuffer,
                  sizeof(READ_CAPACITY_DATA),
                  FALSE);

    if (status == ESUCCESS) {

#if 0
        //
        // Copy sector size from read capacity buffer to device extension
        // in reverse byte order.
        //

        deviceExtension->DiskGeometry->BytesPerSector = 0;

        ((PFOUR_BYTE)&deviceExtension->DiskGeometry->BytesPerSector)->Byte0 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->BytesPerBlock)->Byte3;

        ((PFOUR_BYTE)&deviceExtension->DiskGeometry->BytesPerSector)->Byte1 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->BytesPerBlock)->Byte2;

        if (BytesPerSector == 0) {

            //
            // Assume this is a bad cd-rom and the sector size is 2048.
            //

            BytesPerSector = 2048;

        }

        //
        // Make sure the sector size is less than the maximum expected.
        //

        ASSERT(BytesPerSector <= MAXIMUM_SECTOR_SIZE);

        if (BytesPerSector > MAXIMUM_SECTOR_SIZE) {
            return(EINVAL);
        }

        //
        // Copy last sector in reverse byte order.
        //

        ((PFOUR_BYTE)&LastSector)->Byte0 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte3;

        ((PFOUR_BYTE)&LastSector)->Byte1 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte2;

        ((PFOUR_BYTE)&LastSector)->Byte2 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte1;

        ((PFOUR_BYTE)&LastSector)->Byte3 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte0;

        //
        // Calculate sector to byte shift.
        //

        WHICH_BIT(deviceExtension->DiskGeometry->BytesPerSector, deviceExtension->SectorShift);

        ScsiDebugPrint(2,"SCSI ReadDriveCapacity: Sector size is %d\n",
            deviceExtension->DiskGeometry->BytesPerSector);

        ScsiDebugPrint(2,"SCSI ReadDriveCapacity: Number of Sectors is %d\n",
            LastSector + 1);

        //
        // Calculate media capacity in bytes.
        //

        deviceExtension->PartitionLength = LastSector + 1;

        deviceExtension->PartitionLength.QuadPart <<= deviceExtension->SectorShift.QuadPart;

        //
        // Assume media type is fixed disk.
        //

        deviceExtension->DiskGeometry->MediaType = FixedMedia;

        //
        // Assume sectors per track are 32;
        //

        deviceExtension->DiskGeometry->SectorsPerTrack = 32;

        //
        // Assume tracks per cylinder (number of heads) is 64.
        //

        deviceExtension->DiskGeometry->TracksPerCylinder = 64;
#else

        BytesPerSector = 0;

        //
        // Copy sector size from read capacity buffer to device extension
        // in reverse byte order.
        //

        ((PFOUR_BYTE)&BytesPerSector)->Byte0 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->BytesPerBlock)->Byte3;

        ((PFOUR_BYTE)&BytesPerSector)->Byte1 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->BytesPerBlock)->Byte2;

        if (BytesPerSector == 0) {

            //
            // Assume this is a bad cd-rom and the sector size is 2048.
            //

            BytesPerSector = 2048;

        }

        //
        // Calculate sector to byte shift.
        //

        WHICH_BIT(BytesPerSector, PartitionContext->SectorShift);

        //
        // Copy last sector in reverse byte order.
        //

        ((PFOUR_BYTE)&LastSector)->Byte0 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte3;

        ((PFOUR_BYTE)&LastSector)->Byte1 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte2;

        ((PFOUR_BYTE)&LastSector)->Byte2 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte1;

        ((PFOUR_BYTE)&LastSector)->Byte3 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte0;


        PartitionContext->PartitionLength.QuadPart = LastSector + 1;
        PartitionContext->PartitionLength.QuadPart <<= PartitionContext->SectorShift;

        PartitionContext->StartingSector=0;
        PartitionContext->EndingSector = LastSector + 1;

        ScsiDebugPrint(2,"SCSI ReadDriveCapacity: Sector size is %d\n",
            BytesPerSector);

        ScsiDebugPrint(2,"SCSI ReadDriveCapacity: Number of Sectors is %d\n",
            LastSector + 1);


#endif
    }

    if (status == EAGAIN || status == EBUSY) {

        if (retries--) {

            //
            // Retry request.
            //

            goto Retry;
        }
    }

    return status;

} // end ReadDriveCapacity()


ARC_STATUS
SendSrbSynchronous(
    PPARTITION_CONTEXT PartitionContext,
    PSCSI_REQUEST_BLOCK Srb,
    PVOID BufferAddress,
    ULONG BufferLength,
    BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine is called by SCSI device controls to complete an
    SRB and send it to the port driver synchronously (ie wait for
    completion).
    The CDB is already completed along with the SRB CDB size and
    request timeout value.

Arguments:

    PartitionContext
    SRB
    Buffer address and length (if transfer)

    WriteToDevice - Indicates the direction of the transfer.

Return Value:

    ARC_STATUS

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION IrpStack;
    ULONG retryCount = 1;
    ARC_STATUS status;

    //
    // Write length to SRB.
    //

    Srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set SCSI bus address.
    //

    Srb->PathId = PartitionContext->PathId;
    Srb->TargetId = PartitionContext->TargetId;
    Srb->Lun = PartitionContext->DiskId;

    Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    //
    // Enable auto request sense.
    //

    Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    if (SenseInfoBuffer == NULL) {
        // This DbgPrint has been commented out.  On IA64 and AXP64,
        // it crashes unless booted with a boot debugger.
        //("SendSrbSynchronous: Can't allocate request sense buffer\n");
        return(ENOMEM);
    }

    Srb->SenseInfoBuffer = SenseInfoBuffer;

    Srb->DataBuffer = BufferAddress;

    //
    // Start retries here.
    //

retry:

    Irp = InitializeIrp(
        &PrimarySrb,
        IRP_MJ_SCSI,
        PartitionContext->PortDeviceObject,
        BufferAddress,
        BufferLength
        );

    if (BufferAddress != NULL) {

        if (WriteToDevice) {

            Srb->SrbFlags = SRB_FLAGS_DATA_OUT;

        } else {

            Srb->SrbFlags = SRB_FLAGS_DATA_IN;

        }

    } else {

        //
        // Clear flags.
        //

        Srb->SrbFlags = SRB_FLAGS_NO_DATA_TRANSFER;
    }

    //
    // Disable synchronous transfers.
    //

    Srb->SrbFlags |= SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Set the transfer length.
    //

    Srb->DataTransferLength = BufferLength;

    //
    // Zero out status.
    //

    Srb->ScsiStatus = Srb->SrbStatus = 0;

    //
    // Get next stack location and
    // set major function code.
    //

    IrpStack = IoGetNextIrpStackLocation(Irp);


    //
    // Set up SRB for execute scsi request.
    // Save SRB address in next stack for port driver.
    //

    IrpStack->Parameters.Others.Argument1 = (PVOID)Srb;

    //
    // Set up IRP Address.
    //

    Srb->OriginalRequest = Irp;

    Srb->NextSrb = 0;

    //
    // No need to check the following 2 returned statuses as
    // SRB will have ending status.
    //

    (VOID)IoCallDriver(PartitionContext->PortDeviceObject, Irp);

    //
    // Check that request completed without error.
    //

    if (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        //
        // Update status and determine if request should be retried.
        //

        if (InterpretSenseInfo(Srb, &status, PartitionContext)) {

            //
            // If retries are not exhausted then
            // retry this operation.
            //

            if (retryCount--) {
                goto retry;
            }
        }

    } else {

        status = ESUCCESS;
    }

    return status;

} // end SendSrbSynchronous()


BOOLEAN
InterpretSenseInfo(
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT ARC_STATUS *Status,
    PPARTITION_CONTEXT PartitionContext
    )

/*++

Routine Description:

    This routine interprets the data returned from the SCSI
    request sense. It determines the status to return in the
    IRP and whether this request can be retried.

Arguments:

    DeviceObject
    SRB
    ARC_STATUS to update IRP

Return Value:

    BOOLEAN TRUE: Drivers should retry this request.
            FALSE: Drivers should not retry this request.

--*/

{
    PSENSE_DATA SenseBuffer = Srb->SenseInfoBuffer;
    BOOLEAN retry;

    //
    // Check that request sense buffer is valid.
    //

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        ScsiDebugPrint(2,"InterpretSenseInfo: Error code is %x\n",
                SenseBuffer->ErrorCode);

        ScsiDebugPrint(2,"InterpretSenseInfo: Sense key is %x\n",
                SenseBuffer->SenseKey);

        ScsiDebugPrint(2,"InterpretSenseInfo: Additional sense code is %x\n",
                SenseBuffer->AdditionalSenseCode);

        ScsiDebugPrint(2,"InterpretSenseInfo: Additional sense code qualifier is %x\n",
                SenseBuffer->AdditionalSenseCodeQualifier);

            switch (SenseBuffer->SenseKey) {

                case SCSI_SENSE_NOT_READY:

                    ScsiDebugPrint(1,"InterpretSenseInfo: Device not ready\n");

                    ScsiDebugPrint(1,"InterpretSenseInfo: Waiting for device\n");

                    *Status = EBUSY;

                    retry = TRUE;

                    switch (SenseBuffer->AdditionalSenseCode) {

                    case SCSI_ADSENSE_LUN_NOT_READY:

                        ScsiDebugPrint(1,"InterpretSenseInfo: Lun not ready\n");

                        switch (SenseBuffer->AdditionalSenseCodeQualifier) {

                        case SCSI_SENSEQ_BECOMING_READY:

                            ScsiDebugPrint(1,
                                        "InterpretSenseInfo:"
                                        " In process of becoming ready\n");

                            FwStallExecution( 1000 * 1000 * 3 );

                            break;

                        case SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED:

                            ScsiDebugPrint(1,
                                        "InterpretSenseInfo:"
                                        " Manual intervention required\n");
                           *Status = (ARC_STATUS)STATUS_NO_MEDIA_IN_DEVICE;
                            retry = FALSE;
                            break;

                        case SCSI_SENSEQ_FORMAT_IN_PROGRESS:

                            ScsiDebugPrint(1,
                                        "InterpretSenseInfo:"
                                        " Format in progress\n");
                            retry = FALSE;
                            break;

                        default:

                            FwStallExecution( 1000 * 1000 * 3 );

                            //
                            // Try a start unit too.
                            //

                        case SCSI_SENSEQ_INIT_COMMAND_REQUIRED:

                            ScsiDebugPrint(1,
                                        "InterpretSenseInfo:"
                                        " Initializing command required\n");

                            //
                            // This sense code/additional sense code
                            // combination may indicate that the device
                            // needs to be started.
                            //

                            ScsiDiskStartUnit(PartitionContext);
                            break;

                        }

                    } // end switch

                    break;

                case SCSI_SENSE_DATA_PROTECT:

                    ScsiDebugPrint(1,"InterpretSenseInfo: Media write protected\n");

                    *Status = EACCES;

                    retry = FALSE;

                    break;

                case SCSI_SENSE_MEDIUM_ERROR:

                    ScsiDebugPrint(1,"InterpretSenseInfo: Bad media\n");
                    *Status = EIO;

                    retry = TRUE;

                    break;

                case SCSI_SENSE_HARDWARE_ERROR:

                    ScsiDebugPrint(1,"InterpretSenseInfo: Hardware error\n");
                    *Status = EIO;

                    retry = TRUE;

                    break;

                case SCSI_SENSE_ILLEGAL_REQUEST:

                    ScsiDebugPrint(1,"InterpretSenseInfo: Illegal SCSI request\n");

                    switch (SenseBuffer->AdditionalSenseCode) {

                        case SCSI_ADSENSE_ILLEGAL_COMMAND:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Illegal command\n");
                            break;

                        case SCSI_ADSENSE_ILLEGAL_BLOCK:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Illegal block address\n");
                            break;

                        case SCSI_ADSENSE_INVALID_LUN:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Invalid LUN\n");
                            break;

                        case SCSI_ADSENSE_MUSIC_AREA:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Music area\n");
                            break;

                        case SCSI_ADSENSE_DATA_AREA:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Data area\n");
                            break;

                        case SCSI_ADSENSE_VOLUME_OVERFLOW:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Volume overflow\n");

                    } // end switch ...

                    *Status = EINVAL;

                    retry = FALSE;

                    break;

                case SCSI_SENSE_UNIT_ATTENTION:

                    ScsiDebugPrint(3,"InterpretSenseInfo: Unit attention\n");

                    switch (SenseBuffer->AdditionalSenseCode) {

                        case SCSI_ADSENSE_MEDIUM_CHANGED:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Media changed\n");
                            break;

                        case SCSI_ADSENSE_BUS_RESET:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Bus reset\n");

                    }

                    *Status = EAGAIN;

                    retry = TRUE;

                    break;

                case SCSI_SENSE_ABORTED_COMMAND:

                    ScsiDebugPrint(1,"InterpretSenseInfo: Command aborted\n");

                    *Status = EIO;

                    retry = TRUE;

                    break;

                case SCSI_SENSE_NO_SENSE:

                    ScsiDebugPrint(1,"InterpretSenseInfo: No specific sense key\n");

                    *Status = EIO;

                    retry = TRUE;

                    break;

                default:

                    ScsiDebugPrint(1,"InterpretSenseInfo: Unrecognized sense code\n");

                    *Status = (ARC_STATUS)STATUS_UNSUCCESSFUL;

                    retry = TRUE;

        } // end switch

    } else {

        //
        // Request sense buffer not valid. No sense information
        // to pinpoint the error. Return general request fail.
        //

        ScsiDebugPrint(1,"InterpretSenseInfo: Request sense info not valid\n");

        *Status = EIO;

        retry = TRUE;
    }

    //
    // If this is the primary srb, then reinitialize any bad scsi devices.
    //

    if (Srb == &PrimarySrb.Srb) {

        ScsiDiskFilterBad(PartitionContext);
    }

    return retry;

} // end InterpretSenseInfo()


VOID
RetryRequest(
    PPARTITION_CONTEXT PartitionContext,
    PIRP Irp
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PIO_STACK_LOCATION NextIrpStack = IoGetNextIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK Srb = &PrimarySrb.Srb;
    PMDL Mdl = Irp->MdlAddress;
    ULONG TransferByteCount = Mdl->ByteCount;


    //
    // Reset byte count of transfer in SRB Extension.
    //

    Srb->DataTransferLength = TransferByteCount;

    //
    // Zero SRB statuses.
    //

    Srb->SrbStatus = Srb->ScsiStatus = 0;

    //
    // Set up major SCSI function.
    //

    NextIrpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    NextIrpStack->Parameters.Others.Argument1 = (PVOID)Srb;

    //
    // Return the results of the call to the port driver.
    //

    (PVOID)IoCallDriver(PartitionContext->PortDeviceObject, Irp);

    return;

} // end RetryRequest()

PIRP
BuildRequest(
    IN PPARTITION_CONTEXT PartitionContext,
    IN PMDL Mdl,
    IN ULONG LogicalBlockAddress,
    IN BOOLEAN Operation
    )

/*++

Routine Description:

Arguments:

Note:

If the IRP is for a disk transfer, the byteoffset field
will already have been adjusted to make it relative to
the beginning of the disk. In this way, this routine can
be shared between the disk and cdrom class drivers.

    - Operation  TRUE specifies that this is a READ operation
                 FALSE specifies that this is a WRITE operation

Return Value:

--*/

{
    PIRP Irp = &PrimarySrb.Irp;
    PIO_STACK_LOCATION NextIrpStack;
    PSCSI_REQUEST_BLOCK Srb = &PrimarySrb.Srb;
    PCDB Cdb;
    USHORT TransferBlocks;

    //
    // Initialize the rest of the IRP.
    //

    Irp->MdlAddress = Mdl;

    Irp->Tail.Overlay.CurrentStackLocation = &PrimarySrb.IrpStack[IRP_STACK_SIZE];

    NextIrpStack = IoGetNextIrpStackLocation(Irp);

    //
    // Write length to SRB.
    //

    Srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set up IRP Address.
    //

    Srb->OriginalRequest = Irp;

    Srb->NextSrb = 0;

    //
    // Set up target id and logical unit number.
    //

    Srb->PathId = PartitionContext->PathId;
    Srb->TargetId = PartitionContext->TargetId;
    Srb->Lun = PartitionContext->DiskId;

    Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    Srb->DataBuffer = MmGetMdlVirtualAddress(Mdl);

    //
    // Save byte count of transfer in SRB Extension.
    //

    Srb->DataTransferLength = Mdl->ByteCount;

    //
    // Indicate auto request sense by specifying buffer and size.
    //

    Srb->SenseInfoBuffer = SenseInfoBuffer;

    Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    //
    // Set timeout value in seconds.
    //

    Srb->TimeOutValue = SCSI_DISK_TIMEOUT;

    //
    // Zero statuses.
    //

    Srb->SrbStatus = Srb->ScsiStatus = 0;

    //
    // Indicate that 10-byte CDB's will be used.
    //

    Srb->CdbLength = 10;

    //
    // Fill in CDB fields.
    //

    Cdb = (PCDB)Srb->Cdb;

    Cdb->CDB10.LogicalUnitNumber = PartitionContext->DiskId;

    TransferBlocks = (USHORT)(Mdl->ByteCount >> PartitionContext->SectorShift);

    //
    // Move little endian values into CDB in big endian format.
    //

    Cdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&LogicalBlockAddress)->Byte3;
    Cdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&LogicalBlockAddress)->Byte2;
    Cdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&LogicalBlockAddress)->Byte1;
    Cdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&LogicalBlockAddress)->Byte0;

    Cdb->CDB10.Reserved2 = 0;

    Cdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE)&TransferBlocks)->Byte1;
    Cdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE)&TransferBlocks)->Byte0;

    Cdb->CDB10.Control = 0;

    //
    // Set transfer direction flag and Cdb command.
    //

    if (Operation) {
        ScsiDebugPrint(3, "BuildRequest: Read Command\n");

        Srb->SrbFlags = SRB_FLAGS_DATA_IN;

        Cdb->CDB10.OperationCode = SCSIOP_READ;
    } else {
        ScsiDebugPrint(3, "BuildRequest: Write Command\n");

        Srb->SrbFlags = SRB_FLAGS_DATA_OUT;

        Cdb->CDB10.OperationCode = SCSIOP_WRITE;
    }

    //
    // Disable synchronous transfers.
    //

    Srb->SrbFlags |= SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Set up major SCSI function.
    //

    NextIrpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    NextIrpStack->Parameters.Others.Argument1 = (PVOID)Srb;

    return(Irp);

} // end BuildRequest()

VOID
ScsiDiskStartUnit(
    IN PPARTITION_CONTEXT PartitionContext
    )

/*++

Routine Description:

    Send command to SCSI unit to start or power up.
    Because this command is issued asynchronounsly, that is without
    waiting on it to complete, the IMMEDIATE flag is not set. This
    means that the CDB will not return until the drive has powered up.
    This should keep subsequent requests from being submitted to the
    device before it has completely spun up.
    This routine is called from the InterpretSense routine, when a
    request sense returns data indicating that a drive must be
    powered up.

Arguments:

    PartitionContext - structure containing pointer to port device driver.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION irpStack;
    PIRP irp;
    PSCSI_REQUEST_BLOCK srb = &AbortSrb.Srb;
    PSCSI_REQUEST_BLOCK originalSrb = &PrimarySrb.Srb;
    PCDB cdb;

    ScsiDebugPrint(1,"StartUnit: Enter routine\n");

    //
    // Write length to SRB.
    //

    srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set up SCSI bus address.
    //

    srb->PathId = originalSrb->PathId;
    srb->TargetId = originalSrb->TargetId;
    srb->Lun = originalSrb->Lun;

    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    //
    // Zero out status.
    //

    srb->ScsiStatus = srb->SrbStatus = 0;

    //
    // Set timeout value large enough for drive to spin up.
    // NOTE: This value is arbitrary.
    //

    srb->TimeOutValue = 30;

    //
    // Set the transfer length.
    //

    srb->DataTransferLength = 0;
    srb->SrbFlags = SRB_FLAGS_NO_DATA_TRANSFER | SRB_FLAGS_DISABLE_AUTOSENSE;
    srb->SenseInfoBufferLength = 0;
    srb->SenseInfoBuffer = NULL;

    //
    // Build the start unit CDB.
    //

    srb->CdbLength = 6;
    cdb = (PCDB)srb->Cdb;

    RtlZeroMemory(cdb, sizeof(CDB));

    cdb->CDB10.OperationCode = SCSIOP_START_STOP_UNIT;
    cdb->START_STOP.Start = 1;

    //
    // Build the IRP
    // to be sent to the port driver.
    //

    irp = InitializeIrp(
        &AbortSrb,
        IRP_MJ_SCSI,
        PartitionContext->PortDeviceObject,
        NULL,
        0
        );

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_SCSI;

    srb->OriginalRequest = irp;

    //
    // Save SRB address in next stack for port driver.
    //

    irpStack->Parameters.Others.Argument1 = srb;

    //
    // No need to check the following 2 returned statuses as
    // SRB will have ending status.
    //

    IoCallDriver(PartitionContext->PortDeviceObject, irp);

} // end StartUnit()


ULONG
ClassModeSense(
    IN PPARTITION_CONTEXT Context,
    IN PCHAR ModeSenseBuffer,
    IN ULONG Length,
    IN UCHAR PageMode
    )

/*++

Routine Description:

    This routine sends a mode sense command to a target id and returns
    when it is complete.

Arguments:

Return Value:

    Length of the transferred data is returned.

--*/
{
    PCDB cdb;
    PSCSI_REQUEST_BLOCK Srb = &PrimarySrb.Srb;
    ULONG retries = 1;
    NTSTATUS status;

    DebugPrint((3,"SCSI ModeSense: Enter routine\n"));

    //
    // Build the read capacity CDB.
    //

    Srb->CdbLength = 6;
    cdb = (PCDB)Srb->Cdb;

    //
    // Set timeout value.
    //

    Srb->TimeOutValue = 2;

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = PageMode;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)Length;

Retry:

    status = SendSrbSynchronous(Context,
                                Srb,
                                ModeSenseBuffer,
                                Length,
                                FALSE);


    if (status == EAGAIN || status == EBUSY) {

        //
        // Routine SendSrbSynchronous does not retry
        // requests returned with this status.
        // Read Capacities should be retried
        // anyway.
        //

        if (retries--) {

            //
            // Retry request.
            //

            goto Retry;
        }
    } else if (SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {
        status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(status)) {
        return(Srb->DataTransferLength);
    } else {
        return(0);
    }

} // end ClassModeSense()

PVOID
ClassFindModePage(
    IN PCHAR ModeSenseBuffer,
    IN ULONG Length,
    IN UCHAR PageMode
    )

/*++

Routine Description:

    This routine scans through the mode sense data and finds the requested
    mode sense page code.

Arguments:
    ModeSenseBuffer - Supplies a pointer to the mode sense data.

    Length - Indicates the length of valid data.

    PageMode - Supplies the page mode to be searched for.

Return Value:

    A pointer to the the requested mode page.  If the mode page was not found
    then NULL is return.

--*/
{
    PUCHAR limit;

    limit = ModeSenseBuffer + Length;

    //
    // Skip the mode select header and block descriptors.
    //

    if (Length < sizeof(MODE_PARAMETER_HEADER)) {
        return(NULL);
    }

    ModeSenseBuffer += sizeof(MODE_PARAMETER_HEADER) +
        ((PMODE_PARAMETER_HEADER) ModeSenseBuffer)->BlockDescriptorLength;

    //
    // ModeSenseBuffer now points at pages walk the pages looking for the
    // requested page until the limit is reached.
    //

    while (ModeSenseBuffer < limit) {

        if (((PMODE_DISCONNECT_PAGE) ModeSenseBuffer)->PageCode == PageMode) {
            return(ModeSenseBuffer);
        }

        //
        // Adavance to the next page.
        //

        ModeSenseBuffer += ((PMODE_DISCONNECT_PAGE) ModeSenseBuffer)->PageLength + 2;
    }

    return(NULL);

}

BOOLEAN
IsFloppyDevice(
    PPARTITION_CONTEXT Context
    )
/*++

Routine Description:

    The routine performs the necessary functioons to determinee if a device is
    really a floppy rather than a harddisk.  This is done by a mode sense
    command.  First, a check is made to see if the medimum type is set.  Second
    a check is made for the flexible parameters mode page.

Arguments:

    Context - Supplies the device object to be tested.

Return Value:

    Return TRUE if the indicated device is a floppy.

--*/
{

    PVOID modeData;
    PUCHAR pageData;
    ULONG length;

    modeData = ExAllocatePool(NonPagedPoolCacheAligned, MODE_DATA_SIZE);

    if (modeData == NULL) {
        return(FALSE);
    }

    RtlZeroMemory(modeData, MODE_DATA_SIZE);

    length = ClassModeSense(Context,
                            modeData,
                            MODE_DATA_SIZE,
                            MODE_SENSE_RETURN_ALL);

    if (length < sizeof(MODE_PARAMETER_HEADER)) {

        //
        // Retry the request in case of a check condition.
        //

        length = ClassModeSense(Context,
                                modeData,
                                MODE_DATA_SIZE,
                                MODE_SENSE_RETURN_ALL);

        if (length < sizeof(MODE_PARAMETER_HEADER)) {

            ExFreePool(modeData);
            return(FALSE);

        }
    }
#if 0
    if (((PMODE_PARAMETER_HEADER) modeData)->MediumType >= MODE_FD_SINGLE_SIDE
        && ((PMODE_PARAMETER_HEADER) modeData)->MediumType <= MODE_FD_MAXIMUM_TYPE) {

        DebugPrint((1, "Scsidisk: MediumType value %2x, This is a floppy.\n", ((PMODE_PARAMETER_HEADER) modeData)->MediumType));
        ExFreePool(modeData);
        return(TRUE);
    }
#endif

    //
    // Look for the flexible disk mode page.
    //

    pageData = ClassFindModePage( modeData, length, MODE_PAGE_FLEXIBILE);

    if (pageData != NULL) {

        DebugPrint((1, "Scsidisk: Flexible disk page found, This is a floppy.\n"));
        ExFreePool(modeData);
        return(TRUE);

    }

    ExFreePool(modeData);
    return(FALSE);

} // end IsFloppyDevice()

VOID
ScsiDiskFilterBad(
    IN PPARTITION_CONTEXT PartitionContext
    )

/*++

Routine Description:

    This routine looks for SCSI units which need special initialization
    to operate correctly.

Arguments:

    PartitionContext - structure containing pointer to port device driver.

Return Value:

    None.

--*/
{
    PSCSI_REQUEST_BLOCK srb = &AbortSrb.Srb;
    PCDB cdb;
    PDEVICE_EXTENSION scsiPort;
    PSCSI_CONFIGURATION_INFO configInfo;
    PSCSI_BUS_SCAN_DATA busScanData;
    PUCHAR modePage;
    ULONG busNumber;
    PLUNINFO lunInfo;
    PINQUIRYDATA inquiryData;

    ScsiDebugPrint(3,"FilterBad: Enter routine\n");

    scsiPort = PartitionContext->PortDeviceObject->DeviceExtension;
    configInfo = scsiPort->ScsiInfo;

    //
    // Search the configuration database for scsi disk and cdrom devices
    // which require special initializaion.
    //

    for (busNumber=0; busNumber < (ULONG)configInfo->NumberOfBuses; busNumber++) {

        busScanData = configInfo->BusScanData[busNumber];

        //
        // Set LunInfo to beginning of list.
        //

        lunInfo = busScanData->LunInfoList;

        while (lunInfo != NULL) {

            inquiryData = (PVOID)lunInfo->InquiryData;

            //
            // Determin if this is the correct lun.
            //

            if (PartitionContext->PathId == lunInfo->PathId &&
                PartitionContext->TargetId == lunInfo->TargetId &&
                PartitionContext->DiskId == lunInfo->Lun) {

                goto FoundOne;
            }

            //
            // Get next LunInfo.
            //

            lunInfo = lunInfo->NextLunInfo;
        }
    }

    return;

FoundOne:



    //
    // Zero out status.
    //

    srb->ScsiStatus = srb->SrbStatus = 0;

    //
    // Set timeout value.
    //

    srb->TimeOutValue = 2;

    //
    // Look for a bad devices.
    //

    if (strncmp(inquiryData->VendorId, "HITACHI CDR-1750S", strlen("HITACHI CDR-1750S")) == 0 ||
        strncmp(inquiryData->VendorId, "HITACHI CDR-3650/1650S", strlen("HITACHI CDR-3650/1650S")) == 0) {

        ScsiDebugPrint(1, "ScsiDiskFilterBad:  Found Hitachi CDR-1750S.\n");

        //
        // Found a bad HITACHI cd-rom.  These devices do not work with PIO
        // adapters when read-ahead is enabled.  Read-ahead is disabled by
        // a mode select command.  The mode select page code is zero and the
        // length is 6 bytes.  All of the other bytes should be zero.
        //

        modePage = ExAllocatePool(NonPagedPool, HITACHI_MODE_DATA_SIZE);

        if (modePage == NULL) {
            return;
        }

        RtlZeroMemory(modePage, HITACHI_MODE_DATA_SIZE);

        //
        // Set the page length field to 6.
        //

        modePage[5] = 6;

        //
        // Build the mode select CDB.
        //

        srb->CdbLength = 6;
        cdb = (PCDB)srb->Cdb;

        RtlZeroMemory(cdb, sizeof(CDB));

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.ParameterListLength = HITACHI_MODE_DATA_SIZE;

        //
        // Send the request to the device.
        //

        SendSrbSynchronous(PartitionContext,
                           srb,
                           modePage,
                           HITACHI_MODE_DATA_SIZE,
                           TRUE);

        ExFreePool(modePage);
    }

} // end ScsiDiskFilterBad()

BOOLEAN
CheckFileId(
    ULONG FileId
    )
{

    if (BlFileTable[FileId].u.PartitionContext.PortDeviceObject != NULL) {
        return TRUE;
    }

#if 0
    DbgPrint("\n\rScsidisk: Bad file id passed to read or write.  FileId = %lx\n", FileId);
    DbgPrint("Start sector = %lx; Ending sector = %lx; Disk Id = %x; DeviceUnit = %x\n",
        BlFileTable[FileId].u.PartitionContext.StartingSector,
        BlFileTable[FileId].u.PartitionContext.EndingSector,
        BlFileTable[FileId].u.PartitionContext.DiskId,
        BlFileTable[FileId].u.PartitionContext.DeviceUnit
        );

   DbgPrint("Target Id = %d; Path Id = %d; Sector Shift = %lx; Size = %lx\n",
        BlFileTable[FileId].u.PartitionContext.TargetId,
        BlFileTable[FileId].u.PartitionContext.PathId,
        BlFileTable[FileId].u.PartitionContext.SectorShift,
        BlFileTable[FileId].u.PartitionContext.Size
        );

   DbgPrint("Hit any key\n");
   while(!GET_KEY());  // DEBUG ONLY!
#endif
   return FALSE;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\vga.c ===
//
// vga routines
//

#include "bldr.h"
#include "vga.h"
#include "cmdcnst.h"

PUCHAR VgaBase = (PUCHAR)0xa0000;
PUCHAR VgaRegisterBase = (PUCHAR)0;

//
// globals to track screen position
//

#define DELTA 80L

BOOLEAN
VgaInterpretCmdStream(
    PUSHORT pusCmdStream
    );

UCHAR lMaskTable[8] = {0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01};
UCHAR rMaskTable[8] = {0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff};
UCHAR PixelMask[8]  = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};

//
// Initialize AT registers
//

USHORT AT_Initialization[] = {

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    16,                             // count
    0,                              // start index
    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD

};

ULONG lookup[16] =
{
    0x00000000,
    0x00000100,
    0x00001000,
    0x00001100,
    0x00000001,
    0x00000101,
    0x00001001,
    0x00001101,
    0x00000010,
    0x00000110,
    0x00001010,
    0x00001110,
    0x00000011,
    0x00000111,
    0x00001011,
    0x00001111
};

void __outpw(int p, int v)
{
    WRITE_PORT_USHORT((PUSHORT)(p+VgaRegisterBase), (USHORT)v);
}

void __outpb(int p, int v)
{
    WRITE_PORT_UCHAR((PUCHAR)(p+VgaRegisterBase), (UCHAR)v);
}

VOID
ReadWriteMode(
    ULONG mode
    )
{
    UCHAR value;

    WRITE_PORT_UCHAR((PUCHAR)(VgaRegisterBase+0x3ce), 5);
    value = READ_PORT_UCHAR((PUCHAR)(VgaRegisterBase+0x3cf));

    value &= 0xf4;
    value |= mode;

    WRITE_PORT_UCHAR((PUCHAR)(VgaRegisterBase+0x3cf), value);
}

VOID
SetPixel(
    ULONG x,
    ULONG y,
    ULONG color
    )
{
    PUCHAR pDst;
    ULONG  bank;

    bank = x >> 3;

    pDst = (char *)(VgaBase + y * DELTA + bank);

    ReadWriteMode(0x8 | 0x2);
    __outpw(0x3c4, 0x0f02); // enable all write planes
    __outpw(0x3ce, 0x0007); // set color don't care register to zero
    __outpw(0x3ce, (PixelMask[x & 0x7] << 8) | 8);

    WRITE_REGISTER_UCHAR(pDst, (UCHAR)(READ_REGISTER_UCHAR(pDst) & ((UCHAR)color)));
}

VOID
VidSolidColorFill(
    ULONG x1,
    ULONG y1,
    ULONG x2,
    ULONG y2,
    ULONG color
    )
{
    PUCHAR pDst;
    ULONG x, y;
    ULONG bank1, bank2, count;
    ULONG lMask, rMask;

    lMask = (lMaskTable[x1 & 0x7] << 8) | 8;
    rMask = (rMaskTable[x2 & 0x7] << 8) | 8;

    bank1 = x1 >> 3;
    bank2 = x2 >> 3;
    count = bank2 - bank1;

    if (!count) {
        lMask = lMask & rMask;
    }

    ReadWriteMode(0x8 | 0x2);

    __outpw(0x3c4, 0x0f02); // enable writing to all color planes
    __outpw(0x3ce, 0x0007); // set color don't care register to zero

    //
    // Do the left edge
    //

    pDst = (char *)(VgaBase + y1 * DELTA + bank1);

    __outpw(0x3ce, lMask);

    for (y=y1; y<=y2; y++) {

	WRITE_REGISTER_UCHAR(pDst, (UCHAR)(READ_REGISTER_UCHAR(pDst) & (UCHAR) color));
        pDst += DELTA;
    }

    if (count) {

        //
        // Do the right edge
        //

        pDst = (char *)(VgaBase + y1 * DELTA + bank2);
        count--;
        __outpw(0x3ce, rMask);

        for (y=y1; y<=y2; y++) {
	    WRITE_REGISTER_UCHAR(pDst, (UCHAR)(READ_REGISTER_UCHAR(pDst) & (UCHAR) color));
            pDst += DELTA;
        }

        //
        // Do the center section
        //

        if (count) {

            pDst = (char *)(VgaBase + y1 * DELTA + bank1 + 1);
            __outpw(0x3ce, 0xff08);

            for (y=y1; y<=y2; y++) {

                for (x=0; x<count; x++) {
		    WRITE_REGISTER_UCHAR(pDst++,  (unsigned char) color);
                }
                pDst += DELTA - count;
            }

        }
    }
}

VOID
RleBitBlt(
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    PUCHAR Buffer
    )

/*++

Routine Description:

    This routine displays an RLE 4 bitmap.

Arguments:

    x, y - location at which to display the bitmap.

    width, height - height of the bitmap

    Buffer - Pointer to the compressed bitmap data.

--*/

{
    BOOLEAN Done = FALSE;
    PUCHAR p = Buffer;
    ULONG RunLength;
    LONG RunExtra;
    ULONG curr_x, curr_y;
    ULONG Color1, Color2;

    curr_x = x;
    curr_y = y + height - 1;

    while (!Done) {

        if (*p) {

            RunLength = (ULONG) *p++;

            //
            // Make sure we don't draw past end of scan.
            //

            if ((curr_x + RunLength) > (x + width))
                RunLength -= (curr_x + RunLength) - (width + x);

            Color1 = (*p   & 0xf0) >> 4;
            Color2 = (*p++ & 0x0f);

            if (Color1 == Color2) {

                ULONG end_x = curr_x + RunLength - 1;

                VidSolidColorFill(curr_x,
                                  curr_y,
                                  end_x,
                                  curr_y,
                                  Color1);

                curr_x += RunLength;

            } else {

                while (RunLength > 1) {
                    SetPixel(curr_x++, curr_y, Color1);
                    SetPixel(curr_x++, curr_y, Color2);
                    RunLength -= 2;
                }

                if (RunLength) {
                    SetPixel(curr_x, curr_y, Color1);
                    curr_x++;
                }
            }

        } else {

            p++;

            switch (*p) {

            case 0:  curr_x = x;
                     curr_y--;
                     p++;
                     break;

            case 1:  Done = TRUE;
                     p++;
                     break;

            case 2:  p++;
                     curr_x += (ULONG) *p++;
                     curr_y -= (ULONG) *p++;
                     break;

            default: RunLength = (ULONG) *p++;

                     //
                     // Make sure we don't draw past end of scan.
                     //

                     if ((curr_x + RunLength) > (x + width)) {
                         RunExtra = (curr_x + RunLength) - (width + x);
                         RunLength -= RunExtra;
                     } else {
                         RunExtra = 0;
                     }

                     while (RunLength > 1) {

                         Color1 = (*p   & 0xf0) >> 4;
                         Color2 = (*p++ & 0x0f);

                         SetPixel(curr_x++, curr_y, Color1);
                         SetPixel(curr_x++, curr_y, Color2);

                         RunLength -= 2;
                     }

                     if (RunLength) {
                         Color1 = (*p++ & 0xf0) >> 4;
                         SetPixel(curr_x++, curr_y, Color1);
                         RunExtra--;
                     }

                     //
                     // Read any remaining "extra" run data.
                     //

                     while (RunExtra > 0) {
                         p++;
                         RunExtra -= 2;
                     }

                     if ((ULONG_PTR)p & 1) p++;  // make sure we are word aligned

                     break;
            }
        }
    }
}

VOID
BitBlt(
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    PUCHAR Buffer,
    ULONG bpp,
    LONG ScanWidth
    )
{
    ULONG i, j;
    ULONG color=8;

    if (bpp == 4) {

        UCHAR Plane[81];
        ULONG lMask, rMask, count;
        ULONG bank1, bank2, bank;
        ULONG bRightEdge = FALSE, bCenterSection = FALSE;
        UCHAR value;
        ULONG plane;
        UCHAR Mask;
        ULONG toggle;
        PUCHAR pSrc, pSrcTemp;
        PUCHAR pDst, pDstTemp;
        UCHAR PlaneMask;

        lMask = lMaskTable[x & 0x7];
        rMask = rMaskTable[(x + width - 1) & 0x7];

        bank1 = x >> 3;
        bank2 = (x + width - 1) >> 3;

        count = bank2 - bank1;

        if (bank1 == bank2) {

            lMask = lMask & rMask;

        }

        if (count) {

            bRightEdge = TRUE;

            count--;

            if (count) {

                bCenterSection = TRUE;
            }
        }

        pDst = (PUCHAR)(VgaBase + (y * DELTA) + (x / 8));
        pSrc = Buffer;

        ReadWriteMode(0x0 | 0x0);

        for (j=0; j<height; j++) {

            for (plane=0; plane<4; plane++) {

                pSrcTemp = pSrc;
                pDstTemp = pDst;

                PlaneMask = 1 << plane;

                //
                // Convert the packed bitmap data into planar data
                // for this plane.
                //
                // BUGBUG: My guess this is going to be a hot spot, so
                // I need to revist this and optimize!!  But for now
                // make it work.
                //

                bank = bank1;
                Plane[bank] = 0;
                Mask = PixelMask[x & 0x7];
                toggle = 0;

                for (i=0; i<width; i++) {

                    if (toggle++ & 0x1) {

                        if (*pSrcTemp & PlaneMask) {
                            Plane[bank] |= Mask;
                        }

                        pSrcTemp++;

                    } else {

                        if (((*pSrcTemp) >> 4) & PlaneMask) {
                            Plane[bank] |= Mask;
                        }
                    }

                    Mask >>= 1;

                    if (!Mask) {

                        bank++;
                        Plane[bank] = 0;
                        Mask = 0x80;
                    }
                }

                //
                // Set up the vga so that we see the correct bit plane.
                //

                __outpw(0x3c4, (1 << (plane + 8)) | 2);

                //
                // bank will go from bank1 to bank2
                //

                bank = bank1;
                pDstTemp = pDst;


                //
                // Set Bitmask for left edge.
                //

                __outpw(0x3ce, (lMask << 8) | 8);

		value = READ_REGISTER_UCHAR(pDstTemp);

                value &= ~lMask;
                value |= Plane[bank++];

		WRITE_REGISTER_UCHAR(pDstTemp++, value);

                if (bCenterSection) {

                    __outpw(0x3ce, 0xff08);  // enable writing to all bits

                    for (i=0; i<count; i++) {

			WRITE_REGISTER_UCHAR(pDstTemp++, Plane[bank++]);
                    }
                }

                if (bRightEdge) {

                    //
                    // Set bitmask for right edge.
                    //

                    __outpw(0x3ce, (rMask << 8) | 8);

		    value = READ_REGISTER_UCHAR(pDstTemp);

                    value &= ~rMask;
                    value |= Plane[bank];

		    WRITE_REGISTER_UCHAR(pDstTemp, value);
                }
            }

            pDst += DELTA;
            pSrc += ScanWidth;
        }

    } else {

        PUCHAR pDst, pDstTemp;
        PUCHAR pSrc, pSrcTemp;
        ULONG count;
        UCHAR Value;
        ULONG lMask, rMask;
        ULONG bank1, bank2;
        ULONG plane;
        UCHAR colorMask;

        bank1 = x >> 8;
        bank2 = (x + width - 1) >> 8;

        lMask = lMaskTable[x & 7];
        rMask = rMaskTable[(x + width - 1) & 7];

        if (bank1 == bank2) {

            lMask &= rMask;
        }

        lMask = ~lMask;
        rMask = ~rMask;

        pSrc = Buffer;
        pDst = (PUCHAR)(VgaBase + (y * DELTA) + (x / 8));

        ReadWriteMode(0x0 | 0x0);

        for (j=0; j<height; j++) {

            plane = 1;
            for (i=0; i<4; i++) {

                pDstTemp = pDst;
                pSrcTemp = pSrc;

                __outpw(0x3c4, (plane << 8) | 2);

                colorMask = (UCHAR)((color & plane) ? 0xff : 0x00);

                plane <<= 1;  // bump up each time through loop

                count = width;

                //
                // non aligned case
                //

                if (x & 7) {

                    //
                    // Left Edge.
                    //

		    Value = READ_REGISTER_UCHAR(pDstTemp);

                    Value &= lMask;
                    Value |= (*pSrcTemp >> x) & colorMask;

		    WRITE_REGISTER_UCHAR(pDstTemp++, Value);

                    count -= (8 - x);

                    //
                    // Now do center section
                    //

                    while (count > 7) {

                        Value = (*pSrcTemp << (8 - x)) | (*(pSrcTemp+1) >> x);
                        Value &= colorMask;

			WRITE_REGISTER_UCHAR(pDstTemp++, Value);

                        pSrcTemp++;
                        count -= 8;
                    }

                    //
                    // Now do the right edge.
                    //

                    if (count) {

			Value = READ_REGISTER_UCHAR(pDstTemp);

                        Value &= rMask;
                        Value |= *pSrcTemp << (8 - x) & colorMask;

			WRITE_REGISTER_UCHAR(pDstTemp++, Value);
                    }

                } else {

                    //
                    // Aligned case.
                    //

                    ULONG  ulColorMask = colorMask ? 0xffffffff : 0x00000000;
                    USHORT usColorMask = colorMask ? 0xffff : 0x0000;

                    while (count > 31) {

			WRITE_REGISTER_ULONG(((PULONG)pDstTemp)++, (ULONG)((*((PULONG)pSrcTemp)++) & ulColorMask));
                        count -= 32;
                    }

                    while (count > 15) {

			WRITE_REGISTER_USHORT(((PUSHORT)pDstTemp)++, (USHORT)((*((PUSHORT)pSrcTemp)++) & usColorMask));
                        count -= 16;
                    }

                    if (count > 7) {

			WRITE_REGISTER_UCHAR(pDstTemp++, (UCHAR)(*pSrcTemp++ & colorMask));
                        count -= 8;
                    }

                    //
                    // Now do any remaining bits.
                    //

                    if (count) {

			Value = READ_REGISTER_UCHAR(pDstTemp);

                        Value &= rMask;
                        Value |= *pSrcTemp & colorMask;

			WRITE_REGISTER_UCHAR(pDstTemp++, Value);
                    }
                }
            }

            pSrc += ScanWidth;
            pDst += DELTA;
        }
    }
}

VOID
VidBitBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y
    )

/*++

Routine Description:

    This routine takes a bitmap resource and displays it at a given
    location.

Arguments:

    Buffer - Pointer to the bitmap resource.

    x, y - The position at which to display the bitmap.

--*/

{
    PBITMAPFILEHEADER bfh;
    PBITMAPINFOHEADER bih;
    PRGBQUAD          Palette;

    LONG lDelta;
    PUCHAR pBuffer;
    LONG cbScanLine;

    bih = (PBITMAPINFOHEADER) Buffer;

    Palette = (PRGBQUAD)(((PUCHAR)bih) + bih->biSize);

    //
    // BUGBUG: I need to add some bitmap validation code here!
    //

    cbScanLine = (((bih->biWidth * bih->biBitCount) + 31) & ~31) >> 3;

    pBuffer = (PUCHAR)(Buffer + sizeof(BITMAPINFOHEADER) + 64);

    if (bih->biCompression == BI_RLE4) {

        if (bih->biWidth && bih->biHeight) {
            RleBitBlt(x,
                      y,
                      bih->biWidth,
                      bih->biHeight,
                      pBuffer);
        }

    } else {

        if (bih->biHeight < 0) {

            // top down bitmap
            lDelta = cbScanLine;
            bih->biHeight = -bih->biHeight;

        } else {

            // bottom up bitmap
            pBuffer += cbScanLine * (bih->biHeight - 1);
            lDelta = -cbScanLine;
        }

        if (bih->biWidth && bih->biHeight) {
            BitBlt(x,
                   y,
                   bih->biWidth,
                   bih->biHeight,
                   pBuffer,
                   bih->biBitCount,
                   lDelta);
        }
    }

}

VOID
VidScreenToBufferBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    ULONG lDelta
    )

/*++

Routine Description:

    This routine allows you to copy a portion of video memory into
    system memory.

Arguments:

    Buffer - Points to system memory where the video image should be copied.

    x, y - X,Y coordinates in video memory of top-left portion of image.

    width, height - width and height of the image in pixels.

    lDelta - width of the buffer in bytes.

Notes:

    Upon completion, the video memory image will be in system memory.  Each
    plane of the image are stored seperately, so the first scan line of
    plane 0 will be followed by the first scan line of plane 1, etc.  Then
    the second scan of plane 0, plane 1, and so on.

--*/

{
    ULONG Plane, i, j, BankStart, BankEnd;
    PUCHAR pSrc, pSrcTemp, pDst;
    PULONG pulDstTemp;
    UCHAR Val1, Val2;
    ULONG Shift1, Shift2;
    UCHAR ucCombined;
    ULONG ulCombined;

    BankStart = x >> 3;
    BankEnd = (x + width - 1) >> 3;
    Shift1 = x & 7;
    Shift2 = 8 - Shift1;

    //
    // Zero initialize the buffer so we can or in the bits later!
    //

    pDst = Buffer;
    memset(pDst, 0, lDelta * height);

    for (Plane=0; Plane<4; Plane++) {

        pSrc = (PUCHAR)(VgaBase + (DELTA * y) + BankStart);
        pDst = Buffer;

        ReadWriteMode(0x0 | 0x0);            // set read mode 0
        __outpw(0x3ce, (Plane << 8) | 0x04); // read from given plane

        for (j=0; j<height; j++) {

            pSrcTemp = pSrc;
            pulDstTemp = (PULONG)pDst;

	    Val1 = READ_REGISTER_UCHAR(pSrcTemp++);

            for (i=BankStart; i<=BankEnd; i++) {

		Val2 = READ_REGISTER_UCHAR(pSrcTemp++);

                ucCombined = (Val1 << Shift1) | (Val2 >> Shift2);
                ulCombined = ((lookup[(ucCombined & 0x0f) >> 0] << 16) |
                               lookup[(ucCombined & 0xf0) >> 4]) << Plane;


                *pulDstTemp++ |= ulCombined;

                Val1 = Val2;
            }

            pSrc += DELTA;   // go to next video memory scan line
            pDst += lDelta;  // go to next scan for this plane in buffer
        }
    }
}

void VidBufferToScreenBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    ULONG lDelta
    )

/*++

Routine Description:

    This routine allows you to copy a portion of video memory into
    system memory.

Arguments:

    Buffer - Points to system memory where the video image should be copied
             from.

    x, y - X,Y coordinates in video memory of top-left portion of image.

    width, height - width and height of the image in pixels.

    lDelta - width of the buffer in bytes.

Notes:

    This routine will allow you to blt from a buffer filled by
    VidScreenToBufferBlt.

--*/

{
    if (width && height) {
        BitBlt(x,
               y,
               width,
               height,
               Buffer,
               4,
               lDelta);
    }
}


#pragma optimize( "", off )

VOID
SetPaletteEntryRGB(
    ULONG index,
    RGBQUAD rgb
    )
{
    __outpb(0x3c8, index);
    __outpb(0x3c9, rgb.rgbRed   >> 2);
    __outpb(0x3c9, rgb.rgbGreen >> 2);
    __outpb(0x3c9, rgb.rgbBlue  >> 2);
}

VOID
VgaEnableVideo()
{
	VgaInterpretCmdStream (AT_Initialization);
}

VOID
InitPaletteConversionTable()
{
	/*
	UCHAR n;

	READ_PORT_UCHAR((PUCHAR)(VgaRegisterBase+INPUT_STATUS_1_COLOR));

	for (n=0; n<16; n++) {	//	Initializing table of active palette entries.
		WRITE_PORT_UCHAR((PUCHAR)(VgaRegisterBase+ATT_ADDRESS_PORT), n);
		WRITE_PORT_UCHAR((PUCHAR)(VgaRegisterBase+ATT_ADDRESS_PORT), n);
	}
	*/
	VgaEnableVideo();
}

VOID
InitializePalette(
    VOID
    )
{
    ULONG Palette[] =
    {
        0x00000000,
        0x00000020,
        0x00002000,
        0x00002020,
        0x00200000,
        0x00200020,
        0x00202000,
        0x00202020,
        0x00303030,
        0x0000003f,
        0x00003f00,
        0x00003f3f,
        0x003f0000,
        0x003f003f,
        0x003f3f00,
        0x003f3f3f,
    };
    ULONG i;

    for (i=0; i<16; i++) {
		PRGBQUAD p = (PRGBQUAD)(Palette+i);
        SetPaletteEntryRGB(i, *p);
    }

}

VOID
InitPaletteWithTable(
    PRGBQUAD Palette,
    ULONG count
    )
{
    UCHAR i;
	InitPaletteConversionTable();
	count = 16;
    for (i=0; i<count; i++)
        SetPaletteEntryRGB (i, *Palette++);
}

VOID
InitPaletteWithBlack(
    VOID
    )
{
    ULONG i;
	// RGBQUAD black = {0x3f,0x3f,0x3f,0x3f};
	RGBQUAD black = {0,0,0,0};
	InitPaletteConversionTable();
	//InitializePalette();

    for (i=0; i<16; i++)
        SetPaletteEntryRGB(i, black);
}

VOID
WaitForVsync(
    VOID
    )

/*++

Routine Description:

    Wait for a v-sync

--*/

{
    //
    // Check to see if vsync's are being generated.
    //

    WRITE_PORT_UCHAR((VgaRegisterBase+0x3c4), 00);

    if (READ_PORT_UCHAR(VgaRegisterBase+0x3c5) & 0x2) {

        ULONG MaxDelay;

        //
        // Slight delay.  Wait for one vsync.
        //

        MaxDelay = 100000;
	while (((READ_PORT_UCHAR(VgaRegisterBase+0x3da) & 0x08) == 0x08) && MaxDelay--);
        MaxDelay = 100000;
	while (((READ_PORT_UCHAR(VgaRegisterBase+0x3da) & 0x08) == 0x00) && MaxDelay--);
    }
}

BOOLEAN
VgaInterpretCmdStream(
    PUSHORT pusCmdStream
    )

/*++

Routine Description:

    Interprets the appropriate command array to set up VGA registers for the
    requested mode. Typically used to set the VGA into a particular mode by
    programming all of the registers

Arguments:

    pusCmdStream - array of commands to be interpreted.

Return Value:

    The status of the operation (can only fail on a bad command); TRUE for
    success, FALSE for failure.

--*/

{
    ULONG ulCmd;
    ULONG_PTR ulPort;
    UCHAR jValue;
    USHORT usValue;
    ULONG culCount;
    ULONG ulIndex;
    ULONG_PTR ulBase;

    if (pusCmdStream == NULL) {

        //KdPrint(("VgaInterpretCmdStream: pusCmdStream == NULL\n"));
        return TRUE;
    }

    ulBase = (ULONG_PTR) VgaRegisterBase;

    //
    // Now set the adapter to the desired mode.
    //

    while ((ulCmd = *pusCmdStream++) != EOD) {

        WaitForVsync();

        //
        // Determine major command type
        //

        switch (ulCmd & 0xF0) {

            //
            // Basic input/output command
            //

            case INOUT:

                //
                // Determine type of inout instruction
                //

                if (!(ulCmd & IO)) {

                    //
                    // Out instruction. Single or multiple outs?
                    //

                    if (!(ulCmd & MULTI)) {

                        //
                        // Single out. Byte or word out?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // Single byte out
                            //

                            ulPort = *pusCmdStream++;
                            jValue = (UCHAR) *pusCmdStream++;
                            WRITE_PORT_UCHAR((PUCHAR)(ulBase+ulPort),
                                    jValue);

                        } else {

                            //
                            // Single word out
                            //

                            ulPort = *pusCmdStream++;
                            usValue = *pusCmdStream++;
                            WRITE_PORT_USHORT((PUSHORT)(ulBase+ulPort),
                                    usValue);

                        }

                    } else {

                        //
                        // Output a string of values
                        // Byte or word outs?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // String byte outs. Do in a loop; can't use
                            // VideoPortWritePortBufferUchar because the data
                            // is in USHORT form
                            //

                            ulPort = ulBase + *pusCmdStream++;
                            culCount = *pusCmdStream++;

                            while (culCount--) {
                                jValue = (UCHAR) *pusCmdStream++;
                                WRITE_PORT_UCHAR((PUCHAR)ulPort,
                                        jValue);

                            }

                        } else {

                            //
                            // String word outs
                            //

                            ulPort = *pusCmdStream++;
                            culCount = *pusCmdStream++;
                            WRITE_PORT_BUFFER_USHORT((PUSHORT)
                                    (ulBase + ulPort), pusCmdStream, culCount);
                            pusCmdStream += culCount;

                        }
                    }

                } else {

                    // In instruction
                    //
                    // Currently, string in instructions aren't supported; all
                    // in instructions are handled as single-byte ins
                    //
                    // Byte or word in?
                    //

                    if (!(ulCmd & BW)) {
                        //
                        // Single byte in
                        //

                        ulPort = *pusCmdStream++;
                        jValue = READ_PORT_UCHAR((PUCHAR)ulBase+ulPort);

                    } else {

                        //
                        // Single word in
                        //

                        ulPort = *pusCmdStream++;
                        usValue = READ_PORT_USHORT((PUSHORT)
                                (ulBase+ulPort));

                    }

                }

                break;

            //
            // Higher-level input/output commands
            //

            case METAOUT:

                //
                // Determine type of metaout command, based on minor
                // command field
                //
                switch (ulCmd & 0x0F) {

                    //
                    // Indexed outs
                    //

                    case INDXOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            usValue = (USHORT) (ulIndex +
                                      (((ULONG)(*pusCmdStream++)) << 8));
                            WRITE_PORT_USHORT((PUSHORT)ulPort, usValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // Masked out (read, AND, XOR, write)
                    //

                    case MASKOUT:

                        ulPort = *pusCmdStream++;
                        jValue = READ_PORT_UCHAR((PUCHAR)ulBase+ulPort);
                        jValue &= *pusCmdStream++;
                        jValue ^= *pusCmdStream++;
                        WRITE_PORT_UCHAR((PUCHAR)ulBase + ulPort,
                                jValue);
                        break;

                    //
                    // Attribute Controller out
                    //

                    case ATCOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            // Write Attribute Controller index
                            WRITE_PORT_UCHAR((PUCHAR)ulPort,
                                    (UCHAR)ulIndex);

                            // Write Attribute Controller data
                            jValue = (UCHAR) *pusCmdStream++;
                            WRITE_PORT_UCHAR((PUCHAR)ulPort, jValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // None of the above; error
                    //
                    default:

                        return FALSE;

                }


                break;

            //
            // NOP
            //

            case NCMD:

                break;

            //
            // Unknown command; error
            //

            default:

                return FALSE;

        }

    }
    return TRUE;

} // end VgaInterpretCmdStream()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\vmode.c ===
#include "bldrx86.h"
#include "vmode.h"
#include "vga.h"

#define	SCREEN_WIDTH			(640)					/*	gfx mode resolution: width		*/
#define	SCREEN_HEIGHT			(480)					/*	gfx mode resolution: height		*/
#define	SCREEN_PIXELS			(SCREEN_WIDTH * SCREEN_HEIGHT)

#define VGA_ADR					((UCHAR*)0xA0000)		/*	beginning of VGA memory			*/
#define LINE_MEM_LENGTH			(SCREEN_WIDTH / 8)		/*	1 bit per pixel in every map	*/
#define MAP_PAGE_SZ				(64*1024)               /*	size of single map				*/

#define PROGRESS_BAR_MEM_OFS	(LINE_MEM_LENGTH * (SCREEN_HEIGHT - 40))	/*	starts at 20th line from the bottom	*/

#define BOOTBMP_FNAME "boot.bmp"
#define DOTSBMP_FNAME "dots.bmp"

BOOLEAN DisplayLogoOnBoot = FALSE;
BOOLEAN GraphicsMode = FALSE;

VOID
GrDisplayMBCSChar(
    IN PUCHAR   image,
    IN unsigned width,
    IN UCHAR    top,
    IN UCHAR    bottom
    );

extern unsigned CharacterImageHeight;

extern BOOLEAN  BlShowProgressBar;
extern int      BlMaxFilesToLoad;
extern int      BlNumFilesLoaded;


NTLDRGRAPHICSCONTEXT LoaderGfxContext = {0,0L,0L,0L,NULL /*,EINVAL,EINVAL*/};

#define DIAMETER (6)

VOID BlRedrawGfxProgressBar(VOID)	//	Redraws the progress bar (with the last percentage) 
{   
    if (BlShowProgressBar && BlMaxFilesToLoad) {
        BlUpdateProgressBar((BlNumFilesLoaded * 100) / BlMaxFilesToLoad);
	}
}    

#define	BMP_FILE_SIZE		(1024*1024)

#define	SMALL_BMP_SIZE		(1024)

UCHAR	empty_circle	[SMALL_BMP_SIZE];
UCHAR	simple_circle	[SMALL_BMP_SIZE];
UCHAR	left_2_circles	[SMALL_BMP_SIZE];
UCHAR	left_3_circles	[SMALL_BMP_SIZE];
UCHAR	left_4_circles	[SMALL_BMP_SIZE];
UCHAR	right_2_circles	[SMALL_BMP_SIZE];
UCHAR	right_3_circles	[SMALL_BMP_SIZE];
UCHAR	right_4_circles	[SMALL_BMP_SIZE];

#define	DOT_WIDTH	(13)
#define	DOT_HEIGHT	(13)
#define DOT_BLANK	(7)

#define	PROGRESS_BAR_Y_OFS	(340)
#define	PROGRESS_BAR_X_OFS	(130)
#define DOTS_IN_PBAR		(20)

#define	BITS(w)			((w)*4)
#define	BYTES(b)		(((b)/8)+(((b)%8)?1:0))
#define	DOTS(n)			(((n)*DOT_WIDTH)+(((n)-1)*DOT_BLANK))
#define	DOTS2BYTES(n)	(BYTES(BITS(DOTS(n))))

#define	SCANLINE	(7)

// #define INC_MOD(x) x = (x + 1) % (DOTS_IN_PBAR+5)
#define INC_MOD(x) x = (x + 1)

VOID PrepareGfxProgressBar (VOID)
{
	ULONG i=0;

    if (DisplayLogoOnBoot) {

		PaletteOff ();
        /*
		VidBitBlt (LoaderGfxContext.DotBuffer + sizeof(BITMAPFILEHEADER), 0, 0);

		VidScreenToBufferBlt (simple_circle,	0,							0,	DOTS(1),	DOT_HEIGHT,	 DOTS2BYTES(1));
		VidScreenToBufferBlt (left_2_circles,	0,							0,	DOTS(2),	DOT_HEIGHT,	 DOTS2BYTES(2));
		VidScreenToBufferBlt (left_3_circles,	0,							0,	DOTS(3),	DOT_HEIGHT,	 DOTS2BYTES(3));
		VidScreenToBufferBlt (left_4_circles,	0,							0,	DOTS(4),	DOT_HEIGHT,	 DOTS2BYTES(4));
		VidScreenToBufferBlt (right_2_circles,	3*(DOT_WIDTH+DOT_BLANK),	0,	DOTS(2),	DOT_HEIGHT,	 DOTS2BYTES(2));
		VidScreenToBufferBlt (right_3_circles,	2*(DOT_WIDTH+DOT_BLANK),	0,	DOTS(3),	DOT_HEIGHT,	 DOTS2BYTES(3));
		VidScreenToBufferBlt (right_4_circles,	DOT_WIDTH+DOT_BLANK,		0,	DOTS(4),	DOT_HEIGHT,	 DOTS2BYTES(4));
        */
		DrawBitmap ();
		// VidScreenToBufferBlt (empty_circle, PROGRESS_BAR_X_OFS, PROGRESS_BAR_Y_OFS, DOTS(1), DOT_HEIGHT, DOTS2BYTES(1));
		PaletteOn();

	}
	
}

VOID BlUpdateGfxProgressBar(ULONG fPercentage)
{
	static ULONG current = 0;
	static ULONG delay = 5;
	ULONG i = 0;
	ULONG x, xl;
    ULONG dots = fPercentage; // (fPercentage * (DOTS_IN_PBAR+5)) / 100;

    /*
    if (delay && delay--)
        return;

    if (DisplayLogoOnBoot && (current<(DOTS_IN_PBAR+5))) {

        x  = PROGRESS_BAR_X_OFS + ((current-5) * (DOT_WIDTH+DOT_BLANK));

		switch (current) {

		case 0:
   			VidBufferToScreenBlt (simple_circle,	PROGRESS_BAR_X_OFS,	PROGRESS_BAR_Y_OFS,	DOTS(1), DOT_HEIGHT, DOTS2BYTES(1));
            break;

		case 1:
   			VidBufferToScreenBlt (right_2_circles,	PROGRESS_BAR_X_OFS,	PROGRESS_BAR_Y_OFS,	DOTS(2), DOT_HEIGHT, DOTS2BYTES(2));
            break;

		case 2:
   			VidBufferToScreenBlt (right_3_circles,	PROGRESS_BAR_X_OFS,	PROGRESS_BAR_Y_OFS,	DOTS(3), DOT_HEIGHT, DOTS2BYTES(3));
            break;

		case 3:
   			VidBufferToScreenBlt (right_4_circles,	PROGRESS_BAR_X_OFS,	PROGRESS_BAR_Y_OFS,	DOTS(4), DOT_HEIGHT, DOTS2BYTES(4));
            break;

        case DOTS_IN_PBAR:
            xl = PROGRESS_BAR_X_OFS + ((DOTS_IN_PBAR-4) * (DOT_WIDTH+DOT_BLANK));
   			VidBufferToScreenBlt (left_4_circles,	xl,	PROGRESS_BAR_Y_OFS,	DOTS(4),	DOT_HEIGHT, DOTS2BYTES(4));
            VidBufferToScreenBlt (empty_circle,	x,	PROGRESS_BAR_Y_OFS,	DOTS(1),	    DOT_HEIGHT,	DOTS2BYTES(1));
            break;

        case DOTS_IN_PBAR+1:
            xl = PROGRESS_BAR_X_OFS + ((DOTS_IN_PBAR-3) * (DOT_WIDTH+DOT_BLANK));
   			VidBufferToScreenBlt (left_3_circles,	xl,	PROGRESS_BAR_Y_OFS,	DOTS(3),	DOT_HEIGHT, DOTS2BYTES(3));
            VidBufferToScreenBlt (empty_circle,	x,	PROGRESS_BAR_Y_OFS,	DOTS(1),	    DOT_HEIGHT,	DOTS2BYTES(1));
            break;

        case DOTS_IN_PBAR+2:
            xl = PROGRESS_BAR_X_OFS + ((DOTS_IN_PBAR-2) * (DOT_WIDTH+DOT_BLANK));
   			VidBufferToScreenBlt (left_2_circles,	xl,	PROGRESS_BAR_Y_OFS,	DOTS(2),	DOT_HEIGHT, DOTS2BYTES(2));
            VidBufferToScreenBlt (empty_circle,	x,	PROGRESS_BAR_Y_OFS,	DOTS(1),	    DOT_HEIGHT,	DOTS2BYTES(1));
            break;

        case DOTS_IN_PBAR+3:
            xl = PROGRESS_BAR_X_OFS + ((DOTS_IN_PBAR-1) * (DOT_WIDTH+DOT_BLANK));
   			VidBufferToScreenBlt (simple_circle,	xl,	PROGRESS_BAR_Y_OFS,	DOTS(1),	DOT_HEIGHT, DOTS2BYTES(1));
            VidBufferToScreenBlt (empty_circle,	x,	PROGRESS_BAR_Y_OFS,	DOTS(1),	    DOT_HEIGHT,	DOTS2BYTES(1));
            break;

        case DOTS_IN_PBAR+4:
            VidBufferToScreenBlt (empty_circle,	x,	PROGRESS_BAR_Y_OFS,	DOTS(1),	    DOT_HEIGHT,	DOTS2BYTES(1));
            break;

		default:
			xl = PROGRESS_BAR_X_OFS + ((current-4) * (DOT_WIDTH+DOT_BLANK));
			VidBitBlt (LoaderGfxContext.DotBuffer + sizeof(BITMAPFILEHEADER),	xl,	PROGRESS_BAR_Y_OFS);
            VidBufferToScreenBlt (empty_circle,	x,	PROGRESS_BAR_Y_OFS,	DOTS(1),	    DOT_HEIGHT,	DOTS2BYTES(1));
			break;

		}

		INC_MOD(current);

	}
    */

}

PUCHAR LoadBitmapFile (IN ULONG DriveId, PCHAR path)
{
    ULONG bmp_file = -1;
    ULONG file_size, size_read, page_count, actual_base;
	FILE_INFORMATION FileInfo;
	ARC_STATUS status = EINVAL;
	PUCHAR buffer = NULL;

    status = BlOpen (DriveId, path, ArcOpenReadOnly, &bmp_file);

	if (status==ESUCCESS) {	//	file opened Ok

	    status = BlGetFileInformation(bmp_file, &FileInfo);

		if (status == ESUCCESS) {
			
			file_size = FileInfo.EndingAddress.LowPart;
			page_count = (ULONG)(ROUND_TO_PAGES(file_size) >> PAGE_SHIFT);
			status = BlAllocateDescriptor ( MemoryFirmwareTemporary,
											0,
											page_count,
											&actual_base);

			if (status == ESUCCESS) {
				buffer = (PCHAR)((ULONG_PTR)actual_base << PAGE_SHIFT);
				status = BlRead(bmp_file, buffer, file_size, &size_read);
			}

		} // getting file information

		BlClose(bmp_file);

	} // file opening

	return buffer;
}

VOID PaletteOff (VOID)
{
    if (DisplayLogoOnBoot) {
		InitPaletteConversionTable();
		InitPaletteWithBlack ();
	}
}

VOID PaletteOn (VOID)
{
    if (DisplayLogoOnBoot) {
		InitPaletteConversionTable();
		InitPaletteWithTable(LoaderGfxContext.Palette, LoaderGfxContext.ColorsUsed);
	}
}

VOID LoadBootLogoBitmap (IN ULONG DriveId, PCHAR path)	//	Loads ntldr bitmap and initializes
{														//	loader graphics context.
    PBITMAPINFOHEADER bih;
	CHAR path_fname [256];

    while (*path !='\\')
        path++;

	strcpy (path_fname, path);
	strcat (path_fname, "\\" BOOTBMP_FNAME);

	LoaderGfxContext.BmpBuffer = LoadBitmapFile (DriveId, path_fname);

	// read bitmap palette
	if (LoaderGfxContext.BmpBuffer != NULL) {	//	bitmap data read Ok
		bih = (PBITMAPINFOHEADER) (LoaderGfxContext.BmpBuffer + sizeof(BITMAPFILEHEADER));
		LoaderGfxContext.Palette = (PRGBQUAD)(((PUCHAR)bih) + bih->biSize);
		LoaderGfxContext.ColorsUsed = bih->biClrUsed ? bih->biClrUsed : 16;

        /*
		strcpy (path_fname, path);
		strcat (path_fname, "\\" DOTSBMP_FNAME);
		LoaderGfxContext.DotBuffer = LoadBitmapFile (DriveId, path_fname);
        */
	}

	DisplayLogoOnBoot = (LoaderGfxContext.BmpBuffer!=NULL)	&&
						// (LoaderGfxContext.DotBuffer!=NULL)	&&
						(LoaderGfxContext.Palette!=NULL);
	
}

VOID DrawBitmap (VOID)
{
    if (DisplayLogoOnBoot)
		VidBitBlt (LoaderGfxContext.BmpBuffer + sizeof(BITMAPFILEHEADER), 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=boot
TARGETPATH=obj
TARGETTYPE=LIBRARY

!IF "$(BUILD_DEBUG_LOADER)" != ""
!include $(PROJECT_ROOT)\boot\loader_dbg.inc
!ELSE
!include $(PROJECT_ROOT)\boot\loader.inc
!ENDIF

INCLUDES= \
    $(SDK_INC_PATH);\
    $(PROJECT_ROOT)\boot\inc;\
    $(DS_INC_PATH);\
    $(DS_INC_PATH)\crypto;\
    $(PROJECT_ROOT)\hals;\
    $(PROJECT_ROOT)\hals\inc;\
    $(PROJECT_ROOT)\ntos\inc;\
    $(PROJECT_ROOT)\fs\fastfat;\
    $(PROJECT_ROOT)\fs\cdfs;\
    $(PROJECT_ROOT)\fs\udfs;\
    $(PROJECT_ROOT)\fs\ntfs;\
    $(PROJECT_ROOT)\ntos\config;\
    ..\$(TARGET_DIRECTORY);\
    $(DDK_INC_PATH);\
    $(HALKIT_INC_PATH);

!IF 0
NOTE : To force CD/DVD boot while starting setupldr from harddisk use
       FORCE_CD_BOOT

C_DEFINES=$(C_DEFINES) -DFORCE_CD_BOOT
!ENDIF

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\arcdisk.c  \
        ..\blmemory.c \
        ..\blbind.c   \
        ..\blconfig.c \
        ..\blgpt.c    \
        ..\blio.c     \
        ..\blload.c   \
        ..\blres.c    \
        ..\debug.c    \
        ..\etfsboot.c \
        ..\fatboot.c  \
        ..\ntfsboot.c \
        ..\cdfsboot.c \
        ..\udfsboot.c \
        ..\netboot.c  \
        ..\nlsboot.c  \
        ..\parseini.c \
        ..\hdlsterm.c \
        ..\peldr.c    \
        ..\bllog.c    \
        ..\blmisc.c   \
        ..\blcache.c  \
        ..\blrange.c  \
        ..\vmode.c    \
        ..\vga.c      \
        ..\blsecret.c \
        ..\blstring.c \
        ..\ramdisk.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\vga.h ===
/*++

Copyright (c) 1990-1997  Microsoft Corporation

Module Name:

    vga.h

Author:

    Erick Smith (ericks) Oct. 1997

Environment:

    kernel mode only

Revision History:

--*/

//
// VGA register definitions
//

#define CRTC_ADDRESS_PORT_MONO      0x03b4  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x03b5  // Data registers in mono mode
#define FEAT_CTRL_WRITE_PORT_MONO   0x03bA  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x03bA  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data

#define ATT_ADDRESS_PORT            0x03c0  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x03c0  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x3C0
#define ATT_DATA_READ_PORT          0x03c1  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x03c2  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x03c2  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x03c3  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x03c4  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x03c5  // Data registers
#define DAC_PIXEL_MASK_PORT         0x03c6  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x03c7  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x03c7  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x03c8  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x03c9  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x03cA  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x03cC  // Miscellaneous Output reg read
                                            // port
#define GRAPH_ADDRESS_PORT          0x03cE  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x03cF  // and Data registers

#define CRTC_ADDRESS_PORT_COLOR     0x03d4  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x03d5  // Data registers in color mode
#define FEAT_CTRL_WRITE_PORT_COLOR  0x03dA  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x03dA  // Input Status 1 register read
                                            // port in color mode
#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode

//
// VGA indexed register indexes.
//

#define IND_CURSOR_START        0x0A    // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B    //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E    // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F    //  High and Low Registers
#define IND_VSYNC_END           0x11    // index in CRTC of the Vertical Sync
                                        //  End register, which has the bit
                                        //  that protects/unprotects CRTC
                                        //  index registers 0-7
#define IND_SET_RESET_ENABLE    0x01    // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03    // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04    // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05    // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06    // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08    // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00    // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02    // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04    // index of Memory Mode reg in Seq
#define IND_CRTC_PROTECT        0x11    // index of reg containing regs 0-7 in
                                        //  CRTC

#define START_SYNC_RESET_VALUE  0x01    // value for Sync Reset reg to start
                                        //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03    // value for Sync Reset reg to end
                                        //  synchronous reset

//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

#define VGA_NUM_SEQUENCER_PORTS     5
#define VGA_NUM_CRTC_PORTS         25
#define VGA_NUM_GRAPH_CONT_PORTS    9
#define VGA_NUM_ATTRIB_CONT_PORTS  21
#define VGA_NUM_DAC_ENTRIES       256

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00

//
// prototypes
//

#define BI_RLE4 2

#pragma pack(1)

typedef struct _BITMAPFILEHEADER {

    USHORT bfType;
    ULONG bfSize;
    USHORT bfReserved1;
    USHORT bfReserved2;
    ULONG bfOffBits;
} BITMAPFILEHEADER, *PBITMAPFILEHEADER;

typedef struct _BITMAPINFOHEADER {

    ULONG biSize;
    LONG biWidth;
    LONG biHeight;
    USHORT biPlanes;
    USHORT biBitCount;
    ULONG biCompression;
    ULONG biSizeImage;
    LONG biXPelsPerMeter;
    LONG biYPelsPerMeter;
    ULONG biClrUsed;
    ULONG biClrImportant;
} BITMAPINFOHEADER, *PBITMAPINFOHEADER;

typedef struct _RGBQUAD {

    UCHAR rgbBlue;
    UCHAR rgbGreen;
    UCHAR rgbRed;
    UCHAR rgbReserved;
} RGBQUAD, *PRGBQUAD;

typedef struct _NTLDRGRAPHICSCONTEXT {
	UCHAR		VgaGfxProgressBarColor;
	PUCHAR		BmpBuffer;				//	Bitmap buffer
	PUCHAR		DotBuffer;				//	Dots bitmap buffer
	ULONG		ColorsUsed;
	RGBQUAD*	Palette;				//	pointer to the palette in BmpBuffer (dots MUST have the same palette)
} NTLDRGRAPHICSCONTEXT;

#pragma pack()

////////////////////////////////////////////////////////////////////////////////

VOID
SetPixel(
    ULONG x,
    ULONG y,
    ULONG color
    );

VOID
BitBlt(
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    PUCHAR Buffer,
    ULONG bpp,
    LONG ScanWidth
    );

VOID
SetPaletteEntryRGB(
    ULONG index,
    RGBQUAD rgb
    );

VOID
InitPaletteConversionTable();


VOID
InitPaletteWithBlack(
    VOID
    );

VOID
InitPaletteWithTable(
    PRGBQUAD Palette,
    ULONG count
    );

VOID
VidBitBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y
    );

VOID
VidScreenToBufferBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    ULONG lDelta
    );

void
VidBufferToScreenBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    ULONG lDelta
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\udfsboot.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

  UdfsBoot.c

Abstract:

  Implements UDF File System Reader for reading UDF volumes from DVD/CD.

  Note : Read ISO-13346(ECMA-167) and UDF 2.0 document to understand the
  UDF format. UDF is a subset for ECMA-167 standard.

Author:

  Vijayachandran Jayaseelan (vijayj@microsoft.com)

Revision History:

  None

--*/


#ifdef UDF_TESTING

#include <tbldr.h>    // to test this code from user mode

#else

#include "bootlib.h"
#include "blcache.h"

//#define UDF_DEBUG  1
//#define SHOW_UDF_USAGE 1
#endif // for UDF_TESTING

#include "udfsboot.h"

#include <udf.h>    // predefined IS0-13346 & UDF structures

#define UDFS_ALIGN_BUFFER(Buffer, Size) (PVOID) \
        ((((ULONG_PTR)(Buffer) + Size - 1)) & (~((ULONG_PTR)Size - 1)))

#ifndef UNALIGNED
#define UNALIGNED
#endif

#ifdef UDF_DEBUG

ULONG
BlGetKey(
    VOID
    );

#define DBG_PAUSE while (!BlGetKey())

VOID
BlClearScreen(
    VOID
    );

    VOID
BlPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    );

#endif // for UDF_DEBUG

//
// Global Data
//
BOOTFS_INFO UdfsBootFsInfo = {L"udfs"};

//
// Volume table(s) for all the volumes on different devices
//
UDF_VOLUME                  UDFVolumes[UDF_MAX_VOLUMES];

//
// UDF file system methods
//
BL_DEVICE_ENTRY_TABLE   UDFSMethods;

//
// Per Volume Cache which contains the traversed UDF directories and currently
// opened UDF files.
//
// N.B. Its being assumed here that this reader would be reading files from
// relatively few (may be 1 or 2) directorie(s) which are not nested deeply
//
UDF_CACHE_ENTRY           UDFCache[UDF_MAX_VOLUMES][UDF_MAX_CACHE_ENTRIES];


#ifdef __cplusplus
#define extern "C" {
#endif

//
// Internal Types
//
typedef enum _COMPARISON_RESULTS {
    LessThan = -1,
    EqualTo = 0,
    GreaterThan = 1
} COMPARISON_RESULTS;

//
// Macros
//
#define MIN(_a,_b) (((_a) <= (_b)) ? (_a) : (_b))
#define UDF_ROUND_TO(X, Y)  (((X) % (Y)) ? (X) + (Y) - ((X) % (Y)) : (X))
#define TOUPPER(C) ((((C) >= 'a') && ((C) <= 'z')) ? (C) - 'a' + 'A' : (C))

// file entry operations
#define FILE_ENTRY_TO_VOLUME(X) (((PUDFS_STRUCTURE_CONTEXT)((X)->StructureContext))->\
                                      Volume)
#define FILE_ENTRY_TO_FILE_CONTEXT(X) ((PUDFS_FILE_CONTEXT)&((X)->u.UdfsFileContext))

// NSR_FID operations
#define UDF_FID_NAME(X) (((PUCHAR)(X)) + 38 + (X)->ImpUseLen)
#define UDF_FID_LEN(X)  UDF_ROUND_TO((X)->FileIDLen + (X)->ImpUseLen + 38, 4)
#define UDF_BLOCK_TO_FID(X, Y) ((NSR_FID UNALIGNED *)(((PUCHAR)(X)) + (Y)->Offset))
#define UDF_FID_IS_DIRECTORY(X) ((((NSR_FID UNALIGNED *)(X))->Flags & NSR_FID_F_DIRECTORY) ? TRUE : FALSE)
#define UDF_FID_IS_PARENT(X) ((((NSR_FID UNALIGNED *)(X))->Flags & NSR_FID_F_PARENT) ? TRUE : FALSE)
#define UDF_FID_IS_DELETED(X) ((((NSR_FID UNALIGNED *)(X))->Flags & NSR_FID_F_DELETED) ? TRUE : FALSE)
#define UDF_FID_IS_HIDDEN(X) ((((NSR_FID UNALIGNED *)(X))->Flags & NSR_FID_F_HIDDEN) ? TRUE : FALSE)
#define UDF_FID_SKIP(X) (UDF_FID_IS_PARENT(X) || UDF_FID_IS_DELETED(X) || UDF_FID_IS_HIDDEN(X))

// ICBFILE operations
#define UDF_ICB_IS_DIRECTORY(X) ((X)->Icbtag.FileType == ICBTAG_FILE_T_DIRECTORY)
#define UDF_ICB_NUM_ADS(X) ((X)->AllocLength / sizeof(SHORTAD))
#define UDF_ICB_GET_AD_BUFFER(X) (((PUCHAR)&((X)->AllocLength)) + 4 + (X)->EALength)
#define UDF_ICB_GET_AD(X, Y) (((SHORTAD UNALIGNED *)UDF_ICB_GET_AD_BUFFER(X)) + (Y))

//
//  Local procedure prototypes.
//
ARC_STATUS
UDFSReadDisk(
    IN ULONG DeviceId,
    IN ULONG BlockIdx,
    IN ULONG Size,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    );

COMPARISON_RESULTS
UDFSCompareAnsiNames(
    IN PSTRING Name1,
    IN PSTRING Name2
    );

COMPARISON_RESULTS
UDFSCompareStrings(
    IN PCHAR Str1,
    IN PCHAR Str2
    );

BOOLEAN
UDFSVerifyPathName(
  IN PCHAR Name
  );

BOOLEAN
UDFSGetPathComponent(
  IN PCHAR Name,
  IN USHORT ComponentIdx,
  OUT PCHAR ReqComponent
  );

USHORT
UDFSCountPathComponents(
  IN PCHAR Name
  );

ULONG
UDFCacheGetBestEntryByName(
  IN PUDF_CACHE_ENTRY,
  IN PCHAR Name
  );

VOID
UDFSInitUniStrFromDString(
  OUT PUNICODE_STRING UniStr,
  IN PUCHAR Buffer,
  IN ULONG Length
  );

int
UDFSCompareAnsiUniNames(
    IN CSTRING AnsiString,
    IN UNICODE_STRING UnicodeString
    );

#ifdef __cplusplus
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Implementation
//
/////////////////////////////////////////////////////////////////////////////

ARC_STATUS
UDFSInitialize(
    VOID
    )
/*++

Routine Description:

  Initialize file system specific data structures.

Arguments:

  None

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  //
  // fill in the global device entry table
  //
  UDFSMethods.Open = UDFSOpen;
  UDFSMethods.Close = UDFSClose;
  UDFSMethods.Read = UDFSRead;
  UDFSMethods.Write = UDFSWrite;
  UDFSMethods.Seek = UDFSSeek;
  UDFSMethods.GetFileInformation = UDFSGetFileInformation;
  UDFSMethods.SetFileInformation = UDFSSetFileInformation;

  return ESUCCESS;
}


PBL_DEVICE_ENTRY_TABLE
IsUDFSFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    )

/*++

Routine Description:

    This routine determines if the partition on the specified channel
    contains a UDF file system volume.

Arguments:

    DeviceId - Supplies the file table index for the device on which
        read operations are to be performed.

    StructureContext - Supplies a pointer to a UDFS file structure context.

Return Value:

    A pointer to the UDFS entry table is returned if the partition is
    recognized as containing a UDFS volume. Otherwise, NULL is returned.

--*/

{
  PBL_DEVICE_ENTRY_TABLE  DevMethods = 0;
  ULONG Index;
  ULONG FreeSlot = UDF_MAX_VOLUMES;

  //
  // make sure that we have not mounted the file system on
  // the device already
  //
  for (Index=0; Index < UDF_MAX_VOLUMES; Index++) {
      if ((UDFVolumes[Index].DeviceId == DeviceId) &&
                  (UDFVolumes[Index].Cache != 0)) {
          break;
      }

      if ((!UDFVolumes[Index].Cache) && (FreeSlot == UDF_MAX_VOLUMES))
          FreeSlot = Index;
  }

  if ((Index == UDF_MAX_VOLUMES) && (FreeSlot != UDF_MAX_VOLUMES)) {
    if (UDFSVolumeOpen(UDFVolumes + FreeSlot, DeviceId) == ESUCCESS) {
      UDF_FILE_DIRECTORY  RootDir;
      PUDF_VOLUME Volume = UDFVolumes + FreeSlot;
      UCHAR UBlock[UDF_BLOCK_SIZE + 256] = {0};
      PUCHAR Block = ALIGN_BUFFER(UBlock);
      BOOLEAN Result = FALSE;

      DevMethods = &UDFSMethods;

      // save off the volume context
      ((PUDFS_STRUCTURE_CONTEXT)StructureContext)->Volume = Volume;

      // initialize cache
      Volume->Cache = UDFCache[FreeSlot];

      //
      // Read and Cache the root directory
      //
      RootDir.Volume = Volume;
      RootDir.FileId.BlockIdx = -1; // invalid
      RootDir.FileId.Offset = -1;   // invalid
      RootDir.IsDirectory = TRUE;
      RootDir.IcbBlk = Volume->RootDirBlk;

      if (UDFSReadDisk(Volume->DeviceId, Volume->StartBlk + RootDir.IcbBlk,
                              UDF_BLOCK_SIZE, Block, CACHE_NEW_DATA) == ESUCCESS) {
        ICBFILE UNALIGNED *Icb = (ICBFILE UNALIGNED *)Block;

        if (Icb->Destag.Ident == DESTAG_ID_NSR_FILE) {
          RootDir.Size = Icb->InfoLength;
          RootDir.StartDataBlk = UDF_ICB_GET_AD(Icb, 0)->Start;
          RootDir.NumExtents = (UCHAR)UDF_ICB_NUM_ADS(Icb);
          Result = (UDFCachePutEntry(Volume->Cache, "\\", &RootDir) != -1);
        }
      }

      if (!Result) {
        memset(Volume, 0, sizeof(UDF_VOLUME));
        DevMethods = 0;
      }
    }
  }
  else {
    // use already mounted volume
      if (Index != UDF_MAX_VOLUMES) {
          DevMethods = &UDFSMethods;
          ((PUDFS_STRUCTURE_CONTEXT)StructureContext)->Volume =
              UDFVolumes + Index;
      }
  }

  return DevMethods;
}

//
// Volume methods
//
ARC_STATUS
UDFSVolumeOpen(
    IN PUDF_VOLUME  Volume,
    IN ULONG        DeviceId
    )
/*++

Routine Description:

  Mounts the UDFS Volume on the device and updates the
  file system state (global data structures)

Arguments:

  Volume - UDF Volume pointer
  DeviceId - Device on which the Volume may be residing

Return Value:

  ESUCCESS if successful otherwise EBADF (if no UDF volume was found)

--*/
{
  ARC_STATUS  Status = ESUCCESS;
  UCHAR       UBlock[UDF_BLOCK_SIZE+256] = {0};
  PUCHAR      Block = ALIGN_BUFFER(UBlock);
  ULONG       BlockIdx = 256;
  ULONG       LastBlock = 0;

  while (Status == ESUCCESS) {
    // get hold of Anchor Volume Descriptor
        Status = UDFSReadDisk(DeviceId, BlockIdx, UDF_BLOCK_SIZE, Block, CACHE_NEW_DATA);

    if (Status == ESUCCESS) {
      NSR_ANCHOR  UNALIGNED *Anchor = (NSR_ANCHOR UNALIGNED *)Block;

      Status = EBADF;

      if (Anchor->Destag.Ident == DESTAG_ID_NSR_ANCHOR) {
          // get partition descriptor
          NSR_PART UNALIGNED *Part;
          WCHAR    UNALIGNED *TagID;
          ULONG     BlockIdx = Anchor->Main.Lsn;

        do {
          Status = UDFSReadDisk(DeviceId, BlockIdx++, UDF_BLOCK_SIZE, Block, CACHE_NEW_DATA);
          TagID = (WCHAR UNALIGNED *)Block;
        }
        while ((Status == ESUCCESS) && (*TagID) &&
               (*TagID != DESTAG_ID_NSR_TERM) && (*TagID != DESTAG_ID_NSR_PART));

        if ((Status == ESUCCESS) && (*TagID == DESTAG_ID_NSR_PART)){
          Part = (NSR_PART UNALIGNED *)Block;

          if (strstr(Part->ContentsID.Identifier, "+NSR")){
            Volume->DeviceId = DeviceId;
            Volume->StartBlk = Part->Start;
            Volume->BlockSize = UDF_BLOCK_SIZE;

            // get FSD at partition starting
            if (UDFSVolumeReadBlock(Volume, 0, Block) == ESUCCESS) {
              NSR_FSD UNALIGNED *FileSet = (NSR_FSD UNALIGNED *)Block;
              ULONG RootDirBlk = FileSet->IcbRoot.Start.Lbn;

              // get hold of root directory entry
              if (UDFSVolumeReadBlock(Volume, RootDirBlk, Block) == ESUCCESS) {
                  ICBFILE UNALIGNED *RootDir = (ICBFILE UNALIGNED *)Block;

                if (RootDir->Destag.Ident == DESTAG_ID_NSR_FILE) {
                    Volume->RootDirBlk = RootDirBlk;
                    Status = ESUCCESS;

                    break;
                }
              }
            }
          }
        }
      }
    }

    /*
    //
    // AVD should be at atleast two of the following locations
    // 256, N and N - 256
    //
    if (Status != ESUCCESS) {
      if (BlockIdx == 256) {
        FILE_INFORMATION  FileInfo;

        Status = BlGetFileInformation(DeviceId, &FileInfo);

        if (Status == ESUCCESS) {
          LastBlock = (ULONG)((FileInfo.EndingAddress.QuadPart - FileInfo.StartingAddress.QuadPart) /
                          UDF_BLOCK_SIZE);

          if (LastBlock) {
            LastBlock--;
            BlockIdx = LastBlock;
            Status = ESUCCESS;
          }
        }
      } else {
        if (LastBlock > 256) {
          BlockIdx = LastBlock - 256;
          Status = ESUCCESS;
        }
      }
    }
    */
  }

  return Status;
}

ARC_STATUS
UDFSVolumeReadBlock(
    IN PUDF_VOLUME Volume,
    IN ULONG BlockIdx,
    OUT PUDF_BLOCK Block
    )
/*++

Routine Description:

  Reads a logical UDF block w.r.t to the given Volume

Arguments:

  Volume - Pointer to UDF_VOLUME on which the block is to
           be read
  BlockIdx - Logical (zero based) index w.r.t to Volume start
  Block - Buffer to read the block into.

Return Value:

  ESSUCESS if the block is read successfully otherwise appropriate
  error code.

--*/
{
    ARC_STATUS  Result;

  // TBD : add range checking
    Result = UDFSReadDisk(
                Volume->DeviceId,
                Volume->StartBlk + BlockIdx,
                UDF_BLOCK_SIZE,
                Block,
                DONT_CACHE_NEW_DATA
                );

    return Result;
}

ARC_STATUS
UDFSOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    )
/*++

Routine Description:

  Opens the required file/directory on a UDF volume residing
  on the specified device.

Arguments:

  OpenPath  - Fully qualified path to the file/directory to open
  OpenMode  - Required Open Mode
  FileId    - File identifier as an index to BlFileTable which
              has to be updated for file/dir properties

Return Value:

  ESUCCESS if successful otherwise appropriate error code.

--*/
{
  ARC_STATUS Status;
  PBL_FILE_TABLE FileEntry = BlFileTable + (*FileId);
  PUDF_VOLUME Volume = FILE_ENTRY_TO_VOLUME(FileEntry);
  PUDF_CACHE_ENTRY    Cache = Volume->Cache;
  ULONG CacheIdx = UDFCacheGetEntryByName(Cache, OpenPath, TRUE);
  PUDFS_FILE_CONTEXT FileContext = FILE_ENTRY_TO_FILE_CONTEXT(FileEntry);

#ifdef UDF_DEBUG
  BlClearScreen();
  BlPrint("UDFSOpen(%s)\r\n", OpenPath);
#else
#ifdef SHOW_UDF_USAGE
  BlPositionCursor(1, 22);
  BlPrint("                                                               ", OpenPath);
  BlPositionCursor(1, 22);
  BlPrint("UDFSOpen( %s )", OpenPath);
#endif // for SHOW_UDF_USAGE
#endif // for UDF_DEBUG

    if (UDFSVerifyPathName(OpenPath)) {
    if (CacheIdx == -1) {
      //
      // create an entry and cache it
      //
      CacheIdx = UDFCacheGetBestEntryByName(Cache, OpenPath);

      if (CacheIdx != -1) {
        ULONG PathSize = strlen(OpenPath);
        ULONG BestSize = strlen(Cache[CacheIdx].Name);

        if (BestSize == 1)  // root directory
          BestSize--;

        if ((BestSize < PathSize) && (OpenPath[BestSize] == '\\')) {
          CHAR FullPath[256];
          CHAR Component[256];
          PUDF_FILE_DIRECTORY Entry = &(Cache[CacheIdx].File);
          UDF_FILE_DIRECTORY NewId;

          if (BestSize > 1)
            strcpy(FullPath, Cache[CacheIdx].Name);
          else
            FullPath[0] = 0;

          BestSize++;
          UDFSGetPathComponent(OpenPath + BestSize, 0, Component);
          Status = Component[0] ? ESUCCESS : ENOENT;

          while ((CacheIdx != -1) && (Status == ESUCCESS) && Component[0]) {

            Status = UDFSDirGetFile(Entry, Component, &NewId);

            if (Status == ESUCCESS) {
              strcat(FullPath, "\\");
              strcat(FullPath, Component);

              // cache the directory entry
              CacheIdx = UDFCachePutEntry(Cache, FullPath, &NewId);

              BestSize += strlen(Component);

              if (OpenPath[BestSize] == '\\')
                BestSize++;

              UDFSGetPathComponent(OpenPath + BestSize, 0, Component);

              if (CacheIdx != -1) {
                  Entry = &(Cache[CacheIdx].File);
              }
            }
          }

          if ((Status == ESUCCESS) && !Component[0] && (CacheIdx != -1)) {
            if (OpenMode != ArcOpenReadOnly)
              Status = EACCES;
          }
          else
            Status = ENOENT;
        }
        else
          Status = ENOENT;
      }
      else
        Status = EINVAL;
    } else {
      //
      // use the already cached entry
      //
      if (OpenMode == ArcOpenReadOnly) {
        Status = ESUCCESS;
      } else {
        Status = EACCES;
      }
    }
  } else {
    Status = EINVAL;
  }

  if (Status == ESUCCESS) {
    FileContext->CacheIdx = CacheIdx;
    FileEntry->Position.QuadPart = 0;
    FileEntry->Flags.Open = 1;
    FileEntry->Flags.Read = 1;
    FileEntry->Flags.Write = 0;
    FileEntry->Flags.Firmware = 0;
  }

#ifdef UDF_DEBUG
  if (Status) {
    BlPrint("UDFSOpen() error : %d. Press any key to Continue.\r\n", Status);
    DBG_PAUSE;
  }
#endif

  return Status;
}

ARC_STATUS
UDFSClose (
    IN ULONG FileId
    )
/*++

Routine Description:

  Closes the given file/directory.

Arguments:

  FileId - The file identifier, as an index into the BlFileTable

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  PBL_FILE_TABLE FileEntry = BlFileTable + FileId;
  PUDF_VOLUME Volume = FILE_ENTRY_TO_VOLUME(FileEntry);
  PUDF_CACHE_ENTRY    Cache = Volume->Cache;
  PUDFS_FILE_CONTEXT FileContext = FILE_ENTRY_TO_FILE_CONTEXT(FileEntry);
  ULONG CacheIdx = FileContext->CacheIdx;

  // decrement usage from cache
  UDFCacheDecrementUsage(Cache, CacheIdx);
  FileEntry->Flags.Open = 0;

  return ESUCCESS;
}

ARC_STATUS
UDFSRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    )
/*++

Routine Description:

   Reads the contents of the specified file.

Arguments:

  FileId - File identifier as an index into BlFileTable
  Buffer - The location where the data has to be read into
  Length - The amount of data to read
  Count - The amount of data read

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  ARC_STATUS Status = ESUCCESS;
  PBL_FILE_TABLE FileEntry = BlFileTable + FileId;
  PUDF_VOLUME Volume = FILE_ENTRY_TO_VOLUME(FileEntry);
  PUDF_CACHE_ENTRY    Cache = Volume->Cache;
  PUDFS_FILE_CONTEXT FileContext = FILE_ENTRY_TO_FILE_CONTEXT(FileEntry);
  ULONG CacheIdx = FileContext->CacheIdx;
  PUDF_FILE_DIRECTORY File = &(Cache[CacheIdx].File);
  UCHAR UBlock[UDF_BLOCK_SIZE+256] = {0};
  PUCHAR Block = ALIGN_BUFFER(UBlock);
  ULONGLONG Position = FileEntry->Position.QuadPart;
  ULONG BytesRead = 0;
  ULONG BlkIdx;

  if (Buffer) {
    ULONG CopyCount = 0;

    while ((Status == ESUCCESS) && (BytesRead < Length) &&
              (Position < File->Size)) {
      BlkIdx = (ULONG)(Position / UDF_BLOCK_SIZE);
      Status = UDFSFileReadBlock(File, BlkIdx, UDF_BLOCK_SIZE, Block);

      if (Status == ESUCCESS) {
        // must be amount requested
        CopyCount = MIN(Length - BytesRead, UDF_BLOCK_SIZE);
        // provided data is there
        CopyCount = (ULONG) MIN(CopyCount, File->Size - Position);
        // in case the position is not aligned at block boundaries
        CopyCount = MIN(CopyCount, UDF_BLOCK_SIZE - (ULONG)(Position % UDF_BLOCK_SIZE));

        memcpy((PUCHAR)Buffer + BytesRead, (PUCHAR)Block + (Position % UDF_BLOCK_SIZE),
                  CopyCount);

        BytesRead += CopyCount;
        Position += CopyCount;
      }
    }
  }
  else
    Status = EINVAL;

  if (Status == ESUCCESS) {
    FileEntry->Position.QuadPart = Position;
    *Count = BytesRead;
  }

  return Status;
}


ARC_STATUS
UDFSSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    )
/*++

Routine Description:

  Changes the file's pointer (for random access)

Arguments:

  FileId : File identifier as an index into the BlFileTable
  Offset : Seek amount
  SeekMode : Type of seek (absolute, relative, from end)

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  ARC_STATUS Status = ESUCCESS;
  PBL_FILE_TABLE FileEntry = BlFileTable + FileId;
  PUDF_VOLUME Volume = FILE_ENTRY_TO_VOLUME(FileEntry);
  PUDF_CACHE_ENTRY    Cache = Volume->Cache;
  PUDFS_FILE_CONTEXT FileContext = FILE_ENTRY_TO_FILE_CONTEXT(FileEntry);
  ULONG CacheIdx = FileContext->CacheIdx;
  PUDF_FILE_DIRECTORY File = &(Cache[CacheIdx].File);
  ULONGLONG Position = FileEntry->Position.QuadPart;

  switch (SeekMode) {
    case SeekAbsolute:
      Position = Offset->QuadPart;
      break;

    case SeekRelative:
      Position += Offset->QuadPart;
      break;

    case SeekMaximum:
      Position = File->Size + Offset->QuadPart;
      break;

    default:
      Status = EINVAL;
      break;
  }

  if ((Status == ESUCCESS) && (Position < File->Size))
    FileEntry->Position.QuadPart = Position;
  else
    Status = EINVAL;

  return Status;
}


ARC_STATUS
UDFSWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    )
/*++

Routine Description:

  Write the specified data to the given file.

Arguments:

  FileId : File identifier as an index into BlFileTable
  Buffer : Pointer to the data, which has to be written
  Length : The amount of data to be written
  Count  : The amount of data written.

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  return EACCES;
}


ARC_STATUS
UDFSGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    )
/*++

Routine Description:

  Gets the file information as required by FILE_INFORMATION
  fields.

Arguments:

  FileId : File identifier as an index into BlFileTable
  Buffer : FILE_INFORMATION structure pointer, to be filled in.

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  PBL_FILE_TABLE FileEntry = BlFileTable + FileId;
  PUDF_VOLUME Volume = FILE_ENTRY_TO_VOLUME(FileEntry);
  PUDF_CACHE_ENTRY    Cache = Volume->Cache;
  PUDFS_FILE_CONTEXT FileContext = FILE_ENTRY_TO_FILE_CONTEXT(FileEntry);
  ULONG CacheIdx = FileContext->CacheIdx;
  PUDF_FILE_DIRECTORY File = &(Cache[CacheIdx].File);
  PCHAR Name;
  PCHAR Component;

  memset(Buffer, 0, sizeof(FILE_INFORMATION));
  Buffer->EndingAddress.QuadPart = File->Size;
  Buffer->CurrentPosition = FileEntry->Position;

  if (File->IsDirectory)
    Buffer->Attributes |= ArcDirectoryFile;

  //
  // get hold of the last component in the path name
  //
  Name = Cache[CacheIdx].Name;
  Component = 0;

  while (Name) {
    Component = Name + 1; // skip '\\'
    Name = strchr(Component, '\\');
  }

  if (Component) {
    Buffer->FileNameLength = strlen(Component);
    strncpy(Buffer->FileName, Component, sizeof(Buffer->FileName) - 1);
    Buffer->FileName[sizeof(Buffer->FileName) - 1] = 0; // null terminate
  }

  return ESUCCESS;
}


ARC_STATUS
UDFSSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )
/*++

Routine Description:

  Sets the given file information for the specified file.

Arguments:

  FileId        : File identifier as an index into BlFileTable
  AttributeFlags: The flags to be set for the file (like read only
                  hidden, system etc.)
  AttributeMas  : Mask to be used for the attributes

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  return EACCES;
}

//
// file / directory method implementations
//
ARC_STATUS
UDFSFileReadBlock(
  IN PUDF_FILE_DIRECTORY  File,
  IN ULONG BlockIdx,
  IN ULONG Size,
  OUT PUDF_BLOCK Block
  )
/*++

Routine Description:

  Reads a file/directory data block relative to the start of
  the file/directory's data extent.

Arguments:

  File - UDF_FILE_DIRECTORY pointer indicating the file to
         be operated upon.
  BlockIdx - Zero based block index (w.r.t. to file's data extent)
  Size - Size of the block in bytes
  Block - Buffer where the data has to be read in.

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  ARC_STATUS  Status;

  if (File->NumExtents > 1) {
    //
    // map the logical file block to the acutal volume logical block
    //
    Status = UDFSVolumeReadBlock(File->Volume, File->IcbBlk, Block);

    if (Status == ESUCCESS) {
      ICBFILE UNALIGNED *Icb = (ICBFILE UNALIGNED *)Block;
      ULONG ExtentIdx = 0;
      SHORTAD UNALIGNED *Extent = UDF_ICB_GET_AD(Icb, ExtentIdx);
      ULONG ExtentLength = 0;
      ULONG NumBlocks = 0;

      while (ExtentIdx < File->NumExtents) {
        Extent = UDF_ICB_GET_AD(Icb, ExtentIdx);
        ExtentLength = (Extent->Length.Length / Size);
        NumBlocks += ExtentLength;

        if (NumBlocks > BlockIdx)
          break;

        ExtentIdx++;
      }

      if (Extent) {
        ULONG StartBlock = Extent->Start + (BlockIdx - (NumBlocks - ExtentLength));
        Status = UDFSVolumeReadBlock(File->Volume, StartBlock, Block);
      } else {
        Status = EIO;
      }
    }
  } else {
    Status = UDFSVolumeReadBlock(File->Volume, File->StartDataBlk + BlockIdx, Block);
  }

  return Status;
}

ARC_STATUS
UDFSDirGetFirstFID(
    IN PUDF_FILE_DIRECTORY Dir,
    OUT PUDF_FILE_IDENTIFIER File,
    OUT PUDF_BLOCK Block
    )
/*++

Routine Description:

  Gets the first FID (file identifier descriptor) for the given
  directory.

Arguments:

  Dir : The directory whose first FID is to be read.
  File : The file identifier descriptor which has to be update
  Block : The block in the actual UDF NSR_FID will reside

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  ARC_STATUS Status = ENOENT;
  UDF_FILE_IDENTIFIER Ident = {0};
  NSR_FID UNALIGNED *Fid;

  Status = UDFSFileReadBlock(Dir, 0, UDF_BLOCK_SIZE, Block);

  Fid = UDF_BLOCK_TO_FID(Block, &Ident);

  if ((Status == ESUCCESS) && (Fid->Destag.Ident == DESTAG_ID_NSR_FID)) {
    File->BlockIdx = 0; // relative to the file's data
    File->Offset = 0;
  }

  return Status;
}

#define UDF_NEXT_BLOCK(_Block) ((PUDF_BLOCK)((PUCHAR)_Block + UDF_BLOCK_SIZE))

BOOLEAN
UDFSCurrentFIDSpansBlock(
  IN NSR_FID UNALIGNED *Fid,
    IN PUDF_FILE_IDENTIFIER File
  )
{
  BOOLEAN Result = ((File->Offset + UDF_FID_LEN(Fid)) > UDF_BLOCK_SIZE) ? TRUE : FALSE;

#ifdef UDF_DEBUG
  if (Result)
    BlPrint("Current Fid Spans block\r\n");
#endif

  return Result;
}

BOOLEAN
UDFSNextFidSpansBlock(
  IN PUDF_FILE_IDENTIFIER CurrFile,
  IN PUDF_BLOCK Block
  )
{
  BOOLEAN Result = FALSE;
  NSR_FID UNALIGNED *CurrFid = UDF_BLOCK_TO_FID(Block, CurrFile);

  if (!UDFSCurrentFIDSpansBlock(CurrFid, CurrFile)) {
    ULONG RemainingSize = UDF_BLOCK_SIZE - (CurrFile->Offset + UDF_FID_LEN(CurrFid));

    if (RemainingSize < 38)
      Result = TRUE;
    else {
      UDF_FILE_IDENTIFIER NextFile = *CurrFile;
      NSR_FID UNALIGNED *NextFid = 0;

      NextFile.Offset += UDF_FID_LEN(CurrFid);
      NextFid = UDF_BLOCK_TO_FID(Block, &NextFile);

      if (NextFile.Offset + UDF_FID_LEN(NextFid) > UDF_BLOCK_SIZE)
        Result = TRUE;
    }
  }

#ifdef UDF_DEBUG
  if (Result)
    BlPrint("Next Fid Spans block\r\n");
#endif

  return Result;
}


ARC_STATUS
UDFSDirGetNextFID(
    IN PUDF_FILE_DIRECTORY Dir,
    OUT PUDF_FILE_IDENTIFIER File,
    IN OUT PUDF_BLOCK Block
    )
/*++

Routine Description:

  Reads the next FID, for the specified Directory. The next FID
  is based on contents of the "File" and "Block" arguments.

Arguments:

  Dir : The directory whose next FID is to be found
  File : The FID returned from previous UDFSDirGetFirstFID() or
         UDFSDirGetNextFID() call.
  Block : The block returned from previous UDFSDirGetFirstFID() or
          UDFSDirGetNextFID() call.

Return Value:

  Both File and Block arguments are updated as neccessary.
  ESUCCESS if successful otherwise appropriate error code

--*/
{
  ARC_STATUS  Status = ESUCCESS;
  NSR_FID UNALIGNED *Fid = UDF_BLOCK_TO_FID(Block, File);
  USHORT      FidLen = UDF_FID_LEN(Fid);
  UDF_FILE_IDENTIFIER FileId = *File;

  if (UDFSCurrentFIDSpansBlock(Fid, &FileId)) {
    FileId.BlockIdx++;
    FileId.Offset = (FileId.Offset + FidLen) % UDF_BLOCK_SIZE;
    memcpy(Block, (PUCHAR)Block + UDF_BLOCK_SIZE, UDF_BLOCK_SIZE);
  } else {
    if (UDFSNextFidSpansBlock(File, Block)) {
      Status = UDFSFileReadBlock(Dir, FileId.BlockIdx + 1, UDF_BLOCK_SIZE,
                          UDF_NEXT_BLOCK(Block));
    }

    FileId.Offset += FidLen;
  }

  //
  // make sure that the FID is valid
  //
  if (Status == ESUCCESS) {
    Fid = UDF_BLOCK_TO_FID(Block, &FileId);
    Status = (Fid->Destag.Ident == DESTAG_ID_NSR_FID) ? ESUCCESS : ENOENT;
  }

  if (Status == ESUCCESS) {
    *File = FileId;
  }


  return Status;
}

ARC_STATUS
UDFSDirGetFileByEntry(
    IN PUDF_FILE_DIRECTORY Dir,
    IN PUDF_FILE_IDENTIFIER Fid,
  IN PUDF_BLOCK Block,
    OUT PUDF_FILE_DIRECTORY File
    )
{
  ARC_STATUS Status = ESUCCESS;
  NSR_FID UNALIGNED *FileId = UDF_BLOCK_TO_FID(Block, Fid);
  PUCHAR UBlock[UDF_BLOCK_SIZE+256] = {0};
  PUCHAR IcbBlock = ALIGN_BUFFER(UBlock);

  File->Volume = Dir->Volume;
  File->FileId = *Fid;
  File->IsDirectory = UDF_FID_IS_DIRECTORY(FileId);
  File->IcbBlk = FileId->Icb.Start.Lbn;

  //
  // Get Hold of the ICB block and find the starting extent
  //
  Status = UDFSVolumeReadBlock(Dir->Volume, File->IcbBlk, IcbBlock);

  if (Status == ESUCCESS) {
    ICBFILE  UNALIGNED *Icb = (ICBFILE UNALIGNED *)(IcbBlock);

    File->StartDataBlk = (UDF_ICB_GET_AD(Icb, 0))->Start;
    File->Size = Icb->InfoLength;
    File->NumExtents = (UCHAR)UDF_ICB_NUM_ADS(Icb);
  }

  return Status;
}

ARC_STATUS
UDFSDirGetFile(
    IN PUDF_FILE_DIRECTORY Dir,
    IN PCHAR Name,
    OUT PUDF_FILE_DIRECTORY File
    )
/*++

Routine Description:

  Given an UDF directory gets the file/directory with the
  specified name.

Arguments:

  Dir : The directory which contains the required file/directory
  Name : The directory/file which has to be looked for.
  File : The directory or file which was requested.

Return Value:

  ESUCCESS if successful otherwise an approriate error code.

--*/
{
  UCHAR  UBlock[UDF_BLOCK_SIZE * 2 + 256] = {0};
  PUCHAR Block = ALIGN_BUFFER(UBlock);
  UDF_FILE_IDENTIFIER  Fid;
  ARC_STATUS  Status; //UDFSDirGetFirstFID(Dir, &Fid, Block);
  BOOLEAN Found = FALSE;
  NSR_FID UNALIGNED *FileId;
  WCHAR UUniBuffer[257];
  PWCHAR UniBuffer = UDFS_ALIGN_BUFFER(UUniBuffer, sizeof(WCHAR));
  UNICODE_STRING UniName;
  CSTRING AnsiName;

  Status = UDFSDirGetFirstFID(Dir, &Fid, Block);

  UniName.Buffer = UniBuffer;
  AnsiName.Buffer = Name;
  AnsiName.Length = (USHORT) strlen(Name);

  while(!Found && (Status == ESUCCESS)) {
    FileId = UDF_BLOCK_TO_FID(Block, &Fid);

    if (!UDF_FID_SKIP(FileId)) {
      UDFSInitUniStrFromDString(&UniName, UDF_FID_NAME(FileId), FileId->FileIDLen);
      Found = (UDFSCompareAnsiUniNames(AnsiName, UniName) == EqualTo);
    }

    if (!Found) {
      Status = UDFSDirGetNextFID(Dir, &Fid, Block);
    }
  }

  if (!Found)
    Status = ENOENT;
  else {
    Status = UDFSDirGetFileByEntry(Dir, &Fid, Block, File);
  }

  return Status;
}

//
// Cache method implementations
//
ULONG
UDFCachePutEntry(
    IN OUT PUDF_CACHE_ENTRY Cache,
    IN PCHAR Name,
    IN PUDF_FILE_DIRECTORY File
    )
/*++

Routine Description:

  Puts the given file entry into the specified cache,
  using the given name as key.

Arguments:

  Cache - The cache to be operated upon
  Name - The key for the entry to be put in
  File - The file entry to be cached.

Return Value:

  If successful, Index for the entry into the Cache table
  where the given entry was cached otherwise -1.

--*/
{
  ULONG Index;

  for (Index=0; Index < UDF_MAX_CACHE_ENTRIES; Index++) {
      if (Cache[Index].Usage == 0)
          break;
  }

  if (Index == UDF_MAX_CACHE_ENTRIES)
      Index = -1;
  else {
      strcpy(Cache[Index].Name, Name);
      Cache[Index].File = *File;
      Cache[Index].Usage = 1;
  }

  return Index;
}

ULONG
UDFCacheGetEntryByName(
    IN OUT PUDF_CACHE_ENTRY Cache,
    IN PCHAR Name,
    IN BOOLEAN Increment
    )
/*++

Routine Description:

  Searches for a given entry in the Cache and returns
  the index to that entry if found.

Arguments:

  Cache - The cache to the operated upon
  Name - The key (name of file/directory) to be used
         for searching
  Increment - Indicates whether to increment the usage
              of the entry if one is found

Return Value:

  If successful, Index for the entry into the Cache table
  where the given entry was cached otherwise -1.

--*/
{
  ULONG   Index;

  for (Index=0; Index < UDF_MAX_CACHE_ENTRIES; Index++) {
    if ((Cache[Index].Usage) &&
            (UDFSCompareStrings(Name, Cache[Index].Name) == EqualTo)) {
      //
      // found the required entry
      //
      if (Increment)
        Cache[Index].Usage++;

      break;
    }
  }

  if (Index == UDF_MAX_CACHE_ENTRIES)
      Index = -1;

  return Index;
}

ULONG
UDFCacheGetBestEntryByName(
  IN PUDF_CACHE_ENTRY Cache,
  IN PCHAR Name
  )
/*++

Routine Description:

  Searches for a closest matching entry in the Cache
  and returns the index to that entry if found.

  For e.g. if the cache contains "\", "\a", "\a\b",
  "\a\b\e\f\g" entries and "\a\b\c\d" is requested then
  "\a\b" entry will be returned

Arguments:

  Cache - The cache to the operated upon
  Name - The key (name of file/directory) to be used
         for searching

Return Value:

  If successful, Index for the entry into the Cache table
  where the matched entry was cached otherwise -1.

--*/
{
  ULONG   Index = -1;
  CHAR    NameBuff[256];
  STRING  Str;

  if (Name)
    strcpy(NameBuff, Name);
  else
    NameBuff[0] = 0;

  Str.Buffer = NameBuff;
  Str.Length = (USHORT) strlen(NameBuff);

  while (Str.Length && (Index == -1)) {
    Index = UDFCacheGetEntryByName(Cache, Str.Buffer, FALSE);

    if (Index == -1) {
      while (Str.Length && (Str.Buffer[Str.Length-1] != '\\'))
        Str.Length--;

      if (Str.Length) {
        if (Str.Length != 1)
          Str.Buffer[Str.Length-1] = 0;
        else
          Str.Buffer[Str.Length] = 0;
      }
    }
  }

  return Index;
}

VOID
UDFCacheFreeEntry(
    IN OUT PUDF_CACHE_ENTRY Cache,
    IN ULONG Idx
    )
/*++

Routine Description:

  Decrements the usage count for an entry in the
  Cache.

  Note : All the traversed directories are always
  cached permanently so this method as no effect on directories.

Arguments:

  Cache - Cache to be operated upon
  Idx - Index of the Cache entry which has to be freed


Return Value:

  None.

--*/
{
  if (!Cache[Idx].File.IsDirectory) {
    if (Cache[Idx].Usage)
      Cache[Idx].Usage--;
  }
}

VOID
UDFCacheIncrementUsage(
    IN OUT PUDF_CACHE_ENTRY Cache,
    IN ULONG Idx
    )
/*++

Routine Description:

  Increments the usage for the given entry in the cache.

  Note: Multiple open calls for the same file will result
  in the cache entry being resued and hence the usage will
  also be incremented.

Arguments:

  Cache - The Cache to the operated upon.
  Idx - Index to the cache entry which has to incremented

Return Value:

  None

--*/
{
  if (!Cache[Idx].File.IsDirectory)
    Cache[Idx].Usage++;
}

VOID
UDFCacheDecrementUsage(
    IN OUT PUDF_CACHE_ENTRY Cache,
    IN ULONG Idx
    )
/*++

Routine Description:

  Decrements the usage for the given entry in the cache.

  Note: Multiple open calls for the same file will result
  in the cache entry being resued and hence the usage will
  also be incremented. Each successive close call of the
  same file will result in this usage count to be decremented
  until it becomes 0, when the cache slot can be reused
  for other file/directory.

Arguments:

  Cache - Cache to be operated upon.
  Idx - Index to the Cache entry, whose usage count is
        to be decremented

Return Value:

  None

--*/
{
  if (!Cache[Idx].File.IsDirectory && Cache[Idx].Usage)
    Cache[Idx].Usage--;
}

#ifdef UDF_TESTING

//
// These are the temporary functions needed for testing
// this code in the user mode
//
ARC_STATUS
W32DeviceReadDisk(
      IN ULONG DeviceId,
      IN ULONG Lbo,
      IN ULONG ByteCount,
      IN OUT PVOID Buffer
      );

ARC_STATUS
UDFSReadDisk(
    IN ULONG DeviceId,
    IN ULONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    )
{
  return W32DeviceReadDisk(DeviceId, Lbo, ByteCount, Buffer);
}
#else

//
//  Internal support routine
//

ARC_STATUS
UDFSReadDisk(
    IN ULONG DeviceId,
    IN ULONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    )

/*++

Routine Description:

    This routine reads in zero or more sectors from the specified device.

Arguments:

    DeviceId - Supplies the device id to use in the arc calls.

    Lbo - Supplies the LBO to start reading from.

    ByteCount - Supplies the number of bytes to read.

    Buffer - Supplies a pointer to the buffer to read the bytes into.

    CacheNewData - Whether to cache new data read from the disk.

Return Value:

    ESUCCESS is returned if the read operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    LARGE_INTEGER LargeLbo;
    ARC_STATUS Status;
    ULONG i;
    LONGLONG  Offset = Lbo * UDF_BLOCK_SIZE;

#ifdef UDF_DEBUG
    BlPrint("UDFSReadDisk(%d, %d, %d)\r\n", DeviceId, Lbo, ByteCount);
#endif

    //
    //  Special case the zero byte read request
    //

    if (ByteCount == 0) {

        return ESUCCESS;
    }

    //
    // Issue the read through the cache.
    //

    LargeLbo.QuadPart = Offset;
    Status = BlDiskCacheRead(DeviceId,
                             &LargeLbo,
                             Buffer,
                             ByteCount,
                             &i,
                             CacheNewData);

    if (Status != ESUCCESS) {

        return Status;
    }

    //
    //  Make sure we got back the amount requested
    //

    if (ByteCount != i) {

        return EIO;
    }

    //
    //  Everything is fine so return success to our caller
    //
    return ESUCCESS;
}

#endif // for UDF_TESTING


COMPARISON_RESULTS
UDFSCompareStrings(
    IN PCHAR Str1,
    IN PCHAR Str2
    )
/*++

Routine Description:

  Compares to single byte strings (pointers).

Arguments:

  Str1 : first string
  Str2 : second string

Return Value:

    LessThan    if Str1 is lexically less than Str2
    EqualTo     if Str1 is lexically equal to Str2
    GreaterThan if Str1 is lexically greater than Str2

--*/
{
    STRING  Obj1, Obj2;

    Obj1.Buffer = Str1;
    Obj1.Length = Str1 ? strlen(Str1) : 0;

    Obj2.Buffer = Str2;
    Obj2.Length = Str2 ? strlen(Str2) : 0;

    return UDFSCompareAnsiNames(&Obj1, &Obj2);
}

COMPARISON_RESULTS
UDFSCompareAnsiNames(
    IN PSTRING Name1,
    IN PSTRING Name2
    )

/*++

Routine Description:

    This routine takes two names and compare them ignoring case.  This
    routine does not do implied dot or dbcs processing.

Arguments:

    Name1 - Supplies the first name to compare

    Name2 - Supplies the second name to compare

Return Value:

    LessThan    if Name1 is lexically less than Name2
    EqualTo     if Name1 is lexically equal to Name2
    GreaterThan if Name1 is lexically greater than Name2

--*/

{
    ULONG i;
    ULONG MinimumLength;

    //
    //  Compute the smallest of the two name lengths
    //

    MinimumLength = (Name1->Length < Name2->Length ? Name1->Length : Name2->Length);

    //
    //  Now compare each character in the names.
    //

    for (i = 0; i < MinimumLength; i += 1) {

        if (TOUPPER(Name1->Buffer[i]) < TOUPPER(Name2->Buffer[i])) {

            return LessThan;
        }

        if (TOUPPER(Name1->Buffer[i]) > TOUPPER(Name2->Buffer[i])) {

            return GreaterThan;
        }
    }

    //
    //  The names compared equal up to the smallest name length so
    //  now check the name lengths
    //

    if (Name1->Length < Name2->Length) {

        return LessThan;
    }

    if (Name1->Length > Name2->Length) {

        return GreaterThan;
    }

    return EqualTo;
}


BOOLEAN
UDFSVerifyPathName(
  IN PCHAR  Name
  )
/*++

Routine Description:

  Checks to see if the given path name is valid.

Arguments:

  Name : path name to the verified.

Return Value:

  TRUE if the path name is valid otherwise false

--*/
{
  BOOLEAN Result = Name ? TRUE : FALSE;

  if (Result) {
    USHORT  Length = (USHORT) strlen(Name);

    if (Length && (Length <= 256)) {
      if (Length == 1) {
        Result = (Name[0] == '\\');
      } else {
        Result = (Name[Length-1] != '\\') &&
                  (Name[0] == '\\');
      }
    }
    else
      Result = FALSE;
  }

  return Result;
}

USHORT
UDFSCountPathComponents(
  IN PCHAR Name
  )
/*++

Routine Description:

  Counts the number of the components making
  up the path, separated by '\\' separator

Arguments:

  Name : The path name whose components are to be
  counted

Return Value:

  The number of components which make up the
  given path.

--*/
{
  USHORT Result = -1;

  if (Name && Name[0]) {
    PCHAR Temp = strchr(Name + 1, '\\');

    if (Temp) {
      Result = 0;

      while (Temp) {
        Result++;
        Temp = strchr(Temp + 1, '\\');
      }
    } else {
      Result = 1; // no separators
    }
  }

  return Result;
}

BOOLEAN
UDFSGetPathComponent(
  IN PCHAR Name,
  IN USHORT ComponentIdx,
  OUT PCHAR ReqComponent
  )
/*++

Routine Description:

  Retrieves the requested component from the given
  path name.

Arguments:

  Name : The path name whose component is to be returned
  ComponentIdx : The index (zero based) for the requested
                 component
  RequiredComponent : The requested component, if found.

Return Value:

  TRUE if the component was found other wise FALSE

--*/
{
  PCHAR   Component = 0;
  USHORT  Count = 0;

  //
  // get hold of the component starting position
  //
  if (Name && Name[0]) {
    if (ComponentIdx) {
      Component = Name;

      while (Component && (Count < ComponentIdx)) {
        Component = strchr(Component + 1, '\\');
        Count++;
      }

      if (Component && (Component[0] == '\\'))
        Component++;
    } else {
      Component = (Name[0] == '\\') ? Name + 1 : Name;
    }
  }

  //
  // get ending position of the component
  //
  if (Component && Component[0] && (Component[0] != '\\')) {
    PCHAR Temp = strchr(Component, '\\');
    ULONG Length = Temp ? (ULONG)(Temp - Component) : strlen(Component);

    strncpy(ReqComponent, Component, Length);
    ReqComponent[Length] = 0;
  }
  else {
    ReqComponent[0] = 0;
  }

  return (ReqComponent[0] != 0);
}


VOID
UDFSInitUniStrFromDString(
  OUT PUNICODE_STRING UniStr,
  IN PUCHAR Buffer,
  IN ULONG Length
  )
/*++

Routine Description:

  Initializes a given unicode string.

Arguments:

  UniStr - The unicode string to initialize
  Buffer - The buffer pointing to the unicode string
  Length - The length of the d-string as recorded

Return Value:

  Initialized unicode string in "UniStr"

--*/
{
  UCHAR Step = 0;
  PUCHAR End = Buffer + Length;
  PUCHAR Curr;
  PWCHAR Dest = UniStr->Buffer;
  ULONG DestLen = 0;
  BOOLEAN Swap = FALSE;

  if (Buffer && Length) {
    if (*Buffer == 0x10) {
      Step = 2;
      Swap = (Buffer[1] == 0);  // hack for ISO long file names + UDF bridge sessions
    } else {
      Step = 1;
    }

    for (Curr = Buffer + 1; Curr < End; Curr += Step, Dest++, DestLen += Step) {
      if (Swap) {
        // swap copy !!!
        *((UCHAR *)(Dest)) = *((UCHAR *)(Curr) + 1);
        *((UCHAR *)(Dest) + 1) = *((UCHAR *)(Curr));
      } else {
        if (Step == 1)
          *Dest = *Curr;
        else
          *Dest = *(PWCHAR)Curr;  // erroneous media ???
      }
    }

    UniStr->Length = (USHORT)DestLen;
    ((PWCHAR)UniStr->Buffer)[DestLen/2] = 0;  // null terminate the string
  }
}

VOID
UDFSToAnsiString(
  OUT PSTRING     AnsiStr,
  IN PUNICODE_STRING  UniStr
  )
/*++

Routine Description:

  Converts an single byte string to unicode string.

Arguments:

  AnsiStr - The convereted single byte string
  UniStr  - The unicode string which has to be converted

  Note : Each most significant byte of the Unicode characters
  is simply discarded.

Return Value:

  None

--*/
{
  ULONG Index;

  AnsiStr->Length = UniStr->Length / sizeof(WCHAR);

  for (Index=0; Index < AnsiStr->Length; Index++)
    AnsiStr->Buffer[Index] = (CHAR)(UniStr->Buffer[Index]);

  AnsiStr->Buffer[Index] = 0;
}

VOID
UDFSToUniString(
  OUT PUNICODE_STRING  UniStr,
  OUT PSTRING         AnsiStr
  )
/*++

Routine Description:

  Converts a given single byte string to an Unicode string.

Arguments:

  AnsiStr : The single byte string which has to be converted
  UniStr : The converted unicode string.

Return Value:

  None

--*/
{
  ULONG Index;

  UniStr->Length = AnsiStr->Length * sizeof(WCHAR);

  for (Index=0; Index < AnsiStr->Length; Index++)
    UniStr->Buffer[Index] = (WCHAR)(AnsiStr->Buffer[Index]);

  UniStr->Buffer[Index] = 0; // unicode null
}


int
UDFSCompareAnsiUniNames(
    IN CSTRING AnsiString,
    IN UNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine compares two names (one ansi and one unicode) for equality.

Arguments:

    AnsiString - Supplies the ansi string to compare

    UnicodeString - Supplies the unicode string to compare

Return Value:

    < 0 if AnsiString is approximately < than UnicodeString
    = 0 if AnsiString is approximately == UnicodeString
    > 0 otherwise

--*/

{
    ULONG i;
    ULONG Length;

#ifdef UDF_DEBUG
    {
      char    TempBuff[256] = {0};
      STRING  TempStr;

      TempStr.Buffer = TempBuff;
      UDFSToAnsiString(&TempStr, &UnicodeString);
      BlPrint("Comparing %s - %s\r\n", AnsiString.Buffer, TempStr.Buffer);
    }
#endif


    //
    //  Determine length for compare
    //

    if (AnsiString.Length * sizeof( WCHAR ) < UnicodeString.Length) {
        Length = AnsiString.Length;
    } else {
        Length = UnicodeString.Length / sizeof( WCHAR );
    }

    i = 0;
    while (i < Length) {

        //
        //  If the current char is a mismatch, return the difference
        //

        if (TOUPPER( (USHORT)AnsiString.Buffer[i] ) != TOUPPER( UnicodeString.Buffer[i] )) {
            return TOUPPER( (USHORT)AnsiString.Buffer[i] ) - TOUPPER( UnicodeString.Buffer[i] );
        }

        i++;
    }

    //
    //  We've compared equal up to the length of the shortest string.  Return
    //  based on length comparison now.
    //

    return AnsiString.Length - UnicodeString.Length / sizeof( WCHAR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\amd64\amd64.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    amd64.c

Abstract:

    This module contains routines necessary to support loading and
    transitioning into an AMD64 kernel.  The code in this module has
    access to amd64-specific defines found in amd64.h but not to i386-
    specific declarations found in i386.h.

Author:

    Forrest Foltz (forrestf) 20-Apr-2000

Environment:


Revision History:

--*/

//
// Here, we want the header files to be processed as though building for
// AMD64.  Make appropriate definitions and undefs.
//

#define _AMD64_
#define _M_AMD64
#define _WIN64

#undef _X86_
#undef X86
#undef _M_X86_
#undef _M_IX86

//
// Warning 4163 is "function unavailable as intrinsic"
//

#pragma warning(disable:4163)

//
// Warning 4235 is "nonstandard extension used", referring to __unaligned
//

#pragma warning(disable:4235)

//
// Warning 4391 is "incorrect return type for intrinsi function"
//

#pragma warning(disable:4391)

#include "bootx86.h"
#include "amd64prv.h"
#include <pcmp.inc>
#include <ntapic.inc>

//
// GDT: functino to convert selector to GDT entry.
//

PKGDTENTRY64
__inline
GDT_PTR (
    PGDT_64 Gdt,
    ULONG Selector
    )
{
    ULONG index;
    PKGDTENTRY64 entry;

    index = Selector & ~7;

    entry = (PKGDTENTRY64)((PUCHAR)Gdt + index);

    return entry;
}


//
// Interrupt descriptor table
//

typedef struct _IDT_64 {
    KIDTENTRY64 Entries[ MAXIMUM_IDTVECTOR + 1 ];
} IDT_64, *PIDT_64;

#define VIRTUAL_ADDRESS_BITS 48
#define VIRTUAL_ADDRESS_MASK (((ULONGLONG)1 << VIRTUAL_ADDRESS_BITS) - 1)

//
// Longmode ring0 code selector.  This actually lives in the middle of the
// transition data stream in amd64s.asm
//

extern USHORT BlAmd64_KGDT64_R0_CODE;

//
// Data values exported to amd64x86.c
//

const ULONG BlAmd64DoubleFaultStackSize = DOUBLE_FAULT_STACK_SIZE;
const ULONG BlAmd64KernelStackSize = KERNEL_STACK_SIZE;
const ULONG BlAmd64McaExceptionStackSize = KERNEL_MCA_EXCEPTION_STACK_SIZE;
const ULONG BlAmd64GdtSize = KGDT64_LAST;
const ULONG BlAmd64IdtSize = sizeof(IDT_64);

#define CONST_EXPORT(x) const ULONG BlAmd64_##x = x;
CONST_EXPORT(MSR_FS_BASE)
CONST_EXPORT(MSR_GS_BASE)
CONST_EXPORT(KGDT64_SYS_TSS)
CONST_EXPORT(MSR_EFER)
CONST_EXPORT(TSS_IST_PANIC)
CONST_EXPORT(TSS_IST_MCA)

const ULONG64 BlAmd64_LOCALAPIC = LOCALAPIC;
const ULONG64 BlAmd64UserSharedData = KI_USER_SHARED_DATA;

//
// Flags to be enabled in the EFER MSR before transitioning to long mode
//

const ULONG BlAmd64_MSR_EFER_Flags = MSR_LME | MSR_SCE;

//
// Array of address bit decode counts and recursive mapping bases,
// one for each level of the mapping
// 

AMD64_MAPPING_INFO BlAmd64MappingLevels[ AMD64_MAPPING_LEVELS ] = 
    {
      { PTE_BASE, PTI_MASK_AMD64, PTI_SHIFT },
      { PDE_BASE, PDI_MASK_AMD64, PDI_SHIFT },
      { PPE_BASE, PPI_MASK,       PPI_SHIFT },
      { PXE_BASE, PXI_MASK,       PXI_SHIFT }
    };

//
// BlAmd64TopLevelPte refers to the physical page number of the Page Map
// Level 4 (PML4) table.
//
// BlAmd64TopLevelPte is not really a page table entry and so does not
// actually exist as an element within a page table.  It exists only as
// a convenience to BlAmd64CreateAmd64Mapping().
//

HARDWARE_PTE BlAmd64TopLevelPte;

//
// PAGE_MAP_LEVEL_4 yields the identity-mapped (physical) address of the
// PML4 table.
//

#define PAGE_MAP_LEVEL_4 \
    ((PPAGE_TABLE)(BlAmd64TopLevelPte.PageFrameNumber << PAGE_SHIFT))

//
// Special PFN for BlAmd64CreateMapping
//

#define PFN_NO_MAP ((PFN_NUMBER)-1)

//
// Size of the VA mapped by a level 0 page table
//

#define PAGE_TABLE_VA ((POINTER64)(PTES_PER_PAGE * PAGE_SIZE))

//
// Prototypes for local functions
//

ARC_STATUS
BlAmd64CreateMappingWorker(
    IN     ULONGLONG Va,
    IN     PFN_NUMBER Pfn,
    IN     ULONG MappingLevel,
    IN OUT PHARDWARE_PTE UpperLevelPte
    );

VOID
BlAmd64MakePteValid(
    IN PHARDWARE_PTE Pte,
    IN PFN_NUMBER Pfn
    );

VOID
BlAmd64ClearTopLevelPte(
    VOID
    )

/*++

Routine Description:

    This routine simply clears BlAmd64TopLevelPte.

Arguments:

    None.

Return Value:

    None.

--*/

{

    *(PULONG64)&BlAmd64TopLevelPte = 0;
}

ARC_STATUS
BlAmd64CreateMapping(
    IN ULONGLONG Va,
    IN PFN_NUMBER Pfn
    )

/*++

Routine Description:

    This function maps a virtual address into a 4-level AMD64 page mapping
    structure.

Arguments:

    Va - Supplies the 64-bit virtual address to map

    Pfn - Supplies the 64-bit physical page number to map the address to

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    ARC_STATUS status;

    status = BlAmd64CreateMappingWorker( Va & VIRTUAL_ADDRESS_MASK,
                                         Pfn,
                                         AMD64_MAPPING_LEVELS - 1,
                                         &BlAmd64TopLevelPte );

    return status;
}

ARC_STATUS
BlAmd64CreateMappingWorker(
    IN     ULONGLONG Va,
    IN     PFN_NUMBER Pfn,
    IN     ULONG MappingLevel,
    IN OUT PHARDWARE_PTE UpperLevelPte
    )

/*++

Routine Description:

    This function creates an address mapping in a single level of an AMD64
    4-level mapping structure.  It is called only by BlCreateMapping
    and by itself, recursively.

Arguments:

    Va - Supplies the 64-bit virtual address to map.  This address has already
         had any insignificant upper bits masked via VIRTUAL_ADDRESS_MASK.

    Pfn - Supplies the 64-bit physical page number to map the address to.  If
          Pfn == PFN_NO_MAP, then all of the page tables are put into
          place to support the mapping but the level 0 pte itself is not
          actually filled in.  This is used to create the HAL's VA mapping
          area.

    MappingLevel - The mapping level in which to create the appropriate
        mapping.  Must be 0, 1, 2 or 3.

    UpperLevelPte - A pointer to the parent PTE that refers to the page
        at this mapping level.  If no page exists at this level for this
        address, then this routine will allocate one and modify
        UpperLevelPte appropriately.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    PFN_NUMBER pageTablePfn;
    PAMD64_PAGE_TABLE pageTable;
    ULONGLONG va;
    PAMD64_MAPPING_INFO mappingInfo;
    ULONG pteIndex;
    PHARDWARE_PTE pte;
    ARC_STATUS status;
    BOOLEAN newPage;

    mappingInfo = &BlAmd64MappingLevels[ MappingLevel ];

    if (UpperLevelPte->Valid == 0) {

        //
        // A new page table must be allocated.
        //

        newPage = TRUE;
        pageTable = BlAmd64AllocatePageTable();
        if (pageTable == NULL) {
            return ENOMEM;
        }

        //
        // Reference the new page table with the parent PTE
        // 

        pageTablePfn = (ULONG)pageTable >> PAGE_SHIFT;
        BlAmd64MakePteValid( UpperLevelPte, pageTablePfn );

        if (MappingLevel == (AMD64_MAPPING_LEVELS - 1)) {

            //
            // We have just allocated the top-level page.  Insert a
            // recursive mapping here.
            //

            pteIndex = (ULONG)((mappingInfo->RecursiveMappingBase >>
                                mappingInfo->AddressShift) &
                               mappingInfo->AddressMask);

            pte = &pageTable->PteArray[ pteIndex ];

            BlAmd64MakePteValid( pte, pageTablePfn );
        }

    } else {

        //
        // A page table structure already exists for this level.
        //

        newPage = FALSE;
        pageTablePfn = UpperLevelPte->PageFrameNumber;
        pageTable = (PAMD64_PAGE_TABLE)((ULONG)pageTablePfn << PAGE_SHIFT);
    }

    //
    // Derive a pointer to the appropriate PTE within the page table
    // 

    pteIndex =
        (ULONG)(Va >> mappingInfo->AddressShift) & mappingInfo->AddressMask;

    pte = &pageTable->PteArray[ pteIndex ];

    if (MappingLevel == 0) {

        if (Pfn != PFN_NO_MAP) {

            //
            // This is an actual level 0, or PTE, entry.  Just set it with
            // the Pfn that was passed in.
            //
    
            BlAmd64MakePteValid( pte, Pfn );

        } else {

            //
            // This is a special HAL mapping, one that ensures that all
            // levels of page table are in place to support this mapping
            // but doesn't actually fill in the level 0 PTE.
            //
            // So do nothing here except break the recursion.
            //
        }

    } else {

        //
        // More mapping levels to go, call this function recursively and
        // process the next level.
        //

        status = BlAmd64CreateMappingWorker( Va,
                                             Pfn,
                                             MappingLevel - 1,
                                             pte );
        if (status != ESUCCESS) {
            return status;
        }
    }

    if (newPage != FALSE) {

        //
        // A new page table was allocated, above.  Recursively map
        // it within the PTE_BASE region.
        //

        va = (Va >> mappingInfo->AddressShift);
        va *= sizeof(HARDWARE_PTE);
        va += mappingInfo->RecursiveMappingBase;

        status = BlAmd64CreateMapping( va, pageTablePfn );
        if (status != ESUCCESS) {
            return status;
        }
    }

    return ESUCCESS;
}


VOID
BlAmd64MakePteValid(
    IN OUT PHARDWARE_PTE Pte,
    IN PFN_NUMBER Pfn
    )

/*++

Routine Description:

    This routine fills an AMD64 Pte with the supplied Pfn and makes it
    valid.

Arguments:

    Pte - Supplies a pointer to the Pte to make valid.

    Pfn - Supplies the page frame number to set in the Pte.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    //
    // Make sure we're not just overwriting a PFN in an already
    // valid PTE.
    //

    ASSERT( Pte->Valid == 0 || Pte->PageFrameNumber == Pfn );

    Pte->PageFrameNumber = Pfn;
    Pte->Valid = 1;
    Pte->Write = 1;
    Pte->Accessed = 1;
    Pte->Dirty = 1;
}

VOID
BlAmd64BuildGdtEntry(
    IN PGDT_64 Gdt,
    IN USHORT Selector,
    IN POINTER64 Base,
    IN ULONGLONG Limit,
    IN ULONG Type,
    IN ULONG Dpl,
    IN BOOLEAN LongMode,
    IN BOOLEAN DefaultBig
    )

/*++

Routine Description:

    This routine fills in an AMD64 GDT entry.

Arguments:

    Gdt - Supplies a pointer to the GDT.

    Selector - Segment selector of the GDT entry within Gdt.

    Base - Base address value of the descriptor.

    Limit - Limit value of the descriptor.

    Type - 5-bit type value of the descriptor.

    Dpl - Priviledge value of the descriptor.

    LongMode - Indicates whether this is a longmode descriptor (valid only
               for code segment descriptors).

    DefaultBig - Supplies the value for the default/big field in the
                 descriptor.

Return Value:

    None.

--*/

{
    ULONG limit20;
    PKGDTENTRY64 gdtEntry;

    KGDT_BASE gdtBase;
    KGDT_LIMIT gdtLimit;

    gdtEntry = GDT_PTR(Gdt,Selector);

    //
    // Set the Base and LongMode fields
    //

    gdtBase.Base = Base;

    gdtEntry->BaseLow = gdtBase.BaseLow;
    gdtEntry->Bits.BaseMiddle = gdtBase.BaseMiddle;
    gdtEntry->Bits.BaseHigh = gdtBase.BaseHigh;
    gdtEntry->Bits.LongMode = 0;

    if ((LongMode != FALSE) || (Type == TYPE_TSS64)) {

        //
        // All long GDT entries use a 64-bit base and have the longmode bit
        // set.
        //
        // In addition, a TSS GDT entry uses a 64-bit but does *not* set the
        // longmode bit.  This applies to an LDT entry as well, which is not
        // used in this OS.
        //

        if (Type != TYPE_TSS64) {
            gdtEntry->Bits.LongMode = 1;
        }

        gdtEntry->MustBeZero = 0;
        gdtEntry->BaseUpper = gdtBase.BaseUpper;
    }

    //
    // Set the Limit and Granularity fields
    //

    if (Limit > (1 << 20)) {
        limit20 = (ULONG)(Limit / PAGE_SIZE);
        gdtEntry->Bits.Granularity = 1;
    } else {
        limit20 = (ULONG)Limit;
        gdtEntry->Bits.Granularity = 0;
    }
    gdtLimit.Limit = limit20;
    gdtEntry->LimitLow = gdtLimit.LimitLow;
    gdtEntry->Bits.LimitHigh = gdtLimit.LimitHigh;

    //
    // Set Present = 1 unless this is a NULL descriptor
    //

    if (Type == 0) {
        gdtEntry->Bits.Present = 0;
    } else {
        gdtEntry->Bits.Present = 1;
    }

    //
    // Set remaining fields
    // 

    gdtEntry->Bits.Type = Type;
    gdtEntry->Bits.Dpl = Dpl;
    gdtEntry->Bits.DefaultBig = DefaultBig;
    gdtEntry->Bits.System = 0;
}


VOID
BlAmd64BuildAmd64GDT(
    IN PVOID SysTss,
    OUT PVOID Gdt
    )

/*++

Routine Description:

    This routine initializes the longmode Global Descriptor Table.

Arguments:

    SysTss - Supplies a 32-bit KSEG0_X86 pointer to the system TSS.

    Gdt - Supplies a 32-bit pointer to the Gdt to fill in.

Return Value:

    None.

--*/

{
    PGDT_64 gdt64;
    POINTER64 sysTss64;

    gdt64 = (PGDT_64)Gdt;

    //
    // KGDT64_NULL: NULL descriptor
    //

    BlAmd64BuildGdtEntry(gdt64,KGDT64_NULL,
             0,0,0,0,0,0);                  // Null selector, all zeros

    //
    // KGDT_R0_CODE: Kernel mode code
    //

    BlAmd64BuildGdtEntry(gdt64,KGDT64_R0_CODE,
             0,                             // Base and limit are ignored
             0,                             //  in a long-mode code selector
             TYPE_CODE,                     // Code segment: Execute/Read
             DPL_SYSTEM,                    // Kernel only
             TRUE,                          // Longmode
             FALSE);                        // Not 32-bit default

    //
    // KGDT_R0_STACK: Kernel mode stack
    //

    BlAmd64BuildGdtEntry(gdt64,KGDT64_R0_DATA,
             0,                             // Base and limit are ignored
             0,                             //  when in long-mode
             TYPE_DATA,                     // Data segment: Read/Write
             DPL_SYSTEM,                    // Kernel only
             FALSE,                         // Not longmode
             TRUE);                         // 32-bit default

    //
    // KDT_SYS_TSS: Kernel mode system task state
    //

    sysTss64 = PTR_64(SysTss);
    BlAmd64BuildGdtEntry(gdt64,KGDT64_SYS_TSS,
             sysTss64,                      // Base to be filled in at runtime
             FIELD_OFFSET(KTSS64,IoMap)-1,  // Contains only a KTSS64
             TYPE_TSS64,                    // Not busy TSS
             DPL_SYSTEM,                    // Kernel only
             FALSE,                         // Not longmode
             FALSE);                        // Not 32-bit default

    //
    // KGDT64_R3_CODE: User mode 64-bit code
    //

    BlAmd64BuildGdtEntry(gdt64,KGDT64_R3_CODE,
             0,                             // Base and limit are ignored
             0,                             //  in a long-mode code selector
             TYPE_CODE,                     // Code segment: Execute/Read
             DPL_USER,                      // User mode
             TRUE,                          // Longmode
             FALSE);                        // Not 32-bit default

    //
    // KGDT64_R3_CMCODE: User-mode 32-bit code. Flat 2 gig.
    //

    BlAmd64BuildGdtEntry(gdt64,KGDT64_R3_CMCODE,
             0,                             // Base
             0x7FFFFFFF,                    // 2G limit
             TYPE_CODE,                     // Code segment: Execute/Read
             DPL_USER,                      // User mode
             FALSE,                         // Not longmode
             TRUE);                         // 32-bit default

    //
    // KGDT64_R3_DATA: User-mode 32-bit data.  Flat 2 gig.
    //                     

    BlAmd64BuildGdtEntry(gdt64,KGDT64_R3_DATA,
             0,                             // Base
             0x7FFFFFFF,                    // 2G limit
             TYPE_DATA,                     // Data segment: Read/Write
             DPL_USER,                      // User mode
             FALSE,                         // Not longmode
             TRUE);                         // 32-bit default

    //
    // KGDT64_R3_CMTEB: User-mode 32-bit TEB.  Flat 4K.
    //

    BlAmd64BuildGdtEntry(gdt64,KGDT64_R3_CMTEB,
             0,                             // Base
             0x0FFF,                        // 4K limit
             TYPE_DATA,                     // Data segment: Read/Write
             DPL_USER,                      // User mode
             FALSE,                         // Not longmode
             TRUE);                         // 32-bit default

    //
    // Set the code selector
    //

    BlAmd64_KGDT64_R0_CODE = KGDT64_R0_CODE;
}


ARC_STATUS
BlAmd64MapHalVaSpace(
    VOID
    )

/*++

Routine Description:

    This routine initializes the VA space reserved for the HAL.  This
    involves building all page tables necessary to support the mappings
    but not actually filling in any level 0 PTEs.

Arguments:

    None.

Return Value:

    ARC_STATUS - Status of operation.

--*/


{
    POINTER64 va;
    ULONG round;
    ULONG vaRemaining;
    ARC_STATUS status;

    //
    // The hal has a piece of VA space reserved for it, from HAL_VA_START to
    // HAL_VA_START + HAL_VA_SIZE - 1.
    //
    // This routine ensures that all necessary levels of page tables are
    // present to support any mappings that the hal might put there.
    //

    vaRemaining = HAL_VA_SIZE;
    va = HAL_VA_START;

    //
    // Round VA down to a page table boundary.
    //

    round = (ULONG)(va & (PAGE_TABLE_VA-1));
    va -= round;
    vaRemaining += round;

    while (TRUE) {

        //
        // Perform a "mapping".  The special PFN_NUMBER sets up all of
        // the page tables necessary to support the mapping, without
        // actually filling in a level 0 PTE.
        // 

        status = BlAmd64CreateMapping(va, PFN_NO_MAP);
        if (status != ESUCCESS) {
            return status;
        }

        if (vaRemaining <= PAGE_TABLE_VA) {
            break;
        }

        vaRemaining -= PAGE_TABLE_VA;
        va += PAGE_TABLE_VA;
    }

    return ESUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\amd64\amd64prv.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    amd64prv.h

Abstract:

    This header file defines private interfaces shared between the following
    modules:

    amd64.c
    amd64s.asm
    amd64x86.c

Author:

    Forrest Foltz (forrestf) 20-Apr-00


Revision History:

--*/

#if !defined(_AMD64PRV_H_)
#define _AMD64PRV_H_

//
// 64-bit pointer and LONG_PTR fields are changed to this
//

typedef LONGLONG POINTER64;

//
// KSEG0 definitions for both the AMD64 and X86 platforms.  Note that
// these are duplicated from amd64.h and i386.h, respectively.
// 

#define KSEG0_BASE_AMD64  0xFFFFF80000000000UI64
#define KSEG0_SIZE_AMD64  0x0000000040000000UI64
#define KSEG0_LIMIT_AMD64 (KSEG0_BASE_AMD64 + KSEG0_SIZE_AMD64)

#define KSEG0_BASE_X86   0x80000000
#define KSEG0_SIZE_X86   0x40000000
#define KSEG0_LIMIT_X86  (KSEG0_BASE_X86 + KSEG0_SIZE_X86)

#define IS_KSEG0_PTR_X86(x)   (((x) >= KSEG0_BASE_X86)   && ((x) < KSEG0_LIMIT_X86))
#define IS_KSEG0_PTR_AMD64(x) (((x) >= KSEG0_BASE_AMD64) && ((x) < KSEG0_LIMIT_AMD64))

__inline
POINTER64
PTR_64(
    IN PVOID Pointer32
    )

/*++

Routine Description:

    This function is used by the loader to convert a 32-bit X86 KSEG0 pointer
    to a 64-bit AMD64 KSEG0 pointer.

Arguments:

    Pointer32 - Supplies the 32-bit KSEG0 pointer to convert.

Return value:

    Returns the equivalent 64-bit KSEG0 pointer.

--*/

{
    ULONG pointer32;
    ULONGLONG pointer64;

    if (Pointer32 == NULL) {
        return 0;
    }

    ASSERT( IS_KSEG0_PTR_X86((ULONG)Pointer32) != FALSE );

    pointer32 = (ULONG)Pointer32 - KSEG0_BASE_X86;
    pointer64 = KSEG0_BASE_AMD64 + pointer32;
    return (POINTER64)pointer64;
}

__inline
PVOID
PTR_32(
    IN POINTER64 Pointer64
    )

/*++

Routine Description:

    This function is used by the loader to convert a 64-bit AMD64 KSEG0
    pointer to a 32-bit X86 KSEG0 pointer.

Arguments:

    Pointer64 - Supplies the 64-bit KSEG0 pointer to convert.

Return value:

    Returns the equivalent 32-bit KSEG0 pointer.

--*/

{
    ULONG pointer32;

    if (Pointer64 == 0) {
        return NULL;
    }

    ASSERT( IS_KSEG0_PTR_AMD64(Pointer64) != FALSE );

    pointer32 = (ULONG)(Pointer64 - KSEG0_BASE_AMD64 + KSEG0_BASE_X86);
    return (PVOID)pointer32;
}

//
// Macros
//

#define PAGE_MASK ((1 << PAGE_SHIFT) - 1)

#define ROUNDUP_X(x,m) (((x)+(m)-1) & ~((m)-1))

//
// Size round up
//

#define ROUNDUP16(x)     ROUNDUP_X(x,16)
#define ROUNDUP_PAGE(x)  ROUNDUP_X(x,PAGE_SIZE)

//
// Shared PTE, PFN types
//

typedef ULONG PFN_NUMBER32, *PPFN_NUMBER32;
typedef ULONGLONG PFN_NUMBER64, *PPFN_NUMBER64;

#if defined(_AMD64_)

typedef ULONG        PTE_X86,    *PPTE_X86;
typedef HARDWARE_PTE PTE_AMD64,  *PPTE_AMD64;

#elif defined(_X86_)

typedef ULONGLONG    PTE_AMD64, *PPTE_AMD64;
typedef HARDWARE_PTE PTE_X86,   *PPTE_X86;

#else

#error "Target architecture not defined"

#endif

//
// Descriptor table descriptor
//

#pragma pack(push,1)
typedef struct DESCRIPTOR_TABLE_DESCRIPTOR {
    USHORT Limit;
    POINTER64 Base;
} DESCRIPTOR_TABLE_DESCRIPTOR, *PDESCRIPTOR_TABLE_DESCRIPTOR;
#pragma pack(pop)

//
// Structures found within the CM_PARTIAL_RESOURCE_DESCRIPTOR union
//

typedef struct _CM_PRD_GENERIC {
    PHYSICAL_ADDRESS Start;
    ULONG Length;
} CM_PRD_GENERIC, *PCM_PRD_GENERIC;

typedef struct _CM_PRD_PORT {
    PHYSICAL_ADDRESS Start;
    ULONG Length;
} CM_PRD_PORT, *PCM_PRD_PORT;

typedef struct _CM_PRD_INTERRUPT {
    ULONG Level;
    ULONG Vector;
    KAFFINITY Affinity;
} CM_PRD_INTERRUPT, *PCM_PRD_INTERRUPT;

typedef struct _CM_PRD_MEMORY {
    PHYSICAL_ADDRESS Start;
    ULONG Length;
} CM_PRD_MEMORY, *PCM_PRD_MEMORY;

typedef struct _CM_PRD_DMA {
    ULONG Channel;
    ULONG Port;
    ULONG Reserved1;
} CM_PRD_DMA, *PCM_PRD_DMA;

typedef struct _CM_PRD_DEVICEPRIVATE {
    ULONG Data[3];
} CM_PRD_DEVICEPRIVATE, *PCM_PRD_DEVICEPRIVATE;

typedef struct _CM_PRD_BUSNUMBER {
    ULONG Start;
    ULONG Length;
    ULONG Reserved;
} CM_PRD_BUSNUMBER, *PCM_PRD_BUSNUMBER;

typedef struct _CM_PRD_DEVICESPECIFICDATA {
    ULONG DataSize;
    ULONG Reserved1;
    ULONG Reserved2;
} CM_PRD_DEVICESPECIFICDATA, *PCM_PRD_DEVICESPECIFICDATA;

//
// Define page table structure.
//

#define PTES_PER_PAGE (PAGE_SIZE / sizeof(HARDWARE_PTE))

typedef HARDWARE_PTE  PAGE_TABLE[ PTES_PER_PAGE ];
typedef HARDWARE_PTE *PPAGE_TABLE;

typedef struct _AMD64_PAGE_TABLE {
    PTE_AMD64 PteArray[ PTES_PER_PAGE ];
} AMD64_PAGE_TABLE, *PAMD64_PAGE_TABLE;

//
// Constants that are already defined in other header files but are not
// (yet) included here
//

#define LU_BASE_ADDRESS (ULONG)0xFEE00000

//
// Inclusion of this header file by both amd64.c and amd64x86.c ensures that
// a PAGE_TABLE is the same size for both platforms.
//

C_ASSERT( sizeof(PAGE_TABLE) == PAGE_SIZE );

//
// 64-bit GDT entry
//

typedef struct _GDT_64 *PGDT_64;

//
// We keep some information for each AMD64 mapping level
//

typedef struct _AMD64_MAPPING_LEVEL {
    ULONGLONG RecursiveMappingBase;
    ULONG AddressMask;
    ULONG AddressShift;
} CONST AMD64_MAPPING_INFO, *PAMD64_MAPPING_INFO;

//
// Routines and data found in amd64.c and referenced in amd64x86.c
//

#define AMD64_MAPPING_LEVELS 4
extern AMD64_MAPPING_INFO BlAmd64MappingLevels[ AMD64_MAPPING_LEVELS ];

extern const ULONG BlAmd64DoubleFaultStackSize;
#define DOUBLE_FAULT_STACK_SIZE_64 BlAmd64DoubleFaultStackSize

extern const ULONG BlAmd64KernelStackSize;
#define KERNEL_STACK_SIZE_64 BlAmd64KernelStackSize

extern const ULONG BlAmd64McaExceptionStackSize;
#define MCA_EXCEPTION_STACK_SIZE_64 BlAmd64McaExceptionStackSize

extern const ULONG BlAmd64GdtSize;
#define GDT_64_SIZE BlAmd64GdtSize

extern const ULONG BlAmd64IdtSize;
#define IDT_64_SIZE BlAmd64IdtSize

extern const ULONG BlAmd64_TSS_IST_PANIC;
#define TSS64_IST_PANIC BlAmd64_TSS_IST_PANIC

extern const ULONG BlAmd64_TSS_IST_MCA;
#define TSS64_IST_MCA BlAmd64_TSS_IST_MCA

extern const ULONG64 BlAmd64UserSharedData;
#define KI_USER_SHARED_DATA_64 BlAmd64UserSharedData

VOID
BlAmd64ClearTopLevelPte(
    VOID
    );

VOID
BlAmd64BuildAmd64GDT(
    IN PVOID SysTss,
    OUT PVOID Gdt
    );

VOID
BlAmd64BuildGdtEntry(
    IN PGDT_64 Gdt,
    IN USHORT Selector,
    IN POINTER64 Base,
    IN ULONGLONG Limit,
    IN ULONG Type,
    IN ULONG Dpl,
    IN BOOLEAN LongMode,
    IN BOOLEAN DefaultBig
    );

ARC_STATUS
BlAmd64CreateMapping(
    IN ULONGLONG Va,
    IN ULONGLONG Pfn
    );

ARC_STATUS
BlAmd64MapHalVaSpace(
    VOID
    );

//
// Routines and data found in amd64x86.c and referenced in amd64.c
//

PAMD64_PAGE_TABLE
BlAmd64AllocatePageTable(
    VOID
    );

VOID
BlAmd64InitializePageTable(
    IN PPAGE_TABLE PageTable
    );

ARC_STATUS
BlAmd64PrepForTransferToKernelPhase1(
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    );

VOID
BlAmd64PrepForTransferToKernelPhase2(
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    );


ARC_STATUS
BlAmd64TransferToKernel(
    IN PTRANSFER_ROUTINE SystemEntry,
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    );

//
// Routines and data found in amd64s.asm and referenced elsewhere
//

BOOLEAN
BlIsAmd64Supported (
    VOID
    );

//
// Shared data
//

#endif  // _AMD64PRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\amd64\amd64s.asm ===
;++
;
;Copyright (c) 2000  Microsoft Corporation
;
;Module Name:
;
;    amd64s.asm
;
;Abstract:
;
;    Contains routines to aid in detecting and enabling Amd64 long mode.
;
;Author:
;
;    Forrest Foltz (forrestf) 04-20-00
;
;
;Revision History:
;
;--


.586p
        .xlist
include ks386.inc
        .list

	extrn   _BlAmd64GdtDescriptor:QWORD
	extrn   _BlAmd64IdtDescriptor:QWORD
	extrn   _BlAmd64IdleStack64:QWORD
	extrn   _BlAmd64TopLevelPte:QWORD
	extrn   _BlAmd64KernelEntry:QWORD
	extrn   _BlAmd64LoaderParameterBlock:QWORD
	extrn   _BlAmd64_MSR_EFER:DWORD
	extrn   _BlAmd64_MSR_EFER_Flags:DWORD
	extrn	_BlAmd64_MSR_GS_BASE:DWORD
	extrn   _BlAmd64_KGDT64_SYS_TSS:WORD
	extrn   _BlAmd32GdtDescriptor:QWORD

OP64    macro
        db      048h
endm

;
; LOADREG loads the 64-bit contents of a memory location specified by
; a 32-bit immediate address.
;
; The resultant 64-bit address is zero-extended, as a result this macro
; only works with addresses < 2^32.
;
; This macro also assumes that esi is zero.
;

LDREG64 macro reg, address
        OP64
	mov     reg, ds:[esi + offset address]
endm


_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

EFLAGS_ID	equ 	200000h

;++
;
; BOOLEAN
; BlIsAmd64Supported (
;     VOID
; )
;
; Routine Description:
;
;      This rouine determines whether the current processor supports AMD64
;      mode, a.k.a. "long mode".
;
;   Arguments:
;
;      None.
;
;   Return value:
;
;      0 if long mode is not supported, non-zero otherwise.
;
;--

public _BlIsAmd64Supported@0
_BlIsAmd64Supported@0 proc

	;
	; First determine whether the CPUID instruction is supported.  If
	; the EFLAGS_ID bit "sticks" when popped into the flags
	; register then the CPUID instruction is available.
	;

	mov	ecx, EFLAGS_ID
	pushfd
	pop	eax		; eax == flags
	xor	ecx, eax	; ecx == flags ^ EFLAGS_ID
	push	ecx
	popfd			; load new flags
	pushfd
	pop	ecx		; ecx == result of flag load
	xor	eax, ecx	; Q: did the EFLAGS_ID bit stick?
	jz	done            ; N: CPUID is not available

	;
	; We can use the CPUID instruction.  Detect whether this is an
	; AMD processor and if so whether long mode is supported.
	;

	push	ebx		; CPUID steps on eax, ebx, ecx, edx
	xor     eax, eax        ; eax = 0
	cpuid
	xor	eax, eax        ; Assume no long mode
	cmp     ebx, 'htuA'     ; Q: ebx == 'Auth' ?
	jne     nolong          ; N: no long mode

	;
	; We have an AMD processor, now determine whether long mode is
	; available.
	;

	mov     eax, 80000001h
	xor	edx, edx
	cpuid
	bt      edx, 29         ; Q: Bit 29 is long mode bit, is it set?
	sbb	eax, eax       	; Yes (eax != 0) if carry set, else eax == 0
nolong: pop	ebx
done:   ret

_BlIsAmd64Supported@0 endp

;++
;
; VOID
; BlAmd64SwitchToLongMode (
;     VOID
; )
;
; Routine Description:
;
;  Arguments:
;
;   None.
;
;  Return value:
;
;   None.
;
;--

public _BlAmd64SwitchToLongMode@0
_BlAmd64SwitchToLongMode@0 proc

        cli

	;
	; Disable paging
	;

	mov	eax, cr0
	and     eax, NOT CR0_PG
	mov     cr0, eax
	jmp     $+2

	;
	; Enable XMM and physical address extensions (paging still off)
	;

	mov     eax, cr4
	or      eax, CR4_PAE OR CR4_FXSR OR CR4_XMMEXCPT
	mov     cr4, eax

	;
	; Reference the four-level paging structure.  This must exist
	; below 4G physical (in fact it is somewhere in the low 32MB)
        ;

        mov     eax, DWORD PTR [_BlAmd64TopLevelPte]
        and     eax, 0FFFFF000h
	mov     cr3, eax

	;
	; Set Long Mode enable and enable syscall
	;

	mov     ecx, [_BlAmd64_MSR_EFER]
	rdmsr
	or      eax, [_BlAmd64_MSR_EFER_Flags]
	wrmsr

	;
	; Turn paging on
	;

	mov     eax, cr0
	or      eax, CR0_PG
	mov     cr0, eax
	jmp     $+2

	;
	; Load the new global descriptor table.  Note that because we're
	; not in long mode (current code selector indicates compatibility
	; mode), only a 32-bit base is loaded here.
	;

        lgdt    fword ptr _BlAmd32GdtDescriptor 

	;
	; Far jump to the 64-bit code segment.
	;

	db	0eah
	dd	start64

	;
	; The following selector is set in amd64.c, BlAmd64BuildAmd64GDT, and
	; is included as part of the far jump instruction.
	; 

	public _BlAmd64_KGDT64_R0_CODE
_BlAmd64_KGDT64_R0_CODE:
	dw	?

start64:

	;
	; Zero rsi so that the LDREG64 macros work
	; 

	OP64
	sub	esi, esi

        ;
	; Running in long mode now.  Execute another lgdt, this one
	; referencing the 64-bit mapping of the gdt.
	;
	; Note that an esi-relative address is used to avoid RIP-relative
	; addressing.
	;

	lgdt	fword ptr ds:[esi + offset _BlAmd64GdtDescriptor]

	;
	; Load the new interrupt descriptor table
	;

	lidt    fword ptr ds:[esi + offset _BlAmd64IdtDescriptor]

        ;
	; Switch stacks to the 64-bit idle stack
	;

	LDREG64 esp, _BlAmd64IdleStack64
				   
	;
	; Set the current TSS
	;

        LDREG64 eax, _BlAmd64_KGDT64_SYS_TSS
	ltr     ax

	;
	; Set ss to the kernel-mode SS value (0)
	;

	sub	eax, eax
	mov	ss, ax

	;
	; Allocate space on the stack for a parameter target area and jump
	; to the kernel entrypoint.
	;

	OP64
	sub	esp, 16

	LDREG64 ecx, _BlAmd64LoaderParameterBlock
	LDREG64 eax, _BlAmd64KernelEntry

	call    eax


_BlAmd64SwitchToLongMode@0 endp

_TEXT	ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\axp64\initmap.c ===
/*++

Module Name:

    intimap.c

Abstract:

    This module initializes the system process mapping for a 64-bit Alpha
    system.

Author:

    David N. Cutler (davec) 5-Jan-1998

Environment:

    Kernel mode only.

Revision History:

--*/

#include "bldr.h"
#include "arc.h"

//
// Define size of page map.
//

#define PD_INDEX(va) (((va) >> PDI2_SHIFT) & PDI_MASK)

#define PAGE_MAP_SIZE (PD_INDEX(KSEG2_BASE) - PD_INDEX(KSEG0_BASE))

ARC_STATUS
BlInitializeSystemProcessMap (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function initializes the system process map for 64-bit Alpha
    systems.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block.

Return Value:

    None.

--*/

{

    ULONG Base;
    ULONG Count;
    PMEMORY_ALLOCATION_DESCRIPTOR Descriptor;
    ULONG Index;
    PLIST_ENTRY ListHead;
    UCHAR PageMap[PAGE_MAP_SIZE];
    PLIST_ENTRY NextEntry;
    ULONG Number;
    PHARDWARE_PTE Pdr1;
    PHARDWARE_PTE Pdr2;
    PHARDWARE_PTE Ptp;
    ULONG PdrPage;
    ARC_STATUS Status;
    ULONG Total;

    //
    // On 64-bit Alpha systems a three level mapping structure is used
    // and up to 1gb of physical memory is identity mapped into KSEG0
    // for PAL code access.
    //
    // One page is required for the first level page directory.
    //
    // One page is required for the kernel second level page directory.
    //
    // One page is required for each page table page in the identify map.
    //
    // One page is required for the page table page to map the shared page.
    //
    // One page is required for the shared page.
    //
    // Locate all pages in the first 1gb of physical memory and record
    // page table page usage.
    //

    RtlZeroMemory(&PageMap[0], PAGE_MAP_SIZE);
    ListHead = &LoaderBlock->MemoryDescriptorListHead;
    NextEntry = ListHead->Flink;
    do {
        Descriptor = CONTAINING_RECORD(NextEntry,
                                       MEMORY_ALLOCATION_DESCRIPTOR,
                                       ListEntry);

        Number = Descriptor->BasePage;
        for (Count = 0; Count < Descriptor->PageCount; Count += 1) {
            Index = Number >> (PDI2_SHIFT - PTI_SHIFT);
            if (Index < PAGE_MAP_SIZE) {
                PageMap[Index] = 1;
            }

            Number += 1;
        }

        NextEntry = NextEntry->Flink;
    } while (NextEntry != ListHead);

    //
    // Compute the number of page table pages required to map the first
    // 1gb of physical memory.
    //

    Total = 4;
    for (Count = 0; Count < PAGE_MAP_SIZE; Count += 1) {
        Total += PageMap[Count];
    }

    //
    // Allocate a level 1 page directory page, a level 2 page directory
    // page, a shared page table page, a shared data page, and the required
    // number of pages to map up to 1gb of physical
    // memory.
    //

    Status = BlAllocateAnyMemory(LoaderStartupPdrPage,
                                 0,
                                 Total,
                                 &LoaderBlock->u.Alpha.PdrPage);

    if (Status != ESUCCESS) {
        return Status;
    }

    //
    // Self map the level 1 directory into the level 1 directory, map the
    // level 2 kernel page directory page into the level 1 page directory
    // page, map the shared data page table page, and map all the
    // page table pages into the level 2 page directory page so the first 1gb
    // of physical memory can be accessed via KSEG0.
    //
    // Compute the address of the level one page directory page and zero
    // the page.
    //

    PdrPage = LoaderBlock->u.Alpha.PdrPage;
    Pdr1 = (PHARDWARE_PTE)(KSEG0_BASE | (PdrPage << PAGE_SHIFT));
    RtlZeroMemory(Pdr1, PAGE_SIZE);

    //
    // Map the level one page directory identity entry in the level one
    // page directory page.
    //

    Index = (PDE_BASE >> PDI1_SHIFT) & PDI_MASK;
    Pdr1[Index].Valid = 1;
    Pdr1[Index].KernelReadAccess = 1;
    Pdr1[Index].KernelWriteAccess = 1;
    Pdr1[Index].Write = 1;
    Pdr1[Index].PageFrameNumber = PdrPage++;

    //
    // Map the level two kernel page directory page entry in the level one
    // page directory page.
    //

    Index = (KSEG0_BASE >> PDI1_SHIFT) & PDI_MASK;
    Pdr1[Index].Valid = 1;
    Pdr1[Index].KernelReadAccess = 1;
    Pdr1[Index].KernelWriteAccess = 1;
    Pdr1[Index].Write = 1;
    Pdr1[Index].PageFrameNumber = PdrPage;

    //
    // Compute the address of the level two kernel page directory page and
    // zero the page.
    //

    Pdr2 = (PHARDWARE_PTE)(KSEG0_BASE | (PdrPage++ << PAGE_SHIFT));
    RtlZeroMemory(Pdr2, PAGE_SIZE);

    //
    // Map the shared data page table page in the level two kernel page
    // directory page.
    //

    Index = (KI_USER_SHARED_DATA >> PDI2_SHIFT) & PDI_MASK;
    Pdr2[Index].Valid = 1;
    Pdr2[Index].Global = 1;
    Pdr2[Index].KernelReadAccess = 1;
    Pdr2[Index].KernelWriteAccess = 1;
    Pdr2[Index].Write = 1;
    Pdr2[Index].PageFrameNumber = PdrPage;

    //
    // Compute the address of the shared data page table page and zero
    // the page.
    //

    Ptp = (PHARDWARE_PTE)(KSEG0_BASE | (PdrPage++ << PAGE_SHIFT));
    RtlZeroMemory(Ptp, PAGE_SIZE);

    //
    // Map the shared data page in the shared data page table page.
    //

    Index = (KI_USER_SHARED_DATA >> PTI_SHIFT) & PDI_MASK;
    Ptp[Index].Valid = 1;
    Ptp[Index].Global = 1;
    Ptp[Index].KernelReadAccess = 1;
    Ptp[Index].KernelWriteAccess = 1;
    Ptp[Index].Write = 1;
    Ptp[Index].PageFrameNumber = PdrPage;

    //
    // Compute the address of the shared data page and zero the page.
    //

    Ptp = (PHARDWARE_PTE)(KSEG0_BASE | (PdrPage++ << PAGE_SHIFT));
    RtlZeroMemory(Ptp, PAGE_SIZE);

    //
    // Construct the identity map for the first 1gb of physical memory.
    //

    Base = (KSEG0_BASE >> PDI2_SHIFT) & PDI_MASK;
    for (Count = 0; Count < PAGE_MAP_SIZE; Count += 1) {
        if (PageMap[Count] != 0) {
            Pdr2[Base | Count].Valid = 1;
            Pdr2[Base | Count].Global = 1;
            Pdr2[Base | Count].KernelReadAccess = 1;
            Pdr2[Base | Count].KernelWriteAccess = 1;
            Pdr2[Base | Count].Write = 1;
            Pdr2[Base | Count].PageFrameNumber = PdrPage;
            Ptp = (PHARDWARE_PTE)(KSEG0_BASE | (PdrPage << PAGE_SHIFT));
            RtlZeroMemory(Ptp, PAGE_SIZE);
            PdrPage += 1;
        }
    }

    //
    // Identity map the first 1gb of physical memory into KSEG0.
    //

    ListHead = &LoaderBlock->MemoryDescriptorListHead;
    NextEntry = ListHead->Flink;
    do {
        Descriptor = CONTAINING_RECORD(NextEntry,
                                       MEMORY_ALLOCATION_DESCRIPTOR,
                                       ListEntry);

        Number = Descriptor->BasePage;
        for (Count = 0; Count < Descriptor->PageCount; Count += 1) {
            Index = Number >> (PDI2_SHIFT - PTI_SHIFT);
            if (Index < PAGE_MAP_SIZE) {
                Ptp = (PHARDWARE_PTE)(KSEG0_BASE | (Pdr2[Base | Index].PageFrameNumber << PAGE_SHIFT));
                Index = Number & PDI_MASK;
                Ptp[Index].Valid = 1;
                Ptp[Index].Global = 1;
                Ptp[Index].KernelReadAccess = 1;
                Ptp[Index].KernelWriteAccess = 1;
                Ptp[Index].Write = 1;
                Ptp[Index].PageFrameNumber = Number;
            }

            Number += 1;
        }

        NextEntry = NextEntry->Flink;
    } while (NextEntry != ListHead);

    //
    // Set the granularity hint bits.
    //

    BlSetGranularityHints(Pdr1, Total);
    return ESUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\amd64\amd64x86.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    amd64x86.c

Abstract:

    This module contains routines necessary to support loading and
    transitioning into an AMD64 kernel.  The code in this module has
    access to x86-specific defines found in i386.h but not to amd64-
    specific declarations found in amd64.h.

Author:

    Forrest Foltz (forrestf) 20-Apr-2000

Environment:


Revision History:

--*/

#include "amd64prv.h"
#include <pcmp.inc>
#include <ntapic.inc>

#if defined(ROUND_UP)
#undef ROUND_UP
#endif

#include "cmp.h"

#define WANT_BLDRTHNK_FUNCTIONS
#define COPYBUF_MALLOC BlAllocateHeap
#include <amd64thk.h>

#define IMAGE_DEFINITIONS 0
#include <ximagdef.h>

//
// Private, tempory memory descriptor type
//

#define LoaderAmd64MemoryData (LoaderMaximum + 10)

//
// Array of 64-bit memory descriptors
//

PMEMORY_ALLOCATION_DESCRIPTOR_64 BlAmd64DescriptorArray;
LONG BlAmd64DescriptorArraySize;

//
// Forward declarations for functions local to this module
//

ARC_STATUS
BlAmd64AllocateMemoryAllocationDescriptors(
    VOID
    );

ARC_STATUS
BlAmd64BuildLdrDataTableEntry64(
    IN  PLDR_DATA_TABLE_ENTRY     DataTableEntry32,
    OUT PLDR_DATA_TABLE_ENTRY_64 *DataTableEntry64
    );

ARC_STATUS
BlAmd64BuildLoaderBlock64(
    VOID
    );

ARC_STATUS
BlAmd64BuildLoaderBlockExtension64(
    VOID
    );

ARC_STATUS
BlAmd64BuildMappingPhase1(
    VOID
    );

ARC_STATUS
BlAmd64BuildMappingPhase2(
    VOID
    );

ARC_STATUS
BlAmd64BuildMappingWorker(
    VOID
    );

BOOLEAN
BlAmd64ContainsResourceList(
    IN PCONFIGURATION_COMPONENT_DATA ComponentData32,
    OUT PULONG ResourceListSize64
    );

BOOLEAN
BlAmd64IsPageMapped(
    IN ULONG Va,
    OUT PFN_NUMBER *Pfn,
    OUT PBOOLEAN PageTableMapped
    );

ARC_STATUS
BlAmd64PrepareSystemStructures(
    VOID
    );

VOID
BlAmd64ReplaceMemoryDescriptorType(
    IN TYPE_OF_MEMORY Target,
    IN TYPE_OF_MEMORY Replacement,
    IN BOOLEAN Coallesce
    );

VOID
BlAmd64ResetPageTableHeap(
    VOID
    );

VOID
BlAmd64SwitchToLongMode(
    VOID
    );

ARC_STATUS
BlAmd64TransferArcDiskInformation(
    VOID
    );

ARC_STATUS
BlAmd64TransferBootDriverNodes(
    VOID
    );

ARC_STATUS
BlAmd64TransferConfigurationComponentData(
    VOID
    );

PCONFIGURATION_COMPONENT_DATA_64
BlAmd64TransferConfigWorker(
    IN PCONFIGURATION_COMPONENT_DATA    ComponentData32,
    IN PCONFIGURATION_COMPONENT_DATA_64 ComponentDataParent64
    );

ARC_STATUS
BlAmd64TransferHardwareIdList(
    IN  PPNP_HARDWARE_ID HardwareId,
    OUT POINTER64 *HardwareIdDatabaseList64
    );

ARC_STATUS
BlAmd64TransferLoadedModuleState(
    VOID
    );

ARC_STATUS
BlAmd64TransferMemoryAllocationDescriptors(
    VOID
    );

ARC_STATUS
BlAmd64TransferNlsData(
    VOID
    );

VOID
BlAmd64TransferResourceList(
    IN  PCONFIGURATION_COMPONENT_DATA ComponentData32,
    OUT PCONFIGURATION_COMPONENT_DATA_64 ComponentData64
    );

ARC_STATUS
BlAmd64TransferSetupLoaderBlock(
    VOID
    );


#if DBG

PCHAR BlAmd64MemoryDescriptorText[] = {
    "LoaderExceptionBlock",
    "LoaderSystemBlock",
    "LoaderFree",
    "LoaderBad",
    "LoaderLoadedProgram",
    "LoaderFirmwareTemporary",
    "LoaderFirmwarePermanent",
    "LoaderOsloaderHeap",
    "LoaderOsloaderStack",
    "LoaderSystemCode",
    "LoaderHalCode",
    "LoaderBootDriver",
    "LoaderConsoleInDriver",
    "LoaderConsoleOutDriver",
    "LoaderStartupDpcStack",
    "LoaderStartupKernelStack",
    "LoaderStartupPanicStack",
    "LoaderStartupPcrPage",
    "LoaderStartupPdrPage",
    "LoaderRegistryData",
    "LoaderMemoryData",
    "LoaderNlsData",
    "LoaderSpecialMemory",
    "LoaderBBTMemory",
    "LoaderReserve"
};

#endif


VOID
NSUnmapFreeDescriptors(
    IN PLIST_ENTRY ListHead
    );

//
// Data declarations
//

PLOADER_PARAMETER_BLOCK    BlAmd64LoaderBlock32;
PLOADER_PARAMETER_BLOCK_64 BlAmd64LoaderBlock64;


//
// Pointer to the top of the 64-bit stack frame to use upon transition
// to long mode.
//

POINTER64 BlAmd64IdleStack64;

//
// GDT and IDT pseudo-descriptor for use with LGDT/LIDT
//

DESCRIPTOR_TABLE_DESCRIPTOR BlAmd64GdtDescriptor;
DESCRIPTOR_TABLE_DESCRIPTOR BlAmd64IdtDescriptor;
DESCRIPTOR_TABLE_DESCRIPTOR BlAmd32GdtDescriptor;

//
// 64-bit pointers to the KPCR, loader parameter block and kernel
// entry routine
//

POINTER64 BlAmd64LoaderParameterBlock;
POINTER64 BlAmd64KernelEntry;

//
// A private list of page tables used to build the long mode paging
// structures is kept.  This is in order to avoid memory allocations while
// the structures are being assembled.
//
// The PT_NODE type as well as the BlAmd64FreePfnList and BlAmd64BusyPfnList
// globals are used to that end.
// 

typedef struct _PT_NODE *PPT_NODE;
typedef struct _PT_NODE {
    PPT_NODE Next;
    PAMD64_PAGE_TABLE PageTable;
} PT_NODE;

PPT_NODE BlAmd64FreePfnList = NULL;
PPT_NODE BlAmd64BusyPfnList = NULL;

//
// External data
//

extern ULONG64 BlAmd64_LOCALAPIC;

ARC_STATUS
BlAmd64MapMemoryRegion(
    IN ULONG RegionVa,
    IN ULONG RegionSize
    )

/*++

Routine Description:

    This function creates long mode mappings for all valid x86 mappings
    within the region described by RegionVa and RegionSize.

Arguments:

    RegionVa - Supplies the starting address of the VA region.

    RegionSize - Supplies the size of the VA region.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    ULONG va32;
    ULONG va32End;
    POINTER64 va64;
    ARC_STATUS status;
    PFN_NUMBER pfn;
    BOOLEAN pageMapped;
    BOOLEAN pageTableMapped;
    ULONG increment;

    va32 = RegionVa;
    va32End = va32 + RegionSize;
    while (va32 < va32End) {

        pageMapped = BlAmd64IsPageMapped( va32, &pfn, &pageTableMapped );
        if (pageTableMapped != FALSE) {

            //
            // The page table corresponding to this address is present.
            // 

            if (pageMapped != FALSE) {

                //
                // The page corresponding to this address is present.
                // 

                if ((va32 & KSEG0_BASE_X86) != 0) {

                    //
                    // The address lies within the X86 KSEG0 region.  Map
                    // it to the corresponding address within the AMD64
                    // KSEG0 region.
                    //

                    va64 = PTR_64( (PVOID)va32 );

                } else {

                    //
                    // Map the VA directly.
                    //

                    va64 = (POINTER64)va32;
                }

                //
                // Now create the mapping in the AMD64 page table structure.
                // 
    
                status = BlAmd64CreateMapping( va64, pfn );
                if (status != ESUCCESS) {
                    return status;
                }
            }

            //
            // Check the next page.
            //

            increment = PAGE_SIZE;

        } else {

            //
            // Not only is the page not mapped but neither is the page table.
            // Skip to the next page table address boundary.
            //

            increment = 1 << PDI_SHIFT;
        }

        //
        // Advance to the next VA to check, checking for overflow.
        //

        va32 = (va32 + increment) & ~(increment - 1);
        if (va32 == 0) {
            break;
        }
    }

    return ESUCCESS;
}

BOOLEAN
BlAmd64IsPageMapped(
    IN ULONG Va,
    OUT PFN_NUMBER *Pfn,
    OUT PBOOLEAN PageTableMapped
    )

/*++          

Routine Description:

    This function accepts a 32-bit virtual address, determines whether it
    is a valid address, and if so returns the Pfn associated with it.

    Addresses that are within the recursive mapping are treated as NOT
    mapped.

Arguments:

    None.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    ULONG pdeIndex;
    ULONG pteIndex;
    PHARDWARE_PTE pde;
    PHARDWARE_PTE pte;
    BOOLEAN dummy;
    PBOOLEAN pageTableMapped;

    //
    // Point the output parameter pointer as appropriate.
    // 

    if (ARGUMENT_PRESENT(PageTableMapped)) {
        pageTableMapped = PageTableMapped;
    } else {
        pageTableMapped = &dummy;
    }

    //
    // Pages that are a part of the X86 32-bit mapping structure ARE
    // IGNORED.
    //

    if (Va >= PTE_BASE && Va <= PTE_TOP) {
        *pageTableMapped = TRUE;
        return FALSE;
    }

    //
    // Determine whether the mapping PDE is present
    //

    pdeIndex = Va >> PDI_SHIFT;
    pde = &((PHARDWARE_PTE)PDE_BASE)[ pdeIndex ];

    if (pde->Valid == 0) {
        *pageTableMapped = FALSE;
        return FALSE;
    }

    //
    // Indicate that the page table for this address is mapped.
    //

    *pageTableMapped = TRUE;

    //
    // It is, now get the page present status
    // 

    pteIndex = Va >> PTI_SHIFT;
    pte = &((PHARDWARE_PTE)PTE_BASE)[ pteIndex ];

    if (pte->Valid == 0) {
        return FALSE;
    }

    *Pfn = pte->PageFrameNumber;
    return TRUE;
}


PAMD64_PAGE_TABLE
BlAmd64AllocatePageTable(
    VOID
    )

/*++

Routine Description:

    This function allocates and initializes a PAGE_TABLE structure.

Arguments:

    None.

Return Value:

    Returns a pointer to the allocated page table structure, or NULL
    if the allocation failed.

--*/

{
    ARC_STATUS status;
    ULONG descriptor;
    PPT_NODE ptNode;
    PAMD64_PAGE_TABLE pageTable;

    //
    // Pull a page table off of the free list, if one exists
    // 

    ptNode = BlAmd64FreePfnList;
    if (ptNode != NULL) {

        BlAmd64FreePfnList = ptNode->Next;

    } else {

        //
        // The free page table list is empty, allocate a new
        // page table and node to track it with.
        //

        status = BlAllocateDescriptor( LoaderAmd64MemoryData,
                                       0,
                                       1,
                                       &descriptor );
        if (status != ESUCCESS) {
            return NULL;
        }
    
        ptNode = BlAllocateHeap( sizeof(PT_NODE) );
        if (ptNode == NULL) {
            return NULL;
        }

        ptNode->PageTable = (PAMD64_PAGE_TABLE)(descriptor << PAGE_SHIFT);
    }

    ptNode->Next = BlAmd64BusyPfnList;
    BlAmd64BusyPfnList = ptNode;

    pageTable = ptNode->PageTable;
    RtlZeroMemory( pageTable, PAGE_SIZE );

    return pageTable;
}

ARC_STATUS
BlAmd64Tr